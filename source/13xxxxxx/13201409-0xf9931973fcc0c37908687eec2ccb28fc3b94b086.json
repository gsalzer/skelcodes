{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\n// Sources flattened with hardhat v2.6.4 https://hardhat.org\r\n\r\n// File contracts/Math/SafeMath.sol\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Frax/IFrax.sol\r\n\r\n\r\ninterface IFrax {\r\n  function COLLATERAL_RATIO_PAUSER() external view returns (bytes32);\r\n  function DEFAULT_ADMIN_ADDRESS() external view returns (address);\r\n  function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\r\n  function addPool(address pool_address ) external;\r\n  function allowance(address owner, address spender ) external view returns (uint256);\r\n  function approve(address spender, uint256 amount ) external returns (bool);\r\n  function balanceOf(address account ) external view returns (uint256);\r\n  function burn(uint256 amount ) external;\r\n  function burnFrom(address account, uint256 amount ) external;\r\n  function collateral_ratio_paused() external view returns (bool);\r\n  function controller_address() external view returns (address);\r\n  function creator_address() external view returns (address);\r\n  function decimals() external view returns (uint8);\r\n  function decreaseAllowance(address spender, uint256 subtractedValue ) external returns (bool);\r\n  function eth_usd_consumer_address() external view returns (address);\r\n  function eth_usd_price() external view returns (uint256);\r\n  function frax_eth_oracle_address() external view returns (address);\r\n  function frax_info() external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256);\r\n  function frax_pools(address ) external view returns (bool);\r\n  function frax_pools_array(uint256 ) external view returns (address);\r\n  function frax_price() external view returns (uint256);\r\n  function frax_step() external view returns (uint256);\r\n  function fxs_address() external view returns (address);\r\n  function fxs_eth_oracle_address() external view returns (address);\r\n  function fxs_price() external view returns (uint256);\r\n  function genesis_supply() external view returns (uint256);\r\n  function getRoleAdmin(bytes32 role ) external view returns (bytes32);\r\n  function getRoleMember(bytes32 role, uint256 index ) external view returns (address);\r\n  function getRoleMemberCount(bytes32 role ) external view returns (uint256);\r\n  function globalCollateralValue() external view returns (uint256);\r\n  function global_collateral_ratio() external view returns (uint256);\r\n  function grantRole(bytes32 role, address account ) external;\r\n  function hasRole(bytes32 role, address account ) external view returns (bool);\r\n  function increaseAllowance(address spender, uint256 addedValue ) external returns (bool);\r\n  function last_call_time() external view returns (uint256);\r\n  function minting_fee() external view returns (uint256);\r\n  function name() external view returns (string memory);\r\n  function owner_address() external view returns (address);\r\n  function pool_burn_from(address b_address, uint256 b_amount ) external;\r\n  function pool_mint(address m_address, uint256 m_amount ) external;\r\n  function price_band() external view returns (uint256);\r\n  function price_target() external view returns (uint256);\r\n  function redemption_fee() external view returns (uint256);\r\n  function refreshCollateralRatio() external;\r\n  function refresh_cooldown() external view returns (uint256);\r\n  function removePool(address pool_address ) external;\r\n  function renounceRole(bytes32 role, address account ) external;\r\n  function revokeRole(bytes32 role, address account ) external;\r\n  function setController(address _controller_address ) external;\r\n  function setETHUSDOracle(address _eth_usd_consumer_address ) external;\r\n  function setFRAXEthOracle(address _frax_oracle_addr, address _weth_address ) external;\r\n  function setFXSAddress(address _fxs_address ) external;\r\n  function setFXSEthOracle(address _fxs_oracle_addr, address _weth_address ) external;\r\n  function setFraxStep(uint256 _new_step ) external;\r\n  function setMintingFee(uint256 min_fee ) external;\r\n  function setOwner(address _owner_address ) external;\r\n  function setPriceBand(uint256 _price_band ) external;\r\n  function setPriceTarget(uint256 _new_price_target ) external;\r\n  function setRedemptionFee(uint256 red_fee ) external;\r\n  function setRefreshCooldown(uint256 _new_cooldown ) external;\r\n  function setTimelock(address new_timelock ) external;\r\n  function symbol() external view returns (string memory);\r\n  function timelock_address() external view returns (address);\r\n  function toggleCollateralRatio() external;\r\n  function totalSupply() external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount ) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n  function weth_address() external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/FXS/IFxs.sol\r\n\r\n\r\ninterface IFxs {\r\n  function DEFAULT_ADMIN_ROLE() external view returns(bytes32);\r\n  function FRAXStablecoinAdd() external view returns(address);\r\n  function FXS_DAO_min() external view returns(uint256);\r\n  function allowance(address owner, address spender) external view returns(uint256);\r\n  function approve(address spender, uint256 amount) external returns(bool);\r\n  function balanceOf(address account) external view returns(uint256);\r\n  function burn(uint256 amount) external;\r\n  function burnFrom(address account, uint256 amount) external;\r\n  function checkpoints(address, uint32) external view returns(uint32 fromBlock, uint96 votes);\r\n  function decimals() external view returns(uint8);\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns(bool);\r\n  function genesis_supply() external view returns(uint256);\r\n  function getCurrentVotes(address account) external view returns(uint96);\r\n  function getPriorVotes(address account, uint256 blockNumber) external view returns(uint96);\r\n  function getRoleAdmin(bytes32 role) external view returns(bytes32);\r\n  function getRoleMember(bytes32 role, uint256 index) external view returns(address);\r\n  function getRoleMemberCount(bytes32 role) external view returns(uint256);\r\n  function grantRole(bytes32 role, address account) external;\r\n  function hasRole(bytes32 role, address account) external view returns(bool);\r\n  function increaseAllowance(address spender, uint256 addedValue) external returns(bool);\r\n  function mint(address to, uint256 amount) external;\r\n  function name() external view returns(string memory);\r\n  function numCheckpoints(address) external view returns(uint32);\r\n  function oracle_address() external view returns(address);\r\n  function owner_address() external view returns(address);\r\n  function pool_burn_from(address b_address, uint256 b_amount) external;\r\n  function pool_mint(address m_address, uint256 m_amount) external;\r\n  function renounceRole(bytes32 role, address account) external;\r\n  function revokeRole(bytes32 role, address account) external;\r\n  function setFRAXAddress(address frax_contract_address) external;\r\n  function setFXSMinDAO(uint256 min_FXS) external;\r\n  function setOracle(address new_oracle) external;\r\n  function setOwner(address _owner_address) external;\r\n  function setTimelock(address new_timelock) external;\r\n  function symbol() external view returns(string memory);\r\n  function timelock_address() external view returns(address);\r\n  function toggleVotes() external;\r\n  function totalSupply() external view returns(uint256);\r\n  function trackingVotes() external view returns(bool);\r\n  function transfer(address recipient, uint256 amount) external returns(bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\r\n}\r\n\r\n\r\n// File contracts/Uniswap/TransferHelper.sol\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Staking/Owned.sol\r\n\r\n\r\n// https://docs.synthetix.io/contracts/Owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor (address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\n// File contracts/Oracle/AggregatorV3Interface.sol\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\n// File contracts/Frax/IFraxAMOMinter.sol\r\n\r\n\r\ninterface IFraxAMOMinter {\r\n  function FRAX() external view returns(address);\r\n  function FXS() external view returns(address);\r\n  function acceptOwnership() external;\r\n  function addAMO(address amo_address, bool sync_too) external;\r\n  function allAMOAddresses() external view returns(address[] memory);\r\n  function allAMOsLength() external view returns(uint256);\r\n  function amoProfit(address amo_address) external view returns(int256);\r\n  function amos(address) external view returns(bool);\r\n  function amos_array(uint256) external view returns(address);\r\n  function burnFXS(uint256 amount) external;\r\n  function burnFraxFromAMO(uint256 frax_amount) external;\r\n  function burnFxsFromAMO(uint256 fxs_amount) external;\r\n  function col_idx() external view returns(uint256);\r\n  function collatDollarBalance() external view returns(uint256);\r\n  function collatDollarBalanceStored() external view returns(uint256);\r\n  function collat_borrow_cap() external view returns(int256);\r\n  function collat_borrowed_balances(address) external view returns(int256);\r\n  function collat_borrowed_sum() external view returns(int256);\r\n  function collateral_address() external view returns(address);\r\n  function collateral_token() external view returns(address);\r\n  function custodian_address() external view returns(address);\r\n  function fraxDollarBalanceStored() external view returns(uint256);\r\n  function giveCollatToAMO(address destination_amo, uint256 collat_amount) external;\r\n  function min_cr() external view returns(uint256);\r\n  function mintFraxForAMO(address destination_amo, uint256 frax_amount) external;\r\n  function mint_balances(address) external view returns(int256);\r\n  function mint_cap() external view returns(int256);\r\n  function mint_sum() external view returns(int256);\r\n  function missing_decimals() external view returns(uint256);\r\n  function nominateNewOwner(address _owner) external;\r\n  function nominatedOwner() external view returns(address);\r\n  function override_collat_balance() external view returns(bool);\r\n  function override_collat_balance_amount() external view returns(uint256);\r\n  function owner() external view returns(address);\r\n  function pool() external view returns(address);\r\n  function receiveCollatFromAMO(uint256 usdc_amount) external;\r\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external;\r\n  function removeAMO(address amo_address, bool sync_too) external;\r\n  function setCustodian(address _custodian_address) external;\r\n  function setFraxPool(address _pool_address) external;\r\n  function setMinimumCollateralRatio(uint256 _min_cr) external;\r\n  function setMintCap(uint256 _mint_cap) external;\r\n  function setOverrideCollatBalance(bool _state, uint256 _balance) external;\r\n  function setTimelock(address new_timelock) external;\r\n  function syncDollarBalances() external;\r\n  function timelock_address() external view returns(address);\r\n  function unspentProfitGlobal() external view returns(int256);\r\n}\r\n\r\n\r\n// File contracts/Common/Context.sol\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/ERC20/IERC20.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/Utils/Address.sol\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/ERC20/ERC20.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\n \r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory __name, string memory __symbol) public {\r\n        _name = __name;\r\n        _symbol = __symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for `accounts`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\r\n\r\n        _approve(account, _msgSender(), decreasedAllowance);\r\n        _burn(account, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal virtual {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\r\n// File contracts/Frax/Pools/FraxPoolV3.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ============================ FraxPoolV3 ============================\r\n// ====================================================================\r\n// Allows multiple stablecoins (fixed amount at initialization) as collateral\r\n// LUSD, sUSD, USDP, Wrapped UST, and FEI initially\r\n// For this pool, the goal is to accept crypto-backed / overcollateralized stablecoins to limit\r\n// government / regulatory risk (e.g. USDC blacklisting until holders KYC)\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Jason Huan: https://github.com/jasonhuan\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Dennis: github.com/denett\r\n// Hameed\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FraxPoolV3 is Owned {\r\n    using SafeMath for uint256;\r\n    // SafeMath automatically included in Solidity >= 8.0.0\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    // Core\r\n    address public timelock_address;\r\n    address public custodian_address; // Custodian is an EOA (or msig) with pausing privileges only, in case of an emergency\r\n    IFrax private FRAX = IFrax(0x853d955aCEf822Db058eb8505911ED77F175b99e);\r\n    IFxs private FXS = IFxs(0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0);\r\n    mapping(address => bool) public amo_minter_addresses; // minter address -> is it enabled\r\n    AggregatorV3Interface public priceFeedFRAXUSD = AggregatorV3Interface(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD);\r\n    AggregatorV3Interface public priceFeedFXSUSD = AggregatorV3Interface(0x6Ebc52C8C1089be9eB3945C4350B68B8E4C2233f);\r\n    uint256 private chainlink_frax_usd_decimals;\r\n    uint256 private chainlink_fxs_usd_decimals;\r\n\r\n    // Collateral\r\n    address[] public collateral_addresses;\r\n    string[] public collateral_symbols;\r\n    uint256[] public missing_decimals; // Number of decimals needed to get to E18. collateral index -> missing_decimals\r\n    uint256[] public pool_ceilings; // Total across all collaterals. Accounts for missing_decimals\r\n    uint256[] public collateral_prices; // Stores price of the collateral, if price is paused\r\n    mapping(address => uint256) public collateralAddrToIdx; // collateral addr -> collateral index\r\n    mapping(address => bool) public enabled_collaterals; // collateral address -> is it enabled\r\n    \r\n    // Redeem related\r\n    mapping (address => uint256) public redeemFXSBalances;\r\n    mapping (address => mapping(uint256 => uint256)) public redeemCollateralBalances; // Address -> collateral index -> balance\r\n    uint256[] public unclaimedPoolCollateral; // collateral index -> balance\r\n    uint256 public unclaimedPoolFXS;\r\n    mapping (address => uint256) public lastRedeemed; // Collateral independent\r\n    uint256 public redemption_delay = 2; // Number of blocks to wait before being able to collectRedemption()\r\n    uint256 public redeem_price_threshold = 990000; // $0.99\r\n    uint256 public mint_price_threshold = 1010000; // $1.01\r\n    \r\n    // Buyback related\r\n    mapping(uint256 => uint256) public bbkHourlyCum; // Epoch hour ->  Collat out in that hour (E18)\r\n    uint256 public bbkMaxColE18OutPerHour = 1000e18;\r\n\r\n    // Recollat related\r\n    mapping(uint256 => uint256) public rctHourlyCum; // Epoch hour ->  FXS out in that hour\r\n    uint256 public rctMaxFxsOutPerHour = 1000e18;\r\n\r\n    // Fees and rates\r\n    // getters are in collateral_information()\r\n    uint256[] private minting_fee;\r\n    uint256[] private redemption_fee;\r\n    uint256[] private buyback_fee;\r\n    uint256[] private recollat_fee;\r\n    uint256 public bonus_rate; // Bonus rate on FXS minted during recollateralize(); 6 decimals of precision, set to 0.75% on genesis\r\n    \r\n    // Constants for various precisions\r\n    uint256 private constant PRICE_PRECISION = 1e6;\r\n\r\n    // Pause variables\r\n    // getters are in collateral_information()\r\n    bool[] private mintPaused; // Collateral-specific\r\n    bool[] private redeemPaused; // Collateral-specific\r\n    bool[] private recollateralizePaused; // Collateral-specific\r\n    bool[] private buyBackPaused; // Collateral-specific\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyByOwnGov() {\r\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyByOwnGovCust() {\r\n        require(msg.sender == timelock_address || msg.sender == owner || msg.sender == custodian_address, \"Not owner, tlck, or custd\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAMOMinters() {\r\n        require(amo_minter_addresses[msg.sender], \"Not an AMO Minter\");\r\n        _;\r\n    }\r\n\r\n    modifier collateralEnabled(uint256 col_idx) {\r\n        require(enabled_collaterals[collateral_addresses[col_idx]], \"Collateral disabled\");\r\n        _;\r\n    }\r\n \r\n    /* ========== CONSTRUCTOR ========== */\r\n    \r\n    constructor (\r\n        address _pool_manager_address,\r\n        address _custodian_address,\r\n        address _timelock_address,\r\n        address[] memory _collateral_addresses,\r\n        uint256[] memory _pool_ceilings,\r\n        uint256[] memory _initial_fees\r\n    ) Owned(_pool_manager_address){\r\n        // Core\r\n        timelock_address = _timelock_address;\r\n        custodian_address = _custodian_address;\r\n\r\n        // Fill collateral info\r\n        collateral_addresses = _collateral_addresses;\r\n        for (uint256 i = 0; i < _collateral_addresses.length; i++){ \r\n            // For fast collateral address -> collateral idx lookups later\r\n            collateralAddrToIdx[_collateral_addresses[i]] = i;\r\n\r\n            // Set all of the collaterals initially to disabled\r\n            enabled_collaterals[_collateral_addresses[i]] = false;\r\n\r\n            // Add in the missing decimals\r\n            missing_decimals.push(uint256(18).sub(ERC20(_collateral_addresses[i]).decimals()));\r\n\r\n            // Add in the collateral symbols\r\n            collateral_symbols.push(ERC20(_collateral_addresses[i]).symbol());\r\n\r\n            // Initialize unclaimed pool collateral\r\n            unclaimedPoolCollateral.push(0);\r\n\r\n            // Initialize paused prices to $1 as a backup\r\n            collateral_prices.push(PRICE_PRECISION);\r\n\r\n            // Handle the fees\r\n            minting_fee.push(_initial_fees[0]);\r\n            redemption_fee.push(_initial_fees[1]);\r\n            buyback_fee.push(_initial_fees[2]);\r\n            recollat_fee.push(_initial_fees[3]);\r\n\r\n            // Handle the pauses\r\n            mintPaused.push(false);\r\n            redeemPaused.push(false);\r\n            recollateralizePaused.push(false);\r\n            buyBackPaused.push(false);\r\n        }\r\n\r\n        // Pool ceiling\r\n        pool_ceilings = _pool_ceilings;\r\n\r\n        // Set the decimals\r\n        chainlink_frax_usd_decimals = priceFeedFRAXUSD.decimals();\r\n        chainlink_fxs_usd_decimals = priceFeedFXSUSD.decimals();\r\n    }\r\n\r\n    /* ========== STRUCTS ========== */\r\n    \r\n    struct CollateralInformation {\r\n        uint256 index;\r\n        string symbol;\r\n        address col_addr;\r\n        bool is_enabled;\r\n        uint256 missing_decs;\r\n        uint256 price;\r\n        uint256 pool_ceiling;\r\n        bool mint_paused;\r\n        bool redeem_paused;\r\n        bool recollat_paused;\r\n        bool buyback_paused;\r\n        uint256 minting_fee;\r\n        uint256 redemption_fee;\r\n        uint256 buyback_fee;\r\n        uint256 recollat_fee;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    // Helpful for UIs\r\n    function collateral_information(address collat_address) external view returns (CollateralInformation memory return_data){\r\n        require(enabled_collaterals[collat_address], \"Invalid collateral\");\r\n\r\n        // Get the index\r\n        uint256 idx = collateralAddrToIdx[collat_address];\r\n        \r\n        return_data = CollateralInformation(\r\n            idx, // [0]\r\n            collateral_symbols[idx], // [1]\r\n            collat_address, // [2]\r\n            enabled_collaterals[collat_address], // [3]\r\n            missing_decimals[idx], // [4]\r\n            collateral_prices[idx], // [5]\r\n            pool_ceilings[idx], // [6]\r\n            mintPaused[idx], // [7]\r\n            redeemPaused[idx], // [8]\r\n            recollateralizePaused[idx], // [9]\r\n            buyBackPaused[idx], // [10]\r\n            minting_fee[idx], // [11]\r\n            redemption_fee[idx], // [12]\r\n            buyback_fee[idx], // [13]\r\n            recollat_fee[idx] // [14]\r\n        );\r\n    }\r\n\r\n    function allCollaterals() external view returns (address[] memory) {\r\n        return collateral_addresses;\r\n    }\r\n\r\n    function getFRAXPrice() public view returns (uint256) {\r\n        ( , int price, , , ) = priceFeedFRAXUSD.latestRoundData();\r\n        return uint256(price).mul(PRICE_PRECISION).div(10 ** chainlink_frax_usd_decimals);\r\n    }\r\n\r\n    function getFXSPrice() public view returns (uint256) {\r\n        ( , int price, , , ) = priceFeedFXSUSD.latestRoundData();\r\n        return uint256(price).mul(PRICE_PRECISION).div(10 ** chainlink_fxs_usd_decimals);\r\n    }\r\n\r\n    // Returns the FRAX value in collateral tokens\r\n    function getFRAXInCollateral(uint256 col_idx, uint256 frax_amount) public view returns (uint256) {\r\n        return frax_amount.mul(PRICE_PRECISION).div(10 ** missing_decimals[col_idx]).div(collateral_prices[col_idx]);\r\n    }\r\n\r\n    // Used by some functions.\r\n    function freeCollatBalance(uint256 col_idx) public view returns (uint256) {\r\n        return ERC20(collateral_addresses[col_idx]).balanceOf(address(this)).sub(unclaimedPoolCollateral[col_idx]);\r\n    }\r\n\r\n    // Returns dollar value of collateral held in this Frax pool, in E18\r\n    function collatDollarBalance() external view returns (uint256 balance_tally) {\r\n        balance_tally = 0;\r\n\r\n        // Test 1\r\n        for (uint256 i = 0; i < collateral_addresses.length; i++){ \r\n            balance_tally += freeCollatBalance(i).mul(10 ** missing_decimals[i]).mul(collateral_prices[i]).div(PRICE_PRECISION);\r\n        }\r\n\r\n    }\r\n\r\n    function comboCalcBbkRct(uint256 cur, uint256 max, uint256 theo) internal pure returns (uint256) {\r\n        if (cur >= max) {\r\n            // If the hourly limit has already been reached, return 0;\r\n            return 0;\r\n        }\r\n        else {\r\n            // Get the available amount\r\n            uint256 available = max.sub(cur);\r\n\r\n            if (theo >= available) {\r\n                // If the the theoretical is more than the available, return the available\r\n                return available;\r\n            }\r\n            else {\r\n                // Otherwise, return the theoretical amount\r\n                return theo;\r\n            }\r\n        } \r\n    }\r\n\r\n    // Returns the value of excess collateral (in E18) held globally, compared to what is needed to maintain the global collateral ratio\r\n    // Also has throttling to avoid dumps during large price movements\r\n    function buybackAvailableCollat() public view returns (uint256) {\r\n        uint256 total_supply = FRAX.totalSupply();\r\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\r\n        uint256 global_collat_value = FRAX.globalCollateralValue();\r\n\r\n        if (global_collateral_ratio > PRICE_PRECISION) global_collateral_ratio = PRICE_PRECISION; // Handles an overcollateralized contract with CR > 1\r\n        uint256 required_collat_dollar_value_d18 = (total_supply.mul(global_collateral_ratio)).div(PRICE_PRECISION); // Calculates collateral needed to back each 1 FRAX with $1 of collateral at current collat ratio\r\n        \r\n        if (global_collat_value > required_collat_dollar_value_d18) {\r\n            // Get the theoretical buyback amount\r\n            uint256 theoretical_bbk_amt = global_collat_value.sub(required_collat_dollar_value_d18);\r\n\r\n            // See how much has collateral has been issued this hour\r\n            uint256 current_hr_bbk = bbkHourlyCum[curEpochHr()];\r\n\r\n            // Account for the throttling\r\n            return comboCalcBbkRct(current_hr_bbk, bbkMaxColE18OutPerHour, theoretical_bbk_amt);\r\n        }\r\n        else return 0;\r\n    }\r\n\r\n    // Returns the missing amount of collateral (in E18) needed to maintain the collateral ratio\r\n    function recollatTheoColAvailableE18() public view returns (uint256) {\r\n        uint256 frax_total_supply = FRAX.totalSupply();\r\n        uint256 effective_collateral_ratio = FRAX.globalCollateralValue().mul(PRICE_PRECISION).div(frax_total_supply); // Returns it in 1e6\r\n        \r\n        uint256 desired_collat_e24 = (FRAX.global_collateral_ratio()).mul(frax_total_supply);\r\n        uint256 effective_collat_e24 = effective_collateral_ratio.mul(frax_total_supply);\r\n\r\n        // Return 0 if already overcollateralized\r\n        // Otherwise, return the deficiency\r\n        if (effective_collat_e24 >= desired_collat_e24) return 0;\r\n        else {\r\n            return (desired_collat_e24.sub(effective_collat_e24)).div(PRICE_PRECISION);\r\n        }\r\n    }\r\n\r\n    // Returns the value of FXS available to be used for recollats\r\n    // Also has throttling to avoid dumps during large price movements\r\n    function recollatAvailableFxs() public view returns (uint256) {\r\n        uint256 fxs_price = getFXSPrice();\r\n\r\n        // Get the amount of collateral theoretically available\r\n        uint256 recollat_theo_available_e18 = recollatTheoColAvailableE18();\r\n\r\n        // Get the amount of FXS theoretically outputtable\r\n        uint256 fxs_theo_out = recollat_theo_available_e18.mul(PRICE_PRECISION).div(fxs_price);\r\n\r\n        // See how much FXS has been issued this hour\r\n        uint256 current_hr_rct = rctHourlyCum[curEpochHr()];\r\n\r\n        // Account for the throttling\r\n        return comboCalcBbkRct(current_hr_rct, rctMaxFxsOutPerHour, fxs_theo_out);\r\n    }\r\n\r\n    // Returns the current epoch hour\r\n    function curEpochHr() public view returns (uint256) {\r\n        return (block.timestamp / 3600); // Truncation desired\r\n    }\r\n\r\n    /* ========== PUBLIC FUNCTIONS ========== */\r\n\r\n     function mintFrax(\r\n        uint256 col_idx, \r\n        uint256 frax_amt,\r\n        uint256 frax_out_min,\r\n        bool one_to_one_override\r\n    ) external collateralEnabled(col_idx) returns (\r\n        uint256 total_frax_mint, \r\n        uint256 collat_needed, \r\n        uint256 fxs_needed\r\n    ) {\r\n        require(mintPaused[col_idx] == false, \"Minting is paused\");\r\n\r\n        // Prevent unneccessary mints\r\n        require(getFRAXPrice() >= mint_price_threshold, \"Frax price too low\");\r\n\r\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\r\n\r\n        if (one_to_one_override || global_collateral_ratio >= PRICE_PRECISION) { \r\n            // 1-to-1, overcollateralized, or user selects override\r\n            collat_needed = getFRAXInCollateral(col_idx, frax_amt);\r\n            fxs_needed = 0;\r\n        } else if (global_collateral_ratio == 0) { \r\n            // Algorithmic\r\n            collat_needed = 0;\r\n            fxs_needed = frax_amt.mul(PRICE_PRECISION).div(getFXSPrice());\r\n        } else { \r\n            // Fractional\r\n            uint256 frax_for_collat = frax_amt.mul(global_collateral_ratio).div(PRICE_PRECISION);\r\n            uint256 frax_for_fxs = frax_amt.sub(frax_for_collat);\r\n            collat_needed = getFRAXInCollateral(col_idx, frax_for_collat);\r\n            fxs_needed = frax_for_fxs.mul(PRICE_PRECISION).div(getFXSPrice());\r\n        }\r\n\r\n        // Subtract the minting fee\r\n        total_frax_mint = (frax_amt.mul(PRICE_PRECISION.sub(minting_fee[col_idx]))).div(PRICE_PRECISION);\r\n\r\n        // Checks\r\n        require((frax_out_min <= total_frax_mint), \"FRAX slippage\");\r\n        require(freeCollatBalance(col_idx).add(collat_needed) <= pool_ceilings[col_idx], \"Pool ceiling\");\r\n\r\n        // Take the FXS and collateral first\r\n        FXS.pool_burn_from(msg.sender, fxs_needed);\r\n        TransferHelper.safeTransferFrom(collateral_addresses[col_idx], msg.sender, address(this), collat_needed);\r\n\r\n        // Mint the FRAX\r\n        FRAX.pool_mint(msg.sender, total_frax_mint);\r\n    }\r\n\r\n    function redeemFrax(\r\n        uint256 col_idx, \r\n        uint256 frax_amount, \r\n        uint256 fxs_out_min, \r\n        uint256 col_out_min\r\n    ) external collateralEnabled(col_idx) returns (\r\n        uint256 collat_out, \r\n        uint256 fxs_out\r\n    ) {\r\n        require(redeemPaused[col_idx] == false, \"Redeeming is paused\");\r\n\r\n        // Prevent unneccessary redemptions that could adversely affect the FXS price\r\n        require(getFRAXPrice() <= redeem_price_threshold, \"Frax price too high\");\r\n\r\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\r\n        uint256 frax_after_fee = (frax_amount.mul(PRICE_PRECISION.sub(redemption_fee[col_idx]))).div(PRICE_PRECISION);\r\n\r\n        // Assumes $1 FRAX in all cases\r\n        if(global_collateral_ratio >= PRICE_PRECISION) { \r\n            // 1-to-1 or overcollateralized\r\n            collat_out = frax_after_fee\r\n                            .mul(collateral_prices[col_idx])\r\n                            .div(10 ** (6 + missing_decimals[col_idx])); // PRICE_PRECISION + missing decimals\r\n            fxs_out = 0;\r\n        } else if (global_collateral_ratio == 0) { \r\n            // Algorithmic\r\n            fxs_out = frax_after_fee\r\n                            .mul(PRICE_PRECISION)\r\n                            .div(getFXSPrice());\r\n            collat_out = 0;\r\n        } else { \r\n            // Fractional\r\n            collat_out = frax_after_fee\r\n                            .mul(global_collateral_ratio)\r\n                            .mul(collateral_prices[col_idx])\r\n                            .div(10 ** (12 + missing_decimals[col_idx])); // PRICE_PRECISION ^2 + missing decimals\r\n            fxs_out = frax_after_fee\r\n                            .mul(PRICE_PRECISION.sub(global_collateral_ratio))\r\n                            .div(getFXSPrice()); // PRICE_PRECISIONS CANCEL OUT\r\n        }\r\n\r\n        // Checks\r\n        require(collat_out <= (ERC20(collateral_addresses[col_idx])).balanceOf(address(this)).sub(unclaimedPoolCollateral[col_idx]), \"Insufficient pool collateral\");\r\n        require(collat_out >= col_out_min, \"Collateral slippage\");\r\n        require(fxs_out >= fxs_out_min, \"FXS slippage\");\r\n\r\n        // Account for the redeem delay\r\n        redeemCollateralBalances[msg.sender][col_idx] = redeemCollateralBalances[msg.sender][col_idx].add(collat_out);\r\n        unclaimedPoolCollateral[col_idx] = unclaimedPoolCollateral[col_idx].add(collat_out);\r\n\r\n        redeemFXSBalances[msg.sender] = redeemFXSBalances[msg.sender].add(fxs_out);\r\n        unclaimedPoolFXS = unclaimedPoolFXS.add(fxs_out);\r\n\r\n        lastRedeemed[msg.sender] = block.number;\r\n\r\n        FRAX.pool_burn_from(msg.sender, frax_amount);\r\n        FXS.pool_mint(address(this), fxs_out);\r\n    }\r\n\r\n    // After a redemption happens, transfer the newly minted FXS and owed collateral from this pool\r\n    // contract to the user. Redemption is split into two functions to prevent flash loans from being able\r\n    // to take out FRAX/collateral from the system, use an AMM to trade the new price, and then mint back into the system.\r\n    function collectRedemption(uint256 col_idx) external returns (uint256 fxs_amount, uint256 collateral_amount) {\r\n        require(redeemPaused[col_idx] == false, \"Redeeming is paused\");\r\n        require((lastRedeemed[msg.sender].add(redemption_delay)) <= block.number, \"Too soon\");\r\n        bool sendFXS = false;\r\n        bool sendCollateral = false;\r\n\r\n        // Use Checks-Effects-Interactions pattern\r\n        if(redeemFXSBalances[msg.sender] > 0){\r\n            fxs_amount = redeemFXSBalances[msg.sender];\r\n            redeemFXSBalances[msg.sender] = 0;\r\n            unclaimedPoolFXS = unclaimedPoolFXS.sub(fxs_amount);\r\n            sendFXS = true;\r\n        }\r\n        \r\n        if(redeemCollateralBalances[msg.sender][col_idx] > 0){\r\n            collateral_amount = redeemCollateralBalances[msg.sender][col_idx];\r\n            redeemCollateralBalances[msg.sender][col_idx] = 0;\r\n            unclaimedPoolCollateral[col_idx] = unclaimedPoolCollateral[col_idx].sub(collateral_amount);\r\n            sendCollateral = true;\r\n        }\r\n\r\n        // Send out the tokens\r\n        if(sendFXS){\r\n            TransferHelper.safeTransfer(address(FXS), msg.sender, fxs_amount);\r\n        }\r\n        if(sendCollateral){\r\n            TransferHelper.safeTransfer(collateral_addresses[col_idx], msg.sender, collateral_amount);\r\n        }\r\n    }\r\n\r\n    // Function can be called by an FXS holder to have the protocol buy back FXS with excess collateral value from a desired collateral pool\r\n    // This can also happen if the collateral ratio > 1\r\n    function buyBackFxs(uint256 col_idx, uint256 fxs_amount, uint256 col_out_min) external collateralEnabled(col_idx) returns (uint256 col_out) {\r\n        require(buyBackPaused[col_idx] == false, \"Buyback is paused\");\r\n        uint256 fxs_price = getFXSPrice();\r\n        uint256 available_excess_collat_dv = buybackAvailableCollat();\r\n\r\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible FXS with the desired collateral\r\n        require(available_excess_collat_dv > 0, \"Insuf Collat Avail For BBK\");\r\n\r\n        // Make sure not to take more than is available\r\n        uint256 fxs_dollar_value_d18 = fxs_amount.mul(fxs_price).div(PRICE_PRECISION);\r\n        require(fxs_dollar_value_d18 <= available_excess_collat_dv, \"Insuf Collat Avail For BBK\");\r\n\r\n        // Get the equivalent amount of collateral based on the market value of FXS provided \r\n        uint256 collateral_equivalent_d18 = fxs_dollar_value_d18.mul(PRICE_PRECISION).div(collateral_prices[col_idx]);\r\n        col_out = collateral_equivalent_d18.div(10 ** missing_decimals[col_idx]); // In its natural decimals()\r\n\r\n        // Subtract the buyback fee\r\n        col_out = (col_out.mul(PRICE_PRECISION.sub(buyback_fee[col_idx]))).div(PRICE_PRECISION);\r\n\r\n        // Check for slippage\r\n        require(col_out >= col_out_min, \"Collateral slippage\");\r\n\r\n        // Take in and burn the FXS, then send out the collateral\r\n        FXS.pool_burn_from(msg.sender, fxs_amount);\r\n        TransferHelper.safeTransfer(collateral_addresses[col_idx], msg.sender, col_out);\r\n\r\n        // Increment the outbound collateral, in E18, for that hour\r\n        // Used for buyback throttling\r\n        bbkHourlyCum[curEpochHr()] += collateral_equivalent_d18;\r\n    }\r\n\r\n    // When the protocol is recollateralizing, we need to give a discount of FXS to hit the new CR target\r\n    // Thus, if the target collateral ratio is higher than the actual value of collateral, minters get FXS for adding collateral\r\n    // This function simply rewards anyone that sends collateral to a pool with the same amount of FXS + the bonus rate\r\n    // Anyone can call this function to recollateralize the protocol and take the extra FXS value from the bonus rate as an arb opportunity\r\n    function recollateralize(uint256 col_idx, uint256 collateral_amount, uint256 fxs_out_min) external collateralEnabled(col_idx) returns (uint256 fxs_out) {\r\n        require(recollateralizePaused[col_idx] == false, \"Recollat is paused\");\r\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals[col_idx]);\r\n        uint256 fxs_price = getFXSPrice();\r\n\r\n        // Get the amount of FXS actually available (accounts for throttling)\r\n        uint256 fxs_actually_available = recollatAvailableFxs();\r\n\r\n        // Calculated the attempted amount of FXS\r\n        fxs_out = collateral_amount_d18.mul(PRICE_PRECISION.add(bonus_rate).sub(recollat_fee[col_idx])).div(fxs_price);\r\n\r\n        // Make sure there is FXS available\r\n        require(fxs_out <= fxs_actually_available, \"Insuf FXS Avail For RCT\");\r\n\r\n        // Check slippage\r\n        require(fxs_out >= fxs_out_min, \"FXS slippage\");\r\n\r\n        // Don't take in more collateral than the pool ceiling for this token allows\r\n        require(freeCollatBalance(col_idx).add(collateral_amount) <= pool_ceilings[col_idx], \"Pool ceiling\");\r\n\r\n        // Take in the collateral and pay out the FXS\r\n        TransferHelper.safeTransferFrom(collateral_addresses[col_idx], msg.sender, address(this), collateral_amount);\r\n        FXS.pool_mint(msg.sender, fxs_out);\r\n\r\n        // Increment the outbound FXS, in E18\r\n        // Used for recollat throttling\r\n        rctHourlyCum[curEpochHr()] += fxs_out;\r\n    }\r\n\r\n    // Bypasses the gassy mint->redeem cycle for AMOs to borrow collateral\r\n    function amoMinterBorrow(uint256 collateral_amount) external onlyAMOMinters {\r\n        // Checks the col_idx of the minter as an additional safety check\r\n        uint256 minter_col_idx = IFraxAMOMinter(msg.sender).col_idx();\r\n\r\n        // Transfer\r\n        TransferHelper.safeTransfer(collateral_addresses[minter_col_idx], msg.sender, collateral_amount);\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS, CUSTODIAN CAN CALL TOO ========== */\r\n\r\n    function toggleMRBR(uint256 col_idx, uint8 tog_idx) external onlyByOwnGovCust {\r\n        if (tog_idx == 0) mintPaused[col_idx] = !mintPaused[col_idx];\r\n        else if (tog_idx == 1) redeemPaused[col_idx] = !redeemPaused[col_idx];\r\n        else if (tog_idx == 2) buyBackPaused[col_idx] = !buyBackPaused[col_idx];\r\n        else if (tog_idx == 3) recollateralizePaused[col_idx] = !recollateralizePaused[col_idx];\r\n\r\n        emit MRBRToggled(col_idx, tog_idx);\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS, GOVERNANCE ONLY ========== */\r\n\r\n    // Add an AMO Minter\r\n    function addAMOMinter(address amo_minter_addr) external onlyByOwnGov {\r\n        require(amo_minter_addr != address(0), \"Zero address detected\");\r\n\r\n        // Make sure the AMO Minter has collatDollarBalance()\r\n        uint256 collat_val_e18 = IFraxAMOMinter(amo_minter_addr).collatDollarBalance();\r\n        require(collat_val_e18 >= 0, \"Invalid AMO\");\r\n\r\n        amo_minter_addresses[amo_minter_addr] = true;\r\n\r\n        emit AMOMinterAdded(amo_minter_addr);\r\n    }\r\n\r\n    // Remove an AMO Minter \r\n    function removeAMOMinter(address amo_minter_addr) external onlyByOwnGov {\r\n        amo_minter_addresses[amo_minter_addr] = false;\r\n        \r\n        emit AMOMinterRemoved(amo_minter_addr);\r\n    }\r\n\r\n    function setCollateralPrice(uint256 col_idx, uint256 _new_price) external onlyByOwnGov {\r\n        collateral_prices[col_idx] = _new_price;\r\n\r\n        emit CollateralPriceSet(col_idx, _new_price);\r\n    }\r\n\r\n    // Could also be called toggleCollateral\r\n    function toggleCollateral(uint256 col_idx) external onlyByOwnGov {\r\n        address col_address = collateral_addresses[col_idx];\r\n        enabled_collaterals[col_address] = !enabled_collaterals[col_address];\r\n\r\n        emit CollateralToggled(col_idx, enabled_collaterals[col_address]);\r\n    }\r\n\r\n    function setPoolCeiling(uint256 col_idx, uint256 new_ceiling) external onlyByOwnGov {\r\n        pool_ceilings[col_idx] = new_ceiling;\r\n\r\n        emit PoolCeilingSet(col_idx, new_ceiling);\r\n    }\r\n\r\n    function setFees(uint256 col_idx, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external onlyByOwnGov {\r\n        minting_fee[col_idx] = new_mint_fee;\r\n        redemption_fee[col_idx] = new_redeem_fee;\r\n        buyback_fee[col_idx] = new_buyback_fee;\r\n        recollat_fee[col_idx] = new_recollat_fee;\r\n\r\n        emit FeesSet(col_idx, new_mint_fee, new_redeem_fee, new_buyback_fee, new_recollat_fee);\r\n    }\r\n\r\n    function setPoolParameters(uint256 new_bonus_rate, uint256 new_redemption_delay) external onlyByOwnGov {\r\n        bonus_rate = new_bonus_rate;\r\n        redemption_delay = new_redemption_delay;\r\n        emit PoolParametersSet(new_bonus_rate, new_redemption_delay);\r\n    }\r\n\r\n    function setPriceThresholds(uint256 new_mint_price_threshold, uint256 new_redeem_price_threshold) external onlyByOwnGov {\r\n        mint_price_threshold = new_mint_price_threshold;\r\n        redeem_price_threshold = new_redeem_price_threshold;\r\n        emit PriceThresholdsSet(new_mint_price_threshold, new_redeem_price_threshold);\r\n    }\r\n\r\n    function setBbkRctPerHour(uint256 _bbkMaxColE18OutPerHour, uint256 _rctMaxFxsOutPerHour) external onlyByOwnGov {\r\n        bbkMaxColE18OutPerHour = _bbkMaxColE18OutPerHour;\r\n        rctMaxFxsOutPerHour = _rctMaxFxsOutPerHour;\r\n        emit BbkRctPerHourSet(_bbkMaxColE18OutPerHour, _rctMaxFxsOutPerHour);\r\n    }\r\n\r\n    // Set the Chainlink oracles\r\n    function setOracles(address _frax_usd_chainlink_addr, address _fxs_usd_chainlink_addr) external onlyByOwnGov {\r\n        // Set the instances\r\n        priceFeedFRAXUSD = AggregatorV3Interface(_frax_usd_chainlink_addr);\r\n        priceFeedFXSUSD = AggregatorV3Interface(_fxs_usd_chainlink_addr);\r\n\r\n        // Set the decimals\r\n        chainlink_frax_usd_decimals = priceFeedFRAXUSD.decimals();\r\n        chainlink_fxs_usd_decimals = priceFeedFXSUSD.decimals();\r\n        \r\n        emit OraclesSet(_frax_usd_chainlink_addr, _fxs_usd_chainlink_addr);\r\n    }\r\n\r\n    function setCustodian(address new_custodian) external onlyByOwnGov {\r\n        custodian_address = new_custodian;\r\n\r\n        emit CustodianSet(new_custodian);\r\n    }\r\n\r\n    function setTimelock(address new_timelock) external onlyByOwnGov {\r\n        timelock_address = new_timelock;\r\n\r\n        emit TimelockSet(new_timelock);\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n    event CollateralToggled(uint256 col_idx, bool new_state);\r\n    event PoolCeilingSet(uint256 col_idx, uint256 new_ceiling);\r\n    event FeesSet(uint256 col_idx, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee);\r\n    event PoolParametersSet(uint256 new_bonus_rate, uint256 new_redemption_delay);\r\n    event PriceThresholdsSet(uint256 new_bonus_rate, uint256 new_redemption_delay);\r\n    event BbkRctPerHourSet(uint256 bbkMaxColE18OutPerHour, uint256 rctMaxFxsOutPerHour);\r\n    event AMOMinterAdded(address amo_minter_addr);\r\n    event AMOMinterRemoved(address amo_minter_addr);\r\n    event OraclesSet(address frax_usd_chainlink_addr, address fxs_usd_chainlink_addr);\r\n    event CustodianSet(address new_custodian);\r\n    event TimelockSet(address new_timelock);\r\n    event MRBRToggled(uint256 col_idx, uint8 tog_idx);\r\n    event CollateralPriceSet(uint256 col_idx, uint256 new_price);\r\n}\r\n\r\n\r\n// File contracts/Frax/Pools/IFraxPool.sol\r\n\r\n\r\ninterface IFraxPool {\r\n    function minting_fee() external returns (uint256);\r\n    function redemption_fee() external returns (uint256);\r\n    function buyback_fee() external returns (uint256);\r\n    function recollat_fee() external returns (uint256);\r\n    function collatDollarBalance() external returns (uint256);\r\n    function availableExcessCollatDV() external returns (uint256);\r\n    function getCollateralPrice() external returns (uint256);\r\n    function setCollatETHOracle(address _collateral_weth_oracle_address, address _weth_address) external;\r\n    function mint1t1FRAX(uint256 collateral_amount, uint256 FRAX_out_min) external;\r\n    function mintAlgorithmicFRAX(uint256 fxs_amount_d18, uint256 FRAX_out_min) external;\r\n    function mintFractionalFRAX(uint256 collateral_amount, uint256 fxs_amount, uint256 FRAX_out_min) external;\r\n    function redeem1t1FRAX(uint256 FRAX_amount, uint256 COLLATERAL_out_min) external;\r\n    function redeemFractionalFRAX(uint256 FRAX_amount, uint256 FXS_out_min, uint256 COLLATERAL_out_min) external;\r\n    function redeemAlgorithmicFRAX(uint256 FRAX_amount, uint256 FXS_out_min) external;\r\n    function collectRedemption() external;\r\n    function recollateralizeFRAX(uint256 collateral_amount, uint256 FXS_out_min) external;\r\n    function buyBackFXS(uint256 FXS_amount, uint256 COLLATERAL_out_min) external;\r\n    function toggleMinting() external;\r\n    function toggleRedeeming() external;\r\n    function toggleRecollateralize() external;\r\n    function toggleBuyBack() external;\r\n    function toggleCollateralPrice(uint256 _new_price) external;\r\n    function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external;\r\n    function setTimelock(address new_timelock) external;\r\n    function setOwner(address _owner_address) external;\r\n}\r\n\r\n\r\n// File contracts/Misc_AMOs/IAMO.sol\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IAMO {\r\n    function dollarBalances() external view returns (uint256 frax_val_e18, uint256 collat_val_e18);\r\n}\r\n\r\n\r\n// File contracts/Frax/FraxAMOMinter.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// =========================== FraxAMOMinter ==========================\r\n// ====================================================================\r\n// globalCollateralValue() in Frax.sol is gassy because of the loop and all of the AMOs attached to it. \r\n// This minter would be single mint point for all of the AMOs, and would track the collatDollarBalance with a\r\n// state variable after any mint occurs, or manually with a sync() call\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Jason Huan: https://github.com/jasonhuan\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Dennis: github.com/denett\r\n// Hameed\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FraxAMOMinter is Owned {\r\n    // SafeMath automatically included in Solidity >= 8.0.0\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    // Core\r\n    IFrax public FRAX = IFrax(0x853d955aCEf822Db058eb8505911ED77F175b99e);\r\n    IFxs public FXS = IFxs(0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0);\r\n    ERC20 public collateral_token;\r\n    FraxPoolV3 public pool = FraxPoolV3(0x2fE065e6FFEf9ac95ab39E5042744d695F560729);\r\n    IFraxPool public old_pool = IFraxPool(0x1864Ca3d47AaB98Ee78D11fc9DCC5E7bADdA1c0d);\r\n    address public timelock_address;\r\n    address public custodian_address;\r\n\r\n    // Collateral related\r\n    address public collateral_address;\r\n    uint256 public col_idx;\r\n\r\n    // AMO addresses\r\n    address[] public amos_array;\r\n    mapping(address => bool) public amos; // Mapping is also used for faster verification\r\n\r\n    // Price constants\r\n    uint256 private constant PRICE_PRECISION = 1e6;\r\n\r\n    // Max amount of collateral the contract can borrow from the FraxPool\r\n    int256 public collat_borrow_cap = int256(10000000e6);\r\n\r\n    // Max amount of FRAX this contract can mint\r\n    int256 public mint_cap = int256(100000000e18);\r\n\r\n    // Minimum collateral ratio needed for new FRAX minting\r\n    uint256 public min_cr = 810000;\r\n\r\n    // Mint balances\r\n    mapping(address => int256) public mint_balances; // Amount of FRAX the contract minted, by AMO\r\n    int256 public mint_sum = 0; // Across all AMOs\r\n\r\n    // Collateral borrowed balances\r\n    mapping(address => int256) public collat_borrowed_balances; // Amount of collateral the contract borrowed, by AMO\r\n    int256 public collat_borrowed_sum = 0; // Across all AMOs\r\n\r\n    // Frax balance related\r\n    uint256 public fraxDollarBalanceStored = 0;\r\n\r\n    // Collateral balance related\r\n    uint256 public missing_decimals;\r\n    uint256 public collatDollarBalanceStored = 0;\r\n    bool public override_collat_balance;\r\n    uint256 public override_collat_balance_amount;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n    \r\n    constructor (\r\n        address _owner_address,\r\n        address _custodian_address,\r\n        address _timelock_address,\r\n        address _collateral_address,\r\n        address _pool_address\r\n    ) Owned(_owner_address) {\r\n        custodian_address = _custodian_address;\r\n        timelock_address = _timelock_address;\r\n\r\n        // Pool related\r\n        pool = FraxPoolV3(_pool_address);\r\n\r\n        // Collateral related\r\n        collateral_address = _collateral_address;\r\n        col_idx = pool.collateralAddrToIdx(_collateral_address);\r\n        collateral_token = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n        missing_decimals = uint(18) - collateral_token.decimals();\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyByOwnGov() {\r\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\r\n        _;\r\n    }\r\n\r\n    modifier validAMO(address amo_address) {\r\n        require(amos[amo_address], \"Invalid AMO\");\r\n        _;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    // Needed for the Frax contract to function \r\n    function collatDollarBalance() external view returns (uint256) {\r\n        // Needs to mimic the FraxPool value and return in E18\r\n        // Override is here in case of a brick\r\n        if (override_collat_balance){\r\n            return override_collat_balance_amount;\r\n        }\r\n        else {\r\n            // Saves gas by not having to do the array loop every time\r\n            return collatDollarBalanceStored;\r\n        }\r\n    }\r\n\r\n    function allAMOAddresses() external view returns (address[] memory) {\r\n        return amos_array;\r\n    }\r\n\r\n    function allAMOsLength() external view returns (uint256) {\r\n        return amos_array.length;\r\n    }\r\n\r\n    function unspentProfitGlobal() external view returns (int256) {\r\n        return int256(fraxDollarBalanceStored) - mint_sum - (collat_borrowed_sum * int256(10 ** missing_decimals));\r\n    }\r\n\r\n    function amoProfit(address amo_address) external view returns (int256) {\r\n        (uint256 frax_val_e18, ) = IAMO(amo_address).dollarBalances();\r\n        return int256(frax_val_e18) - mint_balances[amo_address] - ((collat_borrowed_balances[amo_address]) * int256(10 ** missing_decimals));\r\n    }\r\n    \r\n    /* ========== PUBLIC FUNCTIONS ========== */\r\n\r\n    // Callable by anyone willing to pay the gas\r\n    function syncDollarBalances() public {\r\n        uint256 total_frax_value_d18 = 0;\r\n        uint256 total_collateral_value_d18 = 0; \r\n        for (uint i = 0; i < amos_array.length; i++){ \r\n            // Exclude null addresses\r\n            if (amos_array[i] != address(0)){\r\n                (uint256 frax_val_e18, uint256 collat_val_e18) = IAMO(amos_array[i]).dollarBalances();\r\n\r\n                total_frax_value_d18 += frax_val_e18;\r\n                total_collateral_value_d18 += collat_val_e18;\r\n            }\r\n        }\r\n        fraxDollarBalanceStored = total_frax_value_d18;\r\n        collatDollarBalanceStored = total_collateral_value_d18;\r\n    }\r\n\r\n    /* ========== OLD POOL / BACKWARDS COMPATIBILITY ========== */\r\n\r\n    function oldPoolRedeem(uint256 frax_amount) external onlyByOwnGov {\r\n        uint256 redemption_fee = old_pool.redemption_fee();\r\n        uint256 col_price_usd = old_pool.getCollateralPrice();\r\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\r\n        uint256 redeem_amount_E6 = ((frax_amount * (uint256(1e6) - redemption_fee)) / 1e6) / (10 ** missing_decimals);\r\n        uint256 expected_collat_amount = (redeem_amount_E6 * global_collateral_ratio) / 1e6;\r\n        expected_collat_amount = (expected_collat_amount * 1e6) / col_price_usd;\r\n\r\n        require((collat_borrowed_sum + int256(expected_collat_amount)) <= collat_borrow_cap, \"Borrow cap\");\r\n        collat_borrowed_sum += int256(expected_collat_amount);\r\n\r\n        // Mint the frax \r\n        FRAX.pool_mint(address(this), frax_amount);\r\n\r\n        // Redeem the frax\r\n        FRAX.approve(address(old_pool), frax_amount);\r\n        old_pool.redeemFractionalFRAX(frax_amount, 0, 0);\r\n    }\r\n\r\n    function oldPoolCollectAndGive(address destination_amo, uint256 collat_amount) external onlyByOwnGov validAMO(destination_amo) {\r\n        // Collect the redemption\r\n        old_pool.collectRedemption();\r\n\r\n        // Mark the destination amo's borrowed amount\r\n        collat_borrowed_balances[destination_amo] += int256(collat_amount);\r\n\r\n        // Give the collateral to the AMO\r\n        TransferHelper.safeTransfer(collateral_address, destination_amo, collat_amount);\r\n\r\n        // Sync\r\n        syncDollarBalances();\r\n    }\r\n\r\n    /* ========== OWNER / GOVERNANCE FUNCTIONS ONLY ========== */\r\n    // Only owner or timelock can call, to limit risk \r\n\r\n    // This contract is essentially marked as a 'pool' so it can call OnlyPools functions like pool_mint and pool_burn_from\r\n    // on the main FRAX contract\r\n    function mintFraxForAMO(address destination_amo, uint256 frax_amount) external onlyByOwnGov validAMO(destination_amo) {\r\n        int256 frax_amt_i256 = int256(frax_amount);\r\n\r\n        // Make sure you aren't minting more than the mint cap\r\n        require((mint_sum + frax_amt_i256) <= mint_cap, \"Mint cap reached\");\r\n        mint_balances[destination_amo] += frax_amt_i256;\r\n        mint_sum += frax_amt_i256;\r\n\r\n        // Make sure the FRAX minting wouldn't push the CR down too much\r\n        // This is also a sanity check for the int256 math\r\n        uint256 current_collateral_E18 = FRAX.globalCollateralValue();\r\n        uint256 cur_frax_supply = FRAX.totalSupply();\r\n        uint256 new_frax_supply = cur_frax_supply + frax_amount;\r\n        uint256 new_cr = (current_collateral_E18 * PRICE_PRECISION) / new_frax_supply;\r\n        require(new_cr >= min_cr, \"CR would be too low\");\r\n\r\n        // Mint the FRAX to the AMO\r\n        FRAX.pool_mint(destination_amo, frax_amount);\r\n\r\n        // Sync\r\n        syncDollarBalances();\r\n    }\r\n\r\n\r\n    function giveCollatToAMO(\r\n        address destination_amo,\r\n        uint256 collat_amount\r\n    ) external onlyByOwnGov validAMO(destination_amo) {\r\n        int256 collat_amount_i256 = int256(collat_amount);\r\n\r\n        require((collat_borrowed_sum + collat_amount_i256) <= collat_borrow_cap, \"Borrow cap\");\r\n        collat_borrowed_balances[destination_amo] += collat_amount_i256;\r\n        collat_borrowed_sum += collat_amount_i256;\r\n\r\n        // Borrow the collateral\r\n        pool.amoMinterBorrow(collat_amount);\r\n\r\n        // Give the collateral to the AMO\r\n        TransferHelper.safeTransfer(collateral_address, destination_amo, collat_amount);\r\n\r\n        // Sync\r\n        syncDollarBalances();\r\n    }\r\n\r\n    function burnFraxFromAMO(uint256 frax_amount) external validAMO(msg.sender) {\r\n        int256 frax_amt_i256 = int256(frax_amount);\r\n\r\n        // Burn first\r\n        FRAX.pool_burn_from(msg.sender, frax_amount);\r\n\r\n        // Then update the balances\r\n        mint_balances[msg.sender] -= frax_amt_i256;\r\n        mint_sum -= frax_amt_i256;\r\n\r\n        // Sync\r\n        syncDollarBalances();\r\n    }\r\n\r\n    function burnFxsFromAMO(uint256 fxs_amount) external validAMO(msg.sender) {\r\n        // Burn\r\n        FXS.pool_burn_from(msg.sender, fxs_amount);\r\n    }\r\n\r\n    function receiveCollatFromAMO(uint256 usdc_amount) external validAMO(msg.sender) {\r\n        int256 collat_amt_i256 = int256(usdc_amount);\r\n\r\n        // Give back first\r\n        TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(pool), usdc_amount);\r\n\r\n        // Then update the balances\r\n        collat_borrowed_balances[msg.sender] -= collat_amt_i256;\r\n        collat_borrowed_sum -= collat_amt_i256;\r\n\r\n        // Sync\r\n        syncDollarBalances();\r\n    }\r\n\r\n    /* ========== Burns and givebacks ========== */\r\n\r\n    function burnFXS(uint256 amount) external onlyByOwnGov {\r\n        FXS.approve(address(this), amount);\r\n        FXS.pool_burn_from(address(this), amount);\r\n\r\n        // Sync\r\n        syncDollarBalances();\r\n    }\r\n\r\n    /* ========== RESTRICTED GOVERNANCE FUNCTIONS ========== */\r\n\r\n    // Adds an AMO \r\n    function addAMO(address amo_address, bool sync_too) public onlyByOwnGov {\r\n        require(amo_address != address(0), \"Zero address detected\");\r\n\r\n        (uint256 frax_val_e18, uint256 collat_val_e18) = IAMO(amo_address).dollarBalances();\r\n        require(frax_val_e18 >= 0 && collat_val_e18 >= 0, \"Invalid AMO\");\r\n\r\n        require(amos[amo_address] == false, \"Address already exists\");\r\n        amos[amo_address] = true; \r\n        amos_array.push(amo_address);\r\n\r\n        mint_balances[amo_address] = 0;\r\n        collat_borrowed_balances[amo_address] = 0;\r\n\r\n        if (sync_too) syncDollarBalances();\r\n\r\n        emit AMOAdded(amo_address);\r\n    }\r\n\r\n    // Removes an AMO\r\n    function removeAMO(address amo_address, bool sync_too) public onlyByOwnGov {\r\n        require(amo_address != address(0), \"Zero address detected\");\r\n        require(amos[amo_address] == true, \"Address nonexistant\");\r\n        \r\n        // Delete from the mapping\r\n        delete amos[amo_address];\r\n\r\n        // 'Delete' from the array by setting the address to 0x0\r\n        for (uint i = 0; i < amos_array.length; i++){ \r\n            if (amos_array[i] == amo_address) {\r\n                amos_array[i] = address(0); // This will leave a null in the array and keep the indices the same\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (sync_too) syncDollarBalances();\r\n\r\n        emit AMORemoved(amo_address);\r\n    }\r\n\r\n    function setTimelock(address new_timelock) external onlyByOwnGov {\r\n        require(new_timelock != address(0), \"Timelock address cannot be 0\");\r\n        timelock_address = new_timelock;\r\n    }\r\n\r\n    function setCustodian(address _custodian_address) external onlyByOwnGov {\r\n        require(_custodian_address != address(0), \"Custodian address cannot be 0\");        \r\n        custodian_address = _custodian_address;\r\n    }\r\n\r\n    // Only owner or timelock can call\r\n    function setMintCap(uint256 _mint_cap) external onlyByOwnGov {\r\n        mint_cap = int256(_mint_cap);\r\n    }\r\n\r\n    function setCollatBorrowCap(uint256 _collat_borrow_cap) external onlyByOwnGov {\r\n        collat_borrow_cap = int256(_collat_borrow_cap);\r\n    }\r\n\r\n    function setMinimumCollateralRatio(uint256 _min_cr) external onlyByOwnGov {\r\n        min_cr = _min_cr;\r\n    }\r\n\r\n    function setOverrideCollatBalance(bool _state, uint256 _balance) external onlyByOwnGov {\r\n        override_collat_balance = _state;\r\n        override_collat_balance_amount = _balance;\r\n    }\r\n\r\n    function setFraxPool(address _pool_address) external onlyByOwnGov {\r\n        pool = FraxPoolV3(_pool_address);\r\n\r\n        // Make sure the collaterals match, or balances could get corrupted\r\n        require(pool.collateralAddrToIdx(collateral_address) == col_idx, \"col_idx mismatch\");\r\n    }\r\n\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\r\n        // Can only be triggered by owner or governance\r\n        TransferHelper.safeTransfer(tokenAddress, owner, tokenAmount);\r\n        \r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AMOAdded(address amo_address);\r\n    event AMORemoved(address amo_address);\r\n    event Recovered(address token, uint256 amount);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_custodian_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"amo_address\",\"type\":\"address\"}],\"name\":\"AMOAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"amo_address\",\"type\":\"address\"}],\"name\":\"AMORemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FRAX\",\"outputs\":[{\"internalType\":\"contract IFrax\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FXS\",\"outputs\":[{\"internalType\":\"contract IFxs\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"amo_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"sync_too\",\"type\":\"bool\"}],\"name\":\"addAMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allAMOAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allAMOsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"amo_address\",\"type\":\"address\"}],\"name\":\"amoProfit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amos_array\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFXS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"frax_amount\",\"type\":\"uint256\"}],\"name\":\"burnFraxFromAMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fxs_amount\",\"type\":\"uint256\"}],\"name\":\"burnFxsFromAMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"col_idx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collatDollarBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collatDollarBalanceStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collat_borrow_cap\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collat_borrowed_balances\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collat_borrowed_sum\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral_token\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"custodian_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fraxDollarBalanceStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination_amo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collat_amount\",\"type\":\"uint256\"}],\"name\":\"giveCollatToAMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min_cr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination_amo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"frax_amount\",\"type\":\"uint256\"}],\"name\":\"mintFraxForAMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mint_balances\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint_cap\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint_sum\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"missing_decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination_amo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collat_amount\",\"type\":\"uint256\"}],\"name\":\"oldPoolCollectAndGive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"frax_amount\",\"type\":\"uint256\"}],\"name\":\"oldPoolRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"old_pool\",\"outputs\":[{\"internalType\":\"contract IFraxPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"override_collat_balance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"override_collat_balance_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract FraxPoolV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdc_amount\",\"type\":\"uint256\"}],\"name\":\"receiveCollatFromAMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"amo_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"sync_too\",\"type\":\"bool\"}],\"name\":\"removeAMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collat_borrow_cap\",\"type\":\"uint256\"}],\"name\":\"setCollatBorrowCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_custodian_address\",\"type\":\"address\"}],\"name\":\"setCustodian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool_address\",\"type\":\"address\"}],\"name\":\"setFraxPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_cr\",\"type\":\"uint256\"}],\"name\":\"setMinimumCollateralRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mint_cap\",\"type\":\"uint256\"}],\"name\":\"setMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setOverrideCollatBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_timelock\",\"type\":\"address\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncDollarBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unspentProfitGlobal\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FraxAMOMinter","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"000000000000000000000000234d953a9404bf9dbc3b526271d440cd2870bcd20000000000000000000000005180db0237291a6449dda9ed33ad90a38787621c0000000000000000000000008412ebf45bac1b340bbe8f318b928c466c4e39ca000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000002fe065e6ffef9ac95ab39e5042744d695f560729","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ce6b1c17e91289e30badd9b66536daeab03ffec1edc76cc2bd348c0a6c22613e"}]}