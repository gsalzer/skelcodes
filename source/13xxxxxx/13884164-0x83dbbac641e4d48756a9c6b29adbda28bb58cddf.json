{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ncontract mainnetSigner{\r\n\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function getOwner() public view returns(address){\r\n        return owner;\r\n    }\r\n\r\n    function setOwner(address _owner) public{\r\n        require(msg.sender == owner,\"can only be called by owner\");\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n   * @notice Verifies that the signer is the owner of the signing contract.\r\n   */\r\n  function isValidSignature(\r\n    bytes32 _hash,\r\n    bytes calldata _signature\r\n  ) external view returns (bytes4) {\r\n    // Validate signatures\r\n    if (recoverSigner(_hash, _signature) == owner) {\r\n      return 0x1626ba7e;\r\n    } else {\r\n      return 0xffffffff;\r\n    }\r\n  }\r\n\r\n /**\r\n   * @notice Recover the signer of hash, assuming it's an EOA account\r\n   * @dev Only for EthSign signatures\r\n   * @param _ethSignedMessageHash       Hash of message that was signed\r\n   * @param _signature  Signature encoded as (bytes32 r, bytes32 s, uint8 v)\r\n   */\r\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig)\r\n        public\r\n        pure\r\n        returns (\r\n            bytes32 r,\r\n            bytes32 s,\r\n            uint8 v\r\n        )\r\n    {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            /*\r\n            First 32 bytes stores the length of the signature\r\n\r\n            add(sig, 32) = pointer of sig + 32\r\n            effectively, skips first 32 bytes of signature\r\n\r\n            mload(p) loads next 32 bytes starting at the memory address p into memory\r\n            */\r\n\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // implicitly return (r, s, v)\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"mainnetSigner","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6e064f422f8379cd5a1da59624d3eea7fb787700fbbf8e5f71ca6cff1b691c39"}]}