{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/tokens/vesting/LinearVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\\r\\n\\r\\npragma solidity =0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"../../shared/ProtocolConstants.sol\\\";\\r\\n\\r\\nimport \\\"../../interfaces/tokens/vesting/ILinearVesting.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {ILinearVesting} interface.\\r\\n *\\r\\n * The straightforward vesting contract that gradually releases a\\r\\n * fixed supply of tokens to multiple vest parties over a 2 year\\r\\n * window.\\r\\n *\\r\\n * The token expects the {begin} hook to be invoked the moment\\r\\n * it is supplied with the necessary amount of tokens to vest,\\r\\n * which should be equivalent to the time the {setComponents}\\r\\n * function is invoked on the Vader token.\\r\\n */\\r\\ncontract LinearVesting is ILinearVesting, ProtocolConstants, Ownable {\\r\\n    /* ========== LIBRARIES ========== */\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    // The Vader token\\r\\n    IERC20 public immutable vader;\\r\\n\\r\\n    // The start of the vesting period\\r\\n    uint256 public start;\\r\\n\\r\\n    // The end of the vesting period\\r\\n    uint256 public end;\\r\\n\\r\\n    // The status of each vesting member (Vester)\\r\\n    mapping(address => Vester) public vest;\\r\\n\\r\\n    // The address of Converter contract.\\r\\n    address public converter;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract's vesters and vesting amounts as well as sets\\r\\n     * the Vader token address.\\r\\n     *\\r\\n     * It conducts a sanity check to ensure that the total vesting amounts specified match\\r\\n     * the team allocation to ensure that the contract is deployed correctly.\\r\\n     *\\r\\n     * Additionally, it transfers ownership to the Vader contract that needs to consequently\\r\\n     * initiate the vesting period via {begin} after it mints the necessary amount to the contract.\\r\\n     */\\r\\n    constructor(IERC20 _vader, address _converter) {\\r\\n        require(\\r\\n            _vader != IERC20(_ZERO_ADDRESS) && _converter != _ZERO_ADDRESS,\\r\\n            \\\"LinearVesting::constructor: Misconfiguration\\\"\\r\\n        );\\r\\n\\r\\n        vader = _vader;\\r\\n        converter = _converter;\\r\\n\\r\\n        transferOwnership(address(_vader));\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount a user can claim at a given point in time.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - the vesting period has started\\r\\n     */\\r\\n    function getClaim(address _vester)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        hasStarted\\r\\n        returns (uint256 vestedAmount)\\r\\n    {\\r\\n        Vester memory vester = vest[_vester];\\r\\n        return\\r\\n            _getClaim(\\r\\n                vester.amount,\\r\\n                vester.lastClaim,\\r\\n                vester.start,\\r\\n                vester.end\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Allows a user to claim their pending vesting amount of the vested claim\\r\\n     *\\r\\n     * Emits a {Vested} event indicating the user who claimed their vested tokens\\r\\n     * as well as the amount that was vested.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the vesting period has started\\r\\n     * - the caller must have a non-zero vested amount\\r\\n     */\\r\\n    function claim() external override returns (uint256 vestedAmount) {\\r\\n        Vester memory vester = vest[msg.sender];\\r\\n\\r\\n        require(\\r\\n            vester.start != 0,\\r\\n            \\\"LinearVesting::claim: Incorrect Vesting Type\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            vester.start < block.timestamp,\\r\\n            \\\"LinearVesting::claim: Not Started Yet\\\"\\r\\n        );\\r\\n\\r\\n        vestedAmount = _getClaim(\\r\\n            vester.amount,\\r\\n            vester.lastClaim,\\r\\n            vester.start,\\r\\n            vester.end\\r\\n        );\\r\\n\\r\\n        require(vestedAmount != 0, \\\"LinearVesting::claim: Nothing to claim\\\");\\r\\n\\r\\n        vester.amount -= uint192(vestedAmount);\\r\\n        vester.lastClaim = uint64(block.timestamp);\\r\\n\\r\\n        vest[msg.sender] = vester;\\r\\n\\r\\n        emit Vested(msg.sender, vestedAmount);\\r\\n\\r\\n        vader.transfer(msg.sender, vestedAmount);\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the vesting period to be initiated.\\r\\n     *\\r\\n     * Emits a {VestingInitialized} event from which the start and\\r\\n     * end can be calculated via it's attached timestamp.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the owner (vader token)\\r\\n     */\\r\\n    function begin(address[] calldata vesters, uint192[] calldata amounts)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(\\r\\n            vesters.length == amounts.length,\\r\\n            \\\"LinearVesting::begin: Vesters and Amounts lengths do not match\\\"\\r\\n        );\\r\\n\\r\\n        uint256 _start = block.timestamp;\\r\\n        uint256 _end = block.timestamp + _VESTING_DURATION;\\r\\n\\r\\n        start = _start;\\r\\n        end = _end;\\r\\n\\r\\n        uint256 total;\\r\\n        for (uint256 i = 0; i < vesters.length; i++) {\\r\\n            require(\\r\\n                amounts[i] != 0,\\r\\n                \\\"LinearVesting::begin: Incorrect Amount Specified\\\"\\r\\n            );\\r\\n            require(\\r\\n                vesters[i] != _ZERO_ADDRESS,\\r\\n                \\\"LinearVesting::begin: Zero Vester Address Specified\\\"\\r\\n            );\\r\\n            require(\\r\\n                vest[vesters[i]].amount == 0,\\r\\n                \\\"LinearVesting::begin: Duplicate Vester Entry Specified\\\"\\r\\n            );\\r\\n            vest[vesters[i]] = Vester(\\r\\n                amounts[i],\\r\\n                0,\\r\\n                uint128(_start),\\r\\n                uint128(_end)\\r\\n            );\\r\\n            total = total + amounts[i];\\r\\n        }\\r\\n        require(\\r\\n            total == _TEAM_ALLOCATION,\\r\\n            \\\"LinearVesting::begin: Invalid Vest Amounts Specified\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            vader.balanceOf(address(this)) >= _TEAM_ALLOCATION,\\r\\n            \\\"LinearVesting::begin: Vader is less than TEAM_ALLOCATION\\\"\\r\\n        );\\r\\n\\r\\n        emit VestingInitialized(_VESTING_DURATION);\\r\\n\\r\\n        renounceOwnership();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a new vesting schedule to the contract.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Only {converter} can call.\\r\\n     */\\r\\n    function vestFor(address user, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyConverter\\r\\n        hasStarted\\r\\n    {\\r\\n        require(\\r\\n            amount <= type(uint192).max,\\r\\n            \\\"LinearVesting::vestFor: Amount Overflows uint192\\\"\\r\\n        );\\r\\n        require(\\r\\n            vest[user].amount == 0,\\r\\n            \\\"LinearVesting::vestFor: Already a vester\\\"\\r\\n        );\\r\\n        vest[user] = Vester(\\r\\n            uint192(amount),\\r\\n            0,\\r\\n            uint128(block.timestamp),\\r\\n            uint128(block.timestamp + 365 days)\\r\\n        );\\r\\n        vader.transferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        emit VestingCreated(user, amount);\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    function _getClaim(\\r\\n        uint256 amount,\\r\\n        uint256 lastClaim,\\r\\n        uint256 _start,\\r\\n        uint256 _end\\r\\n    ) private view returns (uint256) {\\r\\n        if (block.timestamp >= _end) return amount;\\r\\n        if (lastClaim == 0) lastClaim = _start;\\r\\n\\r\\n        return (amount * (block.timestamp - lastClaim)) / (_end - lastClaim);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates that the vesting period has started\\r\\n     */\\r\\n    function _hasStarted() private view {\\r\\n        require(\\r\\n            start != 0,\\r\\n            \\\"LinearVesting::_hasStarted: Vesting hasn't started yet\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Ensures that only converter is able to call a function.\\r\\n     **/\\r\\n    function _onlyConverter() private view {\\r\\n        require(\\r\\n            msg.sender == converter,\\r\\n            \\\"LinearVesting::_onlyConverter: Only converter is allowed to call\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the vesting period hasn't started\\r\\n     */\\r\\n    modifier hasStarted() {\\r\\n        _hasStarted();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Throws if called by address that is not converter.\\r\\n     **/\\r\\n    modifier onlyConverter() {\\r\\n        _onlyConverter();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/shared/ProtocolConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\\r\\npragma solidity =0.8.9;\\r\\n\\r\\nabstract contract ProtocolConstants {\\r\\n    /* ========== GENERAL ========== */\\r\\n\\r\\n    // The zero address, utility\\r\\n    address internal constant _ZERO_ADDRESS = address(0);\\r\\n\\r\\n    // One year, utility\\r\\n    uint256 internal constant _ONE_YEAR = 365 days;\\r\\n\\r\\n    // Basis Points\\r\\n    uint256 internal constant _MAX_BASIS_POINTS = 100_00;\\r\\n\\r\\n    /* ========== VADER TOKEN ========== */\\r\\n\\r\\n    // Max VADER supply\\r\\n    uint256 internal constant _INITIAL_VADER_SUPPLY = 25_000_000_000 * 1 ether;\\r\\n\\r\\n    // Allocation for VETH holders\\r\\n    uint256 internal constant _VETH_ALLOCATION = 7_500_000_000 * 1 ether;\\r\\n\\r\\n    // Team allocation vested over {VESTING_DURATION} years\\r\\n    uint256 internal constant _TEAM_ALLOCATION = 2_500_000_000 * 1 ether;\\r\\n\\r\\n    // Ecosystem growth fund unlocked for partnerships & USDV provision\\r\\n    uint256 internal constant _ECOSYSTEM_GROWTH = 2_500_000_000 * 1 ether;\\r\\n\\r\\n    // Total grant tokens\\r\\n    uint256 internal constant _GRANT_ALLOCATION = 12_500_000_000 * 1 ether;\\r\\n\\r\\n    // Emission Era\\r\\n    uint256 internal constant _EMISSION_ERA = 24 hours;\\r\\n\\r\\n    // Initial Emission Curve, 5\\r\\n    uint256 internal constant _INITIAL_EMISSION_CURVE = 5;\\r\\n\\r\\n    // Fee Basis Points\\r\\n    uint256 internal constant _MAX_FEE_BASIS_POINTS = 1_00;\\r\\n\\r\\n    /* ========== VESTING ========== */\\r\\n\\r\\n    // Vesting Duration\\r\\n    uint256 internal constant _VESTING_DURATION = 2 * _ONE_YEAR;\\r\\n\\r\\n    /* ========== CONVERTER ========== */\\r\\n\\r\\n    // Vader -> Vether Conversion Rate (1000:1)\\r\\n    uint256 internal constant _VADER_VETHER_CONVERSION_RATE = 10_000;\\r\\n\\r\\n    // Burn Address\\r\\n    address internal constant _BURN =\\r\\n        0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD;\\r\\n\\r\\n    /* ========== SWAP QUEUE ========== */\\r\\n\\r\\n    // A minimum of 10 swaps will be executed per block\\r\\n    uint256 internal constant _MIN_SWAPS_EXECUTED = 10;\\r\\n\\r\\n    // Expressed in basis points (50%)\\r\\n    uint256 internal constant _DEFAULT_SWAPS_EXECUTED = 50_00;\\r\\n\\r\\n    // The queue size of each block is 100 units\\r\\n    uint256 internal constant _QUEUE_SIZE = 100;\\r\\n\\r\\n    /* ========== GAS QUEUE ========== */\\r\\n\\r\\n    // Address of Chainlink Fast Gas Price Oracle\\r\\n    address internal constant _FAST_GAS_ORACLE =\\r\\n        0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C;\\r\\n\\r\\n    /* ========== VADER RESERVE ========== */\\r\\n\\r\\n    // Minimum delay between grants\\r\\n    uint256 internal constant _GRANT_DELAY = 30 days;\\r\\n\\r\\n    // Maximum grant size divisor\\r\\n    uint256 internal constant _MAX_GRANT_BASIS_POINTS = 10_00;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/tokens/vesting/ILinearVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\\r\\npragma solidity =0.8.9;\\r\\n\\r\\ninterface ILinearVesting {\\r\\n    /* ========== STRUCTS ========== */\\r\\n\\r\\n    // Struct of a vesting member, tight-packed to 256-bits\\r\\n    struct Vester {\\r\\n        uint192 amount;\\r\\n        uint64 lastClaim;\\r\\n        uint128 start;\\r\\n        uint128 end;\\r\\n    }\\r\\n\\r\\n    /* ========== FUNCTIONS ========== */\\r\\n\\r\\n    function getClaim(address _vester)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 vestedAmount);\\r\\n\\r\\n    function claim() external returns (uint256 vestedAmount);\\r\\n\\r\\n    //    function claimConverted() external returns (uint256 vestedAmount);\\r\\n\\r\\n    function begin(address[] calldata vesters, uint192[] calldata amounts)\\r\\n        external;\\r\\n\\r\\n    function vestFor(address user, uint256 amount) external;\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event VestingInitialized(uint256 duration);\\r\\n\\r\\n    event VestingCreated(address user, uint256 amount);\\r\\n\\r\\n    event Vested(address indexed from, uint256 amount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_vader\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_converter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"VestingInitialized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vesters\",\"type\":\"address[]\"},{\"internalType\":\"uint192[]\",\"name\":\"amounts\",\"type\":\"uint192[]\"}],\"name\":\"begin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vester\",\"type\":\"address\"}],\"name\":\"getClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vader\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vest\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"amount\",\"type\":\"uint192\"},{\"internalType\":\"uint64\",\"name\":\"lastClaim\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"start\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"end\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vestFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LinearVesting","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000595af52e4022aebd794de267fc20c12c50c08f8000000000000000000000000c4e4ca3f7ca1cfdc70d1364001a932b2870b0b58","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}