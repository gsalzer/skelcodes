{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/deployment/AddressDictator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { Lib_AddressManager } from \\\"../../libraries/resolver/Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title AddressDictator\\n * @dev The AddressDictator (glory to Arstotzka) is a contract that allows us to safely manipulate\\n *      many different addresses in the AddressManager without transferring ownership of the\\n *      AddressManager to a hot wallet or hardware wallet.\\n */\\ncontract AddressDictator {\\n    /*********\\n     * Types *\\n     *********/\\n\\n    struct NamedAddress {\\n        string name;\\n        address addr;\\n    }\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public manager;\\n    address public finalOwner;\\n    NamedAddress[] namedAddresses;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _manager Address of the AddressManager contract.\\n     * @param _finalOwner Address to transfer AddressManager ownership to afterwards.\\n     * @param _names Array of names to associate an address with.\\n     * @param _addresses Array of addresses to associate with the name.\\n     */\\n    constructor(\\n        Lib_AddressManager _manager,\\n        address _finalOwner,\\n        string[] memory _names,\\n        address[] memory _addresses\\n    ) {\\n        manager = _manager;\\n        finalOwner = _finalOwner;\\n        require(\\n            _names.length == _addresses.length,\\n            \\\"AddressDictator: Must provide an equal number of names and addresses.\\\"\\n        );\\n        for (uint256 i = 0; i < _names.length; i++) {\\n            namedAddresses.push(NamedAddress({ name: _names[i], addr: _addresses[i] }));\\n        }\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Called to finalize the transfer, this function is callable by anyone, but will only result in\\n     * an upgrade if this contract is the owner Address Manager.\\n     */\\n    function setAddresses() external {\\n        for (uint256 i = 0; i < namedAddresses.length; i++) {\\n            manager.setAddress(namedAddresses[i].name, namedAddresses[i].addr);\\n        }\\n        // note that this will revert if _finalOwner == currentOwner\\n        manager.transferOwnership(finalOwner);\\n    }\\n\\n    /**\\n     * Transfers ownership of this contract to the finalOwner.\\n     * Only callable by the Final Owner, which is intended to be our multisig.\\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can recover\\n     * if something really surprising goes wrong.\\n     */\\n    function returnOwnership() external {\\n        require(msg.sender == finalOwner, \\\"AddressDictator: only callable by finalOwner\\\");\\n        manager.transferOwnership(finalOwner);\\n    }\\n\\n    /******************\\n     * View Functions *\\n     ******************/\\n\\n    /**\\n     * Returns the full namedAddresses array.\\n     */\\n    function getNamedAddresses() external view returns (NamedAddress[] memory) {\\n        return namedAddresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping(bytes32 => address) private addresses;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_finalOwner\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"finalOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNamedAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"internalType\":\"struct AddressDictator.NamedAddress[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AddressDictator","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000de1fcfb0851916ca5101820a69b13a4e276bd81f0000000000000000000000009ba6e03d8b90de867373db8cf1a58d2f7f006b3a00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000021436861696e53746f72616765436f6e7461696e65722d4354432d62617463686573000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021436861696e53746f72616765436f6e7461696e65722d5343432d6261746368657300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001943616e6f6e6963616c5472616e73616374696f6e436861696e0000000000000000000000000000000000000000000000000000000000000000000000000000145374617465436f6d6d69746d656e74436861696e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b426f6e644d616e61676572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a4f564d5f4c3143726f7373446f6d61696e4d657373656e67657200000000000000000000000000000000000000000000000000000000000000000000000000164c3243726f7373446f6d61696e4d657373656e676572000000000000000000000000000000000000000000000000000000000000000000000000000000000007000000000000000000000000d16463ef9b0338ce3d73309028ef1714d220c024000000000000000000000000b0ddff09c4019e31960de11bd845e836078e8ebe0000000000000000000000005e4e65926ba27467555eb562121fac00d24e9dd2000000000000000000000000be5dab4a2e9cd0f27300db4ab94bee3a233aeb19000000000000000000000000cd626e1328b41fcf24737f137bcd4ce0c32bc8d1000000000000000000000000d9166833ff12a5f900ccfbf2c8b62a90f1ca1fd50000000000000000000000004200000000000000000000000000000000000007","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}