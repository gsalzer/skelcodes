{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MochiCSSRv0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IGovernanceOwned.sol\\\";\\nimport \\\"./interfaces/ICSSRAdapter.sol\\\";\\nimport \\\"./interfaces/ICSSRRouter.sol\\\";\\n\\n///@notice CSSR that mixes rate oracle(keydonix) and centralized(chainlink) / maintained(keep3r) oracle to broaden the oracle usage among small cap tokens\\ncontract MochiCSSRv0 is ICSSRRouter {\\n    IGovernanceOwned public immutable owned;\\n\\n    // bluechip will be\\n    // WETH,\\n    // WBTC,\\n    // USDC,\\n    // DAI\\n    mapping(address => bool) public blueChip;\\n\\n    address public defaultPriceSource;\\n    address public defaultLiquiditySource;\\n\\n    //to check if adapter is listed\\n    mapping(address => bool) public adapter;\\n    mapping(address => address) public priceSource;\\n    mapping(address => address) public liquiditySource;\\n    mapping(address => float) public lastPrice;\\n\\n    ICSSRAdapter public fiatPriceAdapter;\\n\\n    modifier onlyGov() {\\n        require(msg.sender == owned.governance(), \\\"!gov\\\");\\n        _;\\n    }\\n\\n    constructor(address _owned) {\\n        owned = IGovernanceOwned(_owned);\\n    }\\n\\n    function setBluechip(address[] calldata _assets) external onlyGov {\\n        for(uint256 i = 0; i<_assets.length; i++){\\n            blueChip[_assets[i]] = true;\\n        }\\n    }\\n\\n    function removeBluechip(address[] calldata _assets) external onlyGov {\\n        for(uint256 i = 0; i<_assets.length; i++){\\n            blueChip[_assets[i]] = false;\\n        }\\n    }\\n\\n    function listAdapter(address _adapter) external onlyGov {\\n        adapter[_adapter] = true;\\n    }\\n\\n    function delistAdapter(address _adapter) external onlyGov {\\n        adapter[_adapter] = false;\\n    }\\n\\n    function setFiatPriceAdapter(address _adapter) external onlyGov {\\n        fiatPriceAdapter = ICSSRAdapter(_adapter);\\n    }\\n\\n    function setPriceSource(address _adapter, address[] calldata _assets) external onlyGov {\\n        require(adapter[_adapter], \\\"!listed\\\");\\n        for(uint256 i = 0; i<_assets.length; i++){\\n            require(ICSSRAdapter(_adapter).support(_assets[i]), \\\"!supported\\\");\\n            priceSource[_assets[i]] = _adapter;\\n        }\\n    }\\n\\n    function setLiquiditySource(address _adapter, address[] calldata _assets)\\n        external\\n        onlyGov\\n    {\\n        require(adapter[_adapter], \\\"!listed\\\");\\n        for(uint256 i = 0; i<_assets.length; i++){\\n            require(ICSSRAdapter(_adapter).support(_assets[i]), \\\"!supported\\\");\\n            liquiditySource[_assets[i]] = _adapter;\\n        }\\n    }\\n\\n    function setDefaultPriceSource(address _adapter) external onlyGov {\\n        require(adapter[_adapter], \\\"!listed\\\");\\n        defaultPriceSource = _adapter;\\n    }\\n\\n    function setDefaultLiquiditySource(address _adapter) external onlyGov {\\n        require(adapter[_adapter], \\\"!listed\\\");\\n        defaultLiquiditySource = _adapter;\\n    }\\n\\n    function update(address _asset, bytes memory _data)\\n        external\\n        override\\n        returns (float memory price)\\n    {\\n        if (blueChip[_asset]) {\\n            return fiatPriceAdapter.getPrice(_asset);\\n        }\\n        ICSSRAdapter priceAdapter = ICSSRAdapter(priceSource[_asset]);\\n        if (address(priceAdapter) == address(0)) {\\n            priceAdapter = ICSSRAdapter(defaultPriceSource);\\n        }\\n        price = priceAdapter.update(_asset, _data);\\n        lastPrice[_asset] = price;\\n    }\\n\\n    function getPrice(address _asset)\\n        external\\n        view\\n        override\\n        returns (float memory)\\n    {\\n        if (blueChip[_asset]) {\\n            return fiatPriceAdapter.getPrice(_asset);\\n        } else {\\n            ICSSRAdapter priceAdapter = ICSSRAdapter(priceSource[_asset]);\\n            if (address(priceAdapter) == address(0)) {\\n                priceAdapter = ICSSRAdapter(defaultPriceSource);\\n            }\\n            return priceAdapter.getPrice(_asset);\\n        }\\n    }\\n\\n    function getLiquidity(address _asset)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        ICSSRAdapter liquidityAdapter = ICSSRAdapter(liquiditySource[_asset]);\\n        if (address(liquidityAdapter) == address(0)) {\\n            liquidityAdapter = ICSSRAdapter(defaultLiquiditySource);\\n        }\\n        return liquidityAdapter.getLiquidity(_asset);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IGovernanceOwned {\\n    function governance() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICSSRAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\ninterface ICSSRAdapter {\\n    function update(address _asset, bytes memory _data)\\n        external\\n        returns (float memory price);\\n\\n    function support(address _asset) external view returns (bool);\\n\\n    function getPrice(address _asset)\\n        external\\n        view\\n        returns (float memory price);\\n\\n    function getLiquidity(address _asset)\\n        external\\n        view\\n        returns (uint256 _liquidity);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICSSRRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\ninterface ICSSRRouter {\\n    function update(address _asset, bytes memory _data)\\n        external\\n        returns (float memory);\\n\\n    function getPrice(address _asset) external view returns (float memory);\\n\\n    function getLiquidity(address _asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@mochifi/library/contracts/Float.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nstruct float {\\n    uint256 numerator;\\n    uint256 denominator;\\n}\\n\\nlibrary Float {\\n    function multiply(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.numerator / f.denominator;\\n    }\\n\\n    function inverse(float memory f) internal pure returns(float memory) {\\n        require(f.numerator != 0 && f.denominator != 0, \\\"div 0\\\");\\n        return float({\\n            numerator: f.denominator,\\n            denominator: f.numerator\\n        });\\n    }\\n\\n    function divide(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.denominator / f.numerator;\\n    }\\n\\n    function add(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator + a.denominator*b.numerator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n    \\n    function sub(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator - b.numerator*a.denominator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function mul(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator * b.numerator,\\n            denominator : a.denominator * b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function gt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator > a.denominator * b.numerator;\\n    }\\n\\n    function lt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator < a.denominator * b.numerator;\\n    }\\n\\n    function gte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator >= a.denominator * b.numerator;\\n    }\\n\\n    function lte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator <= a.denominator * b.numerator;\\n    }\\n\\n    function equals(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator == b.numerator * a.denominator;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owned\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"adapter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blueChip\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultLiquiditySource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPriceSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"delistAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fiatPriceAdapter\",\"outputs\":[{\"internalType\":\"contract ICSSRAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct float\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquiditySource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"listAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owned\",\"outputs\":[{\"internalType\":\"contract IGovernanceOwned\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"removeBluechip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"setBluechip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"setDefaultLiquiditySource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"setDefaultPriceSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"setFiatPriceAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"setLiquiditySource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"setPriceSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"update\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct float\",\"name\":\"price\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MochiCSSRv0","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000860e47e6d6f4a6bcaaddfc7f17f772d2ab55be2f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}