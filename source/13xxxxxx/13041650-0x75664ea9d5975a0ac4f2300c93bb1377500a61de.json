{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/ReignFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IReign.sol\\\";\\nimport \\\"../libraries/LibReignStorage.sol\\\";\\nimport \\\"diamond-libraries/contracts/libraries/LibOwnership.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract ReignFacet {\\n    using SafeMath for uint256;\\n\\n    uint256 public constant MAX_LOCK = 365 days * 2; //two years\\n    uint256 public constant BASE_STAKE_MULTIPLIER = 1 * 10**18;\\n    uint128 public constant BASE_BALANCE_MULTIPLIER = uint128(1 * 10**18);\\n\\n    mapping(uint128 => bool) private _isInitialized;\\n    mapping(uint128 => uint256) private _initialisedAt;\\n    mapping(address => uint256) private _balances;\\n\\n    event Deposit(address indexed user, uint256 amount, uint256 newBalance);\\n    event Withdraw(\\n        address indexed user,\\n        uint256 amountWithdrew,\\n        uint256 amountLeft\\n    );\\n    event Lock(address indexed user, uint256 timestamp);\\n    event Delegate(address indexed from, address indexed to);\\n    event DelegatedPowerIncreased(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        uint256 to_newDelegatedPower\\n    );\\n    event DelegatedPowerDecreased(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        uint256 to_newDelegatedPower\\n    );\\n    event InitEpoch(address indexed caller, uint128 indexed epochId);\\n\\n    function initReign(\\n        address _reignToken,\\n        uint256 _epoch1Start,\\n        uint256 _epochDuration\\n    ) public {\\n        require(\\n            _reignToken != address(0),\\n            \\\"Reign Token address must not be 0x0\\\"\\n        );\\n\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n\\n        require(!ds.initialized, \\\"Reign: already initialized\\\");\\n        LibOwnership.enforceIsContractOwner();\\n\\n        ds.initialized = true;\\n\\n        ds.reign = IERC20(_reignToken);\\n        ds.epoch1Start = _epoch1Start;\\n        ds.epochDuration = _epochDuration;\\n    }\\n\\n    // deposit allows a user to add more reign to his staked balance\\n    function deposit(uint256 amount) public {\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n        uint256 allowance = ds.reign.allowance(msg.sender, address(this));\\n        require(allowance >= amount, \\\"Token allowance too small\\\");\\n\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n\\n        _updateStake(ds.userStakeHistory[msg.sender], _balances[msg.sender]);\\n        _increaseEpochBalance(ds.userBalanceHistory[msg.sender], amount);\\n        _updateLockedReign(reignStaked().add(amount));\\n\\n        address delegatedTo = userDelegatedTo(msg.sender);\\n        if (delegatedTo != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(delegatedTo).add(amount);\\n            _updateDelegatedPower(\\n                ds.delegatedPowerHistory[delegatedTo],\\n                newDelegatedPower\\n            );\\n\\n            emit DelegatedPowerIncreased(\\n                msg.sender,\\n                delegatedTo,\\n                amount,\\n                newDelegatedPower\\n            );\\n        }\\n\\n        ds.reign.transferFrom(msg.sender, address(this), amount);\\n\\n        emit Deposit(msg.sender, amount, _balances[msg.sender]);\\n    }\\n\\n    // withdraw allows a user to withdraw funds if the balance is not locked\\n    function withdraw(uint256 amount) public {\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(\\n            userLockedUntil(msg.sender) <= block.timestamp,\\n            \\\"User balance is locked\\\"\\n        );\\n\\n        uint256 balance = balanceOf(msg.sender);\\n        require(balance >= amount, \\\"Insufficient balance\\\");\\n\\n        _balances[msg.sender] = balance.sub(amount);\\n\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n\\n        _updateStake(ds.userStakeHistory[msg.sender], _balances[msg.sender]);\\n        _decreaseEpochBalance(ds.userBalanceHistory[msg.sender], amount);\\n        _updateLockedReign(reignStaked().sub(amount));\\n\\n        address delegatedTo = userDelegatedTo(msg.sender);\\n        if (delegatedTo != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(delegatedTo).sub(amount);\\n            _updateDelegatedPower(\\n                ds.delegatedPowerHistory[delegatedTo],\\n                newDelegatedPower\\n            );\\n\\n            emit DelegatedPowerDecreased(\\n                msg.sender,\\n                delegatedTo,\\n                amount,\\n                newDelegatedPower\\n            );\\n        }\\n\\n        ds.reign.transfer(msg.sender, amount);\\n\\n        emit Withdraw(msg.sender, amount, balance.sub(amount));\\n    }\\n\\n    // lock a user's currently staked balance until timestamp\\n    function lock(uint256 timestamp) public {\\n        require(timestamp > block.timestamp, \\\"Timestamp must be in the future\\\");\\n        require(timestamp <= block.timestamp + MAX_LOCK, \\\"Timestamp too big\\\");\\n        require(balanceOf(msg.sender) > 0, \\\"Sender has no balance\\\");\\n\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n        LibReignStorage.Stake[] storage checkpoints = ds.userStakeHistory[\\n            msg.sender\\n        ];\\n        LibReignStorage.Stake storage currentStake = checkpoints[\\n            checkpoints.length - 1\\n        ];\\n        if (!epochIsInitialized(getEpoch())) {\\n            _initEpoch(getEpoch());\\n        }\\n\\n        require(\\n            timestamp > currentStake.expiryTimestamp,\\n            \\\"New timestamp lower than current lock timestamp\\\"\\n        );\\n\\n        _updateUserLock(checkpoints, timestamp);\\n\\n        emit Lock(msg.sender, timestamp);\\n    }\\n\\n    function depositAndLock(uint256 amount, uint256 timestamp) public {\\n        deposit(amount);\\n        lock(timestamp);\\n    }\\n\\n    // delegate allows a user to delegate his voting power to another user\\n    function delegate(address to) public {\\n        require(msg.sender != to, \\\"Can't delegate to self\\\");\\n\\n        uint256 senderBalance = balanceOf(msg.sender);\\n        require(senderBalance > 0, \\\"No balance to delegate\\\");\\n\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n\\n        emit Delegate(msg.sender, to);\\n\\n        address delegatedTo = userDelegatedTo(msg.sender);\\n        if (delegatedTo != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(delegatedTo).sub(\\n                senderBalance\\n            );\\n            _updateDelegatedPower(\\n                ds.delegatedPowerHistory[delegatedTo],\\n                newDelegatedPower\\n            );\\n\\n            emit DelegatedPowerDecreased(\\n                msg.sender,\\n                delegatedTo,\\n                senderBalance,\\n                newDelegatedPower\\n            );\\n        }\\n\\n        if (to != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(to).add(senderBalance);\\n            _updateDelegatedPower(\\n                ds.delegatedPowerHistory[to],\\n                newDelegatedPower\\n            );\\n\\n            emit DelegatedPowerIncreased(\\n                msg.sender,\\n                to,\\n                senderBalance,\\n                newDelegatedPower\\n            );\\n        }\\n\\n        _updateUserDelegatedTo(ds.userStakeHistory[msg.sender], to);\\n    }\\n\\n    // stopDelegate allows a user to take back the delegated voting power\\n    function stopDelegate() public {\\n        return delegate(address(0));\\n    }\\n\\n    /*\\n     *   VIEWS\\n     */\\n\\n    // balanceOf returns the current REIGN balance of a user (bonus not included)\\n    function balanceOf(address user) public view returns (uint256) {\\n        return _balances[user];\\n    }\\n\\n    // balanceAtTs returns the amount of REIGN that the user currently staked (bonus NOT included)\\n    function balanceAtTs(address user, uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        LibReignStorage.Stake memory stake = stakeAtTs(user, timestamp);\\n\\n        return stake.amount;\\n    }\\n\\n    // balanceAtTs returns the amount of REIGN that the user currently staked (bonus NOT included)\\n    function getEpochUserBalance(address user, uint128 epochId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        LibReignStorage.EpochBalance memory epochBalance = balanceCheckAtEpoch(\\n            user,\\n            epochId\\n        );\\n\\n        return getEpochEffectiveBalance(epochBalance);\\n    }\\n\\n    // this returns the effective balance accounting for user entering the pool after epoch start\\n    function getEpochEffectiveBalance(LibReignStorage.EpochBalance memory c)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            _getEpochBalance(c).mul(c.multiplier).div(BASE_BALANCE_MULTIPLIER);\\n    }\\n\\n    // balanceCheckAtEpoch returns the EpochBalance checkpoint object of the user that was valid at epoch\\n    function balanceCheckAtEpoch(address user, uint128 epochId)\\n        public\\n        view\\n        returns (LibReignStorage.EpochBalance memory)\\n    {\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n        LibReignStorage.EpochBalance[] storage balanceHistory = ds\\n            .userBalanceHistory[user];\\n\\n        if (balanceHistory.length == 0 || epochId < balanceHistory[0].epochId) {\\n            return\\n                LibReignStorage.EpochBalance(\\n                    epochId,\\n                    BASE_BALANCE_MULTIPLIER,\\n                    0,\\n                    0\\n                );\\n        }\\n\\n        uint256 min = 0;\\n        uint256 max = balanceHistory.length - 1;\\n\\n        if (epochId >= balanceHistory[max].epochId) {\\n            return balanceHistory[max];\\n        }\\n\\n        // binary search of the value in the array\\n        while (max > min) {\\n            uint256 mid = (max + min + 1) / 2;\\n            if (balanceHistory[mid].epochId <= epochId) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        return balanceHistory[min];\\n    }\\n\\n    // balanceCheckAtEpoch returns the Stake object of the user that was valid at `timestamp`\\n    function stakeAtTs(address user, uint256 timestamp)\\n        public\\n        view\\n        returns (LibReignStorage.Stake memory)\\n    {\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n        LibReignStorage.Stake[] storage stakeHistory = ds.userStakeHistory[\\n            user\\n        ];\\n\\n        if (stakeHistory.length == 0 || timestamp < stakeHistory[0].timestamp) {\\n            return\\n                LibReignStorage.Stake(\\n                    block.timestamp,\\n                    0,\\n                    block.timestamp,\\n                    address(0),\\n                    BASE_STAKE_MULTIPLIER\\n                );\\n        }\\n\\n        uint256 min = 0;\\n        uint256 max = stakeHistory.length - 1;\\n\\n        if (timestamp >= stakeHistory[max].timestamp) {\\n            return stakeHistory[max];\\n        }\\n\\n        // binary search of the value in the array\\n        while (max > min) {\\n            uint256 mid = (max + min + 1) / 2;\\n            if (stakeHistory[mid].timestamp <= timestamp) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        return stakeHistory[min];\\n    }\\n\\n    // votingPower returns the voting power (bonus included) + delegated voting power for a user at the current block\\n    function votingPower(address user) public view returns (uint256) {\\n        return votingPowerAtTs(user, block.timestamp);\\n    }\\n\\n    // votingPowerAtEpoch returns the voting power (bonus included) + delegated voting power for a user at a point in time\\n    function votingPowerAtTs(address user, uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        LibReignStorage.Stake memory stake = stakeAtTs(user, timestamp);\\n\\n        uint256 ownVotingPower;\\n\\n        // if the user delegated his voting power to another user, then he doesn't have any voting power left\\n        if (stake.delegatedTo != address(0)) {\\n            ownVotingPower = 0;\\n        } else {\\n            ownVotingPower = stake.amount;\\n        }\\n\\n        uint256 delegatedVotingPower = delegatedPowerAtTs(user, timestamp);\\n        return ownVotingPower.add(delegatedVotingPower);\\n    }\\n\\n    // reignStaked returns the total raw amount of REIGN staked at the current block\\n    function reignStaked() public view returns (uint256) {\\n        return reignStakedAtTs(block.timestamp);\\n    }\\n\\n    // reignStakedAtEpoch returns the total raw amount of REIGN users have deposited into the contract\\n    // it does not include any bonus\\n    function reignStakedAtTs(uint256 timestamp) public view returns (uint256) {\\n        return\\n            _checkpointSearch(\\n                LibReignStorage.reignStorage().reignStakedHistory,\\n                timestamp\\n            );\\n    }\\n\\n    // delegatedPower returns the total voting power that a user received from other users\\n    function delegatedPower(address user) public view returns (uint256) {\\n        return delegatedPowerAtTs(user, block.timestamp);\\n    }\\n\\n    // delegatedPowerAtTs returns the total voting power that a user received from other users at a point in time\\n    function delegatedPowerAtTs(address user, uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            _checkpointSearch(\\n                LibReignStorage.reignStorage().delegatedPowerHistory[user],\\n                timestamp\\n            );\\n    }\\n\\n    // same as multiplierAtTs but for the current block timestamp\\n    function stakingBoost(address user) public view returns (uint256) {\\n        return stakingBoostAtEpoch(user, getEpoch());\\n    }\\n\\n    // stakingBoostAtEpoch calculates the multiplier at a given epoch based on the user's stake a the\\n    // given timestamp at which the epoch was initialised\\n    function stakingBoostAtEpoch(address user, uint128 epochId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 epochTime;\\n        // if _initialisedAt[epochId] == 0 then the epoch has not yet been initialized\\n        // this guarantees that no deposits or lock updates happend since last epoch and we can safely use the latest checkpoint\\n        if (epochId == getEpoch() || _initialisedAt[epochId] == 0) {\\n            epochTime = block.timestamp;\\n        } else {\\n            epochTime = _initialisedAt[epochId];\\n        }\\n        LibReignStorage.Stake memory stake = stakeAtTs(user, epochTime);\\n        if (block.timestamp > stake.expiryTimestamp) {\\n            return BASE_STAKE_MULTIPLIER;\\n        }\\n\\n        return stake.stakingBoost;\\n    }\\n\\n    // userLockedUntil returns the timestamp until the user's balance is locked\\n    function userLockedUntil(address user) public view returns (uint256) {\\n        LibReignStorage.Stake memory stake = stakeAtTs(user, block.timestamp);\\n\\n        return stake.expiryTimestamp;\\n    }\\n\\n    // userDelegatedTo returns the address to which a user delegated their voting power; address(0) if not delegated\\n    function userDelegatedTo(address user) public view returns (address) {\\n        LibReignStorage.Stake memory stake = stakeAtTs(user, block.timestamp);\\n\\n        return stake.delegatedTo;\\n    }\\n\\n    // returns the last time a user interacted with the contract by deposit or withdraw\\n    function userLastAction(address user) public view returns (uint256) {\\n        LibReignStorage.Stake memory stake = stakeAtTs(user, block.timestamp);\\n\\n        return stake.timestamp;\\n    }\\n\\n    /*\\n     * Returns the id of the current epoch derived from block.timestamp\\n     */\\n    function getEpoch() public view returns (uint128) {\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n\\n        if (block.timestamp < ds.epoch1Start) {\\n            return 0;\\n        }\\n\\n        return\\n            uint128((block.timestamp - ds.epoch1Start) / ds.epochDuration + 1);\\n    }\\n\\n    /*\\n     * Returns the percentage of time left in the current epoch\\n     */\\n    function currentEpochMultiplier() public view returns (uint128) {\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n        uint128 currentEpoch = getEpoch();\\n        uint256 currentEpochEnd = ds.epoch1Start +\\n            currentEpoch *\\n            ds.epochDuration;\\n        uint256 timeLeft = currentEpochEnd - block.timestamp;\\n        uint128 multiplier = uint128(\\n            (timeLeft * BASE_BALANCE_MULTIPLIER) / ds.epochDuration\\n        );\\n\\n        return multiplier;\\n    }\\n\\n    function computeNewMultiplier(\\n        uint256 prevBalance,\\n        uint128 prevMultiplier,\\n        uint256 amount,\\n        uint128 currentMultiplier\\n    ) public pure returns (uint128) {\\n        uint256 prevAmount = prevBalance.mul(prevMultiplier).div(\\n            BASE_BALANCE_MULTIPLIER\\n        );\\n        uint256 addAmount = amount.mul(currentMultiplier).div(\\n            BASE_BALANCE_MULTIPLIER\\n        );\\n        uint128 newMultiplier = uint128(\\n            prevAmount.add(addAmount).mul(BASE_BALANCE_MULTIPLIER).div(\\n                prevBalance.add(amount)\\n            )\\n        );\\n\\n        return newMultiplier;\\n    }\\n\\n    function epochIsInitialized(uint128 epochId) public view returns (bool) {\\n        return _isInitialized[epochId];\\n    }\\n\\n    /*\\n     *   INTERNAL\\n     */\\n\\n    // _updateStake manages an array of stake checkpoints\\n    // if there's already a checkpoint for the same timestamp, the amount is updated\\n    // otherwise, a new checkpoint is inserted\\n    function _updateStake(\\n        LibReignStorage.Stake[] storage checkpoints,\\n        uint256 amount\\n    ) internal {\\n        if (checkpoints.length == 0) {\\n            checkpoints.push(\\n                LibReignStorage.Stake(\\n                    block.timestamp,\\n                    amount,\\n                    block.timestamp,\\n                    address(0),\\n                    BASE_STAKE_MULTIPLIER\\n                )\\n            );\\n        } else {\\n            LibReignStorage.Stake storage old = checkpoints[\\n                checkpoints.length - 1\\n            ];\\n\\n            if (old.timestamp == block.timestamp) {\\n                old.amount = amount;\\n            } else {\\n                checkpoints.push(\\n                    LibReignStorage.Stake(\\n                        block.timestamp,\\n                        amount,\\n                        old.expiryTimestamp,\\n                        old.delegatedTo,\\n                        old.stakingBoost\\n                    )\\n                );\\n            }\\n        }\\n    }\\n\\n    // _increaseEpochBalance manages an array of checkpoints\\n    // if there's already a checkpoint for the same timestamp, the amount is updated\\n    // otherwise, a new checkpoint is inserted\\n    function _increaseEpochBalance(\\n        LibReignStorage.EpochBalance[] storage epochBalances,\\n        uint256 amount\\n    ) internal {\\n        uint128 currentEpoch = getEpoch();\\n        uint128 currentMultiplier = currentEpochMultiplier();\\n        if (!epochIsInitialized(currentEpoch)) {\\n            _initEpoch(currentEpoch);\\n        }\\n\\n        // if there's no checkpoint yet, it means the user didn't have any activity\\n        // we want to store checkpoints both for the current epoch and next epoch because\\n        // if a user does a withdraw, the current epoch can also be modified and\\n        // we don't want to insert another checkpoint in the middle of the array as that could be expensive\\n        if (epochBalances.length == 0) {\\n            epochBalances.push(\\n                LibReignStorage.EpochBalance(\\n                    currentEpoch,\\n                    currentMultiplier,\\n                    0,\\n                    amount\\n                )\\n            );\\n\\n            epochBalances.push(\\n                LibReignStorage.EpochBalance(\\n                    currentEpoch + 1, //for next epoch\\n                    BASE_BALANCE_MULTIPLIER,\\n                    amount, //start balance is amount\\n                    0 // new deposit of amount is made\\n                )\\n            );\\n        } else {\\n            LibReignStorage.EpochBalance storage old = epochBalances[\\n                epochBalances.length - 1\\n            ];\\n            uint256 lastIndex = epochBalances.length - 1;\\n\\n            // the last action happened in an older epoch (e.g. a deposit in epoch 3, current epoch is >=5)\\n            // add a checkpoint for the previous epoch and the current one\\n            if (old.epochId < currentEpoch) {\\n                uint128 multiplier = computeNewMultiplier(\\n                    _getEpochBalance(old),\\n                    BASE_BALANCE_MULTIPLIER,\\n                    amount,\\n                    currentMultiplier\\n                );\\n                //update the stake with new multiplier and amount\\n                epochBalances.push(\\n                    LibReignStorage.EpochBalance(\\n                        currentEpoch,\\n                        multiplier,\\n                        _getEpochBalance(old),\\n                        amount\\n                    )\\n                );\\n\\n                //add a fresh checkpoint for next epoch\\n                epochBalances.push(\\n                    LibReignStorage.EpochBalance(\\n                        currentEpoch + 1,\\n                        BASE_BALANCE_MULTIPLIER,\\n                        _balances[msg.sender],\\n                        0\\n                    )\\n                );\\n            }\\n            // the last action happened in the current epoch, update values and add a new checkpoint\\n            // for the current epoch\\n            else if (old.epochId == currentEpoch) {\\n                old.multiplier = computeNewMultiplier(\\n                    _getEpochBalance(old),\\n                    old.multiplier,\\n                    amount,\\n                    currentMultiplier\\n                );\\n                old.newDeposits = old.newDeposits.add(amount);\\n\\n                epochBalances.push(\\n                    LibReignStorage.EpochBalance(\\n                        currentEpoch + 1,\\n                        BASE_BALANCE_MULTIPLIER,\\n                        _balances[msg.sender],\\n                        0\\n                    )\\n                );\\n            }\\n            // the last action happened in the previous epoch, just upate the value\\n            else {\\n                if (\\n                    lastIndex >= 1 &&\\n                    epochBalances[lastIndex - 1].epochId == currentEpoch\\n                ) {\\n                    epochBalances[lastIndex - 1]\\n                        .multiplier = computeNewMultiplier(\\n                        _getEpochBalance(epochBalances[lastIndex - 1]),\\n                        epochBalances[lastIndex - 1].multiplier,\\n                        amount,\\n                        currentMultiplier\\n                    );\\n                    epochBalances[lastIndex - 1].newDeposits = epochBalances[\\n                        lastIndex - 1\\n                    ].newDeposits.add(amount);\\n                }\\n\\n                epochBalances[lastIndex].startBalance = _balances[msg.sender];\\n            }\\n        }\\n    }\\n\\n    // _decreaseEpochBalance manages an array of checkpoints\\n    // if there's already a checkpoint for the same timestamp, the amount is updated\\n    // otherwise, a new checkpoint is inserted\\n    function _decreaseEpochBalance(\\n        LibReignStorage.EpochBalance[] storage epochBalances,\\n        uint256 amount\\n    ) internal {\\n        uint128 currentEpoch = getEpoch();\\n\\n        if (!epochIsInitialized(currentEpoch)) {\\n            _initEpoch(currentEpoch);\\n        }\\n\\n        // we can't have a situation in which there is a withdraw with no checkpoint\\n\\n        LibReignStorage.EpochBalance storage old = epochBalances[\\n            epochBalances.length - 1\\n        ];\\n        uint256 lastIndex = epochBalances.length - 1;\\n\\n        // the last action happened in an older epoch (e.g. a deposit in epoch 3, current epoch is >=5)\\n        // add a checkpoint for the previous epoch and the current one\\n        if (old.epochId < currentEpoch) {\\n            //update the stake with new multiplier and amount\\n            epochBalances.push(\\n                LibReignStorage.EpochBalance(\\n                    currentEpoch,\\n                    BASE_BALANCE_MULTIPLIER,\\n                    _balances[msg.sender],\\n                    0\\n                )\\n            );\\n        }\\n        // there was a deposit in the current epoch\\n        else if (old.epochId == currentEpoch) {\\n            old.multiplier = BASE_BALANCE_MULTIPLIER;\\n            old.startBalance = _balances[msg.sender];\\n            old.newDeposits = 0;\\n        }\\n        // there was a deposit in the `epochId - 1` epoch => we have a checkpoint for the current epoch\\n        else {\\n            LibReignStorage.EpochBalance\\n                storage currentEpochCheckpoint = epochBalances[lastIndex - 1];\\n\\n            uint256 balanceBefore = getEpochEffectiveBalance(\\n                currentEpochCheckpoint\\n            );\\n            // in case of withdraw, we have 2 branches:\\n            // 1. the user withdraws less than he added in the current epoch\\n            // 2. the user withdraws more than he added in the current epoch (including 0)\\n            if (amount < currentEpochCheckpoint.newDeposits) {\\n                uint128 avgDepositMultiplier = uint128(\\n                    balanceBefore\\n                        .sub(currentEpochCheckpoint.startBalance)\\n                        .mul(BASE_BALANCE_MULTIPLIER)\\n                        .div(currentEpochCheckpoint.newDeposits)\\n                );\\n\\n                currentEpochCheckpoint.newDeposits = currentEpochCheckpoint\\n                    .newDeposits\\n                    .sub(amount);\\n\\n                currentEpochCheckpoint.multiplier = computeNewMultiplier(\\n                    currentEpochCheckpoint.startBalance,\\n                    BASE_BALANCE_MULTIPLIER,\\n                    currentEpochCheckpoint.newDeposits,\\n                    avgDepositMultiplier\\n                );\\n            } else {\\n                currentEpochCheckpoint.startBalance = currentEpochCheckpoint\\n                    .startBalance\\n                    .sub(amount.sub(currentEpochCheckpoint.newDeposits));\\n                currentEpochCheckpoint.newDeposits = 0;\\n                currentEpochCheckpoint.multiplier = BASE_BALANCE_MULTIPLIER;\\n            }\\n\\n            epochBalances[lastIndex].startBalance = _balances[msg.sender];\\n        }\\n    }\\n\\n    // _updateUserLock updates the expiry timestamp on the user's stake\\n    // it assumes that if the user already has a balance, which is checked for in the lock function\\n    // then there must be at least 1 checkpoint\\n    function _updateUserLock(\\n        LibReignStorage.Stake[] storage checkpoints,\\n        uint256 expiryTimestamp\\n    ) internal {\\n        LibReignStorage.Stake storage old = checkpoints[checkpoints.length - 1];\\n\\n        if (old.timestamp < block.timestamp) {\\n            checkpoints.push(\\n                LibReignStorage.Stake(\\n                    block.timestamp,\\n                    old.amount,\\n                    expiryTimestamp,\\n                    old.delegatedTo,\\n                    _lockingBoost(block.timestamp, expiryTimestamp)\\n                )\\n            );\\n        } else {\\n            old.expiryTimestamp = expiryTimestamp;\\n            old.stakingBoost = _lockingBoost(block.timestamp, expiryTimestamp);\\n        }\\n    }\\n\\n    // _updateUserDelegatedTo updates the delegateTo property on the user's stake\\n    // it assumes that if the user already has a balance, which is checked for in the delegate function\\n    // then there must be at least 1 checkpoint\\n    function _updateUserDelegatedTo(\\n        LibReignStorage.Stake[] storage checkpoints,\\n        address to\\n    ) internal {\\n        LibReignStorage.Stake storage old = checkpoints[checkpoints.length - 1];\\n\\n        if (old.timestamp < block.timestamp) {\\n            checkpoints.push(\\n                LibReignStorage.Stake(\\n                    block.timestamp,\\n                    old.amount,\\n                    old.expiryTimestamp,\\n                    to,\\n                    old.stakingBoost\\n                )\\n            );\\n        } else {\\n            old.delegatedTo = to;\\n        }\\n    }\\n\\n    // _updateDelegatedPower updates the power delegated TO the user in the checkpoints history\\n    function _updateDelegatedPower(\\n        LibReignStorage.Checkpoint[] storage checkpoints,\\n        uint256 amount\\n    ) internal {\\n        if (\\n            checkpoints.length == 0 ||\\n            checkpoints[checkpoints.length - 1].timestamp < block.timestamp\\n        ) {\\n            checkpoints.push(\\n                LibReignStorage.Checkpoint(block.timestamp, amount)\\n            );\\n        } else {\\n            LibReignStorage.Checkpoint storage old = checkpoints[\\n                checkpoints.length - 1\\n            ];\\n            old.amount = amount;\\n        }\\n    }\\n\\n    // _updateLockedReign stores the new `amount` into the REIGN locked history\\n    function _updateLockedReign(uint256 amount) internal {\\n        LibReignStorage.Storage storage ds = LibReignStorage.reignStorage();\\n\\n        if (\\n            ds.reignStakedHistory.length == 0 ||\\n            ds.reignStakedHistory[ds.reignStakedHistory.length - 1].timestamp <\\n            block.timestamp\\n        ) {\\n            ds.reignStakedHistory.push(\\n                LibReignStorage.Checkpoint(block.timestamp, amount)\\n            );\\n        } else {\\n            LibReignStorage.Checkpoint storage old = ds.reignStakedHistory[\\n                ds.reignStakedHistory.length - 1\\n            ];\\n            old.amount = amount;\\n        }\\n    }\\n\\n    /*\\n     *   INTERNAL READ\\n     */\\n\\n    // _stakeMultiplier calculates the multiplier for the given lockup\\n    function _lockingBoost(uint256 from, uint256 to)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 diff = to.sub(from); // underflow is checked for in lock()\\n\\n        // for two year lock(MAX_LOCK) users get 50% boost, for 1 year they get 25%\\n        return (\\n            BASE_STAKE_MULTIPLIER.add(\\n                (diff.mul(BASE_STAKE_MULTIPLIER).div(MAX_LOCK)).div(2)\\n            )\\n        );\\n    }\\n\\n    //initialises and epoch, and stores the init time\\n    function _initEpoch(uint128 epochId) internal {\\n        _isInitialized[epochId] = true;\\n        _initialisedAt[epochId] = block.timestamp;\\n\\n        emit InitEpoch(msg.sender, epochId);\\n    }\\n\\n    function _getEpochBalance(LibReignStorage.EpochBalance memory c)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return c.startBalance.add(c.newDeposits);\\n    }\\n\\n    // _checkpointSearch executes a binary search on a list of checkpoints that's sorted chronologically\\n    // looking for the closest checkpoint that matches the specified timestamp\\n    function _checkpointSearch(\\n        LibReignStorage.Checkpoint[] storage checkpoints,\\n        uint256 timestamp\\n    ) internal view returns (uint256) {\\n        if (checkpoints.length == 0 || timestamp < checkpoints[0].timestamp) {\\n            return 0;\\n        }\\n\\n        uint256 min = 0;\\n        uint256 max = checkpoints.length - 1;\\n\\n        if (timestamp >= checkpoints[max].timestamp) {\\n            return checkpoints[max].amount;\\n        }\\n\\n        // binary search of the value in the array\\n        while (max > min) {\\n            uint256 mid = (max + min + 1) / 2;\\n            if (checkpoints[mid].timestamp <= timestamp) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        return checkpoints[min].amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReign.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/LibReignStorage.sol\\\";\\n\\ninterface IReign {\\n    function BASE_MULTIPLIER() external view returns (uint256);\\n\\n    // deposit allows a user to add more bond to his staked balance\\n    function deposit(uint256 amount) external;\\n\\n    // withdraw allows a user to withdraw funds if the balance is not locked\\n    function withdraw(uint256 amount) external;\\n\\n    // lock a user's currently staked balance until timestamp & add the bonus to his voting power\\n    function lock(uint256 timestamp) external;\\n\\n    // delegate allows a user to delegate his voting power to another user\\n    function delegate(address to) external;\\n\\n    // stopDelegate allows a user to take back the delegated voting power\\n    function stopDelegate() external;\\n\\n    // lock the balance of a proposal creator until the voting ends; only callable by DAO\\n    function lockCreatorBalance(address user, uint256 timestamp) external;\\n\\n    // balanceOf returns the current BOND balance of a user (bonus not included)\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    // balanceAtTs returns the amount of BOND that the user currently staked (bonus NOT included)\\n    function balanceAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // stakeAtTs returns the Stake object of the user that was valid at `timestamp`\\n    function stakeAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (LibReignStorage.Stake memory);\\n\\n    // votingPower returns the voting power (bonus included) + delegated voting power for a user at the current block\\n    function votingPower(address user) external view returns (uint256);\\n\\n    // votingPowerAtTs returns the voting power (bonus included) + delegated voting power for a user at a point in time\\n    function votingPowerAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // bondStaked returns the total raw amount of BOND staked at the current block\\n    function reignStaked() external view returns (uint256);\\n\\n    // reignStakedAtTs returns the total raw amount of BOND users have deposited into the contract\\n    // it does not include any bonus\\n    function reignStakedAtTs(uint256 timestamp) external view returns (uint256);\\n\\n    // delegatedPower returns the total voting power that a user received from other users\\n    function delegatedPower(address user) external view returns (uint256);\\n\\n    // delegatedPowerAtTs returns the total voting power that a user received from other users at a point in time\\n    function delegatedPowerAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // stakingBoost calculates the multiplier on the user's stake at the current timestamp\\n    function stakingBoost(address user) external view returns (uint256);\\n\\n    // stackingBoostAtTs calculates the multiplier at a given timestamp based on the user's stake a the given timestamp\\n    function stackingBoostAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // userLockedUntil returns the timestamp until the user's balance is locked\\n    function userLockedUntil(address user) external view returns (uint256);\\n\\n    // userDidDelegate returns the address to which a user delegated their voting power; address(0) if not delegated\\n    function userDelegatedTo(address user) external view returns (address);\\n\\n    // returns the last timestamp in which the user intercated with the staking contarct\\n    function userLastAction(address user) external view returns (uint256);\\n\\n    // reignCirculatingSupply returns the current circulating supply of BOND\\n    function reignCirculatingSupply() external view returns (uint256);\\n\\n    function getEpochDuration() external view returns (uint256);\\n\\n    function getEpoch1Start() external view returns (uint256);\\n\\n    function getCurrentEpoch() external view returns (uint128);\\n\\n    function stakingBoostAtEpoch(address, uint128)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getEpochUserBalance(address, uint128)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibReignStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary LibReignStorage {\\n\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"org.sovreign.reign.storage\\\");\\n\\n    struct Checkpoint {\\n        uint256 timestamp;\\n        uint256 amount;\\n    }\\n\\n    struct EpochBalance {\\n        uint128 epochId;\\n        uint128 multiplier;\\n        uint256 startBalance;\\n        uint256 newDeposits;\\n    }\\n\\n    struct Stake {\\n        uint256 timestamp;\\n        uint256 amount;\\n        uint256 expiryTimestamp;\\n        address delegatedTo;\\n        uint256 stakingBoost;\\n    }\\n\\n    struct Storage {\\n        bool initialized;\\n        // mapping of user address to history of Stake objects\\n        // every user action creates a new object in the history\\n        mapping(address => Stake[]) userStakeHistory;\\n        mapping(address => EpochBalance[]) userBalanceHistory;\\n        mapping(address => uint128) lastWithdrawEpochId;\\n        // array of reign staked Checkpoint\\n        // deposits/withdrawals create a new object in the history (max one per block)\\n        Checkpoint[] reignStakedHistory;\\n        // mapping of user address to history of delegated power\\n        // every delegate/stopDelegate call create a new checkpoint (max one per block)\\n        mapping(address => Checkpoint[]) delegatedPowerHistory;\\n        IERC20 reign; // the reign Token\\n        uint256 epoch1Start;\\n        uint256 epochDuration;\\n    }\\n\\n    function reignStorage() internal pure returns (Storage storage ds) {\\n        bytes32 position = STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/libraries/LibOwnership.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibDiamondStorage.sol\\\";\\n\\nlibrary LibOwnership {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n\\n        address previousOwner = ds.contractOwner;\\n        require(previousOwner != _newOwner, \\\"Previous owner and new owner must be different\\\");\\n\\n        ds.contractOwner = _newOwner;\\n\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = LibDiamondStorage.diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() view internal {\\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \\\"Must be contract owner\\\");\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \\\"Must be contract owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/libraries/LibDiamondStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct Facet {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        // function selector => facet address and selector position in selectors array\\n        mapping(bytes4 => Facet) facets;\\n        bytes4[] selectors;\\n\\n        // ERC165\\n        mapping(bytes4 => bool) supportedInterfaces;\\n\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to_newDelegatedPower\",\"type\":\"uint256\"}],\"name\":\"DelegatedPowerDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to_newDelegatedPower\",\"type\":\"uint256\"}],\"name\":\"DelegatedPowerIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"InitEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLeft\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_BALANCE_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_STAKE_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"balanceAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"balanceCheckAtEpoch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"multiplier\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"startBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDeposits\",\"type\":\"uint256\"}],\"internalType\":\"struct LibReignStorage.EpochBalance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prevBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"prevMultiplier\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"currentMultiplier\",\"type\":\"uint128\"}],\"name\":\"computeNewMultiplier\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpochMultiplier\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"delegatedPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"delegatedPowerAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"depositAndLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"epochIsInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEpoch\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"getEpochUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reignToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epoch1Start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_epochDuration\",\"type\":\"uint256\"}],\"name\":\"initReign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reignStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"reignStakedAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"stakeAtTs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegatedTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingBoost\",\"type\":\"uint256\"}],\"internalType\":\"struct LibReignStorage.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"stakingBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"stakingBoostAtEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userDelegatedTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userLastAction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userLockedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"votingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"votingPowerAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ReignFacet","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}