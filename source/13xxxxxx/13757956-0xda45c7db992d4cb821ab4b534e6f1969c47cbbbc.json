{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ChickenNoodleSoup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\\nimport 'hardhat-deploy/solc_0.8/proxy/Proxied.sol';\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport './libraries/VRFLibrary.sol';\\n\\nimport './interfaces/IEgg.sol';\\nimport './interfaces/ITraits.sol';\\nimport './interfaces/IChickenNoodle.sol';\\nimport './interfaces/IFarm.sol';\\nimport './interfaces/IRandomnessConsumer.sol';\\n\\ncontract ChickenNoodleSoup is\\n    IRandomnessConsumer,\\n    Proxied,\\n    PausableUpgradeable\\n{\\n    using VRFLibrary for VRFLibrary.VRFData;\\n\\n    // number of tokens have been processed so far\\n    uint16 public processed;\\n\\n    // mint price\\n    uint256 public constant MINT_PRICE = .069420 ether;\\n\\n    // mapping from hashed(tokenTrait) to the tokenId it's associated with\\n    // used to ensure there are no duplicates\\n    mapping(uint256 => uint256) public existingCombinations;\\n\\n    // list of probabilities for each trait type\\n    // 0 - 5 are common, 6 is place holder for Chicken Tier, 7 is Noodles tier\\n    uint8[][10] public rarities;\\n    // list of aliases for Walker's Alias algorithm\\n    // 0 - 5 are common, 6 is place holder for Chicken Tier, 7 is Noodles tier\\n    uint8[][10] public aliases;\\n\\n    // reference to the Farm for choosing random Noodle thieves\\n    IFarm public farm;\\n    // reference to $EGG for burning on mint\\n    IEgg public egg;\\n    // reference to ChickenNoodle for minting\\n    IChickenNoodle public chickenNoodle;\\n\\n    VRFLibrary.VRFData private vrf;\\n\\n    mapping(uint256 => bytes32) internal mintBlockhash;\\n\\n    uint256 randomnessInterval;\\n    uint256 randomnessMintsNeeded;\\n    uint256 randomnessMintsMinimum;\\n\\n    // /**\\n    //  * initializes contract and rarity tables\\n    //  */\\n    // constructor(address _egg, address _chickenNoodle) {\\n    //     initialize(_egg, _chickenNoodle);\\n    // }\\n\\n    /**\\n     * initializes contract and rarity tables\\n     */\\n    function initialize(address _egg, address _chickenNoodle) public proxied {\\n        __Pausable_init();\\n\\n        egg = IEgg(_egg);\\n        chickenNoodle = IChickenNoodle(_chickenNoodle);\\n\\n        randomnessInterval = 1 hours;\\n        randomnessMintsNeeded = 500;\\n        randomnessMintsMinimum = 0;\\n\\n        // I know this looks weird but it saves users gas by making lookup O(1)\\n        // A.J. Walker's Alias Algorithm\\n\\n        // Common\\n        // backgrounds\\n        rarities[0] = [\\n            221,\\n            100,\\n            181,\\n            140,\\n            224,\\n            147,\\n            84,\\n            228,\\n            140,\\n            224,\\n            250,\\n            160,\\n            241,\\n            207,\\n            173,\\n            84,\\n            254,\\n            220,\\n            196,\\n            140,\\n            168,\\n            252,\\n            140,\\n            183,\\n            236,\\n            252,\\n            224,\\n            254,\\n            255\\n        ]; //[15, 50, 200, 250, 255];\\n        aliases[0] = [\\n            1,\\n            2,\\n            5,\\n            0,\\n            1,\\n            7,\\n            1,\\n            10,\\n            5,\\n            10,\\n            11,\\n            12,\\n            13,\\n            14,\\n            16,\\n            11,\\n            17,\\n            23,\\n            13,\\n            14,\\n            17,\\n            23,\\n            23,\\n            24,\\n            27,\\n            27,\\n            28,\\n            28,\\n            28\\n        ];\\n        // mouthAccessories\\n        rarities[1] = [\\n            221,\\n            100,\\n            181,\\n            140,\\n            224,\\n            147,\\n            84,\\n            228,\\n            140,\\n            224,\\n            250,\\n            160,\\n            241,\\n            207,\\n            173,\\n            84,\\n            254,\\n            220,\\n            196,\\n            140,\\n            168,\\n            252,\\n            140,\\n            170,\\n            183,\\n            236,\\n            252,\\n            224,\\n            250,\\n            254,\\n            255\\n        ];\\n        aliases[1] = [\\n            1,\\n            2,\\n            5,\\n            0,\\n            1,\\n            7,\\n            1,\\n            10,\\n            5,\\n            10,\\n            11,\\n            12,\\n            13,\\n            14,\\n            16,\\n            11,\\n            17,\\n            23,\\n            13,\\n            14,\\n            17,\\n            20,\\n            23,\\n            23,\\n            24,\\n            27,\\n            27,\\n            28,\\n            28,\\n            29,\\n            29\\n        ];\\n\\n        // pupils\\n        rarities[2] = [\\n            221,\\n            100,\\n            181,\\n            140,\\n            224,\\n            147,\\n            84,\\n            228,\\n            140,\\n            224,\\n            250,\\n            160,\\n            241,\\n            207,\\n            173,\\n            90,\\n            84,\\n            254,\\n            220,\\n            196,\\n            140,\\n            168,\\n            252,\\n            140,\\n            180,\\n            200,\\n            183,\\n            236,\\n            252,\\n            224,\\n            254,\\n            255\\n        ];\\n        aliases[2] = [\\n            1,\\n            2,\\n            5,\\n            0,\\n            1,\\n            7,\\n            1,\\n            10,\\n            5,\\n            10,\\n            11,\\n            12,\\n            13,\\n            14,\\n            16,\\n            11,\\n            17,\\n            23,\\n            13,\\n            14,\\n            17,\\n            23,\\n            23,\\n            24,\\n            27,\\n            27,\\n            28,\\n            28,\\n            29,\\n            29,\\n            30,\\n            31\\n        ];\\n\\n        // hats\\n        rarities[3] = [\\n            221,\\n            100,\\n            181,\\n            140,\\n            224,\\n            147,\\n            84,\\n            228,\\n            140,\\n            224,\\n            250,\\n            160,\\n            241,\\n            207,\\n            173,\\n            84,\\n            254,\\n            220,\\n            196,\\n            140,\\n            168,\\n            252,\\n            140,\\n            170,\\n            183,\\n            236,\\n            252,\\n            224,\\n            250,\\n            254,\\n            255,\\n            221,\\n            100,\\n            181,\\n            140,\\n            224,\\n            147,\\n            84,\\n            228,\\n            140,\\n            224,\\n            250,\\n            160,\\n            241,\\n            207,\\n            173,\\n            84,\\n            154\\n        ];\\n        aliases[3] = [\\n            1,\\n            2,\\n            5,\\n            0,\\n            1,\\n            7,\\n            1,\\n            10,\\n            5,\\n            10,\\n            11,\\n            12,\\n            13,\\n            14,\\n            16,\\n            11,\\n            17,\\n            23,\\n            13,\\n            14,\\n            17,\\n            20,\\n            23,\\n            23,\\n            24,\\n            27,\\n            27,\\n            28,\\n            28,\\n            29,\\n            29,\\n            31,\\n            32,\\n            35,\\n            30,\\n            31,\\n            37,\\n            31,\\n            40,\\n            35,\\n            40,\\n            41,\\n            42,\\n            43,\\n            44,\\n            46,\\n            41,\\n            47\\n        ];\\n\\n        // bodyAccessories\\n        rarities[4] = [\\n            221,\\n            100,\\n            181,\\n            140,\\n            224,\\n            147,\\n            84,\\n            228,\\n            140,\\n            224,\\n            250,\\n            160,\\n            241,\\n            207,\\n            173,\\n            84,\\n            254,\\n            220,\\n            196,\\n            140,\\n            168,\\n            252,\\n            140,\\n            170,\\n            183,\\n            236,\\n            252,\\n            224,\\n            250,\\n            254,\\n            255,\\n            221,\\n            100,\\n            181,\\n            140,\\n            224,\\n            147,\\n            84,\\n            228,\\n            140,\\n            224,\\n            250,\\n            160,\\n            241,\\n            207,\\n            173,\\n            84,\\n            254,\\n            220,\\n            196,\\n            140,\\n            168,\\n            252,\\n            140,\\n            170,\\n            183,\\n            236,\\n            252,\\n            224,\\n            250,\\n            254,\\n            255,\\n            60,\\n            120,\\n            185,\\n            210,\\n            194,\\n            103,\\n            209,\\n            100,\\n            169,\\n            178\\n        ];\\n        aliases[4] = [\\n            1,\\n            2,\\n            5,\\n            0,\\n            1,\\n            7,\\n            1,\\n            10,\\n            5,\\n            10,\\n            11,\\n            12,\\n            13,\\n            14,\\n            16,\\n            11,\\n            17,\\n            23,\\n            13,\\n            14,\\n            17,\\n            20,\\n            23,\\n            23,\\n            24,\\n            27,\\n            27,\\n            28,\\n            28,\\n            29,\\n            29,\\n            31,\\n            32,\\n            35,\\n            30,\\n            31,\\n            37,\\n            31,\\n            40,\\n            35,\\n            40,\\n            41,\\n            42,\\n            43,\\n            44,\\n            46,\\n            41,\\n            47,\\n            53,\\n            43,\\n            44,\\n            47,\\n            50,\\n            53,\\n            53,\\n            54,\\n            57,\\n            57,\\n            58,\\n            58,\\n            59,\\n            59,\\n            60,\\n            69,\\n            64,\\n            61,\\n            70,\\n            67,\\n            66,\\n            68,\\n            65,\\n            71\\n        ];\\n\\n        // tier\\n        rarities[5] = [8, 160, 73, 255];\\n        aliases[5] = [2, 3, 3, 3];\\n\\n        // snakeBodies Tier 0:5-1:4\\n        rarities[6] = [185, 215, 240, 190];\\n        aliases[6] = [1, 2, 2, 0];\\n\\n        // snakeBodies Tier 0:4-1:3\\n        rarities[7] = [135, 215, 240, 185];\\n        aliases[7] = [1, 2, 1, 0];\\n\\n        // snakeBodies Tier 0:3-1:2\\n        rarities[8] = [190, 215, 240, 100, 110, 135, 160, 185];\\n        aliases[8] = [1, 2, 4, 0, 5, 6, 7, 7];\\n\\n        // snakeBodies Tier 0:2-1:1\\n        rarities[9] = [190, 215, 240, 100, 110, 135, 160, 185];\\n        aliases[9] = [1, 2, 4, 0, 5, 6, 7, 7];\\n    }\\n\\n    /** EXTERNAL */\\n    function processingStats()\\n        public\\n        view\\n        returns (\\n            bool requestPending,\\n            uint256 maxIdAvailableToProcess,\\n            uint256 readyForProcessing,\\n            uint256 waitingToBeProcessed,\\n            uint256 timeTellNextRandomnessRequest\\n        )\\n    {\\n        return\\n            vrf.processingStats(\\n                chickenNoodle.totalSupply(),\\n                processed,\\n                randomnessInterval\\n            );\\n    }\\n\\n    /**\\n     * mint a token - 90% Chicken, 10% Noodles\\n     * The first 20% cost ETHER to claim, the remaining cost $EGG\\n     */\\n    function mint(uint256 amount) external payable whenNotPaused {\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n        uint256 maxTokens = chickenNoodle.MAX_TOKENS();\\n        uint256 paidTokens = chickenNoodle.PAID_TOKENS();\\n\\n        require(tx.origin == _msgSender(), 'Only EOA');\\n        require(supply + amount <= maxTokens, 'All tokens minted');\\n        require(amount > 0 && amount <= 10, 'Invalid mint amount');\\n        if (supply < paidTokens) {\\n            require(\\n                supply + amount <= paidTokens,\\n                'All tokens on-sale already sold'\\n            );\\n            require(amount * MINT_PRICE == msg.value, 'Invalid payment amount');\\n        } else {\\n            require(msg.value == 0, 'Egg needed not ETHER');\\n        }\\n\\n        uint256 totalEggCost = 0;\\n        for (uint256 i = 0; i < amount; i++) {\\n            totalEggCost += mintCost(supply + 1 + i);\\n        }\\n\\n        if (totalEggCost > 0) {\\n            egg.burn(_msgSender(), totalEggCost);\\n            egg.mint(address(this), totalEggCost / 100);\\n        }\\n\\n        for (uint256 i = 0; i < amount; i++) {\\n            _processNext();\\n\\n            supply++;\\n            mintBlockhash[supply] = blockhash(block.number - 1);\\n            chickenNoodle.mint(_msgSender(), supply);\\n        }\\n\\n        checkRandomness(false);\\n    }\\n\\n    /**\\n     * the first 20% are paid in ETH\\n     * the next 20% are 20000 $EGG\\n     * the next 40% are 40000 $EGG\\n     * the final 20% are 80000 $EGG\\n     * @param tokenId the ID to check the cost of to mint\\n     * @return the cost of the given token ID\\n     */\\n    function mintCost(uint256 tokenId) public view returns (uint256) {\\n        if (tokenId <= chickenNoodle.PAID_TOKENS()) return 0;\\n        if (tokenId <= (chickenNoodle.MAX_TOKENS() * 2) / 5) return 20000 ether;\\n        if (tokenId <= (chickenNoodle.MAX_TOKENS() * 4) / 5) return 40000 ether;\\n        return 80000 ether;\\n    }\\n\\n    function checkRandomness(bool force) public {\\n        force = force && _msgSender() == _proxyAdmin();\\n\\n        if (force) {\\n            vrf.newRequest();\\n        } else {\\n            vrf.checkRandomness(\\n                chickenNoodle.totalSupply(),\\n                processed,\\n                randomnessInterval,\\n                randomnessMintsNeeded,\\n                randomnessMintsMinimum\\n            );\\n        }\\n    }\\n\\n    function process(uint256 amount) external override {\\n        for (uint256 i = 0; i < amount; i++) {\\n            if (!_processNext()) break;\\n        }\\n    }\\n\\n    function setRandomnessResult(bytes32 requestId, uint256 randomness)\\n        external\\n        override\\n    {\\n        vrf.setRequestResults(\\n            requestId,\\n            randomness,\\n            chickenNoodle.totalSupply()\\n        );\\n    }\\n\\n    function processNext() external override returns (bool) {\\n        return _processNext();\\n    }\\n\\n    /** INTERNAL */\\n\\n    function _processNext() internal returns (bool) {\\n        uint16 tokenId = processed + 1;\\n\\n        (bool available, uint256 randomness) = vrf.randomnessForId(tokenId);\\n\\n        if (available) {\\n            uint256 seed = random(tokenId, mintBlockhash[tokenId], randomness);\\n            IChickenNoodle.ChickenNoodleTraits memory t = generate(\\n                tokenId,\\n                seed\\n            );\\n\\n            address recipient = selectRecipient(tokenId, seed);\\n\\n            delete mintBlockhash[tokenId];\\n            processed++;\\n\\n            chickenNoodle.finalize(tokenId, t, recipient);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * generates traits for a specific token, checking to make sure it's unique\\n     * @param tokenId the id of the token to generate traits for\\n     * @param seed a pseudorandom 256 bit number to derive traits from\\n     * @return t - a struct of traits for the given token ID\\n     */\\n    function generate(uint16 tokenId, uint256 seed)\\n        internal\\n        returns (IChickenNoodle.ChickenNoodleTraits memory t)\\n    {\\n        t = selectTraits(tokenId, seed);\\n\\n        if (existingCombinations[structToHash(t)] == 0) {\\n            existingCombinations[structToHash(t)] = tokenId;\\n            return t;\\n        }\\n\\n        return generate(tokenId, random(tokenId, mintBlockhash[tokenId], seed));\\n    }\\n\\n    /** ADMIN */\\n\\n    /**\\n     * called after deployment so that the contract can get random values\\n     * @param _randomnessProvider the address of the new RandomnessProvider\\n     */\\n    function setRandomnessProvider(address _randomnessProvider)\\n        external\\n        override\\n        onlyProxyAdmin\\n    {\\n        vrf.setRandomnessProvider(_randomnessProvider);\\n    }\\n\\n    /**\\n     * called to upoate fee to get randomness\\n     * @param _fee the fee required for getting randomness\\n     */\\n    function updateRandomnessFee(uint256 _fee)\\n        external\\n        override\\n        onlyProxyAdmin\\n    {\\n        vrf.updateFee(_fee);\\n    }\\n\\n    /**\\n     * allows owner to rescue LINK tokens\\n     */\\n    function rescueLINK(uint256 amount) external override onlyProxyAdmin {\\n        vrf.rescueLINK(_proxyAdmin(), amount);\\n    }\\n\\n    /**\\n     * called after deployment so that the contract can get random noodle thieves\\n     * @param _farm the address of the HenHouse\\n     */\\n    function setFarm(address _farm) external onlyProxyAdmin {\\n        farm = IFarm(_farm);\\n    }\\n\\n    /**\\n     * allows owner to withdraw funds from minting\\n     */\\n    function withdraw() external onlyProxyAdmin {\\n        payable(_proxyAdmin()).transfer(address(this).balance);\\n    }\\n\\n    /**\\n     * allows owner to rescue tokens\\n     */\\n    function rescue(IERC20 token, uint256 amount) external onlyProxyAdmin {\\n        token.transfer(_proxyAdmin(), amount);\\n    }\\n\\n    /**\\n     * enables owner to pause / unpause minting\\n     */\\n    function setPaused(bool _paused) external onlyProxyAdmin {\\n        if (_paused) _pause();\\n        else _unpause();\\n    }\\n\\n    /**\\n     * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\\n     * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\\n     * probability & alias tables are generated off-chain beforehand\\n     * @param seed portion of the 256 bit seed to remove trait correlation\\n     * @param traitType the trait type to select a trait for\\n     * @return the ID of the randomly selected trait\\n     */\\n    function selectTrait(uint16 seed, uint8 traitType)\\n        internal\\n        view\\n        returns (uint8)\\n    {\\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\\n\\n        if (seed >> 8 < rarities[traitType][trait]) {\\n            return trait;\\n        }\\n\\n        return aliases[traitType][trait];\\n    }\\n\\n    /**\\n     * the first 20% (ETH purchases) go to the minter\\n     * the remaining 80% have a 10% chance to be given to a random staked noodle\\n     * @param seed a random value to select a recipient from\\n     * @return the address of the recipient (either the minter or the Noodle thief's owner)\\n     */\\n    function selectRecipient(uint256 tokenId, uint256 seed)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        if (\\n            tokenId <= chickenNoodle.PAID_TOKENS() || ((seed >> 245) % 10) != 0\\n        ) {\\n            // top 10 bits haven't been used\\n            return chickenNoodle.ownerOf(tokenId);\\n        }\\n        address thief = farm.randomNoodleOwner(seed >> 144); // 144 bits reserved for trait selection\\n\\n        if (thief == address(0x0)) {\\n            return chickenNoodle.ownerOf(tokenId);\\n        }\\n\\n        return thief;\\n    }\\n\\n    /**\\n     * selects the species and all of its traits based on the seed value\\n     * @param seed a pseudorandom 256 bit number to derive traits from\\n     * @return t -  a struct of randomly selected traits\\n     */\\n    function selectTraits(uint256 tokenId, uint256 seed)\\n        internal\\n        view\\n        returns (IChickenNoodle.ChickenNoodleTraits memory t)\\n    {\\n        t.minted = true;\\n\\n        t.isChicken = (seed & 0xFFFF) % 10 != 0;\\n\\n        seed >>= 16;\\n        t.backgrounds = selectTrait(uint16(seed & 0xFFFF), 0);\\n\\n        seed >>= 16;\\n        t.mouthAccessories = selectTrait(uint16(seed & 0xFFFF), 1);\\n\\n        seed >>= 16;\\n        t.pupils = selectTrait(uint16(seed & 0xFFFF), 2);\\n\\n        seed >>= 16;\\n        t.hats = selectTrait(uint16(seed & 0xFFFF), 3);\\n\\n        seed >>= 16;\\n        t.bodyAccessories = t.isChicken\\n            ? 0\\n            : selectTrait(uint16(seed & 0xFFFF), 4);\\n\\n        seed >>= 16;\\n        uint8 tier = selectTrait(uint16(seed & 0xFFFF), 5);\\n\\n        uint8 snakeBodiesPlacement = 0;\\n\\n        if (tier == 1) {\\n            snakeBodiesPlacement = 4;\\n        } else if (tier == 2) {\\n            snakeBodiesPlacement = 8;\\n        } else if (tier == 3) {\\n            snakeBodiesPlacement = 16;\\n        }\\n\\n        seed >>= 16;\\n        t.snakeBodies =\\n            snakeBodiesPlacement +\\n            selectTrait(uint16(seed & 0xFFFF), 6 + t.tier);\\n\\n        t.tier = t.isChicken\\n            ? 0\\n            : (tokenId <= chickenNoodle.PAID_TOKENS() ? 5 : 4) - tier;\\n    }\\n\\n    /**\\n     * converts a struct to a 256 bit hash to check for uniqueness\\n     * @param s the struct to pack into a hash\\n     * @return the 256 bit hash of the struct\\n     */\\n    function structToHash(IChickenNoodle.ChickenNoodleTraits memory s)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            uint256(\\n                bytes32(\\n                    abi.encodePacked(\\n                        s.minted,\\n                        s.isChicken,\\n                        s.backgrounds,\\n                        s.snakeBodies,\\n                        s.mouthAccessories,\\n                        s.pupils,\\n                        s.bodyAccessories,\\n                        s.hats,\\n                        s.tier\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * generates a pseudorandom number\\n     * @param tokenId a value ensure different outcomes for different sources in the same block\\n     * @param mintHash minthash stored at time of initial mint\\n     * @param seed vrf random value\\n     * @return a pseudorandom value\\n     */\\n    function random(\\n        uint16 tokenId,\\n        bytes32 mintHash,\\n        uint256 seed\\n    ) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(tokenId, mintHash, seed)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/VRFLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IRandomnessProvider.sol';\\n\\nlibrary VRFLibrary {\\n    struct VRFData {\\n        IRandomnessProvider randomnessProvider;\\n        bytes32 lastRequestId;\\n        mapping(uint256 => uint256) highestIdForRandomness;\\n        mapping(uint256 => uint256) randomResults;\\n        uint256 lastRequest;\\n        uint256 minResultIndex;\\n        uint256 resultsReceived;\\n    }\\n\\n    modifier onlyRandomnessProvider(VRFData storage self) {\\n        require(\\n            msg.sender == address(self.randomnessProvider),\\n            'Required to be randomnessProvider'\\n        );\\n        _;\\n    }\\n\\n    function processingStats(\\n        VRFData storage self,\\n        uint256 maxId,\\n        uint256 processedId,\\n        uint256 interval\\n    )\\n        public\\n        view\\n        returns (\\n            bool requestPending,\\n            uint256 maxIdAvailableToProcess,\\n            uint256 readyForProcessing,\\n            uint256 waitingToBeProcessed,\\n            uint256 timeTellNextRandomnessRequest\\n        )\\n    {\\n        timeTellNextRandomnessRequest = self.lastRequest + interval < block.timestamp\\n                ? 0\\n                : (self.lastRequest + interval) - block.timestamp;\\n\\n        return (\\n            self.lastRequestId != '' && timeTellNextRandomnessRequest > interval / 2,\\n            self.highestIdForRandomness[self.resultsReceived],\\n            self.highestIdForRandomness[self.resultsReceived] - processedId,\\n            maxId - self.highestIdForRandomness[self.resultsReceived],\\n            timeTellNextRandomnessRequest\\n        );\\n    }\\n\\n    function checkRandomness(\\n        VRFData storage self,\\n        uint256 maxId,\\n        uint256 processedId,\\n        uint256 interval,\\n        uint256 needed,\\n        uint256 minimum\\n    ) external {\\n        (\\n            bool requested,\\n            ,\\n            ,\\n            uint256 processingNeeded,\\n            uint256 timeTellNext\\n        ) = processingStats(self, maxId, processedId, interval);\\n\\n        if (\\n            !requested &&\\n            (processingNeeded >= needed ||\\n                (timeTellNext == 0 && processingNeeded > minimum))\\n        ) {\\n            newRequest(self);\\n        }\\n    }\\n\\n    function newRequest(VRFData storage self) public {\\n        bytes32 requestId = self.randomnessProvider.newRandomnessRequest();\\n\\n        if (requestId != '') {\\n            self.lastRequest = block.timestamp;\\n            self.lastRequestId = requestId;\\n        }\\n    }\\n\\n    function setRequestResults(\\n        VRFData storage self,\\n        bytes32 requestId,\\n        uint256 randomness,\\n        uint256 maxId\\n    ) public onlyRandomnessProvider(self) {\\n        if (self.lastRequestId == requestId) {\\n            self.resultsReceived++;\\n            self.randomResults[self.resultsReceived] = randomness;\\n            self.highestIdForRandomness[self.resultsReceived] = maxId;\\n            self.lastRequestId = '';\\n        }\\n    }\\n\\n    function randomnessForId(VRFData storage self, uint256 id)\\n        public\\n        returns (bool available, uint256 randomness)\\n    {\\n        while (\\n            self.highestIdForRandomness[self.minResultIndex] < id &&\\n            self.minResultIndex < self.resultsReceived\\n        ) {\\n            delete self.randomResults[self.minResultIndex];\\n            delete self.highestIdForRandomness[self.minResultIndex];\\n            self.minResultIndex++;\\n        }\\n\\n        if (self.highestIdForRandomness[self.minResultIndex] >= id) {\\n            return (true, self.randomResults[self.minResultIndex]);\\n        }\\n\\n        return (false, 0);\\n    }\\n\\n    function setRandomnessProvider(\\n        VRFData storage self,\\n        address randomnessProvider\\n    ) public {\\n        self.randomnessProvider = IRandomnessProvider(randomnessProvider);\\n    }\\n\\n    function updateFee(VRFData storage self, uint256 fee) public {\\n        self.randomnessProvider.updateFee(fee);\\n    }\\n\\n    function rescueLINK(\\n        VRFData storage self,\\n        address to,\\n        uint256 amount\\n    ) public {\\n        self.randomnessProvider.rescueLINK(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEgg.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IEgg {\\n    /**\\n     * mints $EGG to a recipient\\n     * @param to the recipient of the $EGG\\n     * @param amount the amount of $EGG to mint\\n     */\\n    function mint(address to, uint256 amount) external;\\n\\n    /**\\n     * burns $EGG from a holder\\n     * @param from the holder of the $EGG\\n     * @param amount the amount of $EGG to burn\\n     */\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITraits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITraits {\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChickenNoodle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IChickenNoodle {\\n    // struct to store each token's traits\\n    struct ChickenNoodleTraits {\\n        bool minted;\\n        bool isChicken;\\n        uint8 backgrounds;\\n        uint8 snakeBodies;\\n        uint8 mouthAccessories;\\n        uint8 pupils;\\n        uint8 bodyAccessories;\\n        uint8 hats;\\n        uint8 tier;\\n    }\\n\\n    function MAX_TOKENS() external view returns (uint256);\\n\\n    function PAID_TOKENS() external view returns (uint256);\\n\\n    function tokenTraits(uint256 tokenId)\\n        external\\n        view\\n        returns (ChickenNoodleTraits memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function mint(address to, uint16 tokenId) external;\\n\\n    function finalize(\\n        uint16 tokenId,\\n        ChickenNoodleTraits memory traits,\\n        address thief\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './IChickenNoodle.sol';\\n\\ninterface IFarm {\\n    struct Stake {\\n        uint16 tokenId;\\n        uint80 value;\\n        address owner;\\n    }\\n\\n    struct PagingData {\\n        address tokenOwner;\\n        uint16 limit;\\n        uint16 page;\\n    }\\n\\n    function totalChickenStaked() external view returns (uint16);\\n\\n    function MINIMUM_TO_EXIT() external view returns (uint256);\\n\\n    function MAX_TIER_SCORE() external view returns (uint8);\\n\\n    function MAXIMUM_GLOBAL_EGG() external view returns (uint256);\\n\\n    function DAILY_GEN0_EGG_RATE() external view returns (uint256);\\n\\n    function DAILY_GEN1_EGG_RATE() external view returns (uint256);\\n\\n    function eggPerTierScore() external view returns (uint256);\\n\\n    function totalEggEarned() external view returns (uint256);\\n\\n    function lastClaimTimestamp() external view returns (uint256);\\n\\n    function denIndices(uint16 tokenId) external view returns (uint16);\\n\\n    function chickenNoodle() external view returns (IChickenNoodle);\\n\\n    function isChicken(uint16 tokenId) external view returns (bool);\\n\\n    function tierScoreForNoodle(uint16 tokenId) external view returns (uint8);\\n\\n    function randomNoodleOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomnessConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRandomnessConsumer {\\n    function setRandomnessResult(bytes32 requestId, uint256 randomness)\\n        external;\\n\\n    function process(uint256 amount) external;\\n\\n    function processNext() external returns (bool);\\n\\n    function setRandomnessProvider(address _randomnessProvider) external;\\n\\n    function updateRandomnessFee(uint256 _fee) external;\\n\\n    function rescueLINK(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomnessProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRandomnessProvider {\\n    function newRandomnessRequest() external returns (bytes32);\\n\\n    function updateFee(uint256) external;\\n\\n    function rescueLINK(address to, uint256 amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/VRFLibrary.sol\": {\r\n        \"VRFLibrary\": \"0xe4915cafa1e7e53786719e51fc42c9c12f722f76\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aliases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"checkRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chickenNoodle\",\"outputs\":[{\"internalType\":\"contract IChickenNoodle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"egg\",\"outputs\":[{\"internalType\":\"contract IEgg\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingCombinations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farm\",\"outputs\":[{\"internalType\":\"contract IFarm\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_egg\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chickenNoodle\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processNext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processed\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingStats\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"requestPending\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxIdAvailableToProcess\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"readyForProcessing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"waitingToBeProcessed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeTellNextRandomnessRequest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLINK\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_farm\",\"type\":\"address\"}],\"name\":\"setFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_randomnessProvider\",\"type\":\"address\"}],\"name\":\"setRandomnessProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"setRandomnessResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"updateRandomnessFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChickenNoodleSoup","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}