{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/access/AccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract AccessController is AccessControl {\\n  bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\n  bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n  constructor() public {\\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    _setupRole(MANAGER_ROLE, msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrade/MerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IMerkleDistributor.sol\\\";\\n\\ncontract MerkleDistributor is IMerkleDistributor, Ownable {\\n  address public immutable override token;\\n  bytes32 public immutable override merkleRoot;\\n  uint256 public immutable override endTime;\\n\\n  // This is a packed array of booleans.\\n  mapping(uint256 => uint256) private _claimedBitMap;\\n\\n  constructor(\\n    address _token,\\n    bytes32 _merkleRoot,\\n    uint256 _endTime\\n  ) public {\\n    token = _token;\\n    merkleRoot = _merkleRoot;\\n    require(block.timestamp < _endTime, \\\"Invalid endTime\\\");\\n    endTime = _endTime;\\n  }\\n\\n  /** @dev Modifier to check that claim period is active.*/\\n  modifier whenActive() {\\n    require(isActive(), \\\"Claim period has ended\\\");\\n    _;\\n  }\\n\\n  function claim(\\n    uint256 _index,\\n    address _account,\\n    uint256 _amount,\\n    bytes32[] calldata merkleProof\\n  ) external override whenActive {\\n    require(!isClaimed(_index), \\\"Drop already claimed\\\");\\n\\n    // Verify the merkle proof.\\n    bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), \\\"Invalid proof\\\");\\n\\n    // Mark it claimed and send the token.\\n    _setClaimed(_index);\\n    require(IERC20(token).transfer(_account, _amount), \\\"Transfer failed\\\");\\n\\n    emit Claimed(_index, _account, _amount);\\n  }\\n\\n  function isClaimed(uint256 _index) public view override returns (bool) {\\n    uint256 claimedWordIndex = _index / 256;\\n    uint256 claimedBitIndex = _index % 256;\\n    uint256 claimedWord = _claimedBitMap[claimedWordIndex];\\n    uint256 mask = (1 << claimedBitIndex);\\n    return claimedWord & mask == mask;\\n  }\\n\\n  function isActive() public view override returns (bool) {\\n    return block.timestamp < endTime;\\n  }\\n\\n  function recoverERC20(address _tokenAddress, uint256 _tokenAmount) public onlyOwner {\\n    IERC20(_tokenAddress).transfer(owner(), _tokenAmount);\\n  }\\n\\n  function _setClaimed(uint256 _index) private {\\n    uint256 claimedWordIndex = _index / 256;\\n    uint256 claimedBitIndex = _index % 256;\\n    _claimedBitMap[claimedWordIndex] = _claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n// Allows anyone to claim a token if they exist in a merkle root.\\ninterface IMerkleDistributor {\\n  // This event is triggered whenever a call to #claim succeeds.\\n  event Claimed(uint256 index, address account, uint256 amount);\\n\\n  // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\\n  function claim(\\n    uint256 index,\\n    address account,\\n    uint256 amount,\\n    bytes32[] calldata merkleProof\\n  ) external;\\n\\n  // Returns the address of the token distributed by this contract.\\n  function token() external view returns (address);\\n\\n  // Returns the merkle root of the merkle tree containing account balances available to claim.\\n  function merkleRoot() external view returns (bytes32);\\n\\n  // Returns true if the index has been marked claimed.\\n  function isClaimed(uint256 index) external view returns (bool);\\n\\n  // Returns the block timestamp when claims will end\\n  function endTime() external view returns (uint256);\\n\\n  // Returns true if the claim period has not ended.\\n  function isActive() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/VaultsCoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"./interfaces/IVaultsCoreV1.sol\\\";\\nimport \\\"./interfaces/ILiquidationManagerV1.sol\\\";\\nimport \\\"./interfaces/IAddressProviderV1.sol\\\";\\n\\ncontract VaultsCoreV1 is IVaultsCoreV1, ReentrancyGuard {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  uint256 public constant MAX_INT = 2**256 - 1;\\n\\n  mapping(address => uint256) public override cumulativeRates;\\n  mapping(address => uint256) public override lastRefresh;\\n\\n  IAddressProviderV1 public override a;\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\\n    _;\\n  }\\n\\n  modifier onlyVaultOwner(uint256 _vaultId) {\\n    require(a.vaultsData().vaultOwner(_vaultId) == msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyConfig() {\\n    require(msg.sender == address(a.config()));\\n    _;\\n  }\\n\\n  constructor(IAddressProviderV1 _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /*\\n    Allow smooth upgrading of the vaultscore.\\n    @dev this function approves token transfers to the new vaultscore of\\n    both stablex and all configured collateral types\\n    @param _newVaultsCore address of the new vaultscore\\n  */\\n  function upgrade(address _newVaultsCore) public override onlyManager {\\n    require(address(_newVaultsCore) != address(0));\\n    require(a.stablex().approve(_newVaultsCore, MAX_INT));\\n\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      IERC20 asset = IERC20(collateralType);\\n      asset.safeApprove(_newVaultsCore, MAX_INT);\\n    }\\n  }\\n\\n  /**\\n    Calculate the available income\\n    @return available income that has not been minted yet.\\n  **/\\n  function availableIncome() public view override returns (uint256) {\\n    return a.vaultsData().debt().sub(a.stablex().totalSupply());\\n  }\\n\\n  /**\\n    Refresh the cumulative rates and debts of all vaults and all collateral types.\\n  **/\\n  function refresh() public override {\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      refreshCollateral(collateralType);\\n    }\\n  }\\n\\n  /**\\n    Initialize the cumulative rates to 1 for a new collateral type.\\n    @param _collateralType the address of the new collateral type to be initialized\\n  **/\\n  function initializeRates(address _collateralType) public override onlyConfig {\\n    require(_collateralType != address(0));\\n    lastRefresh[_collateralType] = now;\\n    cumulativeRates[_collateralType] = WadRayMath.ray();\\n  }\\n\\n  /**\\n    Refresh the cumulative rate of a collateraltype.\\n    @dev this updates the debt for all vaults with the specified collateral type.\\n    @param _collateralType the address of the collateral type to be refreshed.\\n  **/\\n  function refreshCollateral(address _collateralType) public override {\\n    require(_collateralType != address(0));\\n    require(a.config().collateralIds(_collateralType) != 0);\\n    uint256 timestamp = now;\\n    uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);\\n    _refreshCumulativeRate(_collateralType, timeElapsed);\\n    lastRefresh[_collateralType] = timestamp;\\n  }\\n\\n  /**\\n    Internal function to increase the cumulative rate over a specified time period\\n    @dev this updates the debt for all vaults with the specified collateral type.\\n    @param _collateralType the address of the collateral type to be updated\\n    @param _timeElapsed the amount of time in seconds to add to the cumulative rate\\n  **/\\n  function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {\\n    uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);\\n    uint256 oldCumulativeRate = cumulativeRates[_collateralType];\\n    cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(\\n      borrowRate,\\n      oldCumulativeRate,\\n      _timeElapsed\\n    );\\n    emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);\\n  }\\n\\n  /**\\n    Deposit an ERC20 token into the vault of the msg.sender as collateral\\n    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.\\n    this function used `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\\n    @param _collateralType the address of the collateral type to be deposited\\n    @param _amount the amount of tokens to be deposited in WEI.\\n  **/\\n  function deposit(address _collateralType, uint256 _amount) public override {\\n    require(a.config().collateralIds(_collateralType) != 0);\\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\\n    if (vaultId == 0) {\\n      vaultId = a.vaultsData().createVault(_collateralType, msg.sender);\\n    }\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(vaultId);\\n    a.vaultsData().setCollateralBalance(vaultId, v.collateralBalance.add(_amount));\\n\\n    IERC20 asset = IERC20(v.collateralType);\\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n    emit Deposited(vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Withdraws ERC20 tokens from a vault.\\n    @dev Only te owner of a vault can withdraw collateral from it.\\n    `withdraw()` will fail if it would bring the vault below the liquidation treshold.\\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\\n    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.\\n  **/\\n  function withdraw(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n    require(_amount <= v.collateralBalance);\\n    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);\\n    a.vaultsData().setCollateralBalance(_vaultId, newCollateralBalance);\\n    if (v.baseDebt > 0) {\\n      //save gas cost when withdrawing from 0 debt vault\\n      refreshCollateral(v.collateralType);\\n      uint256 newCollateralValue = a.priceFeed().convertFrom(v.collateralType, newCollateralBalance);\\n      bool _isHealthy = ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(\\n        v.collateralType,\\n        newCollateralValue,\\n        a.vaultsData().vaultDebt(_vaultId)\\n      );\\n      require(_isHealthy);\\n    }\\n\\n    IERC20 asset = IERC20(v.collateralType);\\n    asset.safeTransfer(msg.sender, _amount);\\n    emit Withdrawn(_vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Convenience function to withdraw all collateral of a vault\\n    @dev Only te owner of a vault can withdraw collateral from it.\\n    `withdrawAll()` will fail if the vault has any outstanding debt attached to it.\\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\\n  **/\\n  function withdrawAll(uint256 _vaultId) public override onlyVaultOwner(_vaultId) {\\n    uint256 collateralBalance = a.vaultsData().vaultCollateralBalance(_vaultId);\\n    withdraw(_vaultId, collateralBalance);\\n  }\\n\\n  /**\\n    Borrow new StableX (Eg: PAR) tokens from a vault.\\n    @dev Only te owner of a vault can borrow from it.\\n    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.\\n     and will fail if it would bring the vault below the liquidation treshold.\\n    @param _vaultId the ID of the vault from which to borrow.\\n    @param _amount the amount of borrowed StableX tokens in WEI.\\n  **/\\n  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n\\n    //make sure current rate is up to date\\n    refreshCollateral(v.collateralType);\\n\\n    uint256 originationFeePercentage = a.config().collateralOriginationFee(v.collateralType);\\n    uint256 newDebt = _amount;\\n    if (originationFeePercentage > 0) {\\n      newDebt = newDebt.add(_amount.wadMul(originationFeePercentage));\\n    }\\n\\n    // Increment vault borrow balance\\n    uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(newDebt, cumulativeRates[v.collateralType]);\\n\\n    a.vaultsData().setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));\\n\\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\\n    uint256 newVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n\\n    require(a.vaultsData().collateralDebt(v.collateralType) <= a.config().collateralDebtLimit(v.collateralType));\\n\\n    bool isHealthy = ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(\\n      v.collateralType,\\n      collateralValue,\\n      newVaultDebt\\n    );\\n    require(isHealthy);\\n\\n    a.stablex().mint(msg.sender, _amount);\\n    emit Borrowed(_vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Convenience function to repay all debt of a vault\\n    @dev `repayAll()` will update the outstanding vault debt to the current time.\\n    @param _vaultId the ID of the vault for which to repay the debt.\\n  **/\\n  function repayAll(uint256 _vaultId) public override {\\n    repay(_vaultId, 2**256 - 1);\\n  }\\n\\n  /**\\n    Repay an outstanding StableX balance to a vault.\\n    @dev `repay()` will update the outstanding vault debt to the current time.\\n    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.\\n    @param _amount the amount of StableX tokens in WEI to be repaid.\\n  **/\\n  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {\\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\\n\\n    // Make sure current rate is up to date\\n    refreshCollateral(collateralType);\\n\\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n    // Decrement vault borrow balance\\n    if (_amount >= currentVaultDebt) {\\n      //full repayment\\n      _amount = currentVaultDebt; //only pay back what's outstanding\\n    }\\n    _reduceVaultDebt(_vaultId, _amount);\\n    a.stablex().burn(msg.sender, _amount);\\n\\n    emit Repaid(_vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Internal helper function to reduce the debt of a vault.\\n    @dev assumes cumulative rates for the vault's collateral type are up to date.\\n    please call `refreshCollateral()` before calling this function.\\n    @param _vaultId the ID of the vault for which to reduce the debt.\\n    @param _amount the amount of debt to be reduced.\\n  **/\\n  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {\\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\\n\\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n    uint256 remainder = currentVaultDebt.sub(_amount);\\n    uint256 cumulativeRate = cumulativeRates[collateralType];\\n\\n    if (remainder == 0) {\\n      a.vaultsData().setBaseDebt(_vaultId, 0);\\n    } else {\\n      uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);\\n      a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);\\n    }\\n  }\\n\\n  /**\\n    Liquidate a vault that is below the liquidation treshold by repaying it's outstanding debt.\\n    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\\n    to the liquidator. `liquidate()` can be called by anyone.\\n    @param _vaultId the ID of the vault to be liquidated.\\n  **/\\n  function liquidate(uint256 _vaultId) public override nonReentrant {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n\\n    refreshCollateral(v.collateralType);\\n\\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n\\n    require(\\n      !ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(\\n        v.collateralType,\\n        collateralValue,\\n        currentVaultDebt\\n      )\\n    );\\n\\n    uint256 discountedValue = ILiquidationManagerV1(address(a.liquidationManager())).applyLiquidationDiscount(\\n      collateralValue\\n    );\\n    uint256 collateralToReceive;\\n    uint256 stableXToPay = currentVaultDebt;\\n\\n    if (discountedValue < currentVaultDebt) {\\n      //Insurance Case\\n      uint256 insuranceAmount = currentVaultDebt.sub(discountedValue);\\n      require(a.stablex().balanceOf(address(this)) >= insuranceAmount);\\n      a.stablex().burn(address(this), insuranceAmount);\\n      emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);\\n      collateralToReceive = v.collateralBalance;\\n      stableXToPay = currentVaultDebt.sub(insuranceAmount);\\n    } else {\\n      collateralToReceive = a.priceFeed().convertTo(v.collateralType, currentVaultDebt);\\n      collateralToReceive = collateralToReceive.add(\\n        ILiquidationManagerV1(address(a.liquidationManager())).liquidationBonus(collateralToReceive)\\n      );\\n    }\\n    // reduce the vault debt to 0\\n    _reduceVaultDebt(_vaultId, currentVaultDebt);\\n    a.stablex().burn(msg.sender, stableXToPay);\\n\\n    // send the collateral to the liquidator\\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));\\n    IERC20 asset = IERC20(v.collateralType);\\n    asset.safeTransfer(msg.sender, collateralToReceive);\\n\\n    emit Liquidated(_vaultId, stableXToPay, collateralToReceive, v.owner, msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/******************\\n@title WadRayMath library\\n@author Aave\\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n */\\n\\nlibrary WadRayMath {\\n  using SafeMath for uint256;\\n\\n  uint256 internal constant _WAD = 1e18;\\n  uint256 internal constant _HALF_WAD = _WAD / 2;\\n\\n  uint256 internal constant _RAY = 1e27;\\n  uint256 internal constant _HALF_RAY = _RAY / 2;\\n\\n  uint256 internal constant _WAD_RAY_RATIO = 1e9;\\n\\n  function ray() internal pure returns (uint256) {\\n    return _RAY;\\n  }\\n\\n  function wad() internal pure returns (uint256) {\\n    return _WAD;\\n  }\\n\\n  function halfRay() internal pure returns (uint256) {\\n    return _HALF_RAY;\\n  }\\n\\n  function halfWad() internal pure returns (uint256) {\\n    return _HALF_WAD;\\n  }\\n\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return _HALF_WAD.add(a.mul(b)).div(_WAD);\\n  }\\n\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 halfB = b / 2;\\n\\n    return halfB.add(a.mul(_WAD)).div(b);\\n  }\\n\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return _HALF_RAY.add(a.mul(b)).div(_RAY);\\n  }\\n\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 halfB = b / 2;\\n\\n    return halfB.add(a.mul(_RAY)).div(b);\\n  }\\n\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = _WAD_RAY_RATIO / 2;\\n\\n    return halfRatio.add(a).div(_WAD_RAY_RATIO);\\n  }\\n\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    return a.mul(_WAD_RAY_RATIO);\\n  }\\n\\n  /**\\n   * @dev calculates x^n, in ray. The code uses the ModExp precompile\\n   * @param x base\\n   * @param n exponent\\n   * @return z = x^n, in ray\\n   */\\n  function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n    z = n % 2 != 0 ? x : _RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      x = rayMul(x, x);\\n\\n      if (n % 2 != 0) {\\n        z = rayMul(z, x);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/interfaces/IVaultsCoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\nimport './IAddressProviderV1.sol';\\n\\ninterface IVaultsCoreV1 {\\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Liquidated(\\n    uint256 indexed vaultId,\\n    uint256 debtRepaid,\\n    uint256 collateralLiquidated,\\n    address indexed owner,\\n    address indexed sender\\n  );\\n\\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\\n\\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\\n\\n  function deposit(address _collateralType, uint256 _amount) external;\\n\\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\\n\\n  function withdrawAll(uint256 _vaultId) external;\\n\\n  function borrow(uint256 _vaultId, uint256 _amount) external;\\n\\n  function repayAll(uint256 _vaultId) external;\\n\\n  function repay(uint256 _vaultId, uint256 _amount) external;\\n\\n  function liquidate(uint256 _vaultId) external;\\n\\n  //Refresh\\n  function initializeRates(address _collateralType) external;\\n\\n  function refresh() external;\\n\\n  function refreshCollateral(address collateralType) external;\\n\\n  //upgrade\\n  function upgrade(address _newVaultsCore) external;\\n\\n  //Read only\\n\\n  function a() external view returns (IAddressProviderV1);\\n\\n  function availableIncome() external view returns (uint256);\\n\\n  function cumulativeRates(address _collateralType) external view returns (uint256);\\n\\n  function lastRefresh(address _collateralType) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/interfaces/ILiquidationManagerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport './IAddressProviderV1.sol';\\n\\ninterface ILiquidationManagerV1 {\\n  function a() external view returns (IAddressProviderV1);\\n\\n  function calculateHealthFactor(\\n    address _collateralType,\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt\\n  ) external view returns (uint256 healthFactor);\\n\\n  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);\\n\\n  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);\\n\\n  function isHealthy(\\n    address _collateralType,\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt\\n  ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/interfaces/IAddressProviderV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport './IConfigProviderV1.sol';\\nimport './ILiquidationManagerV1.sol';\\nimport './IVaultsCoreV1.sol';\\nimport '../../interfaces/IVaultsCore.sol';\\nimport '../../interfaces/IAccessController.sol';\\nimport '../../interfaces/ISTABLEX.sol';\\nimport '../../interfaces/IPriceFeed.sol';\\nimport '../../interfaces/IRatesManager.sol';\\nimport '../../interfaces/IVaultsDataProvider.sol';\\nimport '../../interfaces/IFeeDistributor.sol';\\n\\ninterface IAddressProviderV1 {\\n  function setAccessController(IAccessController _controller) external;\\n\\n  function setConfigProvider(IConfigProviderV1 _config) external;\\n\\n  function setVaultsCore(IVaultsCoreV1 _core) external;\\n\\n  function setStableX(ISTABLEX _stablex) external;\\n\\n  function setRatesManager(IRatesManager _ratesManager) external;\\n\\n  function setPriceFeed(IPriceFeed _priceFeed) external;\\n\\n  function setLiquidationManager(ILiquidationManagerV1 _liquidationManager) external;\\n\\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\\n\\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\\n\\n  function controller() external view returns (IAccessController);\\n\\n  function config() external view returns (IConfigProviderV1);\\n\\n  function core() external view returns (IVaultsCoreV1);\\n\\n  function stablex() external view returns (ISTABLEX);\\n\\n  function ratesManager() external view returns (IRatesManager);\\n\\n  function priceFeed() external view returns (IPriceFeed);\\n\\n  function liquidationManager() external view returns (ILiquidationManagerV1);\\n\\n  function vaultsData() external view returns (IVaultsDataProvider);\\n\\n  function feeDistributor() external view returns (IFeeDistributor);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/interfaces/IConfigProviderV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport './IAddressProviderV1.sol';\\n\\ninterface IConfigProviderV1 {\\n  struct CollateralConfig {\\n    address collateralType;\\n    uint256 debtLimit;\\n    uint256 minCollateralRatio;\\n    uint256 borrowRate;\\n    uint256 originationFee;\\n  }\\n\\n  event CollateralUpdated(\\n    address indexed collateralType,\\n    uint256 debtLimit,\\n    uint256 minCollateralRatio,\\n    uint256 borrowRate,\\n    uint256 originationFee\\n  );\\n  event CollateralRemoved(address indexed collateralType);\\n\\n  function setCollateralConfig(\\n    address _collateralType,\\n    uint256 _debtLimit,\\n    uint256 _minCollateralRatio,\\n    uint256 _borrowRate,\\n    uint256 _originationFee\\n  ) external;\\n\\n  function removeCollateral(address _collateralType) external;\\n\\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\\n\\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\\n\\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\\n\\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\\n\\n  function setLiquidationBonus(uint256 _bonus) external;\\n\\n  function a() external view returns (IAddressProviderV1);\\n\\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\\n\\n  function collateralIds(address _collateralType) external view returns (uint256);\\n\\n  function numCollateralConfigs() external view returns (uint256);\\n\\n  function liquidationBonus() external view returns (uint256);\\n\\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\\n\\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\\n\\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\\n\\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultsCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/IVaultsCoreState.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IDebtNotifier.sol\\\";\\n\\ninterface IVaultsCore {\\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\\n  event Liquidated(\\n    uint256 indexed vaultId,\\n    uint256 debtRepaid,\\n    uint256 collateralLiquidated,\\n    address indexed owner,\\n    address indexed sender\\n  );\\n\\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\\n\\n  function deposit(address _collateralType, uint256 _amount) external;\\n\\n  function depositETH() external payable;\\n\\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;\\n\\n  function depositETHByVaultId(uint256 _vaultId) external payable;\\n\\n  function depositAndBorrow(\\n    address _collateralType,\\n    uint256 _depositAmount,\\n    uint256 _borrowAmount\\n  ) external;\\n\\n  function depositETHAndBorrow(uint256 _borrowAmount) external payable;\\n\\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\\n\\n  function withdrawETH(uint256 _vaultId, uint256 _amount) external;\\n\\n  function borrow(uint256 _vaultId, uint256 _amount) external;\\n\\n  function repayAll(uint256 _vaultId) external;\\n\\n  function repay(uint256 _vaultId, uint256 _amount) external;\\n\\n  function liquidate(uint256 _vaultId) external;\\n\\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;\\n\\n  function upgrade(address payable _newVaultsCore) external;\\n\\n  function acceptUpgrade(address payable _oldVaultsCore) external;\\n\\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\\n\\n  //Read only\\n  function a() external view returns (IAddressProvider);\\n\\n  function WETH() external view returns (IWETH);\\n\\n  function debtNotifier() external view returns (IDebtNotifier);\\n\\n  function state() external view returns (IVaultsCoreState);\\n\\n  function cumulativeRates(address _collateralType) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IAccessController {\\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  function grantRole(bytes32 role, address account) external;\\n\\n  function revokeRole(bytes32 role, address account) external;\\n\\n  function renounceRole(bytes32 role, address account) external;\\n\\n  function MANAGER_ROLE() external view returns (bytes32);\\n\\n  function MINTER_ROLE() external view returns (bytes32);\\n\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n\\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISTABLEX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ninterface ISTABLEX is IERC20 {\\n  function mint(address account, uint256 amount) external;\\n\\n  function burn(address account, uint256 amount) external;\\n\\n  function a() external view returns (IAddressProvider);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../chainlink/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ninterface IPriceFeed {\\n  event OracleUpdated(address indexed asset, address oracle, address sender);\\n  event EurOracleUpdated(address oracle, address sender);\\n\\n  function setAssetOracle(address _asset, address _oracle) external;\\n\\n  function setEurOracle(address _oracle) external;\\n\\n  function a() external view returns (IAddressProvider);\\n\\n  function assetOracles(address _asset) external view returns (AggregatorV3Interface);\\n\\n  function eurOracle() external view returns (AggregatorV3Interface);\\n\\n  function getAssetPrice(address _asset) external view returns (uint256);\\n\\n  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);\\n\\n  function convertTo(address _asset, uint256 _amount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRatesManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ninterface IRatesManager {\\n  function a() external view returns (IAddressProvider);\\n\\n  //current annualized borrow rate\\n  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);\\n\\n  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0\\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);\\n\\n  //uses current cumulative rate to calculate baseDebt at time T0\\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);\\n\\n  //calculate a new cumulative rate\\n  function calculateCumulativeRate(\\n    uint256 _borrowRate,\\n    uint256 _cumulativeRate,\\n    uint256 _timeElapsed\\n  ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultsDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ninterface IVaultsDataProvider {\\n  struct Vault {\\n    // borrowedType support USDX / PAR\\n    address collateralType;\\n    address owner;\\n    uint256 collateralBalance;\\n    uint256 baseDebt;\\n    uint256 createdAt;\\n  }\\n\\n  //Write\\n  function createVault(address _collateralType, address _owner) external returns (uint256);\\n\\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\\n\\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\\n\\n  // Read\\n  function a() external view returns (IAddressProvider);\\n\\n  function baseDebt(address _collateralType) external view returns (uint256);\\n\\n  function vaultCount() external view returns (uint256);\\n\\n  function vaults(uint256 _id) external view returns (Vault memory);\\n\\n  function vaultOwner(uint256 _id) external view returns (address);\\n\\n  function vaultCollateralType(uint256 _id) external view returns (address);\\n\\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\\n\\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\\n\\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\\n\\n  function vaultExists(uint256 _id) external view returns (bool);\\n\\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\\n\\n  function debt() external view returns (uint256);\\n\\n  function collateralDebt(address _collateralType) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ninterface IFeeDistributor {\\n  event PayeeAdded(address indexed account, uint256 shares);\\n  event FeeReleased(uint256 income, uint256 releasedAt);\\n\\n  function release() external;\\n\\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\\n\\n  function a() external view returns (IAddressProvider);\\n\\n  function lastReleasedAt() external view returns (uint256);\\n\\n  function getPayees() external view returns (address[] memory);\\n\\n  function totalShares() external view returns (uint256);\\n\\n  function shares(address payee) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"./IAccessController.sol\\\";\\nimport \\\"./IConfigProvider.sol\\\";\\nimport \\\"./ISTABLEX.sol\\\";\\nimport \\\"./IPriceFeed.sol\\\";\\nimport \\\"./IRatesManager.sol\\\";\\nimport \\\"./ILiquidationManager.sol\\\";\\nimport \\\"./IVaultsCore.sol\\\";\\nimport \\\"./IVaultsDataProvider.sol\\\";\\nimport \\\"./IFeeDistributor.sol\\\";\\n\\ninterface IAddressProvider {\\n  function setAccessController(IAccessController _controller) external;\\n\\n  function setConfigProvider(IConfigProvider _config) external;\\n\\n  function setVaultsCore(IVaultsCore _core) external;\\n\\n  function setStableX(ISTABLEX _stablex) external;\\n\\n  function setRatesManager(IRatesManager _ratesManager) external;\\n\\n  function setPriceFeed(IPriceFeed _priceFeed) external;\\n\\n  function setLiquidationManager(ILiquidationManager _liquidationManager) external;\\n\\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\\n\\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\\n\\n  function controller() external view returns (IAccessController);\\n\\n  function config() external view returns (IConfigProvider);\\n\\n  function core() external view returns (IVaultsCore);\\n\\n  function stablex() external view returns (ISTABLEX);\\n\\n  function ratesManager() external view returns (IRatesManager);\\n\\n  function priceFeed() external view returns (IPriceFeed);\\n\\n  function liquidationManager() external view returns (ILiquidationManager);\\n\\n  function vaultsData() external view returns (IVaultsDataProvider);\\n\\n  function feeDistributor() external view returns (IFeeDistributor);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultsCoreState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\nimport \\\"./IAddressProvider.sol\\\";\\nimport \\\"../v1/interfaces/IVaultsCoreV1.sol\\\";\\n\\ninterface IVaultsCoreState {\\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\\n\\n  function initializeRates(address _collateralType) external;\\n\\n  function refresh() external;\\n\\n  function refreshCollateral(address collateralType) external;\\n\\n  function syncState(IVaultsCoreState _stateAddress) external;\\n\\n  function syncStateFromV1(IVaultsCoreV1 _core) external;\\n\\n  //Read only\\n  function a() external view returns (IAddressProvider);\\n\\n  function availableIncome() external view returns (uint256);\\n\\n  function cumulativeRates(address _collateralType) external view returns (uint256);\\n\\n  function lastRefresh(address _collateralType) external view returns (uint256);\\n\\n  function synced() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\ninterface IWETH {\\n  function deposit() external payable;\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/IDebtNotifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\\nimport './ISupplyMiner.sol';\\n\\ninterface IDebtNotifier {\\n  function debtChanged(uint256 _vaultId) external;\\n\\n  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) external;\\n\\n  function a() external view returns (IGovernanceAddressProvider);\\n\\n  function collateralSupplyMinerMapping(address collateral) external view returns (ISupplyMiner);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfigProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ninterface IConfigProvider {\\n  struct CollateralConfig {\\n    address collateralType;\\n    uint256 debtLimit;\\n    uint256 liquidationRatio;\\n    uint256 minCollateralRatio;\\n    uint256 borrowRate;\\n    uint256 originationFee;\\n    uint256 liquidationBonus;\\n    uint256 liquidationFee;\\n  }\\n\\n  event CollateralUpdated(\\n    address indexed collateralType,\\n    uint256 debtLimit,\\n    uint256 liquidationRatio,\\n    uint256 minCollateralRatio,\\n    uint256 borrowRate,\\n    uint256 originationFee,\\n    uint256 liquidationBonus,\\n    uint256 liquidationFee\\n  );\\n  event CollateralRemoved(address indexed collateralType);\\n\\n  function setCollateralConfig(\\n    address _collateralType,\\n    uint256 _debtLimit,\\n    uint256 _liquidationRatio,\\n    uint256 _minCollateralRatio,\\n    uint256 _borrowRate,\\n    uint256 _originationFee,\\n    uint256 _liquidationBonus,\\n    uint256 _liquidationFee\\n  ) external;\\n\\n  function removeCollateral(address _collateralType) external;\\n\\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\\n\\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio) external;\\n\\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\\n\\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\\n\\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\\n\\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus) external;\\n\\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) external;\\n\\n  function setMinVotingPeriod(uint256 _minVotingPeriod) external;\\n\\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) external;\\n\\n  function setVotingQuorum(uint256 _votingQuorum) external;\\n\\n  function setProposalThreshold(uint256 _proposalThreshold) external;\\n\\n  function a() external view returns (IAddressProvider);\\n\\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\\n\\n  function collateralIds(address _collateralType) external view returns (uint256);\\n\\n  function numCollateralConfigs() external view returns (uint256);\\n\\n  function minVotingPeriod() external view returns (uint256);\\n\\n  function maxVotingPeriod() external view returns (uint256);\\n\\n  function votingQuorum() external view returns (uint256);\\n\\n  function proposalThreshold() external view returns (uint256);\\n\\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\\n\\n  function collateralLiquidationRatio(address _collateralType) external view returns (uint256);\\n\\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\\n\\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\\n\\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\\n\\n  function collateralLiquidationBonus(address _collateralType) external view returns (uint256);\\n\\n  function collateralLiquidationFee(address _collateralType) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ninterface ILiquidationManager {\\n  function a() external view returns (IAddressProvider);\\n\\n  function calculateHealthFactor(\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt,\\n    uint256 _minRatio\\n  ) external view returns (uint256 healthFactor);\\n\\n  function liquidationBonus(address _collateralType, uint256 _amount) external view returns (uint256 bonus);\\n\\n  function applyLiquidationDiscount(address _collateralType, uint256 _amount)\\n    external\\n    view\\n    returns (uint256 discountedAmount);\\n\\n  function isHealthy(\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt,\\n    uint256 _minRatio\\n  ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/IGovernanceAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport './IGovernorAlpha.sol';\\nimport './ITimelock.sol';\\nimport './IVotingEscrow.sol';\\nimport '../../interfaces/IAccessController.sol';\\nimport '../../interfaces/IAddressProvider.sol';\\nimport '../../liquidityMining/interfaces/IMIMO.sol';\\nimport '../../liquidityMining/interfaces/IDebtNotifier.sol';\\n\\ninterface IGovernanceAddressProvider {\\n  function setParallelAddressProvider(IAddressProvider _parallel) external;\\n\\n  function setMIMO(IMIMO _mimo) external;\\n\\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\\n\\n  function setGovernorAlpha(IGovernorAlpha _governorAlpha) external;\\n\\n  function setTimelock(ITimelock _timelock) external;\\n\\n  function setVotingEscrow(IVotingEscrow _votingEscrow) external;\\n\\n  function controller() external view returns (IAccessController);\\n\\n  function parallel() external view returns (IAddressProvider);\\n\\n  function mimo() external view returns (IMIMO);\\n\\n  function debtNotifier() external view returns (IDebtNotifier);\\n\\n  function governorAlpha() external view returns (IGovernorAlpha);\\n\\n  function timelock() external view returns (ITimelock);\\n\\n  function votingEscrow() external view returns (IVotingEscrow);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/ISupplyMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\ninterface ISupplyMiner {\\n  function baseDebtChanged(address user, uint256 newBaseDebt) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/IGovernorAlpha.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\ninterface IGovernorAlpha {\\n  /// @notice Possible states that a proposal may be in\\n  enum ProposalState { Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }\\n\\n  struct Proposal {\\n    // Unique id for looking up a proposal\\n    uint256 id;\\n    // Creator of the proposal\\n    address proposer;\\n    // The timestamp that the proposal will be available for execution, set once the vote succeeds\\n    uint256 eta;\\n    // the ordered list of target addresses for calls to be made\\n    address[] targets;\\n    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n    uint256[] values;\\n    // The ordered list of function signatures to be called\\n    string[] signatures;\\n    // The ordered list of calldata to be passed to each call\\n    bytes[] calldatas;\\n    // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp\\n    uint256 startTime;\\n    // The timestamp at which voting ends: votes must be cast prior to this timestamp\\n    uint256 endTime;\\n    // Current number of votes in favor of this proposal\\n    uint256 forVotes;\\n    // Current number of votes in opposition to this proposal\\n    uint256 againstVotes;\\n    // Flag marking whether the proposal has been canceled\\n    bool canceled;\\n    // Flag marking whether the proposal has been executed\\n    bool executed;\\n    // Receipts of ballots for the entire set of voters\\n    mapping(address => Receipt) receipts;\\n  }\\n\\n  /// @notice Ballot receipt record for a voter\\n  struct Receipt {\\n    // Whether or not a vote has been cast\\n    bool hasVoted;\\n    // Whether or not the voter supports the proposal\\n    bool support;\\n    // The number of votes the voter had, which were cast\\n    uint256 votes;\\n  }\\n\\n  /// @notice An event emitted when a new proposal is created\\n  event ProposalCreated(\\n    uint256 id,\\n    address proposer,\\n    address[] targets,\\n    uint256[] values,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string description\\n  );\\n\\n  /// @notice An event emitted when a vote has been cast on a proposal\\n  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\\n\\n  /// @notice An event emitted when a proposal has been canceled\\n  event ProposalCanceled(uint256 id);\\n\\n  /// @notice An event emitted when a proposal has been queued in the Timelock\\n  event ProposalQueued(uint256 id, uint256 eta);\\n\\n  /// @notice An event emitted when a proposal has been executed in the Timelock\\n  event ProposalExecuted(uint256 id);\\n\\n  function propose(\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    string memory description,\\n    uint256 endTime\\n  ) external returns (uint256);\\n\\n  function queue(uint256 proposalId) external;\\n\\n  function execute(uint256 proposalId) external payable;\\n\\n  function cancel(uint256 proposalId) external;\\n\\n  function castVote(uint256 proposalId, bool support) external;\\n\\n  function getActions(uint256 proposalId)\\n    external\\n    view\\n    returns (\\n      address[] memory targets,\\n      uint256[] memory values,\\n      string[] memory signatures,\\n      bytes[] memory calldatas\\n    );\\n\\n  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\\n\\n  function state(uint256 proposalId) external view returns (ProposalState);\\n\\n  function quorumVotes() external view returns (uint256);\\n\\n  function proposalThreshold() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/ITimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.6.12;\\n\\ninterface ITimelock {\\n  event NewAdmin(address indexed newAdmin);\\n  event NewPendingAdmin(address indexed newPendingAdmin);\\n  event NewDelay(uint256 indexed newDelay);\\n  event CancelTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event ExecuteTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event QueueTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n\\n  function acceptAdmin() external;\\n\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string calldata signature,\\n    bytes calldata data,\\n    uint256 eta\\n  ) external returns (bytes32);\\n\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string calldata signature,\\n    bytes calldata data,\\n    uint256 eta\\n  ) external;\\n\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string calldata signature,\\n    bytes calldata data,\\n    uint256 eta\\n  ) external payable returns (bytes memory);\\n\\n  function delay() external view returns (uint256);\\n\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  function queuedTransactions(bytes32 hash) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.6.12;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../liquidityMining/interfaces/IGenericMiner.sol';\\n\\ninterface IVotingEscrow {\\n  enum LockAction { CREATE_LOCK, INCREASE_LOCK_AMOUNT, INCREASE_LOCK_TIME }\\n\\n  struct LockedBalance {\\n    uint256 amount;\\n    uint256 end;\\n  }\\n\\n  /** Shared Events */\\n  event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);\\n  event Withdraw(address indexed provider, uint256 value, uint256 ts);\\n  event Expired();\\n\\n  function createLock(uint256 _value, uint256 _unlockTime) external;\\n\\n  function increaseLockAmount(uint256 _value) external;\\n\\n  function increaseLockLength(uint256 _unlockTime) external;\\n\\n  function withdraw() external;\\n\\n  function expireContract() external;\\n\\n  function setMiner(IGenericMiner _miner) external;\\n\\n  function setMinimumLockTime(uint256 _minimumLockTime) external;\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint256);\\n\\n  function balanceOf(address _owner) external view returns (uint256);\\n\\n  function balanceOfAt(address _owner, uint256 _blockTime) external view returns (uint256);\\n\\n  function stakingToken() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/IMIMO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IMIMO is IERC20 {\\n  function burn(address account, uint256 amount) external;\\n\\n  function mint(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/IGenericMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../interfaces/IAddressProvider.sol';\\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\\n\\ninterface IGenericMiner {\\n  struct UserInfo {\\n    uint256 stake;\\n    uint256 accAmountPerShare; // User's accAmountPerShare\\n  }\\n\\n  /// @dev This emit when a users' productivity has changed\\n  /// It emits with the user's address and the the value after the change.\\n  event StakeIncreased(address indexed user, uint256 stake);\\n\\n  /// @dev This emit when a users' productivity has changed\\n  /// It emits with the user's address and the the value after the change.\\n  event StakeDecreased(address indexed user, uint256 stake);\\n\\n  function releaseMIMO(address _user) external;\\n\\n  function a() external view returns (IGovernanceAddressProvider);\\n\\n  function stake(address _user) external view returns (uint256);\\n\\n  function pendingMIMO(address _user) external view returns (uint256);\\n\\n  function totalStake() external view returns (uint256);\\n\\n  function userInfo(address _user) external view returns (UserInfo memory);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/VaultsDataProviderV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IVaultsDataProviderV1.sol\\\";\\nimport \\\"./interfaces/IAddressProviderV1.sol\\\";\\n\\ncontract VaultsDataProviderV1 is IVaultsDataProviderV1 {\\n  using SafeMath for uint256;\\n\\n  IAddressProviderV1 public override a;\\n\\n  uint256 public override vaultCount = 0;\\n\\n  mapping(address => uint256) public override baseDebt;\\n\\n  mapping(uint256 => Vault) private _vaults;\\n  mapping(address => mapping(address => uint256)) private _vaultOwners;\\n\\n  modifier onlyVaultsCore() {\\n    require(msg.sender == address(a.core()), \\\"Caller is not VaultsCore\\\");\\n    _;\\n  }\\n\\n  constructor(IAddressProviderV1 _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Opens a new vault.\\n    @dev only the vaultsCore module can call this function\\n    @param _collateralType address to the collateral asset e.g. WETH\\n    @param _owner the owner of the new vault.\\n  */\\n  function createVault(address _collateralType, address _owner) public override onlyVaultsCore returns (uint256) {\\n    require(_collateralType != address(0));\\n    require(_owner != address(0));\\n    uint256 newId = ++vaultCount;\\n    require(_collateralType != address(0), \\\"collateralType unknown\\\");\\n    Vault memory v = Vault({\\n      collateralType: _collateralType,\\n      owner: _owner,\\n      collateralBalance: 0,\\n      baseDebt: 0,\\n      createdAt: block.timestamp\\n    });\\n    _vaults[newId] = v;\\n    _vaultOwners[_owner][_collateralType] = newId;\\n    return newId;\\n  }\\n\\n  /**\\n    Set the collateral balance of a vault.\\n    @dev only the vaultsCore module can call this function\\n    @param _id Vault ID of which the collateral balance will be updated\\n    @param _balance the new balance of the vault.\\n  */\\n  function setCollateralBalance(uint256 _id, uint256 _balance) public override onlyVaultsCore {\\n    require(vaultExists(_id), \\\"Vault not found.\\\");\\n    Vault storage v = _vaults[_id];\\n    v.collateralBalance = _balance;\\n  }\\n\\n  /**\\n    Set the base debt of a vault.\\n    @dev only the vaultsCore module can call this function\\n    @param _id Vault ID of which the base debt will be updated\\n    @param _newBaseDebt the new base debt of the vault.\\n  */\\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) public override onlyVaultsCore {\\n    Vault storage _vault = _vaults[_id];\\n    if (_newBaseDebt > _vault.baseDebt) {\\n      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);\\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].add(increase);\\n    } else {\\n      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);\\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].sub(decrease);\\n    }\\n    _vault.baseDebt = _newBaseDebt;\\n  }\\n\\n  /**\\n    Get a vault by vault ID.\\n    @param _id The vault's ID to be retrieved\\n  */\\n  function vaults(uint256 _id) public view override returns (Vault memory) {\\n    Vault memory v = _vaults[_id];\\n    return v;\\n  }\\n\\n  /**\\n    Get the owner of a vault.\\n    @param _id the ID of the vault\\n    @return owner of the vault\\n  */\\n  function vaultOwner(uint256 _id) public view override returns (address) {\\n    return _vaults[_id].owner;\\n  }\\n\\n  /**\\n    Get the collateral type of a vault.\\n    @param _id the ID of the vault\\n    @return address for the collateral type of the vault\\n  */\\n  function vaultCollateralType(uint256 _id) public view override returns (address) {\\n    return _vaults[_id].collateralType;\\n  }\\n\\n  /**\\n    Get the collateral balance of a vault.\\n    @param _id the ID of the vault\\n    @return collateral balance of the vault\\n  */\\n  function vaultCollateralBalance(uint256 _id) public view override returns (uint256) {\\n    return _vaults[_id].collateralBalance;\\n  }\\n\\n  /**\\n    Get the base debt of a vault.\\n    @param _id the ID of the vault\\n    @return base debt of the vault\\n  */\\n  function vaultBaseDebt(uint256 _id) public view override returns (uint256) {\\n    return _vaults[_id].baseDebt;\\n  }\\n\\n  /**\\n    Retrieve the vault id for a specified owner and collateral type.\\n    @dev returns 0 for non-existing vaults\\n    @param _collateralType address of the collateral type (Eg: WETH)\\n    @param _owner address of the owner of the vault\\n    @return vault id of the vault or 0\\n  */\\n  function vaultId(address _collateralType, address _owner) public view override returns (uint256) {\\n    return _vaultOwners[_owner][_collateralType];\\n  }\\n\\n  /**\\n    Checks if a specified vault exists.\\n    @param _id the ID of the vault\\n    @return boolean if the vault exists\\n  */\\n  function vaultExists(uint256 _id) public view override returns (bool) {\\n    Vault memory v = _vaults[_id];\\n    return v.collateralType != address(0);\\n  }\\n\\n  /**\\n    Calculated the total outstanding debt for all vaults and all collateral types.\\n    @dev uses the existing cumulative rate. Call `refresh()` on `VaultsCore`\\n    to make sure it's up to date.\\n    @return total debt of the platform\\n  */\\n  function debt() public view override returns (uint256) {\\n    uint256 total = 0;\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      total = total.add(collateralDebt(collateralType));\\n    }\\n    return total;\\n  }\\n\\n  /**\\n    Calculated the total outstanding debt for all vaults of a specific collateral type.\\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\\n    to make sure it's up to date.\\n    @param _collateralType address of the collateral type (Eg: WETH)\\n    @return total debt of the platform of one collateral type\\n  */\\n  function collateralDebt(address _collateralType) public view override returns (uint256) {\\n    return a.ratesManager().calculateDebt(baseDebt[_collateralType], a.core().cumulativeRates(_collateralType));\\n  }\\n\\n  /**\\n    Calculated the total outstanding debt for a specific vault.\\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\\n    to make sure it's up to date.\\n    @param _vaultId the ID of the vault\\n    @return total debt of one vault\\n  */\\n  function vaultDebt(uint256 _vaultId) public view override returns (uint256) {\\n    IVaultsDataProviderV1.Vault memory v = vaults(_vaultId);\\n    return a.ratesManager().calculateDebt(v.baseDebt, a.core().cumulativeRates(v.collateralType));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/interfaces/IVaultsDataProviderV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\nimport './IAddressProviderV1.sol';\\n\\ninterface IVaultsDataProviderV1 {\\n  struct Vault {\\n    // borrowedType support USDX / PAR\\n    address collateralType;\\n    address owner;\\n    uint256 collateralBalance;\\n    uint256 baseDebt;\\n    uint256 createdAt;\\n  }\\n\\n  //Write\\n  function createVault(address _collateralType, address _owner) external returns (uint256);\\n\\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\\n\\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\\n\\n  function a() external view returns (IAddressProviderV1);\\n\\n  // Read\\n  function baseDebt(address _collateralType) external view returns (uint256);\\n\\n  function vaultCount() external view returns (uint256);\\n\\n  function vaults(uint256 _id) external view returns (Vault memory);\\n\\n  function vaultOwner(uint256 _id) external view returns (address);\\n\\n  function vaultCollateralType(uint256 _id) external view returns (address);\\n\\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\\n\\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\\n\\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\\n\\n  function vaultExists(uint256 _id) external view returns (bool);\\n\\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\\n\\n  function debt() external view returns (uint256);\\n\\n  function collateralDebt(address _collateralType) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/LiquidiationManagerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"./interfaces/IAddressProviderV1.sol\\\";\\nimport \\\"./interfaces/IConfigProviderV1.sol\\\";\\nimport \\\"./interfaces/ILiquidationManagerV1.sol\\\";\\n\\ncontract LiquidationManagerV1 is ILiquidationManagerV1, ReentrancyGuard {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  IAddressProviderV1 public override a;\\n\\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18; // 1\\n  uint256 public constant FULL_LIQUIDIATION_TRESHOLD = 100e18; // 100 USDX, vaults below 100 USDX can be liquidated in full\\n\\n  constructor(IAddressProviderV1 _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Check if the health factor is above or equal to 1.\\n    @param _collateralType address of the collateral type\\n    @param _collateralValue value of the collateral in stableX currency\\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\\n    @return boolean if the health factor is >= 1.\\n  */\\n  function isHealthy(\\n    address _collateralType,\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt\\n  ) public view override returns (bool) {\\n    uint256 healthFactor = calculateHealthFactor(_collateralType, _collateralValue, _vaultDebt);\\n    return healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\\n  }\\n\\n  /**\\n    Calculate the healthfactor of a debt balance\\n    @param _collateralType address of the collateral type\\n    @param _collateralValue value of the collateral in stableX currency\\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\\n    @return healthFactor\\n  */\\n  function calculateHealthFactor(\\n    address _collateralType,\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt\\n  ) public view override returns (uint256 healthFactor) {\\n    if (_vaultDebt == 0) return WadRayMath.wad();\\n\\n    // CurrentCollateralizationRatio = deposited ETH in USD / debt in USD\\n    uint256 collateralizationRatio = _collateralValue.wadDiv(_vaultDebt);\\n\\n    // Healthfactor = CurrentCollateralizationRatio / MinimumCollateralizationRatio\\n\\n    uint256 collateralId = a.config().collateralIds(_collateralType);\\n    require(collateralId > 0, \\\"collateral not supported\\\");\\n\\n    uint256 minRatio = a.config().collateralConfigs(collateralId).minCollateralRatio;\\n    if (minRatio > 0) {\\n      return collateralizationRatio.wadDiv(minRatio);\\n    }\\n\\n    return 1e18; // 1\\n  }\\n\\n  /**\\n    Calculate the liquidation bonus for a specified amount\\n    @param _amount amount for which the liquidation bonus shall be calculated\\n    @return bonus the liquidation bonus to pay out\\n  */\\n  function liquidationBonus(uint256 _amount) public view override returns (uint256 bonus) {\\n    return _amount.wadMul(IConfigProviderV1(address(a.config())).liquidationBonus());\\n  }\\n\\n  /**\\n    Apply the liquidation bonus to a balance as a discount.\\n    @param _amount the balance on which to apply to liquidation bonus as a discount.\\n    @return discountedAmount\\n  */\\n  function applyLiquidationDiscount(uint256 _amount) public view override returns (uint256 discountedAmount) {\\n    return _amount.wadDiv(IConfigProviderV1(address(a.config())).liquidationBonus().add(WadRayMath.wad()));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/AddressProviderV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/IVaultsCore.sol\\\";\\nimport \\\"../interfaces/IAccessController.sol\\\";\\nimport \\\"../interfaces/IConfigProvider.sol\\\";\\nimport \\\"../interfaces/ISTABLEX.sol\\\";\\nimport \\\"../interfaces/IPriceFeed.sol\\\";\\nimport \\\"../interfaces/IRatesManager.sol\\\";\\nimport \\\"../interfaces/IVaultsDataProvider.sol\\\";\\nimport \\\"./interfaces/IConfigProviderV1.sol\\\";\\nimport \\\"./interfaces/ILiquidationManagerV1.sol\\\";\\nimport \\\"./interfaces/IVaultsCoreV1.sol\\\";\\n\\ncontract AddressProviderV1 is IAddressProvider {\\n  IAccessController public override controller;\\n  IConfigProvider public override config;\\n  IVaultsCore public override core;\\n\\n  ISTABLEX public override stablex;\\n  IRatesManager public override ratesManager;\\n  IPriceFeed public override priceFeed;\\n  ILiquidationManager public override liquidationManager;\\n  IVaultsDataProvider public override vaultsData;\\n  IFeeDistributor public override feeDistributor;\\n\\n  constructor(IAccessController _controller) public {\\n    controller = _controller;\\n  }\\n\\n  modifier onlyManager() {\\n    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  function setAccessController(IAccessController _controller) public override onlyManager {\\n    require(address(_controller) != address(0));\\n    controller = _controller;\\n  }\\n\\n  function setConfigProvider(IConfigProvider _config) public override onlyManager {\\n    require(address(_config) != address(0));\\n    config = _config;\\n  }\\n\\n  function setVaultsCore(IVaultsCore _core) public override onlyManager {\\n    require(address(_core) != address(0));\\n    core = _core;\\n  }\\n\\n  function setStableX(ISTABLEX _stablex) public override onlyManager {\\n    require(address(_stablex) != address(0));\\n    stablex = _stablex;\\n  }\\n\\n  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {\\n    require(address(_ratesManager) != address(0));\\n    ratesManager = _ratesManager;\\n  }\\n\\n  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {\\n    require(address(_liquidationManager) != address(0));\\n    liquidationManager = _liquidationManager;\\n  }\\n\\n  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {\\n    require(address(_priceFeed) != address(0));\\n    priceFeed = _priceFeed;\\n  }\\n\\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {\\n    require(address(_vaultsData) != address(0));\\n    vaultsData = _vaultsData;\\n  }\\n\\n  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {\\n    require(address(_feeDistributor) != address(0));\\n    feeDistributor = _feeDistributor;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/ConfigProviderV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"./interfaces/IConfigProviderV1.sol\\\";\\nimport \\\"./interfaces/IAddressProviderV1.sol\\\";\\nimport \\\"./interfaces/IVaultsCoreV1.sol\\\";\\n\\ncontract ConfigProviderV1 is IConfigProviderV1 {\\n  IAddressProviderV1 public override a;\\n\\n  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1\\n  mapping(address => uint256) public override collateralIds;\\n\\n  uint256 public override numCollateralConfigs;\\n  uint256 public override liquidationBonus = 5e16; // 5%\\n\\n  constructor(IAddressProviderV1 _addresses) public {\\n    a = _addresses;\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  /**\\n    Creates or overwrites an existing config for a collateral type\\n    @param _collateralType address of the collateral type\\n    @param _debtLimit the debt ceiling for the collateral type\\n    @param _minCollateralRatio the minimum ratio to maintain to avoid liquidation\\n    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.\\n    @param _originationFee an optional origination fee for newly created debt. Can be 0.\\n  */\\n  function setCollateralConfig(\\n    address _collateralType,\\n    uint256 _debtLimit,\\n    uint256 _minCollateralRatio,\\n    uint256 _borrowRate,\\n    uint256 _originationFee\\n  ) public override onlyManager {\\n    require(address(_collateralType) != address(0));\\n    if (collateralIds[_collateralType] == 0) {\\n      //new collateral\\n      IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);\\n      CollateralConfig memory config = CollateralConfig({\\n        collateralType: _collateralType,\\n        debtLimit: _debtLimit,\\n        minCollateralRatio: _minCollateralRatio,\\n        borrowRate: _borrowRate,\\n        originationFee: _originationFee\\n      });\\n\\n      numCollateralConfigs++;\\n      _collateralConfigs[numCollateralConfigs] = config;\\n      collateralIds[_collateralType] = numCollateralConfigs;\\n    } else {\\n      // Update collateral config\\n      IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);\\n      uint256 id = collateralIds[_collateralType];\\n\\n      _collateralConfigs[id].collateralType = _collateralType;\\n      _collateralConfigs[id].debtLimit = _debtLimit;\\n      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;\\n      _collateralConfigs[id].borrowRate = _borrowRate;\\n      _collateralConfigs[id].originationFee = _originationFee;\\n    }\\n    emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);\\n  }\\n\\n  function _emitUpdateEvent(address _collateralType) internal {\\n    emit CollateralUpdated(\\n      _collateralType,\\n      _collateralConfigs[collateralIds[_collateralType]].debtLimit,\\n      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,\\n      _collateralConfigs[collateralIds[_collateralType]].borrowRate,\\n      _collateralConfigs[collateralIds[_collateralType]].originationFee\\n    );\\n  }\\n\\n  /**\\n    Remove the config for a collateral type\\n    @param _collateralType address of the collateral type\\n  */\\n  function removeCollateral(address _collateralType) public override onlyManager {\\n    uint256 id = collateralIds[_collateralType];\\n    require(id != 0, \\\"collateral does not exist\\\");\\n\\n    collateralIds[_collateralType] = 0;\\n\\n    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward\\n    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry\\n    delete _collateralConfigs[numCollateralConfigs];\\n    numCollateralConfigs--;\\n\\n    emit CollateralRemoved(_collateralType);\\n  }\\n\\n  /**\\n    Sets the debt limit for a collateral type\\n    @param _collateralType address of the collateral type\\n    @param _debtLimit the new debt limit\\n  */\\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {\\n    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the minimum collateralization ratio for a collateral type\\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\\n    @param _collateralType address of the collateral type\\n    @param _minCollateralRatio the new minimum collateralization ratio\\n  */\\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)\\n    public\\n    override\\n    onlyManager\\n  {\\n    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the borrowing rate for a collateral type\\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\\n    @param _collateralType address of the collateral type\\n    @param _borrowRate the new borrowing rate for a 1 sec interval\\n  */\\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {\\n    IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);\\n    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the origiation fee for a collateral type\\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\\n    @param _collateralType address of the collateral type\\n    @param _originationFee new origination fee in WAD\\n  */\\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {\\n    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Get the debt limit for a collateral type\\n    @dev this is a platform wide limit for new debt issuance against a specific collateral type\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;\\n  }\\n\\n  /**\\n    Get the minimum collateralization ratio for a collateral type\\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;\\n  }\\n\\n  /**\\n    Get the borrowing rate for a collateral type\\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;\\n  }\\n\\n  /**\\n    Get the origiation fee for a collateral type\\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].originationFee;\\n  }\\n\\n  /**\\n    Set the platform wide incentive for liquidations.\\n    @dev the liquidation bonus is specified in WAD\\n    @param _bonus the liquidation bonus to be paid to liquidators\\n  */\\n  function setLiquidationBonus(uint256 _bonus) public override onlyManager {\\n    liquidationBonus = _bonus;\\n  }\\n\\n  /**\\n    Retreives the entire config for a specific config id.\\n    @param _id the ID of the conifg to be returned\\n  */\\n  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {\\n    require(_id <= numCollateralConfigs, \\\"Invalid config id\\\");\\n    return _collateralConfigs[_id];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrade/Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../v1/interfaces/IConfigProviderV1.sol\\\";\\nimport \\\"../v1/interfaces/IVaultsCoreV1.sol\\\";\\nimport \\\"../v1/interfaces/IFeeDistributorV1.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/IVaultsCore.sol\\\";\\nimport \\\"../interfaces/IVaultsCoreState.sol\\\";\\nimport \\\"../interfaces/ILiquidationManager.sol\\\";\\nimport \\\"../interfaces/IConfigProvider.sol\\\";\\nimport \\\"../interfaces/IFeeDistributor.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IDebtNotifier.sol\\\";\\n\\ncontract Upgrade {\\n  using SafeMath for uint256;\\n\\n  uint256 public constant LIQUIDATION_BONUS = 5e16; // 5%\\n\\n  IAddressProvider public a;\\n  IVaultsCore public core;\\n  IVaultsCoreState public coreState;\\n  ILiquidationManager public liquidationManager;\\n  IConfigProvider public config;\\n  IFeeDistributor public feeDistributor;\\n  IDebtNotifier public debtNotifier;\\n  IPriceFeed public priceFeed;\\n  address public bpool;\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\\n    _;\\n  }\\n\\n  constructor(\\n    IAddressProvider _addresses,\\n    IVaultsCore _core,\\n    IVaultsCoreState _coreState,\\n    ILiquidationManager _liquidationManager,\\n    IConfigProvider _config,\\n    IFeeDistributor _feeDistributor,\\n    IDebtNotifier _debtNotifier,\\n    IPriceFeed _priceFeed,\\n    address _bpool\\n  ) public {\\n    require(address(_addresses) != address(0));\\n    require(address(_core) != address(0));\\n    require(address(_coreState) != address(0));\\n    require(address(_liquidationManager) != address(0));\\n    require(address(_config) != address(0));\\n    require(address(_feeDistributor) != address(0));\\n    require(address(_debtNotifier) != address(0));\\n    require(address(_priceFeed) != address(0));\\n    require(_bpool != address(0));\\n\\n    a = _addresses;\\n    core = _core;\\n    coreState = _coreState;\\n    liquidationManager = _liquidationManager;\\n    config = _config;\\n    feeDistributor = _feeDistributor;\\n    debtNotifier = _debtNotifier;\\n    priceFeed = _priceFeed;\\n    bpool = _bpool;\\n  }\\n\\n  function upgrade() public onlyManager {\\n    IConfigProviderV1 oldConfig = IConfigProviderV1(address(a.config()));\\n    IPriceFeed oldPriceFeed = IPriceFeed(address(a.priceFeed()));\\n    IVaultsCoreV1 oldCore = IVaultsCoreV1(address(a.core()));\\n    IFeeDistributorV1 oldFeeDistributor = IFeeDistributorV1(address(a.feeDistributor()));\\n\\n    bytes32 MINTER_ROLE = a.controller().MINTER_ROLE();\\n    bytes32 MANAGER_ROLE = a.controller().MANAGER_ROLE();\\n    bytes32 DEFAULT_ADMIN_ROLE = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n    a.controller().grantRole(MANAGER_ROLE, address(this));\\n    a.controller().grantRole(MINTER_ROLE, address(core));\\n    a.controller().grantRole(MINTER_ROLE, address(feeDistributor));\\n\\n    oldCore.refresh();\\n    if (oldCore.availableIncome() > 0) {\\n      oldFeeDistributor.release();\\n    }\\n\\n    a.controller().revokeRole(MINTER_ROLE, address(a.core()));\\n    a.controller().revokeRole(MINTER_ROLE, address(a.feeDistributor()));\\n\\n    oldCore.upgrade(payable(address(core)));\\n\\n    a.setVaultsCore(core);\\n    a.setConfigProvider(config);\\n    a.setLiquidationManager(liquidationManager);\\n    a.setFeeDistributor(feeDistributor);\\n    a.setPriceFeed(priceFeed);\\n\\n    priceFeed.setEurOracle(address(oldPriceFeed.eurOracle()));\\n\\n    uint256 numCollateralConfigs = oldConfig.numCollateralConfigs();\\n    for (uint256 i = 1; i <= numCollateralConfigs; i++) {\\n      IConfigProviderV1.CollateralConfig memory collateralConfig = oldConfig.collateralConfigs(i);\\n\\n      config.setCollateralConfig(\\n        collateralConfig.collateralType,\\n        collateralConfig.debtLimit,\\n        collateralConfig.minCollateralRatio,\\n        collateralConfig.minCollateralRatio,\\n        collateralConfig.borrowRate,\\n        collateralConfig.originationFee,\\n        LIQUIDATION_BONUS,\\n        0\\n      );\\n\\n      priceFeed.setAssetOracle(\\n        collateralConfig.collateralType,\\n        address(oldPriceFeed.assetOracles(collateralConfig.collateralType))\\n      );\\n    }\\n\\n    coreState.syncStateFromV1(oldCore);\\n    core.acceptUpgrade(payable(address(oldCore)));\\n    core.setDebtNotifier(debtNotifier);\\n    debtNotifier.a().setDebtNotifier(debtNotifier);\\n\\n    address[] memory payees = new address[](2);\\n    payees[0] = bpool;\\n    payees[1] = address(core);\\n    uint256[] memory shares = new uint256[](2);\\n    shares[0] = uint256(90);\\n    shares[1] = uint256(10);\\n    feeDistributor.changePayees(payees, shares);\\n\\n    a.controller().revokeRole(MANAGER_ROLE, address(this));\\n    a.controller().revokeRole(DEFAULT_ADMIN_ROLE, address(this));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/interfaces/IFeeDistributorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport './IAddressProviderV1.sol';\\n\\ninterface IFeeDistributorV1 {\\n  event PayeeAdded(address indexed account, uint256 shares);\\n  event FeeReleased(uint256 income, uint256 releasedAt);\\n\\n  function release() external;\\n\\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\\n\\n  function a() external view returns (IAddressProviderV1);\\n\\n  function lastReleasedAt() external view returns (uint256);\\n\\n  function getPayees() external view returns (address[] memory);\\n\\n  function totalShares() external view returns (uint256);\\n\\n  function shares(address payee) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/upgrade/MIMODeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IMIMO.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IMIMODistributor.sol\\\";\\nimport \\\"../liquidityMining/interfaces/ISupplyMiner.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IDemandMiner.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IDebtNotifier.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"../governance/interfaces/IVotingEscrow.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ncontract MIMODeployment {\\n  IGovernanceAddressProvider public ga;\\n  IMIMO public mimo;\\n  IMIMODistributor public mimoDistributor;\\n  ISupplyMiner public wethSupplyMiner;\\n  ISupplyMiner public wbtcSupplyMiner;\\n  ISupplyMiner public usdcSupplyMiner;\\n  IDemandMiner public demandMiner;\\n  IDebtNotifier public debtNotifier;\\n  IVotingEscrow public votingEscrow;\\n\\n  address public weth;\\n  address public wbtc;\\n  address public usdc;\\n\\n  modifier onlyManager() {\\n    require(ga.controller().hasRole(ga.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not Manager\\\");\\n    _;\\n  }\\n\\n  constructor(\\n    IGovernanceAddressProvider _ga,\\n    IMIMO _mimo,\\n    IMIMODistributor _mimoDistributor,\\n    ISupplyMiner _wethSupplyMiner,\\n    ISupplyMiner _wbtcSupplyMiner,\\n    ISupplyMiner _usdcSupplyMiner,\\n    IDemandMiner _demandMiner,\\n    IDebtNotifier _debtNotifier,\\n    IVotingEscrow _votingEscrow,\\n    address _weth,\\n    address _wbtc,\\n    address _usdc\\n  ) public {\\n    require(address(_ga) != address(0));\\n    require(address(_mimo) != address(0));\\n    require(address(_mimoDistributor) != address(0));\\n    require(address(_wethSupplyMiner) != address(0));\\n    require(address(_wbtcSupplyMiner) != address(0));\\n    require(address(_usdcSupplyMiner) != address(0));\\n    require(address(_demandMiner) != address(0));\\n    require(address(_debtNotifier) != address(0));\\n    require(address(_votingEscrow) != address(0));\\n    require(_weth != address(0));\\n    require(_wbtc != address(0));\\n    require(_usdc != address(0));\\n\\n    ga = _ga;\\n    mimo = _mimo;\\n    mimoDistributor = _mimoDistributor;\\n    wethSupplyMiner = _wethSupplyMiner;\\n    wbtcSupplyMiner = _wbtcSupplyMiner;\\n    usdcSupplyMiner = _usdcSupplyMiner;\\n    demandMiner = _demandMiner;\\n    debtNotifier = _debtNotifier;\\n    votingEscrow = _votingEscrow;\\n\\n    weth = _weth;\\n    wbtc = _wbtc;\\n    usdc = _usdc;\\n  }\\n\\n  function setup() public onlyManager {\\n    //IAddressProvider parallel = a.parallel();\\n\\n    //bytes32 MIMO_MINTER_ROLE = keccak256(\\\"MIMO_MINTER_ROLE\\\");\\n    //bytes32 DEFAULT_ADMIN_ROLE = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n\\n    ga.setMIMO(mimo);\\n    ga.setVotingEscrow(votingEscrow);\\n\\n    debtNotifier.setCollateralSupplyMiner(weth, wethSupplyMiner);\\n    debtNotifier.setCollateralSupplyMiner(wbtc, wbtcSupplyMiner);\\n    debtNotifier.setCollateralSupplyMiner(usdc, usdcSupplyMiner);\\n\\n    address[] memory payees = new address[](4);\\n    payees[0] = address(wethSupplyMiner);\\n    payees[1] = address(wbtcSupplyMiner);\\n    payees[2] = address(usdcSupplyMiner);\\n    payees[3] = address(demandMiner);\\n    uint256[] memory shares = new uint256[](4);\\n    shares[0] = uint256(20);\\n    shares[1] = uint256(25);\\n    shares[2] = uint256(5);\\n    shares[3] = uint256(50);\\n    mimoDistributor.changePayees(payees, shares);\\n\\n    bytes32 MANAGER_ROLE = ga.controller().MANAGER_ROLE();\\n    ga.controller().renounceRole(MANAGER_ROLE, address(this));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/IMIMODistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\\nimport './IBaseDistributor.sol';\\n\\ninterface IMIMODistributorExtension {\\n  function startTime() external view returns (uint256);\\n\\n  function currentIssuance() external view returns (uint256);\\n\\n  function weeklyIssuanceAt(uint256 timestamp) external view returns (uint256);\\n\\n  function totalSupplyAt(uint256 timestamp) external view returns (uint256);\\n}\\n\\ninterface IMIMODistributor is IBaseDistributor, IMIMODistributorExtension {}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/IDemandMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IDemandMiner {\\n  function deposit(uint256 amount) external;\\n\\n  function withdraw(uint256 amount) external;\\n\\n  function token() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/IBaseDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\\n\\ninterface IBaseDistributor {\\n  event PayeeAdded(address account, uint256 shares);\\n  event TokensReleased(uint256 newTokens, uint256 releasedAt);\\n\\n  /**\\n    Public function to release the accumulated new MIMO tokens to the payees.\\n    @dev anyone can call this.\\n  */\\n  function release() external;\\n\\n  /**\\n    Updates the payee configuration to a new one.\\n    @dev will release existing fees before the update.\\n    @param _payees Array of payees\\n    @param _shares Array of shares for each payee\\n  */\\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\\n\\n  function totalShares() external view returns (uint256);\\n\\n  function shares(address) external view returns (uint256);\\n\\n  function a() external view returns (IGovernanceAddressProvider);\\n\\n  function mintableTokens() external view returns (uint256);\\n\\n  /**\\n    Get current configured payees.\\n    @return array of current payees.\\n  */\\n  function getPayees() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/upgrade/RepayVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/IVaultsDataProvider.sol\\\";\\nimport \\\"../interfaces/IVaultsCore.sol\\\";\\n\\ncontract RepayVault {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  uint256 public constant REPAY_PER_VAULT = 10 ether;\\n\\n  IAddressProvider public a;\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n\\n    a = _addresses;\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not Manager\\\");\\n    _;\\n  }\\n\\n  function repay() public onlyManager {\\n    IVaultsCore core = a.core();\\n    IVaultsDataProvider vaultsData = a.vaultsData();\\n    uint256 vaultCount = a.vaultsData().vaultCount();\\n\\n    for (uint256 vaultId = 1; vaultId <= vaultCount; vaultId++) {\\n      uint256 baseDebt = vaultsData.vaultBaseDebt(vaultId);\\n\\n      //if (vaultId==28 || vaultId==29 || vaultId==30 || vaultId==31 || vaultId==32 || vaultId==33 || vaultId==35){\\n      //  continue;\\n      //}\\n\\n      if (baseDebt == 0) {\\n        continue;\\n      }\\n\\n      core.repay(vaultId, REPAY_PER_VAULT);\\n    }\\n\\n    IERC20 par = IERC20(a.stablex());\\n    par.safeTransfer(msg.sender, par.balanceOf(address(this)));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/VaultsCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../interfaces/IVaultsCore.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IVaultsCoreState.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IDebtNotifier.sol\\\";\\n\\ncontract VaultsCore is IVaultsCore, ReentrancyGuard {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  uint256 internal constant _MAX_INT = 2**256 - 1;\\n\\n  IAddressProvider public override a;\\n  IWETH public override WETH;\\n  IVaultsCoreState public override state;\\n  IDebtNotifier public override debtNotifier;\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\\n    _;\\n  }\\n\\n  modifier onlyVaultOwner(uint256 _vaultId) {\\n    require(a.vaultsData().vaultOwner(_vaultId) == msg.sender);\\n    _;\\n  }\\n\\n  constructor(\\n    IAddressProvider _addresses,\\n    IWETH _IWETH,\\n    IVaultsCoreState _vaultsCoreState\\n  ) public {\\n    require(address(_addresses) != address(0));\\n    require(address(_IWETH) != address(0));\\n    require(address(_vaultsCoreState) != address(0));\\n    a = _addresses;\\n    WETH = _IWETH;\\n    state = _vaultsCoreState;\\n  }\\n\\n  // For a contract to receive ETH, it needs to have a payable fallback function\\n  // https://ethereum.stackexchange.com/a/47415\\n  receive() external payable {\\n    require(msg.sender == address(WETH));\\n  }\\n\\n  /*\\n    Allow smooth upgrading of the vaultscore.\\n    @dev this function approves token transfers to the new vaultscore of\\n    both stablex and all configured collateral types\\n    @param _newVaultsCore address of the new vaultscore\\n  */\\n  function upgrade(address payable _newVaultsCore) public override onlyManager {\\n    require(address(_newVaultsCore) != address(0));\\n    require(a.stablex().approve(_newVaultsCore, _MAX_INT));\\n\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      IERC20 asset = IERC20(collateralType);\\n      asset.safeApprove(_newVaultsCore, _MAX_INT);\\n    }\\n  }\\n\\n  /*\\n    Allow smooth upgrading of the VaultsCore.\\n    @dev this function transfers both PAR and all configured collateral\\n    types to the new vaultscore.\\n  */\\n  function acceptUpgrade(address payable _oldVaultsCore) public override onlyManager {\\n    IERC20 stableX = IERC20(a.stablex());\\n    stableX.safeTransferFrom(_oldVaultsCore, address(this), stableX.balanceOf(_oldVaultsCore));\\n\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      IERC20 asset = IERC20(collateralType);\\n      asset.safeTransferFrom(_oldVaultsCore, address(this), asset.balanceOf(_oldVaultsCore));\\n    }\\n  }\\n\\n  /**\\n    Configure the debt notifier.\\n    @param _debtNotifier the new DebtNotifier module address.\\n  **/\\n  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {\\n    require(address(_debtNotifier) != address(0));\\n    debtNotifier = _debtNotifier;\\n  }\\n\\n  /**\\n    Deposit an ERC20 token into the vault of the msg.sender as collateral\\n    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.\\n    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\\n    @param _collateralType the address of the collateral type to be deposited\\n    @param _amount the amount of tokens to be deposited in WEI.\\n  **/\\n  function deposit(address _collateralType, uint256 _amount) public override {\\n    require(a.config().collateralIds(_collateralType) != 0);\\n\\n    IERC20 asset = IERC20(_collateralType);\\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n    _addCollateralToVault(_collateralType, _amount);\\n  }\\n\\n  /**\\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral\\n    @dev A new vault is created if no WETH vault exists\\n  **/\\n  function depositETH() public payable override {\\n    WETH.deposit{ value: msg.value }();\\n    _addCollateralToVault(address(WETH), msg.value);\\n  }\\n\\n  /**\\n    Deposit an ERC20 token into the specified vault as collateral\\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\\n    @param _vaultId the address of the collateral type to be deposited\\n    @param _amount the amount of tokens to be deposited in WEI.\\n  **/\\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) public override {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n    require(v.collateralType != address(0));\\n\\n    IERC20 asset = IERC20(v.collateralType);\\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n    _addCollateralToVaultById(_vaultId, _amount);\\n  }\\n\\n  /**\\n    Wraps ETH and deposits WETH into the specified vault as collateral\\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\\n    @param _vaultId the address of the collateral type to be deposited\\n  **/\\n  function depositETHByVaultId(uint256 _vaultId) public payable override {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n    require(v.collateralType == address(WETH));\\n\\n    WETH.deposit{ value: msg.value }();\\n\\n    _addCollateralToVaultById(_vaultId, msg.value);\\n  }\\n\\n  /**\\n    Deposit an ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\\n    @dev see deposit() and borrow()\\n    @param _collateralType the address of the collateral type to be deposited\\n    @param _depositAmount the amount of tokens to be deposited in WEI.\\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\\n  **/\\n  function depositAndBorrow(\\n    address _collateralType,\\n    uint256 _depositAmount,\\n    uint256 _borrowAmount\\n  ) public override {\\n    deposit(_collateralType, _depositAmount);\\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\\n    borrow(vaultId, _borrowAmount);\\n  }\\n\\n  /**\\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\\n    @dev see depositETH() and borrow()\\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\\n  **/\\n  function depositETHAndBorrow(uint256 _borrowAmount) public payable override {\\n    depositETH();\\n    uint256 vaultId = a.vaultsData().vaultId(address(WETH), msg.sender);\\n    borrow(vaultId, _borrowAmount);\\n  }\\n\\n  function _addCollateralToVault(address _collateralType, uint256 _amount) internal {\\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\\n    if (vaultId == 0) {\\n      vaultId = a.vaultsData().createVault(_collateralType, msg.sender);\\n    }\\n\\n    _addCollateralToVaultById(vaultId, _amount);\\n  }\\n\\n  function _addCollateralToVaultById(uint256 _vaultId, uint256 _amount) internal {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n\\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.add(_amount));\\n\\n    emit Deposited(_vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Withdraws ERC20 tokens from a vault.\\n    @dev Only the owner of a vault can withdraw collateral from it.\\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\\n    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.\\n  **/\\n  function withdraw(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\\n    _removeCollateralFromVault(_vaultId, _amount);\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n\\n    IERC20 asset = IERC20(v.collateralType);\\n    asset.safeTransfer(msg.sender, _amount);\\n  }\\n\\n  /**\\n    Withdraws ETH from a WETH vault.\\n    @dev Only the owner of a vault can withdraw collateral from it.\\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\\n    @param _amount the amount of ETH to be withdrawn in WEI.\\n  **/\\n  function withdrawETH(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\\n    _removeCollateralFromVault(_vaultId, _amount);\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n\\n    require(v.collateralType == address(WETH));\\n\\n    WETH.withdraw(_amount);\\n    msg.sender.transfer(_amount);\\n  }\\n\\n  function _removeCollateralFromVault(uint256 _vaultId, uint256 _amount) internal {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n    require(_amount <= v.collateralBalance);\\n    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);\\n    a.vaultsData().setCollateralBalance(_vaultId, newCollateralBalance);\\n    if (v.baseDebt > 0) {\\n      // Save gas cost when withdrawing from 0 debt vault\\n      state.refreshCollateral(v.collateralType);\\n      uint256 newCollateralValue = a.priceFeed().convertFrom(v.collateralType, newCollateralBalance);\\n      require(\\n        a.liquidationManager().isHealthy(\\n          newCollateralValue,\\n          a.vaultsData().vaultDebt(_vaultId),\\n          a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio\\n        )\\n      );\\n    }\\n\\n    emit Withdrawn(_vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Borrow new PAR tokens from a vault.\\n    @dev Only the owner of a vault can borrow from it.\\n    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.\\n     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.\\n    @param _vaultId the ID of the vault from which to borrow.\\n    @param _amount the amount of borrowed PAR tokens in WEI.\\n  **/\\n  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n\\n    // Make sure current rate is up to date\\n    state.refreshCollateral(v.collateralType);\\n\\n    uint256 originationFeePercentage = a.config().collateralOriginationFee(v.collateralType);\\n    uint256 newDebt = _amount;\\n    if (originationFeePercentage > 0) {\\n      newDebt = newDebt.add(_amount.wadMul(originationFeePercentage));\\n    }\\n\\n    // Increment vault borrow balance\\n    uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(newDebt, cumulativeRates(v.collateralType));\\n\\n    a.vaultsData().setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));\\n\\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\\n    uint256 newVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n\\n    require(a.vaultsData().collateralDebt(v.collateralType) <= a.config().collateralDebtLimit(v.collateralType));\\n\\n    bool isHealthy = a.liquidationManager().isHealthy(\\n      collateralValue,\\n      newVaultDebt,\\n      a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio\\n    );\\n    require(isHealthy);\\n\\n    a.stablex().mint(msg.sender, _amount);\\n    debtNotifier.debtChanged(_vaultId);\\n    emit Borrowed(_vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Convenience function to repay all debt of a vault\\n    @dev `repayAll()` will update the outstanding vault debt to the current time.\\n    @param _vaultId the ID of the vault for which to repay the debt.\\n  **/\\n  function repayAll(uint256 _vaultId) public override {\\n    repay(_vaultId, _MAX_INT);\\n  }\\n\\n  /**\\n    Repay an outstanding PAR balance to a vault.\\n    @dev `repay()` will update the outstanding vault debt to the current time.\\n    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.\\n    @param _amount the amount of PAR tokens in WEI to be repaid.\\n  **/\\n  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {\\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\\n\\n    // Make sure current rate is up to date\\n    state.refreshCollateral(collateralType);\\n\\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n    // Decrement vault borrow balance\\n    if (_amount >= currentVaultDebt) {\\n      //full repayment\\n      _amount = currentVaultDebt; //only pay back what's outstanding\\n    }\\n    _reduceVaultDebt(_vaultId, _amount);\\n    a.stablex().burn(msg.sender, _amount);\\n    debtNotifier.debtChanged(_vaultId);\\n    emit Repaid(_vaultId, _amount, msg.sender);\\n  }\\n\\n  /**\\n    Internal helper function to reduce the debt of a vault.\\n    @dev assumes cumulative rates for the vault's collateral type are up to date.\\n    please call `refreshCollateral()` before calling this function.\\n    @param _vaultId the ID of the vault for which to reduce the debt.\\n    @param _amount the amount of debt to be reduced.\\n  **/\\n  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {\\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\\n\\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n    uint256 remainder = currentVaultDebt.sub(_amount);\\n    uint256 cumulativeRate = cumulativeRates(collateralType);\\n\\n    if (remainder == 0) {\\n      a.vaultsData().setBaseDebt(_vaultId, 0);\\n    } else {\\n      uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);\\n      a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);\\n    }\\n  }\\n\\n  /**\\n    Liquidate a vault that is below the liquidation treshold by repaying its outstanding debt.\\n    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\\n    to the liquidator. `liquidate()` can be called by anyone.\\n    @param _vaultId the ID of the vault to be liquidated.\\n  **/\\n  function liquidate(uint256 _vaultId) public override {\\n    liquidatePartial(_vaultId, _MAX_INT);\\n  }\\n\\n  /**\\n    Liquidate a vault partially that is below the liquidation treshold by repaying part of its outstanding debt.\\n    @dev `liquidatePartial()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\\n    to the liquidator. A LiquidationFee will be applied to the borrower during the liquidation.\\n    This means that the change in outstanding debt can be smaller than the repaid amount.\\n    `liquidatePartial()` can be called by anyone.\\n    @param _vaultId the ID of the vault to be liquidated.\\n    @param _amount the amount of debt+liquidationFee to repay.\\n  **/\\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {\\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\\n\\n    state.refreshCollateral(v.collateralType);\\n\\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\\n\\n    require(\\n      !a.liquidationManager().isHealthy(\\n        collateralValue,\\n        currentVaultDebt,\\n        a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio\\n      )\\n    );\\n\\n    uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(\\n      a.config().collateralLiquidationFee(v.collateralType)\\n    );\\n    uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);\\n\\n    uint256 repayAmount;\\n\\n    if (_amount > maxLiquiditionCost) {\\n      _amount = maxLiquiditionCost;\\n      repayAmount = currentVaultDebt;\\n    } else {\\n      repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);\\n    }\\n\\n    // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).\\n    uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));\\n    uint256 insuranceAmount = 0;\\n    if (collateralValueToReceive >= collateralValue) {\\n      // Not enough collateral for debt & liquidation fee\\n      collateralValueToReceive = collateralValue;\\n      uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(\\n        v.collateralType,\\n        collateralValue\\n      );\\n\\n      if (currentVaultDebt > discountedCollateralValue) {\\n        // Not enough collateral for debt alone\\n        insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);\\n        require(a.stablex().balanceOf(address(this)) >= insuranceAmount);\\n        a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt\\n        emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);\\n      }\\n\\n      repayAmount = currentVaultDebt.sub(insuranceAmount);\\n      _amount = discountedCollateralValue;\\n    }\\n\\n    // reduce the vault debt by repayAmount\\n    _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));\\n    a.stablex().burn(msg.sender, _amount);\\n\\n    // send the claimed collateral to the liquidator\\n    uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);\\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));\\n    IERC20 asset = IERC20(v.collateralType);\\n    asset.safeTransfer(msg.sender, collateralToReceive);\\n\\n    debtNotifier.debtChanged(_vaultId);\\n\\n    emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);\\n  }\\n\\n  /**\\n    Returns the cumulativeRate of a collateral type. This function exists for\\n    backwards compatibility with the VaultsDataProvider.\\n    @param _collateralType the address of the collateral type.\\n  **/\\n  function cumulativeRates(address _collateralType) public view override returns (uint256) {\\n    return state.cumulativeRates(_collateralType);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/VaultsCoreState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/IVaultsCoreState.sol\\\";\\nimport \\\"../v1/interfaces/IVaultsCoreV1.sol\\\";\\n\\ncontract VaultsCoreState is IVaultsCoreState {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  uint256 internal constant _MAX_INT = 2**256 - 1;\\n\\n  bool public override synced = false;\\n  IAddressProvider public override a;\\n\\n  mapping(address => uint256) public override cumulativeRates;\\n  mapping(address => uint256) public override lastRefresh;\\n\\n  modifier onlyConfig() {\\n    require(msg.sender == address(a.config()));\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\\n    _;\\n  }\\n\\n  modifier notSynced() {\\n    require(!synced);\\n    _;\\n  }\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Calculate the available income\\n    @return available income that has not been minted yet.\\n  **/\\n  function availableIncome() public view override returns (uint256) {\\n    return a.vaultsData().debt().sub(a.stablex().totalSupply());\\n  }\\n\\n  /**\\n    Refresh the cumulative rates and debts of all vaults and all collateral types.\\n    @dev anyone can call this.\\n  **/\\n  function refresh() public override {\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      refreshCollateral(collateralType);\\n    }\\n  }\\n\\n  /**\\n    Sync state with another instance. This is used during version upgrade to keep V2 in sync with V2.\\n    @dev This call will read the state via\\n      `cumulativeRates(address collateralType)` and `lastRefresh(address collateralType)`.\\n    @param _stateAddress address from which the state is to be copied.\\n  **/\\n  function syncState(IVaultsCoreState _stateAddress) public override onlyManager notSynced {\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      cumulativeRates[collateralType] = _stateAddress.cumulativeRates(collateralType);\\n      lastRefresh[collateralType] = _stateAddress.lastRefresh(collateralType);\\n    }\\n    synced = true;\\n  }\\n\\n  /**\\n    Sync state with v1 core. This is used during version upgrade to keep V2 in sync with V1.\\n    @dev This call will read the state via\\n      `cumulativeRates(address collateralType)` and `lastRefresh(address collateralType)`.\\n    @param _core address of core v1 from which the state is to be copied.\\n  **/\\n  function syncStateFromV1(IVaultsCoreV1 _core) public override onlyManager notSynced {\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      cumulativeRates[collateralType] = _core.cumulativeRates(collateralType);\\n      lastRefresh[collateralType] = _core.lastRefresh(collateralType);\\n    }\\n    synced = true;\\n  }\\n\\n  /**\\n    Initialize the cumulative rates to 1 for a new collateral type.\\n    @param _collateralType the address of the new collateral type to be initialized\\n  **/\\n  function initializeRates(address _collateralType) public override onlyConfig {\\n    require(_collateralType != address(0));\\n    lastRefresh[_collateralType] = block.timestamp;\\n    cumulativeRates[_collateralType] = WadRayMath.ray();\\n  }\\n\\n  /**\\n    Refresh the cumulative rate of a collateraltype.\\n    @dev this updates the debt for all vaults with the specified collateral type.\\n    @param _collateralType the address of the collateral type to be refreshed.\\n  **/\\n  function refreshCollateral(address _collateralType) public override {\\n    require(_collateralType != address(0));\\n    require(a.config().collateralIds(_collateralType) != 0);\\n    uint256 timestamp = block.timestamp;\\n    uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);\\n    _refreshCumulativeRate(_collateralType, timeElapsed);\\n    lastRefresh[_collateralType] = timestamp;\\n  }\\n\\n  /**\\n    Internal function to increase the cumulative rate over a specified time period\\n    @dev this updates the debt for all vaults with the specified collateral type.\\n    @param _collateralType the address of the collateral type to be updated\\n    @param _timeElapsed the amount of time in seconds to add to the cumulative rate\\n  **/\\n  function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {\\n    uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);\\n    uint256 oldCumulativeRate = cumulativeRates[_collateralType];\\n    cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(\\n      borrowRate,\\n      oldCumulativeRate,\\n      _timeElapsed\\n    );\\n    emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/FeeDistributorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../interfaces/ISTABLEX.sol\\\";\\nimport \\\"./interfaces/IFeeDistributorV1.sol\\\";\\nimport \\\"./interfaces/IAddressProviderV1.sol\\\";\\n\\ncontract FeeDistributorV1 is IFeeDistributorV1, ReentrancyGuard {\\n  using SafeMath for uint256;\\n\\n  event PayeeAdded(address account, uint256 shares);\\n  event FeeReleased(uint256 income, uint256 releasedAt);\\n\\n  uint256 public override lastReleasedAt;\\n  IAddressProviderV1 public override a;\\n\\n  uint256 public override totalShares;\\n  mapping(address => uint256) public override shares;\\n  address[] public payees;\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not Manager\\\");\\n    _;\\n  }\\n\\n  constructor(IAddressProviderV1 _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Public function to release the accumulated fee income to the payees.\\n    @dev anyone can call this.\\n  */\\n  function release() public override nonReentrant {\\n    uint256 income = a.core().availableIncome();\\n    require(income > 0, \\\"income is 0\\\");\\n    require(payees.length > 0, \\\"Payees not configured yet\\\");\\n    lastReleasedAt = now;\\n\\n    // Mint USDX to all receivers\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      address payee = payees[i];\\n      _release(income, payee);\\n    }\\n    emit FeeReleased(income, lastReleasedAt);\\n  }\\n\\n  /**\\n    Get current configured payees.\\n    @return array of current payees.\\n  */\\n  function getPayees() public view override returns (address[] memory) {\\n    return payees;\\n  }\\n\\n  /**\\n    Internal function to release a percentage of income to a specific payee\\n    @dev uses totalShares to calculate correct share\\n    @param _totalIncomeReceived Total income for all payees, will be split according to shares\\n    @param _payee The address of the payee to whom to distribute the fees.\\n  */\\n  function _release(uint256 _totalIncomeReceived, address _payee) internal {\\n    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);\\n    a.stablex().mint(_payee, payment);\\n  }\\n\\n  /**\\n    Internal function to add a new payee.\\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\\n    @param _payee The address of the payee to add.\\n    @param _shares The number of shares owned by the payee.\\n  */\\n  function _addPayee(address _payee, uint256 _shares) internal {\\n    require(_payee != address(0), \\\"payee is the zero address\\\");\\n    require(_shares > 0, \\\"shares are 0\\\");\\n    require(shares[_payee] == 0, \\\"payee already has shares\\\");\\n\\n    payees.push(_payee);\\n    shares[_payee] = _shares;\\n    totalShares = totalShares.add(_shares);\\n    emit PayeeAdded(_payee, _shares);\\n  }\\n\\n  /**\\n    Updates the payee configuration to a new one.\\n    @dev will release existing fees before the update.\\n    @param _payees Array of payees\\n    @param _shares Array of shares for each payee\\n  */\\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\\n    require(_payees.length == _shares.length, \\\"Payees and shares mismatched\\\");\\n    require(_payees.length > 0, \\\"No payees\\\");\\n\\n    uint256 income = a.core().availableIncome();\\n    if (income > 0 && payees.length > 0) {\\n      release();\\n    }\\n\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      delete shares[payees[i]];\\n    }\\n    delete payees;\\n    totalShares = 0;\\n\\n    for (uint256 i = 0; i < _payees.length; i++) {\\n      _addPayee(_payees[i], _shares[i]);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/token/USDX.sol\": {\r\n      \"content\": \"// solium-disable security/no-block-members\\n// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/ISTABLEX.sol\\\";\\n\\n/**\\n * @title   USDX\\n * @notice  Stablecoin which can be minted against collateral in a vault\\n */\\ncontract USDX is ISTABLEX, ERC20(\\\"USD Stablecoin\\\", \\\"USDX\\\") {\\n  IAddressProvider public override a;\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  function mint(address account, uint256 amount) public override onlyMinter {\\n    _mint(account, amount);\\n  }\\n\\n  function burn(address account, uint256 amount) public override onlyMinter {\\n    _burn(account, amount);\\n  }\\n\\n  modifier onlyMinter() {\\n    require(a.controller().hasRole(a.controller().MINTER_ROLE(), msg.sender), \\\"Caller is not a minter\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/token/PAR.sol\": {\r\n      \"content\": \"// solium-disable security/no-block-members\\n// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/ISTABLEX.sol\\\";\\n\\n/**\\n * @title  PAR\\n * @notice  Stablecoin which can be minted against collateral in a vault\\n */\\ncontract PAR is ISTABLEX, ERC20(\\\"PAR Stablecoin\\\", \\\"PAR\\\") {\\n  IAddressProvider public override a;\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  function mint(address account, uint256 amount) public override onlyMinter {\\n    _mint(account, amount);\\n  }\\n\\n  function burn(address account, uint256 amount) public override onlyMinter {\\n    _burn(account, amount);\\n  }\\n\\n  modifier onlyMinter() {\\n    require(a.controller().hasRole(a.controller().MINTER_ROLE(), msg.sender), \\\"Caller is not a minter\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/token/MIMO.sol\": {\r\n      \"content\": \"// solium-disable security/no-block-members\\n// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\n\\n/**\\n * @title  MIMO\\n * @notice  MIMO Governance token\\n */\\ncontract MIMO is ERC20(\\\"MIMO Parallel Governance Token\\\", \\\"MIMO\\\") {\\n  IGovernanceAddressProvider public a;\\n\\n  bytes32 public constant MIMO_MINTER_ROLE = keccak256(\\\"MIMO_MINTER_ROLE\\\");\\n\\n  constructor(IGovernanceAddressProvider _a) public {\\n    require(address(_a) != address(0));\\n\\n    a = _a;\\n  }\\n\\n  modifier onlyMIMOMinter() {\\n    require(a.controller().hasRole(MIMO_MINTER_ROLE, msg.sender), \\\"Caller is not MIMO Minter\\\");\\n    _;\\n  }\\n\\n  function mint(address account, uint256 amount) public onlyMIMOMinter {\\n    _mint(account, amount);\\n  }\\n\\n  function burn(address account, uint256 amount) public onlyMIMOMinter {\\n    _burn(account, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrade/PreUseAirdrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../token/MIMO.sol\\\";\\n\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IMIMODistributor.sol\\\";\\n\\ncontract PreUseAirdrop {\\n  using SafeERC20 for IERC20;\\n\\n  struct Payout {\\n    address recipient;\\n    uint256 amount;\\n  }\\n\\n  Payout[] public payouts;\\n\\n  IGovernanceAddressProvider public ga;\\n  IMIMODistributor public mimoDistributor;\\n\\n  modifier onlyManager() {\\n    require(ga.controller().hasRole(ga.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  constructor(IGovernanceAddressProvider _ga, IMIMODistributor _mimoDistributor) public {\\n    require(address(_ga) != address(0));\\n    require(address(_mimoDistributor) != address(0));\\n\\n    ga = _ga;\\n    mimoDistributor = _mimoDistributor;\\n\\n    payouts.push(Payout(0xBBd92c75C6f8B0FFe9e5BCb2e56a5e2600871a10, 271147720731494841509243076));\\n    payouts.push(Payout(0xcc8793d5eB95fAa707ea4155e09b2D3F44F33D1E, 210989402066696530434956148));\\n    payouts.push(Payout(0x185f19B43d818E10a31BE68f445ef8EDCB8AFB83, 22182938994846641176273320));\\n    payouts.push(Payout(0xDeD9F901D40A96C3Ee558E6885bcc7eFC51ad078, 13678603288816593264718593));\\n    payouts.push(Payout(0x0B3890bbF2553Bd098B45006aDD734d6Fbd6089E, 8416873402881706143143730));\\n    payouts.push(Payout(0x3F41a1CFd3C8B8d9c162dE0f42307a0095A6e5DF, 7159719590701445955473554));\\n    payouts.push(Payout(0x9115BaDce4873d58fa73b08279529A796550999a, 5632453715407980754075398));\\n    payouts.push(Payout(0x7BC8C0B66d7f0E2193ED11eeCAAfE7c1837b926f, 5414893264683531027764823));\\n    payouts.push(Payout(0xE7809aaaaa78E5a24E059889E561f598F3a4664c, 4712320945661497844704387));\\n    payouts.push(Payout(0xf4D3566729f257edD0D4bF365d8f0Db7bF56e1C6, 2997276841876706895655431));\\n    payouts.push(Payout(0x6Cf9AA65EBaD7028536E353393630e2340ca6049, 2734992792750385321760387));\\n    payouts.push(Payout(0x74386381Cb384CC0FBa0Ac669d22f515FfC147D2, 1366427847282177615773594));\\n    payouts.push(Payout(0x9144b150f28437E06Ab5FF5190365294eb1E87ec, 1363226310703652991601514));\\n    payouts.push(Payout(0x5691d53685e8e219329bD8ADf62b1A0A17df9D11, 702790464733701088417744));\\n    payouts.push(Payout(0x2B91B4f5223a0a1f5c7e1D139dDdD6B5B57C7A51, 678663683269882192090830));\\n    payouts.push(Payout(0x8ddBad507F3b20239516810C308Ba4f3BaeAf3a1, 635520835923336863138335));\\n    payouts.push(Payout(0xc3874A2C59b9779A75874Be6B5f0b578120A8701, 488385391000796390198744));\\n    payouts.push(Payout(0x0A22C160f7E57F2e7d88b2fa1B1B03571bdE6128, 297735186117080365383063));\\n    payouts.push(Payout(0x0a1aa2b65832fC0c71f2Ba488c84BeE0b9DB9692, 132688033756581498940995));\\n    payouts.push(Payout(0xAf7b7AbC272a3aE6dD6dA41b9832C758477a85f2, 130254714680714068405131));\\n    payouts.push(Payout(0xCDb17d9bCbA8E3bab6F68D59065efe784700Bee1, 71018627162763037055295));\\n    payouts.push(Payout(0x4Dec19003F9Bb01A4c0D089605618b2d76deE30d, 69655357581389001902516));\\n    payouts.push(Payout(0x31AacA1940C82130c2D4407E609e626E87A7BC18, 21678478730854029506989));\\n    payouts.push(Payout(0xBc77AB8dd8BAa6ddf0D0c241d31b2e30bcEC127d, 21573657481017931484432));\\n    payouts.push(Payout(0x1c25cDD83Cd7106C3dcB361230eC9E6930Aadd30, 14188368728356337446426));\\n    payouts.push(Payout(0xf1B78ed53fa2f9B8cFfa677Ad8023aCa92109d08, 13831474058511281838532));\\n    payouts.push(Payout(0xd27962455de27561e62345a516931F2392997263, 6968208393315527988941));\\n    payouts.push(Payout(0xD8A4411C623aD361E98bC9D98cA33eE1cF308Bca, 4476771187861728227997));\\n    payouts.push(Payout(0x1f06fA59809ee23Ee06e533D67D29C6564fC1964, 3358338614042115121460));\\n    payouts.push(Payout(0xeDccc1501e3BCC8b3973B9BE33f6Bd7072d28388, 2328788070517256560738));\\n    payouts.push(Payout(0xD738A884B2aFE625d372260E57e86E3eB4d5e1D7, 466769668474372743140));\\n    payouts.push(Payout(0x6942b1b6526Fa05035d47c09B419039c00Ef7545, 442736084997163005698));\\n  }\\n\\n  function airdrop() public onlyManager {\\n    MIMO mimo = MIMO(address(ga.mimo()));\\n    for (uint256 i = 0; i < payouts.length; i++) {\\n      Payout memory payout = payouts[i];\\n      mimo.mint(payout.recipient, payout.amount);\\n    }\\n    require(mimoDistributor.mintableTokens() > 0);\\n\\n    bytes32 MIMO_MINTER_ROLE = mimo.MIMO_MINTER_ROLE();\\n    ga.controller().renounceRole(MIMO_MINTER_ROLE, address(this));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/MIMODistributorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./interfaces/IMIMODistributor.sol\\\";\\nimport \\\"./BaseDistributor.sol\\\";\\n\\ncontract MIMODistributorV2 is BaseDistributor, IMIMODistributorExtension {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  uint256 private constant _SECONDS_PER_YEAR = 365 days;\\n  uint256 private constant _SECONDS_PER_WEEK = 7 days;\\n  uint256 private constant _WEEKLY_R = 986125e21; // -1.3875% per week (-5.55% / 4)\\n  uint256 private _FIRST_WEEK_TOKENS;\\n\\n  uint256 public override startTime;\\n  uint256 public alreadyMinted;\\n\\n  constructor(\\n    IGovernanceAddressProvider _a,\\n    uint256 _startTime,\\n    IMIMODistributor _mimoDistributor\\n  ) public {\\n    require(address(_a) != address(0));\\n    require(address(_mimoDistributor) != address(0));\\n\\n    a = _a;\\n    startTime = _startTime;\\n    alreadyMinted = _mimoDistributor.totalSupplyAt(startTime);\\n\\n    uint256 weeklyIssuanceV1 = _mimoDistributor.weeklyIssuanceAt(startTime);\\n    _FIRST_WEEK_TOKENS = weeklyIssuanceV1 / 4; // reduce weeky issuance by 4\\n  }\\n\\n  /**\\n    Get current monthly issuance of new MIMO tokens.\\n    @return number of monthly issued tokens currently`.\\n  */\\n  function currentIssuance() public view override returns (uint256) {\\n    return weeklyIssuanceAt(now);\\n  }\\n\\n  /**\\n    Get monthly issuance of new MIMO tokens at `timestamp`.\\n    @dev invalid for timestamps before deployment\\n    @param timestamp for which to calculate the monthly issuance\\n    @return number of monthly issued tokens at `timestamp`.\\n  */\\n  function weeklyIssuanceAt(uint256 timestamp) public view override returns (uint256) {\\n    uint256 elapsedSeconds = timestamp.sub(startTime);\\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\\n    return _WEEKLY_R.rayPow(elapsedWeeks).rayMul(_FIRST_WEEK_TOKENS);\\n  }\\n\\n  /**\\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\\n    @return number of mintable tokens available right now.\\n  */\\n  function mintableTokens() public view override returns (uint256) {\\n    return totalSupplyAt(now).sub(a.mimo().totalSupply());\\n  }\\n\\n  /**\\n    Calculates the totalSupply for any point after `startTime`\\n    @param timestamp for which to calculate the totalSupply\\n    @return totalSupply at timestamp.\\n  */\\n  function totalSupplyAt(uint256 timestamp) public view override returns (uint256) {\\n    uint256 elapsedSeconds = timestamp.sub(startTime);\\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\\n    uint256 lastWeekSeconds = elapsedSeconds % _SECONDS_PER_WEEK;\\n    uint256 one = WadRayMath.ray();\\n    uint256 fullWeeks = one.sub(_WEEKLY_R.rayPow(elapsedWeeks)).rayMul(_FIRST_WEEK_TOKENS).rayDiv(one.sub(_WEEKLY_R));\\n    uint256 currentWeekIssuance = weeklyIssuanceAt(timestamp);\\n    uint256 partialWeek = currentWeekIssuance.mul(lastWeekSeconds).div(_SECONDS_PER_WEEK);\\n    return alreadyMinted.add(fullWeeks.add(partialWeek));\\n  }\\n\\n  /**\\n    Internal function to release a percentage of newTokens to a specific payee\\n    @dev uses totalShares to calculate correct share\\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\\n    @param _payee The address of the payee to whom to distribute the fees.\\n  */\\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\\n    a.mimo().mint(_payee, payment);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/BaseDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./interfaces/IBaseDistributor.sol\\\";\\n\\n/*\\n  \\tDistribution Formula:\\n  \\t55.5m MIMO in first week\\n  \\t-5.55% redution per week\\n\\n  \\ttotal(timestamp) = _SECONDS_PER_WEEK * ( (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)) / (1-weeklyR) )\\n  \\t\\t+ timestamp % _SECONDS_PER_WEEK * (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)\\n  */\\n\\nabstract contract BaseDistributor is IBaseDistributor {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  uint256 public override totalShares;\\n  mapping(address => uint256) public override shares;\\n  address[] public payees;\\n\\n  IGovernanceAddressProvider public override a;\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not Manager\\\");\\n    _;\\n  }\\n\\n  /**\\n    Public function to release the accumulated new MIMO tokens to the payees.\\n    @dev anyone can call this.\\n  */\\n  function release() public override {\\n    uint256 newTokens = mintableTokens();\\n    require(newTokens > 0, \\\"newTokens is 0\\\");\\n    require(payees.length > 0, \\\"Payees not configured yet\\\");\\n    // Mint MIMO to all receivers\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      address payee = payees[i];\\n      _release(newTokens, payee);\\n    }\\n    emit TokensReleased(newTokens, now);\\n  }\\n\\n  /**\\n    Updates the payee configuration to a new one.\\n    @dev will release existing fees before the update.\\n    @param _payees Array of payees\\n    @param _shares Array of shares for each payee\\n  */\\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\\n    require(_payees.length == _shares.length, \\\"Payees and shares mismatched\\\");\\n    require(_payees.length > 0, \\\"No payees\\\");\\n\\n    if (payees.length > 0 && mintableTokens() > 0) {\\n      release();\\n    }\\n\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      delete shares[payees[i]];\\n    }\\n    delete payees;\\n    totalShares = 0;\\n\\n    for (uint256 i = 0; i < _payees.length; i++) {\\n      _addPayee(_payees[i], _shares[i]);\\n    }\\n  }\\n\\n  /**\\n    Get current configured payees.\\n    @return array of current payees.\\n  */\\n  function getPayees() public view override returns (address[] memory) {\\n    return payees;\\n  }\\n\\n  /**\\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\\n    @return number of mintable tokens available right now.\\n  */\\n  function mintableTokens() public view virtual override returns (uint256);\\n\\n  /**\\n    Internal function to release a percentage of newTokens to a specific payee\\n    @dev uses totalShares to calculate correct share\\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\\n    @param _payee The address of the payee to whom to distribute the fees.\\n  */\\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal virtual;\\n\\n  /**\\n    Internal function to add a new payee.\\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\\n    @param _payee The address of the payee to add.\\n    @param _shares The number of shares owned by the payee.\\n  */\\n  function _addPayee(address _payee, uint256 _shares) internal {\\n    require(_payee != address(0), \\\"payee is the zero address\\\");\\n    require(_shares > 0, \\\"shares are 0\\\");\\n    require(shares[_payee] == 0, \\\"payee already has shares\\\");\\n\\n    payees.push(_payee);\\n    shares[_payee] = _shares;\\n    totalShares = totalShares.add(_shares);\\n    emit PayeeAdded(_payee, _shares);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/PolygonDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/interfaces/IRootChainManager.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./BaseDistributor.sol\\\";\\n\\ncontract PolygonDistributor is BaseDistributor {\\n  using SafeMath for uint256;\\n\\n  IRootChainManager public rootChainManager;\\n  address public erc20Predicate;\\n\\n  constructor(\\n    IGovernanceAddressProvider _a,\\n    IRootChainManager _rootChainManager,\\n    address _erc20Predicate\\n  ) public {\\n    require(address(_a) != address(0));\\n    require(address(_rootChainManager) != address(0));\\n    require(_erc20Predicate != address(0));\\n\\n    a = _a;\\n    rootChainManager = _rootChainManager;\\n    erc20Predicate = _erc20Predicate;\\n  }\\n\\n  /**\\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\\n    @return number of mintable tokens available right now.\\n  */\\n  function mintableTokens() public view override returns (uint256) {\\n    return a.mimo().balanceOf(address(this));\\n  }\\n\\n  /**\\n    Internal function to release a percentage of newTokens to a specific payee\\n    @dev uses totalShares to calculate correct share\\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\\n    @param _payee The address of the payee to whom to distribute the fees.\\n  */\\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\\n    a.mimo().approve(erc20Predicate, payment);\\n    rootChainManager.depositFor(_payee, address(a.mimo()), abi.encode(payment));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/interfaces/IRootChainManager.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IRootChainManager {\\n  event TokenMapped(address indexed rootToken, address indexed childToken, bytes32 indexed tokenType);\\n\\n  event PredicateRegistered(bytes32 indexed tokenType, address indexed predicateAddress);\\n\\n  function registerPredicate(bytes32 tokenType, address predicateAddress) external;\\n\\n  function mapToken(\\n    address rootToken,\\n    address childToken,\\n    bytes32 tokenType\\n  ) external;\\n\\n  function depositEtherFor(address user) external payable;\\n\\n  function depositFor(\\n    address user,\\n    address rootToken,\\n    bytes calldata depositData\\n  ) external;\\n\\n  function exit(bytes calldata inputData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockGenericMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../liquidityMining/GenericMiner.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\n\\ncontract MockGenericMiner is GenericMiner {\\n  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}\\n\\n  function increaseStake(address user, uint256 value) public {\\n    _increaseStake(user, value);\\n  }\\n\\n  function decreaseStake(address user, uint256 value) public {\\n    _decreaseStake(user, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/GenericMiner.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"./interfaces/IGenericMiner.sol\\\";\\n\\n/*\\n    GenericMiner is based on ERC2917. https://github.com/gnufoo/ERC2917-Proposal\\n\\n    The Objective of GenericMiner is to implement a decentralized staking mechanism, which calculates _users' share\\n    by accumulating stake * time. And calculates _users revenue from anytime t0 to t1 by the formula below:\\n\\n        user_accumulated_stake(time1) - user_accumulated_stake(time0)\\n       _____________________________________________________________________________  * (gross_stake(t1) - gross_stake(t0))\\n       total_accumulated_stake(time1) - total_accumulated_stake(time0)\\n\\n*/\\ncontract GenericMiner is IGenericMiner {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  mapping(address => UserInfo) internal _users;\\n\\n  uint256 public override totalStake;\\n  IGovernanceAddressProvider public override a;\\n\\n  uint256 internal _balanceTracker;\\n  uint256 internal _accAmountPerShare;\\n\\n  constructor(IGovernanceAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Releases the outstanding MIMO balance to the user.\\n    @param _user the address of the user for which the MIMO tokens will be released.\\n  */\\n  function releaseMIMO(address _user) public virtual override {\\n    UserInfo storage userInfo = _users[_user];\\n    _refresh();\\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\\n    _balanceTracker = _balanceTracker.sub(pending);\\n    userInfo.accAmountPerShare = _accAmountPerShare;\\n    require(a.mimo().transfer(_user, pending));\\n  }\\n\\n  /**\\n    Returns the number of tokens a user has staked.\\n    @param _user the address of the user.\\n    @return number of staked tokens\\n  */\\n  function stake(address _user) public view override returns (uint256) {\\n    return _users[_user].stake;\\n  }\\n\\n  /**\\n    Returns the number of tokens a user can claim via `releaseMIMO`.\\n    @param _user the address of the user.\\n    @return number of MIMO tokens that the user can claim\\n  */\\n  function pendingMIMO(address _user) public view override returns (uint256) {\\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\\n    uint256 reward = currentBalance.sub(_balanceTracker);\\n    uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\\n\\n    return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));\\n  }\\n\\n  /**\\n    Returns the userInfo stored of a user.\\n    @param _user the address of the user.\\n    @return `struct UserInfo {\\n      uint256 stake;\\n      uint256 rewardDebt;\\n    }`\\n  **/\\n  function userInfo(address _user) public view override returns (UserInfo memory) {\\n    return _users[_user];\\n  }\\n\\n  /**\\n    Refreshes the global state and subsequently decreases the stake a user has.\\n    This is an internal call and meant to be called within derivative contracts.\\n    @param user the address of the user\\n    @param value the amount by which the stake will be reduced\\n  */\\n  function _decreaseStake(address user, uint256 value) internal {\\n    require(value > 0, \\\"STAKE_MUST_BE_GREATER_THAN_ZERO\\\"); //TODO cleanup error message\\n\\n    UserInfo storage userInfo = _users[user];\\n    require(userInfo.stake >= value, \\\"INSUFFICIENT_STAKE_FOR_USER\\\"); //TODO cleanup error message\\n    _refresh();\\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\\n    _balanceTracker = _balanceTracker.sub(pending);\\n    userInfo.stake = userInfo.stake.sub(value);\\n    userInfo.accAmountPerShare = _accAmountPerShare;\\n    totalStake = totalStake.sub(value);\\n\\n    require(a.mimo().transfer(user, pending));\\n    emit StakeDecreased(user, value);\\n  }\\n\\n  /**\\n    Refreshes the global state and subsequently increases a user's stake.\\n    This is an internal call and meant to be called within derivative contracts.\\n    @param user the address of the user\\n    @param value the amount by which the stake will be increased\\n  */\\n  function _increaseStake(address user, uint256 value) internal {\\n    require(value > 0, \\\"STAKE_MUST_BE_GREATER_THAN_ZERO\\\"); //TODO cleanup error message\\n\\n    UserInfo storage userInfo = _users[user];\\n    _refresh();\\n\\n    uint256 pending;\\n    if (userInfo.stake > 0) {\\n      pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\\n      _balanceTracker = _balanceTracker.sub(pending);\\n    }\\n\\n    totalStake = totalStake.add(value);\\n    userInfo.stake = userInfo.stake.add(value);\\n    userInfo.accAmountPerShare = _accAmountPerShare;\\n\\n    if (pending > 0) {\\n      require(a.mimo().transfer(user, pending));\\n    }\\n\\n    emit StakeIncreased(user, value);\\n  }\\n\\n  /**\\n    Refreshes the global state and subsequently updates a user's stake.\\n    This is an internal call and meant to be called within derivative contracts.\\n    @param user the address of the user\\n    @param stake the new amount of stake for the user\\n  */\\n  function _updateStake(address user, uint256 stake) internal returns (bool) {\\n    uint256 oldStake = _users[user].stake;\\n    if (stake > oldStake) {\\n      _increaseStake(user, stake.sub(oldStake));\\n    }\\n    if (stake < oldStake) {\\n      _decreaseStake(user, oldStake.sub(stake));\\n    }\\n  }\\n\\n  /**\\n    Internal read function to calculate the number of MIMO tokens that\\n    have accumulated since the last token release.\\n    @dev This is an internal call and meant to be called within derivative contracts.\\n    @return newly accumulated token balance\\n  */\\n  function _newTokensReceived() internal view returns (uint256) {\\n    return a.mimo().balanceOf(address(this)).sub(_balanceTracker);\\n  }\\n\\n  /**\\n    Updates the internal state variables after accounting for newly received MIMO tokens.\\n  */\\n  function _refresh() internal {\\n    if (totalStake == 0) {\\n      return;\\n    }\\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\\n    uint256 reward = currentBalance.sub(_balanceTracker);\\n    _balanceTracker = currentBalance;\\n\\n    _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/VotingMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"./GenericMiner.sol\\\";\\nimport \\\"./interfaces/IVotingMiner.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"../governance/interfaces/IVotingEscrow.sol\\\";\\n\\ncontract VotingMiner is IVotingMiner, GenericMiner {\\n  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}\\n\\n  /**\\n    Releases the outstanding MIMO balance to the user.\\n    @param _user the address of the user for which the MIMO tokens will be released.\\n  */\\n  function releaseMIMO(address _user) public override {\\n    IVotingEscrow votingEscrow = a.votingEscrow();\\n    require((msg.sender == _user) || (msg.sender == address(votingEscrow)));\\n\\n    UserInfo storage userInfo = _users[_user];\\n    _refresh();\\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\\n    _balanceTracker = _balanceTracker.sub(pending);\\n    userInfo.accAmountPerShare = _accAmountPerShare;\\n\\n    uint256 votingPower = votingEscrow.balanceOf(_user);\\n    totalStake = totalStake.add(votingPower).sub(userInfo.stake);\\n    userInfo.stake = votingPower;\\n\\n    if (pending > 0) {\\n      require(a.mimo().transfer(_user, pending));\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/interfaces/IVotingMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\ninterface IVotingMiner {}\\n\"\r\n    },\r\n    \"contracts/governance/VotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n/* solium-disable security/no-block-members */\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport { SafeERC20, IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IVotingEscrow.sol\\\";\\nimport \\\"./interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IGenericMiner.sol\\\";\\n\\n/**\\n * @title  VotingEscrow\\n * @notice Lockup GOV, receive vGOV (voting weight that decays over time)\\n * @dev    Supports:\\n *            1) Tracking MIMO Locked up\\n *            2) Decaying voting weight lookup\\n *            3) Closure of contract\\n */\\ncontract VotingEscrow is IVotingEscrow, ReentrancyGuard {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public constant MAXTIME = 1460 days; // 365 * 4 years\\n  uint256 public minimumLockTime = 1 days;\\n  bool public expired = false;\\n  IERC20 public override stakingToken;\\n\\n  mapping(address => LockedBalance) public locked;\\n\\n  string public override name;\\n  string public override symbol;\\n  // solhint-disable-next-line\\n  uint256 public constant override decimals = 18;\\n\\n  // AddressProvider\\n  IGovernanceAddressProvider public a;\\n  IGenericMiner public miner;\\n\\n  constructor(\\n    IERC20 _stakingToken,\\n    IGovernanceAddressProvider _a,\\n    IGenericMiner _miner,\\n    string memory _name,\\n    string memory _symbol\\n  ) public {\\n    require(address(_stakingToken) != address(0));\\n    require(address(_a) != address(0));\\n    require(address(_miner) != address(0));\\n\\n    stakingToken = _stakingToken;\\n    a = _a;\\n    miner = _miner;\\n\\n    name = _name;\\n    symbol = _symbol;\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  /** @dev Modifier to ensure contract has not yet expired */\\n  modifier contractNotExpired() {\\n    require(!expired, \\\"Contract is expired\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Creates a new lock\\n   * @param _value Total units of StakingToken to lockup\\n   * @param _unlockTime Time at which the stake should unlock\\n   */\\n  function createLock(uint256 _value, uint256 _unlockTime) external override nonReentrant contractNotExpired {\\n    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });\\n\\n    require(_value > 0, \\\"Must stake non zero amount\\\");\\n    require(locked_.amount == 0, \\\"Withdraw old tokens first\\\");\\n    require(_unlockTime > block.timestamp, \\\"Can only lock until time in the future\\\");\\n    require(_unlockTime.sub(block.timestamp) > minimumLockTime, \\\"Lock duration should be larger than minimum locktime\\\");\\n\\n    _depositFor(msg.sender, _value, _unlockTime, locked_, LockAction.CREATE_LOCK);\\n  }\\n\\n  /**\\n   * @dev Increases amount of stake thats locked up & resets decay\\n   * @param _value Additional units of StakingToken to add to exiting stake\\n   */\\n  function increaseLockAmount(uint256 _value) external override nonReentrant contractNotExpired {\\n    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });\\n\\n    require(_value > 0, \\\"Must stake non zero amount\\\");\\n    require(locked_.amount > 0, \\\"No existing lock found\\\");\\n    require(locked_.end > block.timestamp, \\\"Cannot add to expired lock. Withdraw\\\");\\n\\n    _depositFor(msg.sender, _value, 0, locked_, LockAction.INCREASE_LOCK_AMOUNT);\\n  }\\n\\n  /**\\n   * @dev Increases length of lockup & resets decay\\n   * @param _unlockTime New unlocktime for lockup\\n   */\\n  function increaseLockLength(uint256 _unlockTime) external override nonReentrant contractNotExpired {\\n    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });\\n\\n    require(locked_.amount > 0, \\\"Nothing is locked\\\");\\n    require(locked_.end > block.timestamp, \\\"Lock expired\\\");\\n    require(_unlockTime > locked_.end, \\\"Can only increase lock time\\\");\\n    require(_unlockTime.sub(locked_.end) > minimumLockTime, \\\"Lock duration should be larger than minimum locktime\\\");\\n\\n    _depositFor(msg.sender, 0, _unlockTime, locked_, LockAction.INCREASE_LOCK_TIME);\\n  }\\n\\n  /**\\n   * @dev Withdraws all the senders stake, providing lockup is over\\n   */\\n  function withdraw() external override {\\n    _withdraw(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Ends the contract, unlocking all stakes.\\n   * No more staking can happen. Only withdraw.\\n   */\\n  function expireContract() external override onlyManager contractNotExpired {\\n    expired = true;\\n    emit Expired();\\n  }\\n\\n  /**\\n   * @dev Set miner address.\\n   * @param _miner new miner contract address\\n   */\\n  function setMiner(IGenericMiner _miner) external override onlyManager contractNotExpired {\\n    miner = _miner;\\n  }\\n\\n  /**\\n   * @dev Set minimumLockTime.\\n   * @param _minimumLockTime minimum lockTime\\n   */\\n  function setMinimumLockTime(uint256 _minimumLockTime) external override onlyManager contractNotExpired {\\n    minimumLockTime = _minimumLockTime;\\n  }\\n\\n  /***************************************\\n                    GETTERS\\n    ****************************************/\\n\\n  /**\\n   * @dev Gets the user's votingWeight at the current time.\\n   * @param _owner User for which to return the votingWeight\\n   * @return uint256 Balance of user\\n   */\\n  function balanceOf(address _owner) public view override returns (uint256) {\\n    return balanceOfAt(_owner, block.timestamp);\\n  }\\n\\n  /**\\n   * @dev Gets a users votingWeight at a given block timestamp\\n   * @param _owner User for which to return the balance\\n   * @param _blockTime Timestamp for which to calculate balance. Can not be in the past\\n   * @return uint256 Balance of user\\n   */\\n  function balanceOfAt(address _owner, uint256 _blockTime) public view override returns (uint256) {\\n    require(_blockTime >= block.timestamp, \\\"Must pass block timestamp in the future\\\");\\n\\n    LockedBalance memory currentLock = locked[_owner];\\n\\n    if (currentLock.end <= _blockTime) return 0;\\n    uint256 remainingLocktime = currentLock.end.sub(_blockTime);\\n    if (remainingLocktime > MAXTIME) {\\n      remainingLocktime = MAXTIME;\\n    }\\n\\n    return currentLock.amount.mul(remainingLocktime).div(MAXTIME);\\n  }\\n\\n  /**\\n   * @dev Deposits or creates a stake for a given address\\n   * @param _addr User address to assign the stake\\n   * @param _value Total units of StakingToken to lockup\\n   * @param _unlockTime Time at which the stake should unlock\\n   * @param _oldLocked Previous amount staked by this user\\n   * @param _action See LockAction enum\\n   */\\n  function _depositFor(\\n    address _addr,\\n    uint256 _value,\\n    uint256 _unlockTime,\\n    LockedBalance memory _oldLocked,\\n    LockAction _action\\n  ) internal {\\n    LockedBalance memory newLocked = LockedBalance({ amount: _oldLocked.amount, end: _oldLocked.end });\\n\\n    // Adding to existing lock, or if a lock is expired - creating a new one\\n    newLocked.amount = newLocked.amount.add(_value);\\n    if (_unlockTime != 0) {\\n      newLocked.end = _unlockTime;\\n    }\\n    locked[_addr] = newLocked;\\n\\n    if (_value != 0) {\\n      stakingToken.safeTransferFrom(_addr, address(this), _value);\\n    }\\n\\n    miner.releaseMIMO(_addr);\\n\\n    emit Deposit(_addr, _value, newLocked.end, _action, block.timestamp);\\n  }\\n\\n  /**\\n   * @dev Withdraws a given users stake, providing the lockup has finished\\n   * @param _addr User for which to withdraw\\n   */\\n  function _withdraw(address _addr) internal nonReentrant {\\n    LockedBalance memory oldLock = LockedBalance({ end: locked[_addr].end, amount: locked[_addr].amount });\\n    require(block.timestamp >= oldLock.end || expired, \\\"The lock didn't expire\\\");\\n    require(oldLock.amount > 0, \\\"Must have something to withdraw\\\");\\n\\n    uint256 value = uint256(oldLock.amount);\\n\\n    LockedBalance memory currentLock = LockedBalance({ end: 0, amount: 0 });\\n    locked[_addr] = currentLock;\\n\\n    stakingToken.safeTransfer(_addr, value);\\n    miner.releaseMIMO(_addr);\\n\\n    emit Withdraw(_addr, value, block.timestamp);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/PARMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IMIMO.sol\\\";\\nimport \\\"./interfaces/IGenericMiner.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract PARMiner {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  struct UserInfo {\\n    uint256 stake;\\n    uint256 accAmountPerShare;\\n    uint256 accParAmountPerShare;\\n  }\\n\\n  event StakeIncreased(address indexed user, uint256 stake);\\n  event StakeDecreased(address indexed user, uint256 stake);\\n\\n  IERC20 public par;\\n\\n  mapping(address => UserInfo) internal _users;\\n\\n  uint256 public totalStake;\\n  IGovernanceAddressProvider public a;\\n\\n  uint256 internal _balanceTracker;\\n  uint256 internal _accAmountPerShare;\\n\\n  uint256 internal _parBalanceTracker;\\n  uint256 internal _accParAmountPerShare;\\n\\n  constructor(IGovernanceAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n\\n    par = IERC20(_addresses.parallel().stablex());\\n  }\\n\\n  /**\\n    Deposit an ERC20 pool token for staking\\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\\n    @param amount the amount of tokens to be deposited. Unit is in WEI.\\n  **/\\n  function deposit(uint256 amount) public {\\n    par.safeTransferFrom(msg.sender, address(this), amount);\\n    _increaseStake(msg.sender, amount);\\n  }\\n\\n  /**\\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked.\\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI.\\n  **/\\n  function withdraw(uint256 amount) public {\\n    par.safeTransfer(msg.sender, amount);\\n    _decreaseStake(msg.sender, amount);\\n  }\\n\\n  /**\\n    Releases the outstanding MIMO balance to the user.\\n    @param _user the address of the user for which the MIMO tokens will be released.\\n  */\\n  function releaseMIMO(address _user) public virtual {\\n    UserInfo storage userInfo = _users[_user];\\n    _refresh();\\n    _refreshPAR(totalStake);\\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\\n    _balanceTracker = _balanceTracker.sub(pending);\\n    userInfo.accAmountPerShare = _accAmountPerShare;\\n    require(a.mimo().transfer(_user, pending));\\n  }\\n\\n  /**\\n    Releases the outstanding PAR reward balance to the user.\\n    @param _user the address of the user for which the PAR tokens will be released.\\n  */\\n  function releasePAR(address _user) public virtual {\\n    UserInfo storage userInfo = _users[_user];\\n    _refresh();\\n    _refreshPAR(totalStake);\\n    uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\\n    _parBalanceTracker = _parBalanceTracker.sub(pending);\\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\\n    require(par.transfer(_user, pending));\\n  }\\n\\n  /**\\n    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake\\n    @param _user the address of the user for which the PAR tokens will be restaked.\\n  */\\n  function restakePAR(address _user) public virtual {\\n    UserInfo storage userInfo = _users[_user];\\n    _refresh();\\n    _refreshPAR(totalStake);\\n    uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\\n    _parBalanceTracker = _parBalanceTracker.sub(pending);\\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\\n\\n    _increaseStake(_user, pending);\\n  }\\n\\n  /**\\n    Returns the number of tokens a user has staked.\\n    @param _user the address of the user.\\n    @return number of staked tokens\\n  */\\n  function stake(address _user) public view returns (uint256) {\\n    return _users[_user].stake;\\n  }\\n\\n  /**\\n    Returns the number of tokens a user can claim via `releaseMIMO`.\\n    @param _user the address of the user.\\n    @return number of MIMO tokens that the user can claim\\n  */\\n  function pendingMIMO(address _user) public view returns (uint256) {\\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\\n    uint256 reward = currentBalance.sub(_balanceTracker);\\n    uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\\n\\n    return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));\\n  }\\n\\n  /**\\n    Returns the number of PAR tokens the user has earned as a reward\\n    @param _user the address of the user.\\n    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking\\n  */\\n  function pendingPAR(address _user) public view returns (uint256) {\\n    uint256 currentBalance = par.balanceOf(address(this)).sub(totalStake);\\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(totalStake));\\n\\n    return _users[_user].stake.rayMul(accParAmountPerShare.sub(_users[_user].accParAmountPerShare));\\n  }\\n\\n  /**\\n    Returns the userInfo stored of a user.\\n    @param _user the address of the user.\\n    @return `struct UserInfo {\\n      uint256 stake;\\n      uint256 rewardDebt;\\n    }`\\n  **/\\n  function userInfo(address _user) public view returns (UserInfo memory) {\\n    return _users[_user];\\n  }\\n\\n  /**\\n    Refreshes the global state and subsequently decreases the stake a user has.\\n    This is an internal call and meant to be called within derivative contracts.\\n    @param user the address of the user\\n    @param value the amount by which the stake will be reduced\\n  */\\n  function _decreaseStake(address user, uint256 value) internal {\\n    require(value > 0, \\\"STAKE_MUST_BE_GREATER_THAN_ZERO\\\"); //TODO cleanup error message\\n\\n    UserInfo storage userInfo = _users[user];\\n    require(userInfo.stake >= value, \\\"INSUFFICIENT_STAKE_FOR_USER\\\"); //TODO cleanup error message\\n    _refresh();\\n    uint256 newTotalStake = totalStake.sub(value);\\n    _refreshPAR(newTotalStake);\\n\\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\\n    _balanceTracker = _balanceTracker.sub(pending);\\n    userInfo.accAmountPerShare = _accAmountPerShare;\\n\\n    uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\\n\\n    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\\n\\n    userInfo.stake = userInfo.stake.sub(value);\\n    totalStake = newTotalStake;\\n\\n    if (pending > 0) {\\n      require(a.mimo().transfer(user, pending));\\n    }\\n    if (pendingPAR > 0) {\\n      require(par.transfer(user, pendingPAR));\\n    }\\n\\n    emit StakeDecreased(user, value);\\n  }\\n\\n  /**\\n    Refreshes the global state and subsequently increases a user's stake.\\n    This is an internal call and meant to be called within derivative contracts.\\n    @param user the address of the user\\n    @param value the amount by which the stake will be increased\\n  */\\n  function _increaseStake(address user, uint256 value) internal {\\n    require(value > 0, \\\"STAKE_MUST_BE_GREATER_THAN_ZERO\\\"); //TODO cleanup error message\\n\\n    UserInfo storage userInfo = _users[user];\\n\\n    _refresh();\\n\\n    uint256 newTotalStake = totalStake.add(value);\\n    _refreshPAR(newTotalStake);\\n\\n    uint256 pending;\\n    uint256 pendingPAR;\\n    if (userInfo.stake > 0) {\\n      pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\\n      _balanceTracker = _balanceTracker.sub(pending);\\n\\n      // maybe we should add the accumulated PAR to the stake of the user instead?\\n      pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\\n    }\\n\\n    totalStake = newTotalStake;\\n    userInfo.stake = userInfo.stake.add(value);\\n\\n    userInfo.accAmountPerShare = _accAmountPerShare;\\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\\n\\n    if (pendingPAR > 0) {\\n      // add pendingPAR balance to stake and totalStake instead of sending it back\\n      userInfo.stake = userInfo.stake.add(pendingPAR);\\n      totalStake = totalStake.add(pendingPAR);\\n    }\\n    if (pending > 0) {\\n      require(a.mimo().transfer(user, pending));\\n    }\\n\\n    emit StakeIncreased(user, value.add(pendingPAR));\\n  }\\n\\n  /**\\n    Refreshes the global state and subsequently updates a user's stake.\\n    This is an internal call and meant to be called within derivative contracts.\\n    @param user the address of the user\\n    @param stake the new amount of stake for the user\\n  */\\n  function _updateStake(address user, uint256 stake) internal returns (bool) {\\n    uint256 oldStake = _users[user].stake;\\n    if (stake > oldStake) {\\n      _increaseStake(user, stake.sub(oldStake));\\n    }\\n    if (stake < oldStake) {\\n      _decreaseStake(user, oldStake.sub(stake));\\n    }\\n  }\\n\\n  /**\\n    Updates the internal state variables after accounting for newly received MIMO tokens.\\n  */\\n  function _refresh() internal {\\n    if (totalStake == 0) {\\n      return;\\n    }\\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\\n    uint256 reward = currentBalance.sub(_balanceTracker);\\n    _balanceTracker = currentBalance;\\n    _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\\n  }\\n\\n  /**\\n    Updates the internal state variables after accounting for newly received PAR tokens.\\n  */\\n  function _refreshPAR(uint256 newTotalStake) internal {\\n    if (totalStake == 0) {\\n      return;\\n    }\\n    uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);\\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\\n\\n    _parBalanceTracker = currentParBalance;\\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));\\n  }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/DemandMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./GenericMiner.sol\\\";\\nimport \\\"./interfaces/IMIMO.sol\\\";\\nimport \\\"./interfaces/IDemandMiner.sol\\\";\\n\\ncontract DemandMiner is IDemandMiner, GenericMiner {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  IERC20 public override token;\\n\\n  constructor(IGovernanceAddressProvider _addresses, IERC20 _token) public GenericMiner(_addresses) {\\n    require(address(_token) != address(0));\\n    require(address(_token) != address(_addresses.mimo()));\\n    token = _token;\\n  }\\n\\n  /**\\n    Deposit an ERC20 pool token for staking\\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\\n    @param amount the amount of tokens to be deposited. Unit is in WEI.\\n  **/\\n  function deposit(uint256 amount) public override {\\n    token.safeTransferFrom(msg.sender, address(this), amount);\\n    _increaseStake(msg.sender, amount);\\n  }\\n\\n  /**\\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked.\\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI.\\n  **/\\n  function withdraw(uint256 amount) public override {\\n    token.safeTransfer(msg.sender, amount);\\n    _decreaseStake(msg.sender, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/EthereumDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { SafeERC20, IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./BaseDistributor.sol\\\";\\n\\ncontract EthereumDistributor is BaseDistributor {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  constructor(IGovernanceAddressProvider _a) public {\\n    require(address(_a) != address(0));\\n\\n    a = _a;\\n  }\\n\\n  /**\\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\\n    @return number of mintable tokens available right now.\\n  */\\n  function mintableTokens() public view override returns (uint256) {\\n    return a.mimo().balanceOf(address(this));\\n  }\\n\\n  /**\\n    Internal function to release a percentage of newTokens to a specific payee\\n    @dev uses totalShares to calculate correct share\\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\\n    @param _payee The address of the payee to whom to distribute the fees.\\n  */\\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\\n    IERC20(a.mimo()).safeTransfer(_payee, payment);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernanceAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"./interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./interfaces/IGovernorAlpha.sol\\\";\\nimport \\\"./interfaces/ITimelock.sol\\\";\\nimport \\\"./interfaces/IVotingEscrow.sol\\\";\\nimport \\\"../interfaces/IAccessController.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IDebtNotifier.sol\\\";\\nimport \\\"../liquidityMining/interfaces/IMIMO.sol\\\";\\n\\ncontract GovernanceAddressProvider is IGovernanceAddressProvider {\\n  IAddressProvider public override parallel;\\n  IMIMO public override mimo;\\n  IDebtNotifier public override debtNotifier;\\n  IGovernorAlpha public override governorAlpha;\\n  ITimelock public override timelock;\\n  IVotingEscrow public override votingEscrow;\\n\\n  constructor(IAddressProvider _parallel) public {\\n    require(address(_parallel) != address(0));\\n    parallel = _parallel;\\n  }\\n\\n  modifier onlyManager() {\\n    require(controller().hasRole(controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  /**\\n    Update the `AddressProvider` address that points to main AddressProvider\\n    used in the Parallel Protocol\\n    @dev only manager can call this.\\n    @param _parallel the address of the new `AddressProvider` address.\\n  */\\n  function setParallelAddressProvider(IAddressProvider _parallel) public override onlyManager {\\n    require(address(_parallel) != address(0));\\n    parallel = _parallel;\\n  }\\n\\n  /**\\n    Update the `MIMO` ERC20 token address\\n    @dev only manager can call this.\\n    @param _mimo the address of the new `MIMO` token address.\\n  */\\n  function setMIMO(IMIMO _mimo) public override onlyManager {\\n    require(address(_mimo) != address(0));\\n    mimo = _mimo;\\n  }\\n\\n  /**\\n    Update the `DebtNotifier` address\\n    @dev only manager can call this.\\n    @param _debtNotifier the address of the new `DebtNotifier`.\\n  */\\n  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {\\n    require(address(_debtNotifier) != address(0));\\n    debtNotifier = _debtNotifier;\\n  }\\n\\n  /**\\n    Update the `GovernorAlpha` address\\n    @dev only manager can call this.\\n    @param _governorAlpha the address of the new `GovernorAlpha`.\\n  */\\n  function setGovernorAlpha(IGovernorAlpha _governorAlpha) public override onlyManager {\\n    require(address(_governorAlpha) != address(0));\\n    governorAlpha = _governorAlpha;\\n  }\\n\\n  /**\\n    Update the `Timelock` address\\n    @dev only manager can call this.\\n    @param _timelock the address of the new `Timelock`.\\n  */\\n  function setTimelock(ITimelock _timelock) public override onlyManager {\\n    require(address(_timelock) != address(0));\\n    timelock = _timelock;\\n  }\\n\\n  /**\\n    Update the `VotingEscrow` address\\n    @dev only manager can call this.\\n    @param _votingEscrow the address of the new `VotingEscrow`.\\n  */\\n  function setVotingEscrow(IVotingEscrow _votingEscrow) public override onlyManager {\\n    require(address(_votingEscrow) != address(0));\\n    votingEscrow = _votingEscrow;\\n  }\\n\\n  function controller() public view override returns (IAccessController) {\\n    return parallel.controller();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/AddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../interfaces/IVaultsCore.sol\\\";\\nimport \\\"../interfaces/IAccessController.sol\\\";\\nimport \\\"../interfaces/IConfigProvider.sol\\\";\\nimport \\\"../interfaces/ISTABLEX.sol\\\";\\nimport \\\"../interfaces/IPriceFeed.sol\\\";\\nimport \\\"../interfaces/IRatesManager.sol\\\";\\nimport \\\"../interfaces/ILiquidationManager.sol\\\";\\nimport \\\"../interfaces/IVaultsCore.sol\\\";\\nimport \\\"../interfaces/IVaultsDataProvider.sol\\\";\\n\\ncontract AddressProvider is IAddressProvider {\\n  IAccessController public override controller;\\n  IConfigProvider public override config;\\n  IVaultsCore public override core;\\n\\n  ISTABLEX public override stablex;\\n  IRatesManager public override ratesManager;\\n  IPriceFeed public override priceFeed;\\n  ILiquidationManager public override liquidationManager;\\n  IVaultsDataProvider public override vaultsData;\\n  IFeeDistributor public override feeDistributor;\\n\\n  constructor(IAccessController _controller) public {\\n    controller = _controller;\\n  }\\n\\n  modifier onlyManager() {\\n    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  function setAccessController(IAccessController _controller) public override onlyManager {\\n    require(address(_controller) != address(0));\\n    controller = _controller;\\n  }\\n\\n  function setConfigProvider(IConfigProvider _config) public override onlyManager {\\n    require(address(_config) != address(0));\\n    config = _config;\\n  }\\n\\n  function setVaultsCore(IVaultsCore _core) public override onlyManager {\\n    require(address(_core) != address(0));\\n    core = _core;\\n  }\\n\\n  function setStableX(ISTABLEX _stablex) public override onlyManager {\\n    require(address(_stablex) != address(0));\\n    stablex = _stablex;\\n  }\\n\\n  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {\\n    require(address(_ratesManager) != address(0));\\n    ratesManager = _ratesManager;\\n  }\\n\\n  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {\\n    require(address(_liquidationManager) != address(0));\\n    liquidationManager = _liquidationManager;\\n  }\\n\\n  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {\\n    require(address(_priceFeed) != address(0));\\n    priceFeed = _priceFeed;\\n  }\\n\\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {\\n    require(address(_vaultsData) != address(0));\\n    vaultsData = _vaultsData;\\n  }\\n\\n  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {\\n    require(address(_feeDistributor) != address(0));\\n    feeDistributor = _feeDistributor;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/DebtNotifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./interfaces/ISupplyMiner.sol\\\";\\nimport \\\"../interfaces/IVaultsDataProvider.sol\\\";\\n\\ncontract DebtNotifier is IDebtNotifier {\\n  IGovernanceAddressProvider public override a;\\n  mapping(address => ISupplyMiner) public override collateralSupplyMinerMapping;\\n\\n  constructor(IGovernanceAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  modifier onlyVaultsCore() {\\n    require(msg.sender == address(a.parallel().core()), \\\"Caller is not VaultsCore\\\");\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\\n    _;\\n  }\\n\\n  /**\\n    Notifies the correct supplyMiner of a change in debt.\\n    @dev Only the vaultsCore can call this.\\n    `debtChanged` will silently return if collateralType is not known to prevent any problems in vaultscore.\\n    @param _vaultId the ID of the vault of which the debt has changed.\\n  **/\\n  function debtChanged(uint256 _vaultId) public override onlyVaultsCore {\\n    IVaultsDataProvider.Vault memory v = a.parallel().vaultsData().vaults(_vaultId);\\n\\n    ISupplyMiner supplyMiner = collateralSupplyMinerMapping[v.collateralType];\\n    if (address(supplyMiner) == address(0)) {\\n      // not throwing error so VaultsCore keeps working\\n      return;\\n    }\\n    supplyMiner.baseDebtChanged(v.owner, v.baseDebt);\\n  }\\n\\n  /**\\n    Updates the collateral to supplyMiner mapping.\\n    @dev Manager role in the AccessController is required to call this.\\n    @param collateral the address of the collateralType.\\n    @param supplyMiner the address of the supplyMiner which will be notified on debt changes for this collateralType.\\n  **/\\n  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) public override onlyManager {\\n    collateralSupplyMinerMapping[collateral] = supplyMiner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/SupplyMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./GenericMiner.sol\\\";\\nimport \\\"./interfaces/ISupplyMiner.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\n\\ncontract SupplyMiner is ISupplyMiner, GenericMiner {\\n  using SafeMath for uint256;\\n\\n  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}\\n\\n  modifier onlyNotifier() {\\n    require(msg.sender == address(a.debtNotifier()), \\\"Caller is not DebtNotifier\\\");\\n    _;\\n  }\\n\\n  /**\\n    Gets called by the `DebtNotifier` and will update the stake of the user\\n    to match his current outstanding debt by using his baseDebt.\\n    @param user address of the user.\\n    @param newBaseDebt the new baseDebt and therefore stake for the user.\\n  */\\n  function baseDebtChanged(address user, uint256 newBaseDebt) public override onlyNotifier {\\n    _updateStake(user, newBaseDebt);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/VaultsDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IVaultsDataProvider.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ncontract VaultsDataProvider is IVaultsDataProvider {\\n  using SafeMath for uint256;\\n\\n  IAddressProvider public override a;\\n\\n  uint256 public override vaultCount = 0;\\n\\n  mapping(address => uint256) public override baseDebt;\\n\\n  mapping(uint256 => Vault) private _vaults;\\n  mapping(address => mapping(address => uint256)) private _vaultOwners;\\n\\n  modifier onlyVaultsCore() {\\n    require(msg.sender == address(a.core()), \\\"Caller is not VaultsCore\\\");\\n    _;\\n  }\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Opens a new vault.\\n    @dev only the vaultsCore module can call this function\\n    @param _collateralType address to the collateral asset e.g. WETH\\n    @param _owner the owner of the new vault.\\n  */\\n  function createVault(address _collateralType, address _owner) public override onlyVaultsCore returns (uint256) {\\n    require(_collateralType != address(0));\\n    require(_owner != address(0));\\n    uint256 newId = ++vaultCount;\\n    require(_collateralType != address(0), \\\"collateralType unknown\\\");\\n    Vault memory v = Vault({\\n      collateralType: _collateralType,\\n      owner: _owner,\\n      collateralBalance: 0,\\n      baseDebt: 0,\\n      createdAt: block.timestamp\\n    });\\n    _vaults[newId] = v;\\n    _vaultOwners[_owner][_collateralType] = newId;\\n    return newId;\\n  }\\n\\n  /**\\n    Set the collateral balance of a vault.\\n    @dev only the vaultsCore module can call this function\\n    @param _id Vault ID of which the collateral balance will be updated\\n    @param _balance the new balance of the vault.\\n  */\\n  function setCollateralBalance(uint256 _id, uint256 _balance) public override onlyVaultsCore {\\n    require(vaultExists(_id), \\\"Vault not found.\\\");\\n    Vault storage v = _vaults[_id];\\n    v.collateralBalance = _balance;\\n  }\\n\\n  /**\\n    Set the base debt of a vault.\\n    @dev only the vaultsCore module can call this function\\n    @param _id Vault ID of which the base debt will be updated\\n    @param _newBaseDebt the new base debt of the vault.\\n  */\\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) public override onlyVaultsCore {\\n    Vault storage _vault = _vaults[_id];\\n    if (_newBaseDebt > _vault.baseDebt) {\\n      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);\\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].add(increase);\\n    } else {\\n      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);\\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].sub(decrease);\\n    }\\n    _vault.baseDebt = _newBaseDebt;\\n  }\\n\\n  /**\\n    Get a vault by vault ID.\\n    @param _id The vault's ID to be retrieved\\n    @return struct Vault {\\n      address collateralType;\\n      address owner;\\n      uint256 collateralBalance;\\n      uint256 baseDebt;\\n      uint256 createdAt;\\n    }\\n  */\\n  function vaults(uint256 _id) public view override returns (Vault memory) {\\n    Vault memory v = _vaults[_id];\\n    return v;\\n  }\\n\\n  /**\\n    Get the owner of a vault.\\n    @param _id the ID of the vault\\n    @return owner of the vault\\n  */\\n  function vaultOwner(uint256 _id) public view override returns (address) {\\n    return _vaults[_id].owner;\\n  }\\n\\n  /**\\n    Get the collateral type of a vault.\\n    @param _id the ID of the vault\\n    @return address for the collateral type of the vault\\n  */\\n  function vaultCollateralType(uint256 _id) public view override returns (address) {\\n    return _vaults[_id].collateralType;\\n  }\\n\\n  /**\\n    Get the collateral balance of a vault.\\n    @param _id the ID of the vault\\n    @return collateral balance of the vault\\n  */\\n  function vaultCollateralBalance(uint256 _id) public view override returns (uint256) {\\n    return _vaults[_id].collateralBalance;\\n  }\\n\\n  /**\\n    Get the base debt of a vault.\\n    @param _id the ID of the vault\\n    @return base debt of the vault\\n  */\\n  function vaultBaseDebt(uint256 _id) public view override returns (uint256) {\\n    return _vaults[_id].baseDebt;\\n  }\\n\\n  /**\\n    Retrieve the vault id for a specified owner and collateral type.\\n    @dev returns 0 for non-existing vaults\\n    @param _collateralType address of the collateral type (Eg: WETH)\\n    @param _owner address of the owner of the vault\\n    @return vault id of the vault or 0\\n  */\\n  function vaultId(address _collateralType, address _owner) public view override returns (uint256) {\\n    return _vaultOwners[_owner][_collateralType];\\n  }\\n\\n  /**\\n    Checks if a specified vault exists.\\n    @param _id the ID of the vault\\n    @return boolean if the vault exists\\n  */\\n  function vaultExists(uint256 _id) public view override returns (bool) {\\n    Vault memory v = _vaults[_id];\\n    return v.collateralType != address(0);\\n  }\\n\\n  /**\\n    Calculated the total outstanding debt for all vaults and all collateral types.\\n    @dev uses the existing cumulative rate. Call `refresh()` on `VaultsCore`\\n    to make sure it's up to date.\\n    @return total debt of the platform\\n  */\\n  function debt() public view override returns (uint256) {\\n    uint256 total = 0;\\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\\n      address collateralType = a.config().collateralConfigs(i).collateralType;\\n      total = total.add(collateralDebt(collateralType));\\n    }\\n    return total;\\n  }\\n\\n  /**\\n    Calculated the total outstanding debt for all vaults of a specific collateral type.\\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\\n    to make sure it's up to date.\\n    @param _collateralType address of the collateral type (Eg: WETH)\\n    @return total debt of the platform of one collateral type\\n  */\\n  function collateralDebt(address _collateralType) public view override returns (uint256) {\\n    return a.ratesManager().calculateDebt(baseDebt[_collateralType], a.core().cumulativeRates(_collateralType));\\n  }\\n\\n  /**\\n    Calculated the total outstanding debt for a specific vault.\\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\\n    to make sure it's up to date.\\n    @param _vaultId the ID of the vault\\n    @return total debt of one vault\\n  */\\n  function vaultDebt(uint256 _vaultId) public view override returns (uint256) {\\n    IVaultsDataProvider.Vault memory v = _vaults[_vaultId];\\n    return a.ratesManager().calculateDebt(v.baseDebt, a.core().cumulativeRates(v.collateralType));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/LiquidiationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../interfaces/ILiquidationManager.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ncontract LiquidationManager is ILiquidationManager, ReentrancyGuard {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  IAddressProvider public override a;\\n\\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18; // 1\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Check if the health factor is above or equal to 1.\\n    @param _collateralValue value of the collateral in PAR\\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\\n    @param _minRatio min ratio to calculate health factor\\n    @return boolean if the health factor is >= 1.\\n  */\\n  function isHealthy(\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt,\\n    uint256 _minRatio\\n  ) public view override returns (bool) {\\n    uint256 healthFactor = calculateHealthFactor(_collateralValue, _vaultDebt, _minRatio);\\n    return healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\\n  }\\n\\n  /**\\n    Calculate the healthfactor of a debt balance\\n    @param _collateralValue value of the collateral in PAR currency\\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\\n    @param _minRatio min ratio to calculate health factor\\n    @return healthFactor\\n  */\\n  function calculateHealthFactor(\\n    uint256 _collateralValue,\\n    uint256 _vaultDebt,\\n    uint256 _minRatio\\n  ) public view override returns (uint256 healthFactor) {\\n    if (_vaultDebt == 0) return WadRayMath.wad();\\n\\n    // CurrentCollateralizationRatio = value(deposited ETH) / debt\\n    uint256 collateralizationRatio = _collateralValue.wadDiv(_vaultDebt);\\n\\n    // Healthfactor = CurrentCollateralizationRatio / MinimumCollateralizationRatio\\n    if (_minRatio > 0) {\\n      return collateralizationRatio.wadDiv(_minRatio);\\n    }\\n\\n    return 1e18; // 1\\n  }\\n\\n  /**\\n    Calculate the liquidation bonus for a specified amount\\n    @param _collateralType address of the collateral type\\n    @param _amount amount for which the liquidation bonus shall be calculated\\n    @return bonus the liquidation bonus to pay out\\n  */\\n  function liquidationBonus(address _collateralType, uint256 _amount) public view override returns (uint256 bonus) {\\n    return _amount.wadMul(a.config().collateralLiquidationBonus(_collateralType));\\n  }\\n\\n  /**\\n    Apply the liquidation bonus to a balance as a discount.\\n    @param _collateralType address of the collateral type\\n    @param _amount the balance on which to apply to liquidation bonus as a discount.\\n    @return discountedAmount\\n  */\\n  function applyLiquidationDiscount(address _collateralType, uint256 _amount)\\n    public\\n    view\\n    override\\n    returns (uint256 discountedAmount)\\n  {\\n    return _amount.wadDiv(a.config().collateralLiquidationBonus(_collateralType).add(WadRayMath.wad()));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/fees/FeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../interfaces/ISTABLEX.sol\\\";\\nimport \\\"../interfaces/IFeeDistributor.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ncontract FeeDistributor is IFeeDistributor, ReentrancyGuard {\\n  using SafeMath for uint256;\\n\\n  event PayeeAdded(address account, uint256 shares);\\n  event FeeReleased(uint256 income, uint256 releasedAt);\\n\\n  uint256 public override lastReleasedAt;\\n  IAddressProvider public override a;\\n\\n  uint256 public override totalShares;\\n  mapping(address => uint256) public override shares;\\n  address[] public payees;\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not Manager\\\");\\n    _;\\n  }\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Public function to release the accumulated fee income to the payees.\\n    @dev anyone can call this.\\n  */\\n  function release() public override nonReentrant {\\n    uint256 income = a.core().state().availableIncome();\\n    require(income > 0, \\\"income is 0\\\");\\n    require(payees.length > 0, \\\"Payees not configured yet\\\");\\n    lastReleasedAt = now;\\n\\n    // Mint USDX to all receivers\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      address payee = payees[i];\\n      _release(income, payee);\\n    }\\n    emit FeeReleased(income, lastReleasedAt);\\n  }\\n\\n  /**\\n    Updates the payee configuration to a new one.\\n    @dev will release existing fees before the update.\\n    @param _payees Array of payees\\n    @param _shares Array of shares for each payee\\n  */\\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\\n    require(_payees.length == _shares.length, \\\"Payees and shares mismatched\\\");\\n    require(_payees.length > 0, \\\"No payees\\\");\\n\\n    uint256 income = a.core().state().availableIncome();\\n    if (income > 0 && payees.length > 0) {\\n      release();\\n    }\\n\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      delete shares[payees[i]];\\n    }\\n    delete payees;\\n    totalShares = 0;\\n\\n    for (uint256 i = 0; i < _payees.length; i++) {\\n      _addPayee(_payees[i], _shares[i]);\\n    }\\n  }\\n\\n  /**\\n    Get current configured payees.\\n    @return array of current payees.\\n  */\\n  function getPayees() public view override returns (address[] memory) {\\n    return payees;\\n  }\\n\\n  /**\\n    Internal function to release a percentage of income to a specific payee\\n    @dev uses totalShares to calculate correct share\\n    @param _totalIncomeReceived Total income for all payees, will be split according to shares\\n    @param _payee The address of the payee to whom to distribute the fees.\\n  */\\n  function _release(uint256 _totalIncomeReceived, address _payee) internal {\\n    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);\\n    a.stablex().mint(_payee, payment);\\n  }\\n\\n  /**\\n    Internal function to add a new payee.\\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\\n    @param _payee The address of the payee to add.\\n    @param _shares The number of shares owned by the payee.\\n  */\\n  function _addPayee(address _payee, uint256 _shares) internal {\\n    require(_payee != address(0), \\\"payee is the zero address\\\");\\n    require(_shares > 0, \\\"shares are 0\\\");\\n    require(shares[_payee] == 0, \\\"payee already has shares\\\");\\n\\n    payees.push(_payee);\\n    shares[_payee] = _shares;\\n    totalShares = totalShares.add(_shares);\\n    emit PayeeAdded(_payee, _shares);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/RatesManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../interfaces/IRatesManager.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ncontract RatesManager is IRatesManager {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  uint256 private constant _SECONDS_PER_YEAR = 365 days;\\n\\n  IAddressProvider public override a;\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  /**\\n    Calculate the annualized borrow rate from the specified borrowing rate.\\n    @param _borrowRate rate for a 1 second interval specified in RAY accuracy.\\n    @return annualized rate\\n  */\\n  function annualizedBorrowRate(uint256 _borrowRate) public pure override returns (uint256) {\\n    return _borrowRate.rayPow(_SECONDS_PER_YEAR);\\n  }\\n\\n  /**\\n    Calculate the total debt from a specified base debt and cumulative rate.\\n    @param _baseDebt the base debt to be used. Can be a vault base debt or an aggregate base debt\\n    @param _cumulativeRate the cumulative rate in RAY accuracy.\\n    @return debt after applying the cumulative rate\\n  */\\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) public pure override returns (uint256 debt) {\\n    return _baseDebt.rayMul(_cumulativeRate);\\n  }\\n\\n  /**\\n    Calculate the base debt from a specified total debt and cumulative rate.\\n    @param _debt the total debt to be used.\\n    @param _cumulativeRate the cumulative rate in RAY accuracy.\\n    @return baseDebt the new base debt\\n  */\\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) public pure override returns (uint256 baseDebt) {\\n    return _debt.rayDiv(_cumulativeRate);\\n  }\\n\\n  /**\\n    Bring an existing cumulative rate forward in time\\n    @param _borrowRate rate for a 1 second interval specified in RAY accuracy to be applied\\n    @param _timeElapsed the time over whicht the borrow rate shall be applied\\n    @param _cumulativeRate the initial cumulative rate from which to apply the borrow rate\\n    @return new cumulative rate\\n  */\\n  function calculateCumulativeRate(\\n    uint256 _borrowRate,\\n    uint256 _cumulativeRate,\\n    uint256 _timeElapsed\\n  ) public view override returns (uint256) {\\n    if (_timeElapsed == 0) return _cumulativeRate;\\n    uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);\\n    return _cumulativeRate.rayMul(cumulativeElapsed);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/PriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\nimport \\\"../interfaces/IPriceFeed.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../chainlink/AggregatorV3Interface.sol\\\";\\nimport \\\"../libraries/MathPow.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\n\\ncontract PriceFeed is IPriceFeed {\\n  using SafeMath for uint256;\\n  using SafeMath for uint8;\\n  using WadRayMath for uint256;\\n\\n  uint256 public constant PRICE_ORACLE_STALE_THRESHOLD = 1 days;\\n\\n  IAddressProvider public override a;\\n\\n  mapping(address => AggregatorV3Interface) public override assetOracles;\\n\\n  AggregatorV3Interface public override eurOracle;\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n    a = _addresses;\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice Sets the oracle for the given asset,\\n   * @param _asset address to the collateral asset e.g. WETH\\n   * @param _oracle address to the oracel, this oracle should implement the AggregatorV3Interface\\n   */\\n  function setAssetOracle(address _asset, address _oracle) public override onlyManager {\\n    require(_asset != address(0));\\n    require(_oracle != address(0));\\n    assetOracles[_asset] = AggregatorV3Interface(_oracle);\\n    emit OracleUpdated(_asset, _oracle, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Sets the oracle for EUR, this oracle should provide EUR-USD prices\\n   * @param _oracle address to the oracle, this oracle should implement the AggregatorV3Interface\\n   */\\n  function setEurOracle(address _oracle) public override onlyManager {\\n    require(_oracle != address(0));\\n    eurOracle = AggregatorV3Interface(_oracle);\\n    emit EurOracleUpdated(_oracle, msg.sender);\\n  }\\n\\n  /**\\n   * Gets the asset price in EUR (PAR)\\n   * @dev returned value has matching decimals to the asset oracle (not the EUR oracle)\\n   * @param _asset address to the collateral asset e.g. WETH\\n   */\\n  function getAssetPrice(address _asset) public view override returns (uint256 price) {\\n    (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = eurOracle.latestRoundData();\\n    require(eurAnswer > 0, \\\"EUR price data not valid\\\");\\n    require(block.timestamp - eurUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, \\\"EUR price data is stale\\\");\\n\\n    (, int256 answer, , uint256 assetUpdatedAt, ) = assetOracles[_asset].latestRoundData();\\n    require(answer > 0, \\\"Price data not valid\\\");\\n    require(block.timestamp - assetUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, \\\"Price data is stale\\\");\\n\\n    uint8 eurDecimals = eurOracle.decimals();\\n    uint256 eurAccuracy = MathPow.pow(10, eurDecimals);\\n    return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));\\n  }\\n\\n  /**\\n   * @notice Converts asset balance into stablecoin balance at current price\\n   * @param _asset address to the collateral asset e.g. WETH\\n   * @param _amount amount of collateral\\n   */\\n  function convertFrom(address _asset, uint256 _amount) public view override returns (uint256) {\\n    uint256 price = getAssetPrice(_asset);\\n    uint8 collateralDecimals = ERC20(_asset).decimals();\\n    uint8 parDecimals = ERC20(address(a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()\\n    uint8 oracleDecimals = assetOracles[_asset].decimals();\\n    uint256 parAccuracy = MathPow.pow(10, parDecimals);\\n    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));\\n    return _amount.mul(price).mul(parAccuracy).div(collateralAccuracy);\\n  }\\n\\n  /**\\n   * @notice Converts stablecoin balance into collateral balance at current price\\n   * @param _asset address to the collateral asset e.g. WETH\\n   * @param _amount amount of stablecoin\\n   */\\n  function convertTo(address _asset, uint256 _amount) public view override returns (uint256) {\\n    uint256 price = getAssetPrice(_asset);\\n    uint8 collateralDecimals = ERC20(_asset).decimals();\\n    uint8 parDecimals = ERC20(address(a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()\\n    uint8 oracleDecimals = assetOracles[_asset].decimals();\\n    uint256 parAccuracy = MathPow.pow(10, parDecimals);\\n    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));\\n    return _amount.mul(collateralAccuracy).div(price).div(parAccuracy);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MathPow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary MathPow {\\n  function pow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n    z = n % 2 != 0 ? x : 1;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      x = SafeMath.mul(x, x);\\n\\n      if (n % 2 != 0) {\\n        z = SafeMath.mul(z, x);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockChainlinkFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../chainlink/AggregatorV3Interface.sol\\\";\\n\\ncontract MockChainlinkFeed is AggregatorV3Interface, Ownable {\\n  uint256 private _latestPrice;\\n  string public override description;\\n  uint256 public override version = 3;\\n\\n  uint8 public override decimals;\\n\\n  constructor(\\n    uint8 _decimals,\\n    uint256 _price,\\n    string memory _description\\n  ) public {\\n    decimals = _decimals;\\n    _latestPrice = _price;\\n    description = _description;\\n  }\\n\\n  function setLatestPrice(uint256 price) public onlyOwner {\\n    require(price > 110033500); // > 1.1 USD\\n    require(price < 130033500); // > 1.3 USD\\n    _latestPrice = price;\\n  }\\n\\n  /**\\n   * @notice get data about a round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @param _roundId the requested round ID as presented through the proxy, this\\n   * is made up of the aggregator's round ID with the phase ID encoded in the\\n   * two highest order bytes\\n   * @return roundId is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function getRoundData(uint80 _roundId)\\n    public\\n    view\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    roundId = uint80(_roundId);\\n    answer = int256(_latestPrice);\\n    startedAt = uint256(1597422127);\\n    updatedAt = uint256(1597695228);\\n    answeredInRound = uint80(_roundId);\\n  }\\n\\n  /**\\n   * @notice get data about the latest round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @return roundId is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function latestRoundData()\\n    public\\n    view\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    uint256 latestRound = 101;\\n    roundId = uint80(latestRound);\\n    answer = int256(_latestPrice);\\n    startedAt = uint256(1597422127);\\n    updatedAt = now;\\n    answeredInRound = uint80(latestRound);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockChainlinkAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../chainlink/AggregatorV3Interface.sol\\\";\\n\\ncontract MockChainlinkAggregator is AggregatorV3Interface {\\n  uint256 private _latestPrice;\\n  uint256 private _updatedAt;\\n  string public override description;\\n  uint256 public override version = 3;\\n\\n  uint8 public override decimals;\\n\\n  constructor(\\n    uint8 _decimals,\\n    uint256 _price,\\n    string memory _description\\n  ) public {\\n    decimals = _decimals;\\n    _latestPrice = _price;\\n    description = _description;\\n  }\\n\\n  function setLatestPrice(uint256 price) public {\\n    _latestPrice = price;\\n  }\\n\\n  function setUpdatedAt(uint256 updatedAt) public {\\n    _updatedAt = updatedAt;\\n  }\\n\\n  /**\\n   * @notice get data about a round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @param _roundId the requested round ID as presented through the proxy, this\\n   * is made up of the aggregator's round ID with the phase ID encoded in the\\n   * two highest order bytes\\n   * @return roundId is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function getRoundData(uint80 _roundId)\\n    public\\n    view\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    roundId = uint80(_roundId);\\n    answer = int256(_latestPrice);\\n    startedAt = uint256(1597422127);\\n    updatedAt = uint256(1597695228);\\n    answeredInRound = uint80(_roundId);\\n  }\\n\\n  /**\\n   * @notice get data about the latest round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @return roundId is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function latestRoundData()\\n    public\\n    view\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    uint256 latestRound = 101;\\n    roundId = uint80(latestRound);\\n    answer = int256(_latestPrice);\\n    startedAt = uint256(1597422127);\\n    updatedAt = _updatedAt;\\n    answeredInRound = uint80(latestRound);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ConfigProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../interfaces/IConfigProvider.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\n\\ncontract ConfigProvider is IConfigProvider {\\n  IAddressProvider public override a;\\n\\n  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1\\n  mapping(address => uint256) public override collateralIds;\\n\\n  uint256 public override numCollateralConfigs;\\n  /// @notice The minimum duration of voting on a proposal, in seconds\\n  uint256 public override minVotingPeriod = 3 days;\\n  /// @notice The max duration of voting on a proposal, in seconds\\n  uint256 public override maxVotingPeriod = 2 weeks;\\n  /// @notice The percentage of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed\\n  uint256 public override votingQuorum = 1e16; // 1%\\n  /// @notice The percentage of votes required in order for a voter to become a proposer\\n  uint256 public override proposalThreshold = 2e14; // 0.02%\\n\\n  constructor(IAddressProvider _addresses) public {\\n    require(address(_addresses) != address(0));\\n\\n    a = _addresses;\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  /**\\n    Creates or overwrites an existing config for a collateral type\\n    @param _collateralType address of the collateral type\\n    @param _debtLimit the debt ceiling for the collateral type\\n    @param _liquidationRatio the minimum ratio to maintain to avoid liquidation\\n    @param _minCollateralRatio the minimum ratio to maintain to borrow new money or withdraw collateral\\n    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.\\n    @param _originationFee an optional origination fee for newly created debt. Can be 0.\\n    @param _liquidationBonus the liquidation bonus to be paid to liquidators.\\n    @param _liquidationFee an optional fee for liquidation debt. Can be 0.\\n  */\\n  function setCollateralConfig(\\n    address _collateralType,\\n    uint256 _debtLimit,\\n    uint256 _liquidationRatio,\\n    uint256 _minCollateralRatio,\\n    uint256 _borrowRate,\\n    uint256 _originationFee,\\n    uint256 _liquidationBonus,\\n    uint256 _liquidationFee\\n  ) public override onlyManager {\\n    require(address(_collateralType) != address(0));\\n    require(_minCollateralRatio >= _liquidationRatio);\\n    if (collateralIds[_collateralType] == 0) {\\n      // Initialize new collateral\\n      a.core().state().initializeRates(_collateralType);\\n      CollateralConfig memory config = CollateralConfig({\\n        collateralType: _collateralType,\\n        debtLimit: _debtLimit,\\n        liquidationRatio: _liquidationRatio,\\n        minCollateralRatio: _minCollateralRatio,\\n        borrowRate: _borrowRate,\\n        originationFee: _originationFee,\\n        liquidationBonus: _liquidationBonus,\\n        liquidationFee: _liquidationFee\\n      });\\n\\n      numCollateralConfigs++;\\n      _collateralConfigs[numCollateralConfigs] = config;\\n      collateralIds[_collateralType] = numCollateralConfigs;\\n    } else {\\n      // Update collateral config\\n      a.core().state().refreshCollateral(_collateralType);\\n      uint256 id = collateralIds[_collateralType];\\n\\n      _collateralConfigs[id].collateralType = _collateralType;\\n      _collateralConfigs[id].debtLimit = _debtLimit;\\n      _collateralConfigs[id].liquidationRatio = _liquidationRatio;\\n      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;\\n      _collateralConfigs[id].borrowRate = _borrowRate;\\n      _collateralConfigs[id].originationFee = _originationFee;\\n      _collateralConfigs[id].liquidationBonus = _liquidationBonus;\\n      _collateralConfigs[id].liquidationFee = _liquidationFee;\\n    }\\n    emit CollateralUpdated(\\n      _collateralType,\\n      _debtLimit,\\n      _liquidationRatio,\\n      _minCollateralRatio,\\n      _borrowRate,\\n      _originationFee,\\n      _liquidationBonus,\\n      _liquidationFee\\n    );\\n  }\\n\\n  function _emitUpdateEvent(address _collateralType) internal {\\n    emit CollateralUpdated(\\n      _collateralType,\\n      _collateralConfigs[collateralIds[_collateralType]].debtLimit,\\n      _collateralConfigs[collateralIds[_collateralType]].liquidationRatio,\\n      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,\\n      _collateralConfigs[collateralIds[_collateralType]].borrowRate,\\n      _collateralConfigs[collateralIds[_collateralType]].originationFee,\\n      _collateralConfigs[collateralIds[_collateralType]].liquidationBonus,\\n      _collateralConfigs[collateralIds[_collateralType]].liquidationFee\\n    );\\n  }\\n\\n  /**\\n    Remove the config for a collateral type\\n    @param _collateralType address of the collateral type\\n  */\\n  function removeCollateral(address _collateralType) public override onlyManager {\\n    uint256 id = collateralIds[_collateralType];\\n    require(id != 0, \\\"collateral does not exist\\\");\\n\\n    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward\\n    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry\\n    delete _collateralConfigs[numCollateralConfigs]; // delete last entry\\n    delete collateralIds[_collateralType];\\n\\n    numCollateralConfigs--;\\n\\n    emit CollateralRemoved(_collateralType);\\n  }\\n\\n  /**\\n    Sets the debt limit for a collateral type\\n    @param _collateralType address of the collateral type\\n    @param _debtLimit the new debt limit\\n  */\\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {\\n    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the minimum liquidation ratio for a collateral type\\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\\n    @param _collateralType address of the collateral type\\n    @param _liquidationRatio the new minimum collateralization ratio\\n  */\\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio)\\n    public\\n    override\\n    onlyManager\\n  {\\n    require(_liquidationRatio <= _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio);\\n    _collateralConfigs[collateralIds[_collateralType]].liquidationRatio = _liquidationRatio;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the minimum ratio for a collateral type for new borrowing or collateral withdrawal\\n    @param _collateralType address of the collateral type\\n    @param _minCollateralRatio the new minimum open ratio\\n  */\\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)\\n    public\\n    override\\n    onlyManager\\n  {\\n    require(_minCollateralRatio >= _collateralConfigs[collateralIds[_collateralType]].liquidationRatio);\\n    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the borrowing rate for a collateral type\\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\\n    @param _collateralType address of the collateral type\\n    @param _borrowRate the new borrowing rate for a 1 sec interval\\n  */\\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {\\n    a.core().state().refreshCollateral(_collateralType);\\n    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the origiation fee for a collateral type\\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\\n    @param _collateralType address of the collateral type\\n    @param _originationFee new origination fee in WAD\\n  */\\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {\\n    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the liquidation bonus for a collateral type\\n    @dev the liquidation bonus is specified in WAD\\n    @param _collateralType address of the collateral type\\n    @param _liquidationBonus the liquidation bonus to be paid to liquidators.\\n  */\\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus)\\n    public\\n    override\\n    onlyManager\\n  {\\n    _collateralConfigs[collateralIds[_collateralType]].liquidationBonus = _liquidationBonus;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Sets the liquidation fee for a collateral type\\n    @dev this rate is applied as a fee for liquidation and is specified in WAD\\n    @param _collateralType address of the collateral type\\n    @param _liquidationFee new liquidation fee in WAD\\n  */\\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) public override onlyManager {\\n    require(_liquidationFee < 1e18); // fee < 100%\\n    _collateralConfigs[collateralIds[_collateralType]].liquidationFee = _liquidationFee;\\n    _emitUpdateEvent(_collateralType);\\n  }\\n\\n  /**\\n    Set the min voting period for a gov proposal.\\n    @param _minVotingPeriod the min voting period for a gov proposal\\n  */\\n  function setMinVotingPeriod(uint256 _minVotingPeriod) public override onlyManager {\\n    minVotingPeriod = _minVotingPeriod;\\n  }\\n\\n  /**\\n    Set the max voting period for a gov proposal.\\n    @param _maxVotingPeriod the max voting period for a gov proposal\\n  */\\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) public override onlyManager {\\n    maxVotingPeriod = _maxVotingPeriod;\\n  }\\n\\n  /**\\n    Set the voting quora for a gov proposal.\\n    @param _votingQuorum the voting quora for a gov proposal\\n  */\\n  function setVotingQuorum(uint256 _votingQuorum) public override onlyManager {\\n    require(_votingQuorum < 1e18);\\n    votingQuorum = _votingQuorum;\\n  }\\n\\n  /**\\n    Set the proposal threshold for a gov proposal.\\n    @param _proposalThreshold the proposal threshold for a gov proposal\\n  */\\n  function setProposalThreshold(uint256 _proposalThreshold) public override onlyManager {\\n    require(_proposalThreshold < 1e18);\\n    proposalThreshold = _proposalThreshold;\\n  }\\n\\n  /**\\n    Get the debt limit for a collateral type\\n    @dev this is a platform wide limit for new debt issuance against a specific collateral type\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;\\n  }\\n\\n  /**\\n    Get the liquidation ratio that needs to be maintained for a collateral type to avoid liquidation.\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralLiquidationRatio(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationRatio;\\n  }\\n\\n  /**\\n    Get the minimum collateralization ratio for a collateral type for new borrowing or collateral withdrawal.\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;\\n  }\\n\\n  /**\\n    Get the borrowing rate for a collateral type\\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;\\n  }\\n\\n  /**\\n    Get the origiation fee for a collateral type\\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].originationFee;\\n  }\\n\\n  /**\\n    Get the liquidation bonus for a collateral type\\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralLiquidationBonus(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationBonus;\\n  }\\n\\n  /**\\n    Get the liquidation fee for a collateral type\\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\\n    @param _collateralType address of the collateral type\\n  */\\n  function collateralLiquidationFee(address _collateralType) public view override returns (uint256) {\\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationFee;\\n  }\\n\\n  /**\\n    Retreives the entire config for a specific config id.\\n    @param _id the ID of the conifg to be returned\\n  */\\n  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {\\n    require(_id <= numCollateralConfigs, \\\"Invalid config id\\\");\\n    return _collateralConfigs[_id];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/ITimelock.sol\\\";\\n\\ncontract Timelock is ITimelock {\\n  using SafeMath for uint256;\\n\\n  uint256 public constant MINIMUM_DELAY = 2 days;\\n  uint256 public constant MAXIMUM_DELAY = 30 days;\\n  uint256 public constant override GRACE_PERIOD = 14 days;\\n\\n  address public admin;\\n  address public pendingAdmin;\\n  uint256 public override delay;\\n\\n  mapping(bytes32 => bool) public override queuedTransactions;\\n\\n  constructor(address _admin, uint256 _delay) public {\\n    require(address(_admin) != address(0));\\n    require(_delay >= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n    require(_delay <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n\\n    admin = _admin;\\n    delay = _delay;\\n  }\\n\\n  receive() external payable {}\\n\\n  fallback() external payable {}\\n\\n  function setDelay(uint256 _delay) public {\\n    require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n    require(_delay >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n    require(_delay <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n    delay = _delay;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  function acceptAdmin() public override {\\n    require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n    admin = msg.sender;\\n    pendingAdmin = address(0);\\n\\n    emit NewAdmin(admin);\\n  }\\n\\n  function setPendingAdmin(address _pendingAdmin) public {\\n    require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\n    pendingAdmin = _pendingAdmin;\\n\\n    emit NewPendingAdmin(pendingAdmin);\\n  }\\n\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public override returns (bytes32) {\\n    require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n    require(\\n      eta >= block.timestamp.add(delay),\\n      \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\"\\n    );\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    queuedTransactions[txHash] = true;\\n\\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\\n    return txHash;\\n  }\\n\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public override {\\n    require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    queuedTransactions[txHash] = false;\\n\\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\\n  }\\n\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public payable override returns (bytes memory) {\\n    require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\");\\n    require(block.timestamp >= eta, \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\");\\n    require(block.timestamp <= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n    queuedTransactions[txHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    // solium-disable-next-line security/no-call-value\\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\\n    require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n    return returnData;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/test/TestTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.6.12;\\n\\nimport '../Timelock.sol';\\n\\n// Test timelock contract with admin helpers\\ncontract TestTimelock is Timelock {\\n  constructor(address admin_, uint256 delay_) public Timelock(admin_, 2 days) {\\n    delay = delay_;\\n  }\\n\\n  function harnessSetPendingAdmin(address pendingAdmin_) public {\\n    pendingAdmin = pendingAdmin_;\\n  }\\n\\n  function harnessSetAdmin(address admin_) public {\\n    admin = admin_;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernorAlpha.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IGovernorAlpha.sol\\\";\\nimport \\\"./interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\n\\ncontract GovernorAlpha is IGovernorAlpha {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  /// @notice The maximum number of actions that can be included in a proposal\\n  function proposalMaxOperations() public pure returns (uint256) {\\n    return 10;\\n  } // 10 actions\\n\\n  IGovernanceAddressProvider public a;\\n\\n  /// @notice The address of the Governor Guardian\\n  address public guardian;\\n\\n  /// @notice The total number of proposals\\n  uint256 public proposalCount;\\n\\n  /// @notice The official record of all proposals ever proposed\\n  mapping(uint256 => Proposal) public proposals;\\n\\n  /// @notice The latest proposal for each proposer\\n  mapping(address => uint256) public latestProposalIds;\\n\\n  constructor(IGovernanceAddressProvider _addresses, address _guardian) public {\\n    require(address(_addresses) != address(0));\\n    require(address(_guardian) != address(0));\\n\\n    a = _addresses;\\n    guardian = _guardian;\\n  }\\n\\n  function propose(\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    string memory description,\\n    uint256 endTime\\n  ) public override returns (uint256) {\\n    uint256 votingDuration = endTime.sub(block.timestamp);\\n    require(votingDuration >= a.parallel().config().minVotingPeriod(), \\\"Proposal end-time too early\\\");\\n    require(votingDuration <= a.parallel().config().maxVotingPeriod(), \\\"Proposal end-time too late\\\");\\n\\n    require(\\n      a.votingEscrow().balanceOfAt(msg.sender, endTime) > proposalThreshold(),\\n      \\\"GovernorAlpha::propose: proposer votes below proposal threshold\\\"\\n    );\\n    require(\\n      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\\n      \\\"GovernorAlpha::propose: proposal function information arity mismatch\\\"\\n    );\\n    require(targets.length != 0, \\\"GovernorAlpha::propose: must provide actions\\\");\\n    require(targets.length <= proposalMaxOperations(), \\\"GovernorAlpha::propose: too many actions\\\");\\n\\n    uint256 latestProposalId = latestProposalIds[msg.sender];\\n    if (latestProposalId != 0) {\\n      ProposalState proposersLatestProposalState = state(latestProposalId);\\n      require(\\n        proposersLatestProposalState != ProposalState.Active,\\n        \\\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\\\"\\n      );\\n    }\\n\\n    proposalCount++;\\n    Proposal memory newProposal = Proposal({\\n      id: proposalCount,\\n      proposer: msg.sender,\\n      eta: 0,\\n      targets: targets,\\n      values: values,\\n      signatures: signatures,\\n      calldatas: calldatas,\\n      startTime: block.timestamp,\\n      endTime: endTime,\\n      forVotes: 0,\\n      againstVotes: 0,\\n      canceled: false,\\n      executed: false\\n    });\\n\\n    proposals[newProposal.id] = newProposal;\\n    latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n    emit ProposalCreated(\\n      newProposal.id,\\n      msg.sender,\\n      targets,\\n      values,\\n      signatures,\\n      calldatas,\\n      block.timestamp,\\n      endTime,\\n      description\\n    );\\n    return newProposal.id;\\n  }\\n\\n  function queue(uint256 proposalId) public override {\\n    require(\\n      state(proposalId) == ProposalState.Succeeded,\\n      \\\"GovernorAlpha::queue: proposal can only be queued if it is succeeded\\\"\\n    );\\n    Proposal storage proposal = proposals[proposalId];\\n    uint256 eta = block.timestamp.add(a.timelock().delay());\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n    }\\n    proposal.eta = eta;\\n    emit ProposalQueued(proposalId, eta);\\n  }\\n\\n  function execute(uint256 proposalId) public payable override {\\n    require(\\n      state(proposalId) == ProposalState.Queued,\\n      \\\"GovernorAlpha::execute: proposal can only be executed if it is queued\\\"\\n    );\\n    Proposal storage proposal = proposals[proposalId];\\n    proposal.executed = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      a.timelock().executeTransaction{ value: proposal.values[i] }(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.eta\\n      );\\n    }\\n    emit ProposalExecuted(proposalId);\\n  }\\n\\n  function cancel(uint256 proposalId) public override {\\n    ProposalState state = state(proposalId);\\n    require(state != ProposalState.Executed, \\\"GovernorAlpha::cancel: cannot cancel executed proposal\\\");\\n\\n    Proposal storage proposal = proposals[proposalId];\\n    require(msg.sender == guardian, \\\"Only Guardian can cancel\\\");\\n\\n    proposal.canceled = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      a.timelock().cancelTransaction(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.eta\\n      );\\n    }\\n\\n    emit ProposalCanceled(proposalId);\\n  }\\n\\n  function castVote(uint256 proposalId, bool support) public override {\\n    require(state(proposalId) == ProposalState.Active, \\\"GovernorAlpha::_castVote: voting is closed\\\");\\n    Proposal storage proposal = proposals[proposalId];\\n    Receipt storage receipt = proposal.receipts[msg.sender];\\n    require(receipt.hasVoted == false, \\\"GovernorAlpha::_castVote: voter already voted\\\");\\n    uint256 votes = a.votingEscrow().balanceOfAt(msg.sender, proposal.endTime);\\n\\n    if (support) {\\n      proposal.forVotes = proposal.forVotes.add(votes);\\n    } else {\\n      proposal.againstVotes = proposal.againstVotes.add(votes);\\n    }\\n\\n    receipt.hasVoted = true;\\n    receipt.support = support;\\n    receipt.votes = votes;\\n\\n    emit VoteCast(msg.sender, proposalId, support, votes);\\n  }\\n\\n  // solhint-disable-next-line private-vars-leading-underscore\\n  function __acceptAdmin() public {\\n    require(msg.sender == guardian, \\\"GovernorAlpha::__acceptAdmin: sender must be gov guardian\\\");\\n    a.timelock().acceptAdmin();\\n  }\\n\\n  // solhint-disable-next-line private-vars-leading-underscore\\n  function __abdicate() public {\\n    require(msg.sender == guardian, \\\"GovernorAlpha::__abdicate: sender must be gov guardian\\\");\\n    guardian = address(0);\\n  }\\n\\n  // solhint-disable-next-line private-vars-leading-underscore\\n  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\\n    require(msg.sender == guardian, \\\"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n    a.timelock().queueTransaction(\\n      address(a.timelock()),\\n      0,\\n      \\\"setPendingAdmin(address)\\\",\\n      abi.encode(newPendingAdmin),\\n      eta\\n    );\\n  }\\n\\n  // solhint-disable-next-line private-vars-leading-underscore\\n  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\\n    require(msg.sender == guardian, \\\"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n    a.timelock().executeTransaction(\\n      address(a.timelock()),\\n      0,\\n      \\\"setPendingAdmin(address)\\\",\\n      abi.encode(newPendingAdmin),\\n      eta\\n    );\\n  }\\n\\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n  function quorumVotes() public view override returns (uint256) {\\n    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().votingQuorum());\\n  }\\n\\n  /// @notice The number of votes required in order for a voter to become a proposer\\n  function proposalThreshold() public view override returns (uint256) {\\n    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().proposalThreshold());\\n  }\\n\\n  function getActions(uint256 proposalId)\\n    public\\n    view\\n    override\\n    returns (\\n      address[] memory targets,\\n      uint256[] memory values,\\n      string[] memory signatures,\\n      bytes[] memory calldatas\\n    )\\n  {\\n    Proposal storage p = proposals[proposalId];\\n    return (p.targets, p.values, p.signatures, p.calldatas);\\n  }\\n\\n  function getReceipt(uint256 proposalId, address voter) public view override returns (Receipt memory) {\\n    return proposals[proposalId].receipts[voter];\\n  }\\n\\n  function state(uint256 proposalId) public view override returns (ProposalState) {\\n    require(proposalCount >= proposalId && proposalId > 0, \\\"GovernorAlpha::state: invalid proposal id\\\");\\n    Proposal storage proposal = proposals[proposalId];\\n    if (proposal.canceled) {\\n      return ProposalState.Canceled;\\n    } else if (block.timestamp <= proposal.endTime) {\\n      return ProposalState.Active;\\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\\n      return ProposalState.Defeated;\\n    } else if (proposal.eta == 0) {\\n      return ProposalState.Succeeded;\\n    } else if (proposal.executed) {\\n      return ProposalState.Executed;\\n    } else if (block.timestamp >= a.timelock().GRACE_PERIOD().add(proposal.endTime)) {\\n      return ProposalState.Expired;\\n    } else {\\n      return ProposalState.Queued;\\n    }\\n  }\\n\\n  function _queueOrRevert(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) internal {\\n    require(\\n      !a.timelock().queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\\n      \\\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\\\"\\n    );\\n    a.timelock().queueTransaction(target, value, signature, data, eta);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/MIMODistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./interfaces/IMIMODistributor.sol\\\";\\nimport \\\"./BaseDistributor.sol\\\";\\n\\n/*\\n  \\tDistribution Formula:\\n  \\t55.5m MIMO in first week\\n  \\t-5.55% redution per week\\n\\n  \\ttotal(timestamp) = _SECONDS_PER_WEEK * ( (1-_WEEKLY_R^(timestamp/_SECONDS_PER_WEEK)) / (1-_WEEKLY_R) )\\n  \\t\\t+ timestamp % _SECONDS_PER_WEEK * (1-_WEEKLY_R^(timestamp/_SECONDS_PER_WEEK)\\n  */\\n\\ncontract MIMODistributor is BaseDistributor, IMIMODistributorExtension {\\n  using SafeMath for uint256;\\n  using WadRayMath for uint256;\\n\\n  uint256 private constant _SECONDS_PER_YEAR = 365 days;\\n  uint256 private constant _SECONDS_PER_WEEK = 7 days;\\n  uint256 private constant _WEEKLY_R = 9445e23; //-5.55%\\n  uint256 private constant _FIRST_WEEK_TOKENS = 55500000 ether; //55.5m\\n\\n  uint256 public override startTime;\\n\\n  constructor(IGovernanceAddressProvider _a, uint256 _startTime) public {\\n    require(address(_a) != address(0));\\n\\n    a = _a;\\n    startTime = _startTime;\\n  }\\n\\n  /**\\n    Get current monthly issuance of new MIMO tokens.\\n    @return number of monthly issued tokens currently`.\\n  */\\n  function currentIssuance() public view override returns (uint256) {\\n    return weeklyIssuanceAt(now);\\n  }\\n\\n  /**\\n    Get monthly issuance of new MIMO tokens at `timestamp`.\\n    @dev invalid for timestamps before deployment\\n    @param timestamp for which to calculate the monthly issuance\\n    @return number of monthly issued tokens at `timestamp`.\\n  */\\n  function weeklyIssuanceAt(uint256 timestamp) public view override returns (uint256) {\\n    uint256 elapsedSeconds = timestamp.sub(startTime);\\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\\n    return _WEEKLY_R.rayPow(elapsedWeeks).rayMul(_FIRST_WEEK_TOKENS);\\n  }\\n\\n  /**\\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\\n    @return number of mintable tokens available right now.\\n  */\\n  function mintableTokens() public view override returns (uint256) {\\n    return totalSupplyAt(now).sub(a.mimo().totalSupply());\\n  }\\n\\n  /**\\n    Calculates the totalSupply for any point after `startTime`\\n    @param timestamp for which to calculate the totalSupply\\n    @return totalSupply at timestamp.\\n  */\\n  function totalSupplyAt(uint256 timestamp) public view override returns (uint256) {\\n    uint256 elapsedSeconds = timestamp.sub(startTime);\\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\\n    uint256 lastWeekSeconds = elapsedSeconds % _SECONDS_PER_WEEK;\\n    uint256 one = WadRayMath.ray();\\n    uint256 fullWeeks = one.sub(_WEEKLY_R.rayPow(elapsedWeeks)).rayMul(_FIRST_WEEK_TOKENS).rayDiv(one.sub(_WEEKLY_R));\\n    uint256 currentWeekIssuance = weeklyIssuanceAt(timestamp);\\n    uint256 partialWeek = currentWeekIssuance.mul(lastWeekSeconds).div(_SECONDS_PER_WEEK);\\n    return fullWeeks.add(partialWeek);\\n  }\\n\\n  /**\\n    Internal function to release a percentage of newTokens to a specific payee\\n    @dev uses totalShares to calculate correct share\\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\\n    @param _payee The address of the payee to whom to distribute the fees.\\n  */\\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\\n    a.mimo().mint(_payee, payment);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/DistributorManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../governance/interfaces/IGovernanceAddressProvider.sol\\\";\\nimport \\\"./interfaces/IBaseDistributor.sol\\\";\\n\\ncontract DistributorManager {\\n  using SafeMath for uint256;\\n\\n  IGovernanceAddressProvider public a;\\n  IBaseDistributor public mimmoDistributor;\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not Manager\\\");\\n    _;\\n  }\\n\\n  constructor(IGovernanceAddressProvider _a, IBaseDistributor _mimmoDistributor) public {\\n    require(address(_a) != address(0));\\n    require(address(_mimmoDistributor) != address(0));\\n\\n    a = _a;\\n    mimmoDistributor = _mimmoDistributor;\\n  }\\n\\n  /**\\n    Public function to release the accumulated new MIMO tokens to the payees.\\n    @dev anyone can call this.\\n  */\\n  function releaseAll() public {\\n    mimmoDistributor.release();\\n    address[] memory distributors = mimmoDistributor.getPayees();\\n    for (uint256 i = 0; i < distributors.length; i++) {\\n      IBaseDistributor(distributors[i]).release();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockWETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\") {\\n  function mint(address account, uint256 amount) public {\\n    _mint(account, amount);\\n  }\\n\\n  function deposit() public payable {\\n    _mint(msg.sender, msg.value);\\n  }\\n\\n  function withdraw(uint256 wad) public {\\n    _burn(msg.sender, wad);\\n    msg.sender.transfer(wad);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockWBTC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockWBTC is ERC20(\\\"Wrapped Bitcoin\\\", \\\"WBTC\\\") {\\n  function mint(address account, uint256 amount) public {\\n    _mint(account, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockMIMO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockMIMO is ERC20(\\\"MIMO Token\\\", \\\"MIMO\\\") {\\n  function mint(address account, uint256 amount) public {\\n    _mint(account, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockERC20 is ERC20 {\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals\\n  ) public ERC20(_name, _symbol) {\\n    super._setupDecimals(_decimals);\\n  }\\n\\n  function mint(address account, uint256 amount) public {\\n    _mint(account, amount);\\n  }\\n\\n  function burn(address account, uint256 amount) public {\\n    _burn(account, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockBPT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockBPT is ERC20(\\\"Balancer Pool Token\\\", \\\"BPT\\\") {\\n  function mint(address account, uint256 amount) public {\\n    _mint(account, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/MIMOBuyBack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IAddressProvider.sol\\\";\\nimport \\\"../libraries/interfaces/IVault.sol\\\";\\n\\ncontract MIMOBuyback {\\n  bytes32 public constant KEEPER_ROLE = keccak256(\\\"KEEPER_ROLE\\\");\\n\\n  IAddressProvider public a;\\n  IERC20 public PAR;\\n  IERC20 public MIMO;\\n  uint256 public lockExpiry;\\n  bytes32 public poolID;\\n  IVault public balancer = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\\n\\n  bool public whitelistEnabled = false;\\n\\n  constructor(\\n    uint256 _lockExpiry,\\n    bytes32 _poolID,\\n    address _a,\\n    address _mimo\\n  ) public {\\n    lockExpiry = _lockExpiry;\\n    poolID = _poolID;\\n    a = IAddressProvider(_a);\\n    MIMO = IERC20(_mimo);\\n    PAR = a.stablex();\\n\\n    PAR.approve(address(balancer), 2**256 - 1);\\n  }\\n\\n  modifier onlyManager() {\\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \\\"Caller is not a Manager\\\");\\n    _;\\n  }\\n\\n  modifier onlyKeeper() {\\n    require(\\n      !whitelistEnabled || (whitelistEnabled && a.controller().hasRole(KEEPER_ROLE, msg.sender)),\\n      \\\"Caller is not a Keeper\\\"\\n    );\\n    _;\\n  }\\n\\n  function withdrawMIMO(address destination) public onlyManager {\\n    require(block.timestamp > lockExpiry, \\\"lock not expired yet\\\");\\n    require(MIMO.transfer(destination, MIMO.balanceOf(address(this))));\\n  }\\n\\n  function buyMIMO() public onlyKeeper {\\n    a.core().state().refresh();\\n    a.feeDistributor().release();\\n\\n    bytes memory userData = abi.encode();\\n    IVault.SingleSwap memory singleSwap = IVault.SingleSwap(\\n      poolID,\\n      IVault.SwapKind.GIVEN_IN,\\n      IAsset(address(PAR)), // swap in\\n      IAsset(address(MIMO)), // swap out\\n      PAR.balanceOf(address(this)), // all PAR of this contract\\n      userData\\n    );\\n\\n    IVault.FundManagement memory fundManagement = IVault.FundManagement(\\n      address(this), // sender\\n      false, // useInternalBalance\\n      payable(address(this)), // recipient\\n      false // // useInternalBalance\\n    );\\n\\n    balancer.swap(\\n      singleSwap,\\n      fundManagement,\\n      0, // limit, could be frontrun?\\n      2**256 - 1 // deadline\\n    );\\n  }\\n\\n  function setWhitelistEnabled(bool _status) public onlyManager {\\n    whitelistEnabled = _status;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IAsset {\\n  // solhint-disable-previous-line no-empty-blocks\\n}\\n\\ninterface IVault {\\n  enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n  /**\\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n   * the `kind` value.\\n   *\\n   * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n   * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n   *\\n   * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n   * used to extend swap behavior.\\n   */\\n  struct SingleSwap {\\n    bytes32 poolId;\\n    SwapKind kind;\\n    IAsset assetIn;\\n    IAsset assetOut;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  /**\\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n   * `recipient` account.\\n   *\\n   * If the caller is not `sender`, it must be an authorized relayer for them.\\n   *\\n   * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n   * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n   * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n   * `joinPool`.\\n   *\\n   * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n   * transferred. This matches the behavior of `exitPool`.\\n   *\\n   * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n   * revert.\\n   */\\n  struct FundManagement {\\n    address sender;\\n    bool fromInternalBalance;\\n    address payable recipient;\\n    bool toInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Performs a swap with a single Pool.\\n   *\\n   * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n   * taken from the Pool, which must be greater than or equal to `limit`.\\n   *\\n   * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n   * sent to the Pool, which must be less than or equal to `limit`.\\n   *\\n   * Internal Balance usage and the recipient are determined by the `funds` struct.\\n   *\\n   * Emits a `Swap` event.\\n   */\\n  function swap(\\n    SingleSwap memory singleSwap,\\n    FundManagement memory funds,\\n    uint256 limit,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockBuggyERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\n\\n/**\\n    Buggy ERC20 implementation without the return bool on `transfer`, `transferFrom` and `approve` for testing purposes\\n*/\\n\\ncontract MockBuggyERC20 is Context {\\n  using SafeMath for uint256;\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string memory name_, string memory symbol_) public {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = 18;\\n  }\\n\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) public view returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount) public virtual {\\n    _transfer(_msgSender(), recipient, amount);\\n  }\\n\\n  function allowance(address owner, address spender) public view virtual returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount) public virtual {\\n    _approve(_msgSender(), spender, amount);\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual {\\n    _transfer(sender, recipient, amount);\\n    _approve(\\n      sender,\\n      _msgSender(),\\n      _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\")\\n    );\\n  }\\n\\n  function mint(address account, uint256 amount) public {\\n    _mint(account, amount);\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\")\\n    );\\n    return true;\\n  }\\n\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual {\\n    require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n    require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n    _beforeTokenTransfer(sender, recipient, amount);\\n\\n    _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n    _totalSupply = _totalSupply.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  function _setupDecimals(uint8 decimals_) internal {\\n    _decimals = decimals_;\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\"\r\n    },\r\n    \"contracts/libraries/interfaces/BPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma experimental ABIEncoderV2;\\npragma solidity 0.6.12;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface BPool is IERC20 {\\n  function gulp(address token) external;\\n\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\\n\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    uint256 minPoolAmountOut\\n  ) external returns (uint256 poolAmountOut);\\n\\n  function joinswapPoolAmountOut(\\n    address tokenIn,\\n    uint256 poolAmountOut,\\n    uint256 maxAmountIn\\n  ) external returns (uint256 tokenAmountIn);\\n\\n  function exitswapPoolAmountIn(\\n    address tokenOut,\\n    uint256 poolAmountIn,\\n    uint256 minAmountOut\\n  ) external returns (uint256 tokenAmountOut);\\n\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPoolAmountIn\\n  ) external returns (uint256 poolAmountIn);\\n\\n  function calcPoolOutGivenSingleIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) external pure returns (uint256 poolAmountOut);\\n\\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n  function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n  function getSwapFee() external view returns (uint256);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n  function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getNormalizedWeight(address token) external view returns (uint256);\\n\\n  function isPublicSwap() external view returns (bool);\\n\\n  function isFinalized() external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockExpiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_poolID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mimo\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"KEEPER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIMO\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAR\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"a\",\"outputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancer\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMIMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWhitelistEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdrawMIMO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MIMOBuyback","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000069472a705b1c06c4923dbba4b27cfa270ffb2e60aa28615900020000000000000000004a0000000000000000000000006fae125de41c03fa7d917ccfa17ba54ef4feb01400000000000000000000000090b831fa3bebf58e9744a14d638e25b4ee06f9bc","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}