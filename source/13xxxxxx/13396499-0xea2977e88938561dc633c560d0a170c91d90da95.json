{"status":"1","message":"OK","result":[{"SourceCode":"{\"InventoryManager.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.7;\\n\\ncontract InventoryManager {\\n\\n    address impl_;\\n    address public manager;\\n\\n    enum Part { body, helm, mainhand, offhand, unique }\\n\\n    mapping(uint8 =\\u003e address) public bodies;\\n    mapping(uint8 =\\u003e address) public helms;\\n    mapping(uint8 =\\u003e address) public mainhands;\\n    mapping(uint8 =\\u003e address) public offhands;\\n    mapping(uint8 =\\u003e address) public uniques;\\n\\n\\n    string public constant header = \\u0027\\u003csvg id=\\\"orc\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 60 60\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\u003e\\u0027;\\n    string public constant footer = \\u0027\\u003cstyle\\u003e#orc{shape-rendering: crispedges; image-rendering: -webkit-crisp-edges; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; image-rendering: pixelated; -ms-interpolation-mode: nearest-neighbor;}\\u003c/style\\u003e\\u003c/svg\\u003e\\u0027;\\n\\n    function getSVG(uint8 body_, uint8 helm_, uint8 mainhand_, uint8 offhand_) public view returns(string memory) {\\n\\n        // it\\u0027s a unique!\\n        if (helm_ \\u003e 40) return string(abi.encodePacked(header, get(Part.unique, body_), footer));\\n\\n        return string(abi.encodePacked(\\n            header,\\n            get(Part.body, body_), \\n            helm_     \\u003e 4 ? get(Part.helm, helm_)         : \\\"\\\",\\n            mainhand_ \\u003e 0 ? get(Part.mainhand, mainhand_) : \\\"\\\",\\n            offhand_  \\u003e 4 ? get(Part.offhand, offhand_)   : \\\"\\\",\\n            footer ));\\n    }\\n\\n\\n    constructor() { manager = msg.sender;}\\n\\n\\n    function getTokenURI(uint16 id_, uint8 body_, uint8 helm_, uint8 mainhand_, uint8 offhand_, uint16 level_, uint16 zugModifier_) public view returns (string memory) {\\n\\n        string memory svg = Base64.encode(bytes(getSVG(body_,helm_,mainhand_,offhand_)));\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\u0027data:application/json;base64,\\u0027,\\n                    Base64.encode(\\n                        bytes(\\n                            abi.encodePacked(\\n                                \\u0027{\\\"name\\\":\\\"Orc #\\u0027,toString(id_),\\u0027\\\", \\\"description\\\":\\\"EtherOrcs is a collection of 5050 Orcs ready to pillage the blockchain. With no IPFS or API, these Orcs are the very first role-playing game that takes place 100% on-chain. Spawn new Orcs, battle your Orc to level up, and pillage different loot pools to get new weapons and gear which upgrades your Orc metadata. This Horde of Orcs will stand the test of time and live on the blockchain for eternity.\\\", \\\"image\\\": \\\"\\u0027,\\n                                \\u0027data:image/svg+xml;base64,\\u0027,\\n                                svg,\\n                                \\u0027\\\",\\u0027,\\n                                getAttributes(body_, helm_, mainhand_, offhand_, level_, zugModifier_),\\n                                \\u0027}\\u0027\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                    INVENTORY MANAGEMENT\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\n    function setBodies(uint8[] calldata ids, address source) external {\\n        require(msg.sender == manager, \\\"not manager\\\");\\n\\n        for (uint256 index = 0; index \\u003c ids.length; index++) {\\n            bodies[ids[index]] = source; \\n        }\\n    }\\n\\n     function setHelms(uint8[] calldata ids, address source) external {\\n        require(msg.sender == manager, \\\"not manager\\\");\\n\\n        for (uint256 index = 0; index \\u003c ids.length; index++) {\\n            helms[ids[index]] = source; \\n        }\\n    }\\n\\n    function setMainhands(uint8[] calldata ids, address source) external {\\n        require(msg.sender == manager, \\\"not manager\\\");\\n\\n        for (uint256 index = 0; index \\u003c ids.length; index++) {\\n            mainhands[ids[index]] = source; \\n        }\\n    }\\n\\n    function setOffhands(uint8[] calldata ids, address source) external {\\n        require(msg.sender == manager, \\\"not manager\\\");\\n\\n        for (uint256 index = 0; index \\u003c ids.length; index++) {\\n            offhands[ids[index]] = source; \\n        }\\n    }\\n\\n    function setUniques(uint8[] calldata ids, address source) external {\\n        require(msg.sender == manager, \\\"not manager\\\");\\n\\n        for (uint256 index = 0; index \\u003c ids.length; index++) {\\n            uniques[ids[index]] = source; \\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function call(address source, bytes memory sig) internal view returns (string memory svg) {\\n        (bool succ, bytes memory ret)  = source.staticcall(sig);\\n        require(succ, \\\"failed to get data\\\");\\n        svg = abi.decode(ret, (string));\\n    }\\n\\n    function get(Part part, uint8 id) internal view returns (string memory data_) {\\n        address source = \\n            part == Part.body     ? bodies[id]    :\\n            part == Part.helm     ? helms[id]     :\\n            part == Part.mainhand ? mainhands[id] :\\n            part == Part.offhand  ? offhands[id]  : uniques[id];\\n\\n        data_ = wrapTag(call(source, getData(part, id)));\\n    }\\n    \\n    function wrapTag(string memory uri) internal pure returns (string memory) {\\n        return string(abi.encodePacked(\\u0027\\u003cimage x=\\\"1\\\" y=\\\"1\\\" width=\\\"60\\\" height=\\\"60\\\" image-rendering=\\\"pixelated\\\" preserveAspectRatio=\\\"xMidYMid\\\" xlink:href=\\\"data:image/png;base64,\\u0027, uri, \\u0027\\\"/\\u003e\\u0027));\\n    }\\n\\n    function getData(Part part, uint8 id) internal pure returns (bytes memory data) {\\n        string memory s = string(abi.encodePacked(\\n            part == Part.body     ? \\\"body\\\"     :\\n            part == Part.helm     ? \\\"helm\\\"     :\\n            part == Part.mainhand ? \\\"mainhand\\\" :\\n            part == Part.offhand  ? \\\"offhand\\\"  : \\\"unique\\\",\\n            toString(id),\\n            \\\"()\\\"\\n        ));\\n        \\n        return abi.encodeWithSignature(s, \\\"\\\");\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function getAttributes(uint8 body_, uint8 helm_, uint8 mainhand_, uint8 offhand_, uint16 level_, uint16 zugModifier_) internal pure returns (string memory) {\\n       return string(abi.encodePacked(\\n           \\u0027\\\"attributes\\\": [\\u0027,\\n            getBodyAttributes(body_),         \\u0027,\\u0027,\\n            getHelmAttributes(helm_),         \\u0027,\\u0027,\\n            getMainhandAttributes(mainhand_), \\u0027,\\u0027,\\n            getOffhandAttributes(offhand_), \\n            \\u0027,{\\\"trait_type\\\": \\\"level\\\", \\\"value\\\":\\u0027, toString(level_),\\n            \\u0027},{\\\"display_type\\\": \\\"boost_number\\\",\\\"trait_type\\\": \\\"zug bonus\\\", \\\"value\\\":\\u0027, \\n            toString(zugModifier_),\\u0027}]\\u0027));\\n    }\\n\\n    function getBodyAttributes(uint8 body_) internal pure returns(string memory) {\\n        return string(abi.encodePacked(\\u0027{\\\"trait_type\\\":\\\"Body\\\",\\\"value\\\":\\\"\\u0027,getBodyName(body_),\\u0027\\\"}\\u0027));\\n    }\\n\\n    function getHelmAttributes(uint8 helm_) internal pure returns(string memory) {\\n        return string(abi.encodePacked(\\u0027{\\\"trait_type\\\":\\\"Helm\\\",\\\"value\\\":\\\"\\u0027,getHelmName(helm_),\\u0027\\\"},{\\\"display_type\\\":\\\"number\\\",\\\"trait_type\\\":\\\"HelmTier\\\",\\\"value\\\":\\u0027,toString(getTier(helm_)),\\u0027}\\u0027));\\n    }\\n\\n    function getMainhandAttributes(uint8 mainhand_) internal pure returns(string memory) {\\n        return string(abi.encodePacked(\\u0027{\\\"trait_type\\\":\\\"Mainhand\\\",\\\"value\\\":\\\"\\u0027,getMainhandName(mainhand_),\\u0027\\\"},{\\\"display_type\\\":\\\"number\\\",\\\"trait_type\\\":\\\"MainhandTier\\\",\\\"value\\\":\\u0027,toString(getTier(mainhand_)),\\u0027}\\u0027));\\n    }\\n\\n    function getOffhandAttributes(uint8 offhand_) internal pure returns(string memory) {\\n        return string(abi.encodePacked(\\u0027{\\\"trait_type\\\":\\\"Offhand\\\",\\\"value\\\":\\\"\\u0027,getOffhandName(offhand_),\\u0027\\\"},{\\\"display_type\\\":\\\"number\\\",\\\"trait_type\\\":\\\"OffhandTier\\\",\\\"value\\\":\\u0027,toString(getTier(offhand_)),\\u0027}\\u0027));\\n    }\\n\\n    function getTier(uint16 id) internal pure returns (uint16) {\\n        if (id \\u003e 40) return 100;\\n        if (id == 0) return 0;\\n        return ((id - 1) / 4 );\\n    }\\n\\n    // Here, we do sort of a Binary Search to find the correct name. Not the pritiest code I\\u0027ve wrote, but hey, it works!\\n\\n    function getBodyName(uint8 id) public pure returns (string memory) {\\n        if (id \\u003e 40) return getUniqueName(id);\\n        if (id \\u003c 20) {\\n            if ( id \\u003c 10) {\\n                if (id \\u003c 5) {\\n                    if (id \\u003c 3) {\\n                        return id == 1 ? \\\"Green Orc 1\\\" : \\\"Green Orc 2\\\";\\n                    }\\n                    return id == 3 ? \\\"Green Orc 3\\\" : \\\"Dark Green Orc 1\\\";\\n                }\\n                if (id \\u003c 7) return id == 5 ? \\\"Dark Green Orc 2\\\" : \\\"Dark Green Orc 3\\\"; \\n                return id == 7 ? \\\"Red Orc 1\\\" : id == 8 ? \\\"Red Orc 2\\\" : \\\"Red Orc 3\\\";\\n            }\\n            if (id \\u003c= 15) {\\n                if (id \\u003c 13) {\\n                    return id == 10 ? \\\"Blood Red Orc 1\\\" : id == 11 ? \\\"Blood Red Orc 2\\\" : \\\"Blood Red Orc 3\\\";\\n                }\\n                return id == 13 ? \\\"Clay Orc 1\\\" : id == 14 ? \\\"Clay Orc 2\\\" : \\\"Clay Orc 3\\\";\\n            }\\n            if (id \\u003c 18) return id == 16 ? \\\"Dark Clay Orc 1\\\" : \\\"Dark Clay Orc 2\\\";\\n            return id == 18 ? \\\"Dark Clay Orc 3\\\" :  \\\"Blue Orc 1\\\";\\n        }\\n\\n        if ( id \\u003c 30) {\\n            if (id \\u003c 25) {\\n                if (id \\u003c 23) {\\n                    return id == 20 ? \\\"Blue Orc 2\\\" : id == 21 ? \\\"Blue Orc 3\\\" : \\\"Midnight Blue Orc 1\\\";\\n                }\\n                return id == 23 ? \\\"Midnight Blue Orc 2\\\" : \\\"Midnight Blue Orc 3\\\";\\n            }\\n\\n            if (id \\u003c 27) return id == 25 ? \\\"Albino Orc 1\\\" : \\\"Albino Orc 2\\\"; \\n            return \\\"Albino Orc 3\\\";\\n        }\\n    }\\n\\n    function getHelmName(uint8 id) public pure returns (string memory) {\\n        if (id \\u003e 40) return getUniqueName(id);\\n        if (id \\u003c 20) {\\n            if ( id \\u003c 10) {\\n                if (id \\u003c 5) {\\n                    if (id \\u003c 3) {\\n                        return id == 1 ? \\\"None\\\" : \\\"None\\\";\\n                    }\\n                    return id == 3 ? \\\"None\\\" : \\\"None\\\";\\n                }\\n                if (id \\u003c 7) return id == 5 ? \\\"Leather Helm +1\\\" : \\\"Orcish Helm +1\\\"; \\n                return id == 7 ? \\\"Leather Cap +1\\\" : id == 8 ? \\\"Iron Helm +1\\\" : \\\"Bone Helm +2\\\";\\n            }\\n            if (id \\u003c= 15) {\\n                if (id \\u003c 13) {\\n                    return id == 10 ? \\\"Full Orc Helm +2\\\" : id == 11 ? \\\"Chainmail Cap +2\\\" : \\\"Strange Helm +2\\\";\\n                }\\n                return id == 13 ? \\\"Full Plate Helm +3\\\" : id == 14 ? \\\"Chainmail Coif +3\\\" : \\\"Boar Head +3\\\";\\n            }\\n            if (id \\u003c 18) return id == 16 ? \\\"Orb of Protection +3\\\" : \\\"Royal Thingy +4\\\";\\n            return id == 18 ? \\\"Dark Iron Helm +4\\\" :  \\\"Cursed Hood +4\\\";\\n        }\\n\\n        if ( id \\u003c 30) {\\n            if (id \\u003c 25) {\\n                if (id \\u003c 23) {\\n                    return id == 20 ? \\\"Red Bandana +4\\\" : id == 21 ? \\\"Thorned Helm +5\\\" : \\\"Demon Skull +5\\\";\\n                }\\n                return id == 23 ? \\\"Treasure Chest +5\\\" : \\\"Cursed Hood +5\\\";\\n            }\\n\\n            if (id \\u003c 27) return id == 25 ? \\\"Blue Knight Helm +6\\\" : \\\"Parasite +6\\\"; \\n            return id == 27 ? \\\"Dragon Eyes +6\\\" : id == 28 ? \\\"Horned Cape +6\\\" : \\\"Nether Blindfold +7\\\";\\n        }\\n        if (id \\u003c= 35) {\\n            if (id \\u003c 33) {\\n                return id == 30 ? \\\"Lightning Crown +7\\\" : id == 31 ? \\\"Master Warlock Cape +7\\\" : \\\"Red Knight Helm +7\\\";\\n            }\\n            return id == 33 ? \\\"Beholder Head +8\\\" : id == 34 ? \\\"Ice Crown +8\\\" : \\\"Band of the Dark Lord +8\\\";\\n        }\\n        if (id \\u003c 38) return id == 36 ? \\\"Helm of Evil +8\\\" : \\\"Blazing Horns +9\\\";\\n        return id == 38 ? \\\"Possessed Helm +9\\\" : id == 39 ? \\\"Molten Crown +9\\\" : \\\"Helix Helm +9\\\";\\n    }\\n\\n    function getMainhandName(uint8 id) public pure returns (string memory) {\\n        if (id \\u003e 40) return getUniqueName(id);\\n        if (id \\u003c 20) {\\n            if ( id \\u003c 10) {\\n                if (id \\u003c 5) {\\n                    if (id \\u003c 3) {\\n                        return id == 1 ? \\\"Pickaxe\\\" : \\\"Torch\\\";\\n                    }\\n                return id == 3 ? \\\"Club\\\" : \\\"Pleb Staff\\\";\\n            }\\n                if (id \\u003c 7) return id == 5 ? \\\"Short Sword +1\\\" : \\\"Dagger +1\\\"; \\n                return id == 7 ? \\\"Simple Axe +1\\\" : id == 8 ? \\\"Fiery Poker +1\\\" : \\\"Large Axe +2\\\";\\n            }\\n            if (id \\u003c= 15) {\\n                if (id \\u003c 13) {\\n                    return id == 10 ? \\\"Iron Hammer +2\\\" : id == 11 ? \\\"Iron Mace +2\\\" : \\\"Jagged Axe +2\\\";\\n                }\\n                return id == 13 ? \\\"Enchanted Poker +3\\\" : id == 14 ? \\\"Curved Sword +3\\\" : \\\"Ultra Mallet +3\\\";\\n            }\\n            if (id \\u003c 18) return id == 16 ? \\\"Disciple Staff +3\\\" : \\\"Assassin Blade +4\\\";\\n            return id == 18 ? \\\"Swamp Staff +4\\\" :  \\\"Simple Wand +4\\\";\\n        }\\n\\n        if ( id \\u003c 30) {\\n            if (id \\u003c 25) {\\n                if (id \\u003c 23) {\\n                    return id == 20 ? \\\"Royal Blade +4\\\" : id == 21 ? \\\"Skull Shield +5\\\" : \\\"Skull Crusher Axe +5\\\";\\n                }\\n                return id == 23 ? \\\"Flaming Staff +5\\\" : \\\"Flaming Royal Blade +5\\\";\\n            }\\n\\n            if (id \\u003c 27) return id == 25 ? \\\"Berserker Sword +6\\\" : \\\"Necromancer Staff +6\\\"; \\n            return id == 27 ? \\\"Flaming Skull Shield +6\\\" : id == 28 ? \\\"Frozen Scythe +6\\\" : \\\"Blood Sword +7\\\";\\n        }\\n        if (id \\u003c= 35) {\\n            if (id \\u003c 33) {\\n                return id == 30 ? \\\"Dark Lord Staff +7\\\" : id == 31 ? \\\"Bow of Artemis +7\\\" : \\\"Ice Sword +7\\\";\\n            }\\n            return id == 33 ? \\\"Cryptic Staff +8\\\" : id == 34 ? \\\"Nether Lance +8\\\" : \\\"Demonic Axe +8\\\";\\n        }\\n        if (id \\u003c 38) return id == 36 ? \\\"Old Moon Sword +8\\\" : \\\"Lightning Lance +9\\\";\\n        return id == 38 ? \\\"Molten Hammer +9\\\" : id == 39 ? \\\"Possessed Great Staff +9\\\" : \\\"Helix Lance +9\\\";\\n    }\\n\\n    function getOffhandName(uint8 id) public pure returns (string memory) {\\n        if (id \\u003e 40) return getUniqueName(id);\\n        if (id \\u003c 20) {\\n            if ( id \\u003c 10) {\\n                if (id \\u003c 5) {\\n                    if (id \\u003c 3) {\\n                        return id == 1 ? \\\"None\\\" : \\\"None\\\";\\n                    }\\n                    return id == 3 ? \\\"None\\\" : \\\"None\\\";\\n                }\\n                if (id \\u003c 7) return id == 5 ? \\\"Wooden Shield +1\\\" : \\\"Paper Hands Shield +1\\\"; \\n                return id == 7 ? \\\"Dagger +1\\\" : id == 8 ? \\\"Pirate Hook +1\\\" : \\\"Offhand Axe +2\\\";\\n            }\\n            if (id \\u003c= 15) {\\n                if (id \\u003c 13) {\\n                    return id == 10 ? \\\"Offhand Slasher +2\\\" : id == 11 ? \\\"Large Shield +2\\\" : \\\"Bomb +2\\\";\\n                }\\n                return id == 13 ? \\\"Offhand Poker +3\\\" : id == 14 ? \\\"Reinforced Shield +3\\\" : \\\"War Banner +3\\\";\\n            }\\n            if (id \\u003c 18) return id == 16 ? \\\"Hand Cannon +3\\\" : \\\"Metal Kite Shield +4\\\";\\n            return id == 18 ? \\\"Crossbow +4\\\" :  \\\"Cursed Skull +4\\\";\\n        }\\n\\n        if ( id \\u003c 30) {\\n            if (id \\u003c 25) {\\n                if (id \\u003c 23) {\\n                    return id == 20 ? \\\"Spiked Shield +4\\\" : id == 21 ? \\\"Cursed Totem +5\\\" : \\\"Grimoire +5\\\";\\n                }\\n                return id == 23 ? \\\"Offhand Glaive +5\\\" : \\\"Frost Side Sword +5\\\";\\n            }\\n\\n            if (id \\u003c 27) return id == 25 ? \\\"Magic Shield +6\\\" : \\\"Enchanted Glaive +6\\\"; \\n            return id == 27 ? \\\"Burning Wand +6\\\" : id == 28 ? \\\"Burning Shield +6\\\" : \\\"Burning Blade +7\\\";\\n        }\\n        if (id \\u003c= 35) {\\n            if (id \\u003c 33) {\\n                return id == 30 ? \\\"Holy Scepter +7\\\" : id == 31 ? \\\"Possessed Skull +7\\\" : \\\"Demonic Grimoire +7\\\";\\n            }\\n            return id == 33 ? \\\"Scepter of Frost +8\\\" : id == 34 ? \\\"Demonic Scythe +8\\\" : \\\"Lightning Armband of Power +8\\\";\\n        }\\n        if (id \\u003c 38) return id == 36 ? \\\"Ice Staff +8\\\" : \\\"Nether Shield +9\\\";\\n        return id == 38 ? \\\"Molten Scimitar +9\\\" : id == 39 ? \\\"Staff of the Dark Lord +9\\\" : \\\"Helix Scepter +9\\\";\\n    }\\n\\n    function getUniqueName(uint8 id) internal pure returns (string memory) {\\n        if(id \\u003c 47) {\\n            if(id \\u003c 44) {\\n                return id == 41 ? \\\"Cthulhu\\\" : id == 42 ? \\\"Vorgak The War Chief\\\" : \\\"Gromlock The Destroyer\\\";\\n            } \\n            return id == 44 ? \\\"Yuckha The Hero\\\" : id == 45 ? \\\"Orgug The Master Warlock\\\" : \\\"Hoknuk The Demon Tamer\\\";\\n        }\\n        if (id \\u003c 50) {\\n            return id == 47 ? \\\"Lava Man\\\" : id == 48 ? \\\"hagra the Zombie\\\" : \\\"Morzul The Ice Warrior\\\";\\n        }\\n        return id == 50 ? \\\"T4000 The MechaOrc\\\" : id == 51 ? \\\"Slime Orc The Forgotten\\\" : \\\"Mouse God\\\";\\n    }\\n}\\n\\n/// @title Base64\\n/// @author Brecht Devos - \\u003cbrecht@loopring.org\\u003e\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @notice NOT BUILT BY ETHERORCS TEAM. Thanks Bretch Devos!\\nlibrary Base64 {\\n    string internal constant TABLE = \\u0027ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\u0027;\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\u0027\\u0027;\\n        \\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n            \\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n            \\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n            \\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n            \\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               dataPtr := add(dataPtr, 3)\\n               \\n               // read 3 bytes\\n               let input := mload(dataPtr)\\n               \\n               // write 4 characters\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n            }\\n            \\n            // padding with \\u0027=\\u0027\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n        \\n        return result;\\n    }\\n}\"},\"Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.7;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\ncontract Proxy {\\n\\n    address implementation_;\\n    address public admin;\\n\\n    constructor(address impl) {\\n        implementation_ = impl;\\n        admin = msg.sender;\\n    }\\n\\n    function setImplementation(address newImpl) public {\\n        require(msg.sender == admin);\\n        implementation_ = newImpl;\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don\\u0027t know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view returns (address) {\\n        return implementation_;\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImpl\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Proxy","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000164b9511af29baf9095dc1deeb767e28aca78f0c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"1","Implementation":"0x164b9511af29baf9095dc1deeb767e28aca78f0c","SwarmSource":"ipfs://793d1eecbc079852242a0ec54953728651c14090c3cbc47f80fff669962493cc"}]}