{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/renderers/PointRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./ISvgRenderer.sol\\\";\\nimport \\\"./DynamicBufferAllocator.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/**\\n * @notice Implementation of `ISvgRenderer` displaying individual points.\\n * @dev This renderer ignores tangents.\\n * The following unsafe characters will be % encoded in the resulting svg\\n * because the target use-case will be data-uris.\\n * <    %3C\\n * >    %3E\\n * #    %23\\n * %\\t%25\\n * See also https://codepen.io/tigt/post/optimizing-svgs-in-data-uris\\n * @author David Huber (@cxkoda)\\n */\\ncontract PointRenderer is ISvgRenderer, DynamicBufferAllocator {\\n    uint256 private constant skipBytes = 0x04;\\n\\n    /**\\n     * @notice Converts an RGB color to its HEX string\\n     * @param colormap Array of 256 8-bit RGB colors\\n     * @param idx Position of the color in the array to be converted\\n     */\\n    function getHexColor(bytes memory colormap, uint256 idx)\\n        internal\\n        pure\\n        returns (bytes memory buffer)\\n    {\\n        buffer = new bytes(6);\\n        assembly {\\n            // Load the color from the colormap\\n            // and shift to get rid of excess bits\\n            let color := shr(232, mload(add(add(colormap, 0x20), mul(3, idx))))\\n\\n            // We will build up the hex string from right to left\\n            // The final string will always have length 6\\n            for {\\n                let iter := 0\\n                let bufferPos := add(add(buffer, 0x20), 5)\\n            } lt(iter, 6) {\\n                iter := add(iter, 1)\\n                bufferPos := sub(bufferPos, 1) // right to left\\n                color := shr(4, color)\\n            } {\\n                // In each iteration we convert the last 4 bits of the `color`\\n                // to ascii hex. For the next iteration, we shift those 4 bits\\n                // out and start again.\\n\\n                let lastDigit := and(color, 0xf)\\n\\n                // Check if the character will be a number (or letter)\\n                let numeric := lt(lastDigit, 0xa)\\n\\n                // Set the according character\\n                if not(numeric) {\\n                    mstore8(bufferPos, add(87, lastDigit))\\n                }\\n                if numeric {\\n                    mstore8(bufferPos, add(48, lastDigit))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Generate SVG defs for colored point markers.\\n     * @dev Sets of same colored points will later be set to use one of these\\n     * markers.\\n     */\\n    function generateMarkersDefs(\\n        bytes memory colormap,\\n        string memory markerSize\\n    ) internal pure returns (bytes memory) {\\n        bytes memory buffer;\\n        {\\n            uint256 bufferSize = 64 * 256;\\n            (, buffer) = _allocate(bufferSize);\\n        }\\n\\n        for (uint256 idx = 0; idx < 256; ++idx) {\\n            bytes memory markerDefinition = abi.encodePacked(\\n                \\\"%3Cmarker id='dot\\\",\\n                Strings.toString(idx),\\n                \\\"' viewBox='-1 -1 2 2' markerWidth='\\\",\\n                markerSize,\\n                \\\"' markerHeight='\\\",\\n                markerSize,\\n                \\\"'%3E%3Ccircle r='1' fill='%23\\\",\\n                getHexColor(colormap, idx),\\n                \\\"'/%3E%3C/marker%3E\\\"\\n            );\\n            assembly {\\n                /**\\n                 * @notice Append data to a dynamic buffer.\\n                 * See`DynamicBufferAllocator`.\\n                 * @dev Adds `data_` at the end of the `buffer_` and increases\\n                 * the length of the latter accordingly.\\n                 * Warning! Container capacity checks were neglected for performance.\\n                 */\\n                function appendBytes(buffer_, data_) {\\n                    let length := mload(data_)\\n                    for {\\n                        let data := add(data_, 32)\\n                        let dataEnd := add(data, length)\\n                        let buf := add(buffer_, add(mload(buffer_), 32))\\n                    } lt(data, dataEnd) {\\n                        data := add(data, 32)\\n                        buf := add(buf, 32)\\n                    } {\\n                        // Copy 32B chunks from data to buffer.\\n                        // This may read over data array boundaries and copy\\n                        // invalid bytes, which doesn't matter in the end since\\n                        // we will later set the correct buffer length.\\n                        mstore(buf, mload(data))\\n                    }\\n\\n                    // Update buffer length\\n                    mstore(buffer_, add(mload(buffer_), length))\\n                }\\n\\n                // Append the marker definition to our buffer\\n                appendBytes(buffer, markerDefinition)\\n            }\\n        }\\n        return abi.encodePacked(\\\"%3Cdefs%3E\\\", buffer, \\\"%3C/defs%3E\\\");\\n    }\\n\\n    /**\\n     * @dev Implementation of `ISvgRenderer.render` rendering points.\\n     * The basic idea for assembling the svg is to group points with the same\\n     * color and add them to the same polyline svg element. In the end we will\\n     * therefore have 256 polyline elements. The actual coloring and marker\\n     * style will be handled by adding svg marker defs, which are referenced in\\n     * the polylines.\\n     */\\n    function render(\\n        AttractorSolution calldata solution,\\n        bytes memory colormap,\\n        uint8 markerSize\\n    ) public pure override returns (string memory svg) {\\n        require(colormap.length == 768);\\n\\n        // Allocate buffer which we will later use to build up the svg\\n        {\\n            // 34kB for the marker defs + 146B per polyline + ~12B per point\\n            uint256 bufferSize = 34000 +\\n                256 *\\n                146 +\\n                (solution.points.length / 4) *\\n                12;\\n\\n            (, bytes memory _svg) = _allocate(bufferSize);\\n\\n            // Let's use a little trick here and use the allocated bytes\\n            // buffer for strings\\n            assembly {\\n                svg := _svg\\n            }\\n        }\\n\\n        // Preparing some (repeatedly used) svg fragments.\\n        // They cannot be stored in individual variables -> stack too deep\\n        bytes[4] memory collection = [\\n            // 0x00\\n            abi.encodePacked(\\n                \\\"%3Csvg width='1024' height='1024' viewBox='-4096 -4096 8192 8192' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='-4096' y='-4096' width='100%25' height='100%25' fill='black'/%3E\\\",\\n                generateMarkersDefs(colormap, Strings.toString(markerSize))\\n            ),\\n            // 0x20\\n            bytes(\\\"%3Cpolyline points='\\\"),\\n            // 0x40\\n            bytes(\\\"\\\"),\\n            // 0x60\\n            bytes(\\\"%3C/svg%3E\\\")\\n        ];\\n\\n        // Prepare the endings for the\\n        // It may be an unnecessary overhead to prepare and store them here,\\n        // but it saves a lot of pain in the assembly.\\n        bytes[256] memory polylineEnds;\\n        for (uint256 idx = 0; idx < 256; ++idx) {\\n            string memory idxString = Strings.toString(idx);\\n            polylineEnds[idx] = abi.encodePacked(\\n                \\\"' fill='none' stroke='transparent'  marker-start='url(%23dot\\\",\\n                idxString,\\n                \\\")' marker-mid='url(%23dot\\\",\\n                idxString,\\n                \\\")'  marker-end='url(%23dot\\\",\\n                idxString,\\n                \\\")'/%3E\\\"\\n            );\\n        }\\n\\n        // A handy alias for later\\n        bytes memory points = solution.points;\\n\\n        assembly {\\n            /**\\n             * @notice Append data to a dynamic buffer.\\n             * See `DynamicBufferAllocator`.\\n             * @dev Adds `data_` at the end of the `buffer_` and increases\\n             * the length of the latter accordingly.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendBytes(buffer_, data_) {\\n                let length := mload(data_)\\n                for {\\n                    let data := add(data_, 32)\\n                    let dataEnd := add(data, length)\\n                    let buf := add(buffer_, add(mload(buffer_), 32))\\n                } lt(data, dataEnd) {\\n                    data := add(data, 32)\\n                    buf := add(buf, 32)\\n                } {\\n                    // Copy 32B chunks from data to buffer.\\n                    // This may read over data array boundaries and copy invalid\\n                    // bytes, which doesn't matter in the end since we will later\\n                    // set the correct buffer length.\\n                    mstore(buf, mload(data))\\n                }\\n\\n                // Update buffer length\\n                mstore(buffer_, add(mload(buffer_), length))\\n            }\\n\\n            /**\\n             * @notice Append a single byte to a dynamic buffer.\\n             * See `DynamicBufferAllocator`.\\n             * @dev Adds `data_` at the end of the `buffer_` and increases\\n             * the length of the latter by one.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendByte(buffer_, data) {\\n                let length := mload(buffer_)\\n                let buffer := add(buffer_, add(length, 32))\\n                mstore8(buffer, data)\\n                mstore(buffer_, add(length, 1))\\n            }\\n\\n            /**\\n             * @notice Convert an `int16` to its ASCII `byte` representation\\n             * @dev `value_` is converted and append it to `buffer_`.\\n             * See `DynamicBufferAllocator`.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendConvertedInt256(buffer_, value_) {\\n                // Init a local 32B buffer for the ascii string.\\n                // This is more than enough for the numbers we are dealing with\\n                let ascii := 0\\n\\n                // A counter for the amount of characters in ascii.\\n                let numCharacters := 0\\n\\n                // Check if `value_` is negative.\\n                let negative := slt(value_, 0)\\n\\n                // If so we need to add a minus sign later and continue with\\n                // the absolute value in the meantime.\\n                if negative {\\n                    // Compute and assign the abs value.\\n                    let tmp := sar(255, value_)\\n                    value_ := sub(xor(value_, tmp), tmp)\\n                }\\n\\n                // We treat `ascii` as byte string, meaning that we will fill it\\n                // from left to right. To build up the ascii string we start go\\n                // from the lowest to the highest decimal place.\\n                for {\\n                    let temp := value_\\n                } gt(temp, 0) {\\n                    // Divide number by 10 until nothing more is left.\\n                    temp := div(temp, 10)\\n                } {\\n                    // Read the following from the inside out.\\n\\n                    // Prepend the new digit to the string\\n                    ascii := or(\\n                        shr(8, ascii),\\n                        // Shift it all the way to the left 256-8\\n                        shl(\\n                            248,\\n                            // Digits start at ascii code 48\\n                            add(48, mod(temp, 10))\\n                        )\\n                    )\\n\\n                    numCharacters := add(numCharacters, 1)\\n                }\\n\\n                // If `value_` was zero, the previous code will do nothing.\\n                // Add zero manually in this case.\\n                if eq(numCharacters, 0) {\\n                    ascii := shl(248, 48)\\n                    numCharacters := 1\\n                }\\n\\n                // If `value_` was negative we need to prepend a minus.\\n                if negative {\\n                    ascii := or(shr(8, ascii), shl(248, 45)) // minus = ascii 45\\n                    numCharacters := add(numCharacters, 1)\\n                }\\n\\n                // Append the `ascii` string to the `buffer_`.\\n                let bufferSize := mload(buffer_)\\n                let bufferStart := add(add(buffer_, 0x20), bufferSize)\\n\\n                mstore(bufferStart, ascii)\\n\\n                // Update length of the `buffer_`.\\n                mstore(buffer_, add(bufferSize, numCharacters))\\n            }\\n\\n            /**\\n             * @notice Converts an RGB color to its HEX string\\n             * @param colormap Array of 256 8-bit RGB colors\\n             * @param idx Position of the color in the array to be converted\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendColor(buffer_, colormap_, idx_) {\\n                // Load the color from the colormap\\n                // and shift to get rid of excess bits\\n                let color := shr(\\n                    232,\\n                    mload(add(add(colormap_, 0x20), mul(3, idx_)))\\n                )\\n\\n                // We will build up the hex string from right to left.\\n                // The final string will always have length 6, we therefore\\n                // already know at which `bufferPos` we have to start.\\n                for {\\n                    let iter := 0\\n                    let bufferPos := add(\\n                        add(buffer_, 0x20),\\n                        add(mload(buffer_), 5)\\n                    )\\n                } lt(iter, 6) {\\n                    iter := add(iter, 1)\\n                    bufferPos := sub(bufferPos, 1)\\n                    color := shr(4, color)\\n                } {\\n                    // In each iteration we convert the last 4 bits of the\\n                    // `color` to ascii hex. For the next iteration, we shift\\n                    // those 4 bits out and start again.\\n\\n                    let lastDigit := and(color, 0xf)\\n\\n                    // Check if the character will be a number (or letter)\\n                    let numeric := lt(lastDigit, 0xa)\\n\\n                    // Set the according character\\n                    if not(numeric) {\\n                        mstore8(bufferPos, add(87, lastDigit))\\n                    }\\n                    if numeric {\\n                        mstore8(bufferPos, add(48, lastDigit))\\n                    }\\n                }\\n\\n                // Update the buffer length.\\n                mstore(buffer_, add(mload(buffer_), 6))\\n            }\\n\\n            // -------------------------\\n            //\\n            //  The actual work.\\n            //\\n            // -------------------------\\n\\n            // Append svg init (<svg ..) to the buffer\\n            appendBytes(svg, mload(collection))\\n\\n            // Compute the amount of points with the same color\\n            let nSameCol := div(mload(points), mul(skipBytes, 256))\\n\\n            // The outer loop iterates over colors (0-255).\\n            for {\\n                let iCol := 0\\n                let posPoint := add(points, 0x20)\\n            } lt(iCol, 256) {\\n                iCol := add(iCol, 1)\\n            } {\\n                appendBytes(svg, mload(add(collection, 0x20))) // Polyline init\\n\\n                // The inner loop iterates over points with the same color\\n                for {\\n                    let iter := 0\\n                } lt(iter, nSameCol) {\\n                    posPoint := add(posPoint, skipBytes)\\n                    iter := add(iter, 1)\\n                } {\\n                    {\\n                        // Load the point from memory.\\n                        // For this we read 256bit and shift away the ones that\\n                        // we don't need.\\n                        let tmp := mload(posPoint)\\n                        let x := sar(240, tmp)\\n                        // Invert sign on y, due to svg coordinate layout.\\n                        let y := sub(0, sar(240, shl(16, tmp)))\\n\\n                        appendConvertedInt256(svg, x)\\n                        appendByte(svg, 44) // comma\\n                        appendConvertedInt256(svg, y)\\n                    }\\n                    appendByte(svg, 32) //space\\n                }\\n\\n                // Polyline end\\n                appendBytes(svg, mload(add(polylineEnds, mul(iCol, 0x20))))\\n            }\\n\\n            // Svg end\\n            appendBytes(svg, mload(add(collection, 0x60)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/ISvgRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"../solvers/AttractorSolution.sol\\\";\\n\\n/**\\n * @notice Renders a solution of an attractor simulation as SVG\\n * @author David Huber (@cxkoda)\\n */\\ninterface ISvgRenderer {\\n    /**\\n     * @notice Renders a list of 2D points and tangents as svg\\n     * @param solution List of 16-bit fixed-point points and tangents. \\n     * See `AttractorSolution`.\\n     * @param colormap 256 8-bit RGB colors. Leaving this in memory for easier\\n     * access in assembly later.\\n     * @param markerSize A modifier for marker sizes (e.g. stroke width, \\n     * point size)\\n     * @return The generated svg string. The viewport covers the area \\n     * [-64, 64] x [-64, 64] by convention.\\n     */\\n    function render(\\n        AttractorSolution calldata solution,\\n        bytes memory colormap,\\n        uint8 markerSize\\n    ) external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/DynamicBufferAllocator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @notice Allocation of a dynamically resizable byte container.\\n * @author David Huber (@cxkoda)\\n */\\ncontract DynamicBufferAllocator {\\n    /**\\n     * @notice Allocates a byte buffer container with a given max capacity.\\n     * @dev In solidity, the first 32B in dynamic arrays are always reserved\\n     * @dev for the length of the array. This tells consumers for how long they\\n     * @dev have to read the memory. \\n     * @dev Here we allocate a container that contains the memory layout of \\n     * @dev another dynamic array (buffer), whose length we will continuously\\n     * @dev increase as we append data to it.\\n     * @dev This has the advantage that solidity can directly interpret the data\\n     * @dev from the buffer position in memory as a standard array.\\n     * @dev | container length (32B) | buffer length = s (32B) | buffer data (s B) | ... |\\n     */\\n    function _allocate(uint256 capacity)\\n        internal\\n        pure\\n        returns (bytes memory container, bytes memory buffer)\\n    {\\n        assembly {\\n            // Get next-free memory address\\n            container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                let size := add(capacity, 0x40)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/solvers/AttractorSolution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @notice The data struct that will be passed from the solver to the renderer.\\n * @dev `points` and `tangents` both contain pairs of 16-bit fixed-point numbers\\n * with a PRECISION of 6 in row-major order.`dt` is given in the fixed-point\\n * respresentation used by the solvers and corresponds to the time step between \\n * the datapoints.\\n */\\nstruct AttractorSolution {\\n    bytes points;\\n    bytes tangents;\\n    uint256 dt;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"points\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"tangents\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"dt\",\"type\":\"uint256\"}],\"internalType\":\"struct AttractorSolution\",\"name\":\"solution\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"colormap\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"markerSize\",\"type\":\"uint8\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"PointRenderer","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}