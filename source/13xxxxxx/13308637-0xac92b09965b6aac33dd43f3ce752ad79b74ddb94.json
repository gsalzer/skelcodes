{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/nahmii/NVM/chain/NVM_MessageQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// @unsupported: ovm\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_NVMCodec } from \\\"../../libraries/codec/Lib_NVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_MerkleTree } from \\\"../../libraries/utils/Lib_MerkleTree.sol\\\";\\n\\n/* Interface Imports */\\nimport { iNVM_MessageQueue } from \\\"../../iNVM/chain/iNVM_MessageQueue.sol\\\";\\nimport { iNVM_ChainStorageContainer } from \\\"../../iNVM/chain/iNVM_ChainStorageContainer.sol\\\";\\n\\n/* Contract Imports */\\nimport { NVM_ExecutionManager } from \\\"../execution/NVM_ExecutionManager.sol\\\";\\n\\n/* External Imports */\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\n/**\\n * @title NVM_MessageQueue\\n * @dev TODO\\n *\\n * Compiler used: solc\\n * Runtime target: EVM\\n */\\ncontract NVM_MessageQueue is iNVM_MessageQueue, Lib_AddressResolver {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // L2 tx gas-related\\n    uint256 constant public MIN_ROLLUP_TX_GAS = 100000;\\n    uint256 constant public MAX_ROLLUP_TX_SIZE = 50000;\\n    uint256 constant public L2_GAS_DISCOUNT_DIVISOR = 32;\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    uint256 public forceInclusionPeriodSeconds;\\n    uint256 public forceInclusionPeriodBlocks;\\n    uint256 public maxTransactionGasLimit;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(\\n        address _libAddressManager,\\n        uint256 _maxTransactionGasLimit\\n    )\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        maxTransactionGasLimit = _maxTransactionGasLimit;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue()\\n        override\\n        public\\n        view\\n        returns (\\n            iNVM_ChainStorageContainer\\n        )\\n    {\\n        return iNVM_ChainStorageContainer(\\n            resolve(\\\"NVM_ChainStorageContainer-message-queue\\\")\\n        );\\n    }\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(\\n        uint256 _index\\n    )\\n        override\\n        public\\n        view\\n        returns (\\n            Lib_NVMCodec.QueueElement memory _element\\n        )\\n    {\\n        return _getQueueElement(\\n            _index,\\n            queue()\\n        );\\n    }\\n\\n   /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength()\\n        override\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        return _getQueueLength(\\n            queue()\\n        );\\n    }\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target L2 contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        override\\n        public\\n    {\\n        require(\\n            _data.length <= MAX_ROLLUP_TX_SIZE,\\n            \\\"Transaction data size exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(\\n            _gasLimit <= maxTransactionGasLimit,\\n            \\\"Transaction gas limit exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(\\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\\n            \\\"Transaction gas limit too low to enqueue.\\\"\\n        );\\n\\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\\n        // provided L1 gas.\\n        uint256 gasToConsume = _gasLimit/L2_GAS_DISCOUNT_DIVISOR;\\n        uint256 startingGas = gasleft();\\n\\n        // Although this check is not necessary (burn below will run out of gas if not true), it\\n        // gives the user an explicit reason as to why the enqueue attempt failed.\\n        require(\\n            startingGas > gasToConsume,\\n            \\\"Insufficient gas for L2 rate limiting burn.\\\"\\n        );\\n\\n        // Here we do some \\\"dumb\\\" work in order to burn gas, although we should probably replace\\n        // this with something like minting gas token later on.\\n        uint256 i;\\n        while(startingGas - gasleft() < gasToConsume) {\\n            i++;\\n        }\\n\\n        bytes32 transactionHash = keccak256(\\n            abi.encode(\\n                msg.sender,\\n                _target,\\n                _gasLimit,\\n                _data\\n            )\\n        );\\n\\n        bytes32 timestampAndBlockNumber;\\n        assembly {\\n            timestampAndBlockNumber := timestamp()\\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\\n        }\\n\\n        iNVM_ChainStorageContainer queueRef = queue();\\n\\n        queueRef.push(transactionHash);\\n        queueRef.push(timestampAndBlockNumber);\\n\\n        // The underlying queue data structure stores 2 elements\\n        // per insertion, so to get the real queue length we need\\n        // to divide by 2 and subtract 1.\\n        uint256 queueIndex = queueRef.length() / 2 - 1;\\n        emit TransactionEnqueued(\\n            msg.sender,\\n            _target,\\n            _gasLimit,\\n            _data,\\n            queueIndex,\\n            block.timestamp\\n        );\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function _getQueueElement(\\n        uint256 _index,\\n        iNVM_ChainStorageContainer _queueRef\\n    )\\n        internal\\n        view\\n        returns (\\n            Lib_NVMCodec.QueueElement memory _element\\n        )\\n    {\\n        // The underlying queue data structure stores 2 elements\\n        // per insertion, so to get the actual desired queue index\\n        // we need to multiply by 2.\\n        uint40 trueIndex = uint40(_index * 2);\\n        bytes32 transactionHash = _queueRef.get(trueIndex);\\n        bytes32 timestampAndBlockNumber = _queueRef.get(trueIndex + 1);\\n\\n        uint40 elementTimestamp;\\n        uint40 elementBlockNumber;\\n        // solhint-disable max-line-length\\n        assembly {\\n            elementTimestamp   :=         and(timestampAndBlockNumber, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\\n            elementBlockNumber := shr(40, and(timestampAndBlockNumber, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))\\n        }\\n        // solhint-enable max-line-length\\n\\n        return Lib_NVMCodec.QueueElement({\\n            transactionHash: transactionHash,\\n            timestamp: elementTimestamp,\\n            blockNumber: elementBlockNumber\\n        });\\n    }\\n\\n    /**\\n     * Retrieves the length of the queue.\\n     * @return Length of the queue.\\n     */\\n    function _getQueueLength(\\n        iNVM_ChainStorageContainer _queueRef\\n    )\\n        internal\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        // The underlying queue data structure stores 2 elements\\n        // per insertion, so to get the real queue length we need\\n        // to divide by 2.\\n        return uint40(_queueRef.length() / 2);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/codec/Lib_NVMCodec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_NVMCodec\\n */\\nlibrary Lib_NVMCodec {\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Account {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n        address ethAddress;\\n        bool isFresh;\\n    }\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct Receipt {\\n        uint256 index;\\n        bytes32 stateRoot;\\n        bytes32 nvmTransactionHash;\\n        bytes operatorSignature;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex;  // QUEUED TX ONLY\\n        uint256 timestamp;   // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData;        // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return abi.encodePacked(\\n            _transaction.timestamp,\\n            _transaction.blockNumber,\\n            _transaction.l1QueueOrigin,\\n            _transaction.l1TxOrigin,\\n            _transaction.entrypoint,\\n            _transaction.gasLimit,\\n            _transaction.data\\n        );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * Converts an OVM account to an EVM account.\\n     * @param _in OVM account to convert.\\n     * @return Converted EVM account.\\n     */\\n    function toEVMAccount(\\n        Account memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory\\n        )\\n    {\\n        return EVMAccount({\\n            nonce: _in.nonce,\\n            balance: _in.balance,\\n            storageRoot: _in.storageRoot,\\n            codeHash: _in.codeHash\\n        });\\n    }\\n\\n    /**\\n     * @notice RLP-encodes an account state struct.\\n     * @param _account Account state struct.\\n     * @return RLP-encoded account state.\\n     */\\n    function encodeEVMAccount(\\n        EVMAccount memory _account\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](4);\\n\\n        // Unfortunately we can't create this array outright because\\n        // Lib_RLPWriter.writeList will reject fixed-size arrays. Assigning\\n        // index-by-index circumvents this issue.\\n        raw[0] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.nonce)\\n            )\\n        );\\n        raw[1] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.balance)\\n            )\\n        );\\n        raw[2] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.storageRoot));\\n        raw[3] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.codeHash));\\n\\n        return Lib_RLPWriter.writeList(raw);\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(\\n        bytes memory _encoded\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return EVMAccount({\\n            nonce: Lib_RLPReader.readUint256(accountState[0]),\\n            balance: Lib_RLPReader.readUint256(accountState[1]),\\n            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n            codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n        });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(\\n        Lib_NVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(\\n            abi.encode(\\n                _batchHeader.batchRoot,\\n                _batchHeader.batchSize,\\n                _batchHeader.prevTotalElements,\\n                _batchHeader.extraData\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/resolver/Lib_AddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    ) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/utils/Lib_MerkleTree.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_MerkleTree\\n * @author River Keefer\\n */\\nlibrary Lib_MerkleTree {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\\n     * If you do not know the original length of elements for the tree you are verifying, then\\n     * this may allow empty leaves past _elements.length to pass a verification check down the line.\\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\\n     * @param _elements Array of hashes from which to generate a merkle root.\\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\\n     */\\n    function getMerkleRoot(\\n        bytes32[] memory _elements\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _elements.length > 0,\\n            \\\"Lib_MerkleTree: Must provide at least one leaf hash.\\\"\\n        );\\n\\n        if (_elements.length == 1) {\\n            return _elements[0];\\n        }\\n\\n        uint256[16] memory defaults = [\\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\\n        ];\\n\\n        // Reserve memory space for our hashes.\\n        bytes memory buf = new bytes(64);\\n\\n        // We'll need to keep track of left and right siblings.\\n        bytes32 leftSibling;\\n        bytes32 rightSibling;\\n\\n        // Number of non-empty nodes at the current depth.\\n        uint256 rowSize = _elements.length;\\n\\n        // Current depth, counting from 0 at the leaves\\n        uint256 depth = 0;\\n\\n        // Common sub-expressions\\n        uint256 halfRowSize;         // rowSize / 2\\n        bool rowSizeIsOdd;           // rowSize % 2 == 1\\n\\n        while (rowSize > 1) {\\n            halfRowSize = rowSize / 2;\\n            rowSizeIsOdd = rowSize % 2 == 1;\\n\\n            for (uint256 i = 0; i < halfRowSize; i++) {\\n                leftSibling  = _elements[(2 * i)    ];\\n                rightSibling = _elements[(2 * i) + 1];\\n                assembly {\\n                    mstore(add(buf, 32), leftSibling )\\n                    mstore(add(buf, 64), rightSibling)\\n                }\\n\\n                _elements[i] = keccak256(buf);\\n            }\\n\\n            if (rowSizeIsOdd) {\\n                leftSibling  = _elements[rowSize - 1];\\n                rightSibling = bytes32(defaults[depth]);\\n                assembly {\\n                    mstore(add(buf, 32), leftSibling)\\n                    mstore(add(buf, 64), rightSibling)\\n                }\\n\\n                _elements[halfRowSize] = keccak256(buf);\\n            }\\n\\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\\n            depth++;\\n        }\\n\\n        return _elements[0];\\n    }\\n\\n    /**\\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\\n     * of leaves generated is a known, correct input, and does not return true for indices\\n     * extending past that index (even if _siblings would be otherwise valid.)\\n     * @param _root The Merkle root to verify against.\\n     * @param _leaf The leaf hash to verify inclusion of.\\n     * @param _index The index in the tree of this leaf.\\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0\\n     * (bottom of the tree).\\n     * @param _totalLeaves The total number of leaves originally passed into.\\n     * @return Whether or not the merkle branch and leaf passes verification.\\n     */\\n    function verify(\\n        bytes32 _root,\\n        bytes32 _leaf,\\n        uint256 _index,\\n        bytes32[] memory _siblings,\\n        uint256 _totalLeaves\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _totalLeaves > 0,\\n            \\\"Lib_MerkleTree: Total leaves must be greater than zero.\\\"\\n        );\\n\\n        require(\\n            _index < _totalLeaves,\\n            \\\"Lib_MerkleTree: Index out of bounds.\\\"\\n        );\\n\\n        require(\\n            _siblings.length == _ceilLog2(_totalLeaves),\\n            \\\"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\\\"\\n        );\\n\\n        bytes32 computedRoot = _leaf;\\n\\n        for (uint256 i = 0; i < _siblings.length; i++) {\\n            if ((_index & 1) == 1) {\\n                computedRoot = keccak256(\\n                    abi.encodePacked(\\n                        _siblings[i],\\n                        computedRoot\\n                    )\\n                );\\n            } else {\\n                computedRoot = keccak256(\\n                    abi.encodePacked(\\n                        computedRoot,\\n                        _siblings[i]\\n                    )\\n                );\\n            }\\n\\n            _index >>= 1;\\n        }\\n\\n        return _root == computedRoot;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Calculates the integer ceiling of the log base 2 of an input.\\n     * @param _in Unsigned input to calculate the log.\\n     * @return ceil(log_base_2(_in))\\n     */\\n    function _ceilLog2(\\n        uint256 _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        require(\\n            _in > 0,\\n            \\\"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\\\"\\n        );\\n\\n        if (_in == 1) {\\n            return 0;\\n        }\\n\\n        // Find the highest set bit (will be floor(log_2)).\\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\\n        uint256 val = _in;\\n        uint256 highest = 0;\\n        for (uint256 i = 128; i >= 1; i >>= 1) {\\n            if (val & (uint(1) << i) - 1 << i != 0) {\\n                highest += i;\\n                val >>= i;\\n            }\\n        }\\n\\n        // Increment by one if this is not a perfect logarithm.\\n        if ((uint(1) << highest) != _in) {\\n            highest += 1;\\n        }\\n\\n        return highest;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/iNVM/chain/iNVM_MessageQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_NVMCodec } from \\\"../../libraries/codec/Lib_NVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { iNVM_ChainStorageContainer } from \\\"./iNVM_ChainStorageContainer.sol\\\";\\n\\n/**\\n * @title iNVM_MessageQueue\\n */\\ninterface iNVM_MessageQueue {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event TransactionEnqueued(\\n        address _l1TxOrigin,\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes _data,\\n        uint256 _queueIndex,\\n        uint256 _timestamp\\n    );\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue()\\n        external\\n        view\\n        returns (\\n            iNVM_ChainStorageContainer\\n        );\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            Lib_NVMCodec.QueueElement memory _element\\n        );\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/iNVM/chain/iNVM_ChainStorageContainer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iNVM_ChainStorageContainer\\n */\\ninterface iNVM_ChainStorageContainer {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata()\\n        external\\n        view\\n        returns (\\n            bytes27\\n        );\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length()\\n        external\\n        view\\n        returns (\\n            uint256\\n        );\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(\\n        bytes32 _object\\n    )\\n        external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32\\n        );\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index\\n    )\\n        external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/NVM/execution/NVM_ExecutionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// @unsupported: ovm\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_NVMCodec } from \\\"../../libraries/codec/Lib_NVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../../libraries/utils/Lib_Bytes32Utils.sol\\\";\\nimport { Lib_EthUtils } from \\\"../../libraries/utils/Lib_EthUtils.sol\\\";\\nimport { Lib_ErrorUtils } from \\\"../../libraries/utils/Lib_ErrorUtils.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\n\\n/* Interface Imports */\\nimport { iNVM_ExecutionManager } from \\\"../../iNVM/execution/iNVM_ExecutionManager.sol\\\";\\nimport { iNVM_StateManager } from \\\"../../iNVM/execution/iNVM_StateManager.sol\\\";\\nimport { iNVM_SafetyChecker } from \\\"../../iNVM/execution/iNVM_SafetyChecker.sol\\\";\\n\\n/* Contract Imports */\\nimport { NVM_DeployerWhitelist } from \\\"../predeploys/NVM_DeployerWhitelist.sol\\\";\\n\\n/* External Imports */\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\n/**\\n * @title NVM_ExecutionManager\\n * @dev The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed\\n * environment allowing us to execute OVM transactions deterministically on either Layer 1 or\\n * Layer 2.\\n * The EM's run() function is the first function called during the execution of any\\n * transaction on L2.\\n * For each context-dependent EVM operation the EM has a function which implements a corresponding\\n * OVM operation, which will read state from the State Manager contract.\\n * The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any\\n * context-dependent operations.\\n *\\n * Compiler used: solc\\n * Runtime target: EVM\\n */\\ncontract NVM_ExecutionManager is iNVM_ExecutionManager, Lib_AddressResolver {\\n\\n    /********************************\\n     * External Contract References *\\n     ********************************/\\n\\n    iNVM_SafetyChecker internal nvmSafetyChecker;\\n    iNVM_StateManager internal nvmStateManager;\\n\\n\\n    /*******************************\\n     * Execution Context Variables *\\n     *******************************/\\n\\n    GasMeterConfig internal gasMeterConfig;\\n    GlobalContext internal globalContext;\\n    TransactionContext internal transactionContext;\\n    MessageContext internal messageContext;\\n    TransactionRecord internal transactionRecord;\\n    MessageRecord internal messageRecord;\\n\\n\\n    /**************************\\n     * Gas Metering Constants *\\n     **************************/\\n\\n    address constant GAS_METADATA_ADDRESS = 0x06a506A506a506A506a506a506A506A506A506A5;\\n    uint256 constant NUISANCE_GAS_SLOAD = 20000;\\n    uint256 constant NUISANCE_GAS_SSTORE = 20000;\\n    uint256 constant MIN_NUISANCE_GAS_PER_CONTRACT = 30000;\\n    uint256 constant NUISANCE_GAS_PER_CONTRACT_BYTE = 100;\\n    uint256 constant MIN_GAS_FOR_INVALID_STATE_ACCESS = 30000;\\n\\n\\n    /**************************\\n     * Native Value Constants *\\n     **************************/\\n\\n    // Public so we can access and make assertions in integration tests.\\n    uint256 public constant CALL_WITH_VALUE_INTRINSIC_GAS = 90000;\\n\\n\\n    /**************************\\n     * Default Context Values *\\n     **************************/\\n\\n    uint256 constant DEFAULT_UINT256 =\\n        0xdefa017defa017defa017defa017defa017defa017defa017defa017defa017d;\\n    address constant DEFAULT_ADDRESS = 0xdEfa017defA017DeFA017DEfa017DeFA017DeFa0;\\n\\n\\n    /*************************************\\n     * Container Contract Address Prefix *\\n     *************************************/\\n\\n    /**\\n     * @dev The Execution Manager and State Manager each have this 30 byte prefix,\\n     * and are uncallable.\\n     */\\n    address constant CONTAINER_CONTRACT_PREFIX = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    constructor(\\n        address _libAddressManager,\\n        GasMeterConfig memory _gasMeterConfig,\\n        GlobalContext memory _globalContext\\n    )\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        nvmSafetyChecker = iNVM_SafetyChecker(resolve(\\\"NVM_SafetyChecker\\\"));\\n        gasMeterConfig = _gasMeterConfig;\\n        globalContext = _globalContext;\\n        _resetContext();\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Applies dynamically-sized refund to a transaction to account for the difference in execution\\n     * between L1 and L2, so that the overall cost of the ovmOPCODE is fixed.\\n     * @param _cost Desired gas cost for the function after the refund.\\n     */\\n    modifier netGasCost(\\n        uint256 _cost\\n    ) {\\n        uint256 gasProvided = gasleft();\\n        _;\\n        uint256 gasUsed = gasProvided - gasleft();\\n\\n        // We want to refund everything *except* the specified cost.\\n        if (_cost < gasUsed) {\\n            transactionRecord.ovmGasRefund += gasUsed - _cost;\\n        }\\n    }\\n\\n    /**\\n     * Applies a fixed-size gas refund to a transaction to account for the difference in execution\\n     * between L1 and L2, so that the overall cost of an ovmOPCODE can be lowered.\\n     * @param _discount Amount of gas cost to refund for the ovmOPCODE.\\n     */\\n    modifier fixedGasDiscount(\\n        uint256 _discount\\n    ) {\\n        uint256 gasProvided = gasleft();\\n        _;\\n        uint256 gasUsed = gasProvided - gasleft();\\n\\n        // We want to refund the specified _discount, unless this risks underflow.\\n        if (_discount < gasUsed) {\\n            transactionRecord.ovmGasRefund += _discount;\\n        } else {\\n            // refund all we can without risking underflow.\\n            transactionRecord.ovmGasRefund += gasUsed;\\n        }\\n    }\\n\\n    /**\\n     * Makes sure we're not inside a static context.\\n     */\\n    modifier notStatic() {\\n        if (messageContext.isStatic == true) {\\n            _revertWithFlag(RevertFlag.STATIC_VIOLATION);\\n        }\\n        _;\\n    }\\n\\n\\n    /************************************\\n     * Transaction Execution Entrypoint *\\n     ************************************/\\n\\n    /**\\n     * Starts the execution of a transaction via the NVM_ExecutionManager.\\n     * @param _transaction Transaction data to be executed.\\n     * @param _nvmStateManager iNVM_StateManager implementation providing account state.\\n     */\\n    function run(\\n        Lib_NVMCodec.Transaction memory _transaction,\\n        address _nvmStateManager\\n    )\\n        override\\n        external\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        // Make sure that run() is not re-enterable.  This condition should always be satisfied\\n        // Once run has been called once, due to the behavior of _isValidInput().\\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        // Store our NVM_StateManager instance (significantly easier than attempting to pass the\\n        // address around in calldata).\\n        nvmStateManager = iNVM_StateManager(_nvmStateManager);\\n\\n        // Make sure this function can't be called by anyone except the owner of the\\n        // NVM_StateManager (expected to be an NVM_StateTransitioner). We can revert here because\\n        // this would make the `run` itself invalid.\\n        require(\\n            // This method may return false during fraud proofs, but always returns true in\\n            // L2 nodes' State Manager precompile.\\n            nvmStateManager.isAuthenticated(msg.sender),\\n            \\\"Only authenticated addresses in nvmStateManager can call this function\\\"\\n        );\\n\\n        // Initialize the execution context, must be initialized before we perform any gas metering\\n        // or we'll throw a nuisance gas error.\\n        _initContext(_transaction);\\n\\n        // TEMPORARY: Gas metering is disabled for minnet.\\n        // // Check whether we need to start a new epoch, do so if necessary.\\n        // _checkNeedsNewEpoch(_transaction.timestamp);\\n\\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\\n        // reverts for INVALID_STATE_ACCESS.\\n        if (_isValidInput(_transaction) == false) {\\n            _resetContext();\\n            return bytes(\\\"\\\");\\n        }\\n\\n        // TEMPORARY: Gas metering is disabled for minnet.\\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\\n        // uint256 gasProvided = gasleft();\\n\\n        // Run the transaction, make sure to meter the gas usage.\\n        (, bytes memory returndata) = ovmCALL(\\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\\n            _transaction.entrypoint,\\n            0,\\n            _transaction.data\\n        );\\n\\n        // TEMPORARY: Gas metering is disabled for minnet.\\n        // // Update the cumulative gas based on the amount of gas used.\\n        // uint256 gasUsed = gasProvided - gasleft();\\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\\n\\n        // Wipe the execution context.\\n        _resetContext();\\n\\n        return returndata;\\n    }\\n\\n\\n    /******************************\\n     * Opcodes: Execution Context *\\n     ******************************/\\n\\n    /**\\n     * @notice Overrides CALLER.\\n     * @return _CALLER Address of the CALLER within the current message context.\\n     */\\n    function ovmCALLER()\\n        override\\n        external\\n        view\\n        returns (\\n            address _CALLER\\n        )\\n    {\\n        return messageContext.ovmCALLER;\\n    }\\n\\n    /**\\n     * @notice Overrides ADDRESS.\\n     * @return _ADDRESS Active ADDRESS within the current message context.\\n     */\\n    function ovmADDRESS()\\n        override\\n        public\\n        view\\n        returns (\\n            address _ADDRESS\\n        )\\n    {\\n        return messageContext.ovmADDRESS;\\n    }\\n\\n    /**\\n     * @notice Overrides CALLVALUE.\\n     * @return _CALLVALUE Value sent along with the call according to the current message context.\\n     */\\n    function ovmCALLVALUE()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _CALLVALUE\\n        )\\n    {\\n        return messageContext.ovmCALLVALUE;\\n    }\\n\\n    /**\\n     * @notice Overrides TIMESTAMP.\\n     * @return _TIMESTAMP Value of the TIMESTAMP within the transaction context.\\n     */\\n    function ovmTIMESTAMP()\\n        override\\n        external\\n        view\\n        returns (\\n            uint256 _TIMESTAMP\\n        )\\n    {\\n        return transactionContext.ovmTIMESTAMP;\\n    }\\n\\n    /**\\n     * @notice Overrides NUMBER.\\n     * @return _NUMBER Value of the NUMBER within the transaction context.\\n     */\\n    function ovmNUMBER()\\n        override\\n        external\\n        view\\n        returns (\\n            uint256 _NUMBER\\n        )\\n    {\\n        return transactionContext.ovmNUMBER;\\n    }\\n\\n    /**\\n     * @notice Overrides GASLIMIT.\\n     * @return _GASLIMIT Value of the block's GASLIMIT within the transaction context.\\n     */\\n    function ovmGASLIMIT()\\n        override\\n        external\\n        view\\n        returns (\\n            uint256 _GASLIMIT\\n        )\\n    {\\n        return transactionContext.ovmGASLIMIT;\\n    }\\n\\n    /**\\n     * @notice Overrides CHAINID.\\n     * @return _CHAINID Value of the chain's CHAINID within the global context.\\n     */\\n    function ovmCHAINID()\\n        override\\n        external\\n        view\\n        returns (\\n            uint256 _CHAINID\\n        )\\n    {\\n        return globalContext.ovmCHAINID;\\n    }\\n\\n    /*********************************\\n     * Opcodes: L2 Execution Context *\\n     *********************************/\\n\\n    /**\\n     * @notice Specifies from which source (Sequencer or Queue) this transaction originated from.\\n     * @return _queueOrigin Enum indicating the ovmL1QUEUEORIGIN within the current message context.\\n     */\\n    function ovmL1QUEUEORIGIN()\\n        override\\n        external\\n        view\\n        returns (\\n            Lib_NVMCodec.QueueOrigin _queueOrigin\\n        )\\n    {\\n        return transactionContext.ovmL1QUEUEORIGIN;\\n    }\\n\\n    /**\\n     * @notice Specifies which L1 account, if any, sent this transaction by calling enqueue().\\n     * @return _l1TxOrigin Address of the account which sent the tx into L2 from L1.\\n     */\\n    function ovmL1TXORIGIN()\\n        override\\n        external\\n        view\\n        returns (\\n            address _l1TxOrigin\\n        )\\n    {\\n        return transactionContext.ovmL1TXORIGIN;\\n    }\\n\\n    /********************\\n     * Opcodes: Halting *\\n     ********************/\\n\\n    /**\\n     * @notice Overrides REVERT.\\n     * @param _data Bytes data to pass along with the REVERT.\\n     */\\n    function ovmREVERT(\\n        bytes memory _data\\n    )\\n        override\\n        public\\n    {\\n        _revertWithFlag(RevertFlag.INTENTIONAL_REVERT, _data);\\n    }\\n\\n\\n    /******************************\\n     * Opcodes: Contract Creation *\\n     ******************************/\\n\\n    /**\\n     * @notice Overrides CREATE.\\n     * @param _bytecode Code to be used to CREATE a new contract.\\n     * @return Address of the created contract.\\n     * @return Revert data, if and only if the creation threw an exception.\\n     */\\n    function ovmCREATE(\\n        bytes memory _bytecode\\n    )\\n        override\\n        public\\n        notStatic\\n        fixedGasDiscount(40000)\\n        returns (\\n            address,\\n            bytes memory\\n        )\\n    {\\n        // Creator is always the current ADDRESS.\\n        address creator = ovmADDRESS();\\n\\n        // Check that the deployer is whitelisted, or\\n        // that arbitrary contract deployment has been enabled.\\n        _checkDeployerAllowed(creator);\\n\\n        // Generate the correct CREATE address.\\n        address contractAddress = Lib_EthUtils.getAddressForCREATE(\\n            creator,\\n            _getAccountNonce(creator)\\n        );\\n\\n        return _createContract(\\n            contractAddress,\\n            _bytecode,\\n            MessageType.ovmCREATE\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides CREATE2.\\n     * @param _bytecode Code to be used to CREATE2 a new contract.\\n     * @param _salt Value used to determine the contract's address.\\n     * @return Address of the created contract.\\n     * @return Revert data, if and only if the creation threw an exception.\\n     */\\n    function ovmCREATE2(\\n        bytes memory _bytecode,\\n        bytes32 _salt\\n    )\\n        override\\n        external\\n        notStatic\\n        fixedGasDiscount(40000)\\n        returns (\\n            address,\\n            bytes memory\\n        )\\n    {\\n        // Creator is always the current ADDRESS.\\n        address creator = ovmADDRESS();\\n\\n        // Check that the deployer is whitelisted, or\\n        // that arbitrary contract deployment has been enabled.\\n        _checkDeployerAllowed(creator);\\n\\n        // Generate the correct CREATE2 address.\\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\\n            creator,\\n            _bytecode,\\n            _salt\\n        );\\n\\n        return _createContract(\\n            contractAddress,\\n            _bytecode,\\n            MessageType.ovmCREATE2\\n        );\\n    }\\n\\n\\n    /*******************************\\n     * Account Abstraction Opcodes *\\n     ******************************/\\n\\n    /**\\n     * Retrieves the nonce of the current ovmADDRESS.\\n     * @return _nonce Nonce of the current contract.\\n     */\\n    function ovmGETNONCE()\\n        override\\n        external\\n        returns (\\n            uint256 _nonce\\n        )\\n    {\\n        return _getAccountNonce(ovmADDRESS());\\n    }\\n\\n    /**\\n     * Bumps the nonce of the current ovmADDRESS by one.\\n     */\\n    function ovmINCREMENTNONCE()\\n        override\\n        external\\n        notStatic\\n    {\\n        address account = ovmADDRESS();\\n        uint256 nonce = _getAccountNonce(account);\\n\\n        // Prevent overflow.\\n        if (nonce + 1 > nonce) {\\n            _setAccountNonce(account, nonce + 1);\\n        }\\n    }\\n\\n    /**\\n     * Creates a new EOA contract account, for account abstraction.\\n     * @dev Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks\\n     *      because the contract we're creating is trusted (no need to do safety checking or to\\n     *      handle unexpected reverts). Doesn't need to return an address because the address is\\n     *      assumed to be the user's actual address.\\n     * @param _messageHash Hash of a message signed by some user, for verification.\\n     * @param _v Signature `v` parameter.\\n     * @param _r Signature `r` parameter.\\n     * @param _s Signature `s` parameter.\\n     */\\n    function ovmCREATEEOA(\\n        bytes32 _messageHash,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        override\\n        public\\n        notStatic\\n    {\\n        // Recover the EOA address from the message hash and signature parameters. Since we do the\\n        // hashing in advance, we don't have handle different message hashing schemes. Even if this\\n        // function were to return the wrong address (rather than explicitly returning the zero\\n        // address), the rest of the transaction would simply fail (since there's no EOA account to\\n        // actually execute the transaction).\\n        address eoa = ecrecover(\\n            _messageHash,\\n            _v + 27,\\n            _r,\\n            _s\\n        );\\n\\n        // Invalid signature is a case we proactively handle with a revert. We could alternatively\\n        // have this function return a `success` boolean, but this is just easier.\\n        if (eoa == address(0)) {\\n            ovmREVERT(bytes(\\\"Signature provided for EOA contract creation is invalid.\\\"));\\n        }\\n\\n        // If the user already has an EOA account, then there's no need to perform this operation.\\n        if (_hasEmptyAccount(eoa) == false) {\\n            return;\\n        }\\n\\n        // We always need to initialize the contract with the default account values.\\n        _initPendingAccount(eoa);\\n\\n        // Temporarily set the current address so it's easier to access on L2.\\n        address prevADDRESS = messageContext.ovmADDRESS;\\n        messageContext.ovmADDRESS = eoa;\\n\\n        // Creates a duplicate of the NVM_ProxyEOA located at 0x42....09. Uses the following\\n        // \\\"magic\\\" prefix to deploy an exact copy of the code:\\n        // PUSH1 0x0D   # size of this prefix in bytes\\n        // CODESIZE\\n        // SUB          # subtract prefix size from codesize\\n        // DUP1\\n        // PUSH1 0x0D\\n        // PUSH1 0x00\\n        // CODECOPY     # copy everything after prefix into memory at pos 0\\n        // PUSH1 0x00\\n        // RETURN       # return the copied code\\n        address proxyEOA = Lib_EthUtils.createContract(abi.encodePacked(\\n            hex\\\"600D380380600D6000396000f3\\\",\\n            ovmEXTCODECOPY(\\n                Lib_PredeployAddresses.PROXY_EOA,\\n                0,\\n                ovmEXTCODESIZE(Lib_PredeployAddresses.PROXY_EOA)\\n            )\\n        ));\\n\\n        // Reset the address now that we're done deploying.\\n        messageContext.ovmADDRESS = prevADDRESS;\\n\\n        // Commit the account with its final values.\\n        _commitPendingAccount(\\n            eoa,\\n            address(proxyEOA),\\n            keccak256(Lib_EthUtils.getCode(address(proxyEOA)))\\n        );\\n\\n        _setAccountNonce(eoa, 0);\\n    }\\n\\n\\n    /*********************************\\n     * Opcodes: Contract Interaction *\\n     *********************************/\\n\\n    /**\\n     * @notice Overrides CALL.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _address Address of the contract to call.\\n     * @param _value ETH value to pass with the call.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function ovmCALL(\\n        uint256 _gasLimit,\\n        address _address,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        override\\n        public\\n        fixedGasDiscount(100000)\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // CALL updates the CALLER and ADDRESS.\\n        MessageContext memory nextMessageContext = messageContext;\\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\\n        nextMessageContext.ovmADDRESS = _address;\\n        nextMessageContext.ovmCALLVALUE = _value;\\n\\n        return _callContract(\\n            nextMessageContext,\\n            _gasLimit,\\n            _address,\\n            _calldata,\\n            MessageType.ovmCALL\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides STATICCALL.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _address Address of the contract to call.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function ovmSTATICCALL(\\n        uint256 _gasLimit,\\n        address _address,\\n        bytes memory _calldata\\n    )\\n        override\\n        public\\n        fixedGasDiscount(80000)\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // STATICCALL updates the CALLER, updates the ADDRESS, and runs in a static,\\n        // valueless context.\\n        MessageContext memory nextMessageContext = messageContext;\\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\\n        nextMessageContext.ovmADDRESS = _address;\\n        nextMessageContext.isStatic = true;\\n        nextMessageContext.ovmCALLVALUE = 0;\\n\\n        return _callContract(\\n            nextMessageContext,\\n            _gasLimit,\\n            _address,\\n            _calldata,\\n            MessageType.ovmSTATICCALL\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides DELEGATECALL.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _address Address of the contract to call.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function ovmDELEGATECALL(\\n        uint256 _gasLimit,\\n        address _address,\\n        bytes memory _calldata\\n    )\\n        override\\n        public\\n        fixedGasDiscount(40000)\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // DELEGATECALL does not change anything about the message context.\\n        MessageContext memory nextMessageContext = messageContext;\\n\\n        return _callContract(\\n            nextMessageContext,\\n            _gasLimit,\\n            _address,\\n            _calldata,\\n            MessageType.ovmDELEGATECALL\\n        );\\n    }\\n\\n    /**\\n     * @notice Legacy ovmCALL function which did not support ETH value; this maintains backwards\\n     * compatibility.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _address Address of the contract to call.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function ovmCALL(\\n        uint256 _gasLimit,\\n        address _address,\\n        bytes memory _calldata\\n    )\\n        override\\n        public\\n        returns(\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // Legacy ovmCALL assumed always-0 value.\\n        return ovmCALL(\\n            _gasLimit,\\n            _address,\\n            0,\\n            _calldata\\n        );\\n    }\\n\\n\\n    /************************************\\n     * Opcodes: Contract Storage Access *\\n     ************************************/\\n\\n    /**\\n     * @notice Overrides SLOAD.\\n     * @param _key 32 byte key of the storage slot to load.\\n     * @return _value 32 byte value of the requested storage slot.\\n     */\\n    function ovmSLOAD(\\n        bytes32 _key\\n    )\\n        override\\n        external\\n        netGasCost(40000)\\n        returns (\\n            bytes32 _value\\n        )\\n    {\\n        // We always SLOAD from the storage of ADDRESS.\\n        address contractAddress = ovmADDRESS();\\n\\n        return _getContractStorage(\\n            contractAddress,\\n            _key\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides SSTORE.\\n     * @param _key 32 byte key of the storage slot to set.\\n     * @param _value 32 byte value for the storage slot.\\n     */\\n    function ovmSSTORE(\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        override\\n        external\\n        notStatic\\n        netGasCost(60000)\\n    {\\n        // We always SSTORE to the storage of ADDRESS.\\n        address contractAddress = ovmADDRESS();\\n\\n        _putContractStorage(\\n            contractAddress,\\n            _key,\\n            _value\\n        );\\n    }\\n\\n\\n    /*********************************\\n     * Opcodes: Contract Code Access *\\n     *********************************/\\n\\n    /**\\n     * @notice Overrides EXTCODECOPY.\\n     * @param _contract Address of the contract to copy code from.\\n     * @param _offset Offset in bytes from the start of contract code to copy beyond.\\n     * @param _length Total number of bytes to copy from the contract's code.\\n     * @return _code Bytes of code copied from the requested contract.\\n     */\\n    function ovmEXTCODECOPY(\\n        address _contract,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        override\\n        public\\n        returns (\\n            bytes memory _code\\n        )\\n    {\\n        return Lib_EthUtils.getCode(\\n            _getAccountEthAddress(_contract),\\n            _offset,\\n            _length\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides EXTCODESIZE.\\n     * @param _contract Address of the contract to query the size of.\\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\\n     */\\n    function ovmEXTCODESIZE(\\n        address _contract\\n    )\\n        override\\n        public\\n        returns (\\n            uint256 _EXTCODESIZE\\n        )\\n    {\\n        return Lib_EthUtils.getCodeSize(\\n            _getAccountEthAddress(_contract)\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides EXTCODEHASH.\\n     * @param _contract Address of the contract to query the hash of.\\n     * @return _EXTCODEHASH Hash of the requested contract.\\n     */\\n    function ovmEXTCODEHASH(\\n        address _contract\\n    )\\n        override\\n        external\\n        returns (\\n            bytes32 _EXTCODEHASH\\n        )\\n    {\\n        return Lib_EthUtils.getCodeHash(\\n            _getAccountEthAddress(_contract)\\n        );\\n    }\\n\\n\\n    /***************************************\\n     * Public Functions: ETH Value Opcodes *\\n     ***************************************/\\n\\n    /**\\n     * @notice Overrides BALANCE.\\n     * NOTE: In the future, this could be optimized to directly invoke EM._getContractStorage(...).\\n     * @param _contract Address of the contract to query the NVM_ETH balance of.\\n     * @return _BALANCE NVM_ETH balance of the requested contract.\\n     */\\n    function ovmBALANCE(\\n        address _contract\\n    )\\n        override\\n        public\\n        returns (\\n            uint256 _BALANCE\\n        )\\n    {\\n        // Easiest way to get the balance is query NVM_ETH as normal.\\n        bytes memory balanceOfCalldata = abi.encodeWithSignature(\\n            \\\"balanceOf(address)\\\",\\n            _contract\\n        );\\n\\n        // Static call because this should be a read-only query.\\n        (bool success, bytes memory returndata) = ovmSTATICCALL(\\n            gasleft(),\\n            Lib_PredeployAddresses.NVM_ETH,\\n            balanceOfCalldata\\n        );\\n\\n        // All balanceOf queries should successfully return a uint, otherwise this must be an OOG.\\n        if (!success || returndata.length != 32) {\\n            _revertWithFlag(RevertFlag.OUT_OF_GAS);\\n        }\\n\\n        // Return the decoded balance.\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * @notice Overrides SELFBALANCE.\\n     * @return _BALANCE NVM_ETH balance of the requesting contract.\\n     */\\n    function ovmSELFBALANCE()\\n        override\\n        external\\n        returns (\\n            uint256 _BALANCE\\n        )\\n    {\\n        return ovmBALANCE(ovmADDRESS());\\n    }\\n\\n\\n    /***************************************\\n     * Public Functions: Execution Context *\\n     ***************************************/\\n\\n    function getMaxTransactionGasLimit()\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 _maxTransactionGasLimit\\n        )\\n    {\\n        return gasMeterConfig.maxTransactionGasLimit;\\n    }\\n\\n    /********************************************\\n     * Public Functions: Deployment Whitelisting *\\n     ********************************************/\\n\\n    /**\\n     * Checks whether the given address is on the whitelist to ovmCREATE/ovmCREATE2,\\n     * and reverts if not.\\n     * @param _deployerAddress Address attempting to deploy a contract.\\n     */\\n    function _checkDeployerAllowed(\\n        address _deployerAddress\\n    )\\n        internal\\n    {\\n        // From an OVM semantics perspective, this will appear identical to\\n        // the deployer ovmCALLing the whitelist.  This is fine--in a sense, we are forcing them to.\\n        (bool success, bytes memory data) = ovmSTATICCALL(\\n            gasleft(),\\n            Lib_PredeployAddresses.DEPLOYER_WHITELIST,\\n            abi.encodeWithSelector(\\n                NVM_DeployerWhitelist.isDeployerAllowed.selector,\\n                _deployerAddress\\n            )\\n        );\\n        bool isAllowed = abi.decode(data, (bool));\\n\\n        if (!isAllowed || !success) {\\n            _revertWithFlag(RevertFlag.CREATOR_NOT_ALLOWED);\\n        }\\n    }\\n\\n    /********************************************\\n     * Internal Functions: Contract Interaction *\\n     ********************************************/\\n\\n    /**\\n     * Creates a new contract and associates it with some contract address.\\n     * @param _contractAddress Address to associate the created contract with.\\n     * @param _bytecode Bytecode to be used to create the contract.\\n     * @return Final OVM contract address.\\n     * @return Revertdata, if and only if the creation threw an exception.\\n     */\\n    function _createContract(\\n        address _contractAddress,\\n        bytes memory _bytecode,\\n        MessageType _messageType\\n    )\\n        internal\\n        returns (\\n            address,\\n            bytes memory\\n        )\\n    {\\n        // We always update the nonce of the creating account, even if the creation fails.\\n        _setAccountNonce(ovmADDRESS(), _getAccountNonce(ovmADDRESS()) + 1);\\n\\n        // We're stepping into a CREATE or CREATE2, so we need to update ADDRESS to point\\n        // to the contract's associated address and CALLER to point to the previous ADDRESS.\\n        MessageContext memory nextMessageContext = messageContext;\\n        nextMessageContext.ovmCALLER = messageContext.ovmADDRESS;\\n        nextMessageContext.ovmADDRESS = _contractAddress;\\n\\n        // Run the common logic which occurs between call-type and create-type messages,\\n        // passing in the creation bytecode and `true` to trigger create-specific logic.\\n        (bool success, bytes memory data) = _handleExternalMessage(\\n            nextMessageContext,\\n            gasleft(),\\n            _contractAddress,\\n            _bytecode,\\n            _messageType\\n        );\\n\\n        // Yellow paper requires that address returned is zero if the contract deployment fails.\\n        return (\\n            success ? _contractAddress : address(0),\\n            data\\n        );\\n    }\\n\\n    /**\\n     * Calls the deployed contract associated with a given address.\\n     * @param _nextMessageContext Message context to be used for the call.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _contract OVM address to be called.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function _callContract(\\n        MessageContext memory _nextMessageContext,\\n        uint256 _gasLimit,\\n        address _contract,\\n        bytes memory _calldata,\\n        MessageType _messageType\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // We reserve addresses of the form 0xdeaddeaddead...NNNN for the container contracts in L2\\n        // geth. So, we block calls to these addresses since they are not safe to run as an OVM\\n        // contract itself.\\n        if (\\n            (uint256(_contract) &\\n            uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000))\\n            == uint256(CONTAINER_CONTRACT_PREFIX)\\n        ) {\\n            // solhint-disable-next-line max-line-length\\n            // EVM does not return data in the success case, see: https://github.com/ethereum/go-ethereum/blob/aae7660410f0ef90279e14afaaf2f429fdc2a186/core/vm/instructions.go#L600-L604\\n            return (true, hex'');\\n        }\\n\\n        // Both 0x0000... and the EVM precompiles have the same address on L1 and L2 -->\\n        // no trie lookup needed.\\n        address codeContractAddress =\\n            uint(_contract) < 100\\n            ? _contract\\n            : _getAccountEthAddress(_contract);\\n\\n        return _handleExternalMessage(\\n            _nextMessageContext,\\n            _gasLimit,\\n            codeContractAddress,\\n            _calldata,\\n            _messageType\\n        );\\n    }\\n\\n    /**\\n     * Handles all interactions which involve the execution manager calling out to untrusted code\\n     * (both calls and creates). Ensures that OVM-related measures are enforced, including L2 gas\\n     * refunds, nuisance gas, and flagged reversions.\\n     *\\n     * @param _nextMessageContext Message context to be used for the external message.\\n     * @param _gasLimit Amount of gas to be passed into this message. NOTE: this argument is\\n     * overwritten in some cases to avoid stack-too-deep.\\n     * @param _contract OVM address being called or deployed to\\n     * @param _data Data for the message (either calldata or creation code)\\n     * @param _messageType What type of ovmOPCODE this message corresponds to.\\n     * @return Whether or not the message (either a call or deployment) succeeded.\\n     * @return Data returned by the message.\\n     */\\n    function _handleExternalMessage(\\n        MessageContext memory _nextMessageContext,\\n        // NOTE: this argument is overwritten in some cases to avoid stack-too-deep.\\n        uint256 _gasLimit,\\n        address _contract,\\n        bytes memory _data,\\n        MessageType _messageType\\n    )\\n        internal\\n        returns (\\n            bool,\\n            bytes memory\\n        )\\n    {\\n        uint256 messageValue = _nextMessageContext.ovmCALLVALUE;\\n        // If there is value in this message, we need to transfer the ETH over before switching\\n        // contexts.\\n        if (\\n            messageValue > 0\\n            && _isValueType(_messageType)\\n        ) {\\n            // Handle out-of-intrinsic gas consistent with EVM behavior -- the subcall \\\"appears to\\n            // revert\\\" if we don't have enough gas to transfer the ETH.\\n            // Similar to dynamic gas cost of value exceeding gas here:\\n            // solhint-disable-next-line max-line-length\\n            // https://github.com/ethereum/go-ethereum/blob/c503f98f6d5e80e079c1d8a3601d188af2a899da/core/vm/interpreter.go#L268-L273\\n            if (gasleft() < CALL_WITH_VALUE_INTRINSIC_GAS) {\\n                return (false, hex\\\"\\\");\\n            }\\n\\n            // If there *is* enough gas to transfer ETH, then we need to make sure this amount of\\n            // gas is reserved (i.e. not given to the _contract.call below) to guarantee that\\n            // _handleExternalMessage can't run out of gas. In particular, in the event that\\n            // the call fails, we will need to transfer the ETH back to the sender.\\n            // Taking the lesser of _gasLimit and gasleft() - CALL_WITH_VALUE_INTRINSIC_GAS\\n            // guarantees that the second _attemptForcedEthTransfer below, if needed, always has\\n            // enough gas to succeed.\\n            _gasLimit = Math.min(\\n                _gasLimit,\\n                gasleft() - CALL_WITH_VALUE_INTRINSIC_GAS // Cannot overflow due to the above check.\\n            );\\n\\n            // Now transfer the value of the call.\\n            // The target is interpreted to be the next message's ovmADDRESS account.\\n            bool transferredNvmEth = _attemptForcedEthTransfer(\\n                _nextMessageContext.ovmADDRESS,\\n                messageValue\\n            );\\n\\n            // If the ETH transfer fails (should only be possible in the case of insufficient\\n            // balance), then treat this as a revert. This mirrors EVM behavior, see\\n            // solhint-disable-next-line max-line-length\\n            // https://github.com/ethereum/go-ethereum/blob/2dee31930c9977af2a9fcb518fb9838aa609a7cf/core/vm/evm.go#L298\\n            if (!transferredNvmEth) {\\n                return (false, hex\\\"\\\");\\n            }\\n        }\\n\\n        // We need to switch over to our next message context for the duration of this call.\\n        MessageContext memory prevMessageContext = messageContext;\\n        _switchMessageContext(prevMessageContext, _nextMessageContext);\\n\\n        // Nuisance gas is a system used to bound the ability for an attacker to make fraud proofs\\n        // expensive by touching a lot of different accounts or storage slots. Since most contracts\\n        // only use a few storage slots during any given transaction, this shouldn't be a limiting\\n        // factor.\\n        uint256 prevNuisanceGasLeft = messageRecord.nuisanceGasLeft;\\n        uint256 nuisanceGasLimit = _getNuisanceGasLimit(_gasLimit);\\n        messageRecord.nuisanceGasLeft = nuisanceGasLimit;\\n\\n        // Make the call and make sure to pass in the gas limit. Another instance of hidden\\n        // complexity. `_contract` is guaranteed to be a safe contract, meaning its return/revert\\n        // behavior can be controlled. In particular, we enforce that flags are passed through\\n        // revert data as to retrieve execution metadata that would normally be reverted out of\\n        // existence.\\n\\n        bool success;\\n        bytes memory returndata;\\n        if (_isCreateType(_messageType)) {\\n            // safeCREATE() is a function which replicates a CREATE message, but uses return values\\n            // Which match that of CALL (i.e. bool, bytes).  This allows many security checks to be\\n            // to be shared between untrusted call and create call frames.\\n            (success, returndata) = address(this).call{gas: _gasLimit}(\\n                abi.encodeWithSelector(\\n                    this.safeCREATE.selector,\\n                    _data,\\n                    _contract\\n                )\\n            );\\n        } else {\\n            (success, returndata) = _contract.call{gas: _gasLimit}(_data);\\n        }\\n\\n        // If the message threw an exception, its value should be returned back to the sender.\\n        // So, we force it back, BEFORE returning the messageContext to the previous addresses.\\n        // This operation is part of the reason we \\\"reserved the intrinsic gas\\\" above.\\n        if (\\n            messageValue > 0\\n            && _isValueType(_messageType)\\n            && !success\\n        ) {\\n            bool transferredNvmEth = _attemptForcedEthTransfer(\\n                prevMessageContext.ovmADDRESS,\\n                messageValue\\n            );\\n\\n            // Since we transferred it in above and the call reverted, the transfer back should\\n            // always pass. This code path should NEVER be triggered since we sent `messageValue`\\n            // worth of NVM_ETH into the target and reserved sufficient gas to execute the transfer,\\n            // but in case there is some edge case which has been missed, we revert the entire frame\\n            // (and its parent) to make sure the ETH gets sent back.\\n            if (!transferredNvmEth) {\\n                _revertWithFlag(RevertFlag.OUT_OF_GAS);\\n            }\\n        }\\n\\n        // Switch back to the original message context now that we're out of the call and all\\n        // NVM_ETH is in the right place.\\n        _switchMessageContext(_nextMessageContext, prevMessageContext);\\n\\n        // Assuming there were no reverts, the message record should be accurate here. We'll update\\n        // this value in the case of a revert.\\n        uint256 nuisanceGasLeft = messageRecord.nuisanceGasLeft;\\n\\n        // Reverts at this point are completely OK, but we need to make a few updates based on the\\n        // information passed through the revert.\\n        if (success == false) {\\n            (\\n                RevertFlag flag,\\n                uint256 nuisanceGasLeftPostRevert,\\n                uint256 ovmGasRefund,\\n                bytes memory returndataFromFlag\\n            ) = _decodeRevertData(returndata);\\n\\n            // INVALID_STATE_ACCESS is the only flag that triggers an immediate abort of the\\n            // parent EVM message. This behavior is necessary because INVALID_STATE_ACCESS must\\n            // halt any further transaction execution that could impact the execution result.\\n            if (flag == RevertFlag.INVALID_STATE_ACCESS) {\\n                _revertWithFlag(flag);\\n            }\\n\\n            // INTENTIONAL_REVERT, UNSAFE_BYTECODE, STATIC_VIOLATION, and CREATOR_NOT_ALLOWED aren't\\n            // dependent on the input state, so we can just handle them like standard reverts.\\n            // Our only change here is to record the gas refund reported by the call (enforced by\\n            // safety checking).\\n            if (\\n                flag == RevertFlag.INTENTIONAL_REVERT\\n                || flag == RevertFlag.UNSAFE_BYTECODE\\n                || flag == RevertFlag.STATIC_VIOLATION\\n                || flag == RevertFlag.CREATOR_NOT_ALLOWED\\n            ) {\\n                transactionRecord.ovmGasRefund = ovmGasRefund;\\n            }\\n\\n            // INTENTIONAL_REVERT needs to pass up the user-provided return data encoded into the\\n            // flag, *not* the full encoded flag.  Additionally, we surface custom error messages\\n            // to developers in the case of unsafe creations for improved devex.\\n            // All other revert types return no data.\\n            if (\\n                flag == RevertFlag.INTENTIONAL_REVERT\\n                || flag == RevertFlag.UNSAFE_BYTECODE\\n            ) {\\n                returndata = returndataFromFlag;\\n            } else {\\n                returndata = hex'';\\n            }\\n\\n            // Reverts mean we need to use up whatever \\\"nuisance gas\\\" was used by the call.\\n            // EXCEEDS_NUISANCE_GAS explicitly reduces the remaining nuisance gas for this message\\n            // to zero. OUT_OF_GAS is a \\\"pseudo\\\" flag given that messages return no data when they\\n            // run out of gas, so we have to treat this like EXCEEDS_NUISANCE_GAS. All other flags\\n            // will simply pass up the remaining nuisance gas.\\n            nuisanceGasLeft = nuisanceGasLeftPostRevert;\\n        }\\n\\n        // We need to reset the nuisance gas back to its original value minus the amount used here.\\n        messageRecord.nuisanceGasLeft = prevNuisanceGasLeft - (nuisanceGasLimit - nuisanceGasLeft);\\n\\n        return (\\n            success,\\n            returndata\\n        );\\n    }\\n\\n    /**\\n     * Handles the creation-specific safety measures required for OVM contract deployment.\\n     * This function sanitizes the return types for creation messages to match calls (bool, bytes),\\n     * by being an external function which the EM can call, that mimics the success/fail case of the\\n     * CREATE.\\n     * This allows for consistent handling of both types of messages in _handleExternalMessage().\\n     * Having this step occur as a separate call frame also allows us to easily revert the\\n     * contract deployment in the event that the code is unsafe.\\n     *\\n     * @param _creationCode Code to pass into CREATE for deployment.\\n     * @param _address OVM address being deployed to.\\n     */\\n    function safeCREATE(\\n        bytes memory _creationCode,\\n        address _address\\n    )\\n        external\\n    {\\n        // The only way this should callable is from within _createContract(),\\n        // and it should DEFINITELY not be callable by a non-EM code contract.\\n        if (msg.sender != address(this)) {\\n            return;\\n        }\\n        // Check that there is not already code at this address.\\n        if (_hasEmptyAccount(_address) == false) {\\n            // Note: in the EVM, this case burns all allotted gas.  For improved\\n            // developer experience, we do return the remaining gas.\\n            _revertWithFlag(\\n                RevertFlag.CREATE_COLLISION\\n            );\\n        }\\n\\n        // Check the creation bytecode against the NVM_SafetyChecker.\\n        if (nvmSafetyChecker.isBytecodeSafe(_creationCode) == false) {\\n            // Note: in the EVM, this case burns all allotted gas.  For improved\\n            // developer experience, we do return the remaining gas.\\n            _revertWithFlag(\\n                RevertFlag.UNSAFE_BYTECODE,\\n                // solhint-disable-next-line max-line-length\\n                Lib_ErrorUtils.encodeRevertString(\\\"Contract creation code contains unsafe opcodes. Did you use the right compiler or pass an unsafe constructor argument?\\\")\\n            );\\n        }\\n\\n        // We always need to initialize the contract with the default account values.\\n        _initPendingAccount(_address);\\n\\n        // Actually execute the EVM create message.\\n        // NOTE: The inline assembly below means we can NOT make any evm calls between here and then\\n        address ethAddress = Lib_EthUtils.createContract(_creationCode);\\n\\n        if (ethAddress == address(0)) {\\n            // If the creation fails, the EVM lets us grab its revert data. This may contain a\\n            // revert flag to be used above in _handleExternalMessage, so we pass the revert data\\n            // back up unmodified.\\n            assembly {\\n                returndatacopy(0,0,returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // Again simply checking that the deployed code is safe too. Contracts can generate\\n        // arbitrary deployment code, so there's no easy way to analyze this beforehand.\\n        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);\\n        if (nvmSafetyChecker.isBytecodeSafe(deployedCode) == false) {\\n            _revertWithFlag(\\n                RevertFlag.UNSAFE_BYTECODE,\\n                // solhint-disable-next-line max-line-length\\n                Lib_ErrorUtils.encodeRevertString(\\\"Constructor attempted to deploy unsafe bytecode.\\\")\\n            );\\n        }\\n\\n        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by\\n        // associating the desired address with the newly created contract's code hash and address.\\n        _commitPendingAccount(\\n            _address,\\n            ethAddress,\\n            Lib_EthUtils.getCodeHash(ethAddress)\\n        );\\n    }\\n\\n    /******************************************\\n     * Internal Functions: Value Manipulation *\\n     ******************************************/\\n\\n    /**\\n     * Invokes an ovmCALL to NVM_ETH.transfer on behalf of the current ovmADDRESS, allowing us to\\n     * force movement of NVM_ETH in correspondence with ETH's native value functionality.\\n     * WARNING: this will send on behalf of whatever the messageContext.ovmADDRESS is in storage\\n     * at the time of the call.\\n     * NOTE: In the future, this could be optimized to directly invoke EM._setContractStorage(...).\\n     * @param _to Amount of NVM_ETH to be sent.\\n     * @param _value Amount of NVM_ETH to send.\\n     * @return _success Whether or not the transfer worked.\\n     */\\n    function _attemptForcedEthTransfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n        returns(\\n            bool _success\\n        )\\n    {\\n        bytes memory transferCalldata = abi.encodeWithSignature(\\n            \\\"transfer(address,uint256)\\\",\\n            _to,\\n            _value\\n        );\\n\\n        // NVM_ETH inherits from the UniswapV2ERC20 standard.  In this implementation, its return\\n        // type is a boolean.  However, the implementation always returns true if it does not revert\\n        // Thus, success of the call frame is sufficient to infer success of the transfer itself.\\n        (bool success, ) = ovmCALL(\\n            gasleft(),\\n            Lib_PredeployAddresses.NVM_ETH,\\n            0,\\n            transferCalldata\\n        );\\n\\n        return success;\\n    }\\n\\n    /******************************************\\n     * Internal Functions: State Manipulation *\\n     ******************************************/\\n\\n    /**\\n     * Checks whether an account exists within the NVM_StateManager.\\n     * @param _address Address of the account to check.\\n     * @return _exists Whether or not the account exists.\\n     */\\n    function _hasAccount(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            bool _exists\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return nvmStateManager.hasAccount(_address);\\n    }\\n\\n    /**\\n     * Checks whether a known empty account exists within the NVM_StateManager.\\n     * @param _address Address of the account to check.\\n     * @return _exists Whether or not the account empty exists.\\n     */\\n    function _hasEmptyAccount(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            bool _exists\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return nvmStateManager.hasEmptyAccount(_address);\\n    }\\n\\n    /**\\n     * Sets the nonce of an account.\\n     * @param _address Address of the account to modify.\\n     * @param _nonce New account nonce.\\n     */\\n    function _setAccountNonce(\\n        address _address,\\n        uint256 _nonce\\n    )\\n        internal\\n    {\\n        _checkAccountChange(_address);\\n        nvmStateManager.setAccountNonce(_address, _nonce);\\n    }\\n\\n    /**\\n     * Gets the nonce of an account.\\n     * @param _address Address of the account to access.\\n     * @return _nonce Nonce of the account.\\n     */\\n    function _getAccountNonce(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            uint256 _nonce\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return nvmStateManager.getAccountNonce(_address);\\n    }\\n\\n    /**\\n     * Retrieves the Ethereum address of an account.\\n     * @param _address Address of the account to access.\\n     * @return _ethAddress Corresponding Ethereum address.\\n     */\\n    function _getAccountEthAddress(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            address _ethAddress\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return nvmStateManager.getAccountEthAddress(_address);\\n    }\\n\\n    /**\\n     * Creates the default account object for the given address.\\n     * @param _address Address of the account create.\\n     */\\n    function _initPendingAccount(\\n        address _address\\n    )\\n        internal\\n    {\\n        // Although it seems like `_checkAccountChange` would be more appropriate here, we don't\\n        // actually consider an account \\\"changed\\\" until it's inserted into the state (in this case\\n        // by `_commitPendingAccount`).\\n        _checkAccountLoad(_address);\\n        nvmStateManager.initPendingAccount(_address);\\n    }\\n\\n    /**\\n     * Stores additional relevant data for a new account, thereby \\\"committing\\\" it to the state.\\n     * This function is only called during `ovmCREATE` and `ovmCREATE2` after a successful contract\\n     * creation.\\n     * @param _address Address of the account to commit.\\n     * @param _ethAddress Address of the associated deployed contract.\\n     * @param _codeHash Hash of the code stored at the address.\\n     */\\n    function _commitPendingAccount(\\n        address _address,\\n        address _ethAddress,\\n        bytes32 _codeHash\\n    )\\n        internal\\n    {\\n        _checkAccountChange(_address);\\n        nvmStateManager.commitPendingAccount(\\n            _address,\\n            _ethAddress,\\n            _codeHash\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the value of a storage slot.\\n     * @param _contract Address of the contract to query.\\n     * @param _key 32 byte key of the storage slot.\\n     * @return _value 32 byte storage slot value.\\n     */\\n    function _getContractStorage(\\n        address _contract,\\n        bytes32 _key\\n    )\\n        internal\\n        returns (\\n            bytes32 _value\\n        )\\n    {\\n        _checkContractStorageLoad(_contract, _key);\\n        return nvmStateManager.getContractStorage(_contract, _key);\\n    }\\n\\n    /**\\n     * Sets the value of a storage slot.\\n     * @param _contract Address of the contract to modify.\\n     * @param _key 32 byte key of the storage slot.\\n     * @param _value 32 byte storage slot value.\\n     */\\n    function _putContractStorage(\\n        address _contract,\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        internal\\n    {\\n        // We don't set storage if the value didn't change. Although this acts as a convenient\\n        // optimization, it's also necessary to avoid the case in which a contract with no storage\\n        // attempts to store the value \\\"0\\\" at any key. Putting this value (and therefore requiring\\n        // that the value be committed into the storage trie after execution) would incorrectly\\n        // modify the storage root.\\n        if (_getContractStorage(_contract, _key) == _value) {\\n            return;\\n        }\\n\\n        _checkContractStorageChange(_contract, _key);\\n        nvmStateManager.putContractStorage(_contract, _key, _value);\\n    }\\n\\n    /**\\n     * Validation whenever a contract needs to be loaded. Checks that the account exists, charges\\n     * nuisance gas if the account hasn't been loaded before.\\n     * @param _address Address of the account to load.\\n     */\\n    function _checkAccountLoad(\\n        address _address\\n    )\\n        internal\\n    {\\n        // See `_checkContractStorageLoad` for more information.\\n        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {\\n            _revertWithFlag(RevertFlag.OUT_OF_GAS);\\n        }\\n\\n        // See `_checkContractStorageLoad` for more information.\\n        if (nvmStateManager.hasAccount(_address) == false) {\\n            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);\\n        }\\n\\n        // Check whether the account has been loaded before and mark it as loaded if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that an account is loaded.\\n        (\\n            bool _wasAccountAlreadyLoaded\\n        ) = nvmStateManager.testAndSetAccountLoaded(_address);\\n\\n        // If we hadn't already loaded the account, then we'll need to charge \\\"nuisance gas\\\" based\\n        // on the size of the contract code.\\n        if (_wasAccountAlreadyLoaded == false) {\\n            _useNuisanceGas(\\n                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address))\\n                * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Validation whenever a contract needs to be changed. Checks that the account exists, charges\\n     * nuisance gas if the account hasn't been changed before.\\n     * @param _address Address of the account to change.\\n     */\\n    function _checkAccountChange(\\n        address _address\\n    )\\n        internal\\n    {\\n        // Start by checking for a load as we only want to charge nuisance gas proportional to\\n        // contract size once.\\n        _checkAccountLoad(_address);\\n\\n        // Check whether the account has been changed before and mark it as changed if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that an account is changed.\\n        (\\n            bool _wasAccountAlreadyChanged\\n        ) = nvmStateManager.testAndSetAccountChanged(_address);\\n\\n        // If we hadn't already loaded the account, then we'll need to charge \\\"nuisance gas\\\" based\\n        // on the size of the contract code.\\n        if (_wasAccountAlreadyChanged == false) {\\n            nvmStateManager.incrementTotalUncommittedAccounts();\\n            _useNuisanceGas(\\n                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address))\\n                * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Validation whenever a slot needs to be loaded. Checks that the account exists, charges\\n     * nuisance gas if the slot hasn't been loaded before.\\n     * @param _contract Address of the account to load from.\\n     * @param _key 32 byte key to load.\\n     */\\n    function _checkContractStorageLoad(\\n        address _contract,\\n        bytes32 _key\\n    )\\n        internal\\n    {\\n        // Another case of hidden complexity. If we didn't enforce this requirement, then a\\n        // contract could pass in just enough gas to cause the INVALID_STATE_ACCESS check to fail\\n        // on L1 but not on L2. A contract could use this behavior to prevent the\\n        // NVM_ExecutionManager from detecting an invalid state access. Reverting with OUT_OF_GAS\\n        // allows us to also charge for the full message nuisance gas, because you deserve that for\\n        // trying to break the contract in this way.\\n        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {\\n            _revertWithFlag(RevertFlag.OUT_OF_GAS);\\n        }\\n\\n        // We need to make sure that the transaction isn't trying to access storage that hasn't\\n        // been provided to the NVM_StateManager. We'll immediately abort if this is the case.\\n        // We know that we have enough gas to do this check because of the above test.\\n        if (nvmStateManager.hasContractStorage(_contract, _key) == false) {\\n            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);\\n        }\\n\\n        // Check whether the slot has been loaded before and mark it as loaded if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that a slot is loaded.\\n        (\\n            bool _wasContractStorageAlreadyLoaded\\n        ) = nvmStateManager.testAndSetContractStorageLoaded(_contract, _key);\\n\\n        // If we hadn't already loaded the account, then we'll need to charge some fixed amount of\\n        // \\\"nuisance gas\\\".\\n        if (_wasContractStorageAlreadyLoaded == false) {\\n            _useNuisanceGas(NUISANCE_GAS_SLOAD);\\n        }\\n    }\\n\\n    /**\\n     * Validation whenever a slot needs to be changed. Checks that the account exists, charges\\n     * nuisance gas if the slot hasn't been changed before.\\n     * @param _contract Address of the account to change.\\n     * @param _key 32 byte key to change.\\n     */\\n    function _checkContractStorageChange(\\n        address _contract,\\n        bytes32 _key\\n    )\\n        internal\\n    {\\n        // Start by checking for load to make sure we have the storage slot and that we charge the\\n        // \\\"nuisance gas\\\" necessary to prove the storage slot state.\\n        _checkContractStorageLoad(_contract, _key);\\n\\n        // Check whether the slot has been changed before and mark it as changed if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that a slot is changed.\\n        (\\n            bool _wasContractStorageAlreadyChanged\\n        ) = nvmStateManager.testAndSetContractStorageChanged(_contract, _key);\\n\\n        // If we hadn't already changed the account, then we'll need to charge some fixed amount of\\n        // \\\"nuisance gas\\\".\\n        if (_wasContractStorageAlreadyChanged == false) {\\n            // Changing a storage slot means that we're also going to have to change the\\n            // corresponding account, so do an account change check.\\n            _checkAccountChange(_contract);\\n\\n            nvmStateManager.incrementTotalUncommittedContractStorage();\\n            _useNuisanceGas(NUISANCE_GAS_SSTORE);\\n        }\\n    }\\n\\n\\n    /************************************\\n     * Internal Functions: Revert Logic *\\n     ************************************/\\n\\n    /**\\n     * Simple encoding for revert data.\\n     * @param _flag Flag to revert with.\\n     * @param _data Additional user-provided revert data.\\n     * @return _revertdata Encoded revert data.\\n     */\\n    function _encodeRevertData(\\n        RevertFlag _flag,\\n        bytes memory _data\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory _revertdata\\n        )\\n    {\\n        // Out of gas and create exceptions will fundamentally return no data, so simulating it\\n        // shouldn't either.\\n        if (\\n            _flag == RevertFlag.OUT_OF_GAS\\n        ) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        // INVALID_STATE_ACCESS doesn't need to return any data other than the flag.\\n        if (_flag == RevertFlag.INVALID_STATE_ACCESS) {\\n            return abi.encode(\\n                _flag,\\n                0,\\n                0,\\n                bytes(\\\"\\\")\\n            );\\n        }\\n\\n        // Just ABI encode the rest of the parameters.\\n        return abi.encode(\\n            _flag,\\n            messageRecord.nuisanceGasLeft,\\n            transactionRecord.ovmGasRefund,\\n            _data\\n        );\\n    }\\n\\n    /**\\n     * Simple decoding for revert data.\\n     * @param _revertdata Revert data to decode.\\n     * @return _flag Flag used to revert.\\n     * @return _nuisanceGasLeft Amount of nuisance gas unused by the message.\\n     * @return _ovmGasRefund Amount of gas refunded during the message.\\n     * @return _data Additional user-provided revert data.\\n     */\\n    function _decodeRevertData(\\n        bytes memory _revertdata\\n    )\\n        internal\\n        pure\\n        returns (\\n            RevertFlag _flag,\\n            uint256 _nuisanceGasLeft,\\n            uint256 _ovmGasRefund,\\n            bytes memory _data\\n        )\\n    {\\n        // A length of zero means the call ran out of gas, just return empty data.\\n        if (_revertdata.length == 0) {\\n            return (\\n                RevertFlag.OUT_OF_GAS,\\n                0,\\n                0,\\n                bytes(\\\"\\\")\\n            );\\n        }\\n\\n        // ABI decode the incoming data.\\n        return abi.decode(_revertdata, (RevertFlag, uint256, uint256, bytes));\\n    }\\n\\n    /**\\n     * Causes a message to revert or abort.\\n     * @param _flag Flag to revert with.\\n     * @param _data Additional user-provided data.\\n     */\\n    function _revertWithFlag(\\n        RevertFlag _flag,\\n        bytes memory _data\\n    )\\n        internal\\n        view\\n    {\\n        bytes memory revertdata = _encodeRevertData(\\n            _flag,\\n            _data\\n        );\\n\\n        assembly {\\n            revert(add(revertdata, 0x20), mload(revertdata))\\n        }\\n    }\\n\\n    /**\\n     * Causes a message to revert or abort.\\n     * @param _flag Flag to revert with.\\n     */\\n    function _revertWithFlag(\\n        RevertFlag _flag\\n    )\\n        internal\\n    {\\n        _revertWithFlag(_flag, bytes(\\\"\\\"));\\n    }\\n\\n\\n    /******************************************\\n     * Internal Functions: Nuisance Gas Logic *\\n     ******************************************/\\n\\n    /**\\n     * Computes the nuisance gas limit from the gas limit.\\n     * @dev This function is currently using a naive implementation whereby the nuisance gas limit\\n     *      is set to exactly equal the lesser of the gas limit or remaining gas. It's likely that\\n     *      this implementation is perfectly fine, but we may change this formula later.\\n     * @param _gasLimit Gas limit to compute from.\\n     * @return _nuisanceGasLimit Computed nuisance gas limit.\\n     */\\n    function _getNuisanceGasLimit(\\n        uint256 _gasLimit\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 _nuisanceGasLimit\\n        )\\n    {\\n        return _gasLimit < gasleft() ? _gasLimit : gasleft();\\n    }\\n\\n    /**\\n     * Uses a certain amount of nuisance gas.\\n     * @param _amount Amount of nuisance gas to use.\\n     */\\n    function _useNuisanceGas(\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        // Essentially the same as a standard OUT_OF_GAS, except we also retain a record of the gas\\n        // refund to be given at the end of the transaction.\\n        if (messageRecord.nuisanceGasLeft < _amount) {\\n            _revertWithFlag(RevertFlag.EXCEEDS_NUISANCE_GAS);\\n        }\\n\\n        messageRecord.nuisanceGasLeft -= _amount;\\n    }\\n\\n\\n    /************************************\\n     * Internal Functions: Gas Metering *\\n     ************************************/\\n\\n    /**\\n     * Checks whether a transaction needs to start a new epoch and does so if necessary.\\n     * @param _timestamp Transaction timestamp.\\n     */\\n    function _checkNeedsNewEpoch(\\n        uint256 _timestamp\\n    )\\n        internal\\n    {\\n        if (\\n            _timestamp >= (\\n                _getGasMetadata(GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP)\\n                + gasMeterConfig.secondsPerEpoch\\n            )\\n        ) {\\n            _putGasMetadata(\\n                GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP,\\n                _timestamp\\n            );\\n\\n            _putGasMetadata(\\n                GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS,\\n                _getGasMetadata(\\n                    GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS\\n                )\\n            );\\n\\n            _putGasMetadata(\\n                GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS,\\n                _getGasMetadata(\\n                    GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Validates the input values of a transaction.\\n     * @return _valid Whether or not the transaction data is valid.\\n     */\\n    function _isValidInput(\\n        Lib_NVMCodec.Transaction memory _transaction\\n    )\\n        view\\n        internal\\n        returns (\\n            bool\\n        )\\n    {\\n        // Prevent reentrancy to run():\\n        // This check prevents calling run with the default ovmNumber.\\n        // Combined with the first check in run():\\n        //      if (transactionContext.ovmNUMBER != DEFAULT_UINT256) { return; }\\n        // It should be impossible to re-enter since run() returns before any other call frames are\\n        // created. Since this value is already being written to storage, we save much gas compared\\n        // to using the standard nonReentrant pattern.\\n        if (_transaction.blockNumber == DEFAULT_UINT256)  {\\n            return false;\\n        }\\n\\n        if (_isValidGasLimit(_transaction.gasLimit, _transaction.l1QueueOrigin) == false) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Validates the gas limit for a given transaction.\\n     * @param _gasLimit Gas limit provided by the transaction.\\n     * param _queueOrigin Queue from which the transaction originated.\\n     * @return _valid Whether or not the gas limit is valid.\\n     */\\n    function _isValidGasLimit(\\n        uint256 _gasLimit,\\n        Lib_NVMCodec.QueueOrigin // _queueOrigin\\n    )\\n        view\\n        internal\\n        returns (\\n            bool _valid\\n        )\\n    {\\n        // Always have to be below the maximum gas limit.\\n        if (_gasLimit > gasMeterConfig.maxTransactionGasLimit) {\\n            return false;\\n        }\\n\\n        // Always have to be above the minimum gas limit.\\n        if (_gasLimit < gasMeterConfig.minTransactionGasLimit) {\\n            return false;\\n        }\\n\\n        // TEMPORARY: Gas metering is disabled for minnet.\\n        return true;\\n        // GasMetadataKey cumulativeGasKey;\\n        // GasMetadataKey prevEpochGasKey;\\n        // if (_queueOrigin == Lib_NVMCodec.QueueOrigin.SEQUENCER_QUEUE) {\\n        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;\\n        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS;\\n        // } else {\\n        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;\\n        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS;\\n        // }\\n\\n        // return (\\n        //     (\\n        //         _getGasMetadata(cumulativeGasKey)\\n        //         - _getGasMetadata(prevEpochGasKey)\\n        //         + _gasLimit\\n        //     ) < gasMeterConfig.maxGasPerQueuePerEpoch\\n        // );\\n    }\\n\\n    /**\\n     * Updates the cumulative gas after a transaction.\\n     * @param _gasUsed Gas used by the transaction.\\n     * @param _queueOrigin Queue from which the transaction originated.\\n     */\\n    function _updateCumulativeGas(\\n        uint256 _gasUsed,\\n        Lib_NVMCodec.QueueOrigin _queueOrigin\\n    )\\n        internal\\n    {\\n        GasMetadataKey cumulativeGasKey;\\n        if (_queueOrigin == Lib_NVMCodec.QueueOrigin.SEQUENCER_QUEUE) {\\n            cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;\\n        } else {\\n            cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;\\n        }\\n\\n        _putGasMetadata(\\n            cumulativeGasKey,\\n            (\\n                _getGasMetadata(cumulativeGasKey)\\n                + gasMeterConfig.minTransactionGasLimit\\n                + _gasUsed\\n                - transactionRecord.ovmGasRefund\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the value of a gas metadata key.\\n     * @param _key Gas metadata key to retrieve.\\n     * @return _value Value stored at the given key.\\n     */\\n    function _getGasMetadata(\\n        GasMetadataKey _key\\n    )\\n        internal\\n        returns (\\n            uint256 _value\\n        )\\n    {\\n        return uint256(_getContractStorage(\\n            GAS_METADATA_ADDRESS,\\n            bytes32(uint256(_key))\\n        ));\\n    }\\n\\n    /**\\n     * Sets the value of a gas metadata key.\\n     * @param _key Gas metadata key to set.\\n     * @param _value Value to store at the given key.\\n     */\\n    function _putGasMetadata(\\n        GasMetadataKey _key,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        _putContractStorage(\\n            GAS_METADATA_ADDRESS,\\n            bytes32(uint256(_key)),\\n            bytes32(uint256(_value))\\n        );\\n    }\\n\\n\\n    /*****************************************\\n     * Internal Functions: Execution Context *\\n     *****************************************/\\n\\n    /**\\n     * Swaps over to a new message context.\\n     * @param _prevMessageContext Context we're switching from.\\n     * @param _nextMessageContext Context we're switching to.\\n     */\\n    function _switchMessageContext(\\n        MessageContext memory _prevMessageContext,\\n        MessageContext memory _nextMessageContext\\n    )\\n        internal\\n    {\\n        // These conditionals allow us to avoid unneccessary SSTOREs.  However, they do mean that\\n        // the current storage value for the messageContext MUST equal the _prevMessageContext\\n        // argument, or an SSTORE might be erroneously skipped.\\n        if (_prevMessageContext.ovmCALLER != _nextMessageContext.ovmCALLER) {\\n            messageContext.ovmCALLER = _nextMessageContext.ovmCALLER;\\n        }\\n\\n        if (_prevMessageContext.ovmADDRESS != _nextMessageContext.ovmADDRESS) {\\n            messageContext.ovmADDRESS = _nextMessageContext.ovmADDRESS;\\n        }\\n\\n        if (_prevMessageContext.isStatic != _nextMessageContext.isStatic) {\\n            messageContext.isStatic = _nextMessageContext.isStatic;\\n        }\\n\\n        if (_prevMessageContext.ovmCALLVALUE != _nextMessageContext.ovmCALLVALUE) {\\n            messageContext.ovmCALLVALUE = _nextMessageContext.ovmCALLVALUE;\\n        }\\n    }\\n\\n    /**\\n     * Initializes the execution context.\\n     * @param _transaction OVM transaction being executed.\\n     */\\n    function _initContext(\\n        Lib_NVMCodec.Transaction memory _transaction\\n    )\\n        internal\\n    {\\n        transactionContext.ovmTIMESTAMP = _transaction.timestamp;\\n        transactionContext.ovmNUMBER = _transaction.blockNumber;\\n        transactionContext.ovmTXGASLIMIT = _transaction.gasLimit;\\n        transactionContext.ovmL1QUEUEORIGIN = _transaction.l1QueueOrigin;\\n        transactionContext.ovmL1TXORIGIN = _transaction.l1TxOrigin;\\n        transactionContext.ovmGASLIMIT = gasMeterConfig.maxGasPerQueuePerEpoch;\\n\\n        messageRecord.nuisanceGasLeft = _getNuisanceGasLimit(_transaction.gasLimit);\\n    }\\n\\n    /**\\n     * Resets the transaction and message context.\\n     */\\n    function _resetContext()\\n        internal\\n    {\\n        transactionContext.ovmL1TXORIGIN = DEFAULT_ADDRESS;\\n        transactionContext.ovmTIMESTAMP = DEFAULT_UINT256;\\n        transactionContext.ovmNUMBER = DEFAULT_UINT256;\\n        transactionContext.ovmGASLIMIT = DEFAULT_UINT256;\\n        transactionContext.ovmTXGASLIMIT = DEFAULT_UINT256;\\n        transactionContext.ovmL1QUEUEORIGIN = Lib_NVMCodec.QueueOrigin.SEQUENCER_QUEUE;\\n\\n        transactionRecord.ovmGasRefund = DEFAULT_UINT256;\\n\\n        messageContext.ovmCALLER = DEFAULT_ADDRESS;\\n        messageContext.ovmADDRESS = DEFAULT_ADDRESS;\\n        messageContext.isStatic = false;\\n\\n        messageRecord.nuisanceGasLeft = DEFAULT_UINT256;\\n\\n        // Reset the nvmStateManager.\\n        nvmStateManager = iNVM_StateManager(address(0));\\n    }\\n\\n\\n    /******************************************\\n     * Internal Functions: Message Typechecks *\\n     ******************************************/\\n\\n    /**\\n     * Returns whether or not the given message type is a CREATE-type.\\n     * @param _messageType the message type in question.\\n     */\\n    function _isCreateType(\\n        MessageType _messageType\\n    )\\n        internal\\n        pure\\n        returns(\\n            bool\\n        )\\n    {\\n        return (\\n            _messageType == MessageType.ovmCREATE\\n            || _messageType == MessageType.ovmCREATE2\\n        );\\n    }\\n\\n    /**\\n     * Returns whether or not the given message type (potentially) requires the transfer of ETH\\n     * value along with the message.\\n     * @param _messageType the message type in question.\\n     */\\n    function _isValueType(\\n        MessageType _messageType\\n    )\\n        internal\\n        pure\\n        returns(\\n            bool\\n        )\\n    {\\n        // ovmSTATICCALL and ovmDELEGATECALL types do not accept or transfer value.\\n        return (\\n            _messageType == MessageType.ovmCALL\\n            || _messageType == MessageType.ovmCREATE\\n            || _messageType == MessageType.ovmCREATE2\\n        );\\n    }\\n\\n\\n    /*****************************\\n     * L2-only Helper Functions *\\n     *****************************/\\n\\n    /**\\n     * Unreachable helper function for simulating eth_calls with an OVM message context.\\n     * This function will throw an exception in all cases other than when used as a custom\\n     * entrypoint in L2 Geth to simulate eth_call.\\n     * @param _transaction the message transaction to simulate.\\n     * @param _from the OVM account the simulated call should be from.\\n     * @param _value the amount of ETH value to send.\\n     * @param _nvmStateManager the address of the NVM_StateManager precompile in the L2 state.\\n     */\\n    function simulateMessage(\\n        Lib_NVMCodec.Transaction memory _transaction,\\n        address _from,\\n        uint256 _value,\\n        iNVM_StateManager _nvmStateManager\\n    )\\n        external\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        // Prevent this call from having any effect unless in a custom-set VM frame\\n        require(msg.sender == address(0));\\n\\n        // Initialize the EM's internal state, ignoring nuisance gas.\\n        nvmStateManager = _nvmStateManager;\\n        _initContext(_transaction);\\n        messageRecord.nuisanceGasLeft = uint(-1);\\n\\n        // Set the ovmADDRESS to the _from so that the subsequent call frame \\\"comes from\\\" them.\\n        messageContext.ovmADDRESS = _from;\\n\\n        // Execute the desired message.\\n        bool isCreate = _transaction.entrypoint == address(0);\\n        if (isCreate) {\\n            (address created, bytes memory revertData) = ovmCREATE(_transaction.data);\\n            if (created == address(0)) {\\n                return abi.encode(false, revertData);\\n            } else {\\n                // The eth_call RPC endpoint for to = undefined will return the deployed bytecode\\n                // in the success case, differing from standard create messages.\\n                return abi.encode(true, Lib_EthUtils.getCode(created));\\n            }\\n        } else {\\n            (bool success, bytes memory returndata) = ovmCALL(\\n                _transaction.gasLimit,\\n                _transaction.entrypoint,\\n                _value,\\n                _transaction.data\\n            );\\n            return abi.encode(success, returndata);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/rlp/Lib_RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant internal MAX_LIST_LENGTH = 32;\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem memory\\n        )\\n    {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({\\n            length: _in.length,\\n            ptr: ptr\\n        });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        (\\n            uint256 listOffset,\\n            ,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"Invalid RLP list value.\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(\\n                itemCount < MAX_LIST_LENGTH,\\n                \\\"Provided RLP list exceeds max list length.\\\"\\n            );\\n\\n            (\\n                uint256 itemOffset,\\n                uint256 itemLength,\\n            ) = _decodeLength(RLPItem({\\n                length: _in.length - offset,\\n                ptr: _in.ptr + offset\\n            }));\\n\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: _in.ptr + offset\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        return readList(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes value.\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return readBytes(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return readString(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _in.length <= 33,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return readBytes32(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return readUint256(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _in.length == 1,\\n            \\\"Invalid RLP boolean value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(\\n            out == 0 || out == 1,\\n            \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\"\\n        );\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return readBool(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(\\n            _in.length == 21,\\n            \\\"Invalid RLP address value.\\\"\\n        );\\n\\n        return address(readUint256(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return readAddress(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(\\n            _in.length > 0,\\n            \\\"RLP item cannot be null.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen,\\n                \\\"Invalid RLP short string.\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"Invalid RLP long string length.\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfStrLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"Invalid RLP long string.\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"Invalid RLP short list.\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"Invalid RLP long list length.\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfListLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"Invalid RLP long list.\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\\n        assembly {\\n            mstore(\\n                dest,\\n                or(\\n                    and(mload(src), not(mask)),\\n                    and(mload(dest), mask)\\n                )\\n            )\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/rlp/Lib_RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(\\n        bytes[] memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(\\n        string memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bytes32 value.\\n     * @param _in The bytes32 to encode.\\n     * @return _out The RLP encoded bytes32 in bytes.\\n     */\\n    function writeBytes32(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(\\n        uint256 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(\\n        uint256 _len,\\n        uint256 _offset\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(\\n        uint256 _x\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    )\\n        private\\n        pure\\n    {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(\\n        bytes[] memory _list\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/utils/Lib_BytesUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32PadLeft(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes32 ret;\\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\\n        assembly {\\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\\n        }\\n        return ret;\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toUint24(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint24\\n        )\\n    {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3 , \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint8(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8\\n        )\\n    {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toAddress(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(\\n        bytes memory _bytes,\\n        bytes memory _other\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/utils/Lib_Bytes32Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(_in));\\n    }\\n\\n    /**\\n     * Removes the leading zeros from a bytes32 value and returns a new (smaller) bytes value.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 without any leading zeros.\\n     */\\n    function removeLeadingZeros(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out;\\n\\n        assembly {\\n            // Figure out how many leading zero bytes to remove.\\n            let shift := 0\\n            for { let i := 0 } and(lt(i, 32), eq(byte(i, _in), 0)) { i := add(i, 1) } {\\n                shift := add(shift, 1)\\n            }\\n\\n            // Reserve some space for our output and fix the free memory pointer.\\n            out := mload(0x40)\\n            mstore(0x40, add(out, 0x40))\\n\\n            // Shift the value and store it into the output bytes.\\n            mstore(add(out, 0x20), shl(mul(shift, 8), _in))\\n\\n            // Store the new size (with leading zero bytes removed) in the output byte size.\\n            mstore(out, sub(32, shift))\\n        }\\n\\n        return out;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string indexed _name,\\n        address _newAddress,\\n        address _oldAddress\\n    );\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(\\n            _name,\\n            _address,\\n            oldAddress\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(\\n        string memory _name\\n    )\\n        external\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/utils/Lib_EthUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// @unsupported: ovm\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"./Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_EthUtils\\n */\\nlibrary Lib_EthUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Gets the code for a given address.\\n     * @param _address Address to get code for.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Code read from the contract.\\n     */\\n    function getCode(\\n        address _address,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory code;\\n        assembly {\\n            code := mload(0x40)\\n            mstore(0x40, add(code, add(_length, 0x20)))\\n            mstore(code, _length)\\n            extcodecopy(_address, add(code, 0x20), _offset, _length)\\n        }\\n\\n        return code;\\n    }\\n\\n    /**\\n     * Gets the full code for a given address.\\n     * @param _address Address to get code for.\\n     * @return Full code of the contract.\\n     */\\n    function getCode(\\n        address _address\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return getCode(\\n            _address,\\n            0,\\n            getCodeSize(_address)\\n        );\\n    }\\n\\n    /**\\n     * Gets the size of a contract's code in bytes.\\n     * @param _address Address to get code size for.\\n     * @return Size of the contract's code in bytes.\\n     */\\n    function getCodeSize(\\n        address _address\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256\\n        )\\n    {\\n        uint256 codeSize;\\n        assembly {\\n            codeSize := extcodesize(_address)\\n        }\\n\\n        return codeSize;\\n    }\\n\\n    /**\\n     * Gets the hash of a contract's code.\\n     * @param _address Address to get a code hash for.\\n     * @return Hash of the contract's code.\\n     */\\n    function getCodeHash(\\n        address _address\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_address)\\n        }\\n\\n        return codeHash;\\n    }\\n\\n    /**\\n     * Creates a contract with some given initialization code.\\n     * @param _code Contract initialization code.\\n     * @return Address of the created contract.\\n     */\\n    function createContract(\\n        bytes memory _code\\n    )\\n        internal\\n        returns (\\n            address\\n        )\\n    {\\n        address created;\\n        assembly {\\n            created := create(\\n                0,\\n                add(_code, 0x20),\\n                mload(_code)\\n            )\\n        }\\n\\n        return created;\\n    }\\n\\n    /**\\n     * Computes the address that would be generated by CREATE.\\n     * @param _creator Address creating the contract.\\n     * @param _nonce Creator's nonce.\\n     * @return Address to be generated by CREATE.\\n     */\\n    function getAddressForCREATE(\\n        address _creator,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        bytes[] memory encoded = new bytes[](2);\\n        encoded[0] = Lib_RLPWriter.writeAddress(_creator);\\n        encoded[1] = Lib_RLPWriter.writeUint(_nonce);\\n\\n        bytes memory encodedList = Lib_RLPWriter.writeList(encoded);\\n        return Lib_Bytes32Utils.toAddress(keccak256(encodedList));\\n    }\\n\\n    /**\\n     * Computes the address that would be generated by CREATE2.\\n     * @param _creator Address creating the contract.\\n     * @param _bytecode Bytecode of the contract to be created.\\n     * @param _salt 32 byte salt value mixed into the hash.\\n     * @return Address to be generated by CREATE2.\\n     */\\n    function getAddressForCREATE2(\\n        address _creator,\\n        bytes memory _bytecode,\\n        bytes32 _salt\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        bytes32 hashedData = keccak256(abi.encodePacked(\\n            byte(0xff),\\n            _creator,\\n            _salt,\\n            keccak256(_bytecode)\\n        ));\\n\\n        return Lib_Bytes32Utils.toAddress(hashedData);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/utils/Lib_ErrorUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Lib_ErrorUtils\\n */\\nlibrary Lib_ErrorUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes an error string into raw solidity-style revert data.\\n     * (i.e. ascii bytes, prefixed with bytes4(keccak(\\\"Error(string))\\\"))\\n     * Ref: https://docs.soliditylang.org/en/v0.8.2/control-structures.html?highlight=Error(string)\\n     * #panic-via-assert-and-error-via-require\\n     * @param _reason Reason for the reversion.\\n     * @return Standard solidity revert data for the given reason.\\n     */\\n    function encodeRevertString(\\n        string memory _reason\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return abi.encodeWithSignature(\\n            \\\"Error(string)\\\",\\n            _reason\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/libraries/constants/Lib_PredeployAddresses.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_PredeployAddresses\\n */\\nlibrary Lib_PredeployAddresses {\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n    address internal constant ECDSA_CONTRACT_ACCOUNT = 0x4200000000000000000000000000000000000003;\\n    address internal constant SEQUENCER_ENTRYPOINT = 0x4200000000000000000000000000000000000005;\\n    address payable internal constant NVM_ETH = 0x4200000000000000000000000000000000000006;\\n    // solhint-disable-next-line max-line-length\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\\n    // solhint-disable-next-line max-line-length\\n    address internal constant EXECUTION_MANAGER_WRAPPER = 0x420000000000000000000000000000000000000B;\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n    address internal constant ERC1820_REGISTRY = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/iNVM/execution/iNVM_ExecutionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_NVMCodec } from \\\"../../libraries/codec/Lib_NVMCodec.sol\\\";\\n\\ninterface iNVM_ExecutionManager {\\n    /**********\\n     * Enums *\\n     *********/\\n\\n    enum RevertFlag {\\n        OUT_OF_GAS,\\n        INTENTIONAL_REVERT,\\n        EXCEEDS_NUISANCE_GAS,\\n        INVALID_STATE_ACCESS,\\n        UNSAFE_BYTECODE,\\n        CREATE_COLLISION,\\n        STATIC_VIOLATION,\\n        CREATOR_NOT_ALLOWED\\n    }\\n\\n    enum GasMetadataKey {\\n        CURRENT_EPOCH_START_TIMESTAMP,\\n        CUMULATIVE_SEQUENCER_QUEUE_GAS,\\n        CUMULATIVE_L1TOL2_QUEUE_GAS,\\n        PREV_EPOCH_SEQUENCER_QUEUE_GAS,\\n        PREV_EPOCH_L1TOL2_QUEUE_GAS\\n    }\\n\\n    enum MessageType {\\n        ovmCALL,\\n        ovmSTATICCALL,\\n        ovmDELEGATECALL,\\n        ovmCREATE,\\n        ovmCREATE2\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct GasMeterConfig {\\n        uint256 minTransactionGasLimit;\\n        uint256 maxTransactionGasLimit;\\n        uint256 maxGasPerQueuePerEpoch;\\n        uint256 secondsPerEpoch;\\n    }\\n\\n    struct GlobalContext {\\n        uint256 ovmCHAINID;\\n    }\\n\\n    struct TransactionContext {\\n        Lib_NVMCodec.QueueOrigin ovmL1QUEUEORIGIN;\\n        uint256 ovmTIMESTAMP;\\n        uint256 ovmNUMBER;\\n        uint256 ovmGASLIMIT;\\n        uint256 ovmTXGASLIMIT;\\n        address ovmL1TXORIGIN;\\n    }\\n\\n    struct TransactionRecord {\\n        uint256 ovmGasRefund;\\n    }\\n\\n    struct MessageContext {\\n        address ovmCALLER;\\n        address ovmADDRESS;\\n        uint256 ovmCALLVALUE;\\n        bool isStatic;\\n    }\\n\\n    struct MessageRecord {\\n        uint256 nuisanceGasLeft;\\n    }\\n\\n\\n    /************************************\\n     * Transaction Execution Entrypoint *\\n     ************************************/\\n\\n    function run(\\n        Lib_NVMCodec.Transaction calldata _transaction,\\n        address _txStateManager\\n    ) external returns (bytes memory);\\n\\n\\n    /*******************\\n     * Context Opcodes *\\n     *******************/\\n\\n    function ovmCALLER() external view returns (address _caller);\\n    function ovmADDRESS() external view returns (address _address);\\n    function ovmCALLVALUE() external view returns (uint _callValue);\\n    function ovmTIMESTAMP() external view returns (uint256 _timestamp);\\n    function ovmNUMBER() external view returns (uint256 _number);\\n    function ovmGASLIMIT() external view returns (uint256 _gasLimit);\\n    function ovmCHAINID() external view returns (uint256 _chainId);\\n\\n\\n    /**********************\\n     * L2 Context Opcodes *\\n     **********************/\\n\\n    function ovmL1QUEUEORIGIN() external view returns (Lib_NVMCodec.QueueOrigin _queueOrigin);\\n    function ovmL1TXORIGIN() external view returns (address _l1TxOrigin);\\n\\n\\n    /*******************\\n     * Halting Opcodes *\\n     *******************/\\n\\n    function ovmREVERT(bytes memory _data) external;\\n\\n\\n    /*****************************\\n     * Contract Creation Opcodes *\\n     *****************************/\\n\\n    function ovmCREATE(bytes memory _bytecode) external\\n        returns (address _contract, bytes memory _revertdata);\\n    function ovmCREATE2(bytes memory _bytecode, bytes32 _salt) external\\n        returns (address _contract, bytes memory _revertdata);\\n\\n\\n    /*******************************\\n     * Account Abstraction Opcodes *\\n     ******************************/\\n\\n    function ovmGETNONCE() external returns (uint256 _nonce);\\n    function ovmINCREMENTNONCE() external;\\n    function ovmCREATEEOA(bytes32 _messageHash, uint8 _v, bytes32 _r, bytes32 _s) external;\\n\\n\\n    /****************************\\n     * Contract Calling Opcodes *\\n     ****************************/\\n\\n    // Valueless ovmCALL for maintaining backwards compatibility with legacy OVM bytecode.\\n    function ovmCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external\\n        returns (bool _success, bytes memory _returndata);\\n    function ovmCALL(uint256 _gasLimit, address _address, uint256 _value, bytes memory _calldata)\\n        external returns (bool _success, bytes memory _returndata);\\n    function ovmSTATICCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external\\n        returns (bool _success, bytes memory _returndata);\\n    function ovmDELEGATECALL(uint256 _gasLimit, address _address, bytes memory _calldata) external\\n        returns (bool _success, bytes memory _returndata);\\n\\n\\n    /****************************\\n     * Contract Storage Opcodes *\\n     ****************************/\\n\\n    function ovmSLOAD(bytes32 _key) external returns (bytes32 _value);\\n    function ovmSSTORE(bytes32 _key, bytes32 _value) external;\\n\\n\\n    /*************************\\n     * Contract Code Opcodes *\\n     *************************/\\n\\n    function ovmEXTCODECOPY(address _contract, uint256 _offset, uint256 _length) external\\n        returns (bytes memory _code);\\n    function ovmEXTCODESIZE(address _contract) external returns (uint256 _size);\\n    function ovmEXTCODEHASH(address _contract) external returns (bytes32 _hash);\\n\\n\\n    /*********************\\n     * ETH Value Opcodes *\\n     *********************/\\n\\n    function ovmBALANCE(address _contract) external returns (uint256 _balance);\\n    function ovmSELFBALANCE() external returns (uint256 _balance);\\n\\n\\n    /***************************************\\n     * Public Functions: Execution Context *\\n     ***************************************/\\n\\n    function getMaxTransactionGasLimit() external view returns (uint _maxTransactionGasLimit);\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/iNVM/execution/iNVM_StateManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_NVMCodec } from \\\"../../libraries/codec/Lib_NVMCodec.sol\\\";\\n\\n/**\\n * @title iNVM_StateManager\\n */\\ninterface iNVM_StateManager {\\n\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    enum ItemState {\\n        ITEM_UNTOUCHED,\\n        ITEM_LOADED,\\n        ITEM_CHANGED,\\n        ITEM_COMMITTED\\n    }\\n\\n    /***************************\\n     * Public Functions: Misc *\\n     ***************************/\\n\\n    function isAuthenticated(address _address) external view returns (bool);\\n\\n    /***************************\\n     * Public Functions: Setup *\\n     ***************************/\\n\\n    function owner() external view returns (address _owner);\\n    function nvmExecutionManager() external view returns (address _nvmExecutionManager);\\n    function setExecutionManager(address _nvmExecutionManager) external;\\n\\n\\n    /************************************\\n     * Public Functions: Account Access *\\n     ************************************/\\n\\n    function putAccount(address _address, Lib_NVMCodec.Account memory _account) external;\\n    function putEmptyAccount(address _address) external;\\n    function getAccount(address _address) external view\\n        returns (Lib_NVMCodec.Account memory _account);\\n    function hasAccount(address _address) external view returns (bool _exists);\\n    function hasEmptyAccount(address _address) external view returns (bool _exists);\\n    function setAccountNonce(address _address, uint256 _nonce) external;\\n    function getAccountNonce(address _address) external view returns (uint256 _nonce);\\n    function getAccountEthAddress(address _address) external view returns (address _ethAddress);\\n    function getAccountStorageRoot(address _address) external view returns (bytes32 _storageRoot);\\n    function initPendingAccount(address _address) external;\\n    function commitPendingAccount(address _address, address _ethAddress, bytes32 _codeHash)\\n        external;\\n    function testAndSetAccountLoaded(address _address) external\\n        returns (bool _wasAccountAlreadyLoaded);\\n    function testAndSetAccountChanged(address _address) external\\n        returns (bool _wasAccountAlreadyChanged);\\n    function commitAccount(address _address) external returns (bool _wasAccountCommitted);\\n    function incrementTotalUncommittedAccounts() external;\\n    function getTotalUncommittedAccounts() external view returns (uint256 _total);\\n    function wasAccountChanged(address _address) external view returns (bool);\\n    function wasAccountCommitted(address _address) external view returns (bool);\\n\\n\\n    /************************************\\n     * Public Functions: Storage Access *\\n     ************************************/\\n\\n    function putContractStorage(address _contract, bytes32 _key, bytes32 _value) external;\\n    function getContractStorage(address _contract, bytes32 _key) external view\\n        returns (bytes32 _value);\\n    function hasContractStorage(address _contract, bytes32 _key) external view\\n        returns (bool _exists);\\n    function testAndSetContractStorageLoaded(address _contract, bytes32 _key) external\\n        returns (bool _wasContractStorageAlreadyLoaded);\\n    function testAndSetContractStorageChanged(address _contract, bytes32 _key) external\\n        returns (bool _wasContractStorageAlreadyChanged);\\n    function commitContractStorage(address _contract, bytes32 _key) external\\n        returns (bool _wasContractStorageCommitted);\\n    function incrementTotalUncommittedContractStorage() external;\\n    function getTotalUncommittedContractStorage() external view returns (uint256 _total);\\n    function wasContractStorageChanged(address _contract, bytes32 _key) external view\\n        returns (bool);\\n    function wasContractStorageCommitted(address _contract, bytes32 _key) external view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/iNVM/execution/iNVM_SafetyChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iNVM_SafetyChecker\\n */\\ninterface iNVM_SafetyChecker {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function isBytecodeSafe(bytes calldata _bytecode) external pure returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/NVM/predeploys/NVM_DeployerWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Interface Imports */\\nimport { iNVM_DeployerWhitelist } from \\\"../../iNVM/predeploys/iNVM_DeployerWhitelist.sol\\\";\\n\\n/**\\n * @title NVM_DeployerWhitelist\\n * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the\\n * initial phases of our mainnet roll out. It is owned by the Optimism team, and defines accounts\\n * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an\\n * ovmCREATE or ovmCREATE2 operation to proceed if the deployer's address whitelisted.\\n *\\n * Compiler used: optimistic-solc\\n * Runtime target: OVM\\n */\\ncontract NVM_DeployerWhitelist is iNVM_DeployerWhitelist {\\n\\n    /**********************\\n     * Contract Constants *\\n     **********************/\\n\\n    bool public initialized;\\n    bool public allowArbitraryDeployment;\\n    address override public owner;\\n    mapping (address => bool) public whitelist;\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Blocks functions to anyone except the contract owner.\\n     */\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == owner,\\n            \\\"Function can only be called by the owner of this contract.\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Initializes the whitelist.\\n     * @param _owner Address of the owner for this contract.\\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\\n     */\\n    function initialize(\\n        address _owner,\\n        bool _allowArbitraryDeployment\\n    )\\n        override\\n        external\\n    {\\n        if (initialized == true) {\\n            return;\\n        }\\n\\n        initialized = true;\\n        allowArbitraryDeployment = _allowArbitraryDeployment;\\n        owner = _owner;\\n    }\\n\\n    /**\\n     * Adds or removes an address from the deployment whitelist.\\n     * @param _deployer Address to update permissions for.\\n     * @param _isWhitelisted Whether or not the address is whitelisted.\\n     */\\n    function setWhitelistedDeployer(\\n        address _deployer,\\n        bool _isWhitelisted\\n    )\\n        override\\n        external\\n        onlyOwner\\n    {\\n        whitelist[_deployer] = _isWhitelisted;\\n    }\\n\\n    /**\\n     * Updates the owner of this contract.\\n     * @param _owner Address of the new owner.\\n     */\\n    function setOwner(\\n        address _owner\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        owner = _owner;\\n    }\\n\\n    /**\\n     * Updates the arbitrary deployment flag.\\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\\n     */\\n    function setAllowArbitraryDeployment(\\n        bool _allowArbitraryDeployment\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        allowArbitraryDeployment = _allowArbitraryDeployment;\\n    }\\n\\n    /**\\n     * Permanently enables arbitrary contract deployment and deletes the owner.\\n     */\\n    function enableArbitraryContractDeployment()\\n        override\\n        external\\n        onlyOwner\\n    {\\n        setAllowArbitraryDeployment(true);\\n        setOwner(address(0));\\n    }\\n\\n    /**\\n     * Checks whether an address is allowed to deploy contracts.\\n     * @param _deployer Address to check.\\n     * @return _allowed Whether or not the address can deploy contracts.\\n     */\\n    function isDeployerAllowed(\\n        address _deployer\\n    )\\n        override\\n        external\\n        returns (\\n            bool\\n        )\\n    {\\n        return (\\n            initialized == false\\n            || allowArbitraryDeployment == true\\n            || whitelist[_deployer]\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nahmii/iNVM/predeploys/iNVM_DeployerWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iNVM_DeployerWhitelist\\n */\\ninterface iNVM_DeployerWhitelist {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function initialize(address _owner, bool _allowArbitraryDeployment) external;\\n    function owner() external returns (address _owner);\\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external;\\n    function setOwner(address _newOwner) external;\\n    function setAllowArbitraryDeployment(bool _allowArbitraryDeployment) external;\\n    function enableArbitraryContractDeployment() external;\\n    function isDeployerAllowed(address _deployer) external returns (bool _allowed);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxTransactionGasLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_l1TxOrigin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_queueIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TransactionEnqueued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"L2_GAS_DISCOUNT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ROLLUP_TX_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_ROLLUP_TX_GAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"enqueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceInclusionPeriodBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceInclusionPeriodSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getQueueElement\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"internalType\":\"struct Lib_NVMCodec.QueueElement\",\"name\":\"_element\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"contract iNVM_ChainStorageContainer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NVM_MessageQueue","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007934915c03ea2e2c4d69c269f45598b738ddee080000000000000000000000000000000000000000000000000000000000a7d8c0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}