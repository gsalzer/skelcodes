{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Battle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address account) external view returns (uint);\\r\\n    function transfer(address recipient, uint amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n}\\r\\n\\r\\ninterface IERC1155 {\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n}\\r\\n\\r\\ninterface INodeRunnersNFT {\\r\\n    function getFighter(uint256 tokenId) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\\r\\n    function mint(address to, uint256 id, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract Battle {\\r\\n    IERC20 public NDR;\\r\\n    IERC1155 public NFT;\\r\\n\\r\\n    // struct NftToken {\\r\\n    //     bool hasValue;\\r\\n    //     mapping(address => uint) balances;\\r\\n    // }\\r\\n\\r\\n    struct NftToken {\\r\\n        uint tokenId;\\r\\n        uint balances;\\r\\n    }\\r\\n\\r\\n    mapping(address => uint) public teamIdPerUser;\\r\\n    mapping(uint => uint) public totalNDRAmountPerTeam;\\r\\n    mapping(uint => uint) public totalNFTStrengthPerTeam;\\r\\n\\r\\n    mapping(uint => uint) public totalHashPerTeam;\\r\\n    mapping(address => uint) public totalHashPerUser;\\r\\n\\r\\n    mapping(uint => uint) public dayHashPerTeam;\\r\\n    mapping(address => uint) public dayHashPerUser;\\r\\n\\r\\n    // mapping(address => uint) public balanceNFTPerUser;\\r\\n\\r\\n    mapping(address => uint) public totalNFTStrengthPerUser;\\r\\n    mapping(address => uint) public totalNDRAmountPerUser;\\r\\n\\r\\n    mapping(address => uint) public pureNFTStrengthPerUser;\\r\\n    mapping(address => uint) private percentMultiplierApplied;\\r\\n    mapping(address => uint) public percentMultiplierPerUser;\\r\\n\\r\\n    mapping(address => uint) public lastCheckTimePerUser;\\r\\n    mapping(uint => uint) public lastCheckTimePerTeam;\\r\\n\\r\\n    // mapping(uint => NftToken) public nftTokenMap;\\r\\n    mapping(address => NftToken[]) public nftTokenMap;\\r\\n    mapping(address => uint[]) public nftTokens;\\r\\n\\r\\n    mapping(uint => mapping(uint => bool)) public acceptableIdTeam;\\r\\n    mapping(uint => uint) public playersCounter;\\r\\n\\r\\n    // default: 7 days\\r\\n    uint private battleDuration = 7 days;\\r\\n\\r\\n    uint public rewardDuration = 24 hours;\\r\\n    uint public startTime;\\r\\n    uint private _nftFee;\\r\\n\\r\\n    address public owner;\\r\\n    // bool public started;\\r\\n\\r\\n    event NDRStaked(address indexed user, uint amount);\\r\\n    event NFTStaked(address indexed user, uint tokenId, uint amount);\\r\\n    event BoughtNFT(address indexed user, uint tokenId);\\r\\n    event WithdrawnNFT(address indexed user, uint tokenId, uint amount);\\r\\n    event WithdrawnNDR(address indexed user, uint amount);\\r\\n\\r\\n    constructor (\\r\\n        address _NDR, address _NFT\\r\\n        ) {\\r\\n        NDR = IERC20(_NDR);\\r\\n        NFT = IERC1155(_NFT);\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"!owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateHash() {\\r\\n        uint teamId = teamIdPerUser[msg.sender];\\r\\n        uint rewardRateTeam = dayHashPerTeam[teamId] / rewardDuration;\\r\\n        uint rewardRateUser = dayHashPerUser[msg.sender] / rewardDuration;\\r\\n        totalHashPerTeam[teamId] += rewardRateTeam * (block.timestamp - lastCheckTimePerTeam[teamId]);\\r\\n        totalHashPerUser[msg.sender] += rewardRateUser * (block.timestamp - lastCheckTimePerUser[msg.sender]);\\r\\n        lastCheckTimePerTeam[teamId] = block.timestamp;\\r\\n        lastCheckTimePerUser[msg.sender] = block.timestamp;\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setOwner(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    function setSupportedIds(uint[] calldata tokenIds, uint teamId) public onlyOwner {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        for (uint i = 0; i < tokenIds.length; i++) {\\r\\n            uint tokenId = tokenIds[i];\\r\\n            acceptableIdTeam[teamId][tokenId] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setBattleDuration(uint _duration) public onlyOwner {\\r\\n        require(startTime == 0, \\\"Can not change during the battle\\\");\\r\\n        require(_duration > 0, \\\"Invalid duration value\\\");\\r\\n\\r\\n        battleDuration = _duration;\\r\\n    }\\r\\n\\r\\n    function getBattleDuration() public view returns (uint) {\\r\\n        return battleDuration;\\r\\n    }\\r\\n\\r\\n    function changeAddresses(address _NDR, address _NFT) public onlyOwner {\\r\\n        NDR = IERC20(_NDR);\\r\\n        NFT = IERC1155(_NFT);\\r\\n    }\\r\\n\\r\\n    function getTeamNDRAmount(uint teamId) public view returns (uint) {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        return totalNDRAmountPerTeam[teamId];\\r\\n    }\\r\\n\\r\\n    function getTeamTotalNFTStrength(uint teamId) public view returns (uint) {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        return totalNFTStrengthPerTeam[teamId];\\r\\n    }\\r\\n\\r\\n    function getUserTotalNFTStrength(address user) public view returns (uint) {\\r\\n        return totalNFTStrengthPerUser[user];\\r\\n    }\\r\\n\\r\\n    function getTeamDayHash(uint teamId) public view returns (uint) {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        return dayHashPerTeam[teamId];\\r\\n    }\\r\\n\\r\\n    function getUserDayHash(address user) public view returns (uint) {\\r\\n        return dayHashPerUser[user];\\r\\n    }\\r\\n\\r\\n    function selectTeam(uint teamId) public {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        require(teamIdPerUser[msg.sender] == 0, \\\"Can not change team.\\\");\\r\\n        teamIdPerUser[msg.sender] = teamId;\\r\\n        playersCounter[teamId] += 1;\\r\\n    }\\r\\n\\r\\n    function startBattle() public onlyOwner {\\r\\n        require(startTime == 0, \\\"already started!\\\");\\r\\n        startTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function battleFinishDate() public view returns (uint) {\\r\\n        require(block.timestamp >= startTime, \\\"The battle has not been started.\\\");\\r\\n        require(block.timestamp < startTime + battleDuration, \\\"The battle has already been ended.\\\");\\r\\n        return startTime + battleDuration;\\r\\n    }\\r\\n\\r\\n    function getTeamHashResult(uint teamId) public view returns (uint) {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        require(block.timestamp >= startTime, \\\"The battle has not been started.\\\");\\r\\n        uint rewardRateTeam = dayHashPerTeam[teamId] / rewardDuration;\\r\\n        uint lastTotalHash = totalHashPerTeam[teamId];\\r\\n        if (block.timestamp >= startTime + battleDuration) {\\r\\n            lastTotalHash += rewardRateTeam * (startTime + battleDuration - lastCheckTimePerTeam[teamId]);\\r\\n        } else {\\r\\n            lastTotalHash += rewardRateTeam * (block.timestamp - lastCheckTimePerTeam[teamId]);\\r\\n        }\\r\\n        return lastTotalHash;\\r\\n    }\\r\\n\\r\\n    function getUserHashResult(address user) public view returns (uint) {\\r\\n        // require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        require(block.timestamp >= startTime, \\\"The battle has not been started.\\\");\\r\\n        uint rewardRateUser = dayHashPerUser[user] / rewardDuration;\\r\\n        uint lastTotalHash = totalHashPerUser[user];\\r\\n        if (block.timestamp >= startTime + battleDuration) {\\r\\n            lastTotalHash += rewardRateUser * (startTime + battleDuration - lastCheckTimePerUser[user]);\\r\\n        } else {\\r\\n            lastTotalHash += rewardRateUser * (block.timestamp - lastCheckTimePerUser[user]);\\r\\n        }\\r\\n        return lastTotalHash;\\r\\n    }\\r\\n\\r\\n    function stakeNFT(uint[] calldata tokenIds, uint[] calldata amounts) public payable updateHash {\\r\\n        require(startTime < block.timestamp, \\\"The battle has not been started yet.\\\");\\r\\n        require(block.timestamp < startTime + battleDuration, \\\"The battle has already been ended.\\\");\\r\\n        require(tokenIds.length == amounts.length, \\\"TokenIds and amounts length should be the same\\\");\\r\\n        require(teamIdPerUser[msg.sender] > 0, \\\"Please select team before staking\\\");\\r\\n        for (uint i = 0; i < tokenIds.length; i++) {\\r\\n            // stakeInternal\\r\\n            stakeInternal(tokenIds[i], amounts[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function stakeInternal(uint256 tokenId, uint256 amount) internal {\\r\\n        uint teamId = teamIdPerUser[msg.sender];\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        require(acceptableIdTeam[teamId][tokenId] == true, \\\"Not acceptable tokenId for this team.\\\");\\r\\n        (uint256 strength,,,,,uint256 series) = INodeRunnersNFT(address(NFT)).getFighter(tokenId);\\r\\n        strength = strength * amount * 100;\\r\\n\\r\\n        if (series == 3) {\\r\\n            require(amount == 1, \\\"only one nft with series 3 badge\\\");\\r\\n            require(percentMultiplierApplied[msg.sender] == 0 || percentMultiplierApplied[msg.sender] == 2, \\\"nft with series 3 already applied\\\");\\r\\n            if (percentMultiplierApplied[msg.sender] == 0) {\\r\\n                percentMultiplierApplied[msg.sender] = 1;\\r\\n            } else {\\r\\n                percentMultiplierApplied[msg.sender] == 3;\\r\\n            }\\r\\n        }\\r\\n        if (series == 4) {\\r\\n            require(amount == 1, \\\"only one nft with series 4 badge\\\");\\r\\n            require(percentMultiplierApplied[msg.sender] == 0 || percentMultiplierApplied[msg.sender] == 1, \\\"nft with series 4 already applied\\\");\\r\\n            if (percentMultiplierApplied[msg.sender] == 0) {\\r\\n                percentMultiplierApplied[msg.sender] = 2;\\r\\n            } else {\\r\\n                percentMultiplierApplied[msg.sender] = 3;\\r\\n            }\\r\\n        }\\r\\n        totalNFTStrengthPerTeam[teamId] = totalNFTStrengthPerTeam[teamId] - totalNFTStrengthPerUser[msg.sender];\\r\\n        pureNFTStrengthPerUser[msg.sender] = pureNFTStrengthPerUser[msg.sender] + strength;\\r\\n\\r\\n        if (percentMultiplierApplied[msg.sender] == 1) {\\r\\n            totalNFTStrengthPerUser[msg.sender] = pureNFTStrengthPerUser[msg.sender] * 110 / 100;\\r\\n        } else if (percentMultiplierApplied[msg.sender] == 2) {\\r\\n            totalNFTStrengthPerUser[msg.sender] = pureNFTStrengthPerUser[msg.sender] * 105 / 100;\\r\\n        } else if (percentMultiplierApplied[msg.sender] == 3) {\\r\\n            totalNFTStrengthPerUser[msg.sender] = pureNFTStrengthPerUser[msg.sender] * 11 * 105 / 1000;\\r\\n        } else {\\r\\n            totalNFTStrengthPerUser[msg.sender] = pureNFTStrengthPerUser[msg.sender];\\r\\n        }\\r\\n\\r\\n        // balanceNFTPerUser[msg.sender] += amount;\\r\\n        totalNFTStrengthPerTeam[teamId] += totalNFTStrengthPerUser[msg.sender];\\r\\n        nftTokenMap[msg.sender].push(NftToken(tokenId, amount));\\r\\n\\r\\n        NFT.safeTransferFrom(msg.sender, address(this), tokenId, amount, \\\"0x0\\\");\\r\\n        updateDayHash(msg.sender, teamId);\\r\\n        emit NFTStaked(msg.sender, tokenId, amount);\\r\\n    }\\r\\n\\r\\n    function stakeNDR(uint amount) public payable updateHash {\\r\\n        require(startTime < block.timestamp, \\\"The battle has not been started yet.\\\");\\r\\n        require(block.timestamp < startTime + battleDuration, \\\"The battle has already been ended.\\\");\\r\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\r\\n        require(teamIdPerUser[msg.sender] > 0, \\\"Please select team before staking\\\");\\r\\n        uint teamId = teamIdPerUser[msg.sender];\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        uint teamNDRAmount = totalNDRAmountPerTeam[teamId];\\r\\n        uint userNDRAmount = totalNDRAmountPerUser[msg.sender];\\r\\n        // TODO get teamHash\\r\\n        NDR.transferFrom(msg.sender, address(this), amount);\\r\\n        teamNDRAmount += amount;\\r\\n        userNDRAmount += amount;\\r\\n        totalNDRAmountPerTeam[teamId] = teamNDRAmount;\\r\\n        totalNDRAmountPerUser[msg.sender] = userNDRAmount;\\r\\n        updateDayHash(msg.sender, teamId);\\r\\n\\r\\n        emit NDRStaked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function updateDayHash(address user, uint teamId) internal {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        uint teamStrength = totalNFTStrengthPerTeam[teamId];\\r\\n        uint userStrength = totalNFTStrengthPerUser[user];\\r\\n        uint teamNDRAmount = totalNDRAmountPerTeam[teamId] / (1e18);\\r\\n        // uint userNDRAmount = totalNDRAmountPerUser[user] / (1e18);\\r\\n        if (teamStrength != 0) {\\r\\n            if (teamNDRAmount * 10000 > teamStrength) {\\r\\n                dayHashPerTeam[teamId] = teamStrength;\\r\\n                dayHashPerUser[user] = userStrength;\\r\\n            } else {\\r\\n                dayHashPerTeam[teamId] = totalNDRAmountPerTeam[teamId];\\r\\n                dayHashPerUser[user] = totalNDRAmountPerUser[user];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setNftFee() external payable onlyOwner {\\r\\n        _nftFee = msg.value;\\r\\n    }\\r\\n\\r\\n    function getNftFee() public view returns(uint) {\\r\\n        require(_nftFee > 0, \\\"Nft fee has not set yet.\\\");\\r\\n        return _nftFee;\\r\\n    }\\r\\n\\r\\n    function getMintingFee(uint rarity, uint teamId) internal view returns (uint) {\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        uint teamStrength = totalNFTStrengthPerTeam[teamId];\\r\\n        uint teamNDRAmount = totalNDRAmountPerTeam[teamId] / (1e18);\\r\\n        uint fee = rarity * teamNDRAmount * 10000 / teamStrength;\\r\\n        return fee;\\r\\n    }\\r\\n\\r\\n    function buyNewNFT(uint tokenId) public updateHash payable {\\r\\n        (,,,uint256 rarity,uint256 hashPrice,) = INodeRunnersNFT(address(NFT)).getFighter(tokenId);\\r\\n        uint teamId = teamIdPerUser[msg.sender];\\r\\n        require(teamId == 1 || teamId == 2, \\\"teamId should be 1 or 2\\\");\\r\\n        require(hashPrice > 0, \\\"can't buy in hash\\\");\\r\\n        uint fee = getMintingFee(rarity, teamId);\\r\\n        require(msg.value >= fee, \\\"wrong value\\\");\\r\\n        uint userHash = totalHashPerUser[msg.sender];\\r\\n        uint teamHash = totalHashPerTeam[teamId];\\r\\n        require(userHash >= hashPrice, \\\"not enough Hash\\\");\\r\\n        userHash = userHash - hashPrice;\\r\\n        teamHash = teamHash - hashPrice;\\r\\n        totalHashPerUser[msg.sender] = userHash;\\r\\n        totalHashPerTeam[teamId] = teamHash;\\r\\n        INodeRunnersNFT(address(NFT)).mint(msg.sender, tokenId, 1);\\r\\n\\r\\n        emit BoughtNFT(msg.sender, tokenId);\\r\\n    }\\r\\n\\r\\n    function withdrawNFT() public {\\r\\n        require(block.timestamp > startTime + battleDuration, \\\"The battle has not been ended\\\");\\r\\n        NftToken[] memory tokens = nftTokenMap[msg.sender];\\r\\n        for (uint i = 0; i< tokens.length; i++) {\\r\\n            uint id = tokens[i].tokenId;\\r\\n            uint amount = tokens[i].balances;\\r\\n            tokens[i].balances -= amount;\\r\\n            NFT.safeTransferFrom(address(this), msg.sender, id, amount, \\\"0x0\\\");\\r\\n            emit WithdrawnNFT(msg.sender, id, amount);\\r\\n        }\\r\\n        totalNFTStrengthPerUser[msg.sender] = 0;\\r\\n    }\\r\\n\\r\\n    function withdrawNDR() public {\\r\\n        require(block.timestamp > startTime + battleDuration, \\\"The battle has not been ended\\\");\\r\\n        uint ndrAmount = totalNDRAmountPerUser[msg.sender];\\r\\n        totalNDRAmountPerUser[msg.sender] -= ndrAmount;\\r\\n        NDR.transfer(msg.sender, ndrAmount);\\r\\n        emit WithdrawnNDR(msg.sender, ndrAmount);\\r\\n    }\\r\\n\\r\\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public pure virtual returns (bytes4) {\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function seize(address to) external onlyOwner {\\r\\n        uint amount = address(this).balance;\\r\\n        payable(to).transfer(amount);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NDR\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"BoughtNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NDRStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NFTStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawnNDR\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawnNFT\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NDR\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"acceptableIdTeam\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"battleFinishDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"buyNewNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NDR\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"}],\"name\":\"changeAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayHashPerTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dayHashPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBattleDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNftFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"getTeamDayHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"getTeamHashResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"getTeamNDRAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"getTeamTotalNFTStrength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDayHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserHashResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTotalNFTStrength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastCheckTimePerTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastCheckTimePerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftTokenMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balances\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"percentMultiplierPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playersCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pureNFTStrengthPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"seize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"selectTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setBattleDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setNftFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"setSupportedIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeNDR\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"stakeNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBattle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamIdPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalHashPerTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalHashPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalNDRAmountPerTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalNDRAmountPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalNFTStrengthPerTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalNFTStrengthPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawNDR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Battle","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000739763a258640919981f9ba610ae65492455be5300000000000000000000000089ee76cc25fcbf1714ed575faa6a10202b71c26a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}