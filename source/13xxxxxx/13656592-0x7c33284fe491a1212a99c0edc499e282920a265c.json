{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dungeonsGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n\\n/// @title Simple map generator that spits out procedural dungeons\\n\\n/*****************************************************\\n0000000                                        0000000\\n0001100  Crypts and Caverns                    0001100\\n0001100     9000 generative on-chain dungeons  0001100\\n0003300                                        0003300\\n*****************************************************/\\n\\npragma solidity ^0.8.0;\\n\\nimport { IDungeons } from './interfaces/IDungeons.sol';\\n\\ncontract dungeonsGenerator {\\n\\n    struct EntityData {\\n        uint8[] x;\\n        uint8[] y;\\n        uint8[] entityType; // 0-255\\n    }\\n\\n    struct Settings {\\n            uint256 size;      // Size of dungeon (e.g. 9 -> 9x9)\\n            uint256 length;     // Number of uint256 arrays we need\\n            uint256 seed;\\n            uint256 counter;   // Increment this to make sure we always get a unique value back from random()\\n    }\\n\\n\\n    struct RoomSettings {   // Helper struct so we don't run out of variables\\n        uint256 minRooms;\\n        uint256 maxRooms;\\n        uint256 minRoomSize;\\n        uint256 maxRoomSize;\\n    }\\n\\n    struct Room {\\n        // Used for passing rooms around\\n        uint256 x;    // Top left corner x\\n        uint256 y;    // Top left corner y\\n        uint256 width;\\n        uint256 height;\\n    }\\n\\n    // Constants for each direction (for caverns dungeons\\n    int8[] directionsX = [int8(-1), int8(0), int8(1), int8(0)];    // Left, Up, Right, Down\\n    int8[] directionsY = [int8(0), int8(1), int8(0), int8(-1)];    // Left, Up, Right, Down\\n\\n    /** \\n    * @dev Returns a series of integers with each byte representing a tile on a map starting at 0,0 \\n    * Example: bytes private layout = 0x11111111111111111100110110101011111111011111001111  // Placeholder dungeon layout\\n    */\\n    function getLayout(uint256 seed, uint256 size) external view returns (bytes memory, uint8) {\\n        Settings memory settings = Settings(size, getLength(size), seed, 0);\\n        uint8 structure;\\n        if(uint256(random(settings.seed << settings.counter++, 0, 100)) > 30) {\\n            // Room-based dungeon\\n            structure = 0;\\n            \\n            // Generate Rooms\\n            (Room[] memory rooms, uint256[] memory floor) = generateRooms(settings);\\n\\n            // Generate Hallways\\n            uint256[] memory hallways = generateHallways(settings, rooms);\\n            \\n            // Combine floor and hallway tiles\\n            return (toBytes(addBits(floor, hallways)), structure);  \\n        } else {\\n            // Caverns-based dungeon\\n            structure = 1;\\n            uint256[] memory cavern = generateCavern(settings);\\n            return(toBytes(cavern), structure);\\n        }\\n    }\\n\\n    /** \\n    * @dev Returns a series of integers with each byte representing a tile on a map starting at 0,0 \\n    * Example: bytes private layout = 0x11111111111111111100110110101011111111011111001111  // Placeholder dungeon layout\\n    */\\n    function getEntities(uint256 seed, uint256 size) external view returns (uint8[] memory, uint8[] memory, uint8[] memory) {\\n        /* Generate entities and shove them into arrays */\\n        (uint256[] memory points, uint256[] memory doors) = generateEntities(seed, size);\\n       \\n        return parseEntities(size, points, doors);\\n    }\\n\\n    /** \\n    * @dev Returns a byte array with each bit representing an entity tile on a map (e.g. point or doors) starting at 0,0 \\n    * Example: bytes private layout = 0x11111111111111111100110110101011111111011111001111  // Placeholder dungeon layout\\n    */\\n    function getEntitiesBytes(uint256 seed, uint256 size) external view returns (bytes memory, bytes memory) {\\n        (uint256[] memory points, uint256[] memory doors) = generateEntities(seed, size);\\n        return (toBytes(points), toBytes(doors));\\n    }\\n\\n    /** \\n    * @dev Returns a byte array with each bit representing a point of interest on a map starting at 0,0 \\n    * Example: bytes private points = 0x11111111111111111100110110101011111111011111001111 \\n    */\\n    function getPoints(uint256 seed, uint256 size) external view returns (bytes memory, uint256 numPoints) {\\n        (uint256[] memory points, ) = generateEntities(seed, size);\\n        return (toBytes(points), count(points));\\n    }\\n\\n    /** \\n    * @dev Returns a byte array with each bit representing an door on a map starting at 0,0 \\n    * Example: bytes private doors = 0x11111111111111111100110110101011111111011111001111 \\n    */\\n    function getDoors(uint256 seed, uint256 size) external view returns (bytes memory, uint256 numDoors) {\\n        ( , uint256[] memory doors) = generateEntities(seed, size);\\n        return (toBytes(doors), count(doors));\\n    }\\n\\n\\n\\n    /* Runs through dungeon generation and lays out entities */\\n    function generateEntities(uint256 seed, uint256 size) internal view returns (uint256[] memory, uint256[] memory ) {\\n        /* Generate base info */\\n        Settings memory settings = Settings(size, getLength(size), seed, 0);\\n\\n        if(uint256(random(settings.seed + settings.counter++, 0, 100)) > 30) {\\n            // Generate Rooms (where we can place points of interest)\\n            (Room[] memory rooms, uint256[] memory floor) = generateRooms(settings);\\n            \\n            // Generate Hallways\\n            uint256[] memory hallways = generateHallways(settings, rooms);\\n            \\n            // Remove floor tiles from hallways: hallways & ~(floor); \\n            hallways = subtractBits(hallways, floor);\\n\\n            // Generate entities\\n            // Make sure we don't process an empty array (rooms will never be empty but hallways can)\\n            uint256[] memory hallwayPoints = count(hallways) > 0 ? generatePoints(settings, hallways, 40 / sqrt(count(hallways))) : new uint256[](hallways.length);    // Return empty map if hallways are empty\\n            return(generatePoints(settings, floor, 12 / sqrt(settings.size - 6)), hallwayPoints); \\n        } else {\\n            // Caverns-based dungeon \\n            uint256[] memory cavern = generateCavern(settings);\\n            uint256 numTiles = count(cavern);\\n\\n            // Feed it to doors and points (because everything is a hallway)\\n            uint256[] memory points = generatePoints(settings, cavern, 12 / sqrt(numTiles - 6));\\n            uint256[] memory doors = generatePoints(settings, cavern, 40 / sqrt(numTiles));\\n\\n            subtractBits(points, doors);    // De-dupe and favor points over doors: points & ~(door);\\n            return(points, doors);\\n        }\\n    }\\n\\n    \\n    function generateRooms(Settings memory settings) internal pure returns(Room[] memory, uint256[] memory) {\\n        // Setup constraints for creating rooms (e.g. minRoomSize)\\n\\n        RoomSettings memory roomSettings = RoomSettings(settings.size / 3, settings.size / 1, 2, settings.size / 3);\\n        \\n        uint256[] memory floor = new uint256[](settings.length); // For this implementation we only need a length of 3\\n        \\n        // How many rooms should we create?\\n        uint256 numRooms = uint256(random(settings.seed + settings.counter++, roomSettings.minRooms, roomSettings.maxRooms));\\n\\n        Room[] memory rooms = new Room[](numRooms);\\n\\n        uint256 safetyCheck = 256;   // Safety check in case we get stuck trying to place un placeable rooms\\n\\n        while(numRooms > 0) {\\n            bool valid = true;     // Is this a valid room placement? (default to true to save calculations below)\\n            Room memory current = Room(0, 0, uint256(random(settings.seed + settings.counter++, roomSettings.minRoomSize, roomSettings.maxRoomSize)), uint8(random(settings.seed + settings.counter++, roomSettings.minRoomSize, roomSettings.maxRoomSize)));\\n            // Pick a random width and height for the room\\n\\n            // Pick a random location for the room (we only need top/left because we get bottom right from w/h)\\n            current.x = uint256(random(settings.seed + settings.counter++, 1, settings.size-1 - current.width));\\n            current.y = uint256(random(settings.seed + settings.counter++, 1, settings.size-1 - current.height));\\n\\n            if(rooms[0].x != 0) {    // We can't check for non-empty array in Solidity so this is the closest thing we can check\\n                // There is at least one room so we need to check against current list of rooms to make sure there's no overlap\\n\\n                for(uint256 i = 0; i < rooms.length - numRooms; i++) {\\n                    // Check if the current position fits within an existing room\\n                    if(rooms[i].x-1 < current.x+current.width && rooms[i].x+rooms[i].width+1 > current.x && rooms[i].y-1 < current.x+current.height && rooms[i].y+rooms[i].height > current.y) {\\n                        valid = false;   // We've detected overlap, flag so we don't place a room here\\n                    }\\n                }\\n            }\\n\\n            // We found a room without overlap, let's place it!\\n            if(valid) {\\n                rooms[rooms.length - numRooms] = current;\\n                // Update floor tiles\\n                for(uint256 y = current.y; y < current.y+current.height; y++) {\\n                    for(uint256 x = current.x; x < current.x+current.width; x++) {\\n                        floor = setBit(floor, y*settings.size+x);   // Populate each bit of the room (from room[i]y -> room[i]y+h) to 1\\n                    }\\n                }\\n\\n                numRooms--;\\n            }\\n\\n            if(safetyCheck == 0) {  // Make sure we don't enter an infinite loop trying to place rooms w/ no space\\n                break;\\n            }\\n\\n            safetyCheck--;  \\n\\n        }\\n\\n        return (rooms, floor);\\n    }\\n\\n    function generateCavern(Settings memory settings) internal view returns (uint256[] memory) {\\n    // Tunneling - creates caves, mountains, etc.\\n        uint256[] memory cavern = new uint256[](settings.length); // For this app we only need a length of 2;  // Start with all walls (blank map)\\n        uint256 lastDirection;\\n        uint256 nextDirection;\\n\\n        uint256 x;\\n        uint256 y;\\n\\n        // Cut out holes\\n        uint256 holes = settings.size / 2;\\n\\n        for(uint256 i = 0; i < holes; i++) {\\n            // Pick a randaom starting location\\n            x = uint256(random(settings.seed << settings.counter++, 0, settings.size));\\n            y = uint256(random(settings.seed << settings.counter++, 0, settings.size));\\n        \\n            do {\\n                // Cut current spot out of walls\\n                setBit(cavern, y*settings.size + x);\\n\\n                if(lastDirection == 0) {\\n                    // This is our first time through, pick a random direction\\n                    nextDirection = uint256(random(settings.seed << settings.counter++, 1, 4));\\n                    lastDirection = nextDirection;\\n                } else {\\n                    // We have a last direction so use weighted probability to determine where to go next\\n                    uint256 directionSeed = uint256(random(settings.seed << settings.counter++, 0, 100));\\n                    \\n                    if(directionSeed <= 25) {\\n                        // Turn right\\n                        if(lastDirection == 3) {\\n                            nextDirection = 0;  // (go back to first direction in our aray to avoid overflows)\\n                        } else {\\n                            nextDirection = lastDirection + 1;\\n                        }\\n                    } else if(directionSeed <= 50) {\\n                        // Turn left\\n                        if(lastDirection == 0) {\\n                            nextDirection = 3;  // (go to the last direction in our array to avoid overflow)\\n                        } else {\\n                            nextDirection = lastDirection - 1;\\n                        }\\n                    } else {\\n                        // Keep moving forward in the same direction\\n                        nextDirection = lastDirection;\\n                    } \\n                }\\n   \\n                // if((x != 0 && nextDirection != 0) || (y != 0 && nextDirection != 3) || (x != settings.size && nextDirection != 1) || (y != settings.size && nextDirection != 1)) {\\n                    x = getDirection(x, directionsX[nextDirection]);\\n                    y = getDirection(y, directionsY[nextDirection]);\\n                // } \\n            } while (x > 0 && y > 0 && x < settings.size && y < settings.size); // Stop when we hit an edge\\n\\n        }\\n\\n        return(cavern);\\n    }\\n\\n    function generateHallways(Settings memory settings, Room[] memory rooms) internal pure returns(uint256[] memory) {\\n    // Connect each room with a hallway so we don't have hanging/floating rooms\\n        // Number of hallways is always 1 less than number of rooms\\n        uint256[] memory hallTiles = new uint256[](settings.length); // For this app we only need a length of 2;\\n\\n        // Only place hallways if we have more than one         \\n        if(rooms.length > 1) {\\n            \\n            // Set first room as 'previous' (because we have to connect two rooms together)\\n            uint256 previousX = rooms[0].x + (rooms[0].width / 2);\\n            uint256 previousY = rooms[0].y + (rooms[0].height / 2);\\n\\n            for(uint256 i = 1; i < rooms.length; i++) {\\n                uint256 currentX = rooms[i].x + (rooms[i].width / 2);\\n                uint256 currentY = rooms[i].y + (rooms[i].height / 2);\\n\\n                // Figure out what type of hallway to place\\n                if(currentX == previousX) {\\n                    // Rooms are lined up, make a vertical straight hallway\\n                    hallTiles = vHallway(settings.size, currentY, previousY, previousX, hallTiles);\\n                } else if(currentY == previousY) {\\n                    // Rooms are lined up, make a horizontal straight hallway\\n                    hallTiles = hHallway(settings.size, currentX, previousX, previousY, hallTiles);\\n                } else {\\n                    // Rooms aren't lined up so we need to draw two hallways\\n                    // Flip a coin to decide which we do first\\n\\n                    // We need two hallways (w/ right angle)\\n                    if(random(settings.seed + settings.counter++, 1, 2) == 2) {\\n                        hallTiles = hHallway(settings.size, currentX, previousX, previousY, hallTiles);\\n                        hallTiles = vHallway(settings.size, previousY, currentY, currentX, hallTiles);\\n                    } else {\\n                        // Vertical first\\n                        hallTiles = vHallway(settings.size, currentY, previousY, previousX, hallTiles);\\n                        hallTiles = hHallway(settings.size, previousX, currentX, currentY, hallTiles);\\n                    }\\n                }\\n\\n                previousX = currentX; // Process the next room\\n                previousY = currentY;\\n            }\\n        }\\n\\n        return hallTiles;\\n    }\\n\\n    function vHallway(uint256 size, uint256 y1, uint256 y2, uint256 x, uint256[] memory hallTiles) internal pure returns(uint256[] memory) {\\n        // Draw a vertical tunnel from the center of one room to another (so x is always the same)\\n        uint256 min = minimum(y1, y2);\\n        uint256 max = maximum(y1, y2);\\n\\n        for(uint256 y = min; y < max; y++) {\\n            // Place individual tiles\\n            hallTiles = setBit(hallTiles, (y*size)+x);      // Place a '0' for each hallway tile.\\n        }\\n        \\n        return hallTiles;\\n    }\\n\\n     function hHallway(uint256 size, uint256 x1, uint256 x2, uint256 y, uint256[] memory hallTiles) internal pure returns(uint256[] memory ) {\\n        // Draw a horizontal tunnel from the center of one room to another (so y is always the same)\\n        uint256 min = minimum(x1, x2);\\n        uint256 max = maximum(x1, x2);\\n\\n        for(uint256 x = min; x < max; x++) {\\n            // Place individual tiles\\n            hallTiles = setBit(hallTiles, (y*size)+x);      // Place a '0' for each hallway tile.\\n        }\\n        \\n        return hallTiles;\\n    }\\n\\n    function generatePoints(Settings memory settings, uint256[] memory map, uint256 probability) internal pure returns(uint256[] memory) {\\n        uint256[] memory points = new uint256[](settings.length);\\n        \\n        // Calculate max points based on floor tiles\\n        uint256 prob = random(settings.seed + settings.counter++, 0, probability);\\n\\n        if(prob == 0) {\\n            prob = 1;   // Fix to avoid zero probability because solidity rounds down, not up so we do\\n        }\\n        \\n        uint256 counter = 0;\\n        // Loop through each tile on the map\\n        while(counter < settings.size ** 2) {\\n            // Check if this is a floor tile (vs a wall)\\n            if(getBit(map, counter) == 1) {\\n                uint256 rand = random(settings.seed + settings.counter++, 0, 100);\\n                if(rand <= prob) {\\n                    points = setBit(points, counter);\\n                }\\n            }\\n            counter++;\\n        }\\n\\n        return(points);\\n    }\\n\\n    function countEntities(uint8[] memory entities) external pure returns(uint256, uint256) {\\n        uint256 points = 0;\\n        uint256 doors = 0;\\n        for(uint256 i = 0; i < entities.length; i++) {\\n            if(entities[i] == 0) {\\n                points++;\\n            } else {\\n                doors++;\\n            }\\n        }\\n        return(points, doors);\\n    }\\n\\n    function parseEntities(uint256 size, uint256[] memory points, uint256[] memory doors) private pure returns(uint8[] memory, uint8[] memory, uint8[] memory) {\\n        // Iterate through each map and returns an array for each entitiy type.\\n        // 0 - Doors\\n        // 1 - Points\\n        uint256 entityCount = count(doors)+count(points);\\n        uint8[] memory x = new uint8[](entityCount);\\n        uint8[] memory y = new uint8[](entityCount);\\n        uint8[] memory entityType = new uint8[](entityCount);\\n\\n        uint256 counter = 0;\\n\\n        // Shove points into arrays so we can return them\\n        for(uint256 _y = 0; _y < size; _y++) {\\n            for(uint256 _x = 0; _x < size; _x++) {\\n                if(getBit(doors, counter) == 1) {\\n                    x[entityCount-1] = uint8(_x);\\n                    y[entityCount-1] = uint8(_y);\\n                    entityType[entityCount-1] = 0;   // Hardcoded for doors\\n                    entityCount--;\\n                }\\n\\n                if(getBit(points, counter) == 1) {\\n                    x[entityCount-1] = uint8(_x);\\n                    y[entityCount-1] = uint8(_y);\\n                    entityType[entityCount-1] = 1;   // Hardcoded for points\\n                    entityCount--;\\n                }\\n\\n                counter++;\\n            }\\n        }\\n\\n        return(x, y, entityType);\\n    }\\n    \\n\\n    /* Utility Functions */\\n    /* Bitwise Helper Functions (credit: cjpais) */\\n    function getBit(uint256[] memory map, uint256 position) internal pure returns(uint256) {\\n    // Returns whether a bit is set or off at a given position in our map\\n        (uint256 quotient, uint256 remainder) = getDivided(position, 256);\\n        require(position <= 255 + (quotient * 256));\\n        return (map[quotient] >> (255 - remainder)) & 1;\\n    }\\n\\n    function setBit(uint256[] memory map, uint256 position) internal pure returns(uint256[] memory) {\\n    // Writes a wall bit (1) at a given position and returns the updated map\\n        (uint256 quotient, uint256 remainder) = getDivided(position, 256);\\n        require(position <= 255 + (quotient * 256));\\n        map[quotient] = map[quotient] | (1 << (255 - remainder));\\n\\n        return (map);\\n    }\\n\\n    function addBits(uint256[] memory first, uint256[] memory second) internal pure returns(uint256[] memory) {\\n    // Combines two maps by 'OR'ing the two together\\n        require(first.length == second.length);\\n\\n        for (uint256 i = 0; i < first.length; i++) {\\n            first[i] = first[i] | second[i];\\n        }\\n\\n        return first;\\n    }\\n\\n    function subtractBits(uint256[] memory first, uint256[] memory second) internal pure returns(uint256[] memory) {\\n    // Removes the second map from the first by 'AND'ing the two together\\n        require(first.length == second.length);\\n\\n        for (uint256 i = 0; i < first.length; i++) {\\n            first[i] = first[i] & ~(second[i]);\\n        }\\n\\n        return first;\\n    }\\n\\n    function toBytes(uint256[] memory map) internal pure returns (bytes memory) {\\n    // Combines two maps into a single bytes array to be returned \\n        bytes memory output;\\n\\n        for (uint256 i = 0; i < map.length; i++) {\\n            output = abi.encodePacked(output, map[i]);\\n        }\\n\\n        return output;\\n    } \\n\\n    function count(uint256[] memory map) internal pure returns(uint256) {\\n    // Function to count the total number of set bits in input (similar to an array .length)\\n    // Uses Brian Kernighans algorithm\\n\\n        // Make a copy of the map so we don't clobber the original\\n        uint256 curr;\\n        uint256 result = 0;\\n\\n        for (uint256 i = 0; i < map.length; i++) {\\n            curr = map[i];\\n\\n            while (curr != 0) {\\n                curr = curr & (curr - 1);\\n                result++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function getDivided(uint256 numerator, uint256 denominator) public pure returns (uint256 quotient, uint256 remainder) {\\n    // Divide - Return quotient and remainder\\n        require(denominator > 0);\\n        quotient = numerator / denominator;\\n        remainder = numerator - denominator * quotient;\\n    }\\n\\n    /* Dungeon directions */\\n    function getDirection(uint256 pos, int8 direction) internal pure returns (uint256) {\\n    // Helper function to map directions (because  uint256/int8 can't be added / subtracted)\\n        if(direction == 0) {\\n            return(pos);\\n        } else if(direction == 1) {\\n            return(pos+1);\\n        } else {    // (direction == -1)\\n            if(pos == 0) {\\n                return(0);  // Fix in case we try to move outside the bounds\\n            }\\n            return(pos-1);\\n        }\\n    }\\n\\n    function getLength(uint256 size) public pure returns (uint256) {\\n    // Determine how many uint256's we need for our array\\n        return ((size ** 2) / 256) + 1;    // Always add 1 because solidity rounds down\\n    }\\n\\n    /*  RNG and Math Helper Functions */\\n    function random(uint256 input, uint256 min, uint256 max) internal pure returns (uint256) {\\n    // Returns a random (deterministic) seed between 0-range based on an arbitrary set of inputs\\n        uint256 num;\\n\\n        if(max != min) {\\n            num = max - min;\\n        } else {\\n            // max/min being the same causes modulo by zero error \\n            num = 1;\\n        }\\n        \\n        uint256 output = uint256(keccak256(abi.encodePacked(input))) % (num) + min;\\n        return output;\\n    }\\n\\n    function maximum(uint256 one, uint256 two) internal pure returns(uint256 max) {\\n    // Return the larger of two numbers\\n        if(one > two) {\\n            return one;\\n        } else if(one <= two) {\\n            return two;\\n        }\\n    }\\n    function minimum(uint256 one, uint256 two) internal pure returns(uint256 min) {\\n    // Return the smaller of two numbers\\n        if(one > two) {\\n            return two;\\n        } else if(one <= two) {\\n            return one;\\n        }\\n    }\\n\\n    function abs(uint256 one, uint256 two) internal pure returns(uint256 result) {\\n    // Returns the absolute value of subtracting two numbers\\n        if(one >= two) {\\n            return(one - two);\\n        } else {\\n            return(two - one);\\n        }\\n    }\\n\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n    // Returns the square root of a number\\n        uint256 z = (x + 1) / 2;\\n        uint256 y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n        return y;\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT license\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IDungeons.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for Crypts and Caverns\\n\\n/*****************************************************\\n0000000                                        0000000\\n0001100  Crypts and Caverns                    0001100\\n0001100     9000 generative on-chain dungeons  0001100\\n0003300                                        0003300\\n*****************************************************/\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDungeons {\\n    struct Dungeon {\\n        uint8 size;\\n        uint8 environment;\\n        uint8 structure;  // crypt or cavern\\n        uint8 legendary;\\n        bytes layout;\\n        EntityData entities;\\n        string affinity;\\n        string dungeonName;\\n    }\\n\\n    struct EntityData {\\n        uint8[] x;\\n        uint8[] y;\\n        uint8[] entityType;\\n    }\\n\\n    function claim(uint256 tokenId) external payable;\\n    function claimMany(uint256[] memory tokenArray) external payable;\\n    function ownerClaim(uint256 tokenId) external payable;\\n    function mint() external payable;\\n    function openClaim() external;\\n    function withdraw(address payable recipient, uint256 amount) external;\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n    function getLayout(uint256 tokenId) external view returns (bytes memory);\\n    function getSize(uint256 tokenId) external view returns (uint8);\\n    function getEntities(uint256 tokenId) external view returns (uint8[] memory, uint8[] memory, uint8[] memory);\\n    function getEnvironment(uint256 tokenId) external view returns (uint8);\\n    function getName(uint256 tokenId) external view returns (string memory);\\n    function getNumPoints(uint256 tokenId) external view returns (uint256);\\n    function getNumDoors(uint256 tokenId) external view returns (uint256);\\n    function getSvg(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"entities\",\"type\":\"uint8[]\"}],\"name\":\"countEntities\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"getDivided\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quotient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainder\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getDoors\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"numDoors\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getEntities\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getEntitiesBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getLayout\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getPoints\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"numPoints\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"dungeonsGenerator","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}