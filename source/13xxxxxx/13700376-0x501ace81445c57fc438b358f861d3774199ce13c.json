{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./Factory.sol\\\";\\nimport \\\"./Governable.sol\\\";\\nimport \\\"./interface/IBondTeller.sol\\\";\\nimport \\\"./interface/IBondDepository.sol\\\";\\n\\n/**\\n * @title BondDepository\\n * @author solace.fi\\n * @notice Factory and manager of [`Bond Tellers`](./BondTellerBase).\\n */\\ncontract BondDepository is IBondDepository, Factory, Governable {\\n\\n    // pass these when initializing tellers\\n    address internal _solace;\\n    address internal _xsolace;\\n    address internal _pool;\\n    address internal _dao;\\n\\n    // track tellers\\n    mapping(address => bool) internal _isTeller;\\n\\n    /**\\n     * @notice Constructs the BondDepository contract.\\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\\n     * @param solace_ Address of [**SOLACE**](./solace).\\n     * @param xsolace_ Address of [**xSOLACE**](./xsolace).\\n     * @param pool_ Address of underwriting pool.\\n     * @param dao_ Address of the DAO.\\n     */\\n    constructor(address governance_, address solace_, address xsolace_, address pool_, address dao_) Governable(governance_) {\\n        _setAddresses(solace_, xsolace_, pool_, dao_);\\n    }\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Native [**SOLACE**](./SOLACE) Token.\\n    function solace() external view override returns (address solace_) {\\n        return _solace;\\n    }\\n\\n    /// @notice [**xSOLACE**](./xSOLACE) Token.\\n    function xsolace() external view override returns (address xsolace_) {\\n        return _xsolace;\\n    }\\n\\n    /// @notice Underwriting pool contract.\\n    function underwritingPool() external view override returns (address pool_) {\\n        return _pool;\\n    }\\n\\n    /// @notice The DAO.\\n    function dao() external view override returns (address dao_) {\\n        return _dao;\\n    }\\n\\n    /// @notice Returns true if the address is a teller.\\n    function isTeller(address teller) external view override returns (bool isTeller_) {\\n        return _isTeller[teller];\\n    }\\n\\n    /***************************************\\n    TELLER MANAGEMENT FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Creates a new [`BondTeller`](./BondTellerBase).\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param name The name of the bond token.\\n     * @param governance The address of the teller's [governor](/docs/protocol/governance).\\n     * @param impl The address of BondTeller implementation.\\n     * @param principal address The ERC20 token that users give.\\n     * @return teller The address of the new teller.\\n     */\\n    function createBondTeller(\\n        string memory name,\\n        address governance,\\n        address impl,\\n        address principal\\n    ) external override onlyGovernance returns (address teller) {\\n        teller = _deployMinimalProxy(impl);\\n        IBondTeller(teller).initialize(name, governance, _solace, _xsolace, _pool, _dao, principal, address(this));\\n        _isTeller[teller] = true;\\n        emit TellerAdded(teller);\\n        return teller;\\n    }\\n\\n    /**\\n     * @notice Creates a new [`BondTeller`](./BondTellerBase).\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param name The name of the bond token.\\n     * @param governance The address of the teller's [governor](/docs/protocol/governance).\\n     * @param impl The address of BondTeller implementation.\\n     * @param salt The salt for CREATE2.\\n     * @param principal address The ERC20 token that users give.\\n     * @return teller The address of the new teller.\\n     */\\n    function create2BondTeller(\\n        string memory name,\\n        address governance,\\n        address impl,\\n        bytes32 salt,\\n        address principal\\n    ) external override onlyGovernance returns (address teller) {\\n        teller = _deployMinimalProxy(impl, salt);\\n        IBondTeller(teller).initialize(name, governance, _solace, _xsolace, _pool, _dao, principal, address(this));\\n        _isTeller[teller] = true;\\n        emit TellerAdded(teller);\\n        return teller;\\n    }\\n\\n    /**\\n     * @notice Adds a teller.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param teller The teller to add.\\n     */\\n    function addTeller(address teller) external override onlyGovernance {\\n        _isTeller[teller] = true;\\n        emit TellerAdded(teller);\\n    }\\n\\n    /**\\n     * @notice Adds a teller.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param teller The teller to remove.\\n     */\\n    function removeTeller(address teller) external override onlyGovernance {\\n        _isTeller[teller] = false;\\n        emit TellerRemoved(teller);\\n    }\\n\\n    /**\\n     * @notice Sets the parameters to pass to new tellers.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param solace_ Address of [**SOLACE**](./solace).\\n     * @param xsolace_ Address of [**xSOLACE**](./xsolace).\\n     * @param pool_ Address of underwriting pool.\\n     * @param dao_ Address of the DAO.\\n     */\\n    function setAddresses(address solace_, address xsolace_, address pool_, address dao_) external override onlyGovernance {\\n        _setAddresses(solace_, xsolace_, pool_, dao_);\\n    }\\n\\n    /**\\n     * @notice Sets the parameters to pass to new tellers.\\n     * @param solace_ Address of [**SOLACE**](./solace).\\n     * @param xsolace_ Address of [**xSOLACE**](./xsolace).\\n     * @param pool_ Address of underwriting pool.\\n     * @param dao_ Address of the DAO.\\n     */\\n    function _setAddresses(address solace_, address xsolace_, address pool_, address dao_) internal {\\n        require(solace_ != address(0x0), \\\"zero address solace\\\");\\n        require(xsolace_ != address(0x0), \\\"zero address xsolace\\\");\\n        require(pool_ != address(0x0), \\\"zero address pool\\\");\\n        require(dao_ != address(0x0), \\\"zero address dao\\\");\\n        _solace = solace_;\\n        _xsolace = xsolace_;\\n        _pool = pool_;\\n        _dao = dao_;\\n        emit ParamsSet(solace_, xsolace_, pool_, dao_);\\n    }\\n\\n    /***************************************\\n    FUND MANAGEMENT FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sends **SOLACE** to the teller.\\n     * Can only be called by tellers.\\n     * @param amount The amount of **SOLACE** to send.\\n     */\\n    function pullSolace(uint256 amount) external override {\\n        // this contract must hold solace\\n        // can only be called by authorized minters\\n        require(_isTeller[msg.sender], \\\"!teller\\\");\\n        // transfer\\n        SafeERC20.safeTransfer(IERC20(_solace), msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Sends **SOLACE** to an address.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param dst Destination to send **SOLACE**.\\n     * @param amount The amount of **SOLACE** to send.\\n     */\\n    function returnSolace(address dst, uint256 amount) external override onlyGovernance {\\n        SafeERC20.safeTransfer(IERC20(_solace), dst, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title Factory for arbitrary code deployment using the \\\"CREATE\\\" and \\\"CREATE2\\\" opcodes\\n */\\nabstract contract Factory {\\n    bytes private constant MINIMAL_PROXY_INIT_CODE_PREFIX =\\n        hex\\\"3d602d80600a3d3981f3_363d3d373d3d3d363d73\\\";\\n    bytes private constant MINIMAL_PROXY_INIT_CODE_SUFFIX =\\n        hex\\\"5af43d82803e903d91602b57fd5bf3\\\";\\n\\n    event ContractDeployed(address indexed deployment);\\n\\n    /**\\n     * @notice deploy an EIP1167 minimal proxy using \\\"CREATE\\\" opcode\\n     * @param target implementation contract to proxy\\n     * @return minimalProxy address of deployed proxy\\n     */\\n    function _deployMinimalProxy(address target) internal returns (address minimalProxy) {\\n        return _deploy(_generateMinimalProxyInitCode(target));\\n    }\\n\\n    /**\\n     * @notice deploy an EIP1167 minimal proxy using \\\"CREATE2\\\" opcode\\n     * @dev reverts if deployment is not successful (likely because salt has already been used)\\n     * @param target implementation contract to proxy\\n     * @param salt input for deterministic address calculation\\n     * @return minimalProxy address of deployed proxy\\n     */\\n    function _deployMinimalProxy(address target, bytes32 salt) internal returns (address minimalProxy) {\\n        return _deploy(_generateMinimalProxyInitCode(target), salt);\\n    }\\n\\n    /**\\n     * @notice calculate the deployment address for a given target and salt\\n     * @param target implementation contract to proxy\\n     * @param salt input for deterministic address calculation\\n     * @return deployment address\\n     */\\n    function calculateMinimalProxyDeploymentAddress(address target, bytes32 salt) public view returns (address) {\\n        return\\n            calculateDeploymentAddress(\\n                keccak256(_generateMinimalProxyInitCode(target)),\\n                salt\\n            );\\n    }\\n\\n    /**\\n     * @notice concatenate elements to form EIP1167 minimal proxy initialization code\\n     * @param target implementation contract to proxy\\n     * @return bytes memory initialization code\\n     */\\n    function _generateMinimalProxyInitCode(address target) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                MINIMAL_PROXY_INIT_CODE_PREFIX,\\n                target,\\n                MINIMAL_PROXY_INIT_CODE_SUFFIX\\n            );\\n    }\\n\\n    /**\\n     * @notice deploy contract code using \\\"CREATE\\\" opcode\\n     * @param initCode contract initialization code\\n     * @return deployment address of deployed contract\\n     */\\n    function _deploy(bytes memory initCode) internal returns (address deployment) {\\n        assembly {\\n            let encoded_data := add(0x20, initCode)\\n            let encoded_size := mload(initCode)\\n            deployment := create(0, encoded_data, encoded_size)\\n        }\\n        require(deployment != address(0), \\\"Factory: failed deployment\\\");\\n        emit ContractDeployed(deployment);\\n    }\\n\\n    /**\\n     * @notice deploy contract code using \\\"CREATE2\\\" opcode\\n     * @dev reverts if deployment is not successful (likely because salt has already been used)\\n     * @param initCode contract initialization code\\n     * @param salt input for deterministic address calculation\\n     * @return deployment address of deployed contract\\n     */\\n    function _deploy(bytes memory initCode, bytes32 salt) internal returns (address deployment) {\\n        assembly {\\n            let encoded_data := add(0x20, initCode)\\n            let encoded_size := mload(initCode)\\n            deployment := create2(0, encoded_data, encoded_size, salt)\\n        }\\n        require(deployment != address(0), \\\"Factory: failed deployment\\\");\\n        emit ContractDeployed(deployment);\\n    }\\n\\n    /**\\n     * @notice calculate the _deployMetamorphicContract deployment address for a given salt\\n     * @param initCodeHash hash of contract initialization code\\n     * @param salt input for deterministic address calculation\\n     * @return deployment address\\n     */\\n    function calculateDeploymentAddress(bytes32 initCodeHash, bytes32 salt) public view returns (address) {\\n        return\\n            address(\\n                uint160(\\n                    uint256(\\n                        keccak256(\\n                            abi.encodePacked(\\n                                hex\\\"ff\\\",\\n                                address(this),\\n                                salt,\\n                                initCodeHash\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"./interface/IGovernable.sol\\\";\\n\\n/**\\n * @title Governable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n   * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setPendingGovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./interface/ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ncontract Governable is IGovernable {\\n\\n    /***************************************\\n    GLOBAL VARIABLES\\n    ***************************************/\\n\\n    // Governor.\\n    address private _governance;\\n\\n    // governance to take over.\\n    address private _pendingGovernance;\\n\\n    bool private _locked;\\n\\n    /**\\n     * @notice Constructs the governable contract.\\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\\n     */\\n    constructor(address governance_) {\\n        require(governance_ != address(0x0), \\\"zero address governance\\\");\\n        _governance = governance_;\\n        _pendingGovernance = address(0x0);\\n        _locked = false;\\n    }\\n\\n    /***************************************\\n    MODIFIERS\\n    ***************************************/\\n\\n    // can only be called by governor\\n    // can only be called while unlocked\\n    modifier onlyGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _governance, \\\"!governance\\\");\\n        _;\\n    }\\n\\n    // can only be called by pending governor\\n    // can only be called while unlocked\\n    modifier onlyPendingGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _pendingGovernance, \\\"!pending governance\\\");\\n        _;\\n    }\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() external view override returns (address) {\\n        return _governance;\\n    }\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view override returns (address) {\\n        return _pendingGovernance;\\n    }\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view override returns (bool) {\\n        return _locked;\\n    }\\n\\n    /***************************************\\n    MUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external override onlyGovernance {\\n        _pendingGovernance = pendingGovernance_;\\n        emit GovernancePending(pendingGovernance_);\\n    }\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the pending governor.\\n     */\\n    function acceptGovernance() external override onlyPendingGovernance {\\n        // sanity check against transferring governance to the zero address\\n        // if someone figures out how to sign transactions from the zero address\\n        // consider the entirety of ethereum to be rekt\\n        require(_pendingGovernance != address(0x0), \\\"zero governance\\\");\\n        address oldGovernance = _governance;\\n        _governance = _pendingGovernance;\\n        _pendingGovernance = address(0x0);\\n        emit GovernanceTransferred(oldGovernance, _governance);\\n    }\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external override onlyGovernance {\\n        _locked = true;\\n        // intentionally not using address(0x0), see re-initialization exploit\\n        _governance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        _pendingGovernance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        emit GovernanceTransferred(msg.sender, address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n        emit GovernanceLocked();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IBondTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\n/**\\n * @title IBondTeller\\n * @author solace.fi\\n * @notice Base type of Bond Tellers.\\n *\\n * Bond tellers allow users to buy bonds. After vesting for `vestingTerm`, bonds can be redeemed for [**SOLACE**](./SOLACE) or [**xSOLACE**](./xSOLACE). Payments are made in `principal` which is sent to the underwriting pool and used to back risk.\\n *\\n * Bonds are represented as ERC721s, can be viewed with [`bonds()`](#bonds), and redeemed with [`redeem()`](#redeem).\\n */\\ninterface IBondTeller {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a bond is created.\\n    event CreateBond(uint256 bondID, uint256 principalAmount, address payoutToken, uint256 payoutAmount, uint256 maturation);\\n    /// @notice Emitted when a bond is redeemed.\\n    event RedeemBond(uint256 bondID, address recipient, address payoutToken, uint256 payoutAmount);\\n    /// @notice Emitted when deposits are paused.\\n    event Paused();\\n    /// @notice Emitted when deposits are unpaused.\\n    event Unpaused();\\n    /// @notice Emitted when terms are set.\\n    event TermsSet();\\n    /// @notice Emitted when fees are set.\\n    event FeesSet();\\n    /// @notice Emitted when fees are set.\\n    event AddressesSet();\\n\\n    /***************************************\\n    INITIALIZER\\n    ***************************************/\\n\\n    /**\\n     * @notice Initializes the teller.\\n     * @param name_ The name of the bond token.\\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\\n     * @param solace_ The SOLACE token.\\n     * @param xsolace_ The xSOLACE token.\\n     * @param pool_ The underwriting pool.\\n     * @param dao_ The DAO.\\n     * @param principal_ address The ERC20 token that users deposit.\\n     * @param bondDepo_ The bond depository.\\n     */\\n    function initialize(\\n        string memory name_,\\n        address governance_,\\n        address solace_,\\n        address xsolace_,\\n        address pool_,\\n        address dao_,\\n        address principal_,\\n        address bondDepo_\\n    ) external;\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    // BOND PRICE\\n\\n    /**\\n     * @notice Calculate the current price of a bond.\\n     * Assumes 1 SOLACE payout.\\n     * @return price_ The price of the bond measured in `principal`.\\n     */\\n    function bondPrice() external view returns (uint256 price_);\\n\\n    /**\\n     * @notice Calculate the amount of **SOLACE** or **xSOLACE** out for an amount of `principal`.\\n     * @param amountIn Amount of principal to deposit.\\n     * @param stake True to stake, false to not stake.\\n     * @return amountOut Amount of **SOLACE** or **xSOLACE** out.\\n     */\\n    function calculateAmountOut(uint256 amountIn, bool stake) external view returns (uint256 amountOut);\\n\\n    /**\\n     * @notice Calculate the amount of `principal` in for an amount of **SOLACE** or **xSOLACE** out.\\n     * @param amountOut Amount of **SOLACE** or **xSOLACE** out.\\n     * @param stake True to stake, false to not stake.\\n     * @return amountIn Amount of principal to deposit.\\n     */\\n    function calculateAmountIn(uint256 amountOut, bool stake) external view returns (uint256 amountIn);\\n\\n    /***************************************\\n    BONDER FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Redeem a bond.\\n     * Bond must be matured.\\n     * Redeemer must be owner or approved.\\n     * @param bondID The ID of the bond to redeem.\\n     */\\n    function redeem(uint256 bondID) external;\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Pauses deposits.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n    */\\n    function pause() external;\\n\\n    /**\\n     * @notice Unpauses deposits.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n    */\\n    function unpause() external;\\n\\n    /**\\n     * @notice Sets the addresses to call out.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param solace_ The SOLACE token.\\n     * @param xsolace_ The xSOLACE token.\\n     * @param pool_ The underwriting pool.\\n     * @param dao_ The DAO.\\n     * @param principal_ address The ERC20 token that users deposit.\\n     * @param bondDepo_ The bond depository.\\n     */\\n    function setAddresses(\\n        address solace_,\\n        address xsolace_,\\n        address pool_,\\n        address dao_,\\n        address principal_,\\n        address bondDepo_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IBondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title BondDepository\\n * @author solace.fi\\n * @notice Factory and manager of [`Bond Tellers`](./IBondTeller).\\n */\\ninterface IBondDepository {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a teller is added.\\n    event TellerAdded(address indexed teller);\\n    /// @notice Emitted when a teller is removed.\\n    event TellerRemoved(address indexed teller);\\n    /// @notice Emitted when the params are set.\\n    event ParamsSet(address solace, address xsolace, address pool, address dao);\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Native [**SOLACE**](./SOLACE) Token.\\n    function solace() external view returns (address solace_);\\n\\n    /// @notice [**xSOLACE**](./xSOLACE) Token.\\n    function xsolace() external view returns (address xsolace_);\\n\\n    /// @notice Underwriting pool contract.\\n    function underwritingPool() external view returns (address pool_);\\n\\n    /// @notice The DAO.\\n    function dao() external view returns (address dao_);\\n\\n    /// @notice Returns true if the address is a teller.\\n    function isTeller(address teller) external view returns (bool isTeller_);\\n\\n    /***************************************\\n    TELLER MANAGEMENT FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Creates a new [`BondTeller`](./IBondTeller).\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param name The name of the bond token.\\n     * @param governance The address of the teller's [governor](/docs/protocol/governance).\\n     * @param impl The address of BondTeller implementation.\\n     * @param principal address The ERC20 token that users give.\\n     * @return teller The address of the new teller.\\n     */\\n    function createBondTeller(\\n        string memory name,\\n        address governance,\\n        address impl,\\n        address principal\\n    ) external returns (address teller);\\n\\n    /**\\n     * @notice Creates a new [`BondTeller`](./IBondTeller).\\n     * @param name The name of the bond token.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param governance The address of the teller's [governor](/docs/protocol/governance).\\n     * @param impl The address of BondTeller implementation.\\n     * @param salt The salt for CREATE2.\\n     * @param principal address The ERC20 token that users give.\\n     * @return teller The address of the new teller.\\n     */\\n    function create2BondTeller(\\n        string memory name,\\n        address governance,\\n        address impl,\\n        bytes32 salt,\\n        address principal\\n    ) external returns (address teller);\\n\\n    /**\\n     * @notice Adds a teller.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param teller The teller to add.\\n     */\\n    function addTeller(address teller) external;\\n\\n    /**\\n     * @notice Adds a teller.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param teller The teller to remove.\\n     */\\n    function removeTeller(address teller) external;\\n\\n    /**\\n     * @notice Sets the parameters to pass to new tellers.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param solace_ Address of [**SOLACE**](./solace).\\n     * @param xsolace_ Address of [**xSOLACE**](./xsolace).\\n     * @param pool_ Address of underwriting pool.\\n     * @param dao_ Address of the DAO.\\n     */\\n    function setAddresses(address solace_, address xsolace_, address pool_, address dao_) external;\\n\\n    /***************************************\\n    FUND MANAGEMENT FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sends **SOLACE** to the teller.\\n     * Can only be called by tellers.\\n     * @param amount The amount of **SOLACE** to send.\\n     */\\n    function pullSolace(uint256 amount) external;\\n\\n    /**\\n     * @notice Sends **SOLACE** to an address.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param dst Destination to send **SOLACE**.\\n     * @param amount The amount of **SOLACE** to send.\\n     */\\n    function returnSolace(address dst, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title IGovernable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setPendingGovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ninterface IGovernable {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when pending Governance is set.\\n    event GovernancePending(address pendingGovernance);\\n    /// @notice Emitted when Governance is set.\\n    event GovernanceTransferred(address oldGovernance, address newGovernance);\\n    /// @notice Emitted when Governance is locked.\\n    event GovernanceLocked();\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() external view returns (address);\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view returns (address);\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view returns (bool);\\n\\n    /***************************************\\n    MUTATORS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external;\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the new governor.\\n     */\\n    function acceptGovernance() external;\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solace_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xsolace_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployment\",\"type\":\"address\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GovernanceLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"}],\"name\":\"GovernancePending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solace\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"xsolace\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"ParamsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"teller\",\"type\":\"address\"}],\"name\":\"TellerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"teller\",\"type\":\"address\"}],\"name\":\"TellerRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"teller\",\"type\":\"address\"}],\"name\":\"addTeller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"calculateDeploymentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"calculateMinimalProxyDeploymentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"principal\",\"type\":\"address\"}],\"name\":\"create2BondTeller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"teller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principal\",\"type\":\"address\"}],\"name\":\"createBondTeller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"teller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dao_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"teller\",\"type\":\"address\"}],\"name\":\"isTeller\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isTeller_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullSolace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"teller\",\"type\":\"address\"}],\"name\":\"removeTeller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"returnSolace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"solace_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xsolace_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao_\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingGovernance_\",\"type\":\"address\"}],\"name\":\"setPendingGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"solace_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underwritingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xsolace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"xsolace_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BondDepository","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"000000000000000000000000501ace0e8d16b92236763e2ded7ae3bc2dffa276000000000000000000000000501ace9c35e60f03a2af4d484f49f9b1efde9f40000000000000000000000000501ace5ac3af20f49d53242b6d208f3b91cfc4110000000000000000000000005efc0d9ee3223229ce3b53e441016efc5ba83435000000000000000000000000f075334df87f0a5d9fe6381b5035b60f384d6c2c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}