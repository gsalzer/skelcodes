{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PondGen1.sol\": {\r\n      \"content\": \"// contracts/PondGen1.sol\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ninterface IFrogGame {\\r\\n    function transferFrom(address from, address to, uint tokenId) external;\\r\\n}\\r\\ninterface ITadpole {\\r\\n    function mintTo(address recepient, uint amount) external;\\r\\n    function transfer(address to, uint amount) external;\\r\\n} \\r\\n\\r\\ncontract Pond is IERC721Receiver, ReentrancyGuard, Pausable {\\r\\n    uint typeShift = 69000;\\r\\n\\r\\n    bytes32 entropySauce;\\r\\n    address constant nullAddress = address(0x0);\\r\\n\\r\\n    uint constant public tadpolePerDay = 5000 ether;\\r\\n    uint constant public tadpoleMax = 2000000000 ether;\\r\\n    \\r\\n    //tadpole claimed in total\\r\\n    uint internal _tadpoleClaimed;\\r\\n    //total rewards to be paid to every snake\\r\\n    uint snakeReward;\\r\\n\\r\\n    uint randomNounce=0;\\r\\n\\r\\n    address public owner;\\r\\n    IFrogGame internal frogGameContract;\\r\\n    ITadpole internal tadpoleContract;\\r\\n\\r\\n    uint[] internal snakesStaked;\\r\\n    uint[] internal frogsStaked;\\r\\n\\r\\n    uint internal _snakeTaxesCollected;\\r\\n    uint internal _snakeTaxesPaid;\\r\\n\\r\\n    bool public evacuationStarted;\\r\\n\\r\\n    // map staked tokens IDs to staker address\\r\\n    mapping(uint => address) stakedIdToStaker;\\r\\n    // map staker address to staked ID's array\\r\\n    mapping(address => uint[]) stakerToIds;\\r\\n    // map staked tokens IDs to last reward claim time\\r\\n    mapping(uint => uint) stakedIdToLastClaimTimestamp;\\r\\n    // map staked tokens IDs to their positions in stakerToIds and snakesStaked or frogsStaked\\r\\n    mapping(uint => uint[2]) stakedIdsToIndicies;\\r\\n    // map every staked snake ID to reward claimed\\r\\n    mapping(uint => uint) stakedSnakeToRewardPaid;\\r\\n    // keep track of block where action was performed\\r\\n    mapping(address => uint) callerToLastActionBlock;\\r\\n\\r\\n    constructor() {\\r\\n        owner=msg.sender;\\r\\n    }\\r\\n\\r\\n    //   _____ _        _    _             \\r\\n    //  / ____| |      | |  (_)            \\r\\n    // | (___ | |_ __ _| | ___ _ __   __ _ \\r\\n    //  \\\\___ \\\\| __/ _` | |/ / | '_ \\\\ / _` |\\r\\n    //  ____) | || (_| |   <| | | | | (_| |\\r\\n    // |_____/ \\\\__\\\\__,_|_|\\\\_\\\\_|_| |_|\\\\__, |\\r\\n    //                                __/ |\\r\\n    //                               |___/ \\r\\n\\r\\n    /// @dev Stake token\\r\\n    function stakeToPond(uint[] calldata tokenIds) external noCheaters nonReentrant whenNotPaused {\\r\\n        for (uint i=0;i<tokenIds.length;i++) {\\r\\n            if (tokenIds[i]==0) { continue; }\\r\\n            uint tokenId = tokenIds[i];\\r\\n\\r\\n            stakedIdToStaker[tokenId] = msg.sender;\\r\\n            stakedIdToLastClaimTimestamp[tokenId] = block.timestamp;\\r\\n            \\r\\n            uint stakerToIdsIndex = stakerToIds[msg.sender].length;\\r\\n            stakerToIds[msg.sender].push(tokenId);\\r\\n\\r\\n            uint stakedIndex;\\r\\n            if (tokenId > typeShift)  {\\r\\n                stakedSnakeToRewardPaid[tokenId]=snakeReward;\\r\\n                stakedIndex=snakesStaked.length;\\r\\n                snakesStaked.push(tokenId);\\r\\n            } else {\\r\\n                stakedIndex = frogsStaked.length;\\r\\n                frogsStaked.push(tokenId);\\r\\n            }\\r\\n            stakedIdsToIndicies[tokenId]=[stakerToIdsIndex, stakedIndex];\\r\\n            frogGameContract.transferFrom(msg.sender, address(this), tokenId);  \\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Claim reward by Id, unstake optionally \\r\\n    function _claimById(uint tokenId, bool unstake) internal {\\r\\n        address staker = stakedIdToStaker[tokenId];\\r\\n        require(staker!=nullAddress, \\\"Token is not staked\\\");\\r\\n        require(staker==msg.sender, \\\"You're not the staker\\\");\\r\\n\\r\\n        uint[2] memory indicies = stakedIdsToIndicies[tokenId];\\r\\n        uint rewards;\\r\\n\\r\\n        // unstake general\\r\\n        if (unstake) {\\r\\n            // Remove staker address from the map\\r\\n            stakedIdToStaker[tokenId] = nullAddress;\\r\\n            // Replace the element we want to remove with the last element of array\\r\\n            stakerToIds[msg.sender][indicies[0]] = stakerToIds[msg.sender][stakerToIds[msg.sender].length-1];\\r\\n            // Update moved element with new index\\r\\n            stakedIdsToIndicies[stakerToIds[msg.sender][stakerToIds[msg.sender].length-1]][0] = indicies[0];\\r\\n            // Remove last element\\r\\n            stakerToIds[msg.sender].pop();\\r\\n        }\\r\\n\\r\\n        // if token is snake\\r\\n        if (tokenId > typeShift) {\\r\\n            rewards=snakeReward-stakedSnakeToRewardPaid[tokenId];\\r\\n            _snakeTaxesPaid+=rewards;\\r\\n            stakedSnakeToRewardPaid[tokenId]=snakeReward;\\r\\n\\r\\n            if (unstake) {\\r\\n                stakedIdsToIndicies[snakesStaked[snakesStaked.length-1]][1]=indicies[1];\\r\\n                snakesStaked[indicies[1]]=snakesStaked[snakesStaked.length-1];\\r\\n                snakesStaked.pop();\\r\\n            }\\r\\n        // if token is frog\\r\\n        } else {\\r\\n            uint taxPercent = 20;\\r\\n            uint tax;\\r\\n            rewards = calculateRewardForFrogId(tokenId);\\r\\n            _tadpoleClaimed += rewards;\\r\\n\\r\\n            // if trying to unstake frog\\r\\n            if (unstake) {\\r\\n                //3 days requirement is active till there are $TOADPOLE left to mint\\r\\n                if (_tadpoleClaimed < tadpoleMax) {\\r\\n                    require(rewards >= 15000 ether, \\\"3 days worth tadpole required to leave the Pond\\\");\\r\\n                }\\r\\n\\r\\n                stakedIdsToIndicies[frogsStaked[frogsStaked.length-1]][1]=indicies[1];\\r\\n                frogsStaked[indicies[1]]=frogsStaked[frogsStaked.length-1];\\r\\n                frogsStaked.pop();\\r\\n\\r\\n                uint stealRoll = _randomize(_rand(), \\\"rewardStolen\\\", (rewards + randomNounce++)) % 10000;\\r\\n                // 50% chance to steal all tadpole accumulated by frog, 50% chance to steal nothing\\r\\n                taxPercent=stealRoll<5000?100:0;\\r\\n            }\\r\\n            if (snakesStaked.length>0)\\r\\n            {\\r\\n                tax = rewards * taxPercent / 100;\\r\\n                _snakeTaxesCollected+=tax;\\r\\n                rewards = rewards - tax;\\r\\n                snakeReward += tax / snakesStaked.length;\\r\\n            }\\r\\n        }\\r\\n        stakedIdToLastClaimTimestamp[tokenId]=block.timestamp;\\r\\n\\r\\n        if (rewards > 0) { tadpoleContract.transfer(msg.sender, rewards); }\\r\\n        callerToLastActionBlock[tx.origin] = block.number;\\r\\n        if (unstake) {\\r\\n            frogGameContract.transferFrom(address(this),msg.sender,tokenId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Claim rewards by tokens IDs, unstake optionally\\r\\n    function claimByIds(uint[] calldata tokenIds, bool unstake) external noCheaters nonReentrant whenNotPaused {\\r\\n        uint length=tokenIds.length;\\r\\n        for (uint i=length; i>0; i--) {\\r\\n            _claimById(tokenIds[i-1], unstake);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Claim all rewards, unstake tokens optionally\\r\\n    function claimAll(bool unstake) external noCheaters nonReentrant whenNotPaused {\\r\\n        uint length=stakerToIds[msg.sender].length;\\r\\n        for (uint i=length; i>0; i--) {\\r\\n            _claimById(stakerToIds[msg.sender][i-1], unstake);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // __      ___               \\r\\n    // \\\\ \\\\    / (_)              \\r\\n    //  \\\\ \\\\  / / _  _____      __\\r\\n    //   \\\\ \\\\/ / | |/ _ \\\\ \\\\ /\\\\ / /\\r\\n    //    \\\\  /  | |  __/\\\\ V  V / \\r\\n    //     \\\\/   |_|\\\\___| \\\\_/\\\\_/  \\r\\n\\r\\n    /// @dev Return the amount that can be claimed by specific token\\r\\n    function claimableById(uint tokenId) public view noSameBlockAsAction returns (uint) {\\r\\n        uint reward;\\r\\n        if (stakedIdToStaker[tokenId]==nullAddress) {return 0;}\\r\\n        if (tokenId>typeShift) { \\r\\n            reward=snakeReward-stakedSnakeToRewardPaid[tokenId];\\r\\n        }\\r\\n        else {\\r\\n            uint pre_reward = (block.timestamp-stakedIdToLastClaimTimestamp[tokenId])*(tadpolePerDay/86400);\\r\\n            reward = _tadpoleClaimed + pre_reward > tadpoleMax?tadpoleMax-_tadpoleClaimed:pre_reward;\\r\\n        }\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function evacuate(uint[] calldata tokenIds) external noCheaters nonReentrant {\\r\\n        for (uint i=0;i<tokenIds.length;i++) {\\r\\n            address staker = stakedIdToStaker[tokenIds[i]];\\r\\n            require(evacuationStarted, \\\"There was no evacuation signal\\\");\\r\\n            require(staker!=nullAddress, \\\"Token is not staked\\\");\\r\\n            require(staker==msg.sender, \\\"You're not the staker\\\");\\r\\n\\r\\n            uint tokenId=tokenIds[i];\\r\\n\\r\\n            uint[2] memory indicies = stakedIdsToIndicies[tokenId];\\r\\n\\r\\n            stakedIdToStaker[tokenId] = nullAddress;\\r\\n            stakerToIds[msg.sender][indicies[0]]=stakerToIds[msg.sender][stakerToIds[msg.sender].length-1];\\r\\n            stakedIdsToIndicies[stakerToIds[msg.sender][stakerToIds[msg.sender].length-1]][0]=indicies[0];\\r\\n            stakerToIds[msg.sender].pop();\\r\\n\\r\\n            if (tokenId>typeShift) {\\r\\n                stakedIdsToIndicies[snakesStaked[snakesStaked.length-1]][1]=indicies[1];\\r\\n                snakesStaked[indicies[1]]=snakesStaked[snakesStaked.length-1];\\r\\n                snakesStaked.pop();\\r\\n            } else {\\r\\n                stakedIdsToIndicies[frogsStaked[frogsStaked.length-1]][1]=indicies[1];\\r\\n                frogsStaked[indicies[1]]=frogsStaked[frogsStaked.length-1];\\r\\n                frogsStaked.pop();\\r\\n            }\\r\\n\\r\\n            frogGameContract.transferFrom(address(this), msg.sender, tokenId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev total Snakes staked\\r\\n    function snakesInPond() external view noSameBlockAsAction returns(uint) {\\r\\n        return snakesStaked.length;\\r\\n    }\\r\\n    \\r\\n    /// @dev total Frogs staked\\r\\n    function frogsInPond() external view noSameBlockAsAction returns(uint) {\\r\\n        return frogsStaked.length;\\r\\n    }\\r\\n\\r\\n    function snakeTaxesCollected() external view noSameBlockAsAction returns(uint) {\\r\\n        return _snakeTaxesCollected;\\r\\n    }\\r\\n\\r\\n    function snakeTaxesPaid() external view noSameBlockAsAction returns(uint) {\\r\\n        return _snakeTaxesPaid;\\r\\n    }\\r\\n\\r\\n    function tadpoleClaimed() external view noSameBlockAsAction returns(uint) {\\r\\n        return _tadpoleClaimed;\\r\\n    }\\r\\n\\r\\n    function stakedByAddress(address _wallet)\\r\\n        public\\r\\n        view\\r\\n        noSameBlockAsAction\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        return stakerToIds[_wallet];\\r\\n    }\\r\\n\\r\\n    //   ____                           \\r\\n    //  / __ \\\\                          \\r\\n    // | |  | |_      ___ __   ___ _ __ \\r\\n    // | |  | \\\\ \\\\ /\\\\ / / '_ \\\\ / _ \\\\ '__|\\r\\n    // | |__| |\\\\ V  V /| | | |  __/ |   \\r\\n    //  \\\\____/  \\\\_/\\\\_/ |_| |_|\\\\___|_|   \\r\\n                                    \\r\\n\\r\\n    function Pause() external onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function Unpause() external onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    function evacuationSwitch() external onlyOwner {\\r\\n        evacuationStarted=!evacuationStarted;\\r\\n    }\\r\\n\\r\\n    /// @dev Set Tadpole contract address and init the interface\\r\\n    function setTadpoleAddress(address _tadpoleAddress) external onlyOwner {\\r\\n        tadpoleContract=ITadpole(_tadpoleAddress);\\r\\n    }\\r\\n\\r\\n    /// @dev Set FrogGame contract address and init the interface\\r\\n    function setFrogGameAddress(address _frogGameAddress) external onlyOwner {\\r\\n        frogGameContract=IFrogGame(_frogGameAddress);\\r\\n    }\\r\\n                         \\r\\n    //  _    _ _   _ _ _ _         \\r\\n    // | |  | | | (_) (_) |        \\r\\n    // | |  | | |_ _| |_| |_ _   _ \\r\\n    // | |  | | __| | | | __| | | |\\r\\n    // | |__| | |_| | | | |_| |_| |\\r\\n    //  \\\\____/ \\\\__|_|_|_|\\\\__|\\\\__, |\\r\\n    //                        __/ |\\r\\n    //                       |___/ \\r\\n\\r\\n    /// @dev Create a bit more of randomness\\r\\n    function _randomize(uint256 rand, string memory val, uint256 spicy) internal pure returns (uint256) {\\r\\n        return uint256(keccak256(abi.encode(rand, val, spicy)));\\r\\n    }\\r\\n\\r\\n    /// @dev Get random uint\\r\\n    function _rand() internal view returns (uint256) {\\r\\n        return uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty, block.timestamp, entropySauce)));\\r\\n    }\\r\\n\\r\\n    /// @dev Utility function for FrogGame contract\\r\\n    function getRandomSnakeOwner() external returns(address) {\\r\\n        require(msg.sender==address(frogGameContract), \\\"can be called from the game contract only\\\");\\r\\n        if (snakesStaked.length>0) {\\r\\n            uint random = _randomize(_rand(), \\\"snakeOwner\\\", randomNounce++) % snakesStaked.length; \\r\\n            return stakedIdToStaker[snakesStaked[random]];\\r\\n        } else return nullAddress;\\r\\n    }\\r\\n\\r\\n    /// @dev calculate reward for Frog based on timestamps and toadpole amount claimed\\r\\n    function calculateRewardForFrogId(uint tokenId) internal view returns(uint) {\\r\\n        uint reward = (block.timestamp-stakedIdToLastClaimTimestamp[tokenId])*(tadpolePerDay/86400);\\r\\n        return ((_tadpoleClaimed + reward > tadpoleMax) ? (tadpoleMax - _tadpoleClaimed) : reward);\\r\\n    }\\r\\n\\r\\n    /// @dev Mint initial tadpole pool to the contract\\r\\n    function mintTadpolePool() external onlyOwner() {\\r\\n        tadpoleContract.mintTo(address(this), 2000000000 ether);\\r\\n    }\\r\\n    \\r\\n    //  __  __           _ _  __ _               \\r\\n    // |  \\\\/  |         | (_)/ _(_)              \\r\\n    // | \\\\  / | ___   __| |_| |_ _  ___ _ __ ___ \\r\\n    // | |\\\\/| |/ _ \\\\ / _` | |  _| |/ _ \\\\ '__/ __|\\r\\n    // | |  | | (_) | (_| | | | | |  __/ |  \\\\__ \\\\\\r\\n    // |_|  |_|\\\\___/ \\\\__,_|_|_| |_|\\\\___|_|  |___/\\r\\n\\r\\n    modifier noCheaters() {\\r\\n        // WL for frogGameContract\\r\\n        uint256 size = 0;\\r\\n        address acc = msg.sender;\\r\\n        assembly { size := extcodesize(acc)}\\r\\n\\r\\n        require(msg.sender == tx.origin , \\\"you're trying to cheat!\\\");\\r\\n        require(size == 0,                \\\"you're trying to cheat!\\\");\\r\\n        _;\\r\\n\\r\\n        // We'll use the last caller hash to add entropy to next caller\\r\\n        entropySauce = keccak256(abi.encodePacked(msg.sender, block.coinbase));\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Don't allow view functions in same block as action that changed the state\\r\\n    modifier noSameBlockAsAction() {\\r\\n        require(callerToLastActionBlock[tx.origin] < block.number, \\\"Please try again on next block\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    function onERC721Received(\\r\\n        address,\\r\\n        address from,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external pure override returns (bytes4) {\\r\\n      require(from == address(0x0), \\\"Cannot send tokens to Pond directly\\\");\\r\\n      return IERC721Receiver.onERC721Received.selector;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"claimByIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimableById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"evacuate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"evacuationStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"evacuationSwitch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frogsInPond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRandomSnakeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintTadpolePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_frogGameAddress\",\"type\":\"address\"}],\"name\":\"setFrogGameAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tadpoleAddress\",\"type\":\"address\"}],\"name\":\"setTadpoleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snakeTaxesCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snakeTaxesPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snakesInPond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeToPond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"stakedByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tadpoleClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tadpoleMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tadpolePerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Pond","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}