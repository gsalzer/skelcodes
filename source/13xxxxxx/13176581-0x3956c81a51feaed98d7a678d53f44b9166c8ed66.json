{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/token/Magic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@solidstate/contracts/access/OwnableInternal.sol';\\nimport '@solidstate/contracts/token/ERC20/ERC20.sol';\\n\\nimport './IMagic.sol';\\n\\ncontract Magic is IMagic, ERC20, OwnableInternal {\\n    uint256 public teamMintAmount;\\n    mapping(address => bool) private whitelist;\\n\\n    function setWhitelist(address[] calldata minters) external onlyOwner {\\n        require(!whitelist[address(this)], 'Magic: whitelist already set');\\n\\n        for (uint256 i; i < minters.length; i++) {\\n            whitelist[minters[i]] = true;\\n        }\\n\\n        whitelist[address(this)] = true;\\n    }\\n\\n    function mint(address account, uint256 amount) external override {\\n        require(whitelist[msg.sender], 'Magic: sender must be whitelisted');\\n        _mint(account, amount);\\n    }\\n\\n    function teamMint(address account, uint256 amount) external onlyOwner {\\n        require(\\n            (totalSupply() + amount) / (teamMintAmount + amount) >= 10,\\n            'Magic: excessive mint'\\n        );\\n        _mint(account, amount);\\n        teamMintAmount += amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {OwnableStorage} from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal {\\n  using OwnableStorage for OwnableStorage.Layout;\\n\\n  modifier onlyOwner {\\n    require(\\n      msg.sender == OwnableStorage.layout().owner,\\n      'Ownable: sender must be owner'\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {ERC20Base} from './base/ERC20Base.sol';\\nimport {ERC20Extended} from './extended/ERC20Extended.sol';\\nimport {ERC20Metadata} from './metadata/ERC20Metadata.sol';\\n\\n/**\\n * @title SolidState ERC20 implementation, including recommended extensions\\n */\\nabstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {}\\n\"\r\n    },\r\n    \"contracts/token/IMagic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@solidstate/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IMagic is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n  struct Layout {\\n    address owner;\\n  }\\n\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\n    'solidstate.contracts.storage.Ownable'\\n  );\\n\\n  function layout () internal pure returns (Layout storage l) {\\n    bytes32 slot = STORAGE_SLOT;\\n    assembly { l.slot := slot }\\n  }\\n\\n  function setOwner (\\n    Layout storage l,\\n    address owner\\n  ) internal {\\n    l.owner = owner;\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '../IERC20.sol';\\nimport {ERC20BaseInternal} from './ERC20BaseInternal.sol';\\nimport {ERC20BaseStorage} from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20Base is IERC20, ERC20BaseInternal {\\n  /**\\n   * @inheritdoc IERC20\\n   */\\n  function totalSupply () override virtual public view returns (uint) {\\n    return _totalSupply();\\n  }\\n\\n  /**\\n   * @inheritdoc IERC20\\n   */\\n  function balanceOf (\\n    address account\\n  ) override virtual public view returns (uint) {\\n    return _balanceOf(account);\\n  }\\n\\n  /**\\n   * @inheritdoc IERC20\\n   */\\n  function allowance (\\n    address holder,\\n    address spender\\n  ) override virtual public view returns (uint) {\\n    return ERC20BaseStorage.layout().allowances[holder][spender];\\n  }\\n\\n  /**\\n   * @inheritdoc IERC20\\n   */\\n  function approve (\\n    address spender,\\n    uint amount\\n  ) override virtual public returns (bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @inheritdoc IERC20\\n   */\\n  function transfer (\\n    address recipient,\\n    uint amount\\n  ) override virtual public returns (bool) {\\n    _transfer(msg.sender, recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @inheritdoc IERC20\\n   */\\n  function transferFrom (\\n    address holder,\\n    address recipient,\\n    uint amount\\n  ) override virtual public returns (bool) {\\n    uint256 currentAllowance = ERC20BaseStorage.layout().allowances[holder][msg.sender];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(holder, msg.sender, currentAllowance - amount);\\n    }\\n    _transfer(holder, recipient, amount);\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {ERC20Base, ERC20BaseStorage} from '../base/ERC20Base.sol';\\n\\n/**\\n * @title ERC20 safe approval extensions\\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n */\\nabstract contract ERC20Extended is ERC20Base {\\n  /**\\n   * @notice increase spend amount granted to spender\\n   * @param spender address whose allowance to increase\\n   * @param amount quantity by which to increase allowance\\n   * @return success status (always true; otherwise function will revert)\\n   */\\n  function increaseAllowance (address spender, uint amount) virtual public returns (bool) {\\n    unchecked {\\n      mapping (address => uint) storage allowances = ERC20BaseStorage.layout().allowances[msg.sender];\\n\\n      uint allowance = allowances[spender];\\n      require(allowance + amount >= allowance, 'ERC20Extended: excessive allowance');\\n\\n      _approve(\\n        msg.sender,\\n        spender,\\n        allowances[spender] = allowance + amount\\n      );\\n\\n      return true;\\n    }\\n  }\\n\\n  /**\\n   * @notice decrease spend amount granted to spender\\n   * @param spender address whose allowance to decrease\\n   * @param amount quantity by which to decrease allowance\\n   * @return success status (always true; otherwise function will revert)\\n   */\\n  function decreaseAllowance (address spender, uint amount) virtual public returns (bool) {\\n    unchecked {\\n      mapping (address => uint) storage allowances = ERC20BaseStorage.layout().allowances[msg.sender];\\n\\n      uint allowance = allowances[spender];\\n      require(amount <= allowance, 'ERC20Extended: insufficient allowance');\\n\\n      _approve(\\n        msg.sender,\\n        spender,\\n        allowances[spender] = allowance - amount\\n      );\\n\\n      return true;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {ERC20MetadataStorage} from './ERC20MetadataStorage.sol';\\nimport {IERC20Metadata} from './IERC20Metadata.sol';\\n\\n/**\\n * @title ERC20 metadata extensions\\n */\\nabstract contract ERC20Metadata is IERC20Metadata {\\n  /**\\n   * @inheritdoc IERC20Metadata\\n   */\\n  function name () virtual override public view returns (string memory) {\\n    return ERC20MetadataStorage.layout().name;\\n  }\\n\\n  /**\\n   * @inheritdoc IERC20Metadata\\n   */\\n  function symbol () virtual override public view returns (string memory) {\\n    return ERC20MetadataStorage.layout().symbol;\\n  }\\n\\n  /**\\n   * @inheritdoc IERC20Metadata\\n   */\\n  function decimals () virtual override public view returns (uint8) {\\n    return ERC20MetadataStorage.layout().decimals;\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Internal} from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n  /**\\n   * @notice query the total minted token supply\\n   * @return token supply\\n   */\\n  function totalSupply () external view returns (uint256);\\n\\n  /**\\n   * @notice query the token balance of given account\\n   * @param account address to query\\n   * @return token balance\\n   */\\n  function balanceOf (\\n    address account\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice query the allowance granted from given holder to given spender\\n   * @param holder approver of allowance\\n   * @param spender recipient of allowance\\n   * @return token allowance\\n   */\\n  function allowance (\\n    address holder,\\n    address spender\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice grant approval to spender to spend tokens\\n   * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n   * @param spender recipient of allowance\\n   * @param amount quantity of tokens approved for spending\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function approve (\\n    address spender,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transfer (\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient on behalf of given holder\\n   * @param holder holder of tokens prior to transfer\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transferFrom (\\n    address holder,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Internal} from '../IERC20Internal.sol';\\nimport {ERC20BaseStorage} from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20BaseInternal is IERC20Internal {\\n  /**\\n   * @notice query the total minted token supply\\n   * @return token supply\\n   */\\n  function _totalSupply () virtual internal view returns (uint) {\\n    return ERC20BaseStorage.layout().totalSupply;\\n  }\\n\\n  /**\\n   * @notice query the token balance of given account\\n   * @param account address to query\\n   * @return token balance\\n   */\\n  function _balanceOf (\\n    address account\\n  ) virtual internal view returns (uint) {\\n    return ERC20BaseStorage.layout().balances[account];\\n  }\\n\\n  /**\\n   * @notice enable spender to spend tokens on behalf of holder\\n   * @param holder address on whose behalf tokens may be spent\\n   * @param spender recipient of allowance\\n   * @param amount quantity of tokens approved for spending\\n   */\\n  function _approve (\\n    address holder,\\n    address spender,\\n    uint amount\\n  ) virtual internal {\\n    require(holder != address(0), 'ERC20: approve from the zero address');\\n    require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n    ERC20BaseStorage.layout().allowances[holder][spender] = amount;\\n\\n    emit Approval(holder, spender, amount);\\n  }\\n\\n  /**\\n   * @notice mint tokens for given account\\n   * @param account recipient of minted tokens\\n   * @param amount quantity of tokens minted\\n   */\\n  function _mint (\\n    address account,\\n    uint amount\\n  ) virtual internal {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n    l.totalSupply += amount;\\n    l.balances[account] += amount;\\n\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @notice burn tokens held by given account\\n   * @param account holder of burned tokens\\n   * @param amount quantity of tokens burned\\n   */\\n  function _burn (\\n    address account,\\n    uint amount\\n  ) virtual internal {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n    uint256 balance = l.balances[account];\\n    require(balance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n    unchecked {\\n      l.balances[account] = balance - amount;\\n    }\\n    l.totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @notice transfer tokens from holder to recipient\\n   * @param holder owner of tokens to be transferred\\n   * @param recipient beneficiary of transfer\\n   * @param amount quantity of tokens transferred\\n   */\\n  function _transfer (\\n    address holder,\\n    address recipient,\\n    uint amount\\n  ) virtual internal {\\n    require(holder != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    _beforeTokenTransfer(holder, recipient, amount);\\n\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n    uint256 holderBalance = l.balances[holder];\\n    require(holderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      l.balances[holder] = holderBalance - amount;\\n    }\\n    l.balances[recipient] += amount;\\n\\n    emit Transfer(holder, recipient, amount);\\n  }\\n\\n  /**\\n   * @notice ERC20 hook, called before all transfers including mint and burn\\n   * @dev function should be overridden and new implementation must call super\\n   * @param from sender of tokens\\n   * @param to receiver of tokens\\n   * @param amount quantity of tokens transferred\\n   */\\n  function _beforeTokenTransfer (\\n    address from,\\n    address to,\\n    uint amount\\n  ) virtual internal {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20BaseStorage {\\n  struct Layout {\\n    mapping (address => uint) balances;\\n    mapping (address => mapping (address => uint)) allowances;\\n    uint totalSupply;\\n  }\\n\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\n    'solidstate.contracts.storage.ERC20Base'\\n  );\\n\\n  function layout () internal pure returns (Layout storage l) {\\n    bytes32 slot = STORAGE_SLOT;\\n    assembly { l.slot := slot }\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20MetadataStorage {\\n  struct Layout {\\n    string name;\\n    string symbol;\\n    uint8 decimals;\\n  }\\n\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\n    'solidstate.contracts.storage.ERC20Metadata'\\n  );\\n\\n  function layout () internal pure returns (Layout storage l) {\\n    bytes32 slot = STORAGE_SLOT;\\n    assembly { l.slot := slot }\\n  }\\n\\n  function setName (\\n    Layout storage l,\\n    string memory name\\n  ) internal {\\n    l.name = name;\\n  }\\n\\n  function setSymbol (\\n    Layout storage l,\\n    string memory symbol\\n  ) internal {\\n    l.symbol = symbol;\\n  }\\n\\n  function setDecimals (\\n    Layout storage l,\\n    uint8 decimals\\n  ) internal {\\n    l.decimals = decimals;\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC20 metadata interface\\n */\\ninterface IERC20Metadata {\\n  /**\\n   * @notice return token name\\n   * @return token name\\n   */\\n  function name () external view returns (string memory);\\n\\n  /**\\n   * @notice return token symbol\\n   * @return token symbol\\n   */\\n  function symbol () external view returns (string memory);\\n\\n  /**\\n   * @notice return token decimals, generally used only for display purposes\\n   * @return token decimals\\n   */\\n  function decimals () external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"minters\",\"type\":\"address[]\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"teamMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Magic","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}