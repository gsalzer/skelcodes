/*
                              ▓▓█
                            ▒██▒▒█ 
                           █▓▓▓░▒▓▓     
                         ▒█▓▒█░▒▒▒█     
                        ▒█▒▒▒█▒▒▒▒▓▒    
 ▓▓▒░                  ▓█▒▒▒▓██▓▒░▒█    
 █▓▓██▓░              ▓█▒▒▒▒████▒▒▒█    
 ▓█▓▒▒▓██▓░          ▒█▒▒▒▒▒██▓█▓░░▓▒   
 ▓▒▓▒▒▒▒▒▓█▓░  ░▒▒▓▓██▒▒▒▒▒▒█████▒▒▒▓   
 ▓░█▒▒▒▒▒▒▒▓▓█▓█▓▓▓▓▒▒▒▒▒▒▒▒██▓██▒░▒█   
 ▓░▓█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓████▒▒▒█   
 ▓░▓██▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▓██░░░█   
 ▓░▓███▒▒▒▒▒▒▒▒▒▒▒▓█▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▒▓▓  
 ▒▒▒██▓▒▓█▓▒▒▒▒▒▒▒▓▒▒▒▒▒▒▓▓▓▒▒▒▒▒▒▒▓▒█  
  ▓▒█▓▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒▓█▓▓▓▓█▓▒▒▒▒▒▒▒▓▒ 
  ▓▒█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓      ▓█▓▒▒▒▒▒▓█ 
  ▒▒▓▒▒▒▓▓▓▒▒▒▒▒▒▒▒▒▓▓   ░▓▓   █▓▒▒▒▒▒█ 
   █▒▒▓▓▓▒▒▓▓▒▒▒▒▒▒▓▓   █████▓  █▓▒▒▒▒▓▒
   ▓▓█▒     ▒▓▒▒▒▒▒█   ░██████  ░█▒▒▒▒▓▓
   ▓█▒  ▒███ ▒▓▒▒▒▒█    ██████   ▓▒▒▒▒▒▓
   ██   █████ █▒▒▒▒█     ███▓    ▓▓▒▒▒▒▓
   █▓   █████ ▒▓▒▒▒█             █▓▓▓▒▒▓
   █▓   ░███  ░▓▒▒▒▓█          ░█▓▒▒▒▓▒▓
   ██         ▒▓▒▒▒▒▓▓      ░▒▓█▓    ░▓▓
   ▓█░        █▓██▓▒▒▓█▓▓▓▓██▓▓▒▓▒░░▒▓▒▓
   ▒██░      ▓▒███▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▓▓▓▓▒▓ 
    █▓█▓▓▒▒▓█▓▒░██▒▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓█▒
    ▓ ░▓▓▓▓▓▒▓▓▓▓▒▓▓▓▒▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓
    ▒▒▒▓▒▒▒▒▒▒▓█░ ░░░ ▓▓▒▒▒▒▒▒▒▒▒▒▒▓██▓▒
     █▓▒▒▒▒▒▒▒▒▓▓ ░░░ ▓▓▒▒▒▒▒▒▒▒▒▓▓▓▒▒▓▒
      ██▓▓▒▒▒▒▒▒█▒░░░░█▒▒▒▒▒▒▒▒▓█▓▓▒▒▒▒▒
       ▒██▓▓▒▒▒▒▒█▓▒▒▓▒▒▒▒▒▒▓███▓▒▒▒▒▒▓▓
          ░▒▓▓▓▓▒▒▓▓▓▓▓▓████▓▓█▒▒▒▒▒▓▓█░
████████████████████████████████████████████████████████████████████████
█▄─▄▄─█▄─██─▄█▄─▄▄▀█▄─▄▄▀█▄─▀█▄─▄█▄─▄▄─█▄─▄███─▄▄─█▄─▄▄─█▄─▄▄─█─▄▄▄▄████
██─▄▄▄██─██─███─▄─▄██─▄─▄██─█▄▀─███─▄█▀██─██▀█─██─██─▄▄▄██─▄█▀█▄▄▄▄─████
█▄▄▄████▄▄▄▄██▄▄█▄▄█▄▄█▄▄█▄▄▄██▄▄█▄▄▄▄▄█▄▄▄▄▄█▄▄▄▄█▄▄▄███▄▄▄▄▄█▄▄▄▄▄████
████████████████████████████████████████████████████████████████████████
█─▄▄▄─█─▄▄─█▄─██─▄█▄─▀█▄─▄█─▄─▄─█▄─▄▄▀█▄─█─▄███─▄▄▄─█▄─▄███▄─██─▄█▄─▄─▀█
█─███▀█─██─██─██─███─█▄▀─████─████─▄─▄██▄─▄████─███▀██─██▀██─██─███─▄─▀█
█▄▄▄▄▄█▄▄▄▄██▄▄▄▄██▄▄▄██▄▄██▄▄▄██▄▄█▄▄██▄▄▄████▄▄▄▄▄█▄▄▄▄▄██▄▄▄▄██▄▄▄▄██*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract PCC_Claim is ERC721, Ownable, ReentrancyGuard, Pausable, ERC721Enumerable {
   using Counters for Counters.Counter;
   using Strings for uint256;
   using SafeMath for uint256;
   
   mapping(address => bool)[50] public Whitelist;
   mapping(address => bool)[50] public AddressRedeemed;
   
   string[50] ImageHashes;
   
   uint256[] public ImageOffset = [0, 1000, 4000];
   uint256 private tokenCount;
   Counters.Counter[50] private _tokenCounter;
   Counters.Counter private _collectionCount;
   
   string private _baseUri;
   
   
   string[50] public ImageDescription;
   string[50] public ImageName;
   string[50] public ImageSeries;
   string[50] public ImageArtist;
   string[50] public ImageType;
   
       constructor() ERC721("Purrnelopes Gift","PCCG") {
           _pause();

           
           _collectionCount.increment(); //1
           _collectionCount.increment(); //2
           _baseUri = "ipfs://";
    } 
    
    function collectionTotalSupply(uint256 _index) public view tokenExists(_index) returns(uint256)  {
        return _tokenCounter[_index].current();
    } 
    
    function addWhitelist(uint256 index, address[] memory addresses) public onlyOwner tokenExists(index) {
        for(uint256 i; i < addresses.length; i++){
            Whitelist[index][addresses[i]] = true;
        }
    }
    
    function updateBaseUri(string memory uri) public onlyOwner {
        _baseUri = uri;
    }
    
    function adjustLastCollectionSize(uint256 _newSize) public onlyOwner{
        uint256 index = ImageOffset.length.sub(2);
        require(_tokenCounter[index].current() <= _newSize, "Cannot reduce collection size less than current count");
        ImageOffset[index.add(1)] = ImageOffset[index].add(_newSize);
    }
    

    function addNewCollection(uint256 _size, string memory _description, string memory _type, string memory _hash, string memory _name, string memory _series, string memory _artist) public onlyOwner {
        uint256 index = _collectionCount.current();
        uint256 start_number = ImageOffset[index];

        ImageDescription[index] = _description;
        ImageHashes[index] = _hash;
        ImageName[index] = _name;
        ImageSeries[index] = _series;
        ImageArtist[index] = _artist;
        ImageType[index] = _type;
                _collectionCount.increment();
        ImageOffset.push(start_number.add(_size));
    }
    
    function updateCollectionDetails(uint256 _index, string memory _description, string memory _type, string memory _hash, string memory _name, string memory _series, string memory _artist) public onlyOwner tokenExists(_index){
        ImageDescription[_index] = _description;
        ImageType[_index] = _type;
        ImageHashes[_index] = _hash;
        ImageName[_index] = _name;
        ImageSeries[_index] = _series;
        ImageArtist[_index] = _artist;
    }
    
    function redeemGift(uint256 index) public nonReentrant whenNotPaused tokenExists(index) {
        require(Whitelist[index][msg.sender], "Address not on whitelist");
        require(!AddressRedeemed[index][msg.sender], "Address has already redeemed");
        require(_tokenCounter[index].current().add(ImageOffset[index]) < ImageOffset[index+1], "Cannot redeem this many tokens");
        
        _tokenCounter[index].increment();
        _mint(msg.sender, _tokenCounter[index].current().add(ImageOffset[index]));
        
        AddressRedeemed[index][msg.sender] = true;
        tokenCount++;
    }
    
    function devMint(uint256 index, uint256 quantity) public nonReentrant onlyOwner tokenExists(index){
        require(_tokenCounter[index].current().add(quantity + ImageOffset[index]) <= ImageOffset[index+1], "Cannot redeem this many tokens");
        
        for(uint256 i; i < quantity; i++){
        _tokenCounter[index].increment();
        _mint(msg.sender, _tokenCounter[index].current().add(ImageOffset[index]));  
        }
        tokenCount = tokenCount.add(quantity);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721)
        returns (string memory)
    {
        ownerOf(tokenId); // << check for non-existent token
        uint256 index = getIndex(tokenId);

        
        bytes memory attributes = abi.encodePacked('{"ID":"', Strings.toString(tokenId.sub(ImageOffset[index])), '","Type":"'
                                        , ImageType[index], '","Series":"'
                                        , ImageSeries[index], '","Artist":"'
                                        , ImageArtist[index],'"}');
                                        
        string memory metadata = string(abi.encodePacked('data:application/json;utf8,{"name":"'
                                , ImageName[index], '", "image": "', _baseUri, ImageHashes[index], '", "description": "', ImageDescription[index],'", "attributes":', attributes, '}'));
        return metadata;
        
    }
    
    function getIndex(uint256 _tokenId) private view returns(uint256){
        for(uint256 i; i < ImageOffset.length; i++){
            if (_tokenId <= ImageOffset[i]){
                return i.sub(1);
            }
        }
        require(false, "token out of range");
        return 0;
    }
    
        function _beforeTokenTransfer(address from, address to, uint256 tokenId)
        internal
        whenNotPaused
        override(ERC721, ERC721Enumerable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }
    
    function claimStatus(uint256 index, address addy) public view returns(bool canClaim, bool hasClaimed) {
        canClaim = Whitelist[index][addy];
        hasClaimed = AddressRedeemed[index][addy];
    }
    
    function totalSupply() public override view returns(uint256 supply){
        supply = tokenCount;
    }
    
    function tokenTotalSupply(uint256 tokenId) public view tokenExists(tokenId) returns(uint256){
        return _tokenCounter[tokenId].current();
    }
    
    function togglePause() public onlyOwner {
        if (paused()){
            _unpause();
        }
        else{
            _pause();
        }
    }
    
        function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
    
       modifier tokenExists(uint256 tokenId) {
      require(tokenId < _collectionCount.current(), "token does not exist" );
    _;
       }
}
