{"status":"1","message":"OK","result":[{"SourceCode":"// solhint-disable-next-line\r\npragma solidity 0.4.26;\r\n// solhint-disable func-order\r\n\r\ncontract GenePoolInterface {\r\n  // signals is gene pool\r\n  function isGenePool() public pure returns (bool);\r\n  // breeds two parents and returns childs genes\r\n  function breed(uint256[2] mother, uint256[2] father, uint256 seed) public view returns (uint256[2]);\r\n  // generates (psuedo) random Pepe DNA\r\n  function randomDNA(uint256 seed) public pure returns (uint256[2]);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract Usernames {\r\n\r\n    mapping(address => bytes32) public addressToUser;\r\n    mapping(bytes32 => address) public userToAddress;\r\n\r\n    event UserNamed(address indexed user, bytes32 indexed username);\r\n\r\n    /**\r\n     * Claim a username. Frees up a previously used one\r\n     * @param _username to claim\r\n     */\r\n    function claimUsername(bytes32 _username) external {\r\n        require(userToAddress[_username] == address(0));// Username must be free\r\n\r\n        if (addressToUser[msg.sender] != bytes32(0)) { // If user already has username free it up\r\n            userToAddress[addressToUser[msg.sender]] = address(0);\r\n        }\r\n\r\n        //all is well assign username\r\n        addressToUser[msg.sender] = _username;\r\n        userToAddress[_username] = msg.sender;\r\n\r\n        emit UserNamed(msg.sender, _username);\r\n\r\n    }\r\n\r\n}\r\n\r\n/** @title Beneficiary */\r\ncontract Beneficiary is Ownable {\r\n    address public beneficiary;\r\n\r\n    constructor() public {\r\n        beneficiary = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the beneficiary address\r\n     * @param _beneficiary Address of the new beneficiary\r\n     */\r\n    function setBeneficiary(address _beneficiary) public onlyOwner {\r\n        beneficiary = _beneficiary;\r\n    }\r\n}\r\n\r\n/** @title Affiliate */\r\ncontract Affiliate is Ownable {\r\n    mapping(address => bool) public canSetAffiliate;\r\n    mapping(address => address) public userToAffiliate;\r\n\r\n    /** @dev Allows an address to set the affiliate address for a user\r\n      * @param _setter The address that should be allowed\r\n      */\r\n    function setAffiliateSetter(address _setter) public onlyOwner {\r\n        canSetAffiliate[_setter] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the affiliate of a user\r\n     * @param _user user to set affiliate for\r\n     * @param _affiliate address to set\r\n     */\r\n    function setAffiliate(address _user, address _affiliate) public {\r\n        require(canSetAffiliate[msg.sender]);\r\n        if (userToAffiliate[_user] == address(0)) {\r\n            userToAffiliate[_user] = _affiliate;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract ERC721 {\r\n    function implementsERC721() public pure returns (bool);\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) ;\r\n    function transfer(address _to, uint256 _tokenId) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\r\n    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n}\r\n\r\ncontract PepeInterface is ERC721{\r\n    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) public returns (bool);\r\n    function getCozyAgain(uint256 _pepeId) public view returns(uint64);\r\n}\r\n\r\n/** @title AuctionBase */\r\ncontract AuctionBase is Beneficiary {\r\n    mapping(uint256 => PepeAuction) public auctions;//maps pepes to auctions\r\n    PepeInterface public pepeContract;\r\n    Affiliate public affiliateContract;\r\n    uint256 public fee = 37500; //in 1 10000th of a percent so 3.75% at the start\r\n    uint256 public constant FEE_DIVIDER = 1000000; //Perhaps needs better name?\r\n\r\n    struct PepeAuction {\r\n        address seller;\r\n        uint256 pepeId;\r\n        uint64 auctionBegin;\r\n        uint64 auctionEnd;\r\n        uint256 beginPrice;\r\n        uint256 endPrice;\r\n    }\r\n\r\n    event AuctionWon(uint256 indexed pepe, address indexed winner, address indexed seller);\r\n    event AuctionStarted(uint256 indexed pepe, address indexed seller);\r\n    event AuctionFinalized(uint256 indexed pepe, address indexed seller);\r\n\r\n    constructor(address _pepeContract, address _affiliateContract) public {\r\n        pepeContract = PepeInterface(_pepeContract);\r\n        affiliateContract = Affiliate(_affiliateContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Return a pepe from a auction that has passed\r\n     * @param  _pepeId the id of the pepe to save\r\n     */\r\n    function savePepe(uint256 _pepeId) external {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(auctions[_pepeId].auctionEnd < now);//auction must have ended\r\n        require(pepeContract.transfer(auctions[_pepeId].seller, _pepeId));//transfer pepe back to seller\r\n\r\n        emit AuctionFinalized(_pepeId, auctions[_pepeId].seller);\r\n\r\n        delete auctions[_pepeId];//delete auction\r\n    }\r\n\r\n    /**\r\n     * @dev change the fee on pepe sales. Can only be lowerred\r\n     * @param _fee The new fee to set. Must be lower than current fee\r\n     */\r\n    function changeFee(uint256 _fee) external onlyOwner {\r\n        require(_fee < fee);//fee can not be raised\r\n        fee = _fee;\r\n    }\r\n\r\n    /**\r\n     * @dev Start a auction\r\n     * @param  _pepeId Pepe to sell\r\n     * @param  _beginPrice Price at which the auction starts\r\n     * @param  _endPrice Ending price of the auction\r\n     * @param  _duration How long the auction should take\r\n     */\r\n    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\r\n        require(pepeContract.transferFrom(msg.sender, address(this), _pepeId));\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\r\n\r\n        PepeAuction memory auction;\r\n\r\n        auction.seller = msg.sender;\r\n        auction.pepeId = _pepeId;\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionBegin = uint64(now);\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionEnd = uint64(now) + _duration;\r\n        require(auction.auctionEnd > auction.auctionBegin);\r\n        auction.beginPrice = _beginPrice;\r\n        auction.endPrice = _endPrice;\r\n\r\n        auctions[_pepeId] = auction;\r\n\r\n        emit AuctionStarted(_pepeId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev directly start a auction from the PepeBase contract\r\n     * @param  _pepeId Pepe to put on auction\r\n     * @param  _beginPrice Price at which the auction starts\r\n     * @param  _endPrice Ending price of the auction\r\n     * @param  _duration How long the auction should take\r\n     * @param  _seller The address selling the pepe\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\r\n        require(msg.sender == address(pepeContract)); //can only be called by pepeContract\r\n        //solhint-disable-next-line not-rely-on-time\r\n        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\r\n\r\n        PepeAuction memory auction;\r\n\r\n        auction.seller = _seller;\r\n        auction.pepeId = _pepeId;\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionBegin = uint64(now);\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionEnd = uint64(now) + _duration;\r\n        require(auction.auctionEnd > auction.auctionBegin);\r\n        auction.beginPrice = _beginPrice;\r\n        auction.endPrice = _endPrice;\r\n\r\n        auctions[_pepeId] = auction;\r\n\r\n        emit AuctionStarted(_pepeId, _seller);\r\n    }\r\n\r\n  /**\r\n   * @dev Calculate the current price of a auction\r\n   * @param  _pepeId the pepeID to calculate the current price for\r\n   * @return currentBid the current price for the auction\r\n   */\r\n    function calculateBid(uint256 _pepeId) public view returns(uint256 currentBid) {\r\n        PepeAuction storage auction = auctions[_pepeId];\r\n        // solhint-disable-next-line not-rely-on-time\r\n        uint256 timePassed = now - auctions[_pepeId].auctionBegin;\r\n\r\n        // If auction ended return auction end price.\r\n        // solhint-disable-next-line not-rely-on-time\r\n        if (now >= auction.auctionEnd) {\r\n            return auction.endPrice;\r\n        } else {\r\n            // Can be negative\r\n            int256 priceDifference = int256(auction.endPrice) - int256(auction.beginPrice);\r\n            // Always positive\r\n            int256 duration = int256(auction.auctionEnd) - int256(auction.auctionBegin);\r\n\r\n            // As already proven in practice by CryptoKitties:\r\n            //  timePassed -> 64 bits at most\r\n            //  priceDifference -> 128 bits at most\r\n            //  timePassed * priceDifference -> 64 + 128 bits at most\r\n            int256 priceChange = priceDifference * int256(timePassed) / duration;\r\n\r\n            // Will be positive, both operands are less than 256 bits\r\n            int256 price = int256(auction.beginPrice) + priceChange;\r\n\r\n            return uint256(price);\r\n        }\r\n    }\r\n\r\n  /**\r\n   * @dev collect the fees from the auction\r\n   */\r\n    function getFees() public {\r\n        beneficiary.transfer(address(this).balance);\r\n    }\r\n\r\n\r\n}\r\n\r\n/** @title CozyTimeAuction */\r\ncontract RebornCozyTimeAuction is AuctionBase {\r\n    // solhint-disable-next-line\r\n    constructor (address _pepeContract, address _affiliateContract) AuctionBase(_pepeContract, _affiliateContract) public {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Start an auction\r\n     * @param  _pepeId The id of the pepe to start the auction for\r\n     * @param  _beginPrice Start price of the auction\r\n     * @param  _endPrice End price of the auction\r\n     * @param  _duration How long the auction should take\r\n     */\r\n    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\r\n        super.startAuction(_pepeId, _beginPrice, _endPrice, _duration);\r\n    }\r\n\r\n    /**\r\n     * @dev Start a auction direclty from the PepeBase smartcontract\r\n     * @param  _pepeId The id of the pepe to start the auction for\r\n     * @param  _beginPrice Start price of the auction\r\n     * @param  _endPrice End price of the auction\r\n     * @param  _duration How long the auction should take\r\n     * @param  _seller The address of the seller\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\r\n        super.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, _seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy cozy right from the auction\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _cozyCandidate the pepe to cozy with\r\n     * @param  _candidateAsFather Is the _cozyCandidate father?\r\n     * @param  _pepeReceiver address receiving the pepe after cozy time\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function buyCozy(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver) public payable {\r\n        require(address(pepeContract) == msg.sender); //caller needs to be the PepeBase contract\r\n\r\n        PepeAuction storage auction = auctions[_pepeId];\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now < auction.auctionEnd);// auction must be still going\r\n\r\n        uint256 price = calculateBid(_pepeId);\r\n        require(msg.value >= price);//must send enough ether\r\n        uint256 totalFee = price * fee / FEE_DIVIDER; //safe math needed?\r\n\r\n        //Send ETH to seller\r\n        auction.seller.transfer(price - totalFee);\r\n        //send ETH to beneficiary\r\n\r\n        address affiliate = affiliateContract.userToAffiliate(_pepeReceiver);\r\n\r\n        //solhint-disable-next-line\r\n        if (affiliate != address(0) && affiliate.send(totalFee / 2)) { //if user has affiliate\r\n            //nothing just to suppress warning\r\n        }\r\n\r\n        //actual cozytiming\r\n        if (_candidateAsFather) {\r\n            if (!pepeContract.cozyTime(auction.pepeId, _cozyCandidate, _pepeReceiver)) {\r\n                revert();\r\n            }\r\n        } else {\r\n          // Swap around the two pepes, they have no set gender, the user decides what they are.\r\n            if (!pepeContract.cozyTime(_cozyCandidate, auction.pepeId, _pepeReceiver)) {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        //Send pepe to seller of auction\r\n        if (!pepeContract.transfer(auction.seller, _pepeId)) {\r\n            revert(); //can't complete transfer if this fails\r\n        }\r\n\r\n        if (msg.value > price) { //return ether send to much\r\n            _pepeReceiver.transfer(msg.value - price);\r\n        }\r\n\r\n        emit AuctionWon(_pepeId, _pepeReceiver, auction.seller);//emit event\r\n\r\n        delete auctions[_pepeId];//deletes auction\r\n    }\r\n\r\n    /**\r\n     * @dev Buy cozytime and pass along affiliate\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _cozyCandidate the pepe to cozy with\r\n     * @param  _candidateAsFather Is the _cozyCandidate father?\r\n     * @param  _pepeReceiver address receiving the pepe after cozy time\r\n     * @param  _affiliate Affiliate address to set\r\n     */\r\n    //solhint-disable-next-line max-line-length\r\n    function buyCozyAffiliated(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver, address _affiliate) public payable {\r\n        affiliateContract.setAffiliate(_pepeReceiver, _affiliate);\r\n        buyCozy(_pepeId, _cozyCandidate, _candidateAsFather, _pepeReceiver);\r\n    }\r\n}\r\n\r\ncontract Genetic {\r\n\r\n    // TODO mutations\r\n    // maximum number of random mutations per chromatid\r\n    uint8 public constant R = 5;\r\n\r\n    // solhint-disable-next-line function-max-lines\r\n    function breed(uint256[2] mother, uint256[2] father, uint256 seed) internal view returns (uint256[2] memOffset) {\r\n        // Meiosis I: recombining alleles (Chromosomal crossovers)\r\n\r\n        // Note about optimization I: no cell duplication,\r\n        //  producing 2 seeds/eggs per cell is enough, instead of 4 (like humans do)\r\n\r\n        // Note about optimization II: crossovers happen,\r\n        //  but only 1 side of the result is computed,\r\n        //  as the other side will not affect anything.\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // allocate output\r\n            // 1) get the pointer to our memory\r\n            memOffset := mload(0x40)\r\n            // 2) Change the free-memory pointer to keep our memory\r\n            //     (we will only use 64 bytes: 2 values of 256 bits)\r\n            mstore(0x40, add(memOffset, 64))\r\n\r\n\r\n            // Put seed in scratchpad 0\r\n            mstore(0x0, seed)\r\n            // Also use the timestamp, best we could do to increase randomness\r\n            //  without increasing costs dramatically. (Trade-off)\r\n            mstore(0x20, timestamp)\r\n\r\n            // Hash it for a universally random bitstring.\r\n            let hash := keccak256(0, 64)\r\n\r\n            // Byzantium VM does not support shift opcodes, will be introduced in Constantinople.\r\n            // Soldity itself, in non-assembly, also just uses other opcodes to simulate it.\r\n            // Optmizer should take care of inlining, just declare shiftR ourselves here.\r\n            // Where possible, better optimization is applied to make it cheaper.\r\n            function shiftR(value, offset) -> result {\r\n                result := div(value, exp(2, offset))\r\n            }\r\n\r\n            // solhint-disable max-line-length\r\n            // m_context << Instruction::SWAP1 << u256(2) << Instruction::EXP << Instruction::SWAP1 << (c_leftSigned ? Instruction::SDIV : Instruction::DIV);\r\n\r\n            // optimization: although one side consists of multiple chromatids,\r\n            //  we handle them just as one long chromatid:\r\n            //  only difference is that a crossover in chromatid i affects chromatid i+1.\r\n            //  No big deal, order and location is random anyway\r\n            function processSide(fatherSrc, motherSrc, rngSrc) -> result {\r\n\r\n                {\r\n                    // initial rngSrc bit length: 254 bits\r\n\r\n                    // Run the crossovers\r\n                    // =====================================================\r\n\r\n                    // Pick some crossovers\r\n                    // Each crossover is spaced ~64 bits on average.\r\n                    // To achieve this, we get a random 7 bit number, [0, 128), for each crossover.\r\n\r\n                    // 256 / 64 = 4, we need 4 crossovers,\r\n                    //  and will have 256 / 127 = 2 at least (rounded down).\r\n\r\n                    // Get one bit determining if we should pick DNA from the father,\r\n                    //  or from the mother.\r\n                    // This changes every crossover. (by swapping father and mother)\r\n                    {\r\n                        if eq(and(rngSrc, 0x1), 0) {\r\n                            // Swap mother and father,\r\n                            // create a temporary variable (code golf XOR swap costs more in gas)\r\n                            let temp := fatherSrc\r\n                            fatherSrc := motherSrc\r\n                            motherSrc := temp\r\n                        }\r\n\r\n                        // remove the bit from rng source, 253 rng bits left\r\n                        rngSrc := shiftR(rngSrc, 1)\r\n                    }\r\n\r\n                    // Don't push/pop this all the time, we have just enough space on stack.\r\n                    let mask := 0\r\n\r\n                    // Cap at 4 crossovers, no more than that.\r\n                    let cap := 0\r\n                    let crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\r\n                    // remove bits from hash, e.g. 254 - 7 = 247 left.\r\n                    rngSrc := shiftR(rngSrc, 7)\r\n                    let crossoverPos := crossoverLen\r\n\r\n                    // optimization: instead of shifting with an opcode we don't have until Constantinople,\r\n                    //  keep track of the a shifted number, updated using multiplications.\r\n                    let crossoverPosLeading1 := 1\r\n\r\n                    // solhint-disable-next-line no-empty-blocks\r\n                    for { } and(lt(crossoverPos, 256), lt(cap, 4)) {\r\n\r\n                        crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\r\n                        // remove bits from hash, e.g. 254 - 7 = 247 left.\r\n                        rngSrc := shiftR(rngSrc, 7)\r\n\r\n                        crossoverPos := add(crossoverPos, crossoverLen)\r\n\r\n                        cap := add(cap, 1)\r\n                    } {\r\n\r\n                        // Note: we go from right to left in the bit-string.\r\n\r\n                        // Create a mask for this crossover.\r\n                        // Example:\r\n                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\r\n                        // |Prev. data ||Crossover here  ||remaining data .......\r\n                        //\r\n                        // The crossover part is copied from the mother/father to the child.\r\n\r\n                        // Create the bit-mask\r\n                        // Create a bitstring that ignores the previous data:\r\n                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\r\n                        // First create a leading 1, just before the crossover, like:\r\n                        // 00000000000010000000000000000000000000000000000000000000000000000000000.....\r\n                        // Then substract 1, to get a long string of 1s\r\n                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\r\n                        // Now do the same for the remain part, and xor it.\r\n                        // leading 1\r\n                        // 00000000000000000000000000000010000000000000000000000000000000000000000000000000000000000.....\r\n                        // sub 1\r\n                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\r\n                        // xor with other\r\n                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\r\n                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\r\n                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\r\n\r\n                        // Use the final shifted 1 of the previous crossover as the start marker\r\n                        mask := sub(crossoverPosLeading1, 1)\r\n\r\n                        // update for this crossover, (and will be used as start for next crossover)\r\n                        crossoverPosLeading1 := mul(1, exp(2, crossoverPos))\r\n                        mask := xor(mask,\r\n                                    sub(crossoverPosLeading1, 1)\r\n                        )\r\n\r\n                        // Now add the parent data to the child genotype\r\n                        // E.g.\r\n                        // Mask:         00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000....\r\n                        // Parent:       10010111001000110101011111001010001011100000000000010011000001000100000001011101111000111....\r\n                        // Child (pre):  00000000000000000000000000000001111110100101111111000011001010000000101010100000110110110....\r\n                        // Child (post): 00000000000000110101011111001011111110100101111111000011001010000000101010100000110110110....\r\n\r\n                        // To do this, we run: child_post = child_pre | (mask & father)\r\n                        result := or(result, and(mask, fatherSrc))\r\n\r\n                        // Swap father and mother, next crossover will take a string from the other.\r\n                        let temp := fatherSrc\r\n                        fatherSrc := motherSrc\r\n                        motherSrc := temp\r\n                    }\r\n\r\n                    // We still have a left-over part that was not copied yet\r\n                    // E.g., we have something like:\r\n                    // Father: |            xxxxxxxxxxxxxxxxxxx          xxxxxxxxxxxxxxxxxxxxxxxx            ....\r\n                    // Mother: |############                   xxxxxxxxxx                        xxxxxxxxxxxx....\r\n                    // Child:  |            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx....\r\n                    // The ############ still needs to be applied to the child, also,\r\n                    //  this can be done cheaper than in the loop above,\r\n                    //  as we don't have to swap anything for the next crossover or something.\r\n\r\n                    // At this point we have to assume 4 crossovers ran,\r\n                    //  and that we only have 127 - 1 - (4 * 7) = 98 bits of randomness left.\r\n                    // We stopped at the bit after the crossoverPos index, see \"x\":\r\n                    // 000000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.....\r\n                    // now create a leading 1 at crossoverPos like:\r\n                    // 000000001000000000000000000000000000000000000000000000000000000000000000000.....\r\n                    // Sub 1, get the mask for what we had.\r\n                    // 000000000111111111111111111111111111111111111111111111111111111111111111111.....\r\n                    // Invert, and we have the final mask:\r\n                    // 111111111000000000000000000000000000000000000000000000000000000000000000000.....\r\n                    mask := not(sub(crossoverPosLeading1, 1))\r\n                    // Apply it to the result\r\n                    result := or(result, and(mask, fatherSrc))\r\n\r\n                    // Random mutations\r\n                    // =====================================================\r\n\r\n                    // random mutations\r\n                    // Put rng source in scratchpad 0\r\n                    mstore(0x0, rngSrc)\r\n                    // And some arbitrary padding in scratchpad 1,\r\n                    //  used to create different hashes based on input size changes\r\n                    mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\r\n                    // Hash it for a universally random bitstring.\r\n                    // Then reduce the number of 1s by AND-ing it with other *different* hashes.\r\n                    // Each bit in mutations has a probability of 0.5^5 = 0.03125 = 3.125% to be a 1\r\n                    let mutations := and(\r\n                            and(\r\n                                and(keccak256(0, 32), keccak256(1, 33)),\r\n                                and(keccak256(2, 34), keccak256(3, 35))\r\n                            ),\r\n                            keccak256(0, 36)\r\n                    )\r\n\r\n                    result := xor(result, mutations)\r\n\r\n                }\r\n            }\r\n\r\n\r\n            {\r\n\r\n                // Get 1 bit of pseudo randomness that will\r\n                //  determine if side #1 will come from the left, or right side.\r\n                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\r\n                let relativeFatherSideLoc := mul(and(hash, 0x1), 0x20) // shift by 5 bits = mul by 2^5=32 (0x20)\r\n                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\r\n                let relativeMotherSideLoc := mul(and(hash, 0x2), 0x10) // already shifted by 1, mul by 2^4=16 (0x10)\r\n\r\n                // Now remove the used 2 bits from the hash, 254 bits remaining now.\r\n                hash := div(hash, 4)\r\n\r\n                // Process the side, load the relevant parent data that will be used.\r\n                mstore(memOffset, processSide(\r\n                    mload(add(father, relativeFatherSideLoc)),\r\n                    mload(add(mother, relativeMotherSideLoc)),\r\n                    hash\r\n                ))\r\n\r\n                // The other side will be the opposite index: 1 -> 0, 0 -> 1\r\n                // Apply it to the location,\r\n                //  which is either 0x20 (For index 1) or 0x0 for index 0.\r\n                relativeFatherSideLoc := xor(relativeFatherSideLoc, 0x20)\r\n                relativeMotherSideLoc := xor(relativeMotherSideLoc, 0x20)\r\n\r\n                mstore(0x0, seed)\r\n                // Second argument will be inverse,\r\n                //  resulting in a different second hash.\r\n                mstore(0x20, not(timestamp))\r\n\r\n                // Now create another hash, for the other side\r\n                hash := keccak256(0, 64)\r\n\r\n                // Process the other side\r\n                mstore(add(memOffset, 0x20), processSide(\r\n                    mload(add(father, relativeFatherSideLoc)),\r\n                    mload(add(mother, relativeMotherSideLoc)),\r\n                    hash\r\n                ))\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Sample input:\r\n        // [\"0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC\",\"0x4444444455555555555555556666666666666644444444455555555555666666\"]\r\n        //\r\n        // [\"0x1111111111112222222223333311111111122222223333333331111112222222\",\"0x7777788888888888999999999999977777777777788888888888999999997777\"]\r\n\r\n        // Expected results (or similar, depends on the seed):\r\n        // 0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC < Father side A\r\n        // 0x4444444455555555555555556666666666666644444444455555555555666666 < Father side B\r\n\r\n        // 0x1111111111112222222223333311111111122222223333333331111112222222 < Mother side A\r\n        // 0x7777788888888888999999999999977777777777788888888888999999997777 < Mother side B\r\n\r\n        //   xxxxxxxxxxxxxxxxx           xxxxxxxxx                         xx\r\n        // 0xAAABBBBBBBBCCCCCD99999999998BBBBBBBBF77778888888888899999999774C < Child side A\r\n        //   xxx                       xxxxxxxxxxx\r\n        // 0x4441111111112222222223333366666666666222223333333331111112222222 < Child side B\r\n\r\n        // And then random mutations, for gene pool expansion.\r\n        // Each bit is flipped with a 3.125% chance\r\n\r\n        // Example:\r\n        //a2c37edc61dca0ca0b199e098c80fd5a221c2ad03605b4b54332361358745042 < random hash 1\r\n        //c217d04b19a83fe497c1cf6e1e10030e455a0812a6949282feec27d67fe2baa7 < random hash 2\r\n        //2636a55f38bed26d804c63a13628e21b2d701c902ca37b2b0ca94fada3821364 < random hash 3\r\n        //86bb023a85e2da50ac233b946346a53aa070943b0a8e91c56e42ba181729a5f9 < random hash 4\r\n        //5d71456a1288ab30ddd4c955384d42e66a09d424bd7743791e3eab8e09aa13f1 < random hash 5\r\n        //0000000800800000000000000000000200000000000000000000020000000000 < resulting mutation\r\n        //aaabbbbbbbbcccccd99999999998bbbbbbbbf77778888888888899999999774c < original\r\n        //aaabbbb3bb3cccccd99999999998bbb9bbbbf7777888888888889b999999774c < mutated (= original XOR mutation)\r\n    }\r\n\r\n    // Generates (psuedo) random Pepe DNA\r\n    function randomDNA(uint256 seed) internal pure returns (uint256[2] memOffset) {\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // allocate output\r\n            // 1) get the pointer to our memory\r\n            memOffset := mload(0x40)\r\n            // 2) Change the free-memory pointer to keep our memory\r\n            //     (we will only use 64 bytes: 2 values of 256 bits)\r\n            mstore(0x40, add(memOffset, 64))\r\n\r\n            // Load the seed into 1st scratchpad memory slot.\r\n            // adjacent to the additional value (used to create two distinct hashes)\r\n            mstore(0x0, seed)\r\n\r\n            // In second scratchpad slot:\r\n            // The additional value can be any word, as long as the caller uses\r\n            //  it (second hash needs to be different)\r\n            mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\r\n\r\n\r\n            // // Create first element pointer of array\r\n            // mstore(memOffset, add(memOffset, 64)) // pointer 1\r\n            // mstore(add(memOffset, 32), add(memOffset, 96)) // pointer 2\r\n\r\n            // control block to auto-pop the hash.\r\n            {\r\n                // L * N * 2 * 4 = 4 * 2 * 2 * 4 = 64 bytes, 2x 256 bit hash\r\n\r\n                // Sha3 is cheaper than sha256, make use of it\r\n                let hash := keccak256(0, 64)\r\n\r\n                // Store first array value\r\n                mstore(memOffset, hash)\r\n\r\n                // Now hash again, but only 32 bytes of input,\r\n                //  to ignore make the input different than the previous call,\r\n                hash := keccak256(0, 32)\r\n                mstore(add(memOffset, 32), hash)\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/** @title CozyTimeAuction */\r\ncontract CozyTimeAuction is AuctionBase {\r\n    // solhint-disable-next-line\r\n    constructor (address _pepeContract, address _affiliateContract) AuctionBase(_pepeContract, _affiliateContract) public {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Start an auction\r\n     * @param  _pepeId The id of the pepe to start the auction for\r\n     * @param  _beginPrice Start price of the auction\r\n     * @param  _endPrice End price of the auction\r\n     * @param  _duration How long the auction should take\r\n     */\r\n    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\r\n        super.startAuction(_pepeId, _beginPrice, _endPrice, _duration);\r\n    }\r\n\r\n    /**\r\n     * @dev Start a auction direclty from the PepeBase smartcontract\r\n     * @param  _pepeId The id of the pepe to start the auction for\r\n     * @param  _beginPrice Start price of the auction\r\n     * @param  _endPrice End price of the auction\r\n     * @param  _duration How long the auction should take\r\n     * @param  _seller The address of the seller\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\r\n        super.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, _seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy cozy right from the auction\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _cozyCandidate the pepe to cozy with\r\n     * @param  _candidateAsFather Is the _cozyCandidate father?\r\n     * @param  _pepeReceiver address receiving the pepe after cozy time\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function buyCozy(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver) public payable {\r\n        require(address(pepeContract) == msg.sender); //caller needs to be the PepeBase contract\r\n\r\n        PepeAuction storage auction = auctions[_pepeId];\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now < auction.auctionEnd);// auction must be still going\r\n\r\n        uint256 price = calculateBid(_pepeId);\r\n        require(msg.value >= price);//must send enough ether\r\n        uint256 totalFee = price * fee / FEE_DIVIDER; //safe math needed?\r\n\r\n        //Send ETH to seller\r\n        auction.seller.transfer(price - totalFee);\r\n        //send ETH to beneficiary\r\n\r\n        address affiliate = affiliateContract.userToAffiliate(_pepeReceiver);\r\n\r\n        //solhint-disable-next-line\r\n        if (affiliate != address(0) && affiliate.send(totalFee / 2)) { //if user has affiliate\r\n            //nothing just to suppress warning\r\n        }\r\n\r\n        //actual cozytiming\r\n        if (_candidateAsFather) {\r\n            if (!pepeContract.cozyTime(auction.pepeId, _cozyCandidate, _pepeReceiver)) {\r\n                revert();\r\n            }\r\n        } else {\r\n          // Swap around the two pepes, they have no set gender, the user decides what they are.\r\n            if (!pepeContract.cozyTime(_cozyCandidate, auction.pepeId, _pepeReceiver)) {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        //Send pepe to seller of auction\r\n        if (!pepeContract.transfer(auction.seller, _pepeId)) {\r\n            revert(); //can't complete transfer if this fails\r\n        }\r\n\r\n        if (msg.value > price) { //return ether send to much\r\n            _pepeReceiver.transfer(msg.value - price);\r\n        }\r\n\r\n        emit AuctionWon(_pepeId, _pepeReceiver, auction.seller);//emit event\r\n\r\n        delete auctions[_pepeId];//deletes auction\r\n    }\r\n\r\n    /**\r\n     * @dev Buy cozytime and pass along affiliate\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _cozyCandidate the pepe to cozy with\r\n     * @param  _candidateAsFather Is the _cozyCandidate father?\r\n     * @param  _pepeReceiver address receiving the pepe after cozy time\r\n     * @param  _affiliate Affiliate address to set\r\n     */\r\n    //solhint-disable-next-line max-line-length\r\n    function buyCozyAffiliated(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver, address _affiliate) public payable {\r\n        affiliateContract.setAffiliate(_pepeReceiver, _affiliate);\r\n        buyCozy(_pepeId, _cozyCandidate, _candidateAsFather, _pepeReceiver);\r\n    }\r\n}\r\n\r\ncontract Haltable is Ownable {\r\n    uint256 public haltTime; //when the contract was halted\r\n    bool public halted;//is the contract halted?\r\n    uint256 public haltDuration;\r\n    uint256 public maxHaltDuration = 8 weeks;//how long the contract can be halted\r\n\r\n    modifier stopWhenHalted {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenHalted {\r\n        require(halted);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Halt the contract for a set time smaller than maxHaltDuration\r\n     * @param  _duration Duration how long the contract should be halted. Must be smaller than maxHaltDuration\r\n     */\r\n    function halt(uint256 _duration) public onlyOwner {\r\n        require(haltTime == 0); //cannot halt if it was halted before\r\n        require(_duration <= maxHaltDuration);//cannot halt for longer than maxHaltDuration\r\n        haltDuration = _duration;\r\n        halted = true;\r\n        // solhint-disable-next-line not-rely-on-time\r\n        haltTime = now;\r\n    }\r\n\r\n    /**\r\n     * @dev Unhalt the contract. Can only be called by the owner or when the haltTime has passed\r\n     */\r\n    function unhalt() public {\r\n        // solhint-disable-next-line\r\n        require(now > haltTime + haltDuration || msg.sender == owner);//unhalting is only possible when haltTime has passed or the owner unhalts\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\ncontract PepeBase is Genetic, Ownable, Usernames, Haltable {\r\n\r\n    uint32[15] public cozyCoolDowns = [ //determined by generation / 2\r\n        uint32(1 minutes),\r\n        uint32(2 minutes),\r\n        uint32(5 minutes),\r\n        uint32(15 minutes),\r\n        uint32(30 minutes),\r\n        uint32(45 minutes),\r\n        uint32(1 hours),\r\n        uint32(2 hours),\r\n        uint32(4 hours),\r\n        uint32(8 hours),\r\n        uint32(16 hours),\r\n        uint32(1 days),\r\n        uint32(2 days),\r\n        uint32(4 days),\r\n        uint32(7 days)\r\n    ];\r\n\r\n    struct Pepe {\r\n        address master; //The master of the pepe\r\n        uint256[2] genotype; //all genes stored here\r\n        uint64 canCozyAgain; //time when pepe can have nice time again\r\n        uint64 generation; //what generation?\r\n        uint64 father; //father of this pepe\r\n        uint64 mother; //mommy of this pepe\r\n        uint8 coolDownIndex;\r\n    }\r\n\r\n    mapping(uint256 => bytes32) public pepeNames;\r\n\r\n    //stores all pepes\r\n    Pepe[] public pepes;\r\n\r\n    bool public implementsERC721 = true; //signal erc721 support\r\n\r\n    // solhint-disable-next-line const-name-snakecase\r\n    string public constant name = \"Crypto Pepe\";\r\n    // solhint-disable-next-line const-name-snakecase\r\n    string public constant symbol = \"CPEP\";\r\n\r\n    mapping(address => uint256[]) private wallets;\r\n    mapping(address => uint256) public balances; //amounts of pepes per address\r\n    mapping(uint256 => address) public approved; //pepe index to address approved to transfer\r\n    mapping(address => mapping(address => bool)) public approvedForAll;\r\n\r\n    uint256 public zeroGenPepes; //how many zero gen pepes are mined\r\n    uint256 public constant MAX_PREMINE = 100;//how many pepes can be premined\r\n    uint256 public constant MAX_ZERO_GEN_PEPES = 1100; //max number of zero gen pepes\r\n    address public miner; //address of the miner contract\r\n\r\n    modifier onlyPepeMaster(uint256 _pepeId) {\r\n        require(pepes[_pepeId].master == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowed(uint256 _tokenId) {\r\n        // solhint-disable-next-line max-line-length\r\n        require(msg.sender == pepes[_tokenId].master || msg.sender == approved[_tokenId] || approvedForAll[pepes[_tokenId].master][msg.sender]); //check if msg.sender is allowed\r\n        _;\r\n    }\r\n\r\n    event PepeBorn(uint256 indexed mother, uint256 indexed father, uint256 indexed pepeId);\r\n    event PepeNamed(uint256 indexed pepeId);\r\n\r\n    constructor() public {\r\n\r\n        Pepe memory pepe0 = Pepe({\r\n            master: 0x0,\r\n            genotype: [uint256(0), uint256(0)],\r\n            canCozyAgain: 0,\r\n            father: 0,\r\n            mother: 0,\r\n            generation: 0,\r\n            coolDownIndex: 0\r\n        });\r\n\r\n        pepes.push(pepe0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that creates a new pepe\r\n     * @param  _genoType DNA of the new pepe\r\n     * @param  _mother The ID of the mother\r\n     * @param  _father The ID of the father\r\n     * @param  _generation The generation of the new Pepe\r\n     * @param  _master The owner of this new Pepe\r\n     * @return The ID of the newly generated Pepe\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function _newPepe(uint256[2] _genoType, uint64 _mother, uint64 _father, uint64 _generation, address _master) internal returns (uint256 pepeId) {\r\n        uint8 tempCoolDownIndex;\r\n\r\n        tempCoolDownIndex = uint8(_generation / 2);\r\n\r\n        if (_generation > 28) {\r\n            tempCoolDownIndex = 14;\r\n        }\r\n\r\n        Pepe memory _pepe = Pepe({\r\n            master: _master, //The master of the pepe\r\n            genotype: _genoType, //all genes stored here\r\n            canCozyAgain: 0, //time when pepe can have nice time again\r\n            father: _father, //father of this pepe\r\n            mother: _mother, //mommy of this pepe\r\n            generation: _generation, //what generation?\r\n            coolDownIndex: tempCoolDownIndex\r\n        });\r\n\r\n        if (_generation == 0) {\r\n            zeroGenPepes += 1; //count zero gen pepes\r\n        }\r\n\r\n        //push returns the new length, use it to get a new unique id\r\n        pepeId = pepes.push(_pepe) - 1;\r\n\r\n        //add it to the wallet of the master of the new pepe\r\n        addToWallet(_master, pepeId);\r\n\r\n        emit PepeBorn(_mother, _father, pepeId);\r\n        emit Transfer(address(0), _master, pepeId);\r\n\r\n        return pepeId;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the miner contract. Can only be called once\r\n     * @param _miner Address of the miner contract\r\n     */\r\n    function setMiner(address _miner) public onlyOwner {\r\n        require(miner == address(0));//can only be set once\r\n        miner = _miner;\r\n    }\r\n\r\n    /**\r\n     * @dev Mine a new Pepe. Can only be called by the miner contract.\r\n     * @param  _seed Seed to be used for the generation of the DNA\r\n     * @param  _receiver Address receiving the newly mined Pepe\r\n     * @return The ID of the newly mined Pepe\r\n     */\r\n    function minePepe(uint256 _seed, address _receiver) public stopWhenHalted returns(uint256) {\r\n        require(msg.sender == miner);//only miner contract can call\r\n        require(zeroGenPepes < MAX_ZERO_GEN_PEPES);\r\n\r\n        return _newPepe(randomDNA(_seed), 0, 0, 0, _receiver);\r\n    }\r\n\r\n    /**\r\n     * @dev Premine pepes. Can only be called by the owner and is limited to MAX_PREMINE\r\n     * @param  _amount Amount of Pepes to premine\r\n     */\r\n    function pepePremine(uint256 _amount) public onlyOwner stopWhenHalted {\r\n        for (uint i = 0; i < _amount; i++) {\r\n            require(zeroGenPepes <= MAX_PREMINE);//can only generate set amount during premine\r\n            //create a new pepe\r\n            // 1) who's genes are based on hash of the timestamp and the number of pepes\r\n            // 2) who has no mother or father\r\n            // 3) who is generation zero\r\n            // 4) who's master is the manager\r\n\r\n            // solhint-disable-next-line\r\n            _newPepe(randomDNA(uint256(keccak256(abi.encodePacked(block.timestamp, pepes.length)))), 0, 0, 0, owner);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev CozyTime two Pepes together\r\n     * @param  _mother The mother of the new Pepe\r\n     * @param  _father The father of the new Pepe\r\n     * @param  _pepeReceiver Address receiving the new Pepe\r\n     * @return If it was a success\r\n     */\r\n    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) external stopWhenHalted returns (bool) {\r\n        //cannot cozyTime with itself\r\n        require(_mother != _father);\r\n        //caller has to either be master or approved for mother\r\n        // solhint-disable-next-line max-line-length\r\n        require(pepes[_mother].master == msg.sender || approved[_mother] == msg.sender || approvedForAll[pepes[_mother].master][msg.sender]);\r\n        //caller has to either be master or approved for father\r\n        // solhint-disable-next-line max-line-length\r\n        require(pepes[_father].master == msg.sender || approved[_father] == msg.sender || approvedForAll[pepes[_father].master][msg.sender]);\r\n        //require both parents to be ready for cozytime\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now > pepes[_mother].canCozyAgain && now > pepes[_father].canCozyAgain);\r\n        //require both mother parents not to be father\r\n        require(pepes[_mother].mother != _father && pepes[_mother].father != _father);\r\n        //require both father parents not to be mother\r\n        require(pepes[_father].mother != _mother && pepes[_father].father != _mother);\r\n\r\n        Pepe storage father = pepes[_father];\r\n        Pepe storage mother = pepes[_mother];\r\n\r\n\r\n        approved[_father] = address(0);\r\n        approved[_mother] = address(0);\r\n\r\n        uint256[2] memory newGenotype = breed(father.genotype, mother.genotype, pepes.length);\r\n\r\n        uint64 newGeneration;\r\n\r\n        newGeneration = mother.generation + 1;\r\n        if (newGeneration < father.generation + 1) { //if father generation is bigger\r\n            newGeneration = father.generation + 1;\r\n        }\r\n\r\n        _handleCoolDown(_mother);\r\n        _handleCoolDown(_father);\r\n\r\n        //sets pepe birth when mother is done\r\n        // solhint-disable-next-line max-line-length\r\n        pepes[_newPepe(newGenotype, uint64(_mother), uint64(_father), newGeneration, _pepeReceiver)].canCozyAgain = mother.canCozyAgain; //_pepeReceiver becomes the master of the pepe\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to increase the coolDownIndex\r\n     * @param _pepeId The id of the Pepe to update the coolDown of\r\n     */\r\n    function _handleCoolDown(uint256 _pepeId) internal {\r\n        Pepe storage tempPep = pepes[_pepeId];\r\n\r\n        // solhint-disable-next-line not-rely-on-time\r\n        tempPep.canCozyAgain = uint64(now + cozyCoolDowns[tempPep.coolDownIndex]);\r\n\r\n        if (tempPep.coolDownIndex < 14) {// after every cozy time pepe gets slower\r\n            tempPep.coolDownIndex++;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Set the name of a Pepe. Can only be set once\r\n     * @param _pepeId ID of the pepe to name\r\n     * @param _name The name to assign\r\n     */\r\n    function setPepeName(uint256 _pepeId, bytes32 _name) public stopWhenHalted onlyPepeMaster(_pepeId) returns(bool) {\r\n        require(pepeNames[_pepeId] == 0x0000000000000000000000000000000000000000000000000000000000000000);\r\n        pepeNames[_pepeId] = _name;\r\n        emit PepeNamed(_pepeId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer a Pepe to the auction contract and auction it\r\n     * @param  _pepeId ID of the Pepe to auction\r\n     * @param  _auction Auction contract address\r\n     * @param  _beginPrice Price the auction starts at\r\n     * @param  _endPrice Price the auction ends at\r\n     * @param  _duration How long the auction should run\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function transferAndAuction(uint256 _pepeId, address _auction, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public stopWhenHalted onlyPepeMaster(_pepeId) {\r\n        _transfer(msg.sender, _auction, _pepeId);//transfer pepe to auction\r\n        AuctionBase auction = AuctionBase(_auction);\r\n\r\n        auction.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve and buy. Used to buy cozyTime in one call\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _auction Address of the auction contract\r\n     * @param  _cozyCandidate Pepe to approve and cozy with\r\n     * @param  _candidateAsFather Use the candidate as father or not\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function approveAndBuy(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\r\n        approved[_cozyCandidate] = _auction;\r\n        // solhint-disable-next-line max-line-length\r\n        CozyTimeAuction(_auction).buyCozy.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender); //breeding resets approval\r\n    }\r\n\r\n    /**\r\n     * @dev The same as above only pass an extra parameter\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _auction Address of the auction contract\r\n     * @param  _cozyCandidate Pepe to approve and cozy with\r\n     * @param  _candidateAsFather Use the candidate as father or not\r\n     * @param  _affiliate Address to set as affiliate\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function approveAndBuyAffiliated(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather, address _affiliate) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\r\n        approved[_cozyCandidate] = _auction;\r\n        // solhint-disable-next-line max-line-length\r\n        CozyTimeAuction(_auction).buyCozyAffiliated.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender, _affiliate); //breeding resets approval\r\n    }\r\n\r\n    /**\r\n     * @dev get Pepe information\r\n     * @param  _pepeId ID of the Pepe to get information of\r\n     * @return master\r\n     * @return genotype\r\n     * @return canCozyAgain\r\n     * @return generation\r\n     * @return father\r\n     * @return mother\r\n     * @return pepeName\r\n     * @return coolDownIndex\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function getPepe(uint256 _pepeId) public view returns(address master, uint256[2] genotype, uint64 canCozyAgain, uint64 generation, uint256 father, uint256 mother, bytes32 pepeName, uint8 coolDownIndex) {\r\n        Pepe storage tempPep = pepes[_pepeId];\r\n\r\n        master = tempPep.master;\r\n        genotype = tempPep.genotype;\r\n        canCozyAgain = tempPep.canCozyAgain;\r\n        generation = tempPep.generation;\r\n        father = tempPep.father;\r\n        mother = tempPep.mother;\r\n        pepeName = pepeNames[_pepeId];\r\n        coolDownIndex = tempPep.coolDownIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the time when a pepe can cozy again\r\n     * @param  _pepeId ID of the pepe\r\n     * @return Time when the pepe can cozy again\r\n     */\r\n    function getCozyAgain(uint256 _pepeId) public view returns(uint64) {\r\n        return pepes[_pepeId].canCozyAgain;\r\n    }\r\n\r\n    /**\r\n     *  ERC721 Compatibility\r\n     *\r\n     */\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n     * @dev Get the total number of Pepes\r\n     * @return total Returns the total number of pepes\r\n     */\r\n    function totalSupply() public view returns(uint256 total) {\r\n        total = pepes.length - balances[address(0)];\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the number of pepes owned by an address\r\n     * @param  _owner Address to get the balance from\r\n     * @return balance The number of pepes\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256 balance) {\r\n        balance = balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Get the owner of a Pepe\r\n     * @param  _tokenId the token to get the owner of\r\n     * @return _owner the owner of the pepe\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\r\n        _owner = pepes[_tokenId].master;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the id of an token by its index\r\n     * @param _owner The address to look up the tokens of\r\n     * @param _index Index to look at\r\n     * @return tokenId the ID of the token of the owner at the specified index\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant returns (uint256 tokenId) {\r\n        //The index must be smaller than the balance,\r\n        // to guarantee that there is no leftover token returned.\r\n        require(_index < balances[_owner]);\r\n\r\n        return wallets[_owner][_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Private method that ads a token to the wallet\r\n     * @param _owner Address of the owner\r\n     * @param _tokenId Pepe ID to add\r\n     */\r\n    function addToWallet(address _owner, uint256 _tokenId) private {\r\n        uint256[] storage wallet = wallets[_owner];\r\n        uint256 balance = balances[_owner];\r\n        if (balance < wallet.length) {\r\n            wallet[balance] = _tokenId;\r\n        } else {\r\n            wallet.push(_tokenId);\r\n        }\r\n        //increase owner balance\r\n        //overflow is not likely to happen(need very large amount of pepes)\r\n        balances[_owner] += 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a token from a address's wallet\r\n     * @param _owner Address of the owner\r\n     * @param _tokenId Token to remove from the wallet\r\n     */\r\n    function removeFromWallet(address _owner, uint256 _tokenId) private {\r\n        uint256[] storage wallet = wallets[_owner];\r\n        uint256 i = 0;\r\n        // solhint-disable-next-line no-empty-blocks\r\n        for (; wallet[i] != _tokenId; i++) {\r\n            // not the pepe we are looking for\r\n        }\r\n        if (wallet[i] == _tokenId) {\r\n            //found it!\r\n            uint256 last = balances[_owner] - 1;\r\n            if (last > 0) {\r\n                //move the last item to this spot, the last will become inaccessible\r\n                wallet[i] = wallet[last];\r\n            }\r\n            //else: no last item to move, the balance is 0, making everything inaccessible.\r\n\r\n            //only decrease balance if _tokenId was in the wallet\r\n            balances[_owner] -= 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal transfer function\r\n     * @param _from Address sending the token\r\n     * @param _to Address to token is send to\r\n     * @param _tokenId ID of the token to send\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        pepes[_tokenId].master = _to;\r\n        approved[_tokenId] = address(0);//reset approved of pepe on every transfer\r\n\r\n        //remove the token from the _from wallet\r\n        removeFromWallet(_from, _tokenId);\r\n\r\n        //add the token to the _to wallet\r\n        addToWallet(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev transfer a token. Can only be called by the owner of the token\r\n     * @param  _to Addres to send the token to\r\n     * @param  _tokenId ID of the token to send\r\n     */\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    function transfer(address _to, uint256 _tokenId) public stopWhenHalted\r\n        onlyPepeMaster(_tokenId) //check if msg.sender is the master of this pepe\r\n        returns(bool)\r\n    {\r\n        _transfer(msg.sender, _to, _tokenId);//after master modifier invoke internal transfer\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve a address to send a token\r\n     * @param _to Address to approve\r\n     * @param _tokenId Token to set approval for\r\n     */\r\n    function approve(address _to, uint256 _tokenId) external stopWhenHalted\r\n        onlyPepeMaster(_tokenId)\r\n    {\r\n        approved[_tokenId] = _to;\r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or revoke approval an address for al tokens of a user\r\n     * @param _operator Address to (un)approve\r\n     * @param _approved Approving or revoking indicator\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external stopWhenHalted {\r\n        if (_approved) {\r\n            approvedForAll[msg.sender][_operator] = true;\r\n        } else {\r\n            approvedForAll[msg.sender][_operator] = false;\r\n        }\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Get approved address for a token\r\n     * @param _tokenId Token ID to get the approved address for\r\n     * @return The address that is approved for this token\r\n     */\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        return approved[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get if an operator is approved for all tokens of that owner\r\n     * @param _owner Owner to check the approval for\r\n     * @param _operator Operator to check approval for\r\n     * @return Boolean indicating if the operator is approved for that owner\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return approvedForAll[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to signal support for an interface\r\n     * @param interfaceID the ID of the interface to check for\r\n     * @return Boolean indicating support\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        if (interfaceID == 0x80ac58cd || interfaceID == 0x01ffc9a7) { //TODO: add more interfaces the contract supports\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Safe transferFrom function\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external stopWhenHalted {\r\n        _safeTransferFromInternal(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safe transferFrom function with aditional data attribute\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     * @param _data Data to pass along call\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external stopWhenHalted {\r\n        _safeTransferFromInternal(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal Safe transferFrom function with aditional data attribute\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     * @param _data Data to pass along call\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function _safeTransferFromInternal(address _from, address _to, uint256 _tokenId, bytes _data) internal onlyAllowed(_tokenId) {\r\n        require(pepes[_tokenId].master == _from);//check if from is current owner\r\n        require(_to != address(0));//throw on zero address\r\n\r\n        _transfer(_from, _to, _tokenId); //transfer token\r\n\r\n        if (isContract(_to)) { //check if is contract\r\n            // solhint-disable-next-line max-line-length\r\n            require(ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, _data) == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev TransferFrom function\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     * @return If it was successful\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public stopWhenHalted onlyAllowed(_tokenId) returns(bool) {\r\n        require(pepes[_tokenId].master == _from);//check if _from is really the master.\r\n        require(_to != address(0));\r\n        _transfer(_from, _to, _tokenId);//handles event, balances and approval reset;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Utility method to check if an address is a contract\r\n     * @param _address Address to check\r\n     * @return Boolean indicating if the address is a contract\r\n     */\r\n    function isContract(address _address) internal view returns (bool) {\r\n        uint size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(_address) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\ncontract PepeReborn is Ownable, Usernames {\r\n\r\n  uint32[15] public cozyCoolDowns = [ // determined by generation / 2\r\n      uint32(1 minutes),\r\n      uint32(2 minutes),\r\n      uint32(5 minutes),\r\n      uint32(15 minutes),\r\n      uint32(30 minutes),\r\n      uint32(45 minutes),\r\n      uint32(1 hours),\r\n      uint32(2 hours),\r\n      uint32(4 hours),\r\n      uint32(8 hours),\r\n      uint32(16 hours),\r\n      uint32(1 days),\r\n      uint32(2 days),\r\n      uint32(4 days),\r\n      uint32(7 days)\r\n  ];\r\n\r\n  struct Pepe {\r\n      address master; // The master of the pepe\r\n      uint256[2] genotype; // all genes stored here\r\n      uint64 canCozyAgain; // time when pepe can have nice time again\r\n      uint64 generation; // what generation?\r\n      uint64 father; // father of this pepe\r\n      uint64 mother; // mommy of this pepe\r\n      uint8 coolDownIndex;\r\n  }\r\n\r\n  struct UndeadPepeMutable {\r\n    address master; // The master of the pepe\r\n    // uint256[2] genotype; // all genes stored here\r\n    uint64 canCozyAgain; // time when pepe can have nice time again\r\n    // uint64 generation; // what generation?\r\n    // uint64 father; // father of this pepe\r\n    // uint64 mother; // mommy of this pepe\r\n    uint8 coolDownIndex;\r\n    bool resurrected; // has the pepe been duplicated off the old contract\r\n  }\r\n\r\n  mapping(uint256 => bytes32) public pepeNames;\r\n\r\n  // stores reborn pepes. index 0 holds pepe 5497\r\n  Pepe[] private rebornPepes;\r\n\r\n  // stores undead pepes. get the mutables from the old contract\r\n  mapping(uint256 => UndeadPepeMutable) private undeadPepes;\r\n\r\n  //address private constant PEPE_UNDEAD_ADDRRESS = 0x84aC94F17622241f313511B629e5E98f489AD6E4;\r\n  //address private constant PEPE_AUCTION_SALE_UNDEAD_ADDRESS = 0x28ae3DF366726D248c57b19fa36F6D9c228248BE;\r\n  //address private constant COZY_TIME_AUCTION_UNDEAD_ADDRESS = 0xE2C43d2C6D6875c8F24855054d77B5664c7e810f;\r\n  address private PEPE_UNDEAD_ADDRRESS;\r\n  address private PEPE_AUCTION_SALE_UNDEAD_ADDRESS;\r\n  address private COZY_TIME_AUCTION_UNDEAD_ADDRESS;\r\n  GenePoolInterface private genePool;\r\n\r\n  uint256 private constant REBORN_PEPE_0 = 5497;\r\n\r\n  bool public constant implementsERC721 = true; // signal erc721 support\r\n\r\n  // solhint-disable-next-line const-name-snakecase\r\n  string public constant name = \"Crypto Pepe Reborn\";\r\n  // solhint-disable-next-line const-name-snakecase\r\n  string public constant symbol = \"CPRE\";\r\n\r\n  // Token Base URI\r\n  string public baseTokenURI = \"https://api.cryptopepes.lol/getPepe/\";\r\n  // Contract URI\r\n  string private contractUri = \"https://cryptopepes.lol/contract-metadata.json\";\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping(address => uint256[]) private wallets;\r\n  // Mapping from token ID to index in owners wallet\r\n  mapping(uint256 => uint256) private walletIndex;\r\n  mapping(uint256 => address) public approved; // pepe index to address approved to transfer\r\n  mapping(address => mapping(address => bool)) public approvedForAll;\r\n\r\n  uint256 private preminedPepes = 0;\r\n  uint256 private constant MAX_PREMINE = 1100;\r\n\r\n  modifier onlyPepeMaster(uint256 pepeId) {\r\n    require(_ownerOf(pepeId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAllowed(uint256 pepeId) {\r\n    address master = _ownerOf(pepeId);\r\n    // solhint-disable-next-line max-line-length\r\n    require(msg.sender == master || msg.sender == approved[pepeId] || approvedForAll[master][msg.sender]); // check if msg.sender is allowed\r\n    _;\r\n  }\r\n\r\n  event PepeBorn(uint256 indexed mother, uint256 indexed father, uint256 indexed pepeId);\r\n  event PepeNamed(uint256 indexed pepeId);\r\n\r\n  constructor(address baseAddress, address saleAddress, address cozyAddress, address genePoolAddress) public {\r\n    PEPE_UNDEAD_ADDRRESS = baseAddress;\r\n    PEPE_AUCTION_SALE_UNDEAD_ADDRESS = saleAddress;\r\n    COZY_TIME_AUCTION_UNDEAD_ADDRESS = cozyAddress;\r\n    setGenePool(genePoolAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that creates a new pepe\r\n   * @param  _genoType DNA of the new pepe\r\n   * @param  _mother The ID of the mother\r\n   * @param  _father The ID of the father\r\n   * @param  _generation The generation of the new Pepe\r\n   * @param  _master The owner of this new Pepe\r\n   * @return The ID of the newly generated Pepe\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function _newPepe(uint256[2] _genoType, uint64 _mother, uint64 _father, uint64 _generation, address _master) internal returns (uint256 pepeId) {\r\n    uint8 tempCoolDownIndex;\r\n\r\n    tempCoolDownIndex = uint8(_generation / 2);\r\n\r\n    if (_generation > 28) {\r\n      tempCoolDownIndex = 14;\r\n    }\r\n\r\n    Pepe memory _pepe = Pepe({\r\n      master: _master, // The master of the pepe\r\n      genotype: _genoType, // all genes stored here\r\n      canCozyAgain: 0, // time when pepe can have nice time again\r\n      father: _father, // father of this pepe\r\n      mother: _mother, // mommy of this pepe\r\n      generation: _generation, // what generation?\r\n      coolDownIndex: tempCoolDownIndex\r\n    });\r\n\r\n    // push returns the new length, use it to get a new unique id\r\n    pepeId = rebornPepes.push(_pepe) + REBORN_PEPE_0 - 1;\r\n\r\n    // add it to the wallet of the master of the new pepe\r\n    addToWallet(_master, pepeId);\r\n\r\n    emit PepeBorn(_mother, _father, pepeId);\r\n    emit Transfer(address(0), _master, pepeId);\r\n\r\n    return pepeId;\r\n  }\r\n\r\n  /**\r\n   * @dev Premine pepes. Can only be called by the owner and is limited to MAX_PREMINE\r\n   * @param  _amount Amount of Pepes to premine\r\n   */\r\n  function pepePremine(uint256 _amount) public onlyOwner {\r\n    for (uint i = 0; i < _amount; i++) {\r\n      require(preminedPepes < MAX_PREMINE);//can only generate set amount during premine\r\n      //create a new pepe\r\n      // 1) who's genes are based on hash of the timestamp and the new pepe's id\r\n      // 2) who has no mother or father\r\n      // 3) who is generation zero\r\n      // 4) who's master is the manager\r\n\r\n      // solhint-disable-next-line\r\n      _newPepe(genePool.randomDNA(uint256(keccak256(abi.encodePacked(block.timestamp, (REBORN_PEPE_0 + rebornPepes.length))))), 0, 0, 0, owner);\r\n      ++preminedPepes;\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @dev CozyTime two Pepes together\r\n   * @param  _mother The mother of the new Pepe\r\n   * @param  _father The father of the new Pepe\r\n   * @param  _pepeReceiver Address receiving the new Pepe\r\n   * @return If it was a success\r\n   */\r\n  function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) external returns (bool) {\r\n    // cannot cozyTime with itself\r\n    require(_mother != _father);\r\n    // ressurect parents if needed\r\n    checkResurrected(_mother);\r\n    checkResurrected(_father);\r\n    // get parents\r\n    Pepe memory mother = _getPepe(_mother);\r\n    Pepe memory father = _getPepe(_father);\r\n    // caller has to either be master or approved for mother\r\n    // solhint-disable-next-line max-line-length\r\n    require(mother.master == msg.sender || approved[_mother] == msg.sender || approvedForAll[mother.master][msg.sender]);\r\n    // caller has to either be master or approved for father\r\n    // solhint-disable-next-line max-line-length\r\n    require(father.master == msg.sender || approved[_father] == msg.sender || approvedForAll[father.master][msg.sender]);\r\n    // require both parents to be ready for cozytime\r\n    // solhint-disable-next-line not-rely-on-time\r\n    require(now > mother.canCozyAgain && now > father.canCozyAgain);\r\n    // require both mother parents not to be father\r\n    require(mother.father != _father && mother.mother != _father);\r\n    require(father.mother != _mother && father.father != _mother);\r\n\r\n    approved[_father] = address(0);\r\n    approved[_mother] = address(0);\r\n\r\n    uint256[2] memory newGenotype = genePool.breed(father.genotype, mother.genotype, REBORN_PEPE_0+rebornPepes.length);\r\n\r\n    uint64 newGeneration;\r\n\r\n    newGeneration = mother.generation + 1;\r\n    if (newGeneration < father.generation + 1) { // if father generation is bigger\r\n        newGeneration = father.generation + 1;\r\n    }\r\n\r\n    uint64 motherCanCozyAgain = _handleCoolDown(_mother);\r\n    _handleCoolDown(_father);\r\n\r\n    // birth new pepe\r\n    // _pepeReceiver becomes the master of the pepe\r\n    uint256 pepeId = _newPepe(newGenotype, uint64(_mother), uint64(_father), newGeneration, _pepeReceiver);\r\n    // sets pepe birth when mother is done\r\n    // solhint-disable-next-line max-line-length\r\n    rebornPepes[rebornPepeIdToIndex(pepeId)].canCozyAgain = motherCanCozyAgain;\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to increase the coolDownIndex\r\n   * @param pepeId The id of the Pepe to update the coolDown of\r\n   * @return The time that pepe can cozy again\r\n   */\r\n  function _handleCoolDown(uint256 pepeId) internal returns (uint64){\r\n    if(pepeId >= REBORN_PEPE_0){\r\n      Pepe storage tempPep1 = rebornPepes[pepeId];\r\n      // solhint-disable-next-line not-rely-on-time\r\n      tempPep1.canCozyAgain = uint64(now + cozyCoolDowns[tempPep1.coolDownIndex]);\r\n      if (tempPep1.coolDownIndex < 14) {// after every cozy time pepe gets slower\r\n        tempPep1.coolDownIndex++;\r\n      }\r\n      return tempPep1.canCozyAgain;\r\n    }else{\r\n      // this function is only called in cozyTime(), pepe has already been resurrected\r\n      UndeadPepeMutable storage tempPep2 = undeadPepes[pepeId];\r\n      // solhint-disable-next-line not-rely-on-time\r\n      tempPep2.canCozyAgain = uint64(now + cozyCoolDowns[tempPep2.coolDownIndex]);\r\n      if (tempPep2.coolDownIndex < 14) {// after every cozy time pepe gets slower\r\n        tempPep2.coolDownIndex++;\r\n      }\r\n      return tempPep2.canCozyAgain;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Set the name of a Pepe. Can only be set once\r\n   * @param pepeId ID of the pepe to name\r\n   * @param _name The name to assign\r\n   */\r\n  function setPepeName(uint256 pepeId, bytes32 _name) public onlyPepeMaster(pepeId) returns(bool) {\r\n      require(pepeNames[pepeId] == 0x0000000000000000000000000000000000000000000000000000000000000000);\r\n      pepeNames[pepeId] = _name;\r\n      emit PepeNamed(pepeId);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer a Pepe to the auction contract and auction it\r\n   * @param  pepeId ID of the Pepe to auction\r\n   * @param  _auction Auction contract address\r\n   * @param  _beginPrice Price the auction starts at\r\n   * @param  _endPrice Price the auction ends at\r\n   * @param  _duration How long the auction should run\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function transferAndAuction(uint256 pepeId, address _auction, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public onlyPepeMaster(pepeId) {\r\n    //checkResurrected(pepeId);\r\n    _transfer(msg.sender, _auction, pepeId);// transfer pepe to auction\r\n    AuctionBase auction = AuctionBase(_auction);\r\n    auction.startAuctionDirect(pepeId, _beginPrice, _endPrice, _duration, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve and buy. Used to buy cozyTime in one call\r\n   * @param  pepeId Pepe to cozy with\r\n   * @param  _auction Address of the auction contract\r\n   * @param  _cozyCandidate Pepe to approve and cozy with\r\n   * @param  _candidateAsFather Use the candidate as father or not\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function approveAndBuy(uint256 pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather) public payable onlyPepeMaster(_cozyCandidate) {\r\n    checkResurrected(pepeId);\r\n    approved[_cozyCandidate] = _auction;\r\n    // solhint-disable-next-line max-line-length\r\n    RebornCozyTimeAuction(_auction).buyCozy.value(msg.value)(pepeId, _cozyCandidate, _candidateAsFather, msg.sender); // breeding resets approval\r\n  }\r\n\r\n  /**\r\n   * @dev The same as above only pass an extra parameter\r\n   * @param  pepeId Pepe to cozy with\r\n   * @param  _auction Address of the auction contract\r\n   * @param  _cozyCandidate Pepe to approve and cozy with\r\n   * @param  _candidateAsFather Use the candidate as father or not\r\n   * @param  _affiliate Address to set as affiliate\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function approveAndBuyAffiliated(uint256 pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather, address _affiliate) public payable onlyPepeMaster(_cozyCandidate) {\r\n    checkResurrected(pepeId);\r\n    approved[_cozyCandidate] = _auction;\r\n    // solhint-disable-next-line max-line-length\r\n    RebornCozyTimeAuction(_auction).buyCozyAffiliated.value(msg.value)(pepeId, _cozyCandidate, _candidateAsFather, msg.sender, _affiliate); // breeding resets approval\r\n  }\r\n\r\n  /**\r\n   * @dev Get the time when a pepe can cozy again\r\n   * @param  pepeId ID of the pepe\r\n   * @return Time when the pepe can cozy again\r\n   */\r\n  function getCozyAgain(uint256 pepeId) public view returns(uint64) {\r\n    return _getPepe(pepeId).canCozyAgain;\r\n  }\r\n\r\n  /**\r\n   *  ERC721 Compatibility\r\n   *\r\n   */\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 pepeId);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed pepeId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  /**\r\n   * @dev Get the total number of Pepes\r\n   * @return total Returns the total number of pepes\r\n   */\r\n  function totalSupply() public view returns(uint256) {\r\n    return REBORN_PEPE_0 + rebornPepes.length - 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Get the number of pepes owned by an address\r\n   * Note that this only includes reborn and resurrected pepes\r\n   * Pepes that are still dead are not counted.\r\n   * @param  _owner Address to get the balance from\r\n   * @return balance The number of pepes\r\n   */\r\n  function balanceOf(address _owner) external view returns (uint256 balance) {\r\n    return wallets[_owner].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Get the owner of a Pepe\r\n   * Note that this returns pepes from old auctions\r\n   * @param  pepeId the token to get the owner of\r\n   * @return the owner of the pepe\r\n   */\r\n  function ownerOf(uint256 pepeId) external view returns (address) {\r\n    return _getPepe(pepeId).master;\r\n  }\r\n\r\n  /**\r\n   * @dev Get the owner of a Pepe\r\n   * Note that this returns pepes from old auctions\r\n   * @param  pepeId the token to get the owner of\r\n   * @return the owner of the pepe\r\n   */\r\n  function _ownerOf(uint256 pepeId) internal view returns (address) {\r\n    return _getPepe(pepeId).master;\r\n  }\r\n\r\n  /**\r\n   * @dev Get the id of an token by its index\r\n   * @param _owner The address to look up the tokens of\r\n   * @param _index Index to look at\r\n   * @return pepeId the ID of the token of the owner at the specified index\r\n   */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant returns (uint256 pepeId) {\r\n    // The index must be smaller than the balance,\r\n    // to guarantee that there is no leftover token returned.\r\n    require(_index < wallets[_owner].length);\r\n    return wallets[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Private method that ads a token to the wallet\r\n   * @param _owner Address of the owner\r\n   * @param pepeId Pepe ID to add\r\n   */\r\n  function addToWallet(address _owner, uint256 pepeId) private {\r\n    /*\r\n    uint256 length = wallets[_owner].length;\r\n    wallets[_owner].push(pepeId);\r\n    walletIndex[pepeId] = length;\r\n    */\r\n    walletIndex[pepeId] = wallets[_owner].length;\r\n    wallets[_owner].push(pepeId);\r\n  }\r\n\r\n  /**\r\n   * @dev Remove a token from a address's wallet\r\n   * @param _owner Address of the owner\r\n   * @param pepeId Token to remove from the wallet\r\n   */\r\n  function removeFromWallet(address _owner, uint256 pepeId) private {\r\n    // walletIndex returns 0 if not initialized to a value\r\n    // verify before removing\r\n    if(walletIndex[pepeId] == 0 && (wallets[_owner].length == 0 || wallets[_owner][0] != pepeId)) return;\r\n\r\n    // pop last element from wallet, move it to this index\r\n    uint256 tokenIndex = walletIndex[pepeId];\r\n    uint256 lastTokenIndex = wallets[_owner].length - 1;\r\n    uint256 lastToken = wallets[_owner][lastTokenIndex];\r\n    wallets[_owner][tokenIndex] = lastToken;\r\n    wallets[_owner].length--;\r\n    walletIndex[pepeId] = 0;\r\n    walletIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal transfer function\r\n   * @param _from Address sending the token\r\n   * @param _to Address to token is send to\r\n   * @param pepeId ID of the token to send\r\n   */\r\n  function _transfer(address _from, address _to, uint256 pepeId) internal {\r\n    checkResurrected(pepeId);\r\n    if(pepeId >= REBORN_PEPE_0) rebornPepes[rebornPepeIdToIndex(pepeId)].master = _to;\r\n    else undeadPepes[pepeId].master = _to;\r\n    approved[pepeId] = address(0);//reset approved of pepe on every transfer\r\n    //remove the token from the _from wallet\r\n    removeFromWallet(_from, pepeId);\r\n    //add the token to the _to wallet\r\n    addToWallet(_to, pepeId);\r\n    emit Transfer(_from, _to, pepeId);\r\n  }\r\n\r\n  /**\r\n   * @dev transfer a token. Can only be called by the owner of the token\r\n   * @param  _to Addres to send the token to\r\n   * @param  pepeId ID of the token to send\r\n   */\r\n  // solhint-disable-next-line no-simple-event-func-name\r\n  function transfer(address _to, uint256 pepeId) public onlyPepeMaster(pepeId) returns(bool) {\r\n    _transfer(msg.sender, _to, pepeId);//after master modifier invoke internal transfer\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve a address to send a token\r\n   * @param _to Address to approve\r\n   * @param pepeId Token to set approval for\r\n   */\r\n  function approve(address _to, uint256 pepeId) external onlyPepeMaster(pepeId) {\r\n    approved[pepeId] = _to;\r\n    emit Approval(msg.sender, _to, pepeId);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve or revoke approval an address for all tokens of a user\r\n   * @param _operator Address to (un)approve\r\n   * @param _approved Approving or revoking indicator\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved) external {\r\n    approvedForAll[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Get approved address for a token\r\n   * @param pepeId Token ID to get the approved address for\r\n   * @return The address that is approved for this token\r\n   */\r\n  function getApproved(uint256 pepeId) external view returns (address) {\r\n    return approved[pepeId];\r\n  }\r\n\r\n  /**\r\n   * @dev Get if an operator is approved for all tokens of that owner\r\n   * @param _owner Owner to check the approval for\r\n   * @param _operator Operator to check approval for\r\n   * @return Boolean indicating if the operator is approved for that owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n    return approvedForAll[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to signal support for an interface\r\n   * @param interfaceID the ID of the interface to check for\r\n   * @return Boolean indicating support\r\n   */\r\n  function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n    if(\r\n         interfaceID == 0x01ffc9a7 // ERC 165\r\n      || interfaceID == 0x80ac58cd // ERC 721 base\r\n      || interfaceID == 0x780e9d63 // ERC 721 enumerable\r\n      || interfaceID == 0x4f558e79 // ERC 721 exists\r\n      || interfaceID == 0x5b5e139f // ERC 721 metadata\r\n      // TODO: add more interfaces such as\r\n      // 0x150b7a02: ERC 721 receiver\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @dev Safe transferFrom function\r\n   * @param _from Address currently owning the token\r\n   * @param _to Address to send token to\r\n   * @param pepeId ID of the token to send\r\n   */\r\n  function safeTransferFrom(address _from, address _to, uint256 pepeId) external {\r\n    _safeTransferFromInternal(_from, _to, pepeId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safe transferFrom function with aditional data attribute\r\n   * @param _from Address currently owning the token\r\n   * @param _to Address to send token to\r\n   * @param pepeId ID of the token to send\r\n   * @param _data Data to pass along call\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function safeTransferFrom(address _from, address _to, uint256 pepeId, bytes _data) external {\r\n    _safeTransferFromInternal(_from, _to, pepeId, _data);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal Safe transferFrom function with aditional data attribute\r\n   * @param _from Address currently owning the token\r\n   * @param _to Address to send token to\r\n   * @param pepeId ID of the token to send\r\n   * @param _data Data to pass along call\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function _safeTransferFromInternal(address _from, address _to, uint256 pepeId, bytes _data) internal onlyAllowed(pepeId) {\r\n    require(_ownerOf(pepeId) == _from);//check if from is current owner\r\n    require(_to != address(0));//throw on zero address\r\n\r\n    _transfer(_from, _to, pepeId); //transfer token\r\n\r\n    if (isContract(_to)) { //check if is contract\r\n      // solhint-disable-next-line max-line-length\r\n      require(ERC721TokenReceiver(_to).onERC721Received(_from, pepeId, _data) == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev TransferFrom function\r\n   * @param _from Address currently owning the token\r\n   * @param _to Address to send token to\r\n   * @param pepeId ID of the token to send\r\n   * @return If it was successful\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function transferFrom(address _from, address _to, uint256 pepeId) public onlyAllowed(pepeId) returns(bool) {\r\n    require(_ownerOf(pepeId) == _from);//check if _from is really the master.\r\n    require(_to != address(0));\r\n    _transfer(_from, _to, pepeId);//handles event, balances and approval reset;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Utility method to check if an address is a contract\r\n   * @param _address Address to check\r\n   * @return Boolean indicating if the address is a contract\r\n   */\r\n  function isContract(address _address) internal view returns (bool) {\r\n    uint size;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly { size := extcodesize(_address) }\r\n    return size > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param pepeId uint256 ID of the token to query the existence of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 pepeId) public view returns (bool) {\r\n    return 0 < pepeId && pepeId <= (REBORN_PEPE_0 + rebornPepes.length - 1);//this.totalSupply();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an URI for a given token ID\r\n   * Throws if the token ID does not exist. May return an empty string.\r\n   * @param pepeId uint256 ID of the token to query\r\n   */\r\n  function tokenURI(uint256 pepeId) public view returns (string) {\r\n    require(exists(pepeId));\r\n    return string(abi.encodePacked(baseTokenURI, toString(pepeId)));\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the base URI for metadata.\r\n   * @param baseURI the new base URI\r\n   */\r\n   function setBaseTokenURI(string baseURI) public onlyOwner {\r\n     baseTokenURI = baseURI;\r\n   }\r\n\r\n   /**\r\n    * @dev Returns the URI for the contract\r\n    * @return the uri\r\n    */\r\n   function contractURI() public view returns (string) {\r\n     return contractUri;\r\n   }\r\n\r\n   /**\r\n    * @dev Changes the URI for the contract\r\n    * @param uri the new uri\r\n    */\r\n   function setContractURI(string uri) public onlyOwner {\r\n     contractUri = uri;\r\n   }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` representation.\r\n   * @param value a number to convert to string\r\n   * @return a string representation of the number\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Borrowed from Open Zeppelin, which was\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    uint256 index = digits - 1;\r\n    temp = value;\r\n    while (temp != 0) {\r\n      buffer[index--] = byte(uint8(48 + temp % 10));\r\n      temp /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev get Pepe information\r\n   * Returns information as separate variables\r\n   * @param  pepeId ID of the Pepe to get information of\r\n   * @return master\r\n   * @return genotype\r\n   * @return canCozyAgain\r\n   * @return generation\r\n   * @return father\r\n   * @return mother\r\n   * @return pepeName\r\n   * @return coolDownIndex\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function getPepe(uint256 pepeId) public view returns (address master, uint256[2] genotype, uint64 canCozyAgain, uint64 generation, uint256 father, uint256 mother, bytes32 pepeName, uint8 coolDownIndex) {\r\n    Pepe memory pepe = _getPepe(pepeId);\r\n    master = pepe.master;\r\n    genotype = pepe.genotype;\r\n    canCozyAgain = pepe.canCozyAgain;\r\n    generation = pepe.generation;\r\n    father = pepe.father;\r\n    mother = pepe.mother;\r\n    pepeName = pepeNames[pepeId];\r\n    coolDownIndex = pepe.coolDownIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev get Pepe information\r\n   * Returns information as a single Pepe struct\r\n   * @param  pepeId ID of the Pepe to get information of\r\n   * @return pepe info\r\n   */\r\n  function _getPepe(uint256 pepeId) internal view returns (Pepe memory) {\r\n    if(pepeId >= REBORN_PEPE_0) {\r\n      uint256 index = rebornPepeIdToIndex(pepeId);\r\n      require(index < rebornPepes.length);\r\n      return rebornPepes[index];\r\n    }else{\r\n      (address master, uint256[2] memory genotype, uint64 canCozyAgain, uint64 generation, uint256 father, uint256 mother, , uint8 coolDownIndex) = _getUndeadPepe(pepeId);\r\n      return Pepe({\r\n        master: master, // The master of the pepe\r\n        genotype: genotype, // all genes stored here\r\n        canCozyAgain: canCozyAgain, // time when pepe can have nice time again\r\n        father: uint64(father), // father of this pepe\r\n        mother: uint64(mother), // mommy of this pepe\r\n        generation: generation, // what generation?\r\n        coolDownIndex: coolDownIndex\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev get undead pepe information\r\n   * @param  pepeId ID of the Pepe to get information of\r\n   * @return master\r\n   * @return genotype\r\n   * @return canCozyAgain\r\n   * @return generation\r\n   * @return father\r\n   * @return mother\r\n   * @return pepeName\r\n   * @return coolDownIndex\r\n   */\r\n  function _getUndeadPepe(uint256 pepeId) internal view returns (address master, uint256[2] genotype, uint64 canCozyAgain, uint64 generation, uint256 father, uint256 mother, bytes32 pepeName, uint8 coolDownIndex) {\r\n    // if undead, pull from old contract\r\n    (master, genotype, canCozyAgain, generation, father, mother, pepeName, coolDownIndex) = PepeBase(PEPE_UNDEAD_ADDRRESS).getPepe(pepeId);\r\n    if(undeadPepes[pepeId].resurrected){\r\n      // if resurrected, pull from undead map\r\n      master = undeadPepes[pepeId].master;\r\n      canCozyAgain = undeadPepes[pepeId].canCozyAgain;\r\n      pepeName = pepeNames[pepeId];\r\n      coolDownIndex = undeadPepes[pepeId].coolDownIndex;\r\n    }else if(master == PEPE_AUCTION_SALE_UNDEAD_ADDRESS || master == COZY_TIME_AUCTION_UNDEAD_ADDRESS){\r\n      // if on auction, return to seller\r\n      (master, , , , , ) = AuctionBase(master).auctions(pepeId);\r\n    }\r\n  }\r\n\r\n  // Useful for tracking resurrections\r\n  event PepeResurrected(uint256 pepeId);\r\n\r\n  /**\r\n   * @dev Checks if the pepe needs to be resurrected from the old contract and if so does.\r\n   * @param pepeId ID of the Pepe to check\r\n   */\r\n  // solhint-disable-next-line max-line-length\r\n  function checkResurrected(uint256 pepeId) public {\r\n    if(pepeId >= REBORN_PEPE_0) return;\r\n    if(undeadPepes[pepeId].resurrected) return;\r\n    (address _master, , uint64 _canCozyAgain, , , , bytes32 _pepeName, uint8 _coolDownIndex) = _getUndeadPepe(pepeId);\r\n    undeadPepes[pepeId] = UndeadPepeMutable({\r\n      master: _master, // The master of the pepe\r\n      canCozyAgain: _canCozyAgain, // time when pepe can have nice time again\r\n      coolDownIndex: _coolDownIndex,\r\n      resurrected: true\r\n    });\r\n    if(_pepeName != 0x0000000000000000000000000000000000000000000000000000000000000000) pepeNames[pepeId] = _pepeName;\r\n    addToWallet(_master, pepeId);\r\n    emit PepeResurrected(pepeId);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates reborn pepe array index\r\n   * @param pepeId ID of the pepe to check\r\n   * @return array index\r\n   */\r\n  function rebornPepeIdToIndex(uint256 pepeId) internal pure returns (uint256) {\r\n    require(pepeId >= REBORN_PEPE_0);\r\n    return pepeId - REBORN_PEPE_0;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the address of the previous contracts\r\n   * This is only a precaution in case I mess up deployment\r\n   * @param baseaddr the correct PepeBase address\r\n   * @param saleauctionaddr the correct PepeSaleAuction address\r\n   * @param cozyauctionaddr the correct CozyTimeAuction address\r\n   */\r\n  function setPrevContracts(address baseaddr, address saleauctionaddr, address cozyauctionaddr) public onlyOwner {\r\n    PEPE_UNDEAD_ADDRRESS = baseaddr;\r\n    PEPE_AUCTION_SALE_UNDEAD_ADDRESS = saleauctionaddr;\r\n    COZY_TIME_AUCTION_UNDEAD_ADDRESS = cozyauctionaddr;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the gene pool contract address\r\n   * @param genePoolAddress the new pool address\r\n   */\r\n  function setGenePool(address genePoolAddress) public onlyOwner {\r\n    GenePoolInterface pool = GenePoolInterface(genePoolAddress);\r\n    require(pool.isGenePool());\r\n    genePool = pool;\r\n  }\r\n}\r\n\r\ncontract GenesisActTwo {\r\n\r\n    PepeReborn public cpepToken;\r\n    address public owner;\r\n    uint256 public price = 100000000000000000; // 0.1 eth\r\n    uint256 public mined;\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _cpepToken, address _owner) {\r\n        cpepToken = PepeReborn(_cpepToken);\r\n        owner = _owner;\r\n    }\r\n\r\n    function birth(uint256 amount) external payable {\r\n        require(msg.value >= amount * price, \"insufficient payment\");\r\n        uint256 startSupply = cpepToken.totalSupply();\r\n        cpepToken.pepePremine(amount);\r\n        for(uint256 pepeId = startSupply+1; pepeId <= startSupply + amount; ++pepeId) {\r\n            cpepToken.transfer(msg.sender, pepeId);\r\n        }\r\n        mined += amount;\r\n    }\r\n\r\n    function setPrice(uint256 _price) external onlyOwner {\r\n        price = _price;\r\n    }\r\n\r\n    function sweep(address recipient, uint256 amount) external onlyOwner {\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        cpepToken.transferOwnership(newOwner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mined\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cpepToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"birth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cpepToken\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"GenesisActTwo","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"000000000000000000000000e714485b00e1062c1dfef1aee64ad6c8b85987f3000000000000000000000000ebc146cc23b0742b603595f8bea7dabcbf05840a","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5a5c5ac9618ea3b561e9097b2263843bd6be10b8d9a9dd72da4386db2ef2b0f5"}]}