{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BurnedPalLoanToken.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\nimport {Errors} from  \\\"./utils/Errors.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./IPalLoanToken.sol\\\";\\n\\n\\n\\n/** @title BurnedPalLoanToken contract  */\\n/// @author Paladin\\ncontract BurnedPalLoanToken{\\n    using SafeMath for uint;\\n\\n    //Storage\\n\\n    // Token name\\n    string public name;\\n    // Token symbol\\n    string public symbol;\\n\\n    //Token Minter contract : PalLoanToken\\n    address public minter;\\n\\n    uint256 public totalSupply;\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256[]) private balances;\\n\\n\\n    //Modifiers\\n    modifier authorized() {\\n        //allows only the palLoanToken contract to call methds\\n        require(msg.sender == minter, Errors.CALLER_NOT_MINTER);\\n        _;\\n    }\\n\\n\\n    //Events\\n\\n    /** @notice Event when a new token is minted */\\n    event NewBurnedLoanToken(address indexed to, uint256 indexed tokenId);\\n\\n\\n    //Constructor\\n    constructor(string memory _name, string memory _symbol) {\\n        //ERC721 parameters\\n        name = _name;\\n        symbol = _symbol;\\n        minter = msg.sender;\\n        totalSupply = 0;\\n    }\\n\\n\\n\\n    //Functions\\n\\n\\n    //URI method\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        return IPalLoanToken(minter).tokenURI(tokenId);\\n    }\\n\\n    /**\\n    * @notice Return the user balance (total number of token owned)\\n    * @param owner Address of the user\\n    * @return uint256 : number of token owned (in this contract only)\\n    */\\n    function balanceOf(address owner) external view returns (uint256){\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return balances[owner].length;\\n    }\\n\\n\\n    /**\\n    * @notice Return owner of the token\\n    * @param tokenId Id of the token\\n    * @return address : owner address\\n    */\\n    function ownerOf(uint256 tokenId) external view returns (address){\\n        return owners[tokenId];\\n    }\\n\\n    \\n    /**\\n    * @notice Return the list of all tokens owned by the user\\n    * @dev Return the list of user's tokens\\n    * @param owner User address\\n    * @return uint256[] : list of owned tokens\\n    */\\n    function tokensOf(address owner) external view returns(uint256[] memory){\\n        return balances[owner];\\n    }\\n\\n    \\n\\n    /**\\n    * @notice Mint a new token to the given address with the given Id\\n    * @dev Mint the new token with the correct Id (from the previous burned token)\\n    * @param to Address of the user to mint the token to\\n    * @param tokenId Id of the token to mint\\n    * @return bool : success\\n    */\\n    function mint(address to, uint256 tokenId) external authorized returns(bool){\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n\\n        //Update Supply\\n        totalSupply = totalSupply.add(1);\\n\\n        //Add the new token to storage\\n        balances[to].push(tokenId);\\n        owners[tokenId] = to;\\n\\n        //Emit the correct Event\\n        emit NewBurnedLoanToken(to, tokenId);\\n\\n        return true;\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/utils/Errors.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\nlibrary Errors {\\n    // Admin error\\n    string public constant CALLER_NOT_ADMIN = '1'; // 'The caller must be the admin'\\n    string public constant CALLER_NOT_CONTROLLER = '29'; // 'The caller must be the admin or the controller'\\n    string public constant CALLER_NOT_ALLOWED_POOL = '30';  // 'The caller must be a palPool listed in the controller'\\n    string public constant CALLER_NOT_MINTER = '31';\\n\\n    // ERC20 type errors\\n    string public constant FAIL_TRANSFER = '2';\\n    string public constant FAIL_TRANSFER_FROM = '3';\\n    string public constant BALANCE_TOO_LOW = '4';\\n    string public constant ALLOWANCE_TOO_LOW = '5';\\n    string public constant SELF_TRANSFER = '6';\\n\\n    // PalPool errors\\n    string public constant INSUFFICIENT_CASH = '9';\\n    string public constant INSUFFICIENT_BALANCE = '10';\\n    string public constant FAIL_DEPOSIT = '11';\\n    string public constant FAIL_LOAN_INITIATE = '12';\\n    string public constant FAIL_BORROW = '13';\\n    string public constant ZERO_BORROW = '27';\\n    string public constant BORROW_INSUFFICIENT_FEES = '23';\\n    string public constant LOAN_CLOSED = '14';\\n    string public constant NOT_LOAN_OWNER = '15';\\n    string public constant LOAN_OWNER = '16';\\n    string public constant FAIL_LOAN_EXPAND = '17';\\n    string public constant NOT_KILLABLE = '18';\\n    string public constant RESERVE_FUNDS_INSUFFICIENT = '19';\\n    string public constant FAIL_MINT = '20';\\n    string public constant FAIL_BURN = '21';\\n    string public constant FAIL_WITHDRAW = '24';\\n    string public constant FAIL_CLOSE_BORROW = '25';\\n    string public constant FAIL_KILL_BORROW = '26';\\n    string public constant ZERO_ADDRESS = '22';\\n    string public constant INVALID_PARAMETERS = '28'; \\n    string public constant FAIL_LOAN_DELEGATEE_CHANGE = '32';\\n    string public constant FAIL_LOAN_TOKEN_BURN = '33';\\n    string public constant FEES_ACCRUED_INSUFFICIENT = '34';\\n\\n}\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/IPalLoanToken.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./utils/IERC721.sol\\\";\\n\\n/** @title palLoanToken Interface  */\\n/// @author Paladin\\ninterface IPalLoanToken is IERC721 {\\n\\n    //Events\\n\\n    /** @notice Event when a new Loan Token is minted */\\n    event NewLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\\n    /** @notice Event when a Loan Token is burned */\\n    event BurnLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\\n\\n\\n    //Functions\\n    function mint(address to, address palPool, address palLoan) external returns(uint256);\\n    function burn(uint256 tokenId) external returns(bool);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function tokenOfByIndex(address owner, uint256 tokenIdex) external view returns (uint256);\\n    function loanOf(uint256 tokenId) external view returns(address);\\n    function poolOf(uint256 tokenId) external view returns(address);\\n    function loansOf(address owner) external view returns(address[] memory);\\n    function tokensOf(address owner) external view returns(uint256[] memory);\\n    function loansOfForPool(address owner, address palPool) external view returns(address[] memory);\\n    function allTokensOf(address owner) external view returns(uint256[] memory);\\n    function allLoansOf(address owner) external view returns(address[] memory);\\n    function allLoansOfForPool(address owner, address palPool) external view returns(address[] memory);\\n    function allOwnerOf(uint256 tokenId) external view returns(address);\\n\\n    function isBurned(uint256 tokenId) external view returns(bool);\\n\\n    //Admin functions\\n    function setNewController(address _newController) external;\\n    function setNewBaseURI(string memory _newBaseURI) external;\\n\\n}\"\r\n    },\r\n    \"contracts/utils/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/utils/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NewBurnedLoanToken\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BurnedPalLoanToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"25000","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000136275726e656450616c4c6f616e20546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000462504c5400000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}