{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PremiaOptionNFTDisplay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Metadata} from \\\"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport {IPool} from \\\"./pool/IPool.sol\\\";\\nimport {PoolStorage} from \\\"./pool/PoolStorage.sol\\\";\\nimport {NFTDisplay} from \\\"./libraries/NFTDisplay.sol\\\";\\nimport {IPremiaOptionNFTDisplay} from \\\"./interface/IPremiaOptionNFTDisplay.sol\\\";\\n\\ncontract PremiaOptionNFTDisplay is IPremiaOptionNFTDisplay {\\n    using Strings for uint256;\\n\\n    function tokenURI(address _pool, uint256 _tokenId)\\n        external\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        IPool pool = IPool(_pool);\\n        PoolStorage.PoolSettings memory settings = pool.getPoolSettings();\\n        (\\n            PoolStorage.TokenType tokenType,\\n            uint64 maturity,\\n            int128 strikePrice\\n        ) = pool.getParametersForTokenId(_tokenId);\\n\\n        bool isCall = tokenType == PoolStorage.TokenType.SHORT_CALL ||\\n            tokenType == PoolStorage.TokenType.LONG_CALL;\\n        bool isLong = tokenType == PoolStorage.TokenType.LONG_CALL ||\\n            tokenType == PoolStorage.TokenType.LONG_PUT;\\n\\n        IERC20Metadata baseToken = IERC20Metadata(settings.base);\\n        IERC20Metadata underlyingToken = IERC20Metadata(settings.underlying);\\n\\n        return\\n            NFTDisplay.buildTokenURI(\\n                NFTDisplay.BuildTokenURIParams({\\n                    tokenId: _tokenId,\\n                    pool: _pool,\\n                    base: settings.base,\\n                    underlying: settings.underlying,\\n                    maturity: maturity,\\n                    strikePrice: strikePrice,\\n                    isCall: isCall,\\n                    isLong: isLong,\\n                    baseSymbol: baseToken.symbol(),\\n                    underlyingSymbol: underlyingToken.symbol()\\n                })\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC20 metadata interface\\n */\\ninterface IERC20Metadata {\\n    /**\\n     * @notice return token name\\n     * @return token name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice return token symbol\\n     * @return token symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice return token decimals, generally used only for display purposes\\n     * @return token decimals\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pool/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IPoolBase} from \\\"./IPoolBase.sol\\\";\\r\\nimport {IPoolEvents} from \\\"./IPoolEvents.sol\\\";\\r\\nimport {IPoolExercise} from \\\"./IPoolExercise.sol\\\";\\r\\nimport {IPoolIO} from \\\"./IPoolIO.sol\\\";\\r\\nimport {IPoolSettings} from \\\"./IPoolSettings.sol\\\";\\r\\nimport {IPoolView} from \\\"./IPoolView.sol\\\";\\r\\nimport {IPoolWrite} from \\\"./IPoolWrite.sol\\\";\\r\\n\\r\\ninterface IPool is\\r\\n    IPoolBase,\\r\\n    IPoolEvents,\\r\\n    IPoolExercise,\\r\\n    IPoolIO,\\r\\n    IPoolSettings,\\r\\n    IPoolView,\\r\\n    IPoolWrite\\r\\n{}\\r\\n\"\r\n    },\r\n    \"contracts/pool/PoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {AggregatorInterface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\\\";\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {EnumerableSet, ERC1155EnumerableStorage} from \\\"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol\\\";\\n\\nimport {ABDKMath64x64} from \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\nimport {ABDKMath64x64Token} from \\\"../libraries/ABDKMath64x64Token.sol\\\";\\nimport {OptionMath} from \\\"../libraries/OptionMath.sol\\\";\\n\\nlibrary PoolStorage {\\n    using ABDKMath64x64 for int128;\\n    using PoolStorage for PoolStorage.Layout;\\n\\n    enum TokenType {\\n        UNDERLYING_FREE_LIQ,\\n        BASE_FREE_LIQ,\\n        UNDERLYING_RESERVED_LIQ,\\n        BASE_RESERVED_LIQ,\\n        LONG_CALL,\\n        SHORT_CALL,\\n        LONG_PUT,\\n        SHORT_PUT\\n    }\\n\\n    struct PoolSettings {\\n        address underlying;\\n        address base;\\n        address underlyingOracle;\\n        address baseOracle;\\n    }\\n\\n    struct QuoteArgsInternal {\\n        address feePayer; // address of the fee payer\\n        uint64 maturity; // timestamp of option maturity\\n        int128 strike64x64; // 64x64 fixed point representation of strike price\\n        int128 spot64x64; // 64x64 fixed point representation of spot price\\n        uint256 contractSize; // size of option contract\\n        bool isCall; // true for call, false for put\\n    }\\n\\n    struct QuoteResultInternal {\\n        int128 baseCost64x64; // 64x64 fixed point representation of option cost denominated in underlying currency (without fee)\\n        int128 feeCost64x64; // 64x64 fixed point representation of option fee cost denominated in underlying currency for call, or base currency for put\\n        int128 cLevel64x64; // 64x64 fixed point representation of C-Level of Pool after purchase\\n        int128 slippageCoefficient64x64; // 64x64 fixed point representation of slippage coefficient for given order size\\n    }\\n\\n    struct BatchData {\\n        uint256 eta;\\n        uint256 totalPendingDeposits;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"premia.contracts.storage.Pool\\\");\\n\\n    uint256 private constant C_DECAY_BUFFER = 12 hours;\\n    uint256 private constant C_DECAY_INTERVAL = 4 hours;\\n\\n    struct Layout {\\n        // ERC20 token addresses\\n        address base;\\n        address underlying;\\n        // AggregatorV3Interface oracle addresses\\n        address baseOracle;\\n        address underlyingOracle;\\n        // token metadata\\n        uint8 underlyingDecimals;\\n        uint8 baseDecimals;\\n        // minimum amounts\\n        uint256 baseMinimum;\\n        uint256 underlyingMinimum;\\n        // deposit caps\\n        uint256 basePoolCap;\\n        uint256 underlyingPoolCap;\\n        // market state\\n        int128 steepness64x64;\\n        int128 cLevelBase64x64;\\n        int128 cLevelUnderlying64x64;\\n        uint256 cLevelBaseUpdatedAt;\\n        uint256 cLevelUnderlyingUpdatedAt;\\n        uint256 updatedAt;\\n        // User -> isCall -> depositedAt\\n        mapping(address => mapping(bool => uint256)) depositedAt;\\n        mapping(address => mapping(bool => uint256)) divestmentTimestamps;\\n        // doubly linked list of free liquidity intervals\\n        // isCall -> User -> User\\n        mapping(bool => mapping(address => address)) liquidityQueueAscending;\\n        mapping(bool => mapping(address => address)) liquidityQueueDescending;\\n        // minimum resolution price bucket => price\\n        mapping(uint256 => int128) bucketPrices64x64;\\n        // sequence id (minimum resolution price bucket / 256) => price update sequence\\n        mapping(uint256 => uint256) priceUpdateSequences;\\n        // isCall -> batch data\\n        mapping(bool => BatchData) nextDeposits;\\n        // user -> batch timestamp -> isCall -> pending amount\\n        mapping(address => mapping(uint256 => mapping(bool => uint256))) pendingDeposits;\\n        EnumerableSet.UintSet tokenIds;\\n        // user -> isCallPool -> total value locked of user (Used for liquidity mining)\\n        mapping(address => mapping(bool => uint256)) userTVL;\\n        // isCallPool -> total value locked\\n        mapping(bool => uint256) totalTVL;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate ERC1155 token id for given option parameters\\n     * @param tokenType TokenType enum\\n     * @param maturity timestamp of option maturity\\n     * @param strike64x64 64x64 fixed point representation of strike price\\n     * @return tokenId token id\\n     */\\n    function formatTokenId(\\n        TokenType tokenType,\\n        uint64 maturity,\\n        int128 strike64x64\\n    ) internal pure returns (uint256 tokenId) {\\n        tokenId =\\n            (uint256(tokenType) << 248) +\\n            (uint256(maturity) << 128) +\\n            uint256(int256(strike64x64));\\n    }\\n\\n    /**\\n     * @notice derive option maturity and strike price from ERC1155 token id\\n     * @param tokenId token id\\n     * @return tokenType TokenType enum\\n     * @return maturity timestamp of option maturity\\n     * @return strike64x64 option strike price\\n     */\\n    function parseTokenId(uint256 tokenId)\\n        internal\\n        pure\\n        returns (\\n            TokenType tokenType,\\n            uint64 maturity,\\n            int128 strike64x64\\n        )\\n    {\\n        assembly {\\n            tokenType := shr(248, tokenId)\\n            maturity := shr(128, tokenId)\\n            strike64x64 := tokenId\\n        }\\n    }\\n\\n    function getTokenDecimals(Layout storage l, bool isCall)\\n        internal\\n        view\\n        returns (uint8 decimals)\\n    {\\n        decimals = isCall ? l.underlyingDecimals : l.baseDecimals;\\n    }\\n\\n    function totalFreeLiquiditySupply64x64(Layout storage l, bool isCall)\\n        internal\\n        view\\n        returns (int128)\\n    {\\n        uint256 tokenId = formatTokenId(\\n            isCall ? TokenType.UNDERLYING_FREE_LIQ : TokenType.BASE_FREE_LIQ,\\n            0,\\n            0\\n        );\\n\\n        return\\n            ABDKMath64x64Token.fromDecimals(\\n                ERC1155EnumerableStorage.layout().totalSupply[tokenId] -\\n                    l.nextDeposits[isCall].totalPendingDeposits,\\n                l.getTokenDecimals(isCall)\\n            );\\n    }\\n\\n    function getReinvestmentStatus(\\n        Layout storage l,\\n        address account,\\n        bool isCallPool\\n    ) internal view returns (bool) {\\n        uint256 timestamp = l.divestmentTimestamps[account][isCallPool];\\n        return timestamp == 0 || timestamp > block.timestamp;\\n    }\\n\\n    function addUnderwriter(\\n        Layout storage l,\\n        address account,\\n        bool isCallPool\\n    ) internal {\\n        require(account != address(0));\\n\\n        mapping(address => address) storage asc = l.liquidityQueueAscending[\\n            isCallPool\\n        ];\\n        mapping(address => address) storage desc = l.liquidityQueueDescending[\\n            isCallPool\\n        ];\\n\\n        if (_isInQueue(account, asc, desc)) return;\\n\\n        address last = desc[address(0)];\\n\\n        asc[last] = account;\\n        desc[account] = last;\\n        desc[address(0)] = account;\\n    }\\n\\n    function removeUnderwriter(\\n        Layout storage l,\\n        address account,\\n        bool isCallPool\\n    ) internal {\\n        require(account != address(0));\\n\\n        mapping(address => address) storage asc = l.liquidityQueueAscending[\\n            isCallPool\\n        ];\\n        mapping(address => address) storage desc = l.liquidityQueueDescending[\\n            isCallPool\\n        ];\\n\\n        if (!_isInQueue(account, asc, desc)) return;\\n\\n        address prev = desc[account];\\n        address next = asc[account];\\n        asc[prev] = next;\\n        desc[next] = prev;\\n        delete asc[account];\\n        delete desc[account];\\n    }\\n\\n    function isInQueue(\\n        Layout storage l,\\n        address account,\\n        bool isCallPool\\n    ) internal view returns (bool) {\\n        mapping(address => address) storage asc = l.liquidityQueueAscending[\\n            isCallPool\\n        ];\\n        mapping(address => address) storage desc = l.liquidityQueueDescending[\\n            isCallPool\\n        ];\\n\\n        return _isInQueue(account, asc, desc);\\n    }\\n\\n    function _isInQueue(\\n        address account,\\n        mapping(address => address) storage asc,\\n        mapping(address => address) storage desc\\n    ) private view returns (bool) {\\n        return asc[account] != address(0) || desc[address(0)] == account;\\n    }\\n\\n    function getCLevel(Layout storage l, bool isCall)\\n        internal\\n        view\\n        returns (int128 cLevel64x64)\\n    {\\n        int128 oldCLevel64x64 = isCall\\n            ? l.cLevelUnderlying64x64\\n            : l.cLevelBase64x64;\\n\\n        uint256 timeElapsed = block.timestamp -\\n            (isCall ? l.cLevelUnderlyingUpdatedAt : l.cLevelBaseUpdatedAt);\\n\\n        // do not apply C decay if less than 24 hours have elapsed\\n\\n        if (timeElapsed > C_DECAY_BUFFER) {\\n            timeElapsed -= C_DECAY_BUFFER;\\n        } else {\\n            return oldCLevel64x64;\\n        }\\n\\n        int128 timeIntervalsElapsed64x64 = ABDKMath64x64.divu(\\n            timeElapsed,\\n            C_DECAY_INTERVAL\\n        );\\n\\n        uint256 tokenId = formatTokenId(\\n            isCall ? TokenType.UNDERLYING_FREE_LIQ : TokenType.BASE_FREE_LIQ,\\n            0,\\n            0\\n        );\\n\\n        uint256 tvl = l.totalTVL[isCall];\\n\\n        int128 utilization = ABDKMath64x64.divu(\\n            tvl -\\n                (ERC1155EnumerableStorage.layout().totalSupply[tokenId] -\\n                    l.nextDeposits[isCall].totalPendingDeposits),\\n            tvl\\n        );\\n\\n        cLevel64x64 = OptionMath.calculateCLevelDecay(\\n            OptionMath.CalculateCLevelDecayArgs(\\n                timeIntervalsElapsed64x64,\\n                oldCLevel64x64,\\n                utilization,\\n                0xb333333333333333, // 0.7\\n                0xe666666666666666, // 0.9\\n                0x10000000000000000, // 1.0\\n                0x10000000000000000, // 1.0\\n                0xe666666666666666, // 0.9\\n                0x56fc2a2c515da32ea // 2e\\n            )\\n        );\\n    }\\n\\n    function setCLevel(\\n        Layout storage l,\\n        int128 oldLiquidity64x64,\\n        int128 newLiquidity64x64,\\n        bool isCallPool\\n    ) internal returns (int128 cLevel64x64) {\\n        cLevel64x64 = l.calculateCLevel(\\n            oldLiquidity64x64,\\n            newLiquidity64x64,\\n            isCallPool\\n        );\\n\\n        l.setCLevel(cLevel64x64, isCallPool);\\n    }\\n\\n    function setCLevel(\\n        Layout storage l,\\n        int128 cLevel64x64,\\n        bool isCallPool\\n    ) internal {\\n        if (isCallPool) {\\n            l.cLevelUnderlying64x64 = cLevel64x64;\\n            l.cLevelUnderlyingUpdatedAt = block.timestamp;\\n        } else {\\n            l.cLevelBase64x64 = cLevel64x64;\\n            l.cLevelBaseUpdatedAt = block.timestamp;\\n        }\\n    }\\n\\n    function calculateCLevel(\\n        Layout storage l,\\n        int128 oldLiquidity64x64,\\n        int128 newLiquidity64x64,\\n        bool isCallPool\\n    ) internal view returns (int128 cLevel64x64) {\\n        cLevel64x64 = OptionMath.calculateCLevel(\\n            l.getCLevel(isCallPool),\\n            oldLiquidity64x64,\\n            newLiquidity64x64,\\n            l.steepness64x64\\n        );\\n\\n        if (cLevel64x64 < 0xb333333333333333) {\\n            cLevel64x64 = int128(0xb333333333333333); // 64x64 fixed point representation of 0.7\\n        }\\n    }\\n\\n    function setOracles(\\n        Layout storage l,\\n        address baseOracle,\\n        address underlyingOracle\\n    ) internal {\\n        require(\\n            AggregatorV3Interface(baseOracle).decimals() ==\\n                AggregatorV3Interface(underlyingOracle).decimals(),\\n            \\\"Pool: oracle decimals must match\\\"\\n        );\\n\\n        l.baseOracle = baseOracle;\\n        l.underlyingOracle = underlyingOracle;\\n    }\\n\\n    function fetchPriceUpdate(Layout storage l)\\n        internal\\n        view\\n        returns (int128 price64x64)\\n    {\\n        int256 priceUnderlying = AggregatorInterface(l.underlyingOracle)\\n            .latestAnswer();\\n        int256 priceBase = AggregatorInterface(l.baseOracle).latestAnswer();\\n\\n        return ABDKMath64x64.divi(priceUnderlying, priceBase);\\n    }\\n\\n    /**\\n     * @notice set price update for current hourly bucket\\n     * @param l storage layout struct\\n     * @param timestamp timestamp to update\\n     * @param price64x64 64x64 fixed point representation of price\\n     */\\n    function setPriceUpdate(\\n        Layout storage l,\\n        uint256 timestamp,\\n        int128 price64x64\\n    ) internal {\\n        uint256 bucket = timestamp / (1 hours);\\n        l.bucketPrices64x64[bucket] = price64x64;\\n        l.priceUpdateSequences[bucket >> 8] += 1 << (255 - (bucket & 255));\\n    }\\n\\n    /**\\n     * @notice get price update for hourly bucket corresponding to given timestamp\\n     * @param l storage layout struct\\n     * @param timestamp timestamp to query\\n     * @return 64x64 fixed point representation of price\\n     */\\n    function getPriceUpdate(Layout storage l, uint256 timestamp)\\n        internal\\n        view\\n        returns (int128)\\n    {\\n        return l.bucketPrices64x64[timestamp / (1 hours)];\\n    }\\n\\n    /**\\n     * @notice get first price update available following given timestamp\\n     * @param l storage layout struct\\n     * @param timestamp timestamp to query\\n     * @return 64x64 fixed point representation of price\\n     */\\n    function getPriceUpdateAfter(Layout storage l, uint256 timestamp)\\n        internal\\n        view\\n        returns (int128)\\n    {\\n        // price updates are grouped into hourly buckets\\n        uint256 bucket = timestamp / (1 hours);\\n        // divide by 256 to get the index of the relevant price update sequence\\n        uint256 sequenceId = bucket >> 8;\\n\\n        // get position within sequence relevant to current price update\\n\\n        uint256 offset = bucket & 255;\\n        // shift to skip buckets from earlier in sequence\\n        uint256 sequence = (l.priceUpdateSequences[sequenceId] << offset) >>\\n            offset;\\n\\n        // iterate through future sequences until a price update is found\\n        // sequence corresponding to current timestamp used as upper bound\\n\\n        uint256 currentPriceUpdateSequenceId = block.timestamp / (256 hours);\\n\\n        while (sequence == 0 && sequenceId <= currentPriceUpdateSequenceId) {\\n            sequence = l.priceUpdateSequences[++sequenceId];\\n        }\\n\\n        // if no price update is found (sequence == 0) function will return 0\\n        // this should never occur, as each relevant external function triggers a price update\\n\\n        // the most significant bit of the sequence corresponds to the offset of the relevant bucket\\n\\n        uint256 msb;\\n\\n        for (uint256 i = 128; i > 0; i >>= 1) {\\n            if (sequence >> i > 0) {\\n                msb += i;\\n                sequence >>= i;\\n            }\\n        }\\n\\n        return l.bucketPrices64x64[((sequenceId + 1) << 8) - msb - 1];\\n    }\\n\\n    function fromBaseToUnderlyingDecimals(Layout storage l, uint256 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        int128 valueFixed64x64 = ABDKMath64x64Token.fromDecimals(\\n            value,\\n            l.baseDecimals\\n        );\\n        return\\n            ABDKMath64x64Token.toDecimals(\\n                valueFixed64x64,\\n                l.underlyingDecimals\\n            );\\n    }\\n\\n    function fromUnderlyingToBaseDecimals(Layout storage l, uint256 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        int128 valueFixed64x64 = ABDKMath64x64Token.fromDecimals(\\n            value,\\n            l.underlyingDecimals\\n        );\\n        return ABDKMath64x64Token.toDecimals(valueFixed64x64, l.baseDecimals);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NFTDisplay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {ABDKMath64x64} from \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {Base64} from \\\"base64-sol/base64.sol\\\";\\n\\nimport {NFTSVG} from \\\"./NFTSVG.sol\\\";\\n\\nlibrary NFTDisplay {\\n    using Strings for uint256;\\n    using Strings for uint256;\\n    using ABDKMath64x64 for int128;\\n\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    struct BuildTokenURIParams {\\n        uint256 tokenId;\\n        address pool;\\n        address base;\\n        address underlying;\\n        uint64 maturity;\\n        int128 strikePrice;\\n        bool isCall;\\n        bool isLong;\\n        string baseSymbol;\\n        string underlyingSymbol;\\n    }\\n\\n    function buildTokenURI(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory base64image;\\n\\n        {\\n            string memory svgImage = buildSVGImage(_params);\\n            base64image = Base64.encode(bytes(svgImage));\\n        }\\n\\n        string memory description = buildDescription(_params);\\n        string memory name = buildName(_params);\\n        string memory attributes = buildAttributes(_params);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        bytes(\\n                            abi.encodePacked(\\n                                \\\"{\\\",\\n                                '\\\"image\\\":\\\"',\\n                                \\\"data:image/svg+xml;base64,\\\",\\n                                base64image,\\n                                '\\\",',\\n                                '\\\"description\\\":\\\"',\\n                                description,\\n                                '\\\",',\\n                                '\\\"name\\\":\\\"',\\n                                name,\\n                                '\\\",',\\n                                attributes,\\n                                \\\"}\\\"\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function buildSVGImage(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory maturityString = maturityToString(_params.maturity);\\n        string memory strikePriceString = fixedToDecimalString(\\n            _params.strikePrice\\n        );\\n\\n        return\\n            NFTSVG.buildSVG(\\n                NFTSVG.CreateSVGParams({\\n                    isCall: _params.isCall,\\n                    isLong: _params.isLong,\\n                    baseSymbol: _params.baseSymbol,\\n                    underlyingSymbol: _params.underlyingSymbol,\\n                    strikePriceString: strikePriceString,\\n                    maturityString: maturityString\\n                })\\n            );\\n    }\\n\\n    function buildDescription(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory descriptionPartA = buildDescriptionPartA(\\n            _params.pool,\\n            _params.base,\\n            _params.underlying,\\n            _params.baseSymbol,\\n            _params.underlyingSymbol,\\n            _params.isLong\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    descriptionPartA,\\n                    _params.baseSymbol,\\n                    \\\"\\\\\\\\n\\\\\\\\nMaturity: \\\",\\n                    maturityToString(_params.maturity),\\n                    \\\"\\\\\\\\n\\\\\\\\nStrike Price: \\\",\\n                    strikePriceToString(\\n                        _params.strikePrice,\\n                        _params.baseSymbol\\n                    ),\\n                    \\\"\\\\\\\\n\\\\\\\\nType: \\\",\\n                    optionTypeToString(_params.isCall, _params.isLong),\\n                    \\\"\\\\\\\\n\\\\\\\\nToken ID: \\\",\\n                    _params.tokenId.toString(),\\n                    \\\"\\\\\\\\n\\\\\\\\n\\\",\\n                    unicode\\\"⚠️ DISCLAIMER: Due diligence is imperative when assessing this NFT. Double check the option details and make sure token addresses match the expected tokens, as token symbols may be imitated.\\\"\\n                )\\n            );\\n    }\\n\\n    function buildDescriptionPartA(\\n        address pool,\\n        address base,\\n        address underlying,\\n        string memory baseSymbol,\\n        string memory underlyingSymbol,\\n        bool isLong\\n    ) public pure returns (string memory) {\\n        string memory pairName = getPairName(baseSymbol, underlyingSymbol);\\n        bytes memory bufferA = abi.encodePacked(\\n            \\\"This NFT represents a \\\",\\n            longShortToString(isLong),\\n            \\\" option position in a Premia V2 \\\",\\n            pairName,\\n            \\\" pool. The owner of the NFT can transfer or \\\",\\n            isLong ? \\\"exercise\\\" : \\\"sell\\\",\\n            \\\" the position.\\\",\\n            \\\"\\\\\\\\n\\\\\\\\nPool Address: \\\"\\n        );\\n\\n        bytes memory bufferB = abi.encodePacked(\\n            addressToString(pool),\\n            \\\"\\\\\\\\n\\\\\\\\n\\\",\\n            underlyingSymbol,\\n            \\\" Address: \\\",\\n            addressToString(underlying),\\n            \\\"\\\\\\\\n\\\\\\\\n\\\",\\n            \\\" Address: \\\",\\n            addressToString(base)\\n        );\\n\\n        return string(abi.encodePacked(bufferA, bufferB));\\n    }\\n\\n    function buildName(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory pairName = getPairName(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"Premia - \\\",\\n                    pairName,\\n                    \\\" - \\\",\\n                    maturityToString(_params.maturity),\\n                    \\\" - \\\",\\n                    strikePriceToString(\\n                        _params.strikePrice,\\n                        _params.baseSymbol\\n                    ),\\n                    \\\" - \\\",\\n                    optionTypeToString(_params.isCall, _params.isLong)\\n                )\\n            );\\n    }\\n\\n    function buildAttributes(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory pairName = getPairName(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol\\n        );\\n\\n        bytes memory buffer = abi.encodePacked(\\n            '\\\"attributes\\\":[',\\n            '{\\\"trait_type\\\":\\\"Market\\\",\\\"value\\\":\\\"Premia V2\\\"},',\\n            '{\\\"trait_type\\\":\\\"Pair\\\",\\\"value\\\":\\\"',\\n            pairName,\\n            '\\\"},',\\n            '{\\\"trait_type\\\":\\\"Underlying Token\\\",\\\"value\\\":\\\"',\\n            addressToString(_params.underlying),\\n            '\\\"},'\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    buffer,\\n                    '{\\\"trait_type\\\":\\\"Base Token\\\",\\\"value\\\":\\\"',\\n                    addressToString(_params.base),\\n                    '\\\"},',\\n                    '{\\\"trait_type\\\":\\\"Maturity\\\",\\\"value\\\":\\\"',\\n                    maturityToString(_params.maturity),\\n                    '\\\"},',\\n                    '{\\\"trait_type\\\":\\\"Strike Price\\\",\\\"value\\\":\\\"',\\n                    strikePriceToString(\\n                        _params.strikePrice,\\n                        _params.baseSymbol\\n                    ),\\n                    '\\\"},',\\n                    '{\\\"trait_type\\\":\\\"Type\\\",\\\"value\\\":\\\"',\\n                    optionTypeToString(_params.isCall, _params.isLong),\\n                    '\\\"}',\\n                    \\\"]\\\"\\n                )\\n            );\\n    }\\n\\n    function getPairName(\\n        string memory baseSymbol,\\n        string memory underlyingSymbol\\n    ) public pure returns (string memory) {\\n        return string(abi.encodePacked(underlyingSymbol, \\\"/\\\", baseSymbol));\\n    }\\n\\n    function maturityToString(uint64 maturity)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        (uint256 year, uint256 month, uint256 date) = timestampToDate(maturity);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    date.toString(),\\n                    \\\"-\\\",\\n                    monthToString(month),\\n                    \\\"-\\\",\\n                    year.toString()\\n                )\\n            );\\n    }\\n\\n    function strikePriceToString(int128 strikePrice, string memory baseSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    fixedToDecimalString(strikePrice),\\n                    \\\" \\\",\\n                    baseSymbol\\n                )\\n            );\\n    }\\n\\n    function optionTypeToString(bool isCall, bool isLong)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    isLong ? \\\"LONG \\\" : \\\"SHORT \\\",\\n                    isCall ? \\\"CALL\\\" : \\\"PUT\\\"\\n                )\\n            );\\n    }\\n\\n    function longShortToString(bool isLong)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return isLong ? \\\"LONG\\\" : \\\"SHORT\\\";\\n    }\\n\\n    function monthToString(uint256 month)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (month == 1) {\\n            return \\\"JAN\\\";\\n        } else if (month == 2) {\\n            return \\\"FEB\\\";\\n        } else if (month == 3) {\\n            return \\\"MAR\\\";\\n        } else if (month == 4) {\\n            return \\\"APR\\\";\\n        } else if (month == 5) {\\n            return \\\"MAY\\\";\\n        } else if (month == 6) {\\n            return \\\"JUN\\\";\\n        } else if (month == 7) {\\n            return \\\"JUL\\\";\\n        } else if (month == 8) {\\n            return \\\"AUG\\\";\\n        } else if (month == 9) {\\n            return \\\"SEP\\\";\\n        } else if (month == 10) {\\n            return \\\"OCT\\\";\\n        } else if (month == 11) {\\n            return \\\"NOV\\\";\\n        }\\n\\n        return \\\"DEC\\\";\\n    }\\n\\n    function addressToString(address addr) public pure returns (string memory) {\\n        bytes memory data = abi.encodePacked(addr);\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(2 + data.length * 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < data.length; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n\\n    function fixedToDecimalString(int128 value64x64)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        bool negative = value64x64 < 0;\\n        uint256 integer = uint256(value64x64.abs().toUInt());\\n        int128 decimal64x64 = value64x64 - int128(int256(integer << 64));\\n        uint256 decimal = (decimal64x64 * 1000).toUInt();\\n        string memory decimalString = \\\"\\\";\\n\\n        if (decimal > 0) {\\n            decimalString = string(\\n                abi.encodePacked(\\\".\\\", onlySignificant(decimal))\\n            );\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    negative ? \\\"-\\\" : \\\"\\\",\\n                    commaSeparateInteger(integer),\\n                    decimalString\\n                )\\n            );\\n    }\\n\\n    function onlySignificant(uint256 decimal)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory b = bytes(decimal.toString());\\n        bytes memory buffer;\\n        bool foundSignificant;\\n\\n        for (uint256 i; i < b.length; i++) {\\n            if (!foundSignificant && b[b.length - i - 1] != bytes1(\\\"0\\\"))\\n                foundSignificant = true;\\n\\n            if (foundSignificant) {\\n                buffer = abi.encodePacked(b[b.length - i - 1], buffer);\\n            }\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function commaSeparateInteger(uint256 integer)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory b = bytes(integer.toString());\\n        bytes memory buffer;\\n\\n        for (uint256 i; i < b.length; i++) {\\n            if (i > 0 && i % 3 == 0) {\\n                buffer = abi.encodePacked(b[b.length - i - 1], \\\",\\\", buffer);\\n            } else {\\n                buffer = abi.encodePacked(b[b.length - i - 1], buffer);\\n            }\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    /*\\n     * Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\\n     */\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPremiaOptionNFTDisplay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPremiaOptionNFTDisplay {\\r\\n    function tokenURI(address _pool, uint256 _tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC1155} from \\\"@solidstate/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\nimport {IERC1155Enumerable} from \\\"@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol\\\";\\r\\nimport {IMulticall} from \\\"@solidstate/contracts/utils/IMulticall.sol\\\";\\r\\n\\r\\ninterface IPoolBase is IERC1155, IERC1155Enumerable, IMulticall {\\r\\n    function name() external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPoolEvents {\\r\\n    event Purchase(\\r\\n        address indexed user,\\r\\n        uint256 longTokenId,\\r\\n        uint256 contractSize,\\r\\n        uint256 baseCost,\\r\\n        uint256 feeCost,\\r\\n        int128 spot64x64\\r\\n    );\\r\\n\\r\\n    event Exercise(\\r\\n        address indexed user,\\r\\n        uint256 longTokenId,\\r\\n        uint256 contractSize,\\r\\n        uint256 exerciseValue,\\r\\n        uint256 fee\\r\\n    );\\r\\n\\r\\n    event Underwrite(\\r\\n        address indexed underwriter,\\r\\n        address indexed longReceiver,\\r\\n        uint256 shortTokenId,\\r\\n        uint256 intervalContractSize,\\r\\n        uint256 intervalPremium,\\r\\n        bool isManualUnderwrite\\r\\n    );\\r\\n\\r\\n    event AssignExercise(\\r\\n        address indexed underwriter,\\r\\n        uint256 shortTokenId,\\r\\n        uint256 freedAmount,\\r\\n        uint256 intervalContractSize,\\r\\n        uint256 fee\\r\\n    );\\r\\n\\r\\n    event Deposit(address indexed user, bool isCallPool, uint256 amount);\\r\\n\\r\\n    event Withdrawal(\\r\\n        address indexed user,\\r\\n        bool isCallPool,\\r\\n        uint256 depositedAt,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event FeeWithdrawal(bool indexed isCallPool, uint256 amount);\\r\\n\\r\\n    event Annihilate(uint256 shortTokenId, uint256 amount);\\r\\n\\r\\n    event UpdateCLevel(\\r\\n        bool indexed isCall,\\r\\n        int128 cLevel64x64,\\r\\n        int128 oldLiquidity64x64,\\r\\n        int128 newLiquidity64x64\\r\\n    );\\r\\n\\r\\n    event UpdateSteepness(int128 steepness64x64);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolExercise.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPoolExercise {\\r\\n    function exerciseFrom(\\r\\n        address holder,\\r\\n        uint256 longTokenId,\\r\\n        uint256 contractSize\\r\\n    ) external;\\r\\n\\r\\n    function processExpired(uint256 longTokenId, uint256 contractSize) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolIO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPoolIO {\\r\\n    function setDivestmentTimestamp(uint64 timestamp, bool isCallPool) external;\\r\\n\\r\\n    function deposit(uint256 amount, bool isCallPool) external payable;\\r\\n\\r\\n    function swapAndDeposit(\\r\\n        uint256 amount,\\r\\n        bool isCallPool,\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        bool isSushi\\r\\n    ) external payable;\\r\\n\\r\\n    function withdraw(uint256 amount, bool isCallPool) external;\\r\\n\\r\\n    function reassign(uint256 tokenId, uint256 contractSize)\\r\\n        external\\r\\n        returns (\\r\\n            uint256 baseCost,\\r\\n            uint256 feeCost,\\r\\n            uint256 amountOut\\r\\n        );\\r\\n\\r\\n    function reassignBatch(\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata contractSizes\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256[] memory baseCosts,\\r\\n            uint256[] memory feeCosts,\\r\\n            uint256 amountOutCall,\\r\\n            uint256 amountOutPut\\r\\n        );\\r\\n\\r\\n    function withdrawAllAndReassignBatch(\\r\\n        bool isCallPool,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata contractSizes\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256[] memory baseCosts,\\r\\n            uint256[] memory feeCosts,\\r\\n            uint256 amountOutCall,\\r\\n            uint256 amountOutPut\\r\\n        );\\r\\n\\r\\n    function withdrawFees()\\r\\n        external\\r\\n        returns (uint256 amountOutCall, uint256 amountOutPut);\\r\\n\\r\\n    function annihilate(uint256 tokenId, uint256 contractSize) external;\\r\\n\\r\\n    function claimRewards(bool isCallPool) external;\\r\\n\\r\\n    function claimRewards(address account, bool isCallPool) external;\\r\\n\\r\\n    function updateMiningPools() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPoolSettings {\\r\\n    function setPoolCaps(uint256 basePoolCap, uint256 underlyingPoolCap)\\r\\n        external;\\r\\n\\r\\n    function setMinimumAmounts(uint256 baseMinimum, uint256 underlyingMinimum)\\r\\n        external;\\r\\n\\r\\n    function setSteepness64x64(int128 steepness64x64) external;\\r\\n\\r\\n    function setCLevel64x64(int128 cLevel64x64, bool isCallPool) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {PoolStorage} from \\\"./PoolStorage.sol\\\";\\r\\n\\r\\ninterface IPoolView {\\r\\n    function getFeeReceiverAddress() external view returns (address);\\r\\n\\r\\n    function getPoolSettings()\\r\\n        external\\r\\n        view\\r\\n        returns (PoolStorage.PoolSettings memory);\\r\\n\\r\\n    function getTokenIds() external view returns (uint256[] memory);\\r\\n\\r\\n    function getCLevel64x64(bool isCall) external view returns (int128);\\r\\n\\r\\n    function getSteepness64x64() external view returns (int128);\\r\\n\\r\\n    function getPrice(uint256 timestamp) external view returns (int128);\\r\\n\\r\\n    function getParametersForTokenId(uint256 tokenId)\\r\\n        external\\r\\n        pure\\r\\n        returns (\\r\\n            PoolStorage.TokenType,\\r\\n            uint64,\\r\\n            int128\\r\\n        );\\r\\n\\r\\n    function getMinimumAmounts()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 minCallTokenAmount, uint256 minPutTokenAmount);\\r\\n\\r\\n    function getCapAmounts()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 callTokenCapAmount, uint256 putTokenCapAmount);\\r\\n\\r\\n    function getUserTVL(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 underlyingTVL, uint256 baseTVL);\\r\\n\\r\\n    function getTotalTVL()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 underlyingTVL, uint256 baseTVL);\\r\\n\\r\\n    function getPremiaMining() external view returns (address);\\r\\n\\r\\n    function getDivestmentTimestamps(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 callDivestmentTimestamp,\\r\\n            uint256 putDivestmentTimestamp\\r\\n        );\\r\\n\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolWrite.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPoolWrite {\\r\\n    function quote(\\r\\n        address feePayer,\\r\\n        uint64 maturity,\\r\\n        int128 strike64x64,\\r\\n        uint256 contractSize,\\r\\n        bool isCall\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            int128 baseCost64x64,\\r\\n            int128 feeCost64x64,\\r\\n            int128 cLevel64x64,\\r\\n            int128 slippageCoefficient64x64\\r\\n        );\\r\\n\\r\\n    function purchase(\\r\\n        uint64 maturity,\\r\\n        int128 strike64x64,\\r\\n        uint256 contractSize,\\r\\n        bool isCall,\\r\\n        uint256 maxCost\\r\\n    ) external payable returns (uint256 baseCost, uint256 feeCost);\\r\\n\\r\\n    function swapAndPurchase(\\r\\n        uint64 maturity,\\r\\n        int128 strike64x64,\\r\\n        uint256 contractSize,\\r\\n        bool isCall,\\r\\n        uint256 maxCost,\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        bool isSushi\\r\\n    ) external payable returns (uint256 baseCost, uint256 feeCost);\\r\\n\\r\\n    function writeFrom(\\r\\n        address underwriter,\\r\\n        address longReceiver,\\r\\n        uint64 maturity,\\r\\n        int128 strike64x64,\\r\\n        uint256 contractSize,\\r\\n        bool isCall\\r\\n    ) external payable returns (uint256 longTokenId, uint256 shortTokenId);\\r\\n\\r\\n    function update() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC1155Internal } from './IERC1155Internal.sol';\\nimport { IERC165 } from '../../introspection/IERC165.sol';\\n\\n/**\\n * @notice ERC1155 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/1155\\n */\\ninterface IERC1155 is IERC1155Internal, IERC165 {\\n    /**\\n     * @notice query the balance of given token held by given address\\n     * @param account address to query\\n     * @param id token to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account, uint256 id)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice query the balances of given tokens held by given addresses\\n     * @param accounts addresss to query\\n     * @param ids tokens to query\\n     * @return token balances\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @notice query approval status of given operator with respect to given address\\n     * @param account address to query for approval granted\\n     * @param operator address to query for approval received\\n     * @return whether operator is approved to spend tokens held by account\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\\n     * @param operator address whose approval status to update\\n     * @param status whether operator should be considered approved\\n     */\\n    function setApprovalForAll(address operator, bool status) external;\\n\\n    /**\\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param id token ID\\n     * @param amount quantity of tokens to transfer\\n     * @param data data payload\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param ids list of token IDs\\n     * @param amounts list of quantities of tokens to transfer\\n     * @param data data payload\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC1155 enumerable and aggregate function interface\\n */\\ninterface IERC1155Enumerable {\\n    /**\\n     * @notice query total minted supply of given token\\n     * @param id token id to query\\n     * @return token supply\\n     */\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @notice query total number of holders for given token\\n     * @param id token id to query\\n     * @return quantity of holders\\n     */\\n    function totalHolders(uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @notice query holders of given token\\n     * @param id token id to query\\n     * @return list of holder addresses\\n     */\\n    function accountsByToken(uint256 id)\\n        external\\n        view\\n        returns (address[] memory);\\n\\n    /**\\n     * @notice query tokens held by given address\\n     * @param account address to query\\n     * @return list of token ids\\n     */\\n    function tokensByAccount(address account)\\n        external\\n        view\\n        returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface for the Multicall utility contract\\n */\\ninterface IMulticall {\\n    /**\\n     * @notice batch function calls to the contract and return the results of each\\n     * @param data array of function call data payloads\\n     * @return results array of function call results\\n     */\\n    function multicall(bytes[] calldata data)\\n        external\\n        returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/IERC1155Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from '../../introspection/IERC165.sol';\\n\\n/**\\n * @notice Partial ERC1155 interface needed by internal functions\\n */\\ninterface IERC1155Internal {\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed account,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer()\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n  \\n  function latestTimestamp()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function latestRound()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function getAnswer(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n\\n  function getTimestamp(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  event AnswerUpdated(\\n    int256 indexed current,\\n    uint256 indexed roundId,\\n    uint256 updatedAt\\n  );\\n\\n  event NewRound(\\n    uint256 indexed roundId,\\n    address indexed startedBy,\\n    uint256 startedAt\\n  );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\n\\nlibrary ERC1155EnumerableStorage {\\n    struct Layout {\\n        mapping(uint256 => uint256) totalSupply;\\n        mapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\\n        mapping(address => EnumerableSet.UintSet) tokensByAccount;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC1155Enumerable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"abdk-libraries-solidity/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (x << 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    unchecked {\\n      return int64 (x >> 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (int256 (x << 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    unchecked {\\n      require (x >= 0);\\n      return uint64 (uint128 (x >> 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = x >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    unchecked {\\n      return int256 (x) << 64;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) + y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) - y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) * y >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    unchecked {\\n      if (x == MIN_64x64) {\\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n          y <= 0x1000000000000000000000000000000000000000000000000);\\n        return -y << 63;\\n      } else {\\n        bool negativeResult = false;\\n        if (x < 0) {\\n          x = -x;\\n          negativeResult = true;\\n        }\\n        if (y < 0) {\\n          y = -y; // We rely on overflow behavior here\\n          negativeResult = !negativeResult;\\n        }\\n        uint256 absoluteResult = mulu (x, uint256 (y));\\n        if (negativeResult) {\\n          require (absoluteResult <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000);\\n          return -int256 (absoluteResult); // We rely on overflow behavior here\\n        } else {\\n          require (absoluteResult <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n          return int256 (absoluteResult);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    unchecked {\\n      if (y == 0) return 0;\\n\\n      require (x >= 0);\\n\\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\\n\\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      hi <<= 64;\\n\\n      require (hi <=\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n      return hi + lo;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      int256 result = (int256 (x) << 64) / y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x; // We rely on overflow behavior here\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <= 0x80000000000000000000000000000000);\\n        return -int128 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (absoluteResult); // We rely on overflow behavior here\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      uint128 result = divuu (x, y);\\n      require (result <= uint128 (MAX_64x64));\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return -x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return x < 0 ? -x : x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != 0);\\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      return int128 ((int256 (x) + int256 (y)) >> 1);\\n    }\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 m = int256 (x) * int256 (y);\\n      require (m >= 0);\\n      require (m <\\n          0x4000000000000000000000000000000000000000000000000000000000000000);\\n      return int128 (sqrtu (uint256 (m)));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      bool negative = x < 0 && y & 1 == 1;\\n\\n      uint256 absX = uint128 (x < 0 ? -x : x);\\n      uint256 absResult;\\n      absResult = 0x100000000000000000000000000000000;\\n\\n      if (absX <= 0x10000000000000000) {\\n        absX <<= 63;\\n        while (y != 0) {\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x2 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x4 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x8 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          y >>= 4;\\n        }\\n\\n        absResult >>= 64;\\n      } else {\\n        uint256 absXShift = 63;\\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n        uint256 resultShift = 0;\\n        while (y != 0) {\\n          require (absXShift < 64);\\n\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n            resultShift += absXShift;\\n            if (absResult > 0x100000000000000000000000000000000) {\\n              absResult >>= 1;\\n              resultShift += 1;\\n            }\\n          }\\n          absX = absX * absX >> 127;\\n          absXShift <<= 1;\\n          if (absX >= 0x100000000000000000000000000000000) {\\n              absX >>= 1;\\n              absXShift += 1;\\n          }\\n\\n          y >>= 1;\\n        }\\n\\n        require (resultShift < 64);\\n        absResult >>= 64 - resultShift;\\n      }\\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= 0);\\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      int256 msb = 0;\\n      int256 xc = x;\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 result = msb - 64 << 64;\\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n        ux *= ux;\\n        uint256 b = ux >> 255;\\n        ux >>= 127 + b;\\n        result += bit * int256 (b);\\n      }\\n\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      return int128 (int256 (\\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n\\n      if (x & 0x8000000000000000 > 0)\\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n      if (x & 0x4000000000000000 > 0)\\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n      if (x & 0x2000000000000000 > 0)\\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n      if (x & 0x1000000000000000 > 0)\\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n      if (x & 0x800000000000000 > 0)\\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n      if (x & 0x400000000000000 > 0)\\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n      if (x & 0x200000000000000 > 0)\\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n      if (x & 0x100000000000000 > 0)\\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n      if (x & 0x80000000000000 > 0)\\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n      if (x & 0x40000000000000 > 0)\\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n      if (x & 0x20000000000000 > 0)\\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n      if (x & 0x10000000000000 > 0)\\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n      if (x & 0x8000000000000 > 0)\\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n      if (x & 0x4000000000000 > 0)\\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n      if (x & 0x2000000000000 > 0)\\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n      if (x & 0x1000000000000 > 0)\\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n      if (x & 0x800000000000 > 0)\\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n      if (x & 0x400000000000 > 0)\\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n      if (x & 0x200000000000 > 0)\\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n      if (x & 0x100000000000 > 0)\\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n      if (x & 0x80000000000 > 0)\\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n      if (x & 0x40000000000 > 0)\\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n      if (x & 0x20000000000 > 0)\\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n      if (x & 0x10000000000 > 0)\\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n      if (x & 0x8000000000 > 0)\\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n      if (x & 0x4000000000 > 0)\\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n      if (x & 0x2000000000 > 0)\\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n      if (x & 0x1000000000 > 0)\\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n      if (x & 0x800000000 > 0)\\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n      if (x & 0x400000000 > 0)\\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n      if (x & 0x200000000 > 0)\\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n      if (x & 0x100000000 > 0)\\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n      if (x & 0x80000000 > 0)\\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n      if (x & 0x40000000 > 0)\\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n      if (x & 0x20000000 > 0)\\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n      if (x & 0x10000000 > 0)\\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n      if (x & 0x8000000 > 0)\\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n      if (x & 0x4000000 > 0)\\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n      if (x & 0x2000000 > 0)\\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n      if (x & 0x1000000 > 0)\\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n      if (x & 0x800000 > 0)\\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n      if (x & 0x400000 > 0)\\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n      if (x & 0x200000 > 0)\\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n      if (x & 0x100000 > 0)\\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n      if (x & 0x80000 > 0)\\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n      if (x & 0x40000 > 0)\\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n      if (x & 0x20000 > 0)\\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n      if (x & 0x10000 > 0)\\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n      if (x & 0x8000 > 0)\\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n      if (x & 0x4000 > 0)\\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n      if (x & 0x2000 > 0)\\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n      if (x & 0x1000 > 0)\\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n      if (x & 0x800 > 0)\\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n      if (x & 0x400 > 0)\\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n      if (x & 0x200 > 0)\\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n      if (x & 0x100 > 0)\\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n      if (x & 0x80 > 0)\\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n      if (x & 0x40 > 0)\\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n      if (x & 0x20 > 0)\\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n      if (x & 0x10 > 0)\\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n      if (x & 0x8 > 0)\\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n      if (x & 0x4 > 0)\\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n      if (x & 0x2 > 0)\\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n      if (x & 0x1 > 0)\\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n      result >>= uint256 (int256 (63 - (x >> 64)));\\n      require (result <= uint256 (int256 (MAX_64x64)));\\n\\n      return int128 (int256 (result));\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      return exp_2 (\\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      uint256 result;\\n\\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        result = (x << 64) / y;\\n      else {\\n        uint256 msb = 192;\\n        uint256 xc = x >> 192;\\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 hi = result * (y >> 128);\\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 xh = x >> 192;\\n        uint256 xl = x << 64;\\n\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n        lo = hi << 128;\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n\\n        assert (xh == hi >> 128);\\n\\n        result += xl / y;\\n      }\\n\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return uint128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    unchecked {\\n      if (x == 0) return 0;\\n      else {\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n        if (xx >= 0x8) { r <<= 1; }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return uint128 (r < r1 ? r : r1);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ABDKMath64x64Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {ABDKMath64x64} from \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\n\\nlibrary ABDKMath64x64Token {\\n    using ABDKMath64x64 for int128;\\n\\n    /**\\n     * @notice convert 64x64 fixed point representation of token amount to decimal\\n     * @param value64x64 64x64 fixed point representation of token amount\\n     * @param decimals token display decimals\\n     * @return value decimal representation of token amount\\n     */\\n    function toDecimals(int128 value64x64, uint8 decimals)\\n        internal\\n        pure\\n        returns (uint256 value)\\n    {\\n        value = value64x64.mulu(10**decimals);\\n    }\\n\\n    /**\\n     * @notice convert decimal representation of token amount to 64x64 fixed point\\n     * @param value decimal representation of token amount\\n     * @param decimals token display decimals\\n     * @return value64x64 64x64 fixed point representation of token amount\\n     */\\n    function fromDecimals(uint256 value, uint8 decimals)\\n        internal\\n        pure\\n        returns (int128 value64x64)\\n    {\\n        value64x64 = ABDKMath64x64.divu(value, 10**decimals);\\n    }\\n\\n    /**\\n     * @notice convert 64x64 fixed point representation of token amount to wei (18 decimals)\\n     * @param value64x64 64x64 fixed point representation of token amount\\n     * @return value wei representation of token amount\\n     */\\n    function toWei(int128 value64x64) internal pure returns (uint256 value) {\\n        value = toDecimals(value64x64, 18);\\n    }\\n\\n    /**\\n     * @notice convert wei representation (18 decimals) of token amount to 64x64 fixed point\\n     * @param value wei representation of token amount\\n     * @return value64x64 64x64 fixed point representation of token amount\\n     */\\n    function fromWei(uint256 value) internal pure returns (int128 value64x64) {\\n        value64x64 = fromDecimals(value, 18);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OptionMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {ABDKMath64x64} from \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\n\\nlibrary OptionMath {\\n    using ABDKMath64x64 for int128;\\n\\n    struct QuoteArgs {\\n        int128 varianceAnnualized64x64; // 64x64 fixed point representation of annualized variance\\n        int128 strike64x64; // 64x64 fixed point representation of strike price\\n        int128 spot64x64; // 64x64 fixed point representation of spot price\\n        int128 timeToMaturity64x64; // 64x64 fixed point representation of duration of option contract (in years)\\n        int128 oldCLevel64x64; // 64x64 fixed point representation of C-Level of Pool before purchase\\n        int128 oldPoolState; // 64x64 fixed point representation of current state of the pool\\n        int128 newPoolState; // 64x64 fixed point representation of state of the pool after trade\\n        int128 steepness64x64; // 64x64 fixed point representation of Pool state delta multiplier\\n        int128 minAPY64x64; // 64x64 fixed point representation of minimum APY for capital locked up to underwrite options\\n        bool isCall; // whether to price \\\"call\\\" or \\\"put\\\" option\\n    }\\n\\n    struct CalculateCLevelDecayArgs {\\n        int128 timeIntervalsElapsed64x64; // 64x64 fixed point representation of quantity of discrete arbitrary intervals elapsed since last update\\n        int128 oldCLevel64x64; // 64x64 fixed point representation of C-Level prior to accounting for decay\\n        int128 utilization64x64; // 64x64 fixed point representation of pool capital utilization rate\\n        int128 utilizationLowerBound64x64;\\n        int128 utilizationUpperBound64x64;\\n        int128 cLevelLowerBound64x64;\\n        int128 cLevelUpperBound64x64;\\n        int128 cConvergenceULowerBound64x64;\\n        int128 cConvergenceUUpperBound64x64;\\n    }\\n\\n    // 64x64 fixed point integer constants\\n    int128 internal constant ONE_64x64 = 0x10000000000000000;\\n    int128 internal constant THREE_64x64 = 0x30000000000000000;\\n\\n    // 64x64 fixed point constants used in Choudhury’s approximation of the Black-Scholes CDF\\n    int128 private constant CDF_CONST_0 = 0x09109f285df452394; // 2260 / 3989\\n    int128 private constant CDF_CONST_1 = 0x19abac0ea1da65036; // 6400 / 3989\\n    int128 private constant CDF_CONST_2 = 0x0d3c84b78b749bd6b; // 3300 / 3989\\n\\n    /**\\n     * @notice recalculate C-Level based on change in liquidity\\n     * @param initialCLevel64x64 64x64 fixed point representation of C-Level of Pool before update\\n     * @param oldPoolState64x64 64x64 fixed point representation of liquidity in pool before update\\n     * @param newPoolState64x64 64x64 fixed point representation of liquidity in pool after update\\n     * @param steepness64x64 64x64 fixed point representation of steepness coefficient\\n     * @return 64x64 fixed point representation of new C-Level\\n     */\\n    function calculateCLevel(\\n        int128 initialCLevel64x64,\\n        int128 oldPoolState64x64,\\n        int128 newPoolState64x64,\\n        int128 steepness64x64\\n    ) external pure returns (int128) {\\n        return\\n            newPoolState64x64\\n                .sub(oldPoolState64x64)\\n                .div(\\n                    oldPoolState64x64 > newPoolState64x64\\n                        ? oldPoolState64x64\\n                        : newPoolState64x64\\n                )\\n                .mul(steepness64x64)\\n                .neg()\\n                .exp()\\n                .mul(initialCLevel64x64);\\n    }\\n\\n    /**\\n     * @notice calculate the price of an option using the Premia Finance model\\n     * @param args arguments of quotePrice\\n     * @return premiaPrice64x64 64x64 fixed point representation of Premia option price\\n     * @return cLevel64x64 64x64 fixed point representation of C-Level of Pool after purchase\\n     */\\n    function quotePrice(QuoteArgs memory args)\\n        external\\n        pure\\n        returns (\\n            int128 premiaPrice64x64,\\n            int128 cLevel64x64,\\n            int128 slippageCoefficient64x64\\n        )\\n    {\\n        int128 deltaPoolState64x64 = args\\n            .newPoolState\\n            .sub(args.oldPoolState)\\n            .div(args.oldPoolState)\\n            .mul(args.steepness64x64);\\n        int128 tradingDelta64x64 = deltaPoolState64x64.neg().exp();\\n\\n        int128 blackScholesPrice64x64 = _blackScholesPrice(\\n            args.varianceAnnualized64x64,\\n            args.strike64x64,\\n            args.spot64x64,\\n            args.timeToMaturity64x64,\\n            args.isCall\\n        );\\n\\n        cLevel64x64 = tradingDelta64x64.mul(args.oldCLevel64x64);\\n        slippageCoefficient64x64 = ONE_64x64.sub(tradingDelta64x64).div(\\n            deltaPoolState64x64\\n        );\\n\\n        premiaPrice64x64 = blackScholesPrice64x64.mul(cLevel64x64).mul(\\n            slippageCoefficient64x64\\n        );\\n\\n        int128 intrinsicValue64x64;\\n\\n        if (args.isCall && args.strike64x64 < args.spot64x64) {\\n            intrinsicValue64x64 = args.spot64x64.sub(args.strike64x64);\\n        } else if (!args.isCall && args.strike64x64 > args.spot64x64) {\\n            intrinsicValue64x64 = args.strike64x64.sub(args.spot64x64);\\n        }\\n\\n        int128 collateralValue64x64 = args.isCall\\n            ? args.spot64x64\\n            : args.strike64x64;\\n\\n        int128 minPrice64x64 = intrinsicValue64x64.add(\\n            collateralValue64x64.mul(args.minAPY64x64).mul(\\n                args.timeToMaturity64x64\\n            )\\n        );\\n\\n        if (minPrice64x64 > premiaPrice64x64) {\\n            premiaPrice64x64 = minPrice64x64;\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate the decay of C-Level based on heat diffusion function\\n     * @param args structured CalculateCLevelDecayArgs\\n     * @return cLevelDecayed64x64 C-Level after accounting for decay\\n     */\\n    function calculateCLevelDecay(CalculateCLevelDecayArgs memory args)\\n        external\\n        pure\\n        returns (int128 cLevelDecayed64x64)\\n    {\\n        int128 convFHighU64x64 = (args.utilization64x64 >=\\n            args.utilizationUpperBound64x64 &&\\n            args.oldCLevel64x64 <= args.cLevelLowerBound64x64)\\n            ? ONE_64x64\\n            : int128(0);\\n\\n        int128 convFLowU64x64 = (args.utilization64x64 <=\\n            args.utilizationLowerBound64x64 &&\\n            args.oldCLevel64x64 >= args.cLevelUpperBound64x64)\\n            ? ONE_64x64\\n            : int128(0);\\n\\n        cLevelDecayed64x64 = args\\n            .oldCLevel64x64\\n            .sub(args.cConvergenceULowerBound64x64.mul(convFLowU64x64))\\n            .sub(args.cConvergenceUUpperBound64x64.mul(convFHighU64x64))\\n            .mul(\\n                convFLowU64x64\\n                    .mul(ONE_64x64.sub(args.utilization64x64))\\n                    .add(convFHighU64x64.mul(args.utilization64x64))\\n                    .mul(args.timeIntervalsElapsed64x64)\\n                    .neg()\\n                    .exp()\\n            )\\n            .add(\\n                args.cConvergenceULowerBound64x64.mul(convFLowU64x64).add(\\n                    args.cConvergenceUUpperBound64x64.mul(convFHighU64x64)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice calculate the exponential decay coefficient for a given interval\\n     * @param oldTimestamp timestamp of previous update\\n     * @param newTimestamp current timestamp\\n     * @return 64x64 fixed point representation of exponential decay coefficient\\n     */\\n    function _decay(uint256 oldTimestamp, uint256 newTimestamp)\\n        internal\\n        pure\\n        returns (int128)\\n    {\\n        return\\n            ONE_64x64.sub(\\n                (-ABDKMath64x64.divu(newTimestamp - oldTimestamp, 7 days)).exp()\\n            );\\n    }\\n\\n    /**\\n     * @notice calculate Choudhury’s approximation of the Black-Scholes CDF\\n     * @param input64x64 64x64 fixed point representation of random variable\\n     * @return 64x64 fixed point representation of the approximated CDF of x\\n     */\\n    function _N(int128 input64x64) internal pure returns (int128) {\\n        // squaring via mul is cheaper than via pow\\n        int128 inputSquared64x64 = input64x64.mul(input64x64);\\n\\n        int128 value64x64 = (-inputSquared64x64 >> 1).exp().div(\\n            CDF_CONST_0.add(CDF_CONST_1.mul(input64x64.abs())).add(\\n                CDF_CONST_2.mul(inputSquared64x64.add(THREE_64x64).sqrt())\\n            )\\n        );\\n\\n        return input64x64 > 0 ? ONE_64x64.sub(value64x64) : value64x64;\\n    }\\n\\n    /**\\n     * @notice calculate the price of an option using the Black-Scholes model\\n     * @param varianceAnnualized64x64 64x64 fixed point representation of annualized variance\\n     * @param strike64x64 64x64 fixed point representation of strike price\\n     * @param spot64x64 64x64 fixed point representation of spot price\\n     * @param timeToMaturity64x64 64x64 fixed point representation of duration of option contract (in years)\\n     * @param isCall whether to price \\\"call\\\" or \\\"put\\\" option\\n     * @return 64x64 fixed point representation of Black-Scholes option price\\n     */\\n    function _blackScholesPrice(\\n        int128 varianceAnnualized64x64,\\n        int128 strike64x64,\\n        int128 spot64x64,\\n        int128 timeToMaturity64x64,\\n        bool isCall\\n    ) internal pure returns (int128) {\\n        int128 cumulativeVariance64x64 = timeToMaturity64x64.mul(\\n            varianceAnnualized64x64\\n        );\\n        int128 cumulativeVarianceSqrt64x64 = cumulativeVariance64x64.sqrt();\\n\\n        int128 d1_64x64 = spot64x64\\n            .div(strike64x64)\\n            .ln()\\n            .add(cumulativeVariance64x64 >> 1)\\n            .div(cumulativeVarianceSqrt64x64);\\n        int128 d2_64x64 = d1_64x64.sub(cumulativeVarianceSqrt64x64);\\n\\n        if (isCall) {\\n            return\\n                spot64x64.mul(_N(d1_64x64)).sub(strike64x64.mul(_N(d2_64x64)));\\n        } else {\\n            return\\n                -spot64x64.mul(_N(-d1_64x64)).sub(\\n                    strike64x64.mul(_N(-d2_64x64))\\n                );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        require(\\n            set._values.length > index,\\n            'EnumerableSet: index out of bounds'\\n        );\\n        return set._values[index];\\n    }\\n\\n    function _contains(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 index = valueIndex - 1;\\n            bytes32 last = set._values[set._values.length - 1];\\n\\n            // move last value to now-vacant index\\n\\n            set._values[index] = last;\\n            set._indexes[last] = index + 1;\\n\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NFTSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary NFTSVG {\\n    using Strings for uint256;\\n\\n    string constant ETH_COLOR_A = \\\"#FFFFFF\\\";\\n    string constant WBTC_COLOR_A = \\\"#E2753B\\\";\\n    string constant LINK_COLOR_A = \\\"#376AFF\\\";\\n    string constant DAI_COLOR_A = \\\"#D1A663\\\";\\n    string constant UNKNOWN_COLOR_A = \\\"#52FFB2\\\";\\n\\n    string constant ETH_COLOR_B = \\\"#FFFFFF\\\";\\n    string constant WBTC_COLOR_B = \\\"#E2923B\\\";\\n    string constant LINK_COLOR_B = \\\"#438BFF\\\";\\n    string constant DAI_COLOR_B = \\\"#D8A75B\\\";\\n    string constant UNKNOWN_COLOR_B = \\\"#52B4FF\\\";\\n\\n    string constant ETH_UNDERLYING_LOGO =\\n        '<path d=\\\"m68.86 132.9-7.7-13.4-7.73 13.4 7.72-3.66 7.71 3.65Zm-7.7 7.17-8.66-4.11 8.65 15.12 8.66-15.12-8.66 4.11Zm0-2.09-7.06-3.34 7.05-3.34 7.06 3.34-7.06 3.34Z\\\" fill=\\\"#BBBBBB\\\"/>';\\n    string constant WBTC_UNDERLYING_LOGO =\\n        '<path d=\\\"M52.79 153.08a16.29 16.29 0 1 1 0-32.58 16.29 16.29 0 0 1 0 32.58Zm0-31.31a15.01 15.01 0 1 0 .02 30.02 15.01 15.01 0 0 0-.02-30.02Zm8.55 5.65a12.66 12.66 0 0 0-17.09 0l-.91-.9a13.94 13.94 0 0 1 18.9 0l-.9.9Zm.83.81.9-.9v-.01a13.94 13.94 0 0 1 0 18.9l-.9-.9a12.66 12.66 0 0 0 0-17.09Zm-18.75 17.1a12.66 12.66 0 0 1 0-17.08l-.9-.9a13.94 13.94 0 0 0 0 18.9l.9-.92Zm.82.83a12.67 12.67 0 0 0 17.1 0l.9.9a13.94 13.94 0 0 1-18.9 0l.9-.9Zm14.2-12.35c-.18-1.87-1.8-2.5-3.83-2.69v-2.57h-1.57v2.52h-1.26v-2.52h-1.56v2.59h-3.2v1.68s1.17-.02 1.15 0c.43-.04.83.26.9.7v7.08c-.02.15-.09.29-.2.39a.55.55 0 0 1-.4.13c.02.02-1.15 0-1.15 0l-.3 1.88h3.17v2.63h1.57v-2.59h1.26v2.58h1.58v-2.6c2.66-.16 4.51-.81 4.74-3.3.2-2-.75-2.9-2.26-3.26.92-.45 1.49-1.29 1.36-2.66Zm-2.2 5.6c0 1.8-2.83 1.75-4.12 1.73h-.3v-3.47h.39c1.32-.04 4.02-.1 4.02 1.74Zm-4.16-3.32c1.08.02 3.42.06 3.42-1.58 0-1.67-2.26-1.61-3.37-1.58h-.32v3.16h.27Z\\\" fill=\\\"#E2923B\\\"/>';\\n    string constant LINK_UNDERLYING_LOGO =\\n        '<path d=\\\"m62.4 122 2.7-1.6L68 122l7.5 4.4 2.8 1.6v15l-2.8 1.6L68 149l-2.8 1.6-2.8-1.6-7.6-4.4-2.7-1.6v-15l2.7-1.6 7.6-4.4Zm-4.8 9.1v8.8l7.5 4.3 7.6-4.3V131l-7.6-4.3-7.5 4.3Z\\\" fill=\\\"#3159CC\\\"/>';\\n    string constant UNKNOWN_UNDERLYING_LOGO =\\n        '<path d=\\\"M46.8 119.5a16.3 16.3 0 1 1 0 32.6 16.3 16.3 0 0 1 0-32.6Zm0 20.6c-.5 0-.9.2-1.2.5a1.5 1.5 0 0 0 0 2.2 1.8 1.8 0 0 0 1.2.5c.4 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.1 0-.4-.2-.8-.5-1.1-.3-.3-.7-.5-1.1-.5Zm.2-11.8c-.6 0-1.2 0-1.8.3-.5.2-1 .4-1.4.8-.4.3-.8.8-1 1.3a5 5 0 0 0-.5 1.5v.2l2.4.3.2-.8a2 2 0 0 1 2-1.4c.5 0 1 .2 1.4.6.3.3.5.8.5 1.3 0 .4-.1.8-.3 1l-.5.7-.2.1-1 1-.6.6a3.2 3.2 0 0 0-.6 1.4v1.7H48v-1.3l.2-.6.4-.5.7-.6a16.5 16.5 0 0 0 1.5-1.6l.4-1 .2-1a4 4 0 0 0-.4-1.8c-.2-.4-.5-.9-1-1.2l-1.3-.8-1.7-.2Z\\\" fill=\\\"#383838\\\"/>';\\n\\n    string constant DAI_BASE_LOGO =\\n        '<path d=\\\"M254 135.7a16.3 16.3 0 1 0-32.6 0 16.3 16.3 0 0 0 32.6 0Zm-24 9V139l-.2-.1h-2.2c-.1 0-.2 0-.2-.2v-2h2.4l.2-.1v-2H227.6c-.1 0-.2 0-.2-.2v-1.8c0-.1 0-.2.2-.2h2.2c.1 0 .2 0 .2-.2V127c0-.2 0-.2.2-.2h7.6l1.6.1a10 10 0 0 1 5 2.6l1.1 1.4.8 1.5c0 .2.2.2.3.2h1.8c.3 0 .3 0 .3.3v1.6c0 .2 0 .2-.3.2H247l-.1.2v1.9c0 .1 0 .2.2.2h1.6v1.8c0 .2 0 .3-.2.3h-2l-.3.1a8.1 8.1 0 0 1-3.2 4l-.2.2-1 .5a11 11 0 0 1-4.8 1h-7Zm14-12.2v-.1a4 4 0 0 0-.4-.7l-.7-1-.5-.4a7.3 7.3 0 0 0-4.8-1.7h-5.4c-.2 0-.2 0-.2.2v3.6c0 .1 0 .2.2.2H244Zm-5.7 4.4h6.2c.1 0 .2 0 .2-.2v-2h-12.5l-.2.1v2h6.3Zm5.2 2h.5v.3a6.6 6.6 0 0 1-2.8 2.8 7.7 7.7 0 0 1-3 .8l-.8.1h-5.2c-.2 0-.2 0-.2-.2v-3.5c0-.2 0-.2.2-.2h11.3Z\\\" fill=\\\"#E3A94D\\\"/>';\\n    string constant UNKNOWN_BASE_LOGO =\\n        '<path d=\\\"M253.79 119.5a16.29 16.29 0 1 1 0 32.58 16.29 16.29 0 0 1 0-32.58Zm-.02 20.63c-.45 0-.84.16-1.16.48a1.52 1.52 0 0 0 .01 2.23 1.78 1.78 0 0 0 1.15.45c.45 0 .84-.16 1.16-.47.32-.31.48-.7.48-1.13 0-.44-.16-.8-.5-1.1-.32-.3-.7-.46-1.14-.46Zm.22-11.84c-.62 0-1.21.1-1.76.28a4.2 4.2 0 0 0-2.49 2.11 5 5 0 0 0-.48 1.47l-.04.28 2.52.22c.01-.27.07-.53.16-.8a2.02 2.02 0 0 1 1.93-1.33c.62 0 1.09.19 1.43.55.33.36.5.8.5 1.34 0 .4-.1.76-.28 1.04-.14.22-.3.42-.48.6l-.19.18-.92.88c-.26.25-.47.48-.64.7a3.18 3.18 0 0 0-.64 1.41c-.03.2-.06.41-.07.65v1.01h2.42v-.53c0-.3.02-.55.06-.76.04-.2.11-.4.21-.57.1-.18.24-.36.41-.53.18-.18.4-.39.67-.62.31-.27.6-.53.85-.79.25-.25.47-.51.65-.79.17-.27.31-.57.4-.9.1-.32.15-.7.15-1.14 0-.65-.12-1.21-.35-1.7-.23-.5-.55-.91-.95-1.25-.4-.33-.87-.58-1.4-.75a5.4 5.4 0 0 0-1.66-.26Z\\\" fill=\\\"#383838\\\"/>';\\n\\n    string constant DAI_BASE_LOGO_SMALL =\\n        '<path d=\\\"M125 260a7 7 0 1 0-14 0 7 7 0 0 0 14 0Zm-10.3 3.9v-2.4l-.1-.1h-1v-.9h1v-.9h-1v-.9h1v-2.5H118.8a4.3 4.3 0 0 1 2.2 1l.5.7.3.6.1.1h.9V259.5h-.7v1h.7v.8h-.9l-.1.2a3.5 3.5 0 0 1-1.4 1.7h-.1l-.4.3a4.7 4.7 0 0 1-2.1.4h-3Zm6-5.3c0-.1 0-.2-.2-.3 0-.2-.2-.3-.3-.4l-.2-.2a3.1 3.1 0 0 0-2-.8h-2.4V258.6h5.1Zm-2.4 1.9h2.7v-.9h-5.4v.9h2.7Zm2.2.9h.2c-.3.6-.7 1-1.2 1.3l-.4.2-1 .2h-2.5V261.3h4.9Z\\\" fill=\\\"#646464\\\"/>';\\n    string constant UNKNOWN_BASE_LOGO_SMALL =\\n        '<path d=\\\"M118 253a7 7 0 1 1 0 14 7 7 0 0 1 0-14Zm0 8.87c-.2 0-.37.06-.5.2a.65.65 0 0 0 0 .96.76.76 0 0 0 .5.2c.18 0 .35-.07.49-.21.14-.13.2-.3.2-.48a.62.62 0 0 0-.2-.48.7.7 0 0 0-.5-.2Zm.09-5.1c-.27 0-.52.05-.76.13a1.8 1.8 0 0 0-1.07.9c-.1.2-.17.4-.2.64l-.02.12 1.08.1c0-.12.03-.24.07-.35a.87.87 0 0 1 .83-.57c.26 0 .47.07.61.23s.22.35.22.58c0 .17-.04.32-.12.45l-.2.25-.09.08-.4.38c-.1.1-.2.2-.27.3a1.37 1.37 0 0 0-.28.6l-.03.28V261.33h1.04v-.23c0-.13.01-.24.03-.32a.8.8 0 0 1 .1-.25c.03-.08.1-.15.17-.23a7.09 7.09 0 0 0 .65-.6l.28-.34c.07-.12.13-.25.17-.39.04-.14.06-.3.06-.5 0-.27-.05-.51-.15-.72-.1-.22-.23-.4-.4-.54a1.8 1.8 0 0 0-.6-.32 2.32 2.32 0 0 0-.72-.11Z\\\" fill=\\\"#646464\\\"/>';\\n\\n    struct CreateSVGParams {\\n        string baseSymbol;\\n        string underlyingSymbol;\\n        bool isCall;\\n        bool isLong;\\n        string maturityString;\\n        string strikePriceString;\\n    }\\n\\n    function buildSVG(CreateSVGParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory tokens = buildTokens(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol\\n        );\\n        string memory svgText = buildText(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol,\\n            _params.strikePriceString,\\n            _params.maturityString\\n        );\\n        string memory svgDefs = buildDefs(\\n            _params.underlyingSymbol,\\n            _params.baseSymbol,\\n            _params.isLong\\n        );\\n        string memory shortLongTag = buildShortLongTag(_params.isLong);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<svg width=\\\"300\\\" height=\\\"378\\\" viewBox=\\\"0 0 300 378\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">',\\n                    svgDefs,\\n                    '<g transform=\\\"translate(.5 .5)\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\">',\\n                    tokens,\\n                    _params.isCall ? buildCallRectangle() : buildPutRectangle(),\\n                    shortLongTag,\\n                    svgText,\\n                    \\\"</g>\\\",\\n                    \\\"</svg>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildTokens(\\n        string memory baseSymbol,\\n        string memory underlyingSymbol\\n    ) internal pure returns (string memory) {\\n        string memory baseLogoSmall = getBaseLogoSmall(baseSymbol);\\n        string memory baseLogo = getBaseLogo(baseSymbol);\\n        string memory underlyingLogo = getUnderlyingLogo(underlyingSymbol);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<path d=\\\"M103 0a25 25 0 0 1 17.7 7.3l24 24.1c8.1 8 19 12.6 30.5 12.6h95.2A30 30 0 0 1 300 69.4V348a30 30 0 0 1-30 30H30a30 30 0 0 1-30-30V30A30 30 0 0 1 30 0h73Z\\\" fill=\\\"#000\\\" fill-rule=\\\"nonzero\\\"/>',\\n                    '<path d=\\\"M19.9 150 1.1 163H16l16.8-13h.5l-16.7 13h14.9l14.7-13h.5l-14.6 13H47l12.6-13h.5l-12.5 13h14.9L73 150h.5l-10.4 13H78l8.4-13h.5l-8.3 13h14.9l6.3-13h.5l-6.2 13H109l4.2-13h.5l-4.1 13h14.9l2.1-13h.5l-2 13H140v-13h.5v13h15l-2-13h.4l2.2 13H171l-4.2-13h.5l4.3 13h14.9l-6.3-13h.5l6.4 13H202l-8.4-13h.5l8.5 13h14.9L207 150h.5l10.5 13h15l-12.6-13h.5l12.6 13h15l-14.7-13h.5l14.7 13h15l-16.8-13h.5l16.8 13h15l-18.9-13h.5l19 13h14.8L274 150h.5l21 13h4.5v.3h-4l4 2.4v.3l-4.5-2.8h-15l14 9.7h5.5v.3h-5l5 3.4v.4l-5.6-3.8h-16.5l12.5 9.6h9.6v.3h-9.2l9.2 7v.7l-9.9-7.7h-18l10.9 9.6h17v.4h-16.6l11.3 9.9h-.9l-11.2-10H263l9.7 10h-.9l-9.6-10h-19.6l8 10h-.8l-8-10h-19.6l6.5 10h-.9l-6.4-10h-19.6l4.9 10h-.9l-4.8-10h-19.6l3.3 10h-.9l-3.2-10H161l1.7 10h-.9l-1.5-10h-19.6v10h-.9v-10h-19.5l-1.6 10h-.9l1.7-10H99.9l-3.2 10h-.9l3.3-10H79.5l-4.8 10h-.9l5-10H59l-6.4 10h-.9l6.5-10H38.7l-8 10h-.9l8.1-10H18.3l-9.6 10h-.8l9.7-10H0v-.3h17.9l9.4-9.6H9.2L0 191.3v-.7l8.5-7.5H0v-.3h8.9l10.9-9.6H3.3L0 175.7v-.5l2.6-2H0v-.3h3l12.6-9.7H.6l-.6.5v-.8h.5L19.4 150h.5Zm138.8 33.1h-18v9.6h19.5l-1.5-9.6Zm-18.8 0h-18l-1.6 9.6H140v-9.6Zm-93.9 0H28l-9.3 9.6h19.5l7.8-9.6Zm18.8 0h-18l-7.8 9.6h19.5l6.3-9.6Zm18.8 0h-18l-6.3 9.6H79l4.7-9.6Zm18.8 0H84.3l-4.6 9.6h19.5l3.2-9.6Zm18.7 0h-18l-3.1 9.6h19.5l1.6-9.6Zm56.3 0h-18l1.6 9.6h19.5l-3-9.6Zm18.8 0h-18l3.1 9.6H201l-4.7-9.6Zm18.8 0h-18l4.7 9.6h19.5l-6.2-9.6Zm18.8 0h-18l6.2 9.6h19.5l-7.7-9.6Zm18.7 0h-18l7.8 9.6H262l-9.4-9.6Zm18.8 0h-18l9.3 9.6h19.6l-10.9-9.6Zm6-10h-16.6l11 9.7h18l-12.5-9.6Zm-17.2 0h-16.5l9.3 9.7h18l-10.8-9.6Zm-17.2 0h-16.5l7.8 9.7h18l-9.3-9.6Zm-17.2 0h-16.5l6.3 9.7h18l-7.8-9.6Zm-17.1 0H192l4.7 9.7h18l-6.2-9.6Zm-17.2 0H175l3.2 9.7h18l-4.7-9.6Zm-17.1 0h-16.5l1.5 9.7h18l-3-9.6Zm-17.2 0h-16.5v9.7h18l-1.5-9.6Zm-17.2 0h-16.5l-1.5 9.7h18v-9.6Zm-17.1 0h-16.5l-3.1 9.7h18l1.6-9.6Zm-17.2 0H89.1l-4.6 9.7h18l3.1-9.6Zm-17.2 0H72l-6.2 9.7h18l4.7-9.6Zm-17.1 0H54.8l-7.8 9.7h18l6.3-9.6Zm-17.2 0H37.6l-9.3 9.7h18l7.8-9.6Zm-17.1 0H20.5l-11 9.7h18l9.5-9.6Zm243-9.8h-15l12.5 9.6h16.4l-14-9.7Zm-15.6 0h-15l11 9.6h16.4l-12.4-9.7Zm-15.6 0h-15l9.4 9.6h16.5l-10.9-9.7Zm-15.5 0h-15l7.8 9.6h16.5l-9.3-9.7Zm-15.6 0h-15l6.3 9.6h16.5l-7.8-9.7Zm-15.5 0h-15l4.7 9.6h16.5l-6.2-9.7Zm-15.6 0h-15l3.2 9.6h16.5l-4.7-9.7Zm-15.5 0h-15l1.6 9.6h16.5l-3.1-9.7Zm-15.6 0h-15v9.6H157l-1.5-9.7Zm-15.5 0h-15l-1.5 9.6h16.4v-9.7Zm-15.6 0h-15l-3 9.6h16.4l1.6-9.7Zm-15.5 0h-15l-4.6 9.6h16.4l3.2-9.7Zm-15.6 0h-15l-6.1 9.6h16.4l4.7-9.7Zm-15.5 0h-15l-7.8 9.6h16.5l6.3-9.7Zm-15.6 0h-15l-9.3 9.6h16.5l7.8-9.7Zm-15.5 0h-15l-10.9 9.6h16.5l9.4-9.7Zm-15.6 0h-15l-12.4 9.6h16.5l10.9-9.7ZM287.9 150l12.1 6.7v.4l-12.6-7.1h.5ZM6.5 150 0 154v-.3l6-3.7h.5Z\\\" fill=\\\"url(#a)\\\" opacity=\\\".3\\\"/>',\\n                    '<rect stroke=\\\"#2C2C2C\\\" fill=\\\"#000\\\" fill-rule=\\\"nonzero\\\" x=\\\"18\\\" y=\\\"208.5\\\" width=\\\"264\\\" height=\\\"99\\\" rx=\\\"14\\\"/>',\\n                    baseLogoSmall,\\n                    baseLogo,\\n                    '<path d=\\\"M53.1 26.6c2.5 0 4.4 1.9 4.4 4.7 0 3-2 4.8-4.4 4.8a3.6 3.6 0 0 1-2.8-1.3h-.1v4.5h-1.9V26.8h1.9v1.1a3.8 3.8 0 0 1 3-1.3Zm16.4 0c2.6 0 4.7 2 4.7 4.7v.7h-7.5c.3 1.5 1.4 2.4 2.8 2.4 1 0 1.6-.3 2-.6l.6-.7h2a4.9 4.9 0 0 1-4.6 3c-2.6 0-4.7-2-4.7-4.8 0-2.6 2-4.7 4.7-4.7Zm29.6 0c1 0 1.7.3 2.2.7l.7.6h.1v-1.1h1.9v9.1h-1.9v-1.2l-.8.7c-.5.4-1.2.7-2.2.7-2.4 0-4.3-1.9-4.3-4.8 0-2.8 2-4.7 4.3-4.7Zm-34.7 0v1.9h-1.1c-1.5 0-2.5 1-2.5 2.5v5h-2v-9.2h2V28l.6-.7c.4-.4 1-.7 2-.7h1Zm22 0c2 0 3.4 1.3 3.4 3.8V36h-1.9v-5.4c0-1.5-.7-2.2-2-2.2-1.2 0-2.3 1-2.3 2.6v5h-1.9v-5.4c0-1.5-.7-2.2-2-2.2-1.2 0-2.3 1-2.3 2.6v5h-1.9v-9.1h1.9V28l.7-.7c.4-.4 1-.7 2-.7 1.3 0 2 .4 2.4.8l.7.9.7-.9c.5-.4 1.3-.8 2.5-.8Zm7.1.2v9.1h-1.9v-9.1h1.9Zm-40.7 1.5c-1.5 0-2.6 1-2.6 3s1 3.1 2.6 3.1 2.7-1 2.7-3-1-3.1-2.7-3.1Zm46.7 0c-1.6 0-2.7 1-2.7 3s1 3.1 2.7 3.1c1.5 0 2.6-1 2.6-3s-1-3.1-2.6-3.1Zm-30 0c-1.3 0-2.4.8-2.7 2.1h5.4c-.2-1-1-2.1-2.7-2.1Zm23-5.1c.7 0 1.2.5 1.2 1.1 0 .6-.5 1.1-1.1 1.1-.7 0-1.2-.5-1.2-1.1 0-.6.5-1.1 1.2-1.1Z\\\" fill=\\\"#FFF\\\"/>',\\n                    '<path d=\\\"M29.6 26.7h7.8c.5 0 .7.5.5.9l-3.7 5c-.3.5 0 1 .4 1H38c.2 0 .3-.1.4-.3l3.7-5v-.7l-3.2-4.4a.5.5 0 0 0-.5-.2h-9.5c-.2 0-.4 0-.5.2l-3.2 4.4v.7l8 11c.2.3.7.3.9 0l1.6-2.3c.2-.1.2-.4 0-.6l-6.4-8.8c-.3-.4 0-.9.4-.9Z\\\" fill=\\\"#5294FF\\\"/>',\\n                    underlyingLogo,\\n                    '<path stroke=\\\"#4D4343\\\" d=\\\"m154 148.5 6.5-26\\\"/>',\\n                    '<path d=\\\"M139.5 36c8 8 19.7 14.6 31 14.6h95.6c14.5 0 26.3 7.6 28.4 21.3v271.7c0 16-12.9 28.9-28.7 28.9H34.2c-15.8 0-28.7-13-28.7-28.9V33.4A28 28 0 0 1 34.2 5.5h67c6.3 0 12.4 3.5 16.9 8l21.4 22.6Z\\\" stroke=\\\"#FFF\\\" opacity=\\\".1\\\"/>',\\n                    '<path d=\\\"M289.26 66.05c-57.44 0-104 46.56-104 104s46.56 104 104 104c3.63 0 7.2-.18 10.74-.55V66.6c-3.53-.36-7.11-.55-10.74-.55Z\\\" fill=\\\"url(#b)\\\" opacity=\\\".31\\\" />',\\n                    '<path d=\\\"M10.7 66A104 104 0 1 1 0 273.6V66.6c3.5-.4 7.1-.5 10.7-.5Z\\\" fill=\\\"url(#c)\\\" opacity=\\\".3\\\"/>'\\n                )\\n            );\\n    }\\n\\n    function buildText(\\n        string memory baseSymbol,\\n        string memory underlyingSymbol,\\n        string memory strikePriceString,\\n        string memory maturityString\\n    ) internal pure returns (string memory) {\\n        bytes memory bufferA = abi.encodePacked(\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"gray\\\">',\\n            '<tspan x=\\\"32.1\\\" y=\\\"237\\\">Type</tspan>',\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"gray\\\">',\\n            '<tspan x=\\\"32.1\\\" y=\\\"263\\\">Strike price</tspan>',\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"gray\\\">',\\n            '<tspan x=\\\"32.1\\\" y=\\\"289\\\">Maturity</tspan>',\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Bold, DM Sans\\\" font-size=\\\"24\\\" font-weight=\\\"bold\\\" fill=\\\"#FFF\\\">',\\n            '<tspan style=\\\"direction:rtl\\\" x=\\\"143\\\" y=\\\"144\\\">',\\n            underlyingSymbol,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\"\\n        );\\n\\n        bytes memory bufferB = abi.encodePacked(\\n            '<text font-family=\\\"DMSans-Bold, DM Sans\\\" font-size=\\\"24\\\" font-weight=\\\"bold\\\" fill=\\\"#FFF\\\">',\\n            '<tspan x=\\\"173.1\\\" y=\\\"144\\\">',\\n            baseSymbol,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#FFF\\\">',\\n            '<tspan style=\\\"direction:rtl\\\" x=\\\"265\\\" y=\\\"263\\\">',\\n            strikePriceString,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#FFF\\\">',\\n            '<tspan style=\\\"direction:rtl\\\" x=\\\"265\\\" y=\\\"289\\\">',\\n            maturityString,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\"\\n        );\\n\\n        return string(abi.encodePacked(bufferA, bufferB));\\n    }\\n\\n    function buildDefs(\\n        string memory underlyingSymbol,\\n        string memory baseSymbol,\\n        bool isLong\\n    ) internal pure returns (string memory) {\\n        string memory baseGradient = buildBaseGradient(baseSymbol);\\n        string memory underlyingGradient = buildUnderlyingGradient(\\n            underlyingSymbol\\n        );\\n        string memory shortDefs = isLong ? \\\"\\\" : buildShortDefs();\\n        bytes memory whiteGradient = abi.encodePacked(\\n            '<linearGradient x1=\\\"50%\\\" y1=\\\"0%\\\" x2=\\\"50%\\\" y2=\\\"90%\\\" id=\\\"a\\\">',\\n            '<stop stop-color=\\\"#FFF\\\" stop-opacity=\\\"0\\\" offset=\\\"0%\\\"/>',\\n            '<stop stop-color=\\\"#FFF\\\" offset=\\\"80%\\\"/>',\\n            '<stop stop-color=\\\"#FFF\\\" stop-opacity=\\\"0\\\" offset=\\\"100%\\\"/>',\\n            \\\"</linearGradient>\\\"\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"<defs>\\\",\\n                    '<style type=\\\"text/css\\\">@import url(https://fonts.googleapis.com/css?family=DM+Sans);',\\n                    \\\"</style>\\\",\\n                    whiteGradient,\\n                    underlyingGradient,\\n                    baseGradient,\\n                    shortDefs,\\n                    \\\"</defs>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildUnderlyingGradient(string memory underlyingSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        (\\n            string memory underlyingColorA,\\n            string memory underlyingColorB\\n        ) = getTokenColors(underlyingSymbol);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<radialGradient cx=\\\"8%\\\" cy=\\\"50%\\\" fx=\\\"8%\\\" fy=\\\"50%\\\" r=\\\"90.6%\\\" gradientTransform=\\\"matrix(0 .55164 -1 0 .6 .5)\\\" id=\\\"c\\\">',\\n                    '<stop stop-color=\\\"',\\n                    underlyingColorA,\\n                    '\\\" offset=\\\"0%\\\"/>',\\n                    '<stop stop-color=\\\"',\\n                    underlyingColorB,\\n                    '\\\" stop-opacity=\\\"0\\\" offset=\\\"100%\\\"/>',\\n                    \\\"</radialGradient>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildBaseGradient(string memory baseSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        (string memory baseColorA, string memory baseColorB) = getTokenColors(\\n            baseSymbol\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<radialGradient cx=\\\"100%\\\" cy=\\\"50%\\\" fx=\\\"100%\\\" fy=\\\"50%\\\" r=\\\"90.64%\\\" gradientTransform=\\\"matrix(0 .55164 -1 0 1.5 -.05)\\\" id=\\\"b\\\">',\\n                    '<stop stop-color=\\\"',\\n                    baseColorA,\\n                    '\\\" offset=\\\"0%\\\"/>',\\n                    '<stop stop-color=\\\"',\\n                    baseColorB,\\n                    '\\\" stop-opacity=\\\"0\\\" offset=\\\"99.67%\\\"/>',\\n                    \\\"</radialGradient>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildShortDefs() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<linearGradient x1=\\\"62.1%\\\" y1=\\\"20.8%\\\" x2=\\\"-29.2%\\\" y2=\\\"25.7%\\\" id=\\\"d\\\">',\\n                    '<stop stop-color=\\\"#3E1808\\\" offset=\\\"3%\\\" />',\\n                    '<stop stop-color=\\\"#300427\\\" offset=\\\"100%\\\" />',\\n                    \\\"</linearGradient>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildCallRectangle() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect stroke=\\\"#2CE49A\\\" fill=\\\"#051A12\\\" fill-rule=\\\"nonzero\\\" x=\\\"18\\\" y=\\\"319.5\\\" width=\\\"264\\\" height=\\\"39\\\" rx=\\\"14\\\"/>',\\n                    '<path d=\\\"m111.6 332.2 5.2 5a.7.7 0 0 1 0 1.2l-.5.4c-.2.2-.3.2-.6.2-.2 0-.4 0-.5-.2l-3-3v9.4c0 .5-.4.8-.8.8h-.7c-.5 0-.8-.3-.8-.8v-9.4l-3 3c-.2.2-.4.2-.6.2-.3 0-.5 0-.6-.2l-.5-.4a.7.7 0 0 1 0-1.1l5.2-5 .6-.3c.2 0 .4 0 .6.2Z\\\" fill=\\\"#2CE49A\\\" fill-rule=\\\"nonzero\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#2CE49A\\\">',\\n                    '<tspan x=\\\"121\\\" y=\\\"344\\\">Call Option</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildPutRectangle() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect stroke=\\\"#EB4A97\\\" fill=\\\"#2D0719\\\" fill-rule=\\\"nonzero\\\" x=\\\"18\\\" y=\\\"319.5\\\" width=\\\"264\\\" height=\\\"39\\\" rx=\\\"14\\\"/>',\\n                    '<path d=\\\"m111.6 345.8 5.2-5a.7.7 0 0 0 0-1.2l-.5-.4a.8.8 0 0 0-.6-.2c-.2 0-.4 0-.5.2l-3 3v-9.4c0-.5-.4-.8-.8-.8h-.7c-.5 0-.8.3-.8.8v9.4l-3-3a.8.8 0 0 0-1.1 0l-.6.4a.7.7 0 0 0 0 1.1l5.2 5 .6.3c.2 0 .4 0 .6-.2Z\\\" fill=\\\"#EB4A97\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#EB4A97\\\">',\\n                    '<tspan x=\\\"122.7\\\" y=\\\"344\\\">Put Option</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildShortLongTag(bool _isLong)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return _isLong ? buildLongTag() : buildShortTag();\\n    }\\n\\n    function buildLongTag() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect fill=\\\"#0C1E3C\\\" fill-rule=\\\"nonzero\\\" x=\\\"208\\\" y=\\\"222\\\" width=\\\"57\\\" height=\\\"23\\\" rx=\\\"6\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#5294FF\\\">',\\n                    '<tspan x=\\\"221.1\\\" y=\\\"238.5\\\">Long</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildShortTag() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect fill=\\\"url(#d)\\\" fill-rule=\\\"nonzero\\\" x=\\\"208\\\" y=\\\"222\\\" width=\\\"57\\\" height=\\\"23\\\" rx=\\\"6\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#ED6F64\\\">',\\n                    '<tspan x=\\\"219.1\\\" y=\\\"238.5\\\">Short</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function getUnderlyingLogo(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (\\n            hash == keccak256(abi.encodePacked(\\\"ETH\\\")) ||\\n            hash == keccak256(abi.encodePacked(\\\"WETH\\\"))\\n        ) {\\n            return ETH_UNDERLYING_LOGO;\\n        } else if (hash == keccak256(abi.encodePacked(\\\"LINK\\\"))) {\\n            return LINK_UNDERLYING_LOGO;\\n        } else if (hash == keccak256(abi.encodePacked(\\\"WBTC\\\"))) {\\n            return WBTC_UNDERLYING_LOGO;\\n        } else {\\n            return UNKNOWN_UNDERLYING_LOGO;\\n        }\\n    }\\n\\n    function getBaseLogo(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (hash == keccak256(abi.encodePacked(\\\"DAI\\\"))) {\\n            return DAI_BASE_LOGO;\\n        } else {\\n            return UNKNOWN_BASE_LOGO;\\n        }\\n    }\\n\\n    function getBaseLogoSmall(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (hash == keccak256(abi.encodePacked(\\\"DAI\\\"))) {\\n            return DAI_BASE_LOGO_SMALL;\\n        } else {\\n            return UNKNOWN_BASE_LOGO_SMALL;\\n        }\\n    }\\n\\n    function getTokenColors(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory, string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (\\n            hash == keccak256(abi.encodePacked(\\\"ETH\\\")) ||\\n            hash == keccak256(abi.encodePacked(\\\"WETH\\\"))\\n        ) {\\n            return (ETH_COLOR_A, ETH_COLOR_B);\\n        } else if (hash == keccak256(abi.encodePacked(\\\"LINK\\\"))) {\\n            return (LINK_COLOR_A, LINK_COLOR_B);\\n        } else if (hash == keccak256(abi.encodePacked(\\\"WBTC\\\"))) {\\n            return (WBTC_COLOR_A, WBTC_COLOR_B);\\n        } else if (hash == keccak256(abi.encodePacked(\\\"DAI\\\"))) {\\n            return (DAI_COLOR_A, DAI_COLOR_B);\\n        } else {\\n            return (UNKNOWN_COLOR_A, UNKNOWN_COLOR_B);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/NFTDisplay.sol\": {\r\n        \"NFTDisplay\": \"0x165958225dfd1ca035e66318486968da1521d43a\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PremiaOptionNFTDisplay","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}