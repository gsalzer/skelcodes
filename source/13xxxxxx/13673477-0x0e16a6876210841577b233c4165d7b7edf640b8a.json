{"status":"1","message":"OK","result":[{"SourceCode":"/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: OwnerRelayOnEthereum.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/OwnerRelayOnEthereum.sol\n* Docs: https://docs.synthetix.io/contracts/OwnerRelayOnEthereum\n*\n* Contract Dependencies: \n*\t- IAddressResolver\n*\t- MixinResolver\n*\t- MixinSystemSettings\n*\t- Owned\n* Libraries: (none)\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2021 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\ninterface IFlexibleStorage {\n    // Views\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\n\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\n\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\n\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\n\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\n\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\n\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\n\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\n\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\n\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\n\n    // Mutative functions\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\n\n    function setUIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        uint value\n    ) external;\n\n    function setUIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        uint[] calldata values\n    ) external;\n\n    function setIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        int value\n    ) external;\n\n    function setIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        int[] calldata values\n    ) external;\n\n    function setAddressValue(\n        bytes32 contractName,\n        bytes32 record,\n        address value\n    ) external;\n\n    function setAddressValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        address[] calldata values\n    ) external;\n\n    function setBoolValue(\n        bytes32 contractName,\n        bytes32 record,\n        bool value\n    ) external;\n\n    function setBoolValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bool[] calldata values\n    ) external;\n\n    function setBytes32Value(\n        bytes32 contractName,\n        bytes32 record,\n        bytes32 value\n    ) external;\n\n    function setBytes32Values(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bytes32[] calldata values\n    ) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\ncontract MixinSystemSettings is MixinResolver {\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\n\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = \"crossDomainRelayGasLimit\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_MAX_TOKEN_AMOUNT = \"wrapperMaxTokens\";\n    bytes32 internal constant SETTING_WRAPPER_MINT_FEE_RATE = \"wrapperMintFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_BURN_FEE_RATE = \"wrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_MIN_CRATIO = \"minCratio\";\n    bytes32 internal constant SETTING_NEW_COLLATERAL_MANAGER = \"newCollateralManager\";\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \"interactionDelay\";\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \"collapseFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = \"atomicMaxVolumePerBlock\";\n    bytes32 internal constant SETTING_ATOMIC_TWAP_WINDOW = \"atomicTwapWindow\";\n    bytes32 internal constant SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = \"atomicEquivalentForDexPricing\";\n    bytes32 internal constant SETTING_ATOMIC_EXCHANGE_FEE_RATE = \"atomicExchangeFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_PRICE_BUFFER = \"atomicPriceBuffer\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = \"atomicVolConsiderationWindow\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = \"atomicVolUpdateThreshold\";\n\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\n\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal, Relay}\n\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](1);\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\n    }\n\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\n    }\n\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Relay) {\n            return SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT;\n        } else {\n            revert(\"Unknown gas limit type\");\n        }\n    }\n\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\n    }\n\n    function getTradingRewardsEnabled() internal view returns (bool) {\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\n    }\n\n    function getWaitingPeriodSecs() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\n    }\n\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\n    }\n\n    function getIssuanceRatio() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\n    }\n\n    function getFeePeriodDuration() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\n    }\n\n    function getTargetThreshold() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\n    }\n\n    function getLiquidationDelay() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\n    }\n\n    function getLiquidationRatio() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\n    }\n\n    function getLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\n    }\n\n    function getRateStalePeriod() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\n    }\n\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getMinimumStakeTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\n    }\n\n    function getAggregatorWarningFlags() internal view returns (address) {\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\n    }\n\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\n    }\n\n    function getEtherWrapperMaxETH() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\n    }\n\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\n    }\n\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\n    }\n\n    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))\n            );\n    }\n\n    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))\n            );\n    }\n\n    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))\n            );\n    }\n\n    function getMinCratio(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_MIN_CRATIO, collateral))\n            );\n    }\n\n    function getNewCollateralManager(address collateral) internal view returns (address) {\n        return\n            flexibleStorage().getAddressValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_NEW_COLLATERAL_MANAGER, collateral))\n            );\n    }\n\n    function getInteractionDelay(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\n            );\n    }\n\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\n            );\n    }\n\n    function getAtomicMaxVolumePerBlock() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);\n    }\n\n    function getAtomicTwapWindow() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);\n    }\n\n    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {\n        return\n            flexibleStorage().getAddressValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))\n            );\n    }\n\n    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getAtomicPriceBuffer(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_PRICE_BUFFER, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))\n            );\n    }\n}\n\n\npragma experimental ABIEncoderV2;\n\ninterface IOwnerRelayOnOptimism {\n    function finalizeRelay(address target, bytes calldata payload) external;\n\n    function finalizeRelayBatch(address[] calldata target, bytes[] calldata payloads) external;\n}\n\n\n// SPDX-License-Identifier: MIT\n\n\n/**\n * @title iAbs_BaseCrossDomainMessenger\n */\ninterface iAbs_BaseCrossDomainMessenger {\n\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(bytes message);\n    event RelayedMessage(bytes32 msgHash);\n    event FailedRelayedMessage(bytes32 msgHash);\n\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\ncontract OwnerRelayOnEthereum is MixinSystemSettings, Owned {\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_EXT_MESSENGER = \"ext:Messenger\";\n    bytes32 private constant CONTRACT_OVM_OWNER_RELAY_ON_OPTIMISM = \"ovm:OwnerRelayOnOptimism\";\n\n    // ========== CONSTRUCTOR ==========\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== INTERNALS ============ */\n\n    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {\n        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));\n    }\n\n    function _ownerRelayOnOptimism() private view returns (address) {\n        return requireAndGetAddress(CONTRACT_OVM_OWNER_RELAY_ON_OPTIMISM);\n    }\n\n    function _getCrossDomainGasLimit(uint32 crossDomainGasLimit) private view returns (uint32) {\n        // Use specified crossDomainGasLimit if specified value is not zero.\n        // otherwise use the default in SystemSettings.\n        return\n            crossDomainGasLimit != 0\n                ? crossDomainGasLimit\n                : uint32(getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits.Relay));\n    }\n\n    /* ========== VIEWS ========== */\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](2);\n        newAddresses[0] = CONTRACT_EXT_MESSENGER;\n        newAddresses[1] = CONTRACT_OVM_OWNER_RELAY_ON_OPTIMISM;\n        addresses = combineArrays(existingAddresses, newAddresses);\n    }\n\n    /* ========== RESTRICTED ========== */\n\n    function initiateRelay(\n        address target,\n        bytes calldata payload,\n        uint32 crossDomainGasLimit // If zero, uses default value in SystemSettings\n    ) external onlyOwner {\n        IOwnerRelayOnOptimism ownerRelayOnOptimism;\n        bytes memory messageData = abi.encodeWithSelector(ownerRelayOnOptimism.finalizeRelay.selector, target, payload);\n\n        _messenger().sendMessage(_ownerRelayOnOptimism(), messageData, _getCrossDomainGasLimit(crossDomainGasLimit));\n\n        emit RelayInitiated(target, payload);\n    }\n\n    function initiateRelayBatch(\n        address[] calldata targets,\n        bytes[] calldata payloads,\n        uint32 crossDomainGasLimit // If zero, uses default value in SystemSettings\n    ) external onlyOwner {\n        // First check that the length of the arguments match\n        require(targets.length == payloads.length, \"Argument length mismatch\");\n\n        IOwnerRelayOnOptimism ownerRelayOnOptimism;\n        bytes memory messageData =\n            abi.encodeWithSelector(ownerRelayOnOptimism.finalizeRelayBatch.selector, targets, payloads);\n\n        _messenger().sendMessage(_ownerRelayOnOptimism(), messageData, _getCrossDomainGasLimit(crossDomainGasLimit));\n\n        emit RelayBatchInitiated(targets, payloads);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RelayInitiated(address target, bytes payload);\n    event RelayBatchInitiated(address[] targets, bytes[] payloads);\n}\n\n    ","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"}],\"name\":\"RelayBatchInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"RelayInitiated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"crossDomainGasLimit\",\"type\":\"uint32\"}],\"name\":\"initiateRelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"},{\"internalType\":\"uint32\",\"name\":\"crossDomainGasLimit\",\"type\":\"uint32\"}],\"name\":\"initiateRelayBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"addresses\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OwnerRelayOnEthereum","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000de910777c787903f78c89e7a0bf7f4c435cbb1fe0000000000000000000000004e3b31eb0e5cb73641ee1e65e7dcefe520ba3ef2","EVMVersion":"Default","Library":"SafeDecimalMath:84d626b2bb4d0f064067e4bf80fce7055d8f3e7b","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}