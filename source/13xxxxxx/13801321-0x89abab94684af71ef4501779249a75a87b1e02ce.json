{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./lib/AMMLib.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./OptionVault.sol\\\";\\nimport \\\"./interfaces/IOptionVault.sol\\\";\\nimport \\\"./interfaces/IFeePool.sol\\\";\\nimport \\\"./interfaces/IAMM.sol\\\";\\n\\n/**\\n * @notice AMM contract is Automated Market Maker for option contracts.\\n * It manages LP(Liquidity provider) tokens and liquidity to write options.\\n */\\ncontract AMM is IAMM, ERC1155, Ownable, IERC1155Receiver, ReentrancyGuard {\\n    using AMMLib for AMMLib.PoolInfo;\\n    using AMMLib for mapping(uint32 => AMMLib.Tick);\\n    using AMMLib for AMMLib.Tick;\\n\\n    /// @dev pool info\\n    AMMLib.PoolInfo poolInfo;\\n\\n    /// @dev price oracle contract\\n    PriceOracle priceOracle;\\n\\n    /// @dev fee pool contract\\n    IFeePool public override feePool;\\n\\n    /// @dev operator address\\n    address operator;\\n\\n    /// @dev bot address\\n    address bot;\\n\\n    /// @dev emergency mode or not\\n    bool isEmergencyMode;\\n\\n    /// @dev nobody can provide liquidity after depositAllowedUntil timestamp\\n    uint256 depositAllowedUntil;\\n\\n    /// @dev lp address => rangeId => amount of reservation\\n    mapping(address => mapping(uint256 => AMMLib.Reservation)) public reservations;\\n\\n    /// @dev last provided timestamp of liquidity\\n    mapping(address => uint256) public lastProvidedAt;\\n\\n    /// @dev lockup period for liquidity withdrawal\\n    uint256 lockupPeriod = 2 weeks;\\n\\n    mapping(address => bool) addressesAllowedSkippingLockup;\\n\\n    // events\\n    event Deposited(address indexed account, address asset, uint256 rangeId, uint128 amount, uint128 mint);\\n    event Withdrawn(address indexed account, address asset, uint256 rangeId, uint128 amount, uint128 burn);\\n    event OptionBought(uint256 seriesId, address indexed buyer, uint128 amount, uint128 premium);\\n    event OptionSold(uint256 seriesId, address indexed seller, uint128 amount, uint128 premium);\\n    event Settled(uint256 indexed _expiryId, uint128 protocolFee);\\n    event EmergencyStateChanged(bool isEmergencyMode);\\n    event ConfigUpdated(uint8 key, uint128 value);\\n    event DepositAllowedUntilUpdated(uint256 depositAllowedUntil);\\n    event LockupPeriodUpdated(uint256 period);\\n\\n    modifier onlyOperator() {\\n        require(msg.sender == operator, \\\"AMM: caller must be operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyBot() {\\n        require(msg.sender == bot, \\\"AMM: caller must be bot\\\");\\n        _;\\n    }\\n\\n    modifier isDepositAllowed() {\\n        require(block.timestamp < depositAllowedUntil, \\\"AMM: deposit not allowed\\\");\\n        _;\\n    }\\n\\n    modifier notEmergencyMode() {\\n        require(!isEmergencyMode, \\\"AMM: emergency mode\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory _uri,\\n        address _aggregator,\\n        address _collateral,\\n        address _priceOracle,\\n        address _feeRecipient,\\n        address _operator,\\n        address _optionContract\\n    ) ERC1155(_uri) {\\n        operator = _operator;\\n        bot = _operator;\\n\\n        priceOracle = PriceOracle(_priceOracle);\\n\\n        feePool = IFeePool(_feeRecipient);\\n\\n        depositAllowedUntil = 2**256 - 1;\\n\\n        poolInfo.init(_aggregator, _collateral, _optionContract);\\n    }\\n\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    ) external override(IERC1155Receiver) returns (bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) external override(IERC1155Receiver) returns (bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address _operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override(ERC1155) {\\n        super._beforeTokenTransfer(_operator, from, to, ids, amounts, data);\\n\\n        if (!addressesAllowedSkippingLockup[_operator]) {\\n            // LPs can't transfer LP tokens before lockupPeriod\\n            require(lastProvidedAt[from] + lockupPeriod <= block.timestamp, \\\"AMM: liquidity is locked up\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice deposit collateral asset to pool\\n     * price of LP token is '(balance - lockedPremium) / supply'\\n     * @param _mintAmount amount of write token to mint.\\n     *   it must be muptiples of _tickEnd - _tickStart.\\n     * @param _maxDeposit max deposit collateral amount scaled by 1e6\\n     * @param _tickStart lower tick\\n     * @param _tickEnd upper tick\\n     */\\n    function deposit(\\n        uint128 _mintAmount,\\n        uint128 _maxDeposit,\\n        uint32 _tickStart,\\n        uint32 _tickEnd\\n    ) external notEmergencyMode isDepositAllowed nonReentrant {\\n        // validate inputs\\n        AMMLib.validateRange(_tickStart, _tickEnd);\\n\\n        // mint LP tokens\\n        uint128 amountDeposited = poolInfo.addBalance(_tickStart, _tickEnd, _mintAmount);\\n        require(amountDeposited > 0, \\\"AMM: amount is too small\\\");\\n        require(amountDeposited <= _maxDeposit, \\\"AMM: amount deposited is greater than max\\\");\\n        uint128 rangeId = genRangeId(_tickStart, _tickEnd);\\n\\n        // receive collateral from LP\\n        IERC20(poolInfo.collateral).transferFrom(msg.sender, address(this), amountDeposited);\\n\\n        // mint LP tokens\\n        _mint(msg.sender, rangeId, _mintAmount, \\\"\\\");\\n\\n        lastProvidedAt[msg.sender] = block.timestamp;\\n\\n        //emit event\\n        emit Deposited(msg.sender, poolInfo.collateral, rangeId, amountDeposited, _mintAmount);\\n    }\\n\\n    /**\\n     * @notice reserve withdrawal.\\n     * LPs can make reservation for withdrawal.\\n     * withdrawable timestamp is last expiry of live option serieses.\\n     * The AMM sets aside funds for withdrawals at each maturity.\\n     * @param _reserveAmount amount of LP token\\n     * @param _rangeId range id represents lower tick to upper tick\\n     */\\n    function reserveWithdrawal(uint128 _reserveAmount, uint128 _rangeId) external {\\n        // validate inputs\\n        require(_reserveAmount > 0, \\\"AMM: amount is too small\\\");\\n\\n        (uint32 tickStart, uint32 tickEnd) = getRange(_rangeId);\\n        AMMLib.validateRange(tickStart, tickEnd);\\n        AMMLib.Reservation storage reservation = reservations[msg.sender][_rangeId];\\n\\n        require(balanceOf(msg.sender, _rangeId) >= _reserveAmount + reservation.burn, \\\"AMM: amount is too large\\\");\\n\\n        // get the last expiry\\n        uint128 withdrawableTimestamp = poolInfo.optionVault.getLastExpiry();\\n\\n        poolInfo.reserveWithdrawal(tickStart, tickEnd, _reserveAmount);\\n\\n        if (reservation.burn > 0) {\\n            reservation.burn += _reserveAmount;\\n            reservation.withdrawableTimestamp = withdrawableTimestamp;\\n        } else {\\n            reservations[msg.sender][_rangeId] = AMMLib.Reservation(_reserveAmount, withdrawableTimestamp);\\n        }\\n    }\\n\\n    /**\\n     * @notice withdraw collateral asset from pool\\n     * withdrawable amount is calculated by the following formula.\\n     * amount = (burn amount) * (pool quote value) / supply\\n     * However, if available amount is less than the withdrawable amount,\\n     * LP need to make reservation in advance.\\n     * LPs should specify minimum withdrawable amount as _minWithdrawal\\n     * @param _burnAmount amount of write token to burn.\\n     * @param _minWithdrawal minimal withdraw collateral amount scaled by 1e6\\n     * @param _rangeId range id represents lower tick to upper tick\\n     * @param _useReservation use reservation or not\\n     */\\n    function withdraw(\\n        uint128 _burnAmount,\\n        uint128 _minWithdrawal,\\n        uint128 _rangeId,\\n        bool _useReservation\\n    ) external notEmergencyMode nonReentrant {\\n        // validate inputs\\n        (uint32 tickStart, uint32 tickEnd) = getRange(_rangeId);\\n        AMMLib.Reservation memory reservation = reservations[msg.sender][_rangeId];\\n\\n        AMMLib.validateRange(tickStart, tickEnd);\\n\\n        require(balanceOf(msg.sender, _rangeId) >= _burnAmount, \\\"AMM: msg.sender doesn't have enough LP tokens\\\");\\n\\n        // burn LP tokens\\n        uint128 withdrawnAmount;\\n\\n        if (_useReservation) {\\n            require(_burnAmount <= reservation.burn, \\\"AMM: burnAmount must be reserved\\\");\\n\\n            require(block.timestamp > reservation.withdrawableTimestamp, \\\"AMM: withdrawable period must have passed\\\");\\n\\n            withdrawnAmount = poolInfo.removeBalanceFromReservation(tickStart, tickEnd, _burnAmount);\\n\\n            reservations[msg.sender][_rangeId].burn -= _burnAmount;\\n        } else {\\n            require(reservation.burn == 0, \\\"AMM: reservation must not be exists\\\");\\n\\n            withdrawnAmount = poolInfo.removeBalance(tickStart, tickEnd, _burnAmount);\\n        }\\n\\n        require(withdrawnAmount > 0, \\\"AMM: amount is too small\\\");\\n\\n        _burn(msg.sender, _rangeId, _burnAmount);\\n\\n        // send collateral to LP\\n        require(withdrawnAmount >= _minWithdrawal, \\\"AMM: _burnAmount is too small\\\");\\n        IERC20(poolInfo.collateral).transfer(msg.sender, withdrawnAmount);\\n\\n        //emit event\\n        emit Withdrawn(msg.sender, poolInfo.collateral, _rangeId, withdrawnAmount, _burnAmount);\\n    }\\n\\n    /**\\n     * @notice calculate option premium\\n     * @param _seriesId option series id\\n     * @param _size option size scaled by 1e8\\n     */\\n    function calculatePremium(\\n        uint256 _seriesId,\\n        uint128 _size,\\n        bool _isSelling\\n    ) external view returns (uint128) {\\n        require(_size > 0, \\\"AMM: size must not be 0\\\");\\n\\n        uint128 spot = getPrice();\\n\\n        return poolInfo.calculatePremium(_seriesId, _size, spot, _isSelling);\\n    }\\n\\n    /**\\n     * @notice send premium and receive options\\n     * @param _seriesId option series id\\n     * @param _amount amount to buy scaled by 1e8\\n     * @param _maxFee max total amount of premium to pay\\n     */\\n    function buy(\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _maxFee\\n    ) external notEmergencyMode nonReentrant {\\n        require(_amount > 0, \\\"AMM: amount must not be 0\\\");\\n\\n        uint128 spot = getPrice();\\n\\n        uint128 premium = poolInfo.buy(_seriesId, _amount, spot, msg.sender);\\n        require(premium <= _maxFee, \\\"AMM: total fee exceeds maxFeeAmount\\\");\\n\\n        // receive premium from trader\\n        IERC20(poolInfo.collateral).transferFrom(msg.sender, address(this), premium);\\n\\n        emit OptionBought(_seriesId, msg.sender, _amount, premium);\\n    }\\n\\n    /**\\n     * @notice send options and receive premium\\n     * @param _seriesId option series id\\n     * @param _amount amount to sell scaled by 1e8\\n     * @param _minFee minimal premium to receive\\n     */\\n    function sell(\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _minFee\\n    ) external override notEmergencyMode nonReentrant returns (uint128) {\\n        require(_amount > 0, \\\"AMM: amount must not be 0\\\");\\n\\n        require(\\n            ERC1155(address(poolInfo.optionVault)).balanceOf(msg.sender, _seriesId) >= _amount,\\n            \\\"AMM: msg.sender doesn't have enough amount\\\"\\n        );\\n\\n        ERC1155(address(poolInfo.optionVault)).safeTransferFrom(msg.sender, address(this), _seriesId, _amount, \\\"\\\");\\n\\n        uint128 spot = getPrice();\\n\\n        uint128 premium = poolInfo.sell(_seriesId, _amount, spot, msg.sender);\\n\\n        require(premium >= _minFee, \\\"AMM: premium is too low\\\");\\n\\n        // send premium to trader from pool\\n        IERC20(poolInfo.collateral).transfer(msg.sender, premium);\\n\\n        // emit event\\n        emit OptionSold(_seriesId, msg.sender, _amount, premium);\\n\\n        return premium;\\n    }\\n\\n    ////////////////////////\\n    // Operator Functions //\\n    ////////////////////////\\n\\n    /**\\n     * @notice settle option serieses of an expiration\\n     * settle vaults for pool's short positions and unlock collaterals.\\n     * claim profit of pool's long positions.\\n     * @param _expiryId expiration id\\n     */\\n    function settle(uint256 _expiryId) external onlyBot {\\n        uint128 protocolFee = poolInfo.settle(_expiryId);\\n\\n        if (protocolFee > 0) {\\n            // send protocolFee to fee recipient\\n            IERC20(poolInfo.collateral).approve(address(feePool), protocolFee);\\n            feePool.sendProfitERC20(address(this), protocolFee);\\n        }\\n\\n        emit Settled(_expiryId, protocolFee);\\n    }\\n\\n    /**\\n     * @notice rebalance collateral for a tick\\n     * withdraw collaterals from the vault if there are extra collaterals.\\n     * Only the operator can call this function.\\n     * @param _tickId tick id\\n     * @param _expiryId expiry id\\n     */\\n    function rebalanceCollateral(uint32 _tickId, uint256 _expiryId) external onlyOperator {\\n        poolInfo.rebalanceCollateral(_tickId, _expiryId);\\n    }\\n\\n    /**\\n     * @notice set or unset emergency mode\\n     * @param _isEmergencyMode if true, set emergency mode.\\n     *  if false unset emergency mode.\\n     */\\n    function changeState(bool _isEmergencyMode) external onlyOperator {\\n        isEmergencyMode = _isEmergencyMode;\\n\\n        emit EmergencyStateChanged(_isEmergencyMode);\\n    }\\n\\n    /**\\n     * @notice set depositAllowedUntil parameter\\n     * @param _depositAllowedUntil no one can provide liquidity after this timestamp\\n     */\\n    function setDepositAllowedUntil(uint256 _depositAllowedUntil) external onlyOperator {\\n        depositAllowedUntil = _depositAllowedUntil;\\n\\n        emit DepositAllowedUntilUpdated(_depositAllowedUntil);\\n    }\\n\\n    /**\\n     * @notice set lockup period\\n     * @param _lockupPeriod depositor cannot withdraw during lockup period\\n     */\\n    function setLockupPeriod(uint256 _lockupPeriod) external onlyOperator {\\n        lockupPeriod = _lockupPeriod;\\n\\n        emit LockupPeriodUpdated(_lockupPeriod);\\n    }\\n\\n    function setAddressAllowedSkippingLockup(address _address, bool _isAllowed) external onlyOperator {\\n        addressesAllowedSkippingLockup[_address] = _isAllowed;\\n    }\\n\\n    /**\\n     * @notice update a config value\\n     */\\n    function setConfig(uint8 _key, uint128 _value) external onlyOperator {\\n        poolInfo.configs[_key] = _value;\\n\\n        // emit event\\n        emit ConfigUpdated(_key, _value);\\n    }\\n\\n    /**\\n     * @notice set bot address\\n     * @param _bot bot address\\n     */\\n    function setBot(address _bot) external onlyOperator {\\n        bot = _bot;\\n    }\\n\\n    /**\\n     * @notice set new fee recipient\\n     * @param _feeRecipient fee recipient\\n     */\\n    function setFeeRecipient(address _feeRecipient) external onlyOperator {\\n        feePool = IFeePool(_feeRecipient);\\n    }\\n\\n    /**\\n     * @notice set new operator\\n     * @param _operator operator address\\n     */\\n    function setNewOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    //////////////////////\\n    // Getter Functions //\\n    //////////////////////\\n\\n    /**\\n     * @notice get mint amount of LP token\\n     * @param _depositAmount amount of collateral to deposit scaled by 1e6\\n     * @param _tickStart lower tick\\n     * @param _tickEnd upper tick\\n     */\\n    function getMintAmount(\\n        uint128 _depositAmount,\\n        uint32 _tickStart,\\n        uint32 _tickEnd\\n    ) external view returns (uint128) {\\n        return poolInfo.getMintAmount(_tickStart, _tickEnd, _depositAmount);\\n    }\\n\\n    /**\\n     * @notice get withdrawable amount of collateral scaled by 1e6\\n     * @param _burnAmount LP token to burn\\n     * @param _tickStart lower tick\\n     * @param _tickEnd upper tick\\n     */\\n    function getWithdrawableAmount(\\n        uint128 _burnAmount,\\n        uint32 _tickStart,\\n        uint32 _tickEnd\\n    ) external view returns (uint128) {\\n        return poolInfo.getWithdrawableAmount(_tickStart, _tickEnd, _burnAmount);\\n    }\\n\\n    /**\\n     * @notice get tick list\\n     * @param _tickStart lower tick\\n     * @param _tickEnd upper tick\\n     * @return tick list\\n     */\\n    function getTicks(uint32 _tickStart, uint32 _tickEnd) public view returns (AMMLib.Tick[] memory) {\\n        AMMLib.validateRange(_tickStart, _tickEnd);\\n        AMMLib.Tick[] memory _ticks = new AMMLib.Tick[](_tickEnd - _tickStart);\\n        for (uint32 i = _tickStart; i < _tickEnd; i++) {\\n            _ticks[i - _tickStart] = poolInfo.ticks[i];\\n        }\\n        return _ticks;\\n    }\\n\\n    function getSeriesState(uint32 _tickId, uint256 _seriesId)\\n        public\\n        view\\n        returns (AMMLib.LockedOptionStatePerTick memory, bool exists)\\n    {\\n        return AMMLib.getLockedOptionStatePerTick(poolInfo, _seriesId, _tickId);\\n    }\\n\\n    function getProfitState(uint32 _tickId, uint256 _expiryId) public view returns (AMMLib.Profit memory) {\\n        return poolInfo.profits[_expiryId][_tickId];\\n    }\\n\\n    /**\\n     * @notice get tick cumulative of earning seconds per liquidity\\n     */\\n    function getSecondsPerLiquidity(uint32 _tickLower, uint32 _tickUpper) external view returns (uint128) {\\n        AMMLib.validateRange(_tickLower, _tickUpper);\\n        return poolInfo.ticks.getSecondsPerLiquidity(_tickLower, _tickUpper);\\n    }\\n\\n    function getLockupPeriod() external view returns (uint256) {\\n        return lockupPeriod;\\n    }\\n\\n    /**\\n     * @notice get a config value\\n     */\\n    function getConfig(uint8 _key) external view returns (uint128) {\\n        return poolInfo.configs[_key];\\n    }\\n\\n    function genRangeId(uint32 _tickStart, uint32 _tickEnd) public pure returns (uint128) {\\n        return _tickStart + 1e2 * _tickEnd;\\n    }\\n\\n    function getRange(uint128 _rangeId) public pure returns (uint32 _start, uint32 _end) {\\n        _start = uint32(_rangeId % 1e2);\\n        _end = uint32(_rangeId / 1e2);\\n    }\\n\\n    function getPrice() internal view returns (uint128) {\\n        (uint256 spot, ) = priceOracle.getPrice(poolInfo.aggregator);\\n        return uint128(spot);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155).interfaceId\\n            || interfaceId == type(IERC1155MetadataURI).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][from] = fromBalance - amount;\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            _balances[id][from] = fromBalance - amount;\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        _balances[id][account] = accountBalance - amount;\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal\\n        virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AMMLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"../interfaces/IHedge.sol\\\";\\nimport \\\"../interfaces/IOptionVault.sol\\\";\\nimport \\\"./PredyMath.sol\\\";\\nimport \\\"./OptionLib.sol\\\";\\n\\n/**\\n * @title AMMLib\\n * @notice The library for option automated market maker\\n */\\nlibrary AMMLib {\\n    using AMMLib for AMMLib.PoolInfo;\\n    using AMMLib for AMMLib.Tick;\\n    using AMMLib for AMMLib.LockedOptionStatePerTick[];\\n    using PredyMath for uint128;\\n\\n    /// @dev max uint256\\n    uint256 constant MAX_UINT256 = 2**256 - 1;\\n\\n    /// @dev minimum value of tick\\n    uint32 constant MIN_TICK = 2;\\n\\n    /// @dev maximum value of tick\\n    uint32 constant MAX_TICK = 30;\\n\\n    /// @dev the maximum interval of trading at which the protocol recalculates the premium.\\n    uint256 constant SAFETY_PERIOD = 6 minutes;\\n\\n    /**\\n     * @notice tick is a section of IV\\n     *   Tick has information about the status of the funds\\n     * @param supply amount of LP token issued\\n     * @param balance amount of fund for buying and selling options\\n     * @param lastSupply last snapshot of supply\\n     * @param lastBalance last snapshot of balance\\n     * @param secondsPerLiquidity seconds / liquidity\\n     * @param reservationForWithdrawal reservation for withdrawal\\n     * @param hedgePosition current position of the hedge\\n     */\\n    struct Tick {\\n        uint128 supply;\\n        uint128 balance;\\n        int128 unrealizedPnL;\\n        uint128 lastSupply;\\n        uint128 lastBalance;\\n        uint128 secondsPerLiquidity;\\n        uint128 burnReserved;\\n        uint128 reservationForWithdrawal;\\n    }\\n\\n    /**\\n     * @notice tick state for a option series\\n     */\\n    struct LockedOptionStatePerTick {\\n        // tick id\\n        uint32 tickId;\\n        //\\n        bool isLong;\\n        // the price per size in last trade recorded per series.\\n        // scaled by 1e12\\n        uint128 lastPricePerSize;\\n        // the timestamp of last trade recorded per series.\\n        uint128 tradeTime;\\n    }\\n\\n    struct Profit {\\n        // unrealized profit and loss\\n        int128 unrealizedPnL;\\n        // cumulative locked premium\\n        uint128 cumulativeFee;\\n    }\\n\\n    /// @dev pool information\\n    struct PoolInfo {\\n        address aggregator;\\n        // option vault contract\\n        IOptionVault optionVault;\\n        // collateral address\\n        address collateral;\\n        // timestamp of last trade\\n        uint64 lastBoughtTimestamp;\\n        // ticks\\n        mapping(uint32 => Tick) ticks;\\n        // extra locked amount for each option series\\n        // tickId => seriesId => buy or sell\\n        mapping(uint32 => mapping(uint256 => uint128[2])) lockedAmounts;\\n        // seriesId => LockedOptionState\\n        mapping(uint256 => LockedOptionStatePerTick[]) locked;\\n        // expiryId => tickId => Profit\\n        mapping(uint256 => mapping(uint32 => Profit)) profits;\\n        // pool configs\\n        mapping(uint8 => uint128) configs;\\n    }\\n\\n    /// @dev buy and sell trade state\\n    struct TradeState {\\n        uint32 currentTick;\\n        uint32 nextTick;\\n        uint128 stepAmount;\\n        uint128 remain;\\n        uint128 currentIV;\\n        address trader;\\n        bool isTickLong;\\n        uint128 pricePerSize;\\n    }\\n\\n    /// @dev reservation for withdrawal\\n    struct Reservation {\\n        uint128 burn;\\n        uint128 withdrawableTimestamp;\\n    }\\n\\n    uint8 public constant PROTOCOL_FEE_RATIO = 1;\\n    uint8 public constant MIN_DELTA = 3;\\n    uint8 public constant BASE_SPREAD = 4;\\n\\n    /**\\n     * @notice initialize PoolInfo\\n     */\\n    function init(\\n        PoolInfo storage _pool,\\n        address _aggregator,\\n        address _collateral,\\n        address _optionVault\\n    ) external {\\n        require(address(_pool.optionVault) == address(0), \\\"AMMLib: \\\");\\n\\n        _pool.collateral = _collateral;\\n        require(ERC20(_collateral).decimals() == 6);\\n        _pool.aggregator = _aggregator;\\n        _pool.optionVault = IOptionVault(_optionVault);\\n\\n        _pool.configs[PROTOCOL_FEE_RATIO] = 10;\\n        _pool.configs[MIN_DELTA] = 5 * 1e6;\\n        // 1 / 500 = 0.2%\\n        _pool.configs[BASE_SPREAD] = 500;\\n\\n        IERC20(_pool.collateral).approve(address(_pool.optionVault), MAX_UINT256);\\n        IERC1155(address(_pool.optionVault)).setApprovalForAll(address(_pool.optionVault), true);\\n    }\\n\\n    /**\\n     * @notice add balance to range\\n     */\\n    function addBalance(\\n        PoolInfo storage _pool,\\n        uint32 _tickStart,\\n        uint32 _tickEnd,\\n        uint128 _mint\\n    ) external returns (uint128 depositedAmount) {\\n        require(_mint % (_tickEnd - _tickStart) == 0, \\\"PoolLib: mint is not multiples of range length\\\");\\n        uint128 mintPerRange = _mint / (_tickEnd - _tickStart);\\n\\n        for (uint32 i = _tickStart; i < _tickEnd; i++) {\\n            Tick storage tick = _pool.ticks[i];\\n            if (tick.supply > 0) {\\n                // We use roundUp here to make sure that the money going into the contract\\n                // is always equal or greater than the money going out.\\n                uint128 a = calSwapAmountForLPToken(tick, mintPerRange, true);\\n\\n                tick.balance += a;\\n                depositedAmount += a;\\n            } else {\\n                tick.balance += mintPerRange;\\n                depositedAmount += mintPerRange;\\n            }\\n            tick.supply += mintPerRange;\\n        }\\n    }\\n\\n    /**\\n     * @notice reserve withdrawal\\n     */\\n    function reserveWithdrawal(\\n        PoolInfo storage _pool,\\n        uint32 _tickStart,\\n        uint32 _tickEnd,\\n        uint128 _burn\\n    ) external {\\n        require(_burn % (_tickEnd - _tickStart) == 0, \\\"AMMLib: burn is not multiples of range length\\\");\\n        uint128 burnPerRange = _burn / (_tickEnd - _tickStart);\\n\\n        for (uint32 i = _tickStart; i < _tickEnd; i++) {\\n            Tick storage tick = _pool.ticks[i];\\n\\n            tick.burnReserved += burnPerRange;\\n        }\\n    }\\n\\n    /**\\n     * @notice remove balance from range\\n     */\\n    function removeBalance(\\n        PoolInfo storage _pool,\\n        uint32 _tickStart,\\n        uint32 _tickEnd,\\n        uint128 _burn\\n    ) external returns (uint128 withdrawnAmount) {\\n        require(_burn % (_tickEnd - _tickStart) == 0, \\\"PoolLib: burn is not multiples of range length\\\");\\n        uint128 burnPerRange = _burn / (_tickEnd - _tickStart);\\n\\n        for (uint32 i = _tickStart; i < _tickEnd; i++) {\\n            Tick storage tick = _pool.ticks[i];\\n\\n            uint128 substraction = removeBalancePerTick(tick, burnPerRange, tick.reservationForWithdrawal);\\n\\n            withdrawnAmount += substraction;\\n        }\\n    }\\n\\n    /**\\n     * @notice remove balance from reserved balance\\n     */\\n    function removeBalanceFromReservation(\\n        PoolInfo storage _pool,\\n        uint32 _tickStart,\\n        uint32 _tickEnd,\\n        uint128 _burn\\n    ) external returns (uint128 withdrawnAmount) {\\n        require(_burn % (_tickEnd - _tickStart) == 0, \\\"PoolLib: burn is not multiples of range length\\\");\\n        uint128 burnPerRange = _burn / (_tickEnd - _tickStart);\\n\\n        for (uint32 i = _tickStart; i < _tickEnd; i++) {\\n            Tick storage tick = _pool.ticks[i];\\n\\n            uint128 subWithdrawReserved = calSwapAmountForLPToken(tick, _burn, false);\\n            uint128 substraction = removeBalancePerTick(tick, burnPerRange, 0);\\n\\n            // decrease burn reserved\\n            tick.burnReserved -= burnPerRange;\\n            if (tick.reservationForWithdrawal > subWithdrawReserved) {\\n                tick.reservationForWithdrawal -= subWithdrawReserved;\\n            } else {\\n                tick.reservationForWithdrawal = 0;\\n            }\\n\\n            withdrawnAmount += substraction;\\n        }\\n    }\\n\\n    /**\\n     * @notice get premium\\n     * @param _seriesId option id\\n     * @param _amount amount to buy scaled by 1e8\\n     * @return premium total premium\\n     */\\n    function calculatePremium(\\n        PoolInfo storage _pool,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _spot,\\n        bool _isSelling\\n    ) external view returns (uint128 premium) {\\n        IOptionVault.OptionSeriesView memory optionSeries = _pool.optionVault.getOptionSeries(_seriesId);\\n\\n        TradeState memory step = initializeTradeState(_amount, address(0), optionSeries.iv);\\n\\n        // calculate premium\\n        premium = _calculatePremium(_pool, step, optionSeries, _spot, _isSelling);\\n    }\\n\\n    /**\\n     * @notice buy options\\n     * @param _seriesId option id\\n     * @param _amount amount to buy scaled by 1e8\\n     * @return premium total premium\\n     */\\n    function buy(\\n        PoolInfo storage _pool,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _spot,\\n        address _recipient\\n    ) external returns (uint128 premium) {\\n        IOptionVault.OptionSeriesView memory optionSeries = _pool.optionVault.getOptionSeries(_seriesId);\\n\\n        TradeState memory step = initializeTradeState(_amount, _recipient, optionSeries.iv);\\n\\n        // process buying\\n        (premium, step) = _buy(_pool, step, optionSeries, _spot);\\n\\n        // update IV\\n        setIV(_pool, _seriesId, step.currentIV);\\n\\n        _pool.lastBoughtTimestamp = uint64(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice sell options\\n     * @param _seriesId option id\\n     * @param _amount amount to sell scaled by 1e8\\n     * @return premium total premium\\n     */\\n    function sell(\\n        PoolInfo storage _pool,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _spot,\\n        address _seller\\n    ) external returns (uint128 premium) {\\n        IOptionVault.OptionSeriesView memory optionSeries = _pool.optionVault.getOptionSeries(_seriesId);\\n\\n        require(optionSeries.maturity >= 1 days, \\\"AMMLib: maturity must be greater than 1 days\\\");\\n\\n        TradeState memory step = initializeTradeState(_amount, _seller, optionSeries.iv);\\n\\n        // process selling\\n        (premium, step) = _pool._sell(step, optionSeries, _spot);\\n\\n        // update IV\\n        _pool.setIV(_seriesId, step.currentIV);\\n\\n        _pool.lastBoughtTimestamp = uint64(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice settle option serieses of an expiration\\n     * unlock all collateral in vaults and calculate unrealized profit and loss.\\n     */\\n    function settle(PoolInfo storage _pool, uint256 _expiryId) external returns (uint128 totalProtocolFee) {\\n        IOptionVault.Expiration memory expiration = _pool.optionVault.getExpiration(_expiryId);\\n\\n        uint32 minTickId = MAX_TICK;\\n        uint32 maxTickId = MIN_TICK;\\n\\n        for (uint256 i = 0; i < expiration.seriesIds.length; i++) {\\n            (uint32 _minTickId, uint32 _maxTickId) = settleInternal(_pool, expiration.seriesIds[i]);\\n\\n            if (minTickId > _minTickId) {\\n                minTickId = _minTickId;\\n            }\\n\\n            if (maxTickId < _maxTickId) {\\n                maxTickId = _maxTickId;\\n            }\\n        }\\n\\n        require(minTickId <= maxTickId, \\\"AMMLib: ticks are already settled\\\");\\n\\n        for (uint32 i = minTickId; i <= maxTickId; i++) {\\n            Tick storage tick = _pool.ticks[i];\\n\\n            totalProtocolFee += settleExpiryInternal(_pool, _expiryId, i, tick);\\n\\n            tick.balance += _pool.optionVault.settleVault(i, _expiryId);\\n\\n            // update LP token price\\n            tick.lastBalance = getPoolValueQuote(_pool, tick, i);\\n            tick.lastSupply = tick.supply;\\n\\n            // calculate withdrawal reserved amount\\n            tick.reservationForWithdrawal = PredyMath.mulDiv(\\n                tick.burnReserved,\\n                tick.lastBalance,\\n                tick.lastSupply,\\n                false\\n            );\\n        }\\n    }\\n\\n    function settleInternal(PoolInfo storage _pool, uint256 _seriesId)\\n        internal\\n        returns (uint32 minTickId, uint32 maxTickId)\\n    {\\n        LockedOptionStatePerTick[] memory lockedOptionStates = _pool.locked[_seriesId];\\n\\n        minTickId = MAX_TICK;\\n        maxTickId = MIN_TICK;\\n\\n        for (uint256 i = 0; i < lockedOptionStates.length; i++) {\\n            uint32 tickId = lockedOptionStates[i].tickId;\\n            Tick storage tick = _pool.ticks[tickId];\\n\\n            if (minTickId > tickId) {\\n                minTickId = tickId;\\n            }\\n\\n            if (maxTickId < tickId) {\\n                maxTickId = tickId;\\n            }\\n\\n            if (lockedOptionStates[i].isLong) {\\n                settleLongPositions(_pool, tick, lockedOptionStates[i], _seriesId);\\n            }\\n        }\\n\\n        delete _pool.locked[_seriesId];\\n    }\\n\\n    function settleExpiryInternal(\\n        PoolInfo storage _pool,\\n        uint256 _expiryId,\\n        uint32 _tickId,\\n        Tick storage _tick\\n    ) internal returns (uint128) {\\n        Profit memory profit = _pool.profits[_expiryId][_tickId];\\n\\n        uint128 cumulativeFee = profit.cumulativeFee;\\n        // calculate protocol fee\\n        uint128 protocolFee = cumulativeFee / _pool.configs[PROTOCOL_FEE_RATIO];\\n\\n        _tick.balance += (cumulativeFee - protocolFee);\\n        _tick.unrealizedPnL -= profit.unrealizedPnL;\\n\\n        return protocolFee;\\n    }\\n\\n    function settleLongPositions(\\n        PoolInfo storage _pool,\\n        Tick storage _tick,\\n        LockedOptionStatePerTick memory state,\\n        uint256 _seriesId\\n    ) internal {\\n        (, uint128 longSize) = _pool.optionVault.getPositionSize(state.tickId, _seriesId);\\n\\n        uint128 payout = _pool.optionVault.claim(_seriesId, longSize);\\n\\n        _tick.balance += payout;\\n    }\\n\\n    /**\\n     * @notice withdraw unrequired collaterals\\n     */\\n    function rebalanceCollateral(\\n        PoolInfo storage _pool,\\n        uint32 _tickId,\\n        uint256 _expiryId\\n    ) external {\\n        Tick storage tick = _pool.ticks[_tickId];\\n\\n        uint128 unrequiredCollateralAmount = calculateUnrequiredCollateral(_pool, _tickId, _expiryId);\\n\\n        if (unrequiredCollateralAmount == 0) {\\n            return;\\n        }\\n\\n        tick.balance += unrequiredCollateralAmount;\\n\\n        _pool.optionVault.withdraw(_tickId, _expiryId, unrequiredCollateralAmount);\\n    }\\n\\n    //////////////////////\\n    // Getter Functions //\\n    //////////////////////\\n\\n    function getMintAmount(\\n        PoolInfo storage _pool,\\n        uint32 _tickStart,\\n        uint32 _tickEnd,\\n        uint128 _amount\\n    ) external view returns (uint128) {\\n        uint128 share;\\n        uint128 range = _tickEnd - _tickStart;\\n        for (uint32 i = _tickStart; i < _tickEnd; i++) {\\n            Tick memory tick = _pool.ticks[i];\\n            if (tick.lastSupply > 0) {\\n                share += (1e6 * tick.lastBalance) / tick.lastSupply;\\n            } else {\\n                share += 1e6;\\n            }\\n        }\\n        return PredyMath.mulDiv(_amount * 1e6, range, share, false);\\n    }\\n\\n    function getWithdrawableAmount(\\n        PoolInfo storage _pool,\\n        uint32 _tickStart,\\n        uint32 _tickEnd,\\n        uint128 _burn\\n    ) external view returns (uint128 withdrawableAmount) {\\n        require(_burn % (_tickEnd - _tickStart) == 0, \\\"PoolLib: burn is not multiples of range length\\\");\\n        uint128 burnPerRange = _burn / (_tickEnd - _tickStart);\\n\\n        for (uint32 i = _tickStart; i < _tickEnd; i++) {\\n            Tick memory tick = _pool.ticks[i];\\n            withdrawableAmount += calSwapAmountForLPToken(tick, burnPerRange, false);\\n        }\\n    }\\n\\n    /**\\n     * @notice get tick cumulative of seconds per liquidity\\n     * @param _ticks ticks\\n     * @param _tickLower lower tick to get seconds per liquidity\\n     * @param _tickUpper upper tick to get seconds per liquidity\\n     * @return secondsPerLiquidity scaled by 1e8\\n     */\\n    function getSecondsPerLiquidity(\\n        mapping(uint32 => Tick) storage _ticks,\\n        uint32 _tickLower,\\n        uint32 _tickUpper\\n    ) external view returns (uint128) {\\n        uint128 secondsPerLiquidity;\\n        for (uint32 i = _tickLower; i < _tickUpper; i++) {\\n            Tick memory tick = _ticks[i];\\n            secondsPerLiquidity += tick.secondsPerLiquidity;\\n        }\\n        return secondsPerLiquidity * (_tickUpper - _tickLower);\\n    }\\n\\n    ///////////////////////\\n    // Private Functions //\\n    ///////////////////////\\n\\n    /**\\n     * @notice remove balance from a tick\\n     */\\n    function removeBalancePerTick(\\n        Tick storage _tick,\\n        uint128 _burn,\\n        uint128 _reservedAmount\\n    ) internal returns (uint128) {\\n        // decrease balance\\n        uint128 substraction = calSwapAmountForLPToken(_tick, _burn, false);\\n\\n        require(_tick.balance >= _reservedAmount + substraction, \\\"AMMLib: no enough balance to withdraw\\\");\\n        _tick.balance -= substraction;\\n\\n        // decrease supply\\n        require(_tick.supply >= _burn, \\\"AMMLib: burn is too big\\\");\\n        _tick.supply -= _burn;\\n\\n        return substraction;\\n    }\\n\\n    function updateSecondsPerLiquidity(PoolInfo storage _pool, uint32 _currentTickId) internal {\\n        Tick storage state = _pool.ticks[_currentTickId];\\n        state.updateSecondsPerLiquidity(1e8 * getElapsedTime(_pool.lastBoughtTimestamp));\\n    }\\n\\n    /**\\n     * @notice update seconds per liquidity\\n     * secondsPerLiquidity is scaled by 1e8\\n     * @param _tick a tick\\n     * @param _seconds seconds scaled by 1e8\\n     */\\n    function updateSecondsPerLiquidity(Tick storage _tick, uint128 _seconds) internal {\\n        if (_tick.supply > 0) {\\n            _tick.secondsPerLiquidity += (1e8 * _seconds) / (_tick.supply);\\n        }\\n    }\\n\\n    /**\\n     * @notice internal function of calculating premium\\n     */\\n    function _calculatePremium(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint128 _spot,\\n        bool _isSelling\\n    ) internal view returns (uint128 totalPremium) {\\n        while (_step.remain != 0) {\\n            uint128 premium;\\n            uint128 fee;\\n            bool isContinue;\\n\\n            if (_isSelling) {\\n                (premium, isContinue) = calculateTradeStateToSell(_pool, _spot, _series, _step);\\n            } else {\\n                (premium, fee, isContinue) = calculateTradeStateToBuy(_pool, _spot, _series, _step);\\n            }\\n\\n            if (isContinue) {\\n                continue;\\n            }\\n\\n            totalPremium += premium + fee;\\n\\n            _step.currentTick = _step.nextTick;\\n        }\\n        return totalPremium;\\n    }\\n\\n    /**\\n     * @notice process buying options\\n     * calculate premium and trade state and update ticks\\n     */\\n    function _buy(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint128 _spot\\n    ) internal returns (uint128 totalPremium, TradeState memory) {\\n        updateSecondsPerLiquidity(_pool, _step.currentTick);\\n\\n        while (_step.remain != 0) {\\n            _step.isTickLong = getIsTickLongFlag(_pool, _series.seriesId, _step.currentTick, false);\\n\\n            (uint128 premium, uint128 fee, bool isContinue) = calculateTradeStateToBuy(_pool, _spot, _series, _step);\\n            if (isContinue) {\\n                continue;\\n            }\\n            totalPremium += premium + fee;\\n\\n            if (_step.isTickLong) {\\n                // remove long\\n                removeLongPosition(_pool, _step, _series.expiryId, _series.seriesId, premium, fee);\\n            } else {\\n                // add short\\n                addShortPosition(_pool, _step, _series, premium, fee);\\n            }\\n\\n            _step.currentTick = _step.nextTick;\\n        }\\n        return (totalPremium, _step);\\n    }\\n\\n    /**\\n     * @notice process buying options for a tick\\n     * calculate available size of a tick, next IV and premium\\n     */\\n    function calculateTradeStateToBuy(\\n        PoolInfo storage _pool,\\n        uint128 _spotPrice,\\n        IOptionVault.OptionSeriesView memory _series,\\n        TradeState memory _step\\n    )\\n        internal\\n        view\\n        returns (\\n            uint128 premium,\\n            uint128 fee,\\n            bool\\n        )\\n    {\\n        require(_step.currentTick < MAX_TICK, \\\"AMMLib: tick is too large\\\");\\n\\n        Tick memory state = _pool.ticks[_step.currentTick];\\n        uint128 upper = tick2pos(_step.currentTick + 1);\\n\\n        if (\\n            state.balance <=\\n            getUnavailableCollateral(state) + _pool.lockedAmounts[_step.currentTick][_series.seriesId][0] ||\\n            upper <= _step.currentIV\\n        ) {\\n            _step.currentTick += 1;\\n            return (0, 0, true);\\n        }\\n        {\\n            uint128 lower = tick2pos(_step.currentTick);\\n            if (_step.currentIV < lower) {\\n                _step.currentIV = lower;\\n            }\\n        }\\n        uint128 x1;\\n        {\\n            // calculate available size\\n            uint128 available = (state.balance -\\n                getUnavailableCollateral(state) -\\n                _pool.lockedAmounts[_step.currentTick][_series.seriesId][0]) / 2;\\n            uint128 ivMove;\\n            (available, ivMove) = calAvailableSizeForBuying(\\n                _pool,\\n                available,\\n                _series,\\n                _step.currentTick,\\n                upper - _step.currentIV\\n            );\\n            if (available >= _step.remain) {\\n                _step.stepAmount = _step.remain;\\n                _step.remain = 0;\\n                _step.nextTick = _step.currentTick;\\n            } else {\\n                _step.stepAmount = available;\\n                // _step.stepAmount must be less than _step.remain\\n                _step.remain -= _step.stepAmount;\\n                _step.nextTick = _step.currentTick + 1;\\n            }\\n\\n            x1 = _step.currentIV + PredyMath.mulDiv(ivMove, _step.stepAmount, 1e12, true);\\n        }\\n\\n        premium = calculatePrice(_pool, _spotPrice, _series, _step.currentIV, x1);\\n        fee = calculateSpread(_pool, _step.stepAmount, _spotPrice, premium);\\n        premium = (premium * _step.stepAmount) / 1e10;\\n\\n        _step.currentIV = x1;\\n        _step.pricePerSize = (1e12 * (premium + fee)) / _step.stepAmount;\\n\\n        premium = checkPricePerSize(_pool, _step, _series.seriesId, false, premium + fee) - fee;\\n\\n        return (premium, fee, false);\\n    }\\n\\n    /**\\n     * @notice sell options\\n     * trader can only sell to close if the same option series is shorted.\\n     * @param _pool option id\\n     * @param _step step information\\n     * @param _series option\\n     * @param _spot spot price\\n     * @return totalPremium total premium\\n     */\\n    function _sell(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint128 _spot\\n    ) internal returns (uint128 totalPremium, TradeState memory) {\\n        updateSecondsPerLiquidity(_pool, _step.currentTick);\\n\\n        while (_step.remain != 0) {\\n            (uint128 premium, bool isContinue) = calculateTradeStateToSell(_pool, _spot, _series, _step);\\n            if (isContinue) {\\n                continue;\\n            }\\n            totalPremium += premium;\\n\\n            if (_step.isTickLong) {\\n                // add long\\n                addLongPosition(_pool, _step, _series.expiryId, _series.seriesId, premium);\\n            } else {\\n                // remove short\\n                removeShortPosition(_pool, _step, _series, premium);\\n            }\\n\\n            _step.currentTick = _step.nextTick;\\n        }\\n\\n        require(_step.remain == 0, \\\"AMMLib: no enough available balance\\\");\\n\\n        return (totalPremium, _step);\\n    }\\n\\n    function calculateTradeStateToSell(\\n        PoolInfo storage _pool,\\n        uint128 _spotPrice,\\n        IOptionVault.OptionSeriesView memory _series,\\n        TradeState memory _step\\n    ) internal view returns (uint128 totalPremium, bool) {\\n        _step.isTickLong = getIsTickLongFlag(_pool, _series.seriesId, _step.currentTick, true);\\n\\n        Tick memory state = _pool.ticks[_step.currentTick];\\n        uint128 lower = tick2pos(_step.currentTick);\\n\\n        if (\\n            state.balance <=\\n            getUnavailableCollateral(state) + _pool.lockedAmounts[_step.currentTick][_series.seriesId][1] ||\\n            _step.currentIV <= lower\\n        ) {\\n            require(_step.currentTick > MIN_TICK, \\\"AMMLib: tick is too small\\\");\\n            _step.currentTick -= 1;\\n            return (0, true);\\n        }\\n        {\\n            uint128 upper = tick2pos(_step.currentTick + 1);\\n            if (_step.currentIV > upper) {\\n                _step.currentIV = upper;\\n            }\\n        }\\n\\n        // calculate start IV and end IV\\n        uint128 x1 = _step.currentIV;\\n        {\\n            (uint128 available, uint128 ivMove) = calAvailableSizeForSelling(\\n                _pool,\\n                (state.balance -\\n                    getUnavailableCollateral(state) -\\n                    _pool.lockedAmounts[_step.currentTick][_series.seriesId][1]) / 2,\\n                _spotPrice,\\n                _series,\\n                lower,\\n                _step.currentIV,\\n                _step.currentTick\\n            );\\n\\n            // available must be greater than 0\\n            if (available >= _step.remain) {\\n                _step.stepAmount = _step.remain;\\n                _step.remain = 0;\\n                _step.nextTick = _step.currentTick;\\n            } else {\\n                _step.stepAmount = available;\\n                // _step.stepAmount must be less than _step.remain\\n                _step.remain -= _step.stepAmount;\\n                require(_step.currentTick > MIN_TICK, \\\"AMMLib: tick is too small\\\");\\n                _step.nextTick = _step.currentTick - 1;\\n            }\\n\\n            _step.currentIV -= PredyMath.mulDiv(_step.stepAmount, ivMove, 1e12, true);\\n        }\\n        {\\n            uint128 premium = calculatePrice(_pool, _spotPrice, _series, _step.currentIV, x1);\\n            premium = premium2c(premium, _step.stepAmount);\\n\\n            totalPremium += premium;\\n        }\\n\\n        _step.pricePerSize = (1e12 * totalPremium) / _step.stepAmount;\\n\\n        totalPremium = checkPricePerSize(_pool, _step, _series.seriesId, true, totalPremium);\\n\\n        return (totalPremium, false);\\n    }\\n\\n    /**\\n     * @notice check lastPricePerSize to avoid sandwich attack.\\n     * compare lastPricePerSize and current pricePerSize, and re-calculate premium if needed.\\n     */\\n    function checkPricePerSize(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        uint256 _seriesId,\\n        bool _isSelling,\\n        uint128 _price\\n    ) internal view returns (uint128 _priceAfter) {\\n        _priceAfter = _price;\\n\\n        (LockedOptionStatePerTick memory locked, ) = getLockedOptionStatePerTick(_pool, _seriesId, _step.currentTick);\\n\\n        if (locked.lastPricePerSize == 0) {\\n            return _price;\\n        }\\n\\n        // premium never re-calculated after SAFETY_PERIOD\\n        if (locked.tradeTime + SAFETY_PERIOD <= block.timestamp) {\\n            return _price;\\n        }\\n\\n        if (_isSelling) {\\n            // sell premium must be less than last buy's\\n            if (_step.pricePerSize > locked.lastPricePerSize) {\\n                _priceAfter = (locked.lastPricePerSize * _step.stepAmount) / 1e12;\\n                _step.pricePerSize = locked.lastPricePerSize;\\n            }\\n        } else {\\n            // buy premium must be greater than last sell's\\n            if (_step.pricePerSize < locked.lastPricePerSize) {\\n                _priceAfter = (locked.lastPricePerSize * _step.stepAmount) / 1e12;\\n                _step.pricePerSize = locked.lastPricePerSize;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice add long position to pool\\n     */\\n    function addLongPosition(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _premium\\n    ) internal {\\n        uint32 tickId = _step.currentTick;\\n\\n        Tick storage tick = _pool.ticks[tickId];\\n\\n        // deposit USDC to the vault for delta hedge\\n        uint128 lockAmount = _pool.optionVault.calRequiredMarginForASeries(\\n            _seriesId,\\n            -_step.stepAmount.toInt128(),\\n            IOptionVault.MarginLevel.Safe\\n        );\\n\\n        _pool.optionVault.deposit(tickId, _expiryId, lockAmount);\\n\\n        // decrease premium to pay\\n        require(tick.balance >= (_premium + lockAmount), \\\"AMMLib: no enough balance\\\");\\n        tick.balance -= (_premium + lockAmount);\\n\\n        // add unrealized loss\\n        int128 premium = _premium.toInt128();\\n\\n        tick.unrealizedPnL -= premium;\\n        _pool.profits[_expiryId][tickId].unrealizedPnL -= premium;\\n\\n        // additional locked amount\\n        _pool.lockedAmounts[tickId][_seriesId][1] += _premium;\\n\\n        // add options to the account\\n        _pool.optionVault.addLong(tickId, _expiryId, _seriesId, _step.stepAmount);\\n\\n        // add series specific state\\n        for (uint256 i = 0; i < _pool.locked[_seriesId].length; i++) {\\n            LockedOptionStatePerTick storage locked = _pool.locked[_seriesId][i];\\n            if (locked.tickId == tickId) {\\n                require(locked.isLong);\\n\\n                // update the last price per size\\n                locked.tradeTime = uint128(block.timestamp);\\n                locked.lastPricePerSize = _step.pricePerSize;\\n                return;\\n            }\\n        }\\n\\n        // if there is no state, add new\\n        _pool.locked[_seriesId].push(\\n            LockedOptionStatePerTick(tickId, true, _step.pricePerSize, uint128(block.timestamp))\\n        );\\n    }\\n\\n    /**\\n     * @notice remove long position from pool\\n     */\\n    function removeLongPosition(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _premium,\\n        uint128 _fee\\n    ) internal {\\n        uint32 tickId = _step.currentTick;\\n\\n        Tick storage tick = _pool.ticks[tickId];\\n\\n        // add received premium to balance\\n        tick.balance += _premium;\\n\\n        // add unrealized profit from premium\\n        int128 premium = _premium.toInt128();\\n\\n        tick.unrealizedPnL += premium;\\n\\n        _pool.profits[_expiryId][tickId].unrealizedPnL += premium;\\n        _pool.profits[_expiryId][tickId].cumulativeFee += _fee;\\n\\n        // remove options from the account\\n        _pool.optionVault.removeLong(tickId, _expiryId, _seriesId, _step.stepAmount);\\n\\n        // calculate unrequired collateral and withdraw the collateral\\n        uint128 unrequiredCollateral = _pool.optionVault.closeShortPosition(tickId, _seriesId, 0, 1e6);\\n\\n        tick.balance += unrequiredCollateral;\\n\\n        // decrease additional locked premium\\n        if (_pool.lockedAmounts[tickId][_seriesId][1] > _premium) {\\n            _pool.lockedAmounts[tickId][_seriesId][1] -= _premium;\\n        } else {\\n            _pool.lockedAmounts[tickId][_seriesId][1] = 0;\\n        }\\n\\n        // transfer options to the trader\\n        ERC1155(address(_pool.optionVault)).safeTransferFrom(\\n            address(this),\\n            _step.trader,\\n            _seriesId,\\n            _step.stepAmount,\\n            \\\"\\\"\\n        );\\n\\n        // update series specific state\\n        for (uint256 i = 0; i < _pool.locked[_seriesId].length; i++) {\\n            LockedOptionStatePerTick storage locked = _pool.locked[_seriesId][i];\\n            if (locked.tickId == tickId) {\\n                require(locked.isLong);\\n\\n                // update the last price per size\\n                locked.tradeTime = uint128(block.timestamp);\\n                locked.lastPricePerSize = _step.pricePerSize;\\n                return;\\n            }\\n        }\\n\\n        // if there is no series state, revert\\n        revert(\\\"AMMLib: series state not found\\\");\\n    }\\n\\n    /**\\n     * @notice add short position to pool\\n     */\\n    function addShortPosition(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint128 _premium,\\n        uint128 _fee\\n    ) internal {\\n        uint32 tickId = _step.currentTick;\\n\\n        // deposit 100% of IM collateral and premium, and write options(transfer options to the trader)\\n        uint128 lockAmount = _pool.optionVault.depositAndWrite(\\n            tickId,\\n            _series.seriesId,\\n            1e6,\\n            _step.stepAmount,\\n            _step.trader\\n        );\\n\\n        require(lockAmount >= _premium, \\\"AMMLib: lockAmount must be greater than premium\\\");\\n\\n        Tick storage tick = _pool.ticks[tickId];\\n\\n        // decrease lockAmount from pool balance\\n        require(tick.balance >= lockAmount + getUnavailableCollateral(tick), \\\"AMMLib: enough balance to lock\\\");\\n        tick.balance -= lockAmount - _premium;\\n\\n        // add unrealized profit from premium\\n        int128 premium = _premium.toInt128();\\n\\n        tick.unrealizedPnL += premium;\\n\\n        _pool.profits[_series.expiryId][tickId].unrealizedPnL += premium;\\n        _pool.profits[_series.expiryId][tickId].cumulativeFee += _fee;\\n\\n        // calculate additional lock amount\\n        _pool.lockedAmounts[tickId][_series.seriesId][0] += lockAmount;\\n\\n        // update series specific state(premium and fee)\\n        for (uint256 i = 0; i < _pool.locked[_series.seriesId].length; i++) {\\n            LockedOptionStatePerTick storage locked = _pool.locked[_series.seriesId][i];\\n            if (locked.tickId == tickId) {\\n                require(!locked.isLong);\\n\\n                // update the last price per size\\n                locked.tradeTime = uint128(block.timestamp);\\n                locked.lastPricePerSize = _step.pricePerSize;\\n                return;\\n            }\\n        }\\n\\n        // if there is no series state, create new\\n        _pool.locked[_series.seriesId].push(\\n            LockedOptionStatePerTick(tickId, false, _step.pricePerSize, uint128(block.timestamp))\\n        );\\n    }\\n\\n    /**\\n     * @notice remove short position from pool\\n     */\\n    function removeShortPosition(\\n        PoolInfo storage _pool,\\n        TradeState memory _step,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint128 _premium\\n    ) internal {\\n        uint32 tickId = _step.currentTick;\\n\\n        // burn options from the account\\n        // calculate unrequired collateral and withdraw the collateral\\n        uint128 unrequiredCollateral = _pool.optionVault.closeShortPosition(\\n            tickId,\\n            _series.seriesId,\\n            _step.stepAmount,\\n            1e6\\n        );\\n\\n        Tick storage tick = _pool.ticks[tickId];\\n\\n        uint128 balance = tick.balance;\\n\\n        // increase withdrawn collateral to balance\\n        balance += unrequiredCollateral;\\n\\n        // decrease premium to pay\\n        balance -= _premium;\\n\\n        tick.balance = balance;\\n\\n        // add unrealized loss\\n        int128 premium = _premium.toInt128();\\n\\n        tick.unrealizedPnL -= premium;\\n\\n        _pool.profits[_series.expiryId][tickId].unrealizedPnL -= premium;\\n\\n        // additional locked amount\\n        if (_pool.lockedAmounts[tickId][_series.seriesId][0] > unrequiredCollateral) {\\n            _pool.lockedAmounts[tickId][_series.seriesId][0] -= unrequiredCollateral;\\n        } else {\\n            _pool.lockedAmounts[tickId][_series.seriesId][0] = 0;\\n        }\\n\\n        // update series specific state\\n        for (uint256 i = 0; i < _pool.locked[_series.seriesId].length; i++) {\\n            LockedOptionStatePerTick storage locked = _pool.locked[_series.seriesId][i];\\n            if (locked.tickId == tickId) {\\n                require(!locked.isLong);\\n\\n                // update the last price per size\\n                locked.tradeTime = uint128(block.timestamp);\\n                locked.lastPricePerSize = _step.pricePerSize;\\n                return;\\n            }\\n        }\\n\\n        // if there is no series state, revert\\n        revert(\\\"AMMLib: series state not found\\\");\\n    }\\n\\n    function calculateUnrequiredCollateral(\\n        PoolInfo storage _pool,\\n        uint32 _tickId,\\n        uint256 _expiryId\\n    ) internal view returns (uint128 amount) {\\n        uint128 accountCollateral = _pool.optionVault.getVault(_tickId, _expiryId).collateral;\\n\\n        uint128 requiredCollateral = getSafeMargin(_pool, _tickId, _expiryId);\\n\\n        if (requiredCollateral < accountCollateral) {\\n            return accountCollateral - requiredCollateral;\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice get pool value quote\\n     * returns the sum of pool value and hedged value\\n     */\\n    function getPoolValueQuote(\\n        PoolInfo storage _pool,\\n        Tick memory _tick,\\n        uint32 _tickId\\n    ) internal view returns (uint128 total) {\\n        uint128 b = _tick.balance + _pool.optionVault.getCollateralValueQuote(_tickId);\\n\\n        if (_tick.unrealizedPnL > 0) {\\n            return b - uint128(_tick.unrealizedPnL);\\n        } else {\\n            return b + uint128(-_tick.unrealizedPnL);\\n        }\\n    }\\n\\n    function calSwapAmountForLPToken(\\n        Tick memory _tick,\\n        uint128 _amount,\\n        bool _isDeposit\\n    ) internal pure returns (uint128) {\\n        if (_tick.lastBalance == 0 || _tick.lastSupply == 0) {\\n            return _amount;\\n        } else {\\n            return PredyMath.mulDiv(_amount, _tick.lastBalance, _tick.lastSupply, _isDeposit);\\n        }\\n    }\\n\\n    function calculatePrice(\\n        PoolInfo storage _pool,\\n        uint128 _spot,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint128 _x0,\\n        uint128 _x1\\n    ) internal view returns (uint128) {\\n        uint256 p = PriceCalculator.calculatePrice2(\\n            _spot,\\n            _series.strike,\\n            _series.maturity,\\n            _x0,\\n            _x1,\\n            _series.isPut,\\n            _pool.configs[MIN_DELTA]\\n        );\\n        return uint128(p);\\n    }\\n\\n    /**\\n     * @notice calculating spread of premium.\\n     * spread is 0.4% of size and 1% of premium\\n     * @param _amount option size scaled by 1e8\\n     * @param _spot oracle price scaled by 1e8\\n     * @param _premium premium scaled by 1e8\\n     * @return fee scaled by 1e6\\n     */\\n    function calculateSpread(\\n        PoolInfo storage _pool,\\n        uint128 _amount,\\n        uint128 _spot,\\n        uint128 _premium\\n    ) internal view returns (uint128) {\\n        return (_amount * (_spot / _pool.configs[BASE_SPREAD] + _premium / 100)) / (1e10);\\n    }\\n\\n    /**\\n     * @notice initialize trade state\\n     */\\n    function initializeTradeState(\\n        uint128 _amount,\\n        address _trader,\\n        uint64 _iv\\n    ) internal pure returns (TradeState memory) {\\n        uint128 currentIV = _iv;\\n        uint32 tick = uint32(currentIV / 1e7);\\n\\n        return TradeState(tick, tick, 0, _amount, currentIV, _trader, false, 0);\\n    }\\n\\n    function getIsTickLongFlag(\\n        PoolInfo storage _pool,\\n        uint256 _seriesId,\\n        uint32 _tickId,\\n        bool _isSelling\\n    ) internal view returns (bool) {\\n        (LockedOptionStatePerTick memory locked, bool exists) = getLockedOptionStatePerTick(_pool, _seriesId, _tickId);\\n        return exists ? locked.isLong : _isSelling;\\n    }\\n\\n    /**\\n     * @notice calculate available size for buying\\n     * if tick is long, available size is same as the size of tick's long position.\\n     * if tick is short, available size is (balance / collateral to lock).\\n     * @return (available size, ivMove)\\n     *  available size is the size that trader can buy\\n     *  ivMove is iv changes per size in this trade\\n     */\\n    function calAvailableSizeForBuying(\\n        PoolInfo storage _pool,\\n        uint128 _c,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint32 _tickId,\\n        uint128 _ivRange\\n    ) internal view returns (uint128, uint128) {\\n        (LockedOptionStatePerTick memory locked, bool exists) = getLockedOptionStatePerTick(\\n            _pool,\\n            _series.seriesId,\\n            _tickId\\n        );\\n\\n        if (exists && locked.isLong) {\\n            // get pool's long position size\\n            (, uint128 longSize) = _pool.optionVault.getPositionSize(_tickId, _series.seriesId);\\n\\n            return (longSize, (1e12 * _ivRange) / longSize);\\n        } else {\\n            uint128 safeMargin = _pool.optionVault.calRequiredMarginForASeries(\\n                _series.seriesId,\\n                1e8,\\n                IOptionVault.MarginLevel.Safe\\n            );\\n            uint128 availableSize = (1e8 * _c) / safeMargin;\\n\\n            // ivMove is scaled by 1e12\\n            uint128 ivMove = (1e12 * _ivRange) / availableSize;\\n\\n            return (availableSize, ivMove);\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate available size for selling\\n     * if tick is long, available size is (balance / (premium to pay + collateral to lock)).\\n     * if tick is short, available size is same as the size of tick's short position.\\n     * @return (available size, ivMove)\\n     *  available size is the size that trader can sell\\n     *  ivMove is iv changes per size in this trade\\n     */\\n    function calAvailableSizeForSelling(\\n        PoolInfo storage _pool,\\n        uint128 _c,\\n        uint128 _spot,\\n        IOptionVault.OptionSeriesView memory _series,\\n        uint128 _iv0,\\n        uint128 _iv1,\\n        uint32 _tickId\\n    ) internal view returns (uint128, uint128) {\\n        (LockedOptionStatePerTick memory locked, bool exists) = getLockedOptionStatePerTick(\\n            _pool,\\n            _series.seriesId,\\n            _tickId\\n        );\\n\\n        uint128 ivRange = 1e12 * (_iv1 - _iv0);\\n\\n        if (!exists || locked.isLong) {\\n            // pricePerAmount is estimation price when IV moves from lower to _step.position (price/amount)\\n            uint128 availableSize;\\n            {\\n                uint128 pricePerAmount = calculatePrice(_pool, _spot, _series, _iv0, _iv1);\\n                uint128 safeMargin = _pool.optionVault.calRequiredMarginForASeries(\\n                    _series.seriesId,\\n                    -1e8,\\n                    IOptionVault.MarginLevel.Safe\\n                );\\n\\n                availableSize = (_c * 1e10) / (pricePerAmount + 1e2 * safeMargin);\\n            }\\n\\n            uint128 ivMove = ivRange / availableSize;\\n\\n            return (availableSize, ivMove);\\n        } else {\\n            // get pool's short position size\\n            uint128 availableSize = getVaultSize(_pool, _tickId, _series.seriesId);\\n            return (availableSize, ivRange / availableSize);\\n        }\\n    }\\n\\n    function getVaultSize(\\n        PoolInfo storage _pool,\\n        uint32 _tickId,\\n        uint256 _seriesId\\n    ) internal view returns (uint128) {\\n        (uint128 shortSize, ) = _pool.optionVault.getPositionSize(_tickId, _seriesId);\\n        return shortSize;\\n    }\\n\\n    function getUnavailableCollateral(Tick memory _tick) internal pure returns (uint128) {\\n        return _tick.reservationForWithdrawal;\\n    }\\n\\n    /**\\n     * @notice convert premium to amount of collateral\\n     * @param _premium premium\\n     * @param _size size of option\\n     */\\n    function premium2c(uint128 _premium, uint128 _size) internal pure returns (uint128) {\\n        uint128 r = (_premium * _size) / 1e8;\\n        return r / 1e2;\\n    }\\n\\n    function getLockedOptionStatePerTick(\\n        PoolInfo storage _pool,\\n        uint256 _seriesId,\\n        uint32 _tickId\\n    ) internal view returns (LockedOptionStatePerTick memory, bool exists) {\\n        for (uint256 i = 0; i < _pool.locked[_seriesId].length; i++) {\\n            if (_pool.locked[_seriesId][i].tickId == _tickId) {\\n                return (_pool.locked[_seriesId][i], true);\\n            }\\n        }\\n\\n        return (LockedOptionStatePerTick(0, false, 0, 0), false);\\n    }\\n\\n    /**\\n     * @notice set pool IV\\n     */\\n    function setIV(\\n        PoolInfo storage _poolInfo,\\n        uint256 _seriesId,\\n        uint128 _iv\\n    ) internal {\\n        _poolInfo.optionVault.setIV(_seriesId, _iv);\\n    }\\n\\n    /**\\n     * @notice get elapsed time from latest bought\\n     */\\n    function getElapsedTime(uint128 _lastBoughtTimestamp) internal view returns (uint128) {\\n        return uint128(block.timestamp) - _lastBoughtTimestamp;\\n    }\\n\\n    /**\\n     * @notice calculate safe collateral\\n     */\\n    function getSafeMargin(\\n        PoolInfo storage _pool,\\n        uint32 _tickId,\\n        uint256 _expiryId\\n    ) internal view returns (uint128) {\\n        return _pool.optionVault.getRequiredMargin(_tickId, _expiryId, IOptionVault.MarginLevel.Safe);\\n    }\\n\\n    function validateTick(uint32 _tickId) public pure {\\n        require(MIN_TICK <= _tickId, \\\"AMM: start must be greater than MIN\\\");\\n        require(_tickId < MAX_TICK, \\\"AMM: tick must be less than MAX\\\");\\n    }\\n\\n    function validateRange(uint32 _s, uint32 _e) external pure {\\n        require(MIN_TICK <= _s, \\\"AMM: start must be greater than MIN\\\");\\n        require(_s < _e, \\\"AMM: end must be greater than start\\\");\\n        require(_s < MAX_TICK && _e <= MAX_TICK, \\\"AMM: tick must be less than MAX\\\");\\n        require(_s > 0 && _e > 1, \\\"AMM: tick must be greater than 1\\\");\\n    }\\n\\n    function tick2pos(uint32 _tick) internal pure returns (uint128) {\\n        if (_tick >= MAX_TICK) {\\n            return 1e7 * 50;\\n        } else {\\n            return 1e7 * _tick;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @notice chainlink price oracle.\\n * This is the contract to fix the price at the nearest time after expiry.\\n */\\ncontract PriceOracle is Ownable {\\n    /// @dev expiry price with timestamp\\n    struct ExpiryPrice {\\n        uint256 price;\\n        uint256 timestamp;\\n    }\\n\\n    /// @dev chainlink aggregator address of the underlying asset price\\n    mapping(address => AggregatorV3Interface) aggregators;\\n\\n    /// @dev aggregator address => timestamp => expiry price\\n    mapping(address => mapping(uint256 => ExpiryPrice)) internal expiryPrices;\\n\\n    event ExpiryPriceUpdated(address aggregator, uint256 expiry, uint256 price);\\n\\n    uint256 public constant DISPUTE_PERIOD = 2 hours;\\n\\n    /**\\n     * @notice set aggregator\\n     * only owner can set new aggregator\\n     */\\n    function setAggregator(address _aggregatorAddress) external onlyOwner {\\n        require(address(aggregators[_aggregatorAddress]) == address(0));\\n        aggregators[_aggregatorAddress] = AggregatorV3Interface(_aggregatorAddress);\\n    }\\n\\n    /**\\n     * @notice set expiry price\\n     * anyone can set price if the price has not been setted.\\n     * Also timestamp must be later than expiration.\\n     */\\n    function setExpiryPrice(address _aggregator, uint256 _expiryTimestamp) external {\\n        (uint256 price, uint256 timestamp) = getPrice(_aggregator);\\n\\n        require(_expiryTimestamp < timestamp, \\\"PriceOracle: price timestamp must be later than expiry\\\");\\n\\n        ExpiryPrice storage expiryPrice = expiryPrices[_aggregator][_expiryTimestamp];\\n\\n        require(expiryPrice.timestamp == 0, \\\"PriceOracle: already setted\\\");\\n\\n        expiryPrice.price = price;\\n        expiryPrice.timestamp = timestamp;\\n\\n        emit ExpiryPriceUpdated(_aggregator, _expiryTimestamp, price);\\n    }\\n\\n    /**\\n     * @notice update expiry price\\n     * anyone can update price if the price has not been setted\\n     * or if new price's timestamp is earlier than previous one.\\n     * Also timestamp must be later than expiration.\\n     */\\n    function updateExpiryPrice(\\n        address _aggregator,\\n        uint256 _expiryTimestamp,\\n        uint80 _roundId\\n    ) external {\\n        (uint256 price, uint256 timestamp) = getHistoricalPrice(_aggregator, _roundId);\\n\\n        require(_expiryTimestamp < timestamp, \\\"PriceOracle: price timestamp must be later than expiry\\\");\\n\\n        ExpiryPrice storage expiryPrice = expiryPrices[_aggregator][_expiryTimestamp];\\n\\n        require(\\n            expiryPrice.timestamp == 0 || expiryPrice.timestamp > timestamp,\\n            \\\"PriceOracle: new price's timestamp must be close to expiry\\\"\\n        );\\n\\n        expiryPrice.price = price;\\n        expiryPrice.timestamp = timestamp;\\n\\n        emit ExpiryPriceUpdated(_aggregator, _expiryTimestamp, price);\\n    }\\n\\n    /**\\n     * @notice get price for an expiration\\n     * @return price price scaled by 1e8\\n     * @return _isFinalized returns true if price has been finalized, if not returns false\\n     */\\n    function getExpiryPrice(address _aggregator, uint256 _expiryTimestamp)\\n        external\\n        view\\n        returns (uint256 price, bool _isFinalized)\\n    {\\n        price = expiryPrices[_aggregator][_expiryTimestamp].price;\\n        _isFinalized = isFinalized(_aggregator, _expiryTimestamp);\\n    }\\n\\n    /**\\n     * @notice return flag if price is finalized or not\\n     * true if dispute period has been passed and price has been setted more than once\\n     */\\n    function isFinalized(address _aggregator, uint256 _expiryTimestamp) internal view returns (bool) {\\n        return\\n            (_expiryTimestamp + DISPUTE_PERIOD < block.timestamp) &&\\n            expiryPrices[_aggregator][_expiryTimestamp].timestamp != 0;\\n    }\\n\\n    /**\\n     * @notice get price scaled by 1e8\\n     */\\n    function getPrice(address _aggregatorAddress) public view returns (uint256, uint256) {\\n        (, int256 answer, , uint256 roundTimestamp, ) = aggregators[_aggregatorAddress].latestRoundData();\\n\\n        require(answer > 0, \\\"PriceOracle: price is lower than 0\\\");\\n\\n        return (uint256(answer), roundTimestamp);\\n    }\\n\\n    function getHistoricalPrice(address _aggregatorAddress, uint80 _roundId) public view returns (uint256, uint256) {\\n        (, int256 answer, , uint256 roundTimestamp, ) = aggregators[_aggregatorAddress].getRoundData(_roundId);\\n\\n        require(answer > 0, \\\"PriceOracle: price is lower than 0\\\");\\n\\n        return (uint256(answer), roundTimestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OptionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport \\\"./lib/OptionLib.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./interfaces/IOptionVault.sol\\\";\\nimport \\\"./interfaces/IAMM.sol\\\";\\n\\n/**\\n * @notice OptionVault contract is vaults for basic on-chain option contracts.\\n * It manages option tokens.\\n */\\ncontract OptionVault is IOptionVault, ERC1155, IERC1155Receiver {\\n    using OptionLib for OptionLib.OptionInfo;\\n\\n    /// @dev operator address\\n    address operator;\\n\\n    /// @dev AMM address\\n    address ammAddress;\\n\\n    /// @dev option info\\n    OptionLib.OptionInfo public optionInfo;\\n\\n    /// @dev price oracle contract\\n    PriceOracle priceOracle;\\n\\n    // events\\n    event ExpiryCreated(uint256 indexed expiryId, uint64 expiry);\\n    event SeriesCreated(uint256 indexed expiryId, uint256 seriesId, uint128 strike, bool isPut);\\n\\n    event AccountCreated(uint256 accountId, address indexed account);\\n    event VaultDeposited(uint256 indexed accountId, uint256 expiryId, uint128 amount);\\n    event VaultWithdrawn(uint256 indexed accountId, uint256 expiryId, uint128 amount);\\n    event Written(uint256 indexed accountId, uint256 seriesId, uint128 amount, address recipient);\\n    event Unlocked(uint256 indexed accountId, uint256 seriesId, uint128 amount, address holder);\\n    event Claimed(uint256 indexed seriesId, uint128 amount, uint128 profit);\\n    event Settled(uint256 accountId, uint256 indexed seriesId, uint128 profit);\\n    event Hedged(uint32 tickId, int256 tickDelta, int256 hedgePosition);\\n    event Liquidated(uint256 accountId, uint256 seriesId);\\n    event ConfigUpdated(uint8 key, uint128 value);\\n\\n    // modifiers\\n    modifier onlyVaultOwner(uint256 _accountId) {\\n        // if accountId is id of trader's vaults, check owner\\n        // if AMM vaults, check caller is AMM contract\\n        require(\\n            (msg.sender == optionInfo.getVaultOwner(_accountId) &&\\n                _accountId >= OptionLib.MIN_VAULT_ID &&\\n                _accountId < optionInfo.vaultCount) ||\\n                (msg.sender == ammAddress && _accountId < OptionLib.MIN_VAULT_ID),\\n            \\\"V1\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyAMMVault(uint256 _accountId) {\\n        require(_accountId < OptionLib.MIN_VAULT_ID, \\\"V2\\\");\\n        _;\\n    }\\n\\n    modifier notAMMVault(uint256 _accountId) {\\n        require(_accountId >= OptionLib.MIN_VAULT_ID, \\\"V3\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(msg.sender == operator, \\\"V4\\\");\\n        _;\\n    }\\n\\n    modifier onlyAMM() {\\n        require(msg.sender == ammAddress, \\\"V5\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory _uri,\\n        address _aggregator,\\n        address _collateral,\\n        address _underlying,\\n        address _priceOracle,\\n        address _operator,\\n        address _lendingPool\\n    ) ERC1155(_uri) {\\n        optionInfo.aggregator = _aggregator;\\n        priceOracle = PriceOracle(_priceOracle);\\n\\n        operator = _operator;\\n\\n        optionInfo.init(_collateral, _underlying, _lendingPool);\\n    }\\n\\n    function onERC1155Received(\\n        address _operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    ) external override(IERC1155Receiver) returns (bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) external override(IERC1155Receiver) returns (bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    }\\n\\n    function isApprovedForAll(address account, address _operator) public view virtual override returns (bool) {\\n        return super.isApprovedForAll(account, _operator) || _operator == address(this) || _operator == ammAddress;\\n    }\\n\\n    /**\\n     * @notice set AMM address\\n     * @param _ammAddress amm address\\n     */\\n    function setAMMAddress(address _ammAddress) external {\\n        require(ammAddress == address(0));\\n        ammAddress = _ammAddress;\\n        setApprovalForAll(ammAddress, true);\\n    }\\n\\n    /**\\n     * @notice set IV by AMM contract\\n     * @param _seriesId series id\\n     * @param _iv new implied volatility\\n     */\\n    function setIV(uint256 _seriesId, uint128 _iv) external override(IOptionVault) onlyAMM {\\n        optionInfo.setIV(_seriesId, _iv);\\n    }\\n\\n    /**\\n     * @notice create new vault\\n     */\\n    function createAccount() public override(IOptionVault) returns (uint256) {\\n        uint256 accountId = optionInfo.createAccount(msg.sender);\\n\\n        emit AccountCreated(accountId, msg.sender);\\n\\n        return accountId;\\n    }\\n\\n    /**\\n     * @notice deposit collateral to the vault\\n     * @param _accountId vault id\\n     * @param _collateral amount to deposit scaled by 1e6\\n     */\\n    function deposit(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_collateral > 0, \\\"V9\\\");\\n\\n        optionInfo.deposit(_accountId, _expiryId, _collateral);\\n\\n        IERC20(optionInfo.tokens.collateral).transferFrom(msg.sender, address(this), _collateral);\\n\\n        emit VaultDeposited(_accountId, _expiryId, _collateral);\\n    }\\n\\n    /**\\n     * @notice withdraw collateral from the vault\\n     * @param _accountId vault id\\n     * @param _expiryId expiry id\\n     * @param _collateral amount to withdraw scaled by 1e6\\n     */\\n    function withdraw(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_collateral > 0, \\\"V9\\\");\\n\\n        uint128 spot = getPrice();\\n\\n        optionInfo.withdraw(_accountId, _expiryId, _collateral, spot);\\n\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, _collateral);\\n\\n        emit VaultWithdrawn(_accountId, _expiryId, _collateral);\\n    }\\n\\n    /**\\n     * @notice close short position and withdraw unrequired collateral from the vault\\n     * @param _accountId account id\\n     * @param _seriesId series id to close\\n     * @param _amount the amount to close\\n     * @param _cRatio the final IM ratio(IM / collateral)\\n     */\\n    function closeShortPosition(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _cRatio\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) returns (uint128) {\\n        require(0 < _cRatio && _cRatio <= 1e6, \\\"V6\\\");\\n\\n        if (_amount > 0) {\\n            require(balanceOf(msg.sender, _seriesId) >= _amount, \\\"V7\\\");\\n\\n            // unlock options\\n            optionInfo.unlock(_accountId, _seriesId, _amount);\\n\\n            _burn(msg.sender, _seriesId, _amount);\\n\\n            emit Unlocked(_accountId, _seriesId, _amount, msg.sender);\\n        }\\n\\n        bool isPool = _accountId < OptionLib.MIN_VAULT_ID;\\n\\n        uint256 expiryId = optionInfo.serieses[_seriesId].expiryId;\\n        uint128 unrequiredCollateral = optionInfo.withdrawUnrequiredCollateral(\\n            _accountId,\\n            expiryId,\\n            getPrice(),\\n            _cRatio,\\n            isPool\\n        );\\n\\n        if (unrequiredCollateral > 0) {\\n            IERC20(optionInfo.tokens.collateral).transfer(msg.sender, unrequiredCollateral);\\n\\n            emit VaultWithdrawn(_accountId, expiryId, unrequiredCollateral);\\n        }\\n\\n        return unrequiredCollateral;\\n    }\\n\\n    /**\\n     * @notice lock collateral and mint option tokens\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @param _amount amount to write scaled by 1e8\\n     * @param _recipient recipient of option tokens\\n     */\\n    function write(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        address _recipient\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        uint128 spot = getPrice();\\n\\n        // write options\\n        optionInfo.write(_accountId, _seriesId, _amount, spot);\\n\\n        _mint(_recipient, _seriesId, _amount, \\\"\\\");\\n\\n        emit Written(_accountId, _seriesId, _amount, _recipient);\\n    }\\n\\n    /**\\n     * @notice deposit collateral and write options in one transaction\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @param _cRatio _collateral ratio of Initial Margin\\n     * @param _amount amount to write scaled by 1e8\\n     * @param _recipient recipient of option tokens\\n     */\\n    function depositAndWrite(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _cRatio,\\n        uint128 _amount,\\n        address _recipient\\n    ) public override(IOptionVault) onlyVaultOwner(_accountId) returns (uint128) {\\n        require(_amount > 0, \\\"V9\\\");\\n        require(0 < _cRatio && _cRatio <= 1e6, \\\"V6\\\");\\n\\n        bool isPool = _accountId < OptionLib.MIN_VAULT_ID;\\n\\n        // deposit collateral and write options\\n        (uint256 expiryId, uint128 collateral) = optionInfo.depositAndWrite(\\n            _accountId,\\n            _seriesId,\\n            _amount,\\n            _cRatio,\\n            getPrice(),\\n            isPool\\n        );\\n\\n        IERC20(optionInfo.tokens.collateral).transferFrom(msg.sender, address(this), collateral);\\n\\n        _mint(_recipient, _seriesId, _amount, \\\"\\\");\\n\\n        emit VaultDeposited(_accountId, expiryId, collateral);\\n        emit Written(_accountId, _seriesId, _amount, _recipient);\\n\\n        return collateral;\\n    }\\n\\n    /**\\n     * @notice add long position to calculate net delta\\n     */\\n    function addLong(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        uint128 longSize = optionInfo.addLong(_accountId, _expiryId, _seriesId, _amount);\\n\\n        require(balanceOf(msg.sender, _seriesId) >= longSize, \\\"V10\\\");\\n    }\\n\\n    /**\\n     * @notice remove long position to calculate net delta\\n     */\\n    function removeLong(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        optionInfo.removeLong(_accountId, _expiryId, _seriesId, _amount);\\n    }\\n\\n    /**\\n     * @notice swap collateral asset for underling asset to hedge vault's delta\\n     * @param _accountId the id of target vault\\n     * @param _underlyingAmount amount of underlying asset scaled by 1e8\\n     * @param _collateralAmount amount of collateral asset scaled by 1e6\\n     */\\n    function addUnderlyingLong(\\n        uint32 _accountId,\\n        uint256 _expiryId,\\n        uint256 _underlyingAmount,\\n        uint256 _collateralAmount\\n    ) external onlyAMMVault(_accountId) {\\n        uint128 spot = getPrice();\\n\\n        // calculate vault's net delta\\n        int256 vaultDelta = optionInfo.calculateVaultDelta(_accountId, _expiryId, spot);\\n\\n        // swap collateral asset for underling asset\\n        int256 hedgePosition = optionInfo.addUnderlyingLong(\\n            _accountId,\\n            _expiryId,\\n            spot,\\n            vaultDelta,\\n            _underlyingAmount,\\n            _collateralAmount\\n        );\\n\\n        emit Hedged(_accountId, vaultDelta, hedgePosition);\\n    }\\n\\n    /**\\n     * @notice swap underling asset for collateral asset to hedge vaults' delta\\n     * @param _accountId the id of target vault\\n     * @param _underlyingAmount amount of underlying asset scaled by 1e8\\n     * @param _collateralAmount amount of collateral asset scaled by 1e6\\n     */\\n    function addUnderlyingShort(\\n        uint32 _accountId,\\n        uint256 _expiryId,\\n        uint256 _underlyingAmount,\\n        uint256 _collateralAmount\\n    ) external onlyAMMVault(_accountId) {\\n        uint128 spot = getPrice();\\n\\n        // calculate vault's net delta\\n        int256 vaultDelta = optionInfo.calculateVaultDelta(_accountId, _expiryId, spot);\\n\\n        // swap underling asset for collateral asset\\n        int256 hedgePosition = optionInfo.addUnderlyingShort(\\n            _accountId,\\n            _expiryId,\\n            spot,\\n            vaultDelta,\\n            _underlyingAmount,\\n            _collateralAmount\\n        );\\n\\n        emit Hedged(_accountId, vaultDelta, hedgePosition);\\n    }\\n\\n    /**\\n     * @notice repay all underlying asset and withdraw collateral from AAVE\\n     * @param _repayAmount amount to repay\\n     */\\n    function redeemCollateralFromLendingPool(uint128 _repayAmount) external onlyOperator {\\n        optionInfo.redeemCollateralFromLendingPool(\\n            _repayAmount,\\n            getPrice(),\\n            msg.sender,\\n            address(IAMM(ammAddress).feePool())\\n        );\\n    }\\n\\n    /**\\n     * @notice burn options and get collateral from a vault that requires liquidation\\n     * to save the profit of option holders.\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @param _amount amount to liquidate scaled by 1e8\\n     */\\n    function liquidate(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external notAMMVault(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        require(balanceOf(msg.sender, _seriesId) >= _amount, \\\"V7\\\");\\n\\n        uint128 price = getPrice();\\n\\n        uint128 reward = optionInfo.liquidate(_accountId, _seriesId, _amount, price);\\n\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, reward);\\n\\n        _burn(msg.sender, _seriesId, _amount);\\n\\n        emit Liquidated(_accountId, _seriesId);\\n    }\\n\\n    /**\\n     * @notice claim profit of some amount of expired option contracts.\\n     * @param _seriesId option series id\\n     * @param _size option size to claim profit scaled by 1e8\\n     */\\n    function claim(uint256 _seriesId, uint128 _size) external override(IOptionVault) returns (uint128) {\\n        IOptionVault.OptionSeries storage series = optionInfo.serieses[_seriesId];\\n\\n        require(balanceOf(msg.sender, _seriesId) >= _size, \\\"V7\\\");\\n\\n        uint256 price = getExpiryPrice(series.expiryId);\\n\\n        uint128 payout = optionInfo.claimProfit(_seriesId, _size, uint128(price));\\n\\n        // burn options\\n        _burn(msg.sender, _seriesId, _size);\\n\\n        // send payout to option holder\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, payout);\\n\\n        emit Claimed(_seriesId, _size, payout);\\n\\n        return payout;\\n    }\\n\\n    /**\\n     * @notice settle a vault\\n     * fix the payout of an expired vault and send collateral in the vault to vault's owner\\n     * @param _accountId vault id\\n     * @param _expiryId option series id\\n     */\\n    function settleVault(uint256 _accountId, uint256 _expiryId) external override(IOptionVault) returns (uint128) {\\n        // anyone can settle trader's vault, but only AMM contract can settle AMM's vault\\n        require(\\n            (_accountId >= OptionLib.MIN_VAULT_ID && _accountId < optionInfo.vaultCount) ||\\n                (msg.sender == ammAddress && _accountId < OptionLib.MIN_VAULT_ID),\\n            \\\"V8\\\"\\n        );\\n\\n        uint256 price = getExpiryPrice(_expiryId);\\n\\n        uint128 settledAmount = optionInfo.settle(_accountId, _expiryId, uint128(price));\\n\\n        if (settledAmount > 0) {\\n            // send all vault's collateral to owner\\n            if (_accountId < OptionLib.MIN_VAULT_ID) {\\n                IERC20(optionInfo.tokens.collateral).transfer(ammAddress, settledAmount);\\n            } else {\\n                IERC20(optionInfo.tokens.collateral).transfer(optionInfo.getVaultOwner(_accountId), settledAmount);\\n            }\\n        }\\n\\n        emit Settled(_accountId, _expiryId, settledAmount);\\n\\n        return settledAmount;\\n    }\\n\\n    ////////////////////////\\n    // Wrapper Functions //\\n    ////////////////////////\\n\\n    function makeShortPosition(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _cRatio,\\n        uint128 _amount,\\n        uint128 _minFee\\n    ) external {\\n        uint256 accountId = _accountId;\\n\\n        if (accountId == 0) {\\n            accountId = createAccount();\\n        }\\n\\n        depositAndWrite(accountId, _seriesId, _cRatio, _amount, address(this));\\n\\n        uint128 premium = IAMM(ammAddress).sell(_seriesId, _amount, _minFee);\\n\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, premium);\\n    }\\n\\n    ////////////////////////\\n    // Operator Functions //\\n    ////////////////////////\\n\\n    /**\\n     * @notice create new expiration\\n     * @param _expiry expiration\\n     * @param _strikes strike prices\\n     * @param _callIVs initial call ivs\\n     * @param _putIVs initial put ivs\\n     */\\n    function createExpiry(\\n        uint64 _expiry,\\n        uint64[] memory _strikes,\\n        uint64[] memory _callIVs,\\n        uint64[] memory _putIVs\\n    ) external onlyOperator {\\n        uint128 expiryId = optionInfo.createExpiry(_expiry);\\n\\n        for (uint256 i = 0; i < _strikes.length; i++) {\\n            createSeries(expiryId, _strikes[i], false, _callIVs[i]);\\n            createSeries(expiryId, _strikes[i], true, _putIVs[i]);\\n        }\\n\\n        emit ExpiryCreated(expiryId, _expiry);\\n    }\\n\\n    /**\\n     * @notice update a config value\\n     */\\n    function setConfig(uint8 _key, uint128 _value) external onlyOperator {\\n        require(_value > 0);\\n        optionInfo.setConfig(_key, _value);\\n\\n        // emit event\\n        emit ConfigUpdated(_key, _value);\\n    }\\n\\n    /**\\n     * @notice set new operator\\n     * @param _operator operator address\\n     */\\n    function setNewOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    //////////////////////\\n    // Getter Functions //\\n    //////////////////////\\n\\n    /**\\n     * @notice get an expiration\\n     */\\n    function getExpiration(uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (IOptionVault.Expiration memory)\\n    {\\n        return optionInfo.expiries[_expiryId];\\n    }\\n\\n    /**\\n     * @notice get an option series\\n     */\\n    function getOptionSeries(uint256 _seriesId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (IOptionVault.OptionSeriesView memory)\\n    {\\n        return optionInfo.getOptionSeriesView(_seriesId);\\n    }\\n\\n    /**\\n     * @notice get list of live option serieses\\n     */\\n    function getLiveOptionSerieses() external view override(IOptionVault) returns (IOptionVault.Expiration[] memory) {\\n        return optionInfo.getLiveOptionSerieses();\\n    }\\n\\n    /**\\n     * @notice get timestamp of the last expiry\\n     */\\n    function getLastExpiry() external view override(IOptionVault) returns (uint64) {\\n        return optionInfo.expiries[optionInfo.expiryCount - 1].expiry;\\n    }\\n\\n    /**\\n     * @notice get total collateral value of a vault\\n     * @param _accountId vault id\\n     */\\n    function getCollateralValueQuote(uint256 _accountId) external view override(IOptionVault) returns (uint128) {\\n        return optionInfo.getCollateralValueQuote(_accountId, getPrice());\\n    }\\n\\n    /**\\n     * @notice get required margin of a vault\\n     * there are 3 margin levels\\n     * 1. Maintenance Margin: vaults can be liquidated if the collateral is lower than MM\\n     * 2. Initial Margin: collateral must be greater than IM to write options\\n     * 3. Safe Margin: enough margin for delta hedging\\n     * @param _accountId vault id\\n     * @param _expiryId expiry id\\n     * @param _marginLevel margin level\\n     */\\n    function getRequiredMargin(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view override(IOptionVault) returns (uint128) {\\n        uint128 price = getPrice();\\n\\n        return optionInfo.getRequiredMargin(_accountId, _expiryId, price, _marginLevel);\\n    }\\n\\n    /**\\n     * @notice calculate required margin for a series\\n     * @param _seriesId series id\\n     * @param _amount amount of options. plus for short and minus for long\\n     * @param _marginLevel margin level\\n     */\\n    function calRequiredMarginForASeries(\\n        uint256 _seriesId,\\n        int128 _amount,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view override(IOptionVault) returns (uint128) {\\n        IOptionVault.OptionSeries memory series = optionInfo.serieses[_seriesId];\\n\\n        return optionInfo.getRequiredMarginForASeries(series.expiryId, _seriesId, getPrice(), _amount, _marginLevel);\\n    }\\n\\n    /**\\n     * @notice get total payout of a vault\\n     * @param _accountId vault id\\n     * @param _expiryId expiry id\\n     */\\n    function getTotalPayout(uint256 _accountId, uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (uint128)\\n    {\\n        return optionInfo.getTotalPayout(_accountId, _expiryId, getPrice(), false);\\n    }\\n\\n    /**\\n     * @notice get liquidatable amount of a vault\\n     * @param _accountId vault id\\n     * @param _seriesId series id\\n     */\\n    function getLiquidatableAmount(uint256 _accountId, uint256 _seriesId) external view returns (uint128 limit) {\\n        return optionInfo.getLiquidatableAmount(_accountId, _seriesId, getPrice());\\n    }\\n\\n    function getAccount(uint256 _accountId) external view override(IOptionVault) returns (AccountView memory) {\\n        Account storage account = optionInfo.accounts[_accountId];\\n        return AccountView(account.owner, account.settledCount);\\n    }\\n\\n    function getVault(uint256 _accountId, uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (VaultView memory)\\n    {\\n        Vault storage vault = optionInfo.accounts[_accountId].vaults[_expiryId];\\n        return\\n            VaultView(\\n                optionInfo.accounts[_accountId].owner,\\n                vault.isSettled,\\n                vault.collateral,\\n                vault.hedgePosition,\\n                vault.shortLiquidity\\n            );\\n    }\\n\\n    /**\\n     * @notice get position size\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @return (short size, long size)\\n     */\\n    function getPositionSize(uint256 _accountId, uint256 _seriesId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (uint128, uint128)\\n    {\\n        return optionInfo.getPositionSize(_accountId, _seriesId);\\n    }\\n\\n    /**\\n     * @notice get vault's net delta\\n     * @param _accountId vault id\\n     */\\n    function calculateVaultDelta(uint256 _accountId, uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (int256)\\n    {\\n        return optionInfo.calculateVaultDelta(_accountId, _expiryId, getPrice());\\n    }\\n\\n    /**\\n     * @notice get a config value\\n     */\\n    function getConfig(uint8 _key) external view returns (uint128) {\\n        return optionInfo.configs[_key];\\n    }\\n\\n    ///////////////////////\\n    // Private Functions //\\n    ///////////////////////\\n\\n    function createSeries(\\n        uint128 _expiryId,\\n        uint64 _strike,\\n        bool _isPut,\\n        uint64 _iv\\n    ) internal {\\n        uint256 seriesId = optionInfo.createSeries(_expiryId, _strike, _isPut, _iv);\\n        emit SeriesCreated(_expiryId, seriesId, _strike, _isPut);\\n    }\\n\\n    function getExpiryPrice(uint256 _expiryId) internal view returns (uint256) {\\n        IOptionVault.Expiration storage expiration = optionInfo.expiries[_expiryId];\\n\\n        (uint256 price, bool isFinalized) = priceOracle.getExpiryPrice(optionInfo.aggregator, expiration.expiry);\\n\\n        require(isFinalized, \\\"V11\\\");\\n\\n        return price;\\n    }\\n\\n    function getPrice() internal view returns (uint128) {\\n        (uint256 spot, ) = priceOracle.getPrice(optionInfo.aggregator);\\n        return uint128(spot);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IOptionVault {\\n    enum MarginLevel {\\n        Maintenance,\\n        Initial,\\n        Safe\\n    }\\n\\n    struct Expiration {\\n        uint128 expiryId;\\n        uint64 expiry;\\n        uint256[] seriesIds;\\n    }\\n\\n    struct OptionSeries {\\n        uint64 strike;\\n        bool isPut;\\n        uint64 iv;\\n        uint128 expiryId;\\n    }\\n\\n    struct Account {\\n        address owner;\\n        uint256 settledCount;\\n        mapping(uint256 => Vault) vaults;\\n    }\\n\\n    struct Vault {\\n        // is settled or not\\n        bool isSettled;\\n        // seriesId => short amount\\n        mapping(uint256 => uint128) shorts;\\n        // seriesId => long amount\\n        mapping(uint256 => uint128) longs;\\n        //\\n        uint128 collateral;\\n        //\\n        int256 hedgePosition;\\n        //\\n        uint128 shortLiquidity;\\n    }\\n\\n    // view struct\\n\\n    struct OptionSeriesParams {\\n        uint256 id;\\n        uint64 maturity;\\n        uint128 strike;\\n        bool isPut;\\n        uint128 iv;\\n    }\\n\\n    struct OptionSeriesView {\\n        uint256 expiryId;\\n        uint256 seriesId;\\n        uint64 expiry;\\n        uint64 maturity;\\n        uint128 strike;\\n        bool isPut;\\n        uint64 iv;\\n    }\\n\\n    struct AccountView {\\n        address owner;\\n        uint256 settledCount;\\n    }\\n\\n    struct VaultView {\\n        address owner;\\n        bool isSettled;\\n        uint128 collateral;\\n        int256 hedgePosition;\\n        uint128 shortLiquidity;\\n    }\\n\\n    function getExpiration(uint256 _expiryId) external view returns (IOptionVault.Expiration memory);\\n\\n    function getOptionSeries(uint256 _seriesId) external view returns (IOptionVault.OptionSeriesView memory);\\n\\n    function getAccount(uint256 _vaultId) external view returns (AccountView memory);\\n\\n    function getVault(uint256 _vaultId, uint256 _expiryId) external view returns (VaultView memory);\\n\\n    function getCollateralValueQuote(uint256 _vaultId) external view returns (uint128);\\n\\n    function getRequiredMargin(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view returns (uint128);\\n\\n    function calRequiredMarginForASeries(\\n        uint256 _seriesId,\\n        int128 _amount,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view returns (uint128);\\n\\n    function getTotalPayout(uint256 _vaultId, uint256 _expiryId) external view returns (uint128);\\n\\n    function getPositionSize(uint256 _vaultId, uint256 _seriesId) external view returns (uint128, uint128);\\n\\n    function getLiveOptionSerieses() external view returns (IOptionVault.Expiration[] memory);\\n\\n    function getLastExpiry() external view returns (uint64);\\n\\n    function createAccount() external returns (uint256);\\n\\n    function setIV(uint256 _seriesId, uint128 _iv) external;\\n\\n    function deposit(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external;\\n\\n    function withdraw(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external;\\n\\n    function closeShortPosition(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _cRatio\\n    ) external returns (uint128);\\n\\n    function write(\\n        uint256 _vaultId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        address _recepient\\n    ) external;\\n\\n    function depositAndWrite(\\n        uint256 _vaultId,\\n        uint256 _seriesId,\\n        uint128 _collateral,\\n        uint128 _amount,\\n        address _recepient\\n    ) external returns (uint128);\\n\\n    function settleVault(uint256 _vaultId, uint256 _expiryId) external returns (uint128);\\n\\n    function claim(uint256 _seriesId, uint128 _size) external returns (uint128);\\n\\n    function addLong(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external;\\n\\n    function removeLong(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external;\\n\\n    function calculateVaultDelta(uint256 _vaultId, uint256 _expiryId) external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IFeePool {\\n    function sendProfitERC20(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IFeePool.sol\\\";\\n\\ninterface IAMM {\\n    function sell(\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _minFee\\n    ) external returns (uint128);\\n\\n    function feePool() external returns (IFeePool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHedge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IHedge {\\n    function init(address _ammAddress) external;\\n\\n    function underlying() external returns (address);\\n\\n    function shortAsset() external returns (address);\\n\\n    function buy(uint256 _underlyingAmount, uint256 _amountInMaximum) external returns (uint256 amountIn);\\n\\n    function sell(uint256 _underlyingAmount, uint256 _amountOutMinimum) external returns (uint256 amountOut);\\n\\n    function getShortPrice(uint256 _size) external view returns (uint256);\\n\\n    function buyShort(uint256 _size, uint256 _amountToPay) external returns (uint256 amountIn);\\n\\n    function sellShort(uint256 _size, uint256 amountToReceive) external returns (uint256 amountOut);\\n\\n    function getValueQuote(int256 _position) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/PredyMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nlibrary PredyMath {\\n    function max(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a > b ? a : b;\\n    }\\n\\n    function min(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a > b ? b : a;\\n    }\\n\\n    function abs(int128 x) internal pure returns (uint128) {\\n        return uint128(x >= 0 ? x : -x);\\n    }\\n\\n    function mulDiv(\\n        uint256 _x,\\n        uint256 _y,\\n        uint256 _d,\\n        bool _roundUp\\n    ) internal pure returns (uint128) {\\n        uint256 tailing;\\n        if (_roundUp) {\\n            uint256 remainer = (_x * _y) % _d;\\n            if (remainer > 0) {\\n                tailing = 1;\\n            }\\n        }\\n\\n        uint256 result = (_x * _y) / _d + tailing;\\n\\n        return SafeCast.toUint128(result);\\n    }\\n\\n    function scale(\\n        uint256 _a,\\n        uint256 _from,\\n        uint256 _to\\n    ) internal pure returns (uint256) {\\n        if (_from > _to) {\\n            return _a / 10**(_from - _to);\\n        } else if (_from < _to) {\\n            return _a * 10**(_to - _from);\\n        } else {\\n            return _a;\\n        }\\n    }\\n\\n    function toInt128(uint256 _a) internal pure returns (int128) {\\n        return SafeCast.toInt128(SafeCast.toInt256(_a));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OptionLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./PriceCalculator.sol\\\";\\nimport \\\"../interfaces/IAave.sol\\\";\\nimport \\\"../interfaces/IHedge.sol\\\";\\nimport \\\"../interfaces/IOptionVault.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IFeePool.sol\\\";\\nimport \\\"./PredyMath.sol\\\";\\n\\n/**\\n * @title OptionLib\\n */\\nlibrary OptionLib {\\n    using PredyMath for uint128;\\n\\n    struct TokenContracts {\\n        // collateral token\\n        address collateral;\\n        // underlying token\\n        address underlying;\\n    }\\n\\n    /// @dev option information\\n    struct OptionInfo {\\n        address aggregator;\\n        TokenContracts tokens;\\n        // counter of serieses\\n        uint128 seriesCount;\\n        uint128 expiryCount;\\n        uint128 expiredCount;\\n        // expiration => seriesId => option series\\n        mapping(uint256 => IOptionVault.Expiration) expiries;\\n        //\\n        mapping(uint256 => IOptionVault.OptionSeries) serieses;\\n        // counter of vaults\\n        uint256 vaultCount;\\n        // accountId => IOptionVault.Account\\n        uint128 totalDepositedToLendingPool;\\n        mapping(uint256 => IOptionVault.Account) accounts;\\n        // config\\n        mapping(uint8 => uint128) configs;\\n        //\\n        LendingPool lendingPool;\\n    }\\n\\n    uint8 public constant MM_RATIO = 1;\\n    uint8 public constant IM_RATIO = 2;\\n    uint8 public constant CALL_SAFE_RATIO = 3;\\n    uint8 public constant PUT_SAFE_RATIO = 4;\\n    uint8 public constant SLIPPAGE_TOLERANCE = 5;\\n    uint8 public constant BASE_LIQ_REWARD = 8;\\n    uint8 public constant REWARD_PER_SIZE_RATIO = 9;\\n\\n    /// @dev minimum vault id.\\n    /// trader's vault id is larger than MIN_VAULT_ID\\n    uint128 public constant MIN_VAULT_ID = 100;\\n\\n    uint256 constant MAX_UINT256 = 2**256 - 1;\\n\\n    modifier existsExpiry(uint256 _expiryId, uint128 _expiryCount) {\\n        require(_expiryId > 0 && _expiryId < _expiryCount, \\\"OptionLib: expiry not found\\\");\\n        _;\\n    }\\n\\n    modifier existsSeries(uint256 _seriesId, uint128 _seriesCount) {\\n        require(_seriesId > 0 && _seriesId < _seriesCount, \\\"OptionLib: series not found\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice initialize OptionInfo\\n     */\\n    function init(\\n        OptionInfo storage _optionInfo,\\n        address _collateral,\\n        address _underlying,\\n        address _lendingPool\\n    ) external {\\n        // initialize states\\n        _optionInfo.expiredCount = 0;\\n        _optionInfo.expiryCount = 1;\\n        _optionInfo.seriesCount = 1;\\n        _optionInfo.vaultCount = OptionLib.MIN_VAULT_ID;\\n\\n        // initialize configs\\n        // 10%\\n        _optionInfo.configs[MM_RATIO] = 100;\\n        // 20%\\n        _optionInfo.configs[IM_RATIO] = 200;\\n        // 120%\\n        _optionInfo.configs[CALL_SAFE_RATIO] = 1200;\\n        // 120%\\n        _optionInfo.configs[PUT_SAFE_RATIO] = 1200;\\n        // 0.5%\\n        _optionInfo.configs[SLIPPAGE_TOLERANCE] = 50;\\n        // $100\\n        _optionInfo.configs[BASE_LIQ_REWARD] = 100 * 1e6;\\n        // 9%\\n        _optionInfo.configs[REWARD_PER_SIZE_RATIO] = 90;\\n\\n        // set contract addresses\\n        _optionInfo.tokens.collateral = _collateral;\\n        _optionInfo.tokens.underlying = _underlying;\\n        _optionInfo.lendingPool = LendingPool(_lendingPool);\\n    }\\n\\n    function setIV(\\n        OptionInfo storage _optionInfo,\\n        uint256 _seriesId,\\n        uint128 _iv\\n    ) external {\\n        _optionInfo.serieses[_seriesId].iv = uint64(_iv);\\n    }\\n\\n    /**\\n     * @notice create new option series\\n     * the option series must have later expiry than existence serieses\\n     */\\n    function createExpiry(OptionInfo storage _optionInfo, uint64 _expiry) external returns (uint128 expiryId) {\\n        // check expiry is greater than or equal to last created\\n        uint64 lastExpiry;\\n        if (_optionInfo.expiryCount > 0) {\\n            lastExpiry = _optionInfo.expiries[_optionInfo.expiryCount - 1].expiry;\\n        }\\n\\n        require(_expiry >= block.timestamp, \\\"OptionLib: expiry must be greater than now\\\");\\n        require(_expiry >= lastExpiry, \\\"OptionLib: expiry must be greater than or equal to last created\\\");\\n        require(_expiry % 1 hours == 0, \\\"OptionLib: expiry must be formatted\\\");\\n\\n        // create series\\n        expiryId = _optionInfo.expiryCount;\\n        _optionInfo.expiries[expiryId].expiryId = expiryId;\\n        _optionInfo.expiries[expiryId].expiry = _expiry;\\n\\n        _optionInfo.expiryCount += 1;\\n    }\\n\\n    function createSeries(\\n        OptionInfo storage _optionInfo,\\n        uint128 _expiryId,\\n        uint64 _strike,\\n        bool _isPut,\\n        uint64 _iv\\n    ) external returns (uint256 seriesId) {\\n        require(_strike > 0 && _strike < 1e16, \\\"OptionLib: strike must be greater than 0 and less than $100M\\\");\\n        require(_iv > 0 && _iv < 1000 * 1e6, \\\"OptionLib: iv must be greater than 0 and less than 1000%\\\");\\n\\n        seriesId = _optionInfo.seriesCount;\\n\\n        // create series\\n        _optionInfo.serieses[seriesId] = IOptionVault.OptionSeries(_strike, _isPut, _iv, _expiryId);\\n        _optionInfo.expiries[_expiryId].seriesIds.push(seriesId);\\n\\n        _optionInfo.seriesCount += 1;\\n    }\\n\\n    function createAccount(OptionInfo storage _optionInfo, address owner) external returns (uint256) {\\n        uint256 id = _optionInfo.vaultCount;\\n\\n        IOptionVault.Account storage account = _optionInfo.accounts[id];\\n        account.owner = owner;\\n        account.settledCount = _optionInfo.expiredCount;\\n\\n        _optionInfo.vaultCount += 1;\\n\\n        return id;\\n    }\\n\\n    function deposit(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _amount\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        require(!vault.isSettled, \\\"Vault already settled\\\");\\n\\n        increaseCollateral(vault, _amount);\\n    }\\n\\n    function withdraw(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _amount,\\n        uint128 _spot\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[_expiryId]);\\n\\n        decreaseCollateral(vault, _amount);\\n\\n        checkCollateral(_optionInfo, _accountId, _expiryId, _spot);\\n    }\\n\\n    function withdrawUnrequiredCollateral(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        uint128 _cRatio,\\n        bool _isPool\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (uint128) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[_expiryId]);\\n\\n        uint128 collateralValue = getCollateralValue(_optionInfo, _accountId, _expiryId, _spot);\\n\\n        uint128 requiredCollateral = (1e6 *\\n            getRequiredMargin(\\n                _optionInfo,\\n                _accountId,\\n                _expiryId,\\n                _spot,\\n                _isPool ? IOptionVault.MarginLevel.Safe : IOptionVault.MarginLevel.Initial\\n            )) / _cRatio;\\n\\n        if (collateralValue > requiredCollateral) {\\n            return decreaseCollateral(vault, collateralValue - requiredCollateral);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function write(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _spot\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.OptionSeries storage series = _optionInfo.serieses[_seriesId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[series.expiryId]);\\n\\n        account.vaults[series.expiryId].shorts[_seriesId] += _amount;\\n\\n        checkCollateral(_optionInfo, _accountId, series.expiryId, _spot);\\n    }\\n\\n    function unlock(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) {\\n        IOptionVault.OptionSeries storage series = _optionInfo.serieses[_seriesId];\\n\\n        _optionInfo.accounts[_accountId].vaults[series.expiryId].shorts[_seriesId] -= _amount;\\n    }\\n\\n    function depositAndWrite(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _cRatio,\\n        uint128 _spot,\\n        bool _isPool\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint256 expiryId, uint128 collateral) {\\n        expiryId = _optionInfo.serieses[_seriesId].expiryId;\\n\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[expiryId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[expiryId]);\\n\\n        account.vaults[expiryId].shorts[_seriesId] += _amount;\\n\\n        collateral = getCollateralForASeries(_optionInfo, expiryId, _seriesId, _spot, _amount, _cRatio, _isPool);\\n\\n        increaseCollateral(vault, collateral);\\n    }\\n\\n    function addLong(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint128) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n\\n        account.vaults[_expiryId].longs[_seriesId] += _amount;\\n\\n        return account.vaults[_expiryId].longs[_seriesId];\\n    }\\n\\n    function removeLong(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n\\n        account.vaults[_expiryId].longs[_seriesId] -= _amount;\\n    }\\n\\n    /**\\n     * @notice liquidate a vault\\n     * the amount that liquidator can burn is '(BASE_REWRD + MM - C) / (mm - premium - REWARD_RATIO * (St or K))'\\n     * where C = vault.collateral\\n     * , MM current maintenance margin\\n     * and mm is maintenance margin per size\\n     */\\n    function liquidate(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _spot\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint128) {\\n        IOptionVault.OptionSeries memory option = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[option.expiryId];\\n\\n        uint128 shortAmount = vault.shorts[_seriesId];\\n\\n        require(shortAmount >= _amount, \\\"OptionLib: amount exceeds vault size\\\");\\n\\n        uint128 collateralValue = getCollateralValue(_optionInfo, _accountId, option.expiryId, _spot);\\n\\n        uint128 limit;\\n        {\\n            uint128 maintenanceMargin = getRequiredMargin(\\n                _optionInfo,\\n                _accountId,\\n                option.expiryId,\\n                _spot,\\n                IOptionVault.MarginLevel.Maintenance\\n            );\\n            require(collateralValue < maintenanceMargin, \\\"OptionLib: collateral must be less than MM\\\");\\n\\n            limit = calLiquidatableAmount(\\n                _optionInfo,\\n                maintenanceMargin,\\n                collateralValue,\\n                option.isPut ? option.strike : _spot\\n            );\\n        }\\n\\n        require(limit >= _amount, \\\"OptionLib: amount exceeds liquidatable limit\\\");\\n\\n        vault.shorts[_seriesId] -= _amount;\\n\\n        uint128 reward;\\n        {\\n            uint128 maintenanceMargin = getRequiredMargin(\\n                _optionInfo,\\n                _accountId,\\n                option.expiryId,\\n                _spot,\\n                IOptionVault.MarginLevel.Maintenance\\n            );\\n\\n            require(collateralValue >= maintenanceMargin, \\\"OptionLib: margin must be safe\\\");\\n            reward = collateralValue - maintenanceMargin;\\n        }\\n\\n        return decreaseCollateral(vault, reward);\\n    }\\n\\n    /**\\n     * @notice calculate profit of some amount of option contracts\\n     */\\n    function claimProfit(\\n        OptionInfo storage _optionInfo,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _price\\n    ) external view existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint128) {\\n        uint128 payout = calculatePayout(\\n            _amount,\\n            _price,\\n            _optionInfo.serieses[_seriesId].strike,\\n            _optionInfo.serieses[_seriesId].isPut,\\n            false\\n        );\\n\\n        return payout;\\n    }\\n\\n    /**\\n     * @notice fix payout of a vault and remove the payout from vault's collaterals\\n     * @return settledAmount the amount that the vault owner can redeem\\n     */\\n    function settle(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _price\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (uint128 settledAmount) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n\\n        uint128 payout = getTotalPayout(_optionInfo, _accountId, _expiryId, _price, true);\\n\\n        require(!vault.isSettled, \\\"OptionLib: vault already settled\\\");\\n\\n        require(vault.hedgePosition == 0, \\\"OptionLib: hedge position must be neutral\\\");\\n\\n        // all collaterals in Aave must be redeemed before settlement\\n        require(vault.shortLiquidity == 0, \\\"OptionLib: all collaterals must be withdrawn\\\");\\n\\n        require(account.settledCount < _expiryId, \\\"OptionLib: vault already settled\\\");\\n\\n        for (uint256 i = account.settledCount + 1; i < _expiryId; i++) {\\n            uint128 skippedCollateral = account.vaults[i].collateral;\\n            require(skippedCollateral == 0, \\\"OptionLib: can not skip expiry\\\");\\n        }\\n\\n        vault.isSettled = true;\\n        account.settledCount = _expiryId;\\n\\n        updateExpiredCount(_optionInfo, _expiryId);\\n\\n        decreaseCollateral(vault, payout);\\n\\n        settledAmount = vault.collateral;\\n    }\\n\\n    /*\\n     * addUnderlyingLong and addUnderlyingShort are functions to achieve delta neutral.\\n     * vault's net delta is calculated as vaultDelta, and the protocol wanna make (vaultDelta + vault.hedgePosition) zero.\\n     * hedgePosition exactly represents how many underlying asset the vault has,\\n     * and negative hedgePosition means short position of underlying asset.\\n     */\\n\\n    /**\\n     * @notice receive underlying asset and send collateral asset to sender\\n     * @param _vaultDelta net delta of the vault\\n     * @param _underlyingAmountE8 amount of underlying asset scaled by 1e8\\n     */\\n    function addUnderlyingLong(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        int256 _vaultDelta,\\n        uint256 _underlyingAmountE8,\\n        uint256 _collateralAmount\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (int256) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n        ERC20 underlying = ERC20(_optionInfo.tokens.underlying);\\n\\n        uint256 decimals = underlying.decimals();\\n\\n        require(_vaultDelta + vault.hedgePosition < 0, \\\"OptionLib: net delta must be negative\\\");\\n\\n        require(\\n            -(_vaultDelta + vault.hedgePosition) >= int256(_underlyingAmountE8),\\n            \\\"OptionLib: underlying amount is too large\\\"\\n        );\\n\\n        if (-(_vaultDelta + vault.hedgePosition) < int256(_underlyingAmountE8)) {\\n            _underlyingAmountE8 = uint256(-(_vaultDelta + vault.hedgePosition));\\n        }\\n\\n        require(\\n            (PredyMath.scale(_spot * _underlyingAmountE8, 16, 6) * (10000 + _optionInfo.configs[SLIPPAGE_TOLERANCE])) /\\n                10000 >=\\n                _collateralAmount,\\n            \\\"OptionLib: collateral amount is too large\\\"\\n        );\\n\\n        uint256 uAmount = PredyMath.scale(_underlyingAmountE8, 8, decimals);\\n\\n        int256 hedgePosition = vault.hedgePosition;\\n\\n        vault.hedgePosition += int256(_underlyingAmountE8);\\n\\n        underlying.transferFrom(msg.sender, address(this), uAmount);\\n\\n        if (hedgePosition < -int256(_underlyingAmountE8)) {\\n            repayUnderlyingInternal(_optionInfo, vault, _spot, uAmount, uint256(-hedgePosition) - _underlyingAmountE8);\\n        } else if (hedgePosition < 0) {\\n            repayUnderlyingInternal(\\n                _optionInfo,\\n                vault,\\n                _spot,\\n                PredyMath.scale(uint256(-hedgePosition), 8, decimals),\\n                0\\n            );\\n        }\\n\\n        require(vault.collateral >= uint128(_collateralAmount), \\\"OptionLib: no enough collateral\\\");\\n\\n        decreaseCollateral(vault, uint128(_collateralAmount));\\n\\n        IERC20(_optionInfo.tokens.collateral).transfer(msg.sender, _collateralAmount);\\n\\n        return vault.hedgePosition;\\n    }\\n\\n    /**\\n     * @notice receive collateral asset and send underlying asset to sender\\n     * @param _vaultDelta net delta of the vault\\n     * @param _underlyingAmountE8 amount of underlying asset scaled by 1e8\\n     */\\n    function addUnderlyingShort(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        int256 _vaultDelta,\\n        uint256 _underlyingAmountE8,\\n        uint256 _collateralAmount\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (int256) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n        ERC20 underlying = ERC20(_optionInfo.tokens.underlying);\\n\\n        uint256 decimals = underlying.decimals();\\n\\n        require(_vaultDelta + vault.hedgePosition > 0, \\\"OptionLib: net delta must be positive\\\");\\n\\n        require(\\n            (_vaultDelta + vault.hedgePosition) >= int256(_underlyingAmountE8),\\n            \\\"OptionLib: underlying amount is too large\\\"\\n        );\\n\\n        require(\\n            (PredyMath.scale(_spot * _underlyingAmountE8, 16, 6) * (10000 - _optionInfo.configs[SLIPPAGE_TOLERANCE])) /\\n                10000 <=\\n                _collateralAmount,\\n            \\\"OptionLib: collateral amount is too small\\\"\\n        );\\n\\n        uint256 uAmount = PredyMath.scale(_underlyingAmountE8, 8, decimals);\\n\\n        increaseCollateral(vault, uint128(_collateralAmount));\\n\\n        IERC20(_optionInfo.tokens.collateral).transferFrom(msg.sender, address(this), _collateralAmount);\\n\\n        if (vault.hedgePosition <= 0) {\\n            borrowUnderlyingInternal(_optionInfo, vault, _spot, uAmount);\\n        } else if (vault.hedgePosition < int256(_underlyingAmountE8)) {\\n            borrowUnderlyingInternal(\\n                _optionInfo,\\n                vault,\\n                _spot,\\n                uAmount - PredyMath.scale(uint256(vault.hedgePosition), 8, decimals)\\n            );\\n        }\\n\\n        vault.hedgePosition -= int256(_underlyingAmountE8);\\n\\n        underlying.transfer(msg.sender, uAmount);\\n\\n        return vault.hedgePosition;\\n    }\\n\\n    /**\\n     * @notice redeem collateral from LendingPool\\n     */\\n    function redeemCollateralFromLendingPool(\\n        OptionInfo storage _optionInfo,\\n        uint128 _repayAmount,\\n        uint128 _price,\\n        address _caller,\\n        address _feePool\\n    ) external {\\n        // there are no live option serieses\\n        require(_optionInfo.expiryCount == _optionInfo.expiredCount + 1);\\n        // check total short liquidity is 0\\n        require(_optionInfo.totalDepositedToLendingPool == 0);\\n\\n        IERC20(_optionInfo.tokens.underlying).transferFrom(_caller, address(this), _repayAmount);\\n\\n        IERC20(_optionInfo.tokens.underlying).approve(address(_optionInfo.lendingPool), _repayAmount);\\n        uint128 repaidAmount = repayBorrow(_optionInfo, MAX_UINT256);\\n\\n        // redeem underlying tokens\\n        uint128 withdrawnAmount = uint128(\\n            _optionInfo.lendingPool.withdraw(_optionInfo.tokens.collateral, MAX_UINT256, address(this))\\n        );\\n\\n        uint128 reward = (_price * repaidAmount) / 1e20;\\n        reward = (reward * (10000 + _optionInfo.configs[SLIPPAGE_TOLERANCE])) / 10000;\\n\\n        if (reward < withdrawnAmount) {\\n            uint128 rewardForFeePool = withdrawnAmount - reward;\\n\\n            // send USDC to fee pool\\n            IFeePool feePool = IFeePool(_feePool);\\n\\n            IERC20(_optionInfo.tokens.collateral).approve(address(feePool), rewardForFeePool);\\n            feePool.sendProfitERC20(address(this), rewardForFeePool);\\n        } else {\\n            reward = withdrawnAmount;\\n        }\\n\\n        // send USDC and WETH to caller\\n        IERC20(_optionInfo.tokens.collateral).transfer(_caller, reward);\\n        IERC20(_optionInfo.tokens.underlying).transfer(_caller, _repayAmount - repaidAmount);\\n    }\\n\\n    function setConfig(\\n        OptionInfo storage _optionInfo,\\n        uint8 _key,\\n        uint128 _value\\n    ) external {\\n        _optionInfo.configs[_key] = _value;\\n    }\\n\\n    //////////////////////\\n    // Getter Functions //\\n    //////////////////////\\n\\n    function getLiveOptionSerieses(OptionInfo storage _optionInfo)\\n        external\\n        view\\n        returns (IOptionVault.Expiration[] memory)\\n    {\\n        IOptionVault.Expiration[] memory expirations = new IOptionVault.Expiration[](\\n            _optionInfo.expiryCount - _optionInfo.expiredCount - 1\\n        );\\n\\n        for (uint128 i = _optionInfo.expiredCount + 1; i < _optionInfo.expiryCount; i++) {\\n            expirations[i - _optionInfo.expiredCount - 1] = IOptionVault.Expiration(\\n                i,\\n                _optionInfo.expiries[i].expiry,\\n                _optionInfo.expiries[i].seriesIds\\n            );\\n        }\\n\\n        return expirations;\\n    }\\n\\n    function getOptionSeriesView(OptionInfo storage _optionInfo, uint256 _seriesId)\\n        external\\n        view\\n        returns (IOptionVault.OptionSeriesView memory)\\n    {\\n        IOptionVault.OptionSeries memory optionSeries = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Expiration memory expiration = _optionInfo.expiries[optionSeries.expiryId];\\n\\n        return\\n            IOptionVault.OptionSeriesView(\\n                optionSeries.expiryId,\\n                _seriesId,\\n                expiration.expiry,\\n                OptionLib.getMaturity(expiration.expiry),\\n                optionSeries.strike,\\n                optionSeries.isPut,\\n                optionSeries.iv\\n            );\\n    }\\n\\n    function getCollateralValueQuote(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint128 price\\n    ) external view returns (uint128 total) {\\n        for (uint256 i = _optionInfo.accounts[_accountId].settledCount + 1; i < _optionInfo.seriesCount; i++) {\\n            total += getCollateralValue(_optionInfo, _accountId, i, price);\\n        }\\n    }\\n\\n    /**\\n     * @notice get position size\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @return (short size, long size)\\n     */\\n    function getPositionSize(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId\\n    ) external view returns (uint128, uint128) {\\n        IOptionVault.OptionSeries memory series = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[series.expiryId];\\n\\n        return (vault.shorts[_seriesId], vault.longs[_seriesId]);\\n    }\\n\\n    function getVaultOwner(OptionInfo storage _optionInfo, uint256 _accountId) external view returns (address) {\\n        return _optionInfo.accounts[_accountId].owner;\\n    }\\n\\n    /**\\n     * @notice get the amount that can be liquidated\\n     */\\n    function getLiquidatableAmount(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _spot\\n    ) external view returns (uint128) {\\n        IOptionVault.OptionSeries memory option = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[option.expiryId];\\n\\n        uint128 maintenanceMargin = getRequiredMargin(\\n            _optionInfo,\\n            _accountId,\\n            option.expiryId,\\n            _spot,\\n            IOptionVault.MarginLevel.Maintenance\\n        );\\n\\n        uint128 collateralValue = getCollateralValue(_optionInfo, _accountId, option.expiryId, _spot);\\n\\n        if (collateralValue >= maintenanceMargin) {\\n            return 0;\\n        }\\n\\n        uint128 liquidatableAmount = calLiquidatableAmount(\\n            _optionInfo,\\n            maintenanceMargin,\\n            collateralValue,\\n            option.isPut ? option.strike : _spot\\n        );\\n\\n        if (vault.shorts[_seriesId] < liquidatableAmount) {\\n            return vault.shorts[_seriesId];\\n        }\\n\\n        return liquidatableAmount;\\n    }\\n\\n    int256 internal constant SQRT_YEAR_E8 = 5615.69229926 * 10**8;\\n\\n    /**\\n     * @notice calculate vault's net delta\\n     * @param _optionInfo pool info\\n     * @param _accountId vault id to calculate net delta\\n     * @param _spot spot price\\n     * @return tickDelta vault's net delta scaled by 1e8\\n     */\\n    function calculateVaultDelta(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot\\n    ) external view returns (int256 tickDelta) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        // calculate serieses that is not expired\\n        IOptionVault.Expiration memory expiration = _optionInfo.expiries[_expiryId];\\n\\n        // option serieses before maturity are included in the calculation.\\n        if (expiration.expiry <= block.timestamp) {\\n            return 0;\\n        }\\n\\n        // uint64 maturity = getMaturity(expiration.expiry);\\n        int256 sqrtMaturity = PriceCalculator.getSqrtMaturity(getMaturity(expiration.expiry));\\n\\n        for (uint256 j = 0; j < expiration.seriesIds.length; j++) {\\n            uint256 seriesId = expiration.seriesIds[j];\\n\\n            int128 position = vault.longs[seriesId].toInt128() - vault.shorts[seriesId].toInt128();\\n            tickDelta += calculateDelta(sqrtMaturity, _optionInfo.serieses[seriesId], position, _spot);\\n        }\\n        return tickDelta;\\n    }\\n\\n    ///////////////////////\\n    // Private Functions //\\n    ///////////////////////\\n\\n    function increaseCollateral(IOptionVault.Vault storage _vault, uint128 _amount) internal {\\n        _vault.collateral += _amount;\\n    }\\n\\n    function decreaseCollateral(IOptionVault.Vault storage _vault, uint128 _amount) internal returns (uint128) {\\n        if (_vault.collateral >= _amount) {\\n            _vault.collateral -= _amount;\\n            return _amount;\\n        } else {\\n            uint128 a = _vault.collateral;\\n            _vault.collateral = 0;\\n            return a;\\n        }\\n    }\\n\\n    /**\\n     * @notice get USD value of collateral\\n     */\\n    function getCollateralValue(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot\\n    ) internal view returns (uint128) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n\\n        int256 hedgedValue = vault.shortLiquidity.toInt128() + (_spot.toInt128() * vault.hedgePosition) / 1e10;\\n\\n        return uint128(uint256(hedgedValue)) + vault.collateral;\\n    }\\n\\n    /**\\n     * @notice get the required margin of a vault\\n     */\\n    function getRequiredMargin(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) public view returns (uint128 requiredMargin) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n        IOptionVault.Expiration storage expiration = _optionInfo.expiries[_expiryId];\\n\\n        if (vault.isSettled) {\\n            return 0;\\n        }\\n\\n        for (uint256 i = 0; i < expiration.seriesIds.length; i++) {\\n            uint256 seriesId = expiration.seriesIds[i];\\n            uint128 shortAmount = vault.shorts[seriesId];\\n            uint128 longAmount = vault.longs[seriesId];\\n\\n            if (shortAmount == 0 && longAmount == 0) {\\n                continue;\\n            }\\n\\n            IOptionVault.OptionSeriesParams memory seriesParams = getOptionSeriesParams(\\n                _optionInfo.serieses[seriesId],\\n                expiration.expiry\\n            );\\n\\n            if (_marginLevel == IOptionVault.MarginLevel.Safe) {\\n                requiredMargin += calMargin(\\n                    _optionInfo,\\n                    shortAmount.toInt128() - longAmount.toInt128(),\\n                    _spot,\\n                    seriesParams,\\n                    _marginLevel\\n                );\\n            } else {\\n                requiredMargin += calMargin(_optionInfo, shortAmount.toInt128(), _spot, seriesParams, _marginLevel);\\n            }\\n        }\\n    }\\n\\n    function getRequiredMarginForASeries(\\n        OptionInfo storage _optionInfo,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _spot,\\n        int128 _amount,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) public view returns (uint128) {\\n        uint64 expiry = _optionInfo.expiries[_expiryId].expiry;\\n\\n        IOptionVault.OptionSeries memory series = _optionInfo.serieses[_seriesId];\\n\\n        return calMargin(_optionInfo, _amount, _spot, getOptionSeriesParams(series, expiry), _marginLevel);\\n    }\\n\\n    /**\\n     * @notice get the total payout of a vault\\n     */\\n    function getTotalPayout(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        bool _roundUp\\n    ) public view returns (uint128 totalPayout) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n\\n        IOptionVault.Expiration memory expiration = _optionInfo.expiries[_expiryId];\\n\\n        for (uint256 i = 0; i < expiration.seriesIds.length; i++) {\\n            uint256 seriesId = expiration.seriesIds[i];\\n\\n            if (vault.shorts[seriesId] == 0) {\\n                continue;\\n            }\\n\\n            totalPayout += calculatePayout(\\n                vault.shorts[seriesId],\\n                _spot,\\n                _optionInfo.serieses[seriesId].strike,\\n                _optionInfo.serieses[seriesId].isPut,\\n                _roundUp\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate liquidatable amount\\n     * Calculate the liquidatable size so that the collateral of the size's premium + BASE_REWARD remains in vault\\n     */\\n    function calLiquidatableAmount(\\n        OptionInfo storage _optionInfo,\\n        uint128 _maintenanceMargin,\\n        uint128 _collateralValue,\\n        uint128 _spotOrStrike\\n    ) internal view returns (uint128 limit) {\\n        // maintenance margin - premium\\n        uint128 rewardDiffPerSize = (_spotOrStrike * _optionInfo.configs[REWARD_PER_SIZE_RATIO]) / (1000);\\n\\n        return\\n            (1e10 * (_optionInfo.configs[BASE_LIQ_REWARD] + _maintenanceMargin - _collateralValue)) / rewardDiffPerSize;\\n    }\\n\\n    /**\\n     * @notice get maturity\\n     */\\n    function getMaturity(uint64 _expiry) internal view returns (uint64 maturity) {\\n        maturity = _expiry > block.timestamp ? _expiry - uint64(block.timestamp) : 0;\\n    }\\n\\n    function getOptionSeriesParams(IOptionVault.OptionSeries memory _series, uint64 _expiry)\\n        internal\\n        view\\n        returns (IOptionVault.OptionSeriesParams memory)\\n    {\\n        uint64 maturity = getMaturity(_expiry);\\n\\n        return IOptionVault.OptionSeriesParams(_series.expiryId, maturity, _series.strike, _series.isPut, _series.iv);\\n    }\\n\\n    function checkOptionSeriesIsLive(IOptionVault.Expiration memory _expiration) internal view {\\n        require(_expiration.expiry > block.timestamp, \\\"OptionLib: option series has been expired\\\");\\n    }\\n\\n    function checkCollateral(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot\\n    ) internal view {\\n        require(\\n            getCollateralValue(_optionInfo, _accountId, _expiryId, _spot) >=\\n                getRequiredMargin(_optionInfo, _accountId, _expiryId, _spot, IOptionVault.MarginLevel.Initial),\\n            \\\"OptionLib: collateral is not enough\\\"\\n        );\\n    }\\n\\n    function getCollateralForASeries(\\n        OptionInfo storage _optionInfo,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _spot,\\n        uint128 _amount,\\n        uint128 _cRatio,\\n        bool _isPool\\n    ) internal view returns (uint128 collateral) {\\n        uint128 requiredMargin = getRequiredMarginForASeries(\\n            _optionInfo,\\n            _expiryId,\\n            _seriesId,\\n            _spot,\\n            _amount.toInt128(),\\n            _isPool ? IOptionVault.MarginLevel.Safe : IOptionVault.MarginLevel.Initial\\n        );\\n\\n        collateral = (1e6 * requiredMargin) / _cRatio;\\n    }\\n\\n    /**\\n     * @notice calculate required margin\\n     * there are 3 margin levels, Maintenance Margin, Initial Margin and Safe Margin.\\n     * Maintenance Margin: premium + mmRatio * spot\\n     * Initial Margin: premium + imRatio * spot\\n     * Safe Margin:\\n     *   120% of spot for short call\\n     *   200% of min(strike, spot) for short put\\n     *   200% of min(strike, spot) for long call\\n     *   120% of spot for long put\\n     */\\n    function calMargin(\\n        OptionInfo storage _optionInfo,\\n        int128 _u,\\n        uint128 _spot,\\n        IOptionVault.OptionSeriesParams memory _series,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) internal view returns (uint128) {\\n        if (_marginLevel == IOptionVault.MarginLevel.Maintenance || _marginLevel == IOptionVault.MarginLevel.Initial) {\\n            uint128 size = uint128(_u);\\n            // calculate as ATM if option is OTM\\n\\n            uint256 p = PriceCalculator.calculatePrice(\\n                _spot,\\n                _series.strike,\\n                _series.maturity,\\n                _series.iv,\\n                _series.isPut\\n            );\\n\\n            if (_marginLevel == IOptionVault.MarginLevel.Initial) {\\n                // initial margin\\n                if (_series.isPut) {\\n                    p += (_series.strike * _optionInfo.configs[IM_RATIO]) / (1000);\\n                } else {\\n                    p += (_spot * _optionInfo.configs[IM_RATIO]) / (1000);\\n                }\\n            } else {\\n                // maintenance margin\\n                if (_series.isPut) {\\n                    p += (_series.strike * _optionInfo.configs[MM_RATIO]) / (1000);\\n                } else {\\n                    p += (_spot * _optionInfo.configs[MM_RATIO]) / (1000);\\n                }\\n            }\\n\\n            return uint128(size * p) / 1e10;\\n        } else if (_marginLevel == IOptionVault.MarginLevel.Safe) {\\n            bool collateralForShort;\\n            uint128 size;\\n\\n            if (_u > 0) {\\n                size = uint128(_u);\\n                collateralForShort = _series.isPut;\\n            } else {\\n                size = uint128(-_u);\\n                collateralForShort = !_series.isPut;\\n            }\\n\\n            if (collateralForShort) {\\n                return\\n                    (size * PredyMath.min(_series.strike, _spot) * _optionInfo.configs[PUT_SAFE_RATIO]) / (1e10 * 1000);\\n            } else {\\n                return (size * _spot * _optionInfo.configs[CALL_SAFE_RATIO]) / (1e10 * 1000);\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice calculate payout\\n     * put: amount * max(K - S, 0)\\n     * call: amount * max(S - K, 0)\\n     */\\n    function calculatePayout(\\n        uint128 _u,\\n        uint128 _spot,\\n        uint128 _strike,\\n        bool _isPut,\\n        bool _isRoundUp\\n    ) internal pure returns (uint128) {\\n        uint128 r;\\n        if (_isPut && _strike > _spot) {\\n            r = _strike - _spot;\\n        } else if (!_isPut && _strike < _spot) {\\n            r = _spot - _strike;\\n        } else {\\n            return 0;\\n        }\\n        return PredyMath.mulDiv(_u, r, 1e10, _isRoundUp);\\n    }\\n\\n    function updateExpiredCount(OptionInfo storage _optionInfo, uint256 _expiryId) internal {\\n        IOptionVault.Expiration storage expiration = _optionInfo.expiries[_expiryId];\\n\\n        require(expiration.expiry < block.timestamp, \\\"expiry must have been passed\\\");\\n\\n        if (_optionInfo.expiredCount < _expiryId) {\\n            _optionInfo.expiredCount = uint128(_expiryId);\\n        }\\n    }\\n\\n    function calculateDelta(\\n        int256 _maturity,\\n        IOptionVault.OptionSeries memory _option,\\n        int256 _position,\\n        uint128 _spot\\n    ) internal pure returns (int256 delta) {\\n        return\\n            (_position * PriceCalculator.calculateDelta(_spot, _option.strike, _maturity, _option.iv, _option.isPut)) /\\n            int256(1e8);\\n    }\\n\\n    /**\\n     * @notice deposits USDC and borrows underlying asset from compound\\n     */\\n    function borrowUnderlyingInternal(\\n        OptionInfo storage _optionInfo,\\n        IOptionVault.Vault storage vault,\\n        uint128 _spot,\\n        uint256 _underlyingAmount\\n    ) internal {\\n        ERC20 underlying = ERC20(_optionInfo.tokens.underlying);\\n\\n        uint256 decimals = underlying.decimals();\\n\\n        uint128 depositCollateral = uint128(PredyMath.scale(_underlyingAmount * _spot * 2.0, decimals + 8, 6));\\n\\n        // deposit USDC to compound\\n        IERC20(_optionInfo.tokens.collateral).approve(address(_optionInfo.lendingPool), depositCollateral);\\n        _optionInfo.lendingPool.deposit(_optionInfo.tokens.collateral, depositCollateral, address(this), 0);\\n\\n        // borrow underling\\n        borrow(_optionInfo, _underlyingAmount);\\n\\n        require(vault.collateral >= depositCollateral, \\\"OptionLib: no enough collateral\\\");\\n\\n        depositCollateral = decreaseCollateral(vault, depositCollateral);\\n        vault.shortLiquidity += depositCollateral;\\n        _optionInfo.totalDepositedToLendingPool += depositCollateral;\\n    }\\n\\n    /**\\n     * @notice repays underlying asset and withdraws USDC from compound\\n     * @param _optionInfo option vault object\\n     * @param _vault the vault repaying underlying asset\\n     * @param _spot spot price\\n     * @param _underlyingAmount amount to repay\\n     * @param _remainingDebt The remaining debt after the repayment, scaled by 1e8.\\n     */\\n    function repayUnderlyingInternal(\\n        OptionInfo storage _optionInfo,\\n        IOptionVault.Vault storage _vault,\\n        uint128 _spot,\\n        uint256 _underlyingAmount,\\n        uint256 _remainingDebt\\n    ) internal {\\n        IERC20(_optionInfo.tokens.underlying).approve(address(_optionInfo.lendingPool), _underlyingAmount);\\n        repayBorrow(_optionInfo, _underlyingAmount);\\n\\n        // calculate unrequired collateral\\n        // if maturity is large, the protocol have to pay borrowing interest, and it can not redeem all shortLiquidity.\\n        // In this case, repay underling from outside of protocol.\\n        uint128 redeemCollateralAmount = _vault.shortLiquidity - (uint128(_remainingDebt) * _spot * 2) / 1e10;\\n\\n        _optionInfo.lendingPool.withdraw(_optionInfo.tokens.collateral, redeemCollateralAmount, address(this));\\n\\n        increaseCollateral(_vault, redeemCollateralAmount);\\n\\n        _vault.shortLiquidity -= redeemCollateralAmount;\\n        _optionInfo.totalDepositedToLendingPool -= redeemCollateralAmount;\\n    }\\n\\n    /**\\n     * @notice borrow underlying asset with Variable type debt\\n     */\\n    function borrow(OptionInfo storage _optionInfo, uint256 _amount) internal {\\n        _optionInfo.lendingPool.borrow(_optionInfo.tokens.underlying, _amount, 2, 0, address(this));\\n    }\\n\\n    /**\\n     * @notice repay borrowing underlying asset with Variable type debt\\n     */\\n    function repayBorrow(OptionInfo storage _optionInfo, uint256 _amount) internal returns (uint128) {\\n        return uint128(_optionInfo.lendingPool.repay(_optionInfo.tokens.underlying, _amount, 2, address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/PriceCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AdvancedMath.sol\\\";\\n\\n/**\\n * @notice Option price calculator using Black-Scholes formula\\n */\\nlibrary PriceCalculator {\\n    /// @dev sqrt(365 * 86400)\\n    int256 internal constant SQRT_YEAR_E8 = 5615.69229926 * 10**8;\\n    /// @dev range size of linear function\\n    int256 internal constant RANGE = 20 * 1e6;\\n\\n    struct Parameters {\\n        // spot price\\n        int256 spot;\\n        // strike price\\n        int256 strike;\\n        // log(spot / strike)\\n        int256 logSigE4;\\n        // sqrt(maturity)\\n        int256 sqrtMaturity;\\n    }\\n\\n    /**\\n     * @notice calculate option price at a IV point\\n     * @param _spot spot price scaled 1e8\\n     * @param _strike strike price scaled 1e8\\n     * @param _maturity maturity in seconds\\n     * @param _iv IV\\n     * @param _isPut option type\\n     * @return premium per amount\\n     */\\n    function calculatePrice(\\n        uint256 _spot,\\n        uint256 _strike,\\n        uint256 _maturity,\\n        uint256 _iv,\\n        bool _isPut\\n    ) external pure returns (uint256 premium) {\\n        validateParameters(_spot, _strike);\\n        require(0 < _iv && _iv < 1000 * 1e6, \\\"PriceCalculator: implied volatility must be between 0 and 1000%\\\");\\n\\n        int256 sqrtMaturity = getSqrtMaturity(_maturity);\\n        int256 logSigE4;\\n        {\\n            int256 spotPerStrikeE4 = int256((_spot * 1e4) / _strike);\\n            logSigE4 = AdvancedMath.logTaylor(spotPerStrikeE4);\\n        }\\n\\n        return\\n            uint256(\\n                calOptionPrice(\\n                    Parameters(int256(_spot), int256(_strike), logSigE4, sqrtMaturity),\\n                    int256(_iv),\\n                    _isPut,\\n                    // calculatePrice function never reverts by delta cut-off\\n                    0\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice calculate option price with two IV points\\n     * @param _spot spot price scaled 1e8\\n     * @param _strike strike price scaled 1e8\\n     * @param _maturity maturity in seconds\\n     * @param _x0 start IV\\n     * @param _x1 end IV\\n     * @param _isPut option type\\n     * @param _minDelta minimum delta. if delta is less than minDelta or greater than (100% - minDelta), calculation reverts\\n     * @return premium per amount\\n     */\\n    function calculatePrice2(\\n        uint256 _spot,\\n        uint256 _strike,\\n        uint256 _maturity,\\n        uint256 _x0,\\n        uint256 _x1,\\n        bool _isPut,\\n        uint256 _minDelta\\n    ) external pure returns (uint256 premium) {\\n        validateParameters(_spot, _strike);\\n        require(0 < _x0 && _x0 < 10 * 1e8, \\\"PriceCalculator: 0 < x0 < 1000%\\\");\\n        require(0 < _x1 && _x1 < 10 * 1e8, \\\"PriceCalculator: 0 < x1 < 1000%\\\");\\n        require(_x0 < _x1, \\\"PriceCalculator: _x0 < _x1\\\");\\n\\n        int256 sqrtMaturity = getSqrtMaturity(_maturity);\\n\\n        int256 logSigE4;\\n        {\\n            int256 spotPerStrikeE4 = int256((_spot * 1e4) / _strike);\\n            logSigE4 = AdvancedMath.logTaylor(spotPerStrikeE4);\\n        }\\n\\n        return\\n            uint256(\\n                calculatePriceOfRanges(\\n                    Parameters(int256(_spot), int256(_strike), logSigE4, sqrtMaturity),\\n                    int256(_x0),\\n                    int256(_x1),\\n                    _isPut,\\n                    _minDelta\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice calculate option's delta\\n     * @param _spot spot price scaled 1e8\\n     * @param _strike strike price scaled 1e8\\n     * @param sqrtMaturity maturity in seconds\\n     * @param _iv IV\\n     * @param _isPut option type\\n     * @return delta\\n     */\\n    function calculateDelta(\\n        uint256 _spot,\\n        uint256 _strike,\\n        int256 sqrtMaturity,\\n        uint256 _iv,\\n        bool _isPut\\n    ) external pure returns (int256) {\\n        validateParameters(_spot, _strike);\\n        require(0 < _iv && _iv < 1000 * 1e6, \\\"PriceCalculator: implied volatility must be between 0 and 1000%\\\");\\n\\n        int256 logSigE4;\\n        {\\n            int256 spotPerStrikeE4 = int256((_spot * 1e4) / _strike);\\n            logSigE4 = AdvancedMath.logTaylor(spotPerStrikeE4);\\n        }\\n        (int256 d1E4, ) = _calD1D2(logSigE4, sqrtMaturity, int256(_iv));\\n        if (_isPut) {\\n            return -AdvancedMath.calStandardNormalCDF(-d1E4);\\n        } else {\\n            return AdvancedMath.calStandardNormalCDF(d1E4);\\n        }\\n    }\\n\\n    function getSqrtMaturity(uint256 _maturity) public pure returns (int256) {\\n        require(\\n            _maturity > 0 && _maturity < 31536000,\\n            \\\"PriceCalculator: maturity must not have expired and less than 1 year\\\"\\n        );\\n\\n        return (AdvancedMath.sqrt(int256(_maturity)) * 1e16) / SQRT_YEAR_E8;\\n    }\\n\\n    function calculatePriceOfRanges(\\n        Parameters memory _params,\\n        int256 _x0,\\n        int256 _x1,\\n        bool _isPut,\\n        uint256 _minDelta\\n    ) internal pure returns (int256 premium) {\\n        int256 lower = _x0 / RANGE;\\n        int256 upper = _x1 / RANGE;\\n        int256 cache;\\n        for (int256 i = lower; i <= upper; i++) {\\n            int256 x0 = 0;\\n            int256 x1 = RANGE;\\n            if (i == lower) {\\n                x0 = _x0 - i * RANGE;\\n            }\\n            if (i == upper) {\\n                x1 = _x1 - i * RANGE;\\n            }\\n            int256 p;\\n            (p, cache) = calculatePriceOfRange(_params, i, x0, x1, _isPut, cache, _minDelta);\\n            premium += p;\\n        }\\n        premium /= upper - lower + 1;\\n    }\\n\\n    function calculatePriceOfRange(\\n        Parameters memory _params,\\n        int256 _tick,\\n        int256 _x0,\\n        int256 _x1,\\n        bool _isPut,\\n        int256 _start,\\n        uint256 _minDelta\\n    ) internal pure returns (int256, int256) {\\n        if (_start == 0) {\\n            _start = calOptionPrice(_params, _tick * RANGE, _isPut, _minDelta);\\n        }\\n        int256 end = calOptionPrice(_params, (_tick + 1) * RANGE, _isPut, _minDelta);\\n        // y = (end - start)/RANGE * x + start + instrict\\n        return ((_start + ((end - _start) * (_x1 + _x0)) / (2 * RANGE)), end);\\n    }\\n\\n    function _calD1D2(\\n        int256 _logSigE4,\\n        int256 _sqrtMaturity,\\n        int256 _volatilityE8\\n    ) internal pure returns (int256 d1E4, int256 d2E4) {\\n        int256 sigE8 = (_volatilityE8 * _sqrtMaturity) / (1e8);\\n        d1E4 = ((_logSigE4 * 10**8) / sigE8) + (sigE8 / (2 * 10**4));\\n        d2E4 = d1E4 - (sigE8 / 10**4);\\n    }\\n\\n    function calOptionPrice(\\n        Parameters memory _params,\\n        int256 _volatility,\\n        bool _isPut,\\n        uint256 _minDelta\\n    ) internal pure returns (int256 price) {\\n        int256 nd1E8;\\n\\n        if (_volatility > 0) {\\n            (int256 d1E4, int256 d2E4) = _calD1D2(_params.logSigE4, _params.sqrtMaturity, _volatility);\\n            nd1E8 = AdvancedMath.calStandardNormalCDF(d1E4);\\n            int256 nd2E8 = AdvancedMath.calStandardNormalCDF(d2E4);\\n            price = (_params.spot * nd1E8 - _params.strike * nd2E8) / 1e8;\\n        }\\n        int256 lowestPrice;\\n        if (_isPut) {\\n            price = price - _params.spot + _params.strike;\\n\\n            lowestPrice = (_params.strike > _params.spot) ? _params.strike - _params.spot : int256(0);\\n        } else {\\n            lowestPrice = (_params.spot > _params.strike) ? _params.spot - _params.strike : int256(0);\\n        }\\n\\n        // delta cut-off\\n        // if option type is put, delta is `1 - N(d1)`\\n        // if option type is call, delta is `N(d1)`\\n        require((!_isPut && abs(nd1E8) >= _minDelta) || (_isPut && 1e8 - abs(nd1E8) >= _minDelta), \\\"delta is too low\\\");\\n\\n        if (price < lowestPrice) {\\n            return lowestPrice;\\n        }\\n\\n        return price;\\n    }\\n\\n    function validateParameters(uint256 _spot, uint256 _strike) internal pure {\\n        require(_spot > 0 && _spot < 1e13, \\\"PriceCalculator: spot price must be between 0 and 10^13\\\");\\n        require(_strike > 0 && _strike < 1e13, \\\"PriceCalculator: strike price must be between 0 and 10^13\\\");\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAave.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface LendingPool {\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 rateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AdvancedMath.sol\": {\r\n      \"content\": \"/// from https://github.com/LienFinance/bondmaker\\npragma solidity ^0.8.0;\\n\\nlibrary AdvancedMath {\\n    /// @dev sqrt(2*PI) * 10^8\\n    int256 internal constant SQRT_2PI_E8 = 250662827;\\n    /// @dev PI * 10^8\\n    int256 internal constant PI_E8 = 314159265;\\n    /// @dev Napier's constant\\n    int256 internal constant E_E8 = 271828182;\\n    /// @dev Inverse of Napier's constant (1/e)\\n    int256 internal constant INV_E_E8 = 36787944;\\n\\n    // for CDF\\n    int256 internal constant p = 23164190;\\n    int256 internal constant b1 = 31938153;\\n    int256 internal constant b2 = -35656378;\\n    int256 internal constant b3 = 178147793;\\n    int256 internal constant b4 = -182125597;\\n    int256 internal constant b5 = 133027442;\\n\\n    /**\\n     * @dev Calculate an approximate value of the square root of x by Babylonian method.\\n     */\\n    function sqrt(int256 x) internal pure returns (int256 y) {\\n        require(x >= 0, \\\"cannot calculate the square root of a negative number\\\");\\n        int256 z = (x + 1) / 2;\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns log(x) for any positive x.\\n     */\\n    function logTaylor(int256 inputE4) internal pure returns (int256 outputE4) {\\n        require(inputE4 > 1, \\\"input should be positive number\\\");\\n        int256 inputE8 = inputE4 * 1e4;\\n        // input x for _logTaylor1 is adjusted to 1/e < x < 1.\\n        while (inputE8 < INV_E_E8) {\\n            inputE8 = (inputE8 * E_E8) / 1e8;\\n            outputE4 -= 1e4;\\n        }\\n        while (inputE8 > 1e8) {\\n            inputE8 = (inputE8 * INV_E_E8) / 1e8;\\n            outputE4 += 1e4;\\n        }\\n        outputE4 += logTaylor1(inputE8 / 1e4 - 1e4);\\n    }\\n\\n    /**\\n     * @notice Calculate an approximate value of the logarithm of input value by\\n     * Taylor expansion around 1.\\n     * @dev log(x + 1) = x - 1/2 x^2 + 1/3 x^3 - 1/4 x^4 + 1/5 x^5\\n     *                     - 1/6 x^6 + 1/7 x^7 - 1/8 x^8 + ...\\n     */\\n    function logTaylor1(int256 inputE4) internal pure returns (int256 outputE4) {\\n        outputE4 =\\n            inputE4 -\\n            inputE4**2 /\\n            (2 * 1e4) +\\n            inputE4**3 /\\n            (3 * 1e8) -\\n            inputE4**4 /\\n            (4 * 1e12) +\\n            inputE4**5 /\\n            (5 * 1e16) -\\n            inputE4**6 /\\n            (6 * 1e20) +\\n            inputE4**7 /\\n            (7 * 1e24) -\\n            inputE4**8 /\\n            (8 * 1e28);\\n    }\\n\\n    /**\\n     * @notice Calculate the cumulative distribution function of standard normal\\n     * distribution.\\n     * @dev Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\\n     * http://people.math.sfu.ca/~cbm/aands/\\n     * errors are less than 0.7% at -3.2\\n     */\\n    function calStandardNormalCDF(int256 inputE4) internal pure returns (int256 outputE8) {\\n        require(inputE4 < 440 * 1e4 && inputE4 > -440 * 1e4, \\\"input is too large\\\");\\n        int256 _inputE4 = inputE4 > 0 ? inputE4 : inputE4 * (-1);\\n        int256 t = 1e16 / (1e8 + (p * _inputE4) / 1e4);\\n        int256 X2 = (inputE4 * inputE4) / 2;\\n        int256 X3 = (X2 * X2) / 1e8;\\n        int256 X4 = (X3 * X2) / 1e8;\\n        int256 exp2X2 = 1e8 +\\n            X2 +\\n            (X3 / 2) +\\n            (X4 / 6) +\\n            ((X3 * X3) / (24 * 1e8)) +\\n            ((X2 * (X3 * X3)) / (120 * 1e16)) +\\n            ((X4 * X4) / (720 * 1e8)) +\\n            ((X2 * (X4 * X4)) / (5040 * 1e16)) +\\n            ((X3 * (X4 * X4)) / (40320 * 1e16)) +\\n            ((X4 * X4 * X4) / (362880 * 1e16)) +\\n            ((X2 * (X4 * X4 * X4)) / (3628800 * 1e24)) +\\n            ((X3 * (X4 * X4 * X4)) / (39916800 * 1e24));\\n\\n        int256 Z = (1e24 / exp2X2) / SQRT_2PI_E8;\\n        int256 y = (b5 * t) / 1e8;\\n        y = ((y + b4) * t) / 1e8;\\n        y = ((y + b3) * t) / 1e8;\\n        y = ((y + b2) * t) / 1e8;\\n        y = 1e8 - (Z * ((y + b1) * t)) / 1e16;\\n        return inputE4 > 0 ? y : 1e8 - y;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/lib/AMMLib.sol\": {\r\n        \"AMMLib\": \"0xa6d727b729b3f429efe5742b4488f2e65e04d128\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optionContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"key\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAllowedUntil\",\"type\":\"uint256\"}],\"name\":\"DepositAllowedUntilUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"mint\",\"type\":\"uint128\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEmergencyMode\",\"type\":\"bool\"}],\"name\":\"EmergencyStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"LockupPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"premium\",\"type\":\"uint128\"}],\"name\":\"OptionBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"premium\",\"type\":\"uint128\"}],\"name\":\"OptionSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"protocolFee\",\"type\":\"uint128\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"burn\",\"type\":\"uint128\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxFee\",\"type\":\"uint128\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_size\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"_isSelling\",\"type\":\"bool\"}],\"name\":\"calculatePremium\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEmergencyMode\",\"type\":\"bool\"}],\"name\":\"changeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_mintAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxDeposit\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_tickStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tickEnd\",\"type\":\"uint32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePool\",\"outputs\":[{\"internalType\":\"contract IFeePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tickStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tickEnd\",\"type\":\"uint32\"}],\"name\":\"genRangeId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_key\",\"type\":\"uint8\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_depositAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_tickStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tickEnd\",\"type\":\"uint32\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tickId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"getProfitState\",\"outputs\":[{\"components\":[{\"internalType\":\"int128\",\"name\":\"unrealizedPnL\",\"type\":\"int128\"},{\"internalType\":\"uint128\",\"name\":\"cumulativeFee\",\"type\":\"uint128\"}],\"internalType\":\"struct AMMLib.Profit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_rangeId\",\"type\":\"uint128\"}],\"name\":\"getRange\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"_start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_end\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tickLower\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tickUpper\",\"type\":\"uint32\"}],\"name\":\"getSecondsPerLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tickId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"}],\"name\":\"getSeriesState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"tickId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"lastPricePerSize\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"tradeTime\",\"type\":\"uint128\"}],\"internalType\":\"struct AMMLib.LockedOptionStatePerTick\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tickStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tickEnd\",\"type\":\"uint32\"}],\"name\":\"getTicks\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"supply\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"unrealizedPnL\",\"type\":\"int128\"},{\"internalType\":\"uint128\",\"name\":\"lastSupply\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lastBalance\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"secondsPerLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"burnReserved\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"reservationForWithdrawal\",\"type\":\"uint128\"}],\"internalType\":\"struct AMMLib.Tick[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_burnAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_tickStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tickEnd\",\"type\":\"uint32\"}],\"name\":\"getWithdrawableAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastProvidedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tickId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"rebalanceCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reservations\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"burn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawableTimestamp\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_reserveAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_rangeId\",\"type\":\"uint128\"}],\"name\":\"reserveWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_minFee\",\"type\":\"uint128\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"setAddressAllowedSkippingLockup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_key\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_value\",\"type\":\"uint128\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositAllowedUntil\",\"type\":\"uint256\"}],\"name\":\"setDepositAllowedUntil\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockupPeriod\",\"type\":\"uint256\"}],\"name\":\"setLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setNewOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_burnAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_minWithdrawal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_rangeId\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"_useReservation\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AMM","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000008feebd1fd65b6706b2837792c5dfa5b569c4cea700000000000000000000000066fbaad82083716343b9413caeb77aa13a8053a40000000000000000000000004f071924d66bbc71a5254217893cc7d49938b1c4000000000000000000000000a73029d664a835f1429d40cd2cc0b785fd056157000000000000000000000000000000000000000000000000000000000000002568747470733a2f2f7572692e70726564792e66696e616e63652f76312f6c70746f6b656e73000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}