{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ISquuid.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ISquuid {\r\n\r\n  // struct to store each token's traits\r\n  struct PlayerGuard {\r\n    bool isPlayer;\r\n    uint8 colors;\r\n    uint8 head;\r\n    uint8 numbers;\r\n    uint8 shapes;\r\n    uint8 nose;\r\n    uint8 accessories;\r\n    uint8 guns;\r\n    uint8 feet;\r\n    uint8 alphaIndex;\r\n  }\r\n\r\n\r\n  function getPaidTokens() external view returns (uint256);\r\n  function getTokenTraits(uint256 tokenId) external view returns (PlayerGuard memory);\r\n}\r\n// File: contracts/ITraits.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITraits {\r\n  function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n// File: contracts/Strings.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/Traits.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract Traits is Ownable, ITraits {\r\n\r\n  using Strings for uint256;\r\n\r\n  // struct to store each trait's data for metadata and rendering\r\n  struct Trait {\r\n    string name;\r\n    string png;\r\n  }\r\n\r\n  // mapping from trait type (index) to its name\r\n  string[9] _traitTypes = [\r\n    \"Colors\",\r\n    \"Head\",\r\n    \"Numbers\",\r\n    \"Shapes\",\r\n    \"Nose\",\r\n    \"Accessories\",\r\n    \"Guns\",\r\n    \"Feet\",\r\n    \"Alpha\"\r\n  ];\r\n  // storage of each traits name and base64 PNG data\r\n  mapping(uint8 => mapping(uint8 => Trait)) public traitData;\r\n  // mapping from alphaIndex to its score\r\n  string[4] _alphas = [\r\n    \"8\",\r\n    \"7\",\r\n    \"6\",\r\n    \"5\"\r\n  ];\r\n\r\n  ISquuid public squuid;\r\n\r\n  constructor() {}\r\n\r\n  /** ADMIN */\r\n\r\n  function setSquuid(address _squuid) external onlyOwner {\r\n    squuid = ISquuid(_squuid);\r\n  }\r\n\r\n  /**\r\n   * administrative to upload the names and images associated with each trait\r\n   * @param traitType the trait type to upload the traits for (see traitTypes for a mapping)\r\n   * @param traits the names and base64 encoded PNGs for each trait\r\n   */\r\n  function uploadTraits(uint8 traitType, uint8[] calldata traitIds, Trait[] calldata traits) external onlyOwner {\r\n    require(traitIds.length == traits.length, \"Mismatched inputs\");\r\n    for (uint i = 0; i < traits.length; i++) {\r\n      traitData[traitType][traitIds[i]] = Trait(\r\n        traits[i].name,\r\n        traits[i].png\r\n      );\r\n    }\r\n  }\r\n\r\n  /** RENDER */\r\n\r\n  /**\r\n   * generates an <image> element using base64 encoded PNGs\r\n   * @param trait the trait storing the PNG data\r\n   * @return the <image> element\r\n   */\r\n  function drawTrait(Trait memory trait) internal pure returns (string memory) {\r\n    return string(abi.encodePacked(\r\n      '<image x=\"4\" y=\"4\" width=\"32\" height=\"32\" image-rendering=\"pixelated\" preserveAspectRatio=\"xMidYMid\" xlink:href=\"data:image/png;base64,',\r\n      trait.png,\r\n      '\"/>'\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * generates an entire SVG by composing multiple <image> elements of PNGs\r\n   * @param tokenId the ID of the token to generate an SVG for\r\n   * @return a valid SVG of the Player / Guard\r\n   */\r\n  function drawSVG(uint256 tokenId) public view returns (string memory) {\r\n    ISquuid.PlayerGuard memory s = squuid.getTokenTraits(tokenId);\r\n    uint8 shift = s.isPlayer ? 0 : 9;\r\n\r\n    string memory svgString = string(abi.encodePacked(\r\n      drawTrait(traitData[0 + shift][s.colors]),\r\n      s.isPlayer ? drawTrait(traitData[1 + shift][s.head]) : drawTrait(traitData[1 + shift][s.alphaIndex]),\r\n      s.isPlayer ? drawTrait(traitData[2 + shift][s.numbers]) : '',\r\n      drawTrait(traitData[3 + shift][s.shapes]),\r\n      s.isPlayer ? drawTrait(traitData[4 + shift][s.nose]) : '',\r\n      drawTrait(traitData[5 + shift][s.accessories]),\r\n      s.isPlayer ? '' : drawTrait(traitData[6 + shift][s.guns]),\r\n      s.isPlayer ? drawTrait(traitData[7 + shift][s.feet]) : ''\r\n    ));\r\n\r\n    return string(abi.encodePacked(\r\n      '<svg id=\"squuid\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\r\n      svgString,\r\n      \"</svg>\"\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * generates an attribute for the attributes array in the ERC721 metadata standard\r\n   * @param traitType the trait type to reference as the metadata key\r\n   * @param value the token's trait associated with the key\r\n   * @return a JSON dictionary for the single attribute\r\n   */\r\n  function attributeForTypeAndValue(string memory traitType, string memory value) internal pure returns (string memory) {\r\n    return string(abi.encodePacked(\r\n      '{\"trait_type\":\"',\r\n      traitType,\r\n      '\",\"value\":\"',\r\n      value,\r\n      '\"}'\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * generates an array composed of all the individual traits and values\r\n   * @param tokenId the ID of the token to compose the metadata for\r\n   * @return a JSON array of all of the attributes for given token ID\r\n   */\r\n  function compileAttributes(uint256 tokenId) public view returns (string memory) {\r\n    ISquuid.PlayerGuard memory s = squuid.getTokenTraits(tokenId);\r\n    string memory traits;\r\n    if (s.isPlayer) {\r\n      traits = string(abi.encodePacked(\r\n        attributeForTypeAndValue(_traitTypes[0], traitData[0][s.colors].name),',',\r\n        attributeForTypeAndValue(_traitTypes[1], traitData[1][s.head].name),',',\r\n        attributeForTypeAndValue(_traitTypes[2], traitData[2][s.numbers].name),',',\r\n        attributeForTypeAndValue(_traitTypes[3], traitData[3][s.shapes].name),',',\r\n        attributeForTypeAndValue(_traitTypes[4], traitData[4][s.nose].name),',',\r\n        attributeForTypeAndValue(_traitTypes[5], traitData[5][s.accessories].name),',',\r\n        attributeForTypeAndValue(_traitTypes[7], traitData[7][s.feet].name),','\r\n      ));\r\n    } else {\r\n      traits = string(abi.encodePacked(\r\n        attributeForTypeAndValue(_traitTypes[0], traitData[9][s.colors].name),',',\r\n        attributeForTypeAndValue(_traitTypes[1], traitData[10][s.alphaIndex].name),',',\r\n        attributeForTypeAndValue(_traitTypes[3], traitData[12][s.shapes].name),',',\r\n        attributeForTypeAndValue(_traitTypes[5], traitData[14][s.accessories].name),',',\r\n        attributeForTypeAndValue(_traitTypes[6], traitData[15][s.guns].name),',',\r\n        attributeForTypeAndValue(\"Alpha Score\", _alphas[s.alphaIndex]),','\r\n      ));\r\n    }\r\n    return string(abi.encodePacked(\r\n      '[',\r\n      traits,\r\n      '{\"trait_type\":\"Generation\",\"value\":',\r\n      tokenId <= squuid.getPaidTokens() ? '\"Gen 0\"' : '\"Gen 1\"',\r\n      '},{\"trait_type\":\"Type\",\"value\":',\r\n      s.isPlayer ? '\"Player\"' : '\"Guard\"',\r\n      '}]'\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * generates a base64 encoded metadata response without referencing off-chain content\r\n   * @param tokenId the ID of the token to generate the metadata for\r\n   * @return a base64 encoded JSON dictionary of the token's metadata and SVG\r\n   */\r\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n    ISquuid.PlayerGuard memory s = squuid.getTokenTraits(tokenId);\r\n\r\n    string memory metadata = string(abi.encodePacked(\r\n      '{\"name\": \"',\r\n      s.isPlayer ? 'Player #' : 'Guard #',\r\n      tokenId.toString(),\r\n      '\", \"description\": \"Thousands of Player and Wolves compete on a farm in the metaverse. A tempting prize of $SQUID awaits, with deadly high stakes. All the metadata and images are generated and stored 100% on-chain. No IPFS. NO API. Just the Ethereum blockchain.\", \"image\": \"data:image/svg+xml;base64,',\r\n      base64(bytes(drawSVG(tokenId))),\r\n      '\", \"attributes\":',\r\n      compileAttributes(tokenId),\r\n      \"}\"\r\n    ));\r\n\r\n    return string(abi.encodePacked(\r\n      \"data:application/json;base64,\",\r\n      base64(bytes(metadata))\r\n    ));\r\n  }\r\n\r\n  /** BASE 64 - Written by Brech Devos */\r\n  \r\n  string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n  function base64(bytes memory data) internal pure returns (string memory) {\r\n    if (data.length == 0) return '';\r\n    \r\n    // load the table into memory\r\n    string memory table = TABLE;\r\n\r\n    // multiply by 4/3 rounded up\r\n    uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n    // add some extra buffer at the end required for the writing\r\n    string memory result = new string(encodedLen + 32);\r\n\r\n    assembly {\r\n      // set the actual output length\r\n      mstore(result, encodedLen)\r\n      \r\n      // prepare the lookup table\r\n      let tablePtr := add(table, 1)\r\n      \r\n      // input ptr\r\n      let dataPtr := data\r\n      let endPtr := add(dataPtr, mload(data))\r\n      \r\n      // result ptr, jump over length\r\n      let resultPtr := add(result, 32)\r\n      \r\n      // run over the input, 3 bytes at a time\r\n      for {} lt(dataPtr, endPtr) {}\r\n      {\r\n          dataPtr := add(dataPtr, 3)\r\n          \r\n          // read 3 bytes\r\n          let input := mload(dataPtr)\r\n          \r\n          // write 4 characters\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n      }\r\n      \r\n      // padding with '='\r\n      switch mod(mload(data), 3)\r\n      case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\r\n      case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"compileAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"drawSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_squuid\",\"type\":\"address\"}],\"name\":\"setSquuid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"squuid\",\"outputs\":[{\"internalType\":\"contract ISquuid\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"png\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"traitType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"traitIds\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"png\",\"type\":\"string\"}],\"internalType\":\"struct Traits.Trait[]\",\"name\":\"traits\",\"type\":\"tuple[]\"}],\"name\":\"uploadTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Traits","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://018733f7742c445299fb1e81f528e1c66889b65b69964b690306a2ee4f376c2c"}]}