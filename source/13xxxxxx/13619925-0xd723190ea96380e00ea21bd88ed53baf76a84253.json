{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SnakeBackend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC-BY-4.0\\n\\npragma solidity >= 0.8.0;\\n\\nimport \\\"./IArcadeBackend.sol\\\";\\n\\ncontract SnakeBackend is IArcadeBackend {\\n\\n    address controller;\\n\\n    string constant svgWrapper1 = \\\"<svg viewBox='0 0 11 17' fill='none' xmlns='http://www.w3.org/2000/svg'><rect x='.5' y='.5' width='10' height='16' fill='#221D42'/><rect x='.5' y='.5' width='10' height='10' fill='#07060E'/><rect x='.5' y='.5' width='10' height='10' stroke='#221D42'/><rect x='.5' y='.5' width='10' height='16' stroke='#221D42'/>\\\";\\n    string constant svgWrapper2 = \\\"</g></svg>\\\";\\n\\n    string constant pixelTemplate0a = \\\"<rect><animate id='stop' being='0s' dur='\\\";\\n    string constant pixelTemplate0b = \\\"s' fill='freeze'/></rect>\\\";\\n    string constant pixelTemplate1Head = \\\"<rect rx='0.2' width='1' opacity='0' height='1' fill='#5E05CE'><animateMotion begin='\\\";\\n    string constant pixelTemplate1 = \\\"<rect rx='0.2' width='1' opacity='0' height='1' fill='#8C3BE5'><animateMotion begin='\\\";\\n    string constant pixelTemplate2 = \\\"s' end='stop.end' dur='\\\";\\n    string constant pixelTemplate3 = \\\"s' fill='freeze'><mpath href='#p1'/></animateMotion><animate begin='\\\";\\n    string constant pixelTemplate4 = \\\"s' attributeName='opacity' values='1' fill='freeze' /></rect>\\\";\\n\\n    string constant pixelTemplateStatic1Head = \\\"<rect rx='0.2' width='1' height='1' fill='#5e05ce' x='\\\";\\n    string constant pixelTemplateStatic1 = \\\"<rect rx='0.2' width='1' height='1' fill='#8c3be5' x='\\\";\\n    string constant pixelTemplateStatic2 = \\\"' y='\\\";\\n    string constant pixelTemplateStatic3 = \\\"' />\\\";\\n\\n    string constant blinkingAnimationTemplate1 = \\\"<g><animate attributeName='opacity' values='0;1;' dur='1s' calcMode='discrete' begin='\\\";\\n    string constant blinkingAnimationTemplate2 = \\\"' repeatCount='5'/>\\\";\\n\\n    string constant applePixelTemplateStatic1 = \\\"<g><rect rx='0.2' width='1' height='1' fill='#c82b76' x='\\\";\\n    \\n    string  constant numbersTemplate1 = \\\"<path d='M \\\";\\n\\n    string  constant appleTemplate1 = \\\"<rect rx='0.2' x='\\\";\\n    string  constant appleTemplate2 = \\\"' y='\\\";\\n    string  constant appleTemplate3 = \\\"' opacity='0' width='1' height='1' fill='#C82B76'><animate begin='\\\";\\n    string  constant appleTemplate4 = \\\"s' attributeName='opacity' values='1' fill='freeze' /><animate begin='\\\";\\n    string  constant appleTemplate5 = \\\"s' attributeName='opacity' values='0' fill='freeze' /></rect>\\\";\\n    string  constant appleTemplate4alt = \\\"s' attributeName='opacity' values='1' fill='freeze' /></rect>\\\";\\n\\n\\n    string  constant animatedNumberTemplate1 = \\\"' opacity='0' stroke='#fff'><animate begin='\\\";\\n    string  constant animatedNumberTemplate2 = \\\"s' attributeName='opacity' values='1' fill='freeze' /><animate begin='\\\";\\n    string  constant animatedNumberTemplate3 = \\\"s' attributeName='opacity' values='0' fill='freeze' /></path>\\\";\\n    string  constant animatedNumberTemplate2alt = \\\"s' attributeName='opacity' values='1' fill='freeze' /></path>\\\";\\n\\n\\n    string  constant pathTemplate1 = \\\"<path d='M \\\";\\n    string  constant pathTemplate2 = \\\"' id='p1'/>\\\";\\n\\n    function getLeftNumber(uint number) internal pure returns (string memory _svgCode) {\\n       return [\\n            \\\"2.5 11.5 h 2 v 4 h -2 v -4.5\\\",\\n            \\\"3 11.5 h 1.5 v 4.5\\\",\\n            \\\"2 11.5 h 2.5 v 2 h -2 v 2 h 2.5\\\",\\n            \\\"2 11.5 h 2.5 v 2 h -2.5 h 2.5 v 2 h -2.5\\\",\\n            \\\"2.5 11 v 2.5 h 2 v 2.5 v -5\\\"\\n        ][number];\\n    }\\n\\n    function getRightNumber(uint number) internal pure returns (string memory _svgCode) {\\n        return [\\n            \\\"6 11.5 h 2.5 v 4 h -2 v -3.5\\\",\\n            \\\"7 11.5 h 1.5 v 4.5\\\",\\n            \\\"6 11.5 h 2.5 v 2 h -2 v 2 h 2.5\\\",\\n            \\\"6 11.5 h 2.5 v 2 h -2.5 h 2.5 v 2 h -2.5\\\",\\n            \\\"6.5 11 v 2.5 h 2 v -2.5 v 5\\\",\\n            \\\"9 11.5 h -2.5 v 2 h 2 v 2 h -2.5\\\",\\n            \\\"6.5 11 v 4.5 h 2 v -2 h -2.5\\\",\\n            \\\"6 11.5 h 2.5 v 2.5 M 7.5 14 v 2\\\",\\n            \\\"6 11.5 h 2.5 v 2 h -2 v -2.5 v 4.5 h 2 v -2.5\\\",\\n            \\\"9 13.5 h -2.5 v -2 h 2 v 4.5\\\"\\n        ][number];\\n    }\\n\\n    string constant numbersTemplate2 = \\\"' stroke='#fff'/>\\\";\\n\\n    uint constant INITIAL_SNAIL_LENGTH = 3;\\n    uint constant GRID_SIZE = 11;\\n    uint constant appleShift = GRID_SIZE + 1;\\n    uint constant validRowSlotCount = GRID_SIZE - 2;\\n    uint constant SPEED = 256;\\n    uint constant MAX_INT = (1 << 256) - 1;\\n    uint constant validPositionsCount = validRowSlotCount * validRowSlotCount;\\n    uint[validPositionsCount] validPositions;\\n    \\n    uint WALL_MASK;\\n\\n    modifier onlyController() {\\n        require(controller == msg.sender, \\\"Not allowed.\\\");\\n        _;\\n    }\\n\\n    constructor (address _controller) {\\n        uint boundary = GRID_SIZE - 1;\\n        for(uint i = 0; i < GRID_SIZE; i++) {\\n            WALL_MASK = WALL_MASK | (1 << i);\\n            WALL_MASK = WALL_MASK | (1 << (i * GRID_SIZE));\\n            WALL_MASK = WALL_MASK | (1 << (boundary * GRID_SIZE + i));\\n            WALL_MASK = WALL_MASK | (1 << (i * GRID_SIZE + boundary));\\n        }\\n   \\n        uint lastPosition = 0;\\n        for(uint x = 1; x < GRID_SIZE - 1; x++) {\\n            for(uint y = 1; y < GRID_SIZE - 1; y++) {\\n                lastPosition = 1 << (x * GRID_SIZE) << y;\\n                validPositions[(x - 1) * validRowSlotCount + (y - 1)] = lastPosition;\\n            }\\n        }\\n\\n        controller = _controller;\\n    }\\n\\n    mapping(uint => uint) tokenIdToBlockHash;\\n    mapping(uint => uint) tokenIdToRandomness;\\n    mapping(uint => uint) tokenIdToStartingBlock;\\n\\n    // ------- Minting logic -------\\n\\n    function adress2uint(address a) internal pure returns (uint256) {\\n        return uint256(uint160(a));\\n    }\\n\\n    function extendSnail(uint head, uint appleBitmap, uint amountIndex, uint moveIndex) internal view returns (uint256, uint[600] memory) {\\n        uint amount = [GRID_SIZE, 1][amountIndex % 2];\\n        uint extendedBitmap = moveIndex == 0 ? \\n            head | (head >> amount) | (head >> (amount * 2)) : \\n            head | (head << amount) | (head << (amount * 2));\\n        if(isCollision(extendedBitmap, appleBitmap)) {\\n            return extendSnail(head, appleBitmap, amountIndex + 1, (amountIndex % 4) < 2 ? 0 : 1);\\n        }\\n        else {\\n            uint[600] memory extendedState;\\n            if (moveIndex == 0) {\\n                extendedState[0] = head >> (amount * 2);\\n                extendedState[1] = head >> amount;\\n            }\\n            else {\\n                extendedState[0] = head << (amount * 2);\\n                extendedState[1] = head << amount;\\n            }\\n\\n            extendedState[2] = head;\\n        \\n            return  (extendedBitmap, extendedState);\\n        }\\n    }\\n\\n    function gameConfiguration(uint startingBlock, uint blockHash, uint randomness) internal view returns (uint[600] memory _initialState, uint[100] memory _initialApples, uint _initialStateBitmap) {    \\n        uint appleIndex = randomness % validPositionsCount;\\n        uint initialAppleBitmap = validPositions[appleIndex];\\n        uint[100] memory initialApples;\\n        initialApples[0] = initialAppleBitmap;\\n        \\n        \\n        uint headIndex = randomness | blockHash;\\n        uint snailHead = validPositions[headIndex % validPositionsCount];\\n        if(isCollision(snailHead, initialAppleBitmap) && headIndex < MAX_INT) {\\n            snailHead = validPositions[(headIndex + 1) % validPositionsCount];\\n        }\\n        else if(isCollision(snailHead, initialAppleBitmap)) {\\n            snailHead = validPositions[(headIndex - 1) % validPositionsCount];\\n        }\\n\\n        uint initialStateBitmap = 0;\\n        uint[600] memory initialState;\\n        uint extensionSeed = startingBlock % 4;\\n        uint amountIndex = extensionSeed % 2;\\n        uint moveIndex = extensionSeed < 2 ? 0 : 1;\\n        (initialStateBitmap, initialState) = extendSnail(snailHead, initialAppleBitmap, amountIndex, moveIndex);\\n        \\n        return (initialState, initialApples, initialStateBitmap);\\n    }\\n\\n    // ----- Game logic ------\\n    \\n    function logg2(uint x) internal pure returns (uint y){\\n        assembly {\\n            let arg := x\\n            x := sub(x,1)\\n            x := or(x, div(x, 0x02))\\n            x := or(x, div(x, 0x04))\\n            x := or(x, div(x, 0x10))\\n            x := or(x, div(x, 0x100))\\n            x := or(x, div(x, 0x10000))\\n            x := or(x, div(x, 0x100000000))\\n            x := or(x, div(x, 0x10000000000000000))\\n            x := or(x, div(x, 0x100000000000000000000000000000000))\\n            x := add(x, 1)\\n            let m := mload(0x40)\\n            mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n            mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n            mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n            mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n            mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n            mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n            mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n            mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n            mstore(0x40, add(m, 0x100))\\n            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n            let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n            let a := div(mul(x, magic), shift)\\n            y := div(mload(add(m,sub(255,a))), shift)\\n            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n        }  \\n    }\\n\\n    function getRightMost(uint bitmap) internal pure returns (uint bit) {\\n        return bitmap ^ ( bitmap & (bitmap - 1));\\n    }\\n\\n    function decodePosition(uint positionMask) internal pure returns (uint[2] memory _position) {\\n        uint position = logg2(positionMask);\\n\\n        return [position / GRID_SIZE, position % GRID_SIZE];\\n    }\\n\\n    function decodeX(uint p) internal pure returns(uint x) {\\n        return (\\n            1 >> (2047 & p ^ p)\\n            | 2 >> (4192256 & p ^ p)\\n            | 4 >> (8585740288 & p ^ p)\\n            | 8 >> (17583596109824 & p ^ p)\\n            | 16 >> (36011204832919552 & p ^ p)\\n            | 32 >> (73750947497819242496 & p ^ p)\\n            | 64 >> (151041940475533808631808 & p ^ p)\\n            | 128 >> (309333894093893240077942784 & p ^ p)\\n            | 256 >> (633515815104293355679626821632 & p ^ p)\\n            | 512 >> (1297440389333592792431875730702336 & p ^ p)\\n            | 1024 >> (2657157917355198038900481496478384128 & p ^ p)\\n        );\\n    }\\n\\n    function decodeY(uint p) internal pure returns(uint y) {\\n        return (\\n            (2047 & p)\\n            | (4192256 & p) >> 11\\n            | (8585740288 & p) >> 22\\n            | (17583596109824 & p) >> 33\\n            | (36011204832919552 & p) >> 44\\n            | (73750947497819242496 & p) >> 55\\n            | (151041940475533808631808 & p) >> 66\\n            | (309333894093893240077942784 & p) >> 77\\n            | (633515815104293355679626821632 & p) >> 88\\n            | (1297440389333592792431875730702336 & p) >> 99\\n            | (2657157917355198038900481496478384128 & p) >> 110\\n        );\\n    }\\n\\n    function getUMovementsMask(uint point) internal pure returns (uint _mask) {\\n        uint movements = point << GRID_SIZE | point >> GRID_SIZE | point << 1 | point >> 1;\\n        \\n        return movements;\\n    }\\n\\n\\n    function getNextAIMove(uint stateBitmap, uint mouthBitmap, uint appleBitmap, uint tailBitmap) internal view returns (uint _newMouth) {\\n        uint mouthX = decodeX(mouthBitmap);\\n        uint mouthY = decodeY(mouthBitmap);\\n\\n        uint targetX = decodeX(appleBitmap);\\n        uint targetY = decodeY(appleBitmap);\\n\\n        if(mouthX < targetX && !isCollision(mouthBitmap << GRID_SIZE, stateBitmap)) {\\n            return mouthBitmap << GRID_SIZE;\\n        }\\n        else if(mouthX > targetX && !isCollision(mouthBitmap >> GRID_SIZE, stateBitmap)) {\\n            return mouthBitmap >> GRID_SIZE;\\n        }\\n        else if(mouthY < targetY && !isCollision(mouthBitmap << 1, stateBitmap)) {\\n            return mouthBitmap << 1;\\n        } \\n        else if(mouthY > targetY && !isCollision(mouthBitmap >> 1, stateBitmap)) {\\n            return mouthBitmap >> 1;\\n        }\\n\\n        targetX = decodeX(tailBitmap);\\n        targetY = decodeY(tailBitmap);\\n\\n        if(mouthX < targetX && !isCollision(mouthBitmap << GRID_SIZE, stateBitmap)) {\\n            return mouthBitmap << GRID_SIZE;\\n        }\\n        else if(mouthX > targetX && !isCollision(mouthBitmap >> GRID_SIZE, stateBitmap)) {\\n            return mouthBitmap >> GRID_SIZE;\\n        }\\n        else if(mouthY < targetY && !isCollision(mouthBitmap << 1, stateBitmap)) {\\n            return mouthBitmap << 1;\\n        } \\n        else if(mouthY > targetY && !isCollision(mouthBitmap >> 1, stateBitmap)) {\\n            return mouthBitmap >> 1;\\n        }\\n\\n        uint movements = getUMovementsMask(mouthBitmap);\\n        uint valid = movements ^ ((movements & WALL_MASK) | (movements & stateBitmap));\\n        \\n        return getRightMost(valid | (1 << (GRID_SIZE * GRID_SIZE - 1)));\\n\\n    }\\n\\n    function encodeUPosition(uint x, uint y) internal pure returns (uint) {\\n        return 1 << (x * GRID_SIZE) + y;\\n    }\\n\\n    function isCollision(uint point, uint stateSummary) internal view returns (bool _collision) {\\n        return ((WALL_MASK & point) | (point & stateSummary)) > 0;\\n    }\\n\\n    function getNewApple(uint blockNumber, uint stateBitmap, uint currentStateLength) internal view returns (uint _newPosition) {\\n        uint seed = (blockNumber + currentStateLength) % validPositionsCount;\\n        uint newAppleBitmap = 1 << (seed + appleShift + 2 * (seed / validRowSlotCount));\\n        if(isCollision(newAppleBitmap, stateBitmap)) {\\n            return getRightMost(~stateBitmap - WALL_MASK);\\n        }\\n\\n        return newAppleBitmap;\\n    }\\n\\n    function getCurrentState(uint iteration, uint startingBlock, uint[600] memory currentState, uint currentStateBitmap, uint[100] memory apples) internal view returns (uint _points, uint _stateLength, uint[100] memory _keyTimes) {\\n        uint points = 0;\\n        uint currentStateLength = INITIAL_SNAIL_LENGTH;\\n        uint currentBlock = startingBlock;\\n        uint nextMouth;\\n        \\n        uint[100] memory keyTimes; // more than 100 hits is impossible with this configuration\\n\\n        while(currentStateLength < INITIAL_SNAIL_LENGTH + iteration) {\\n            uint mouthBitmap = currentState[currentStateLength - 1];\\n            uint tail = currentState[currentStateLength - points - INITIAL_SNAIL_LENGTH];\\n            nextMouth = getNextAIMove(currentStateBitmap, mouthBitmap, apples[points], tail);\\n            currentStateBitmap = currentStateBitmap ^ tail;\\n\\n            if(isCollision(nextMouth, currentStateBitmap)) {\\n                break;\\n            }\\n\\n            currentState[currentStateLength] = nextMouth;\\n            currentStateLength++;\\n\\n            currentStateBitmap = currentStateBitmap | nextMouth;\\n            if(currentStateBitmap & apples[points] > 0) {\\n                keyTimes[points] = currentStateLength - 1;\\n                points = points + 1;\\n                currentStateBitmap = currentStateBitmap | tail;\\n                apples[points] = getNewApple(currentBlock, currentStateBitmap, currentStateLength);\\n            }\\n\\n            currentBlock = currentBlock + SPEED;\\n        }\\n        \\n        return (points, currentStateLength, keyTimes);\\n    }\\n\\n    // ---- Drawing logic -----\\n\\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len;\\n        while (_i != 0) {\\n            k = k-1;\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    function getAnimationPathOpt(uint[600] memory states, uint iterations) internal pure returns (bytes memory _path) {\\n\\n        uint[2] memory firstPosition = decodePosition(states[0]);\\n        bytes memory path = abi.encodePacked(pathTemplate1, uint2str(firstPosition[1]), \\\" \\\", uint2str(firstPosition[0]), \\\" \\\");\\n        \\n        for(uint i = 0; i < iterations; i++) {\\n            uint[2] memory position = decodePosition(states[i]);\\n            path = abi.encodePacked(path, uint2str(position[1]), \\\" \\\", uint2str(position[0]), \\\" \\\");\\n        }\\n\\n        return abi.encodePacked(path, pathTemplate2);\\n    }\\n\\n    function getApples(uint[100] memory apples, uint[100] memory keyTimes, uint hits) internal pure returns (bytes memory _apples) {\\n        bytes memory appleElements;\\n    \\n        uint previousKeyTime = 0;\\n        for(uint i = 0; i <= hits; i++) {\\n            uint[2] memory position = decodePosition(apples[i]); \\n            if(i == hits) {\\n                appleElements = abi.encodePacked(appleElements, appleTemplate1, uint2str(position[1]), appleTemplate2, uint2str(position[0]), appleTemplate3, strDiv(previousKeyTime, 4), appleTemplate4alt);\\n            }\\n            else {\\n                uint keyTime = keyTimes[i];\\n                appleElements = abi.encodePacked(appleElements, appleTemplate1, uint2str(position[1]), appleTemplate2, uint2str(position[0]), appleTemplate3, strDiv(previousKeyTime, 4), appleTemplate4, strDiv(keyTime, 4), appleTemplate5);\\n                previousKeyTime = keyTime;\\n            }\\n        }\\n\\n        return appleElements;\\n    }\\n\\n    function strDiv(uint i, uint div) internal pure returns (bytes memory _result) {\\n        return abi.encodePacked(uint2str(i * 1000 / div / 1000), \\\".\\\", uint2str(i * 1000 / div % 1000));\\n    }\\n\\n    function getTimesElements(uint t, uint[100] memory keyTimes, uint initialSnaleLength, uint speed) public pure returns (bytes memory _animationBegin, bytes memory _opacityBegin) {\\n        bytes memory animationBegin = strDiv(t + initialSnaleLength, speed); //abi.encodePacked(uint2str((t + initialSnaleLength) / 2 ), \\\".\\\", uint2str((t + initialSnaleLength) * 10 / 2 % 10));\\n        bytes memory opacityBegin = strDiv(keyTimes[t], speed);\\n\\n        return (animationBegin, opacityBegin);\\n    }\\n\\n\\n    function getStaticPixels(uint[600] memory states, uint iterations, uint snailLength) internal pure returns (bytes memory _pixels) {\\n        bytes memory pixels;\\n        uint[2] memory position;\\n        for(uint i = iterations - snailLength; i < iterations - 1; i++) {\\n            position = decodePosition(states[i]); \\n            pixels = abi.encodePacked(pixels, pixelTemplateStatic1, uint2str(position[1]), pixelTemplateStatic2, uint2str(position[0]), pixelTemplateStatic3);\\n        }\\n        position = decodePosition(states[iterations - 1]); \\n        pixels = abi.encodePacked(pixels, pixelTemplateStatic1Head, uint2str(position[1]), pixelTemplateStatic2, uint2str(position[0]), pixelTemplateStatic3);\\n\\n        return pixels;\\n    }\\n\\n    function getApplePixel(uint applePixel) internal pure returns (bytes memory _pixel) {\\n        uint[2] memory position = decodePosition(applePixel); \\n        return abi.encodePacked(applePixelTemplateStatic1, uint2str(position[1]), pixelTemplateStatic2, uint2str(position[0]), pixelTemplateStatic3);\\n    }\\n    \\n\\n    function getNumbers(uint points) internal pure returns (string memory _left, string memory _right) {\\n        return (getLeftNumber(points / 10), getRightNumber(points % 10));\\n    }\\n\\n\\n    function getAnimationElementNumbers(bool last, string memory number, bytes memory previousTimeStr, bytes memory keyTimeStr) internal pure returns (bytes memory _pixels) {\\n\\n        if (!last) {\\n            return abi.encodePacked(\\n                        numbersTemplate1,\\n                        number, \\n                        animatedNumberTemplate1, \\n                        previousTimeStr, \\n                        animatedNumberTemplate2, \\n                        keyTimeStr,\\n                        animatedNumberTemplate3\\n                    );\\n        } else {\\n            return abi.encodePacked(\\n                    numbersTemplate1,\\n                    number, \\n                    animatedNumberTemplate1, \\n                    previousTimeStr, \\n                    animatedNumberTemplate2alt\\n            );\\n        }\\n    }\\n\\n    function getAnimatedLeftPointPixels(uint[100] memory keyTimes, uint points, uint speed) internal pure returns (bytes memory _pixels) {\\n        bytes memory numberElements;\\n        \\n        bytes memory previousKeyTimeStr = \\\"0\\\";\\n\\n        string memory leftNumber;\\n        for(uint i = 9; i < points; i = i + 10) {\\n            leftNumber = getLeftNumber(i / 10);\\n            \\n            uint keyTime = keyTimes[i];\\n            bytes memory keyTimeStr = strDiv(keyTime, speed);\\n            numberElements = abi.encodePacked(numberElements, getAnimationElementNumbers(false, leftNumber, previousKeyTimeStr, keyTimeStr));\\n            previousKeyTimeStr = keyTimeStr;\\n        }\\n\\n        leftNumber = getLeftNumber(points / 10);\\n        numberElements = abi.encodePacked(numberElements, getAnimationElementNumbers(true, leftNumber, previousKeyTimeStr, \\\"\\\"));\\n\\n        return numberElements;\\n    }\\n\\n    function getAnimatedRightPointPixels(uint[100] memory keyTimes, uint points, uint speed) internal pure returns (bytes memory _pixels) {\\n        bytes memory numberElements;\\n        \\n        bytes memory previousKeyTimeStr = \\\"0\\\";\\n\\n        string memory rightNumber;\\n        for(uint i = 0; i < points; i++) {\\n            rightNumber = getRightNumber(i % 10);\\n            uint keyTime = keyTimes[i];\\n            bytes memory keyTimeStr = strDiv(keyTime, speed);\\n            numberElements = abi.encodePacked(numberElements, getAnimationElementNumbers(false, rightNumber, previousKeyTimeStr, keyTimeStr));\\n            previousKeyTimeStr = keyTimeStr;\\n        }\\n\\n        rightNumber = getRightNumber(points % 10);\\n        numberElements = abi.encodePacked(numberElements, getAnimationElementNumbers(true, rightNumber, previousKeyTimeStr, \\\"\\\"));\\n            \\n\\n        return numberElements;\\n    }\\n\\n    function getPointPixels(uint points) internal pure returns (bytes memory _pixels) {\\n        uint left = points / 10;\\n        uint right = points % 10;\\n\\n        return abi.encodePacked(numbersTemplate1, getLeftNumber(left), numbersTemplate2, numbersTemplate1, getRightNumber(right), numbersTemplate2);\\n    }\\n\\n    function stateToImage(uint[600] memory states, uint[100] memory apples, uint iterations, uint points) internal pure returns (string memory _svg) {\\n        return string(abi.encodePacked(\\n            svgWrapper1,\\n            getApplePixel(apples[points]),\\n            getStaticPixels(states, iterations, points + INITIAL_SNAIL_LENGTH),\\n            getPointPixels(points),\\n            svgWrapper2));\\n    }\\n    \\n    function stateToGif(uint[600] memory states, uint[100] memory keyTimes, uint points, uint iterations, uint[100] memory apples) internal pure returns (string memory svg) {\\n        bytes memory duration = strDiv(iterations, 4);\\n\\n        bytes memory gif = abi.encodePacked(\\n            svgWrapper1,\\n            getApples(apples, keyTimes, points),\\n            getAnimationPathOpt(states, iterations),\\n            getAnimatedLeftPointPixels(keyTimes, points, 4),\\n            getAnimatedRightPointPixels(keyTimes, points, 4),\\n            blinkingAnimationTemplate1,\\n            duration,\\n            blinkingAnimationTemplate2,\\n            pixelTemplate0a, strDiv(iterations, 4), pixelTemplate0b);\\n\\n        \\n        gif = abi.encodePacked(gif, pixelTemplate1Head, \\\"0\\\", pixelTemplate2, duration, pixelTemplate3, \\\"0\\\", pixelTemplate4);\\n        gif = abi.encodePacked(gif, pixelTemplate1, \\\"0.25\\\", pixelTemplate2, duration, pixelTemplate3, \\\"0.25\\\", pixelTemplate4);\\n        gif = abi.encodePacked(gif, pixelTemplate1, \\\"0.5\\\", pixelTemplate2, duration, pixelTemplate3, \\\"0.5\\\", pixelTemplate4);\\n\\n        bytes memory pixels;\\n        for(uint t = 0; t < points; t++) {\\n            (bytes memory animationBegin, bytes memory opacityBegin) = getTimesElements(t, keyTimes, INITIAL_SNAIL_LENGTH, 4);\\n            pixels = abi.encodePacked(pixels, pixelTemplate1, animationBegin, pixelTemplate2, duration, pixelTemplate3, opacityBegin, pixelTemplate4);\\n        }\\n\\n        return string(\\n            abi.encodePacked(gif, pixels, svgWrapper2)\\n        );\\n    } \\n\\n    function getSVG(uint startingBlock, uint blockHash, uint randomness) internal view returns (string memory _svg, uint _points, uint _length, bool _gameOver) {\\n        uint iteration = calculateIterations(startingBlock, SPEED);\\n        (uint[600] memory initialStates, uint[100] memory initialApples, uint initialStateBitmap) = gameConfiguration(startingBlock, blockHash, randomness);\\n        \\n        (uint points, uint stateLength, uint[100] memory keyTimes) = getCurrentState(iteration, startingBlock, initialStates, initialStateBitmap, initialApples);\\n        string memory image;\\n        bool gameOver = isGameOver(stateLength, iteration);\\n        if(gameOver) {\\n            image = stateToGif(initialStates, keyTimes, points, stateLength, initialApples);\\n        }\\n        else {\\n            image = stateToImage(initialStates, initialApples, stateLength, points);\\n        }\\n\\n        return (image, points, stateLength, gameOver);\\n    }\\n\\n\\n    function calculateIterations(uint startingBlock, uint speed) internal view returns (uint _iterations) {\\n        uint currentBlock = block.number;\\n        uint iterations = (currentBlock - startingBlock) / speed;\\n\\n        return iterations;\\n    }\\n\\n    // ------ Utlities -----\\n    function isGameOver(uint stateLength, uint iterations) internal pure returns (bool _over) {\\n        return stateLength < iterations + INITIAL_SNAIL_LENGTH;\\n    }\\n\\n\\n    function getConfig(uint tokenId) internal view returns (uint blockHash, uint randomness, uint startingBlock) {\\n        return (tokenIdToBlockHash[tokenId], tokenIdToRandomness[tokenId], tokenIdToStartingBlock[tokenId]);\\n    }\\n\\n    function getAttributeString(bool gameOver, uint startingBlock, uint points, uint length) internal pure returns (bytes memory) {\\n        bytes memory attributeCommon = '{\\\"trait_type\\\":\\\"';\\n        bytes memory blockAttribute = abi.encodePacked(attributeCommon, 'Start Block\\\",\\\"value\\\":\\\"', uint2str(startingBlock), '\\\"}');\\n        bytes memory pointsAttribute = abi.encodePacked(attributeCommon, 'Score\\\",\\\"value\\\":', uint2str(points), '}');\\n        bytes memory lengthAttribute = abi.encodePacked(attributeCommon, 'Moves\\\",\\\"value\\\":', uint2str(length - INITIAL_SNAIL_LENGTH), '}');\\n        string memory state = gameOver ? \\\"Game Over\\\" : \\\"Playing\\\";\\n        bytes memory gameOverAttribute = abi.encodePacked('{\\\"trait_type\\\": \\\"State\\\",\\\"value\\\":\\\"', state, '\\\"}');\\n\\n        return abi.encodePacked('\\\"attributes\\\":[',pointsAttribute,',',lengthAttribute,',',gameOverAttribute,',',blockAttribute,']');\\n    }\\n\\n\\n    // ------ IArcadeBackend implementation ------\\n\\n    function tokenURI(uint tokenId) override external view onlyController returns (string memory) {\\n        (uint blockHash, uint randomness, uint startingBlock) = getConfig(tokenId);\\n\\n        (string memory image, uint points, uint length, bool gameOver) = getSVG(startingBlock, blockHash, randomness);\\n\\n        bytes memory attributeString = getAttributeString(gameOver, startingBlock, points, length);\\n        bytes memory json = abi.encodePacked('{\\\"name\\\":\\\"ArcadeGlyph #', uint2str(tokenId), '\\\",\\\"description\\\":\\\"\\\",', attributeString,',\\\"created_by\\\":\\\"Inner Space and Captain Pixel\\\",\\\"image\\\":\\\"', image,'\\\"}');\\n        \\n        return string(abi.encodePacked('data:text/plain,',json));\\n\\n    }\\n\\n    function insertCoin(uint tokenId, uint blockNumber) override external onlyController {\\n        tokenIdToBlockHash[tokenId] = uint(blockhash(blockNumber - 1));\\n        tokenIdToRandomness[tokenId] = (block.timestamp) * tokenId;\\n        tokenIdToStartingBlock[tokenId] = blockNumber;\\n    }\\n\\n    function verifyPoints(uint minPoints, uint maxPoints, uint tokenId) override external view onlyController {\\n        (uint blockHash, uint randomness, uint startingBlock) = getConfig(tokenId);\\n\\n        uint iteration = calculateIterations(startingBlock, SPEED);\\n        \\n        (uint[600] memory initialState, uint[100] memory initialApples, uint initialStateBitmap) = gameConfiguration(startingBlock, blockHash, randomness);\\n        \\n        (uint actualPoints, uint stateLength, ) = getCurrentState(iteration, startingBlock, initialState, initialStateBitmap, initialApples);\\n        \\n\\n        require(isGameOver(stateLength, iteration), \\\"Not over.\\\");\\n        require(actualPoints >= minPoints, \\\"Points too low\\\");\\n\\n        if(maxPoints >= minPoints) {\\n            require(actualPoints <= maxPoints, \\\"Points too high\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/IArcadeBackend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC-BY-4.0\\n\\npragma solidity >= 0.8.0;\\n\\nabstract contract IArcadeBackend {\\n    function tokenURI(uint tokenId) virtual external view returns (string memory);\\n    function verifyPoints(uint minPoints, uint maxPoints, uint tokenId) virtual external view;\\n    function insertCoin(uint tokenId, uint variant) virtual external;\\n    \\n    function interact(uint tokenId, uint[6] memory intActions, string[6] memory stringActions) external {\\n    }\\n\\n    function restart(uint tokenId) external {\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"uint256[100]\",\"name\":\"keyTimes\",\"type\":\"uint256[100]\"},{\"internalType\":\"uint256\",\"name\":\"initialSnaleLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"}],\"name\":\"getTimesElements\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_animationBegin\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_opacityBegin\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"insertCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"intActions\",\"type\":\"uint256[6]\"},{\"internalType\":\"string[6]\",\"name\":\"stringActions\",\"type\":\"string[6]\"}],\"name\":\"interact\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"restart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"verifyPoints\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SnakeBackend","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007eefee2d0b0e23b7ce6b56a9ce9b62a599e6e9da","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}