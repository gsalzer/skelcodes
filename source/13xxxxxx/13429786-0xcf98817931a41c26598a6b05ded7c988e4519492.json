{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/auction/TornadoAuctionHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport { IWETH } from \\\"./interfaces/IWETH.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { EtherSend } from \\\"../libraries/EtherSend.sol\\\";\\nimport { IEasyAuction } from \\\"./interfaces/IEasyAuction.sol\\\";\\nimport { ImmutableGovernanceInformation } from \\\"../ImmutableGovernanceInformation.sol\\\";\\n\\n/// @notice Handler which should help governance start an auction and transfer results of an auction to governance.\\n/// @dev The reasoning behind this contract is to not bloat governance with unnecessary logic.\\ncontract TornadoAuctionHandler is ImmutableGovernanceInformation {\\n  using EtherSend for address;\\n\\n  address public constant EasyAuctionAddress = 0x0b7fFc1f4AD541A4Ed16b40D8c37f0929158D101;\\n  address public constant WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n  /// @notice main auction initialization function, please see: https://github.com/h-ivor/tornado-lottery-period/blob/only-vault-and-gas/contracts/auction/Auction.md\\n  /// @dev calls easy auction deployed on eth mainnet\\n  function initializeAuction(\\n    uint256 _auctionEndDate,\\n    uint96 _auctionedSellAmount,\\n    uint96 _minBuyAmount,\\n    uint256 _minBidPerOrder,\\n    uint256 _minFundingThreshold\\n  ) external onlyGovernance {\\n    require(IERC20(TornTokenAddress).balanceOf(address(this)) >= _auctionedSellAmount, \\\"torn balance not enough\\\");\\n    IERC20(TornTokenAddress).approve(EasyAuctionAddress, _auctionedSellAmount);\\n\\n    IEasyAuction(EasyAuctionAddress).initiateAuction(\\n      IERC20(TornTokenAddress),\\n      IERC20(WETHAddress),\\n      0,\\n      _auctionEndDate,\\n      _auctionedSellAmount,\\n      _minBuyAmount,\\n      _minBidPerOrder,\\n      _minFundingThreshold,\\n      false,\\n      address(0x0000000000000000000000000000000000000000),\\n      new bytes(0)\\n    );\\n  }\\n\\n  /// @notice function to transfer all eth and TORN dust to governance\\n  function convertAndTransferToGovernance() external {\\n    IWETH(WETHAddress).withdraw(IWETH(WETHAddress).balanceOf(address(this)));\\n    if (address(this).balance > 0) require(GovernanceAddress.sendEther(address(this).balance), \\\"pay fail\\\");\\n    if (IERC20(TornTokenAddress).balanceOf(address(this)) > 0)\\n      IERC20(TornTokenAddress).transfer(GovernanceAddress, IERC20(TornTokenAddress).balanceOf(address(this)));\\n  }\\n\\n  /// @notice receive eth that should only allow mainnet WETH to send eth\\n  receive() external payable {\\n    require(msg.sender == WETHAddress, \\\"only weth\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface IWETH {\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function approve(address guy, uint256 wad) external returns (bool);\\n\\n  function transfer(address dst, uint256 wad) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 wad\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/EtherSend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12 || ^0.8.7;\\n\\n/// @notice very short library which implements a method to transfer ether via <address>.call\\nlibrary EtherSend {\\n  /**\\n  * @notice function to transfer ether via filling the value field of a call\\n  * @dev DICLAIMER: you must handle the possibility of reentrancy when using this function!!!\\n  * @param to address to be transferred to\\n  * @param amount amount to be transferred\\n  * @return success true if transfer successful\\n  * */\\n  function sendEther(address to, uint256 amount) internal returns (bool success) {\\n    (success, ) = payable(to).call{ value: amount }(\\\"\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/IEasyAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IEasyAuction {\\n  function initiateAuction(\\n    IERC20 _auctioningToken,\\n    IERC20 _biddingToken,\\n    uint256 orderCancellationEndDate,\\n    uint256 auctionEndDate,\\n    uint96 _auctionedSellAmount,\\n    uint96 _minBuyAmount,\\n    uint256 minimumBiddingAmountPerOrder,\\n    uint256 minFundingThreshold,\\n    bool isAtomicClosureAllowed,\\n    address accessManagerContract,\\n    bytes memory accessManagerContractData\\n  ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ImmutableGovernanceInformation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IGovernanceMultisigAddress {\\n  function returnMultisigAddress() external pure returns (address);\\n}\\n\\n/**\\n * @notice Contract which hold governance information. Useful for avoiding code duplication.\\n * */\\ncontract ImmutableGovernanceInformation {\\n  address internal constant GovernanceAddress = 0x5efda50f22d34F262c29268506C5Fa42cB56A1Ce;\\n  address internal constant TornTokenAddress = 0x77777FeDdddFfC19Ff86DB637967013e6C6A116C;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == GovernanceAddress, \\\"only governance\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev this modifier calls the pure governance returnMultisigAddress() function,\\n   *      if governance version is not -> vault-and-gas upgrade <= version\\n   *      then this will not work!\\n   */\\n  modifier onlyMultisig() {\\n    require(msg.sender == IGovernanceMultisigAddress(GovernanceAddress).returnMultisigAddress(), \\\"only multisig\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice Function to return a payable version of the governance address.\\n   * @return payable version of the address\\n   * */\\n  function returnPayableGovernance() internal pure returns (address payable) {\\n    return payable(GovernanceAddress);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"EasyAuctionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convertAndTransferToGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_auctionEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"_auctionedSellAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_minBuyAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_minBidPerOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minFundingThreshold\",\"type\":\"uint256\"}],\"name\":\"initializeAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"TornadoAuctionHandler","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}