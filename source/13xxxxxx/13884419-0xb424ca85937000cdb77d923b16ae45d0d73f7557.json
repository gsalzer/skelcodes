{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.4;\r\n\r\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\r\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\r\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\r\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\r\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\r\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\r\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\r\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\r\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\r\n\r\n/**\r\n * @title CXIP ERC721\r\n * @author CXIP-Labs\r\n * @notice A smart contract for minting and managing ERC721 NFTs.\r\n * @dev The entire logic and functionality of the smart contract is self-contained.\r\n */\r\ncontract CxipERC721 {\r\n    /**\r\n     * @dev Stores default collection data: name, symbol, and royalties.\r\n     */\r\n    CollectionData private _collectionData;\r\n\r\n    /**\r\n     * @dev Internal last minted token id, to allow for auto-increment.\r\n     */\r\n    uint256 private _currentTokenId;\r\n\r\n    /**\r\n     * @dev Array of all token ids in collection.\r\n     */\r\n    uint256[] private _allTokens;\r\n\r\n    /**\r\n     * @dev Map of token id to array index of _ownedTokens.\r\n     */\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    /**\r\n     * @dev Token id to wallet (owner) address map.\r\n     */\r\n    mapping(uint256 => address) private _tokenOwner;\r\n\r\n    /**\r\n     * @dev 1-to-1 map of token id that was assigned an approved operator address.\r\n     */\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    /**\r\n     * @dev Map of total tokens owner by a specific address.\r\n     */\r\n    mapping(address => uint256) private _ownedTokensCount;\r\n\r\n    /**\r\n     * @dev Map of array of token ids owned by a specific address.\r\n     */\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    /**\r\n     * @notice Map of full operator approval for a particular address.\r\n     * @dev Usually utilised for supporting marketplace proxy wallets.\r\n     */\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Token data mapped by token id.\r\n     */\r\n    mapping(uint256 => TokenData) private _tokenData;\r\n\r\n    /**\r\n     * @dev Address of admin user. Primarily used as an additional recover address.\r\n     */\r\n    address private _admin;\r\n\r\n    /**\r\n     * @dev Address of contract owner. This address can run all onlyOwner functions.\r\n     */\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Simple tracker of all minted (not-burned) tokens.\r\n     */\r\n    uint256 private _totalTokens;\r\n\r\n    /**\r\n     * @notice Event emitted when an token is minted, transfered, or burned.\r\n     * @dev If from is empty, it's a mint. If to is empty, it's a burn. Otherwise, it's a transfer.\r\n     * @param from Address from where token is being transfered.\r\n     * @param to Address to where token is being transfered.\r\n     * @param tokenId Token id that is being minted, Transfered, or burned.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @notice Event emitted when an address delegates power, for a token, to another address.\r\n     * @dev Emits event that informs of address approving a third-party operator for a particular token.\r\n     * @param wallet Address of the wallet configuring a token operator.\r\n     * @param operator Address of the third-party operator approved for interaction.\r\n     * @param tokenId A specific token id that is being authorised to operator.\r\n     */\r\n    event Approval(address indexed wallet, address indexed operator, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @notice Event emitted when an address authorises an operator (third-party).\r\n     * @dev Emits event that informs of address approving/denying a third-party operator.\r\n     * @param wallet Address of the wallet configuring it's operator.\r\n     * @param operator Address of the third-party operator that interacts on behalf of the wallet.\r\n     * @param approved A boolean indicating whether approval was granted or revoked.\r\n     */\r\n    event ApprovalForAll(address indexed wallet, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @notice Event emitted to signal to OpenSea that a permanent URI was created.\r\n     * @dev Even though OpenSea advertises support for this, they do not listen to this event, and do not respond to it.\r\n     * @param uri The permanent/static URL of the NFT. Cannot ever be changed again.\r\n     * @param id Token id of the NFT.\r\n     */\r\n    event PermanentURI(string uri, uint256 indexed id);\r\n\r\n    /**\r\n     * @notice Constructor is empty and not utilised.\r\n     * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"CXIP: caller not an owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Enables royaltiy functionality at the ERC721 level when ether is sent with no calldata.\r\n     * @dev See implementation of _royaltiesFallback.\r\n     */\r\n    receive() external payable {\r\n        _royaltiesFallback();\r\n    }\r\n\r\n    /**\r\n     * @notice Enables royaltiy functionality at the ERC721 level no other function matches the call.\r\n     * @dev See implementation of _royaltiesFallback.\r\n     */\r\n    fallback() external {\r\n        _royaltiesFallback();\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the URI of the NFT on Arweave.\r\n     * @dev Concatenates 2 sections of the arweave URI.\r\n     * @param tokenId Id of the token.\r\n     * @return string The URI.\r\n     */\r\n    function arweaveURI(uint256 tokenId) external view returns (string memory) {\r\n        return\r\n            string(abi.encodePacked(\"https://arweave.net/\", _tokenData[tokenId].arweave, _tokenData[tokenId].arweave2));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the URI of the NFT backup from CXIP.\r\n     * @dev Concatenates to https://nft.cxip.io/.\r\n     * @return string The URI.\r\n     */\r\n    function contractURI() external view returns (string memory) {\r\n        return string(abi.encodePacked(\"https://nft.cxip.io/\", Strings.toHexString(address(this)), \"/\"));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the creator's address.\r\n     * @dev If the token Id doesn't exist it will return zero address.\r\n     * @param tokenId Id of the token.\r\n     * @return address Creator's address.\r\n     */\r\n    function creator(uint256 tokenId) external view returns (address) {\r\n        return _tokenData[tokenId].creator;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the HTTP URI of the token.\r\n     * @dev Concatenates to the baseURI.\r\n     * @return string The URI.\r\n     */\r\n    function httpURI(uint256 tokenId) external view returns (string memory) {\r\n        return string(abi.encodePacked(baseURI(), \"/\", Strings.toHexString(tokenId)));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the IPFS URI\r\n     * @dev Concatenates to the IPFS domain.\r\n     * @param tokenId Id of the token.\r\n     * @return string The URI.\r\n     */\r\n    function ipfsURI(uint256 tokenId) external view returns (string memory) {\r\n        return string(abi.encodePacked(\"https://ipfs.io/ipfs/\", _tokenData[tokenId].ipfs, _tokenData[tokenId].ipfs2));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the name of the collection.\r\n     * @dev Uses two names to extend the max length of the collection name in bytes\r\n     * @return string The collection name.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return string(abi.encodePacked(Bytes.trim(_collectionData.name), Bytes.trim(_collectionData.name2)));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the hash of the NFT data used to create it.\r\n     * @dev Payload is used for verification.\r\n     * @param tokenId The Id of the token.\r\n     * @return bytes32 The hash.\r\n     */\r\n    function payloadHash(uint256 tokenId) external view returns (bytes32) {\r\n        return _tokenData[tokenId].payloadHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the signature of the signed NFT data used to create it.\r\n     * @dev Used for signature verification.\r\n     * @param tokenId The Id of the token.\r\n     * @return Verification a struct containing v, r, s values of the signature.\r\n     */\r\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory) {\r\n        return _tokenData[tokenId].payloadSignature;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the address of the creator.\r\n     * @dev The creator signs a payload while creating the NFT.\r\n     * @param tokenId The Id of the token.\r\n     * @return address The creator.\r\n     */\r\n    function payloadSigner(uint256 tokenId) external view returns (address) {\r\n        return _tokenData[tokenId].creator;\r\n    }\r\n\r\n    /**\r\n     * @notice Shows the interfaces the contracts support\r\n     * @dev Must add new 4 byte interface Ids here to acknowledge support\r\n     * @param interfaceId ERC165 style 4 byte interfaceId.\r\n     * @return bool True if supported.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        if (\r\n            interfaceId == 0x01ffc9a7 || // ERC165\r\n            interfaceId == 0x80ac58cd || // ERC721\r\n            // || interfaceId == 0x780e9d63 // ERC721Enumerable\r\n            interfaceId == 0x5b5e139f || // ERC721Metadata\r\n            interfaceId == 0x150b7a02 || // ERC721TokenReceiver\r\n            interfaceId == 0xe8a3d485 || // contractURI()\r\n            IPA1D(getRegistry().getPA1D()).supportsInterface(interfaceId)\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the collection's symbol.\r\n     * @dev Trims the symbol.\r\n     * @return string The symbol.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return string(Bytes.trim(_collectionData.symbol));\r\n    }\r\n\r\n    /**\r\n     * @notice Get's the URI of the token.\r\n     * @dev Defaults the the Arweave URI\r\n     * @param tokenId The Id of the token.\r\n     * @return string The URI.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        return\r\n            string(abi.encodePacked(\"https://arweave.net/\", _tokenData[tokenId].arweave, _tokenData[tokenId].arweave2));\r\n    }\r\n\r\n    /** Disabled due to tokenEnumeration not enabled.\r\n     * @notice Get list of tokens owned by wallet.\r\n     * @param wallet The wallet address to get tokens for.\r\n     * @return uint256[] Returns an array of token ids owned by wallet.\r\n    function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\r\n        return _ownedTokens[wallet];\r\n    }\r\n    */\r\n\r\n    /**\r\n     * @notice Checks if a given hash matches a payload hash.\r\n     * @dev Uses sha256 instead of keccak.\r\n     * @param hash The hash to check.\r\n     * @param payload The payload prehashed.\r\n     * @return bool True if the hashes match.\r\n     */\r\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool) {\r\n        bytes32 thePayloadHash = sha256(payload);\r\n        return hash == thePayloadHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new address to the token's approval list.\r\n     * @dev Requires the sender to be in the approved addresses.\r\n     * @param to The address to approve.\r\n     * @param tokenId The affected token.\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        if (to != tokenOwner && _isApproved(msg.sender, tokenId)) {\r\n            _tokenApprovals[tokenId] = to;\r\n            emit Approval(tokenOwner, to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Burns the token.\r\n     * @dev The sender must be the owner or approved.\r\n     * @param tokenId The token to burn.\r\n     */\r\n    function burn(uint256 tokenId) public {\r\n        if (_isApproved(msg.sender, tokenId)) {\r\n            address wallet = _tokenOwner[tokenId];\r\n            require(!Address.isZero(wallet));\r\n            _clearApproval(tokenId);\r\n            _tokenOwner[tokenId] = address(0);\r\n            emit Transfer(wallet, address(0), tokenId);\r\n            // _removeTokenFromOwnerEnumeration(wallet, tokenId);\r\n            // uint256 index = _allTokens.length;\r\n            // index--;\r\n            // if (index == 0) {\r\n            //     delete _allTokens;\r\n            // } else {\r\n            //     delete _allTokens[index];\r\n            // }\r\n            _totalTokens -= 1;\r\n            delete _tokenData[tokenId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the collection.\r\n     * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\r\n     * @param newOwner The owner of the collection.\r\n     * @param collectionData The collection data.\r\n     */\r\n    function init(address newOwner, CollectionData calldata collectionData) public {\r\n        require(Address.isZero(_admin), \"CXIP: already initialized\");\r\n        _admin = msg.sender;\r\n        // temporary set to self, to pass rarible royalties logic trap\r\n        _owner = address(this);\r\n        _collectionData = collectionData;\r\n        IPA1D(address(this)).init (0, payable(collectionData.royalties), collectionData.bps);\r\n        // set to actual owner\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /** Disabled since this flow has not been agreed on.\r\n     * @notice Transfer received NFTs to contract owner.\r\n     * @dev Automatically transfer NFTs out of this smart contract to contract owner. This uses gas from sender.\r\n     * @param _operator The smart contract where NFT is minted/operated.\r\n     * @param _from The address from where NFT is being transfered from.\r\n     * @param _tokenId NFT token id.\r\n     * @param _data Arbitrary data that could be used for special function calls.\r\n     * @return bytes4 Returns the onERC721Received interfaceId, to confirm successful receipt of NFT transfer.\r\n     *\r\n    function onERC721Received(\r\n        address _operator,\r\n        address /*_from*\\/,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) public returns (bytes4) {\r\n        ICxipERC721(_operator).safeTransferFrom(\r\n            payable(address(this)),\r\n            _owner,\r\n            _tokenId,\r\n            _data\r\n        );\r\n        return 0x150b7a02;\r\n    }\r\n    */\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     * @param from cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must exist and be owned by `from`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     * @param from cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must exist and be owned by `from`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory /*_data*/\r\n    ) public payable {\r\n        if (_isApproved(msg.sender, tokenId)) {\r\n            _transferFrom(from, to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new approved operator.\r\n     * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\r\n     * @param to The address to approve.\r\n     * @param approved Turn on or off approval status.\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        if (to != msg.sender) {\r\n            _operatorApprovals[msg.sender][to] = approved;\r\n            emit ApprovalForAll(msg.sender, to, approved);\r\n        } else {\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `tokenId` token from `from` to `to`.\r\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * @param from  cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must be owned by `from`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable {\r\n        transferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `tokenId` token from `from` to `to`.\r\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\r\n     * @param from  cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must be owned by `from`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory /*_data*/\r\n    ) public payable {\r\n        if (_isApproved(msg.sender, tokenId)) {\r\n            _transferFrom(from, to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mints and NFT.\r\n     * @dev Includes event with the Arwave token URI.\r\n     * @param id The new tokenId.\r\n     * @param tokenData The token data for the NFT.\r\n     * @return uint256 The new tokenId.\r\n     */\r\n    function cxipMint(uint256 id, TokenData calldata tokenData) public onlyOwner returns (uint256) {\r\n        if (id == 0) {\r\n            _currentTokenId += 1;\r\n            id = _currentTokenId;\r\n        }\r\n        _mint(tokenData.creator, id);\r\n        _tokenData[id] = tokenData;\r\n        emit PermanentURI(string(abi.encodePacked(\"https://arweave.net/\", tokenData.arweave, tokenData.arweave2)), id);\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a name for the collection.\r\n     * @dev The name is split in two for gas optimization.\r\n     * @param newName First part of name.\r\n     * @param newName2 Second part of name.\r\n     */\r\n    function setName(bytes32 newName, bytes32 newName2) public onlyOwner {\r\n        _collectionData.name = newName;\r\n        _collectionData.name2 = newName2;\r\n    }\r\n\r\n    /**\r\n     * @notice Set a symbol for the collection.\r\n     * @dev This is the ticker symbol for smart contract that shows up on EtherScan.\r\n     * @param newSymbol The ticker symbol to set for smart contract.\r\n     */\r\n    function setSymbol(bytes32 newSymbol) public onlyOwner {\r\n        _collectionData.symbol = newSymbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the collection.\r\n     * @dev Can't be the zero address.\r\n     * @param newOwner Address of new owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (!Address.isZero(newOwner)) {\r\n            _owner = newOwner;\r\n        }\r\n    }\r\n\r\n    /** Disabled due to tokenEnumeration not enabled.\r\n     * @notice Get total number of tokens owned by wallet.\r\n     * @dev Used to see total amount of tokens owned by a specific wallet.\r\n     * @param wallet Address for which to get token balance.\r\n     * @return uint256 Returns an integer, representing total amount of tokens held by address.\r\n     *\r\n    function balanceOf(address wallet) public view returns (uint256) {\r\n        return _ownedTokensCount[wallet];\r\n    }\r\n    */\r\n\r\n    /**\r\n     * @notice Get a base URI for the token.\r\n     * @dev Concatenates with the CXIP domain name.\r\n     * @return string the token URI.\r\n     */\r\n    function baseURI() public view returns (string memory) {\r\n        return string(abi.encodePacked(\"https://cxip.io/nft/\", Strings.toHexString(address(this))));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the approved address for the token.\r\n     * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\r\n     * @param tokenId Token id to get approved operator for.\r\n     * @return address Approved address for token.\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the associated identity for the collection.\r\n     * @dev Goes up the chain to read from the registry.\r\n     * @return address Identity contract address.\r\n     */\r\n    function getIdentity() public view returns (address) {\r\n        return ICxipProvenance(getRegistry().getProvenance()).getWalletIdentity(_owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the address is approved.\r\n     * @dev Includes references to OpenSea and Rarible marketplace proxies.\r\n     * @param wallet Address of the wallet.\r\n     * @param operator Address of the marketplace operator.\r\n     * @return bool True if approved.\r\n     */\r\n    function isApprovedForAll(address wallet, address operator) public view returns (bool) {\r\n        return (_operatorApprovals[wallet][operator] ||\r\n            // Rarible Transfer Proxy\r\n            0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be == operator ||\r\n            // OpenSea Transfer Proxy\r\n            address(OpenSeaProxyRegistry(0xa5409ec958C83C3f309868babACA7c86DCB077c1).proxies(wallet)) == operator);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the sender is the owner.\r\n     * @dev The owner could also be the admin or identity contract of the owner.\r\n     * @return bool True if owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return (msg.sender == _owner || msg.sender == _admin || isIdentityWallet(msg.sender));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the owner's address.\r\n     * @dev _owner is first set in init.\r\n     * @return address Of ower.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks who the owner of a token is.\r\n     * @dev The token must exist.\r\n     * @param tokenId The token to look up.\r\n     * @return address Owner of the token.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        require(!Address.isZero(tokenOwner), \"ERC721: token does not exist\");\r\n        return tokenOwner;\r\n    }\r\n\r\n    /** Disabled due to tokenEnumeration not enabled.\r\n     * @notice Get token by index instead of token id.\r\n     * @dev Helpful for token enumeration where token id info is not yet available.\r\n     * @param index Index of token in array.\r\n     * @return uint256 Returns the token id of token located at that index.\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply());\r\n        return _allTokens[index];\r\n    }\r\n    */\r\n\r\n    /** Disabled due to tokenEnumeration not enabled.\r\n     * @notice Get token from wallet by index instead of token id.\r\n     * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\r\n     * @param wallet Specific address for which to get token for.\r\n     * @param index Index of token in array.\r\n     * @return uint256 Returns the token id of token located at that index in specified wallet.\r\n     *\r\n    function tokenOfOwnerByIndex(\r\n        address wallet,\r\n        uint256 index\r\n    ) public view returns (uint256) {\r\n        require(index < balanceOf(wallet));\r\n        return _ownedTokens[wallet][index];\r\n    }\r\n    */\r\n\r\n    /** Disabled due to tokenEnumeration not enabled.\r\n     * @notice Total amount of tokens in the collection.\r\n     * @dev Ignores burned tokens.\r\n     * @return uint256 Returns the total number of active (not burned) tokens.\r\n     *\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n    */\r\n\r\n    /**\r\n     * @notice Total amount of tokens in the collection.\r\n     * @dev Ignores burned tokens.\r\n     * @return uint256 Returns the total number of active (not burned) tokens.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Empty function that is triggered by external contract on NFT transfer.\r\n     * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\r\n     * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\r\n     * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\r\n     * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\r\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\r\n     * @return bytes4 Returns the interfaceId of onERC721Received.\r\n     */\r\n    function onERC721Received(\r\n        address, /*_operator*/\r\n        address, /*_from*/\r\n        uint256, /*_tokenId*/\r\n        bytes calldata /*_data*/\r\n    ) public pure returns (bytes4) {\r\n        return 0x150b7a02;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows retrieval of royalties from the contract.\r\n     * @dev This is a default fallback to ensure the royalties are available.\r\n     */\r\n    function _royaltiesFallback() internal {\r\n        address _target = getRegistry().getPA1D();\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if an address is an identity contract.\r\n     * @dev It must also be registred.\r\n     * @param sender Address to check if registered to identity.\r\n     * @return bool True if registred identity.\r\n     */\r\n    function isIdentityWallet(address sender) internal view returns (bool) {\r\n        address identity = getIdentity();\r\n        if (Address.isZero(identity)) {\r\n            return false;\r\n        }\r\n        return ICxipIdentity(identity).isWalletRegistered(sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\r\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\r\n     */\r\n    function getRegistry() internal pure returns (ICxipRegistry) {\r\n        return ICxipRegistry(0xC267d41f81308D7773ecB3BDd863a902ACC01Ade);\r\n    }\r\n\r\n    /** Disabled due to tokenEnumeration not enabled.\r\n     * @dev Add a newly minted token into managed list of tokens.\r\n     * @param to Address of token owner for which to add the token.\r\n     * @param tokenId Id of token to add.\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\r\n        _ownedTokensCount[to]++;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n    */\r\n\r\n    /**\r\n     * @notice Deletes a token from the approval list.\r\n     * @dev Removes from count.\r\n     * @param tokenId T.\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        delete _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @notice Mints an NFT.\r\n     * @dev Can to mint the token to the zero address and the token cannot already exist.\r\n     * @param to Address to mint to.\r\n     * @param tokenId The new token.\r\n     */\r\n    function _mint(address to, uint256 tokenId) private {\r\n        if (Address.isZero(to) || _exists(tokenId)) {\r\n            assert(false);\r\n        }\r\n        _tokenOwner[tokenId] = to;\r\n        emit Transfer(address(0), to, tokenId);\r\n        // _addTokenToOwnerEnumeration(to, tokenId);\r\n        _totalTokens += 1;\r\n        // _allTokens.push(tokenId);\r\n    }\r\n\r\n    /** Disabled due to tokenEnumeration not enabled.\r\n     * @dev Remove a token from managed list of tokens.\r\n     * @param from Address of token owner for which to remove the token.\r\n     * @param tokenId Id of token to remove.\r\n    function _removeTokenFromOwnerEnumeration(\r\n        address from,\r\n        uint256 tokenId\r\n    ) private {\r\n        _ownedTokensCount[from]--;\r\n        uint256 lastTokenIndex = _ownedTokensCount[from];\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n        if(tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n            _ownedTokens[from][tokenIndex] = lastTokenId;\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\r\n        }\r\n        if(lastTokenIndex == 0) {\r\n            delete _ownedTokens[from];\r\n        } else {\r\n            delete _ownedTokens[from][lastTokenIndex];\r\n        }\r\n    }\r\n    */\r\n\r\n    /**\r\n     * @dev Primary internal function that handles the transfer/mint/burn functionality.\r\n     * @param from Address from where token is being transferred. Zero address means it is being minted.\r\n     * @param to Address to whom the token is being transferred. Zero address means it is being burned.\r\n     * @param tokenId Id of token that is being transferred/minted/burned.\r\n     */\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) private {\r\n        if (_tokenOwner[tokenId] == from && !Address.isZero(to)) {\r\n            _clearApproval(tokenId);\r\n            _tokenOwner[tokenId] = to;\r\n            emit Transfer(from, to, tokenId);\r\n            // _removeTokenFromOwnerEnumeration(from, tokenId);\r\n            // _addTokenToOwnerEnumeration(to, tokenId);\r\n        } else {\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the token owner exists.\r\n     * @dev If the address is the zero address no owner exists.\r\n     * @param tokenId The affected token.\r\n     * @return bool True if it exists.\r\n     */\r\n    function _exists(uint256 tokenId) private view returns (bool) {\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        return !Address.isZero(tokenOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the address is an approved one.\r\n     * @dev Uses inlined checks for different usecases of approval.\r\n     * @param spender Address of the spender.\r\n     * @param tokenId The affected token.\r\n     * @return bool True if approved.\r\n     */\r\n    function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\r\n        require(_exists(tokenId));\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        return (\r\n            spender == tokenOwner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(tokenOwner, spender)\r\n        );\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n\r\n    function isZero(address account) internal pure returns (bool) {\r\n        return (account == address(0));\r\n    }\r\n}\r\n\r\nlibrary Bytes {\r\n    function getBoolean(uint192 _packedBools, uint192 _boolNumber) internal pure returns (bool) {\r\n        uint192 flag = (_packedBools >> _boolNumber) & uint192(1);\r\n        return (flag == 1 ? true : false);\r\n    }\r\n\r\n    function setBoolean(\r\n        uint192 _packedBools,\r\n        uint192 _boolNumber,\r\n        bool _value\r\n    ) internal pure returns (uint192) {\r\n        if (_value) {\r\n            return _packedBools | (uint192(1) << _boolNumber);\r\n        } else {\r\n            return _packedBools & ~(uint192(1) << _boolNumber);\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                tempBytes := mload(0x40)\r\n                let lengthmod := and(_length, 31)\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n                for {\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n                mstore(tempBytes, _length)\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                mstore(tempBytes, 0)\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n        return tempBytes;\r\n    }\r\n\r\n    function trim(bytes32 source) internal pure returns (bytes memory) {\r\n        uint256 temp = uint256(source);\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return slice(abi.encodePacked(source), 32 - length, length);\r\n    }\r\n}\r\n\r\nstruct CollectionData {\r\n    bytes32 name;\r\n    bytes32 name2;\r\n    bytes32 symbol;\r\n    address royalties;\r\n    uint96 bps;\r\n}\r\n\r\ninterface ICxipERC721 {\r\n    function arweaveURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function contractURI() external view returns (string memory);\r\n\r\n    function creator(uint256 tokenId) external view returns (address);\r\n\r\n    function httpURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function ipfsURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function payloadHash(uint256 tokenId) external view returns (bytes32);\r\n\r\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory);\r\n\r\n    function payloadSigner(uint256 tokenId) external view returns (address);\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function tokensOfOwner(\r\n        address wallet\r\n    ) external view returns (uint256[] memory);\r\n    */\r\n\r\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool);\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function init(address newOwner, CollectionData calldata collectionData) external;\r\n\r\n    /* Disabled since this flow has not been agreed on.\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n    */\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) external payable;\r\n\r\n    function setApprovalForAll(address to, bool approved) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) external payable;\r\n\r\n    function cxipMint(uint256 id, TokenData calldata tokenData) external returns (uint256);\r\n\r\n    function setApprovalForAll(\r\n        address from,\r\n        address to,\r\n        bool approved\r\n    ) external;\r\n\r\n    function setName(bytes32 newName, bytes32 newName2) external;\r\n\r\n    function setSymbol(bytes32 newSymbol) external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /*\r\n    // Disabled due to tokenEnumeration not enabled.\r\n    function balanceOf(address wallet) external view returns (uint256);\r\n    */\r\n    function baseURI() external view returns (string memory);\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n\r\n    function getIdentity() external view returns (address);\r\n\r\n    function isApprovedForAll(address wallet, address operator) external view returns (bool);\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n    */\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function tokenOfOwnerByIndex(\r\n        address wallet,\r\n        uint256 index\r\n    ) external view returns (uint256);\r\n    */\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function totalSupply() external view returns (uint256);\r\n    */\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external pure returns (bytes4);\r\n}\r\n\r\ninterface ICxipIdentity {\r\n    function addSignedWallet(\r\n        address newWallet,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function addWallet(address newWallet) external;\r\n\r\n    function connectWallet() external;\r\n\r\n    function createERC721Token(\r\n        address collection,\r\n        uint256 id,\r\n        TokenData calldata tokenData,\r\n        Verification calldata verification\r\n    ) external returns (uint256);\r\n\r\n    function createERC721Collection(\r\n        bytes32 saltHash,\r\n        address collectionCreator,\r\n        Verification calldata verification,\r\n        CollectionData calldata collectionData\r\n    ) external returns (address);\r\n\r\n    function createCustomERC721Collection(\r\n        bytes32 saltHash,\r\n        address collectionCreator,\r\n        Verification calldata verification,\r\n        CollectionData calldata collectionData,\r\n        bytes32 slot,\r\n        bytes memory bytecode\r\n    ) external returns (address);\r\n\r\n    function init(address wallet, address secondaryWallet) external;\r\n\r\n    function getAuthorizer(address wallet) external view returns (address);\r\n\r\n    function getCollectionById(uint256 index) external view returns (address);\r\n\r\n    function getCollectionType(address collection) external view returns (InterfaceType);\r\n\r\n    function getWallets() external view returns (address[] memory);\r\n\r\n    function isCollectionCertified(address collection) external view returns (bool);\r\n\r\n    function isCollectionRegistered(address collection) external view returns (bool);\r\n\r\n    function isNew() external view returns (bool);\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function isTokenCertified(address collection, uint256 tokenId) external view returns (bool);\r\n\r\n    function isTokenRegistered(address collection, uint256 tokenId) external view returns (bool);\r\n\r\n    function isWalletRegistered(address wallet) external view returns (bool);\r\n\r\n    function listCollections(uint256 offset, uint256 length) external view returns (address[] memory);\r\n\r\n    function nextNonce(address wallet) external view returns (uint256);\r\n\r\n    function totalCollections() external view returns (uint256);\r\n\r\n    function isCollectionOpen(address collection) external pure returns (bool);\r\n}\r\n\r\ninterface ICxipProvenance {\r\n    function createIdentity(\r\n        bytes32 saltHash,\r\n        address wallet,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256, address);\r\n\r\n    function createIdentityBatch(\r\n        bytes32 saltHash,\r\n        address[] memory wallets,\r\n        uint8[] memory V,\r\n        bytes32[] memory RS\r\n    ) external returns (uint256, address);\r\n\r\n    function getIdentity() external view returns (address);\r\n\r\n    function getWalletIdentity(address wallet) external view returns (address);\r\n\r\n    function informAboutNewWallet(address newWallet) external;\r\n\r\n    function isIdentityValid(address identity) external view returns (bool);\r\n\r\n    function nextNonce(address wallet) external view returns (uint256);\r\n}\r\n\r\ninterface ICxipRegistry {\r\n    function getAsset() external view returns (address);\r\n\r\n    function getAssetSigner() external view returns (address);\r\n\r\n    function getAssetSource() external view returns (address);\r\n\r\n    function getCopyright() external view returns (address);\r\n\r\n    function getCopyrightSource() external view returns (address);\r\n\r\n    function getCustomSource(bytes32 name) external view returns (address);\r\n\r\n    function getCustomSourceFromString(string memory name) external view returns (address);\r\n\r\n    function getERC1155CollectionSource() external view returns (address);\r\n\r\n    function getERC721CollectionSource() external view returns (address);\r\n\r\n    function getIdentitySource() external view returns (address);\r\n\r\n    function getPA1D() external view returns (address);\r\n\r\n    function getPA1DSource() external view returns (address);\r\n\r\n    function getProvenance() external view returns (address);\r\n\r\n    function getProvenanceSource() external view returns (address);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function setAsset(address proxy) external;\r\n\r\n    function setAssetSigner(address source) external;\r\n\r\n    function setAssetSource(address source) external;\r\n\r\n    function setCopyright(address proxy) external;\r\n\r\n    function setCopyrightSource(address source) external;\r\n\r\n    function setCustomSource(string memory name, address source) external;\r\n\r\n    function setERC1155CollectionSource(address source) external;\r\n\r\n    function setERC721CollectionSource(address source) external;\r\n\r\n    function setIdentitySource(address source) external;\r\n\r\n    function setPA1D(address proxy) external;\r\n\r\n    function setPA1DSource(address source) external;\r\n\r\n    function setProvenance(address proxy) external;\r\n\r\n    function setProvenanceSource(address source) external;\r\n}\r\n\r\n// This is a 256 value limit (uint8)\r\nenum InterfaceType {\r\n    NULL, // 0\r\n    ERC20, // 1\r\n    ERC721, // 2\r\n    ERC1155 // 3\r\n}\r\n\r\ninterface IPA1D {\r\n    function init(\r\n        uint256 tokenId,\r\n        address payable receiver,\r\n        uint256 bp\r\n    ) external;\r\n\r\n    function configurePayouts(address payable[] memory addresses, uint256[] memory bps) external;\r\n\r\n    function getPayoutInfo() external view returns (address payable[] memory addresses, uint256[] memory bps);\r\n\r\n    function getEthPayout() external;\r\n\r\n    function getTokenPayout(address tokenAddress) external;\r\n\r\n    function getTokenPayoutByName(string memory tokenName) external;\r\n\r\n    function getTokensPayout(address[] memory tokenAddresses) external;\r\n\r\n    function getTokensPayoutByName(string[] memory tokenNames) external;\r\n\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\r\n\r\n    function setRoyalties(\r\n        uint256 tokenId,\r\n        address payable receiver,\r\n        uint256 bp\r\n    ) external;\r\n\r\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\r\n\r\n    function getFeeBps(uint256 tokenId) external view returns (uint256[] memory);\r\n\r\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\r\n\r\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\r\n\r\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\r\n\r\n    function tokenCreator(address contractAddress, uint256 tokenId) external view returns (address);\r\n\r\n    function calculateRoyaltyFee(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        uint256 amount\r\n    ) external view returns (uint256);\r\n\r\n    function marketContract() external view returns (address);\r\n\r\n    function tokenCreators(uint256 tokenId) external view returns (address);\r\n\r\n    function bidSharesForToken(uint256 tokenId) external view returns (Zora.BidShares memory bidShares);\r\n\r\n    function getStorageSlot(string calldata slot) external pure returns (bytes32);\r\n\r\n    function getTokenAddress(string memory tokenName) external view returns (address);\r\n}\r\n\r\ncontract OpenSeaOwnableDelegateProxy {}\r\n\r\ncontract OpenSeaProxyRegistry {\r\n    mapping(address => OpenSeaOwnableDelegateProxy) public proxies;\r\n}\r\n\r\nlibrary Strings {\r\n    function toHexString(address account) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(account)));\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = bytes16(\"0123456789abcdef\")[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nstruct Token {\r\n    address collection;\r\n    uint256 tokenId;\r\n    InterfaceType tokenType;\r\n    address creator;\r\n}\r\n\r\nstruct TokenData {\r\n    bytes32 payloadHash;\r\n    Verification payloadSignature;\r\n    address creator;\r\n    bytes32 arweave;\r\n    bytes11 arweave2;\r\n    bytes32 ipfs;\r\n    bytes14 ipfs2;\r\n}\r\n\r\n// This is a 256 value limit (uint8)\r\nenum UriType {\r\n    ARWEAVE, // 0\r\n    IPFS, // 1\r\n    HTTP // 2\r\n}\r\n\r\nstruct Verification {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n}\r\n\r\nlibrary Zora {\r\n    struct Decimal {\r\n        uint256 value;\r\n    }\r\n\r\n    struct BidShares {\r\n        // % of sale value that goes to the _previous_ owner of the nft\r\n        Decimal prevOwner;\r\n        // % of sale value that goes to the original creator of the nft\r\n        Decimal creator;\r\n        // % of sale value that goes to the seller (current owner) of the nft\r\n        Decimal owner;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PermanentURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"arweaveURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData\",\"name\":\"tokenData\",\"type\":\"tuple\"}],\"name\":\"cxipMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdentity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"httpURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"royalties\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"bps\",\"type\":\"uint96\"}],\"internalType\":\"struct CollectionData\",\"name\":\"collectionData\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ipfsURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadSignature\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newName2\",\"type\":\"bytes32\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newSymbol\",\"type\":\"bytes32\"}],\"name\":\"setSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"verifySHA256\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CxipERC721","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cf7b130fa145542e8dedeca24cf1fcb40fe12cc6a96e00f41a65ea1e7dcdc6d4"}]}