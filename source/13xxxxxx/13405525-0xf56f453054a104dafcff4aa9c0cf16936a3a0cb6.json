{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/inft/FixedSupplySale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/AletheaERC721Spec.sol\\\";\\nimport \\\"./IntelligentNFTv2.sol\\\";\\nimport \\\"../utils/AccessControl.sol\\\";\\n\\n/**\\n * @title Fixed Supply Sale\\n *\\n * @notice Fixed Supply Sale sales fixed amount of iNFTs for a fixed price in a fixed period of time;\\n *      underlying NFTs and AI Personalities are being minted as well as a part of the sale process\\n *\\n * @notice In restricted mode (FEATURE_PUBLIC_SALE feature disabled) sells the items only to\\n *      accounts having `ROLE_BUYER` permission (used to mint first hundred iNFTs in the 10k sale campaign)\\n *\\n * @dev Technically, all the \\\"fixed\\\" parameters can be changed on the go after smart contract is deployed\\n *      and operational, but this ability is reserved for quick fix-like adjustments, and to provide\\n *      an ability to restart and run a similar sale after the previous one ends\\n *\\n * @dev When buying an iNFT from this smart contract:\\n *      1) next NFT is minted to the transaction sender address\\n *      2) next AI Personality is minted directly to iNFT smart contract for further locking\\n *      3) next iNFT is created, bound to an NFT minted in step (1)\\n *         and locking the AI Personality minted in step (2)\\n *      4) no ALI tokens are minted, no ALI tokens are locked or consumed in the process\\n *\\n * @dev Deployment and setup:\\n *      1. Deploy smart contract, specify smart contract addresses during the deployment\\n *         - iNFT deployed instance address\\n *         - NFT deployed instance address\\n *         - AI Personality deployed instance address\\n *      2. Execute `initialize` function and set up the sale parameters;\\n *         sale is not active until it's initialized\\n */\\ncontract FixedSupplySale is AccessControl {\\n\\t// ----- SLOT.1 (256/256)\\n\\t/**\\n\\t * @notice Price of a single iNFT minted (with the underlying NFT and AI Personality minted)\\n\\t *      When buying several iNFTs at once the price accumulates accordingly, with no discount\\n\\t *\\n\\t * @dev Maximum item price is ~18.44 ETH\\n\\t */\\n\\tuint64 public itemPrice;\\n\\n\\t/**\\n\\t * @dev Next iNFT / bound NFT / AI Personality ID to mint;\\n\\t *      initially this is the first \\\"free\\\" ID which can be minted;\\n\\t *      at any point in time this should point to a free, mintable ID\\n\\t *      for iNFT / bound NFT / AI Personality\\n\\t *\\n\\t * @dev `nextId` cannot be zero, we do not ever mint NFTs with zero IDs\\n\\t */\\n\\tuint32 public nextId = 1;\\n\\n\\t/**\\n\\t * @dev Last iNFT / bound NFT / AI Personality ID to mint;\\n\\t *      once `nextId` exceeds `finalId` the sale pauses\\n\\t */\\n\\tuint32 public finalId;\\n\\n\\t/**\\n\\t * @notice Sale start unix timestamp; the sale is active after the start (inclusive)\\n\\t */\\n\\tuint32 public saleStart;\\n\\n\\t/**\\n\\t * @notice Sale end unix timestamp; the sale is active before the end (exclusive)\\n\\t */\\n\\tuint32 public saleEnd;\\n\\n\\t/**\\n\\t * @notice Once set, limits the amount of iNFTs one can buy in a single transaction;\\n\\t *       When unset (zero) the amount of iNFTs is limited only by block size and\\n\\t *       amount of iNFTs left for sale\\n\\t */\\n\\tuint32 public batchLimit;\\n\\n\\t/**\\n\\t * @notice Counter of the iNFTs sold (minted) by this sale smart contract\\n\\t */\\n\\tuint32 public soldCounter;\\n\\n\\t// ----- NON-SLOTTED\\n\\t/**\\n\\t * @dev ALI ERC20 contract address to transfer tokens and bind to iNFTs created,\\n\\t *      should match with `iNftContract.aliContract`\\n\\t */\\n\\taddress public immutable aliContract;\\n\\n\\t/**\\n\\t * @dev NFT ERC721 contract address to mint NFTs from and bind to iNFTs created\\n\\t */\\n\\taddress public immutable nftContract;\\n\\n\\t/**\\n\\t * @dev Personality Pod ERC721 contract address to mint and lock into iNFTs created\\n\\t */\\n\\taddress public immutable personalityContract;\\n\\n\\t/**\\n\\t * @dev iNFT contract address used to create iNFTs\\n\\t */\\n\\taddress public immutable iNftContract;\\n\\n\\t// ----- SLOT.2\\n\\t/**\\n\\t * @dev iNFTs may get created with the ALI tokens bound to them.\\n\\t *      The tokens are transferred from the address specified.\\n\\t *      The address specified has to approve the sale to spend tokens.\\n\\t *\\n\\t * @dev Both `aliSource` and `aliValue` must be set in order to bind tokens\\n\\t *      to iNFTs sold\\n\\t *\\n\\t * @dev Both `aliSource` and `aliValue` can be either set or unset\\n\\t */\\n\\taddress public aliSource;\\n\\n\\t/**\\n\\t * @dev iNFTs may get created with the ALI tokens bound to them.\\n\\t *      Specified amount of tokens is transferred from the address specified above\\n\\t *      for each iNFT created, and is bound within the iNFT\\n\\t *      The address specified above has to approve the sale to spend tokens.\\n\\t *\\n\\t * @dev Both `aliSource` and `aliValue` must be set in order to bind tokens\\n\\t *      to iNFTs sold\\n\\t *\\n\\t * @dev Both `aliSource` and `aliValue` can be either set or unset\\n\\t */\\n\\tuint96 public aliValue;\\n\\n\\t/**\\n\\t * @notice Allows buying the items publicly, effectively ignoring the buyer permission\\n\\t *\\n\\t * @dev When `FEATURE_PUBLIC_SALE` is enabled, `ROLE_BUYER` is ignored and\\n\\t *      buying items via buy(), buyTo(), buySingle(), buySingleTo() becomes publicly accessible\\n\\t */\\n\\tuint32 public constant FEATURE_PUBLIC_SALE = 0x0000_0001;\\n\\n\\t/**\\n\\t * @notice Sale manager is responsible for managing properties of the sale,\\n\\t *      such as sale price, amount, start/end dates, etc.\\n\\t *\\n\\t * @dev Role ROLE_SALE_MANAGER allows updating sale properties via initialize() function\\n\\t */\\n\\tuint32 public constant ROLE_SALE_MANAGER = 0x0001_0000;\\n\\n\\t/**\\n\\t * @notice Withdrawal manager is responsible for withdrawing ETH obtained in sale\\n\\t *      from the sale smart contract\\n\\t *\\n\\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows ETH withdrawals:\\n\\t *      - withdraw()\\n\\t *      - withdrawTo()\\n\\t */\\n\\tuint32 public constant ROLE_WITHDRAWAL_MANAGER = 0x0002_0000;\\n\\n\\t/**\\n\\t * @notice Buyer can buy items via the restricted sale\\n\\t *\\n\\t * @dev Role ROLE_BUYER allows buying items via buy(), buyTo(), buySingle(), buySingleTo()\\n\\t */\\n\\tuint32 public constant ROLE_BUYER = 0x0004_0000;\\n\\n\\t/**\\n\\t * @dev Fired in initialize()\\n\\t *\\n\\t * @param _by an address which executed the initialization\\n\\t * @param _itemPrice price of one iNFT created\\n\\t * @param _nextId next ID of the iNFT, NFT, and AI Pod to mint\\n\\t * @param _finalId final ID of the iNFT, NFT, and AI Pod to mint\\n\\t * @param _saleStart start of the sale, unix timestamp\\n\\t * @param _saleEnd end of the sale, unix timestamp\\n\\t * @param _batchLimit how many iNFTs is allowed to buy in a single transaction\\n\\t * @param _aliSource an address to transfer ALI tokens from to bind to iNFTs created\\n\\t * @param _aliValue an amount of ALI tokens to transfer and bind for each iNFT created\\n\\t */\\n\\tevent Initialized(\\n\\t\\taddress indexed _by,\\n\\t\\tuint64 _itemPrice,\\n\\t\\tuint32 _nextId,\\n\\t\\tuint32 _finalId,\\n\\t\\tuint32 _saleStart,\\n\\t\\tuint32 _saleEnd,\\n\\t\\tuint32 _batchLimit,\\n\\t\\taddress indexed _aliSource,\\n\\t\\tuint96 _aliValue\\n\\t);\\n\\n\\t/**\\n\\t * @dev Fired in buy(), buyTo(), buySingle(), and buySingleTo()\\n\\t *\\n\\t * @param _by an address which executed and payed the transaction, probably a buyer\\n\\t * @param _to an address which received token(s) and iNFT(s) minted\\n\\t * @param _amount number of tokens and iNFTs minted\\n\\t * @param _aliValue number of ALI tokens transferred\\n\\t * @param _value ETH amount charged\\n\\t */\\n\\tevent Bought(address indexed _by, address indexed _to, uint256 _amount, uint256 _aliValue, uint256 _value);\\n\\n\\t/**\\n\\t * @dev Fired in withdraw() and withdrawTo()\\n\\t *\\n\\t * @param _by an address which executed the withdrawal\\n\\t * @param _to an address which received the ETH withdrawn\\n\\t * @param _value ETH amount withdrawn\\n\\t */\\n\\tevent Withdrawn(address indexed _by, address indexed _to, uint256 _value);\\n\\n\\t/**\\n\\t * @dev Creates/deploys FixedSupplySale and binds it to NFT, AI Personality, and iNFT\\n\\t *      smart contracts on construction\\n\\t *\\n\\t * @param _ali deployed ALI ERC20 smart contract address; sale may bind tokens to iNFTs created\\n\\t * @param _iNft deployed iNFT smart contract address; sale will create iNFTs of that type\\n\\t * @param _nft deployed NFT smart contract address; sale will mint NFTs of that type\\n\\t *      and bind created iNFT to these NFTs\\n\\t * @param _personality deployed AI Personality smart contract; sale will mint AI Personality\\n\\t *      tokens of that type and lock them within iNFTs\\n\\t */\\n\\tconstructor(address _ali, address _nft, address _personality, address _iNft) {\\n\\t\\t// verify the inputs are set\\n\\t\\trequire(_ali != address(0), \\\"ALI Token contract is not set\\\");\\n\\t\\trequire(_nft != address(0), \\\"NFT contract is not set\\\");\\n\\t\\trequire(_personality != address(0), \\\"AI Personality contract is not set\\\");\\n\\t\\trequire(_iNft != address(0), \\\"iNFT contract is not set\\\");\\n\\n\\t\\t// verify inputs are valid smart contracts of the expected interfaces\\n\\t\\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \\\"unexpected ALI Token type\\\");\\n\\t\\trequire(\\n\\t\\t\\tERC165(_nft).supportsInterface(type(ERC721).interfaceId)\\n\\t\\t\\t&& ERC165(_nft).supportsInterface(type(MintableERC721).interfaceId),\\n\\t\\t\\t\\\"unexpected NFT type\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\tERC165(_personality).supportsInterface(type(ERC721).interfaceId)\\n\\t\\t\\t&& ERC165(_personality).supportsInterface(type(MintableERC721).interfaceId),\\n\\t\\t\\t\\\"unexpected AI Personality type\\\"\\n\\t\\t);\\n\\t\\trequire(ERC165(_iNft).supportsInterface(type(IntelligentNFTv2Spec).interfaceId), \\\"unexpected iNFT type\\\");\\n\\n\\t\\t// assign the addresses\\n\\t\\taliContract = _ali;\\n\\t\\tnftContract = _nft;\\n\\t\\tpersonalityContract = _personality;\\n\\t\\tiNftContract = _iNft;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Number of iNFTs left on sale\\n\\t *\\n\\t * @dev Doesn't take into account if sale is active or not,\\n\\t *      if `nextId - finalId < 1` returns zero\\n\\t *\\n\\t * @return number of iNFTs left on sale\\n\\t */\\n\\tfunction itemsOnSale() public view returns(uint32) {\\n\\t\\t// calculate items left on sale, taking into account that\\n\\t\\t// finalId is on sale (inclusive bound)\\n\\t\\treturn finalId > nextId? finalId + 1 - nextId: 0;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Number of iNFTs available on sale\\n\\t *\\n\\t * @dev Takes into account if sale is active or not, doesn't throw,\\n\\t *      returns zero if sale is inactive\\n\\t *\\n\\t * @return number of iNFTs available on sale\\n\\t */\\n\\tfunction itemsAvailable() public view returns(uint32) {\\n\\t\\t// delegate to itemsOnSale() if sale is active, return zero otherwise\\n\\t\\treturn isActive()? itemsOnSale(): 0;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Active sale is an operational sale capable of minting and selling\\n\\t *      iNFTs (together with minting the underlying assets - NFTs and AI Personalities)\\n\\t *\\n\\t * @dev The sale is active when all the requirements below are met:\\n\\t *      1. Price is set (`itemPrice` is not zero)\\n\\t *      2. `finalId` is not reached (`nextId <= finalId`)\\n\\t *      3. current timestamp is between `saleStart` (inclusive) and `saleEnd` (exclusive)\\n\\t *\\n\\t * @dev Function is marked as virtual to be overridden in the helper test smart contract (mock)\\n\\t *      in order to test how it affects the sale process\\n\\t *\\n\\t * @return true if sale is active (operational) and can sell iNFTs, false otherwise\\n\\t */\\n\\tfunction isActive() public view virtual returns(bool) {\\n\\t\\t// evaluate sale state based on the internal state variables and return\\n\\t\\treturn itemPrice > 0 && nextId <= finalId && saleStart <= now256() && saleEnd > now256();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function to set up sale parameters, all at once,\\n\\t *      or any subset of them\\n\\t *\\n\\t * @dev To skip parameter initialization, set it to `-1`,\\n\\t *      that is a maximum value for unsigned integer of the corresponding type;\\n\\t *      `_aliSource` and `_aliValue` must both be either set or skipped\\n\\t *\\n\\t * @dev Example: following initialization will update only _itemPrice and _batchLimit,\\n\\t *      leaving the rest of the fields unchanged\\n\\t *      initialize(\\n\\t *          100000000000000000,\\n\\t *          0xFFFFFFFF,\\n\\t *          0xFFFFFFFF,\\n\\t *          0xFFFFFFFF,\\n\\t *          0xFFFFFFFF,\\n\\t *          10,\\n\\t *          0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF,\\n\\t *          0xFFFFFFFFFFFFFFFFFFFFFFFF\\n\\t *      )\\n\\t *\\n\\t * @dev Requires next ID to be greater than zero (strict): `_nextId > 0`\\n\\t * @dev Requires ALI source/value to be both either set or unset (zero);\\n\\t *      if set, ALI value must not be less than 1e12 (0.000001 ALI)\\n\\t *\\n\\t * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\\n\\t *\\n\\t * @param _itemPrice price of one iNFT created (with NFT and AI Personality also minted);\\n\\t *      setting the price to zero deactivates the sale\\n\\t * @param _nextId next ID of the iNFT, NFT, and AI Pod to mint, will be increased\\n\\t *      in smart contract storage after every successful buy\\n\\t * @param _finalId final ID of the iNFT, NFT, and AI Pod to mint; sale is capable of producing\\n\\t *      `_finalId - _nextId + 1` iNFTs\\n\\t * @param _saleStart start of the sale, unix timestamp\\n\\t * @param _saleEnd end of the sale, unix timestamp; sale is active only\\n\\t *      when current time is within _saleStart (inclusive) and _saleEnd (exclusive)\\n\\t * @param _batchLimit how many iNFTs is allowed to buy in a single transaction,\\n\\t *      set to zero to disable the limit\\n\\t * @param _aliSource an address to transfer ALI tokens from to bind to iNFTs created\\n\\t * @param _aliValue an amount of ALI tokens to transfer and bind for each iNFT created\\n\\t */\\n\\tfunction initialize(\\n\\t\\tuint64 _itemPrice,\\t// <<<--- keep type in sync with the body type(uint64).max !!!\\n\\t\\tuint32 _nextId,\\t// <<<--- keep type in sync with the body type(uint32).max !!!\\n\\t\\tuint32 _finalId,\\t// <<<--- keep type in sync with the body type(uint32).max !!!\\n\\t\\tuint32 _saleStart,\\t// <<<--- keep type in sync with the body type(uint32).max !!!\\n\\t\\tuint32 _saleEnd,\\t// <<<--- keep type in sync with the body type(uint32).max !!!\\n\\t\\tuint32 _batchLimit,\\t// <<<--- keep type in sync with the body type(uint32).max !!!\\n\\t\\taddress _aliSource,\\t// <<<--- keep that in sync with the body type(uint160).max !!!\\n\\t\\tuint96 _aliValue\\t// <<<--- keep type in sync with the body type(uint96).max !!!\\n\\t) public {\\n\\t\\t// check the access permission\\n\\t\\trequire(isSenderInRole(ROLE_SALE_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// verify the inputs\\n\\t\\trequire(_nextId > 0, \\\"zero nextId\\\");\\n\\t\\t// ALI source/value should be either both set or both unset\\n\\t\\t// ALI value must not be too low if set\\n\\t\\trequire(_aliSource == address(0) && _aliValue == 0 || _aliSource != address(0) && _aliValue >= 1e12, \\\"invalid ALI source/value\\\");\\n\\n\\t\\t// no need to verify extra parameters - \\\"incorrect\\\" values will deactivate the sale\\n\\n\\t\\t// initialize contract state based on the values supplied\\n\\t\\t// take into account our convention that value `-1` means \\\"do not set\\\"\\n\\t\\t// 0xFFFFFFFFFFFFFFFF, 64 bits\\n\\t\\tif(_itemPrice != type(uint64).max) {\\n\\t\\t\\titemPrice = _itemPrice;\\n\\t\\t}\\n\\t\\t// 0xFFFFFFFF, 32 bits\\n\\t\\tif(_nextId != type(uint32).max) {\\n\\t\\t\\tnextId = _nextId;\\n\\t\\t}\\n\\t\\t// 0xFFFFFFFF, 32 bits\\n\\t\\tif(_finalId != type(uint32).max) {\\n\\t\\t\\tfinalId = _finalId;\\n\\t\\t}\\n\\t\\t// 0xFFFFFFFF, 32 bits\\n\\t\\tif(_saleStart != type(uint32).max) {\\n\\t\\t\\tsaleStart = _saleStart;\\n\\t\\t}\\n\\t\\t// 0xFFFFFFFF, 32 bits\\n\\t\\tif(_saleEnd != type(uint32).max) {\\n\\t\\t\\tsaleEnd = _saleEnd;\\n\\t\\t}\\n\\t\\t// 0xFFFFFFFF, 32 bits\\n\\t\\tif(_batchLimit != type(uint32).max) {\\n\\t\\t\\tbatchLimit = _batchLimit;\\n\\t\\t}\\n\\t\\t// 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF and 0xFFFFFFFFFFFFFFFFFFFFFFFF, 160 and 96 bits\\n\\t\\tif(uint160(_aliSource) != type(uint160).max && _aliValue != type(uint96).max) {\\n\\t\\t\\taliSource = _aliSource;\\n\\t\\t\\taliValue = _aliValue;\\n\\t\\t}\\n\\n\\t\\t// emit an event - read values from the storage since not all of them might be set\\n\\t\\temit Initialized(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\titemPrice,\\n\\t\\t\\tnextId,\\n\\t\\t\\tfinalId,\\n\\t\\t\\tsaleStart,\\n\\t\\t\\tsaleEnd,\\n\\t\\t\\tbatchLimit,\\n\\t\\t\\taliSource,\\n\\t\\t\\taliValue\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Buys several (at least two) iNFTs in a batch.\\n\\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\\n\\t *\\n\\t * @param _amount amount of iNFTs to create (same amount of NFTs and AI Personalities\\n\\t *      will be created and bound/locked to iNFT), two or more\\n\\t */\\n\\tfunction buy(uint32 _amount) public virtual payable {\\n\\t\\t// delegate to `buyTo` with the transaction sender set to be a recipient\\n\\t\\tbuyTo(msg.sender, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Buys several (at least two) iNFTs in a batch to an address specified.\\n\\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\\n\\t *\\n\\t * @param _to address to mint tokens and iNFTs to\\n\\t * @param _amount amount of iNFTs to create (same amount of NFTs and AI Personalities\\n\\t *      will be created and bound/locked to iNFT), two or more\\n\\t */\\n\\tfunction buyTo(address _to, uint32 _amount) public virtual payable {\\n\\t\\t// check the access permission\\n\\t\\trequire(isFeatureEnabled(FEATURE_PUBLIC_SALE) || isSenderInRole(ROLE_BUYER), \\\"access denied\\\");\\n\\n\\t\\t// verify the inputs\\n\\t\\trequire(_to != address(0), \\\"recipient not set\\\");\\n\\t\\trequire(_amount > 1 && (batchLimit == 0 || _amount <= batchLimit), \\\"incorrect amount\\\");\\n\\n\\t\\t// verify there is enough items available to buy the amount\\n\\t\\t// verifies sale is in active state under the hood\\n\\t\\trequire(itemsAvailable() >= _amount, \\\"inactive sale or not enough items available\\\");\\n\\n\\t\\t// calculate the total price required and validate the transaction value\\n\\t\\tuint256 totalPrice = uint256(itemPrice) * _amount;\\n\\t\\trequire(msg.value >= totalPrice, \\\"not enough funds\\\");\\n\\n\\t\\t// based on ALI value set on the contract and amount of iNFTs to create\\n\\t\\t// calculate the cumulative ALI value to be sent to iNFT\\n\\t\\t// note: cumulative ALI value may overflow uint96, store it into uint256 on stack\\n\\t\\tuint256 _aliValue = uint256(aliValue) * _amount;\\n\\t\\t// if it's not zero (that is if ALI token binding is enabled)\\n\\t\\tif(_aliValue != 0) {\\n\\t\\t\\t// transfer ALI amount required to iNFT smart contract\\n\\t\\t\\tERC20(aliContract).transferFrom(aliSource, iNftContract, _aliValue);\\n\\t\\t}\\n\\n\\t\\t// mint NFTs to the recipient\\n\\t\\tMintableERC721(nftContract).safeMintBatch(_to, nextId, _amount);\\n\\n\\t\\t// mint AI Personality directly to iNFT smart contract\\n\\t\\tMintableERC721(personalityContract).mintBatch(iNftContract, nextId, _amount);\\n\\n\\t\\t// create iNFT bound to NFT minted and locking the AI Personality minted\\n\\t\\tIntelligentNFTv2(iNftContract).mintBatch(\\n\\t\\t\\tnextId, // first recordId\\n\\t\\t\\taliValue, // ALI value\\n\\t\\t\\tpersonalityContract, // AI Personality contract address\\n\\t\\t\\tnextId, // first AI Personality ID\\n\\t\\t\\tnftContract, // NFT contract address\\n\\t\\t\\tnextId, // first target NFT ID\\n\\t\\t\\t_amount // amount of iNFTs to create\\n\\t\\t);\\n\\n\\t\\t// increment `nextId`\\n\\t\\tnextId += _amount;\\n\\t\\t// increment `soldCounter`\\n\\t\\tsoldCounter += _amount;\\n\\n\\t\\t// if ETH amount supplied exceeds the price\\n\\t\\tif(msg.value > totalPrice) {\\n\\t\\t\\t// send excess amount back to sender\\n\\t\\t\\tpayable(msg.sender).transfer(msg.value - totalPrice);\\n\\t\\t}\\n\\n\\t\\t// emit en event\\n\\t\\temit Bought(msg.sender, _to, _amount, _aliValue, totalPrice);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Buys single iNFTs.\\n\\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\\n\\t */\\n\\tfunction buySingle() public virtual payable {\\n\\t\\t// delegate to `buySingleTo` with the transaction sender set to be a recipient\\n\\t\\tbuySingleTo(msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Buys single iNFTs to an address specified.\\n\\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\\n\\t *\\n\\t * @param _to address to mint tokens and iNFT to\\n\\t */\\n\\tfunction buySingleTo(address _to) public virtual payable {\\n\\t\\t// check the access permission\\n\\t\\trequire(isFeatureEnabled(FEATURE_PUBLIC_SALE) || isSenderInRole(ROLE_BUYER), \\\"access denied\\\");\\n\\n\\t\\t// verify the inputs and transaction value\\n\\t\\trequire(_to != address(0), \\\"recipient not set\\\");\\n\\t\\trequire(msg.value >= itemPrice, \\\"not enough funds\\\");\\n\\n\\t\\t// verify sale is in active state\\n\\t\\trequire(isActive(), \\\"inactive sale\\\");\\n\\n\\t\\t// if ALI token binding is enabled\\n\\t\\tif(aliValue != 0) {\\n\\t\\t\\t// transfer ALI amount required to iNFT smart contract\\n\\t\\t\\tERC20(aliContract).transferFrom(aliSource, iNftContract, aliValue);\\n\\t\\t}\\n\\t\\t// mint NFT to the recipient\\n\\t\\tMintableERC721(nftContract).safeMint(_to, nextId);\\n\\t\\t// mint AI Personality directly to iNFT smart contract\\n\\t\\tMintableERC721(personalityContract).mint(iNftContract, nextId);\\n\\t\\t// create iNFT bound to NFT minted and locking the AI Personality minted\\n\\t\\tIntelligentNFTv2(iNftContract).mint(nextId, aliValue, personalityContract, nextId, nftContract, nextId);\\n\\n\\t\\t// increment `nextId`\\n\\t\\tnextId++;\\n\\t\\t// increment `soldCounter`\\n\\t\\tsoldCounter++;\\n\\n\\t\\t// if ETH amount supplied exceeds the price\\n\\t\\tif(msg.value > itemPrice) {\\n\\t\\t\\t// send excess amount back to sender\\n\\t\\t\\tpayable(msg.sender).transfer(msg.value - itemPrice);\\n\\t\\t}\\n\\n\\t\\t// emit en event\\n\\t\\temit Bought(msg.sender, _to, 1, aliValue, itemPrice);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function to withdraw ETH on the contract balance,\\n\\t *      sends ETH back to transaction sender\\n\\t */\\n\\tfunction withdraw() public {\\n\\t\\t// delegate to `withdrawTo`\\n\\t\\twithdrawTo(msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function to withdraw ETH on the contract balance,\\n\\t *      sends ETH to the address specified\\n\\t *\\n\\t * @param _to an address to send ETH to\\n\\t */\\n\\tfunction withdrawTo(address _to) public {\\n\\t\\t// check the access permission\\n\\t\\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// verify withdrawal address is set\\n\\t\\trequire(_to != address(0), \\\"address not set\\\");\\n\\n\\t\\t// ETH value to send\\n\\t\\tuint256 _value = address(this).balance;\\n\\n\\t\\t// verify sale balance is positive (non-zero)\\n\\t\\trequire(_value > 0, \\\"zero balance\\\");\\n\\n\\t\\t// send the entire balance to the transaction sender\\n\\t\\tpayable(_to).transfer(_value);\\n\\n\\t\\t// emit en event\\n\\t\\temit Withdrawn(msg.sender, _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Testing time-dependent functionality may be difficult;\\n\\t *      we override time in the helper test smart contract (mock)\\n\\t *\\n\\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\\n\\t */\\n\\tfunction now256() public view virtual returns (uint256) {\\n\\t\\t// return current block timestamp\\n\\t\\treturn block.timestamp;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AletheaERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n/**\\n * @title Alethea Mintable ERC721\\n *\\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what mintable means for ERC721\\n */\\ninterface MintableERC721 {\\n\\t/**\\n\\t * @notice Checks if specified token exists\\n\\t *\\n\\t * @dev Returns whether the specified token ID has an ownership\\n\\t *      information associated with it\\n\\t *\\n\\t * @param _tokenId ID of the token to query existence for\\n\\t * @return whether the token exists (true - exists, false - doesn't exist)\\n\\t */\\n\\tfunction exists(uint256 _tokenId) external view returns(bool);\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `saveMint` instead of `mint`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction mint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint tokens to\\n\\t * @param _tokenId ID of the first token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\\n}\\n\\n/**\\n * @title Alethea Burnable ERC721\\n *\\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what burnable means for ERC721\\n */\\ninterface BurnableERC721 {\\n\\t/**\\n\\t * @notice Destroys the token with token ID specified\\n\\t *\\n\\t * @dev Should be accessible publicly by token owners.\\n\\t *      May have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _tokenId ID of the token to burn\\n\\t */\\n\\tfunction burn(uint256 _tokenId) external;\\n}\\n\\n/**\\n * @title With Base URI\\n *\\n * @notice A marker interface for the contracts having the baseURI() function\\n *      or public string variable named baseURI\\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\\n */\\ninterface WithBaseURI {\\n\\t/**\\n\\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\\n\\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\\n\\t *\\n\\t * @dev For example, if base URI is https://api.com/token/, then token #1\\n\\t *      will have an URI https://api.com/token/1\\n\\t */\\n\\tfunction baseURI() external view returns(string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/inft/IntelligentNFTv2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/ERC20Spec.sol\\\";\\nimport \\\"../interfaces/ERC721Spec.sol\\\";\\nimport \\\"../lib/StringUtils.sol\\\";\\nimport \\\"../utils/AccessControl.sol\\\";\\n\\n/**\\n * @title Intelligent NFT Interface\\n *        Version 2\\n *\\n * @notice External interface of IntelligentNFTv2 declared to support ERC165 detection.\\n *      Despite some similarity with ERC721 interfaces, iNFT is not ERC721, any similarity\\n *      should be treated as coincidental. Client applications may benefit from this similarity\\n *      to reuse some of the ERC721 client code for display/reading.\\n *\\n * @dev See Intelligent NFT documentation below.\\n */\\ninterface IntelligentNFTv2Spec {\\n\\t/**\\n\\t * @dev ERC20/ERC721 like name - Intelligent NFT\\n\\t *\\n\\t * @return \\\"Intelligent NFT\\\"\\n\\t */\\n\\tfunction name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev ERC20/ERC721 like symbol - iNFT\\n\\t *\\n\\t * @return \\\"iNFT\\\"\\n\\t */\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev ERC721 like link to the iNFT metadata\\n\\t *\\n\\t * @param recordId iNFT ID to get metadata URI for\\n\\t */\\n\\tfunction tokenURI(uint256 recordId) external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev ERC20/ERC721 like counter of the iNFTs in existence (upper bound),\\n\\t *      some (or all) of which may not exist due to target NFT destruction\\n\\t *\\n\\t * @return amount of iNFT tracked by this smart contract\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Check if iNFT binding with the given ID exists\\n\\t *\\n\\t * @return true if iNFT binding exist, false otherwise\\n\\t */\\n\\tfunction exists(uint256 recordId) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev ERC721 like function to get owner of the iNFT, which is by definition\\n\\t *      an owner of the underlying NFT\\n\\t */\\n\\tfunction ownerOf(uint256 recordId) external view returns (address);\\n}\\n\\n/**\\n * @title Intelligent NFT (iNFT)\\n *        Version 2\\n *\\n * @notice Intelligent NFT (iNFT) represents an enhancement to an existing NFT\\n *      (we call it a \\\"target\\\" or \\\"target NFT\\\"), it binds a GPT-3 prompt (a \\\"personality prompt\\\",\\n *      delivered as a Personality Pod ERC721 token bound to iNFT)\\n *      to the target to embed intelligence, is controlled and belongs to the owner of the target.\\n *\\n * @notice iNFT stores AI Personality and some amount of ALI tokens locked, available for\\n *      unlocking when iNFT is destroyed\\n *\\n * @notice iNFT is not an ERC721 token, but it has some very limited similarity to an ERC721:\\n *      every record is identified by ID and this ID has an owner, which is effectively the target NFT owner;\\n *      still, it doesn't store ownership information itself and fully relies on the target ownership instead\\n *\\n * @dev Internally iNFTs consist of:\\n *      - target NFT - smart contract address and ID of the NFT the iNFT is bound to\\n *      - AI Personality - smart contract address and ID of the AI Personality used to produce given iNFT,\\n *        representing a \\\"personality prompt\\\", and locked within an iNFT\\n *      - ALI tokens amount - amount of the ALI tokens used to produce given iNFT, also locked\\n *\\n * @dev iNFTs can be\\n *      - created, this process requires an AI Personality and ALI tokens to be locked\\n *      - destroyed, this process releases an AI Personality and ALI tokens previously locked\\n */\\ncontract IntelligentNFTv2 is IntelligentNFTv2Spec, AccessControl, ERC165 {\\n\\t/**\\n\\t * @inheritdoc IntelligentNFTv2Spec\\n\\t */\\n\\tstring public override name = \\\"Intelligent NFT\\\";\\n\\n\\t/**\\n\\t * @inheritdoc IntelligentNFTv2Spec\\n\\t */\\n\\tstring public override symbol = \\\"iNFT\\\";\\n\\n\\t/**\\n\\t * @dev Each intelligent token, represented by its unique ID, is bound to the target NFT,\\n\\t *      defined by the pair of the target NFT smart contract address and unique token ID\\n\\t *      within the target NFT smart contract\\n\\t *\\n\\t * @dev Effectively iNFT is owned by the target NFT owner\\n\\t *\\n\\t * @dev Additionally, each token holds an AI Personality and some amount of ALI tokens bound to it\\n\\t *\\n\\t * @dev `IntelliBinding` keeps all the binding information, including target NFT coordinates,\\n\\t *      bound AI Personality ID, and amount of ALI ERC20 tokens bound to the iNFT\\n\\t */\\n\\tstruct IntelliBinding {\\n\\t\\t// Note: structure members are reordered to fit into less memory slots, see EVM memory layout\\n\\t\\t// ----- SLOT.1 (256/256)\\n\\t\\t/**\\n\\t\\t * @dev Specific AI Personality is defined by the pair of AI Personality smart contract address\\n\\t\\t *       and AI Personality ID\\n\\t\\t *\\n\\t\\t * @dev Address of the AI Personality smart contract\\n\\t\\t */\\n\\t\\taddress personalityContract;\\n\\n\\t\\t/**\\n\\t\\t * @dev AI Personality ID within the AI Personality smart contract\\n\\t\\t */\\n\\t\\tuint96 personalityId;\\n\\n\\t\\t// ----- SLOT.2 (256/256)\\n\\t\\t/**\\n\\t\\t * @dev Amount of an ALI ERC20 tokens bound to (owned by) the iNFTs\\n\\t\\t *\\n\\t\\t * @dev ALI ERC20 smart contract address is defined globally as `aliContract` constant\\n\\t\\t */\\n\\t\\tuint96 aliValue;\\n\\n\\t\\t/**\\n\\t\\t * @dev Address of the target NFT deployed smart contract,\\n\\t\\t *      this is a contract a particular iNFT is bound to\\n\\t\\t */\\n\\t\\taddress targetContract;\\n\\n\\t\\t// ----- SLOT.3 (256/256)\\n\\t\\t/**\\n\\t\\t * @dev Target NFT ID within the target NFT smart contract,\\n\\t\\t *      effectively target NFT ID and contract address define the owner of an iNFT\\n\\t\\t */\\n\\t\\tuint256 targetId;\\n\\t}\\n\\n\\t/**\\n\\t * @notice iNFT binding storage, stores binding information for each existing iNFT\\n\\t * @dev Maps iNFT ID to its binding data, which includes underlying NFT data\\n\\t */\\n\\tmapping(uint256 => IntelliBinding) public bindings;\\n\\n\\t/**\\n\\t * @notice Reverse iNFT binding allows to find iNFT bound to a particular NFT\\n\\t * @dev Maps target NFT (smart contract address and unique token ID) to the iNFT ID:\\n\\t *      NFT Contract => NFT ID => iNFT ID\\n\\t */\\n\\tmapping(address => mapping(uint256 => uint256)) public reverseBindings;\\n\\n\\t/**\\n\\t * @notice Ai Personality to iNFT binding allows to find iNFT bound to a particular Ai Personality\\n\\t * @dev Maps Ai Personality NFT (unique token ID) to the linked iNFT:\\n\\t *      AI Personality Contract => AI Personality ID => iNFT ID\\n\\t */\\n\\tmapping(address => mapping(uint256 => uint256)) public personalityBindings;\\n\\n\\t/**\\n\\t * @notice Total amount (maximum value estimate) of iNFT in existence.\\n\\t *       This value can be higher than number of effectively accessible iNFTs\\n\\t *       since when underlying NFT gets burned this value doesn't get updated.\\n\\t */\\n\\tuint256 public override totalSupply;\\n\\n\\t/**\\n\\t * @notice Each iNFT holds some ALI tokens, which are tracked by the ALI token ERC20 smart contract defined here\\n\\t */\\n\\taddress public immutable aliContract;\\n\\n\\t/**\\n\\t * @notice ALI token balance the contract is aware of, cumulative ALI obligation,\\n\\t *      i.e. sum of all iNFT locked ALI balances\\n\\t *\\n\\t * @dev Sum of all `IntelliBinding.aliValue` for each iNFT in existence\\n\\t */\\n\\tuint256 public aliBalance;\\n\\n\\t/**\\n\\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\\n\\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\\n\\t *\\n\\t * @dev For example, if base URI is https://api.com/token/, then token #1\\n\\t *      will have an URI https://api.com/token/1\\n\\t *\\n\\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\\n\\t */\\n\\tstring public baseURI = \\\"\\\";\\n\\n\\t/**\\n\\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\\n\\t *      is called; if mapping doesn't exist for token, the URI is constructed\\n\\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\\n\\t */\\n\\tmapping(uint256 => string) internal _tokenURIs;\\n\\n\\t/**\\n\\t * @notice Minter is responsible for creating (minting) iNFTs\\n\\t *\\n\\t * @dev Role ROLE_MINTER allows minting iNFTs (calling `mint` function)\\n\\t */\\n\\tuint32 public constant ROLE_MINTER = 0x0001_0000;\\n\\n\\t/**\\n\\t * @notice Burner is responsible for destroying (burning) iNFTs\\n\\t *\\n\\t * @dev Role ROLE_BURNER allows burning iNFTs (calling `burn` function)\\n\\t */\\n\\tuint32 public constant ROLE_BURNER = 0x0002_0000;\\n\\n\\t/**\\n\\t * @notice Editor is responsible for editing (updating) iNFT records in general,\\n\\t *      adding/removing locked ALI tokens to/from iNFT in particular\\n\\t *\\n\\t * @dev Role ROLE_EDITOR allows editing iNFTs (calling `increaseAli`, `decreaseAli` functions)\\n\\t */\\n\\tuint32 public constant ROLE_EDITOR = 0x0004_0000;\\n\\n\\t/**\\n\\t * @notice URI manager is responsible for managing base URI\\n\\t *      part of the token URI ERC721Metadata interface\\n\\t *\\n\\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\\n\\t *      (executing `setBaseURI` function)\\n\\t */\\n\\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\\n\\n\\t/**\\n\\t * @dev Fired in setBaseURI()\\n\\t *\\n\\t * @param _by an address which executed update\\n\\t * @param _oldVal old _baseURI value\\n\\t * @param _newVal new _baseURI value\\n\\t */\\n\\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\\n\\n\\t/**\\n\\t * @dev Fired in setTokenURI()\\n\\t *\\n\\t * @param _by an address which executed update\\n\\t * @param _tokenId token ID which URI was updated\\n\\t * @param _oldVal old _baseURI value\\n\\t * @param _newVal new _baseURI value\\n\\t */\\n\\tevent TokenURIUpdated(address indexed _by, uint256 indexed _tokenId, string _oldVal, string _newVal);\\n\\n\\t/**\\n\\t * @dev Fired in mint() when new iNFT is created\\n\\t *\\n\\t * @param _by an address which executed the mint function\\n\\t * @param _owner current owner of the NFT\\n\\t * @param _recordId ID of the iNFT minted (created, bound)\\n\\t * @param _aliValue amount of ALI tokens locked within newly created iNFT\\n\\t * @param _personalityContract AI Personality smart contract address\\n\\t * @param _personalityId ID of the AI Personality locked within newly created iNFT\\n\\t * @param _targetContract target NFT smart contract address\\n\\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\\n\\t */\\n\\tevent Minted(\\n\\t\\taddress indexed _by,\\n\\t\\taddress indexed _owner,\\n\\t\\tuint256 indexed _recordId,\\n\\t\\tuint96 _aliValue,\\n\\t\\taddress _personalityContract,\\n\\t\\tuint96 _personalityId,\\n\\t\\taddress _targetContract,\\n\\t\\tuint256 _targetId\\n\\t);\\n\\n\\t/**\\n\\t * @dev Fired in increaseAli() and decreaseAli() when iNFT record is updated\\n\\t *\\n\\t * @param _by an address which executed the update\\n\\t * @param _owner iNFT (target NFT) owner\\n\\t * @param _recordId ID of the updated iNFT\\n\\t * @param _oldAliValue amount of ALI tokens locked within iNFT before update\\n\\t * @param _newAliValue amount of ALI tokens locked within iNFT after update\\n\\t */\\n\\tevent Updated(\\n\\t\\taddress indexed _by,\\n\\t\\taddress indexed _owner,\\n\\t\\tuint256 indexed _recordId,\\n\\t\\tuint96 _oldAliValue,\\n\\t\\tuint96 _newAliValue\\n\\t);\\n\\n\\t/**\\n\\t * @dev Fired in burn() when an existing iNFT gets destroyed\\n\\t *\\n\\t * @param _by an address which executed the burn function\\n\\t * @param _recordId ID of the iNFT burnt (destroyed, unbound)\\n\\t * @param _recipient and address which received unlocked AI Personality and ALI tokens\\n\\t * @param _aliValue amount of ALI tokens transferred from the destroyed iNFT\\n\\t * @param _personalityContract AI Personality smart contract address\\n\\t * @param _personalityId ID of the AI Personality transferred from the destroyed iNFT\\n\\t * @param _targetContract target NFT smart contract\\n\\t * @param _targetId target NFT ID (where this iNFT was bound to and belonged to)\\n\\t */\\n\\tevent Burnt(\\n\\t\\taddress indexed _by,\\n\\t\\tuint256 indexed _recordId,\\n\\t\\taddress indexed _recipient,\\n\\t\\tuint96 _aliValue,\\n\\t\\taddress _personalityContract,\\n\\t\\tuint96 _personalityId,\\n\\t\\taddress _targetContract,\\n\\t\\tuint256 _targetId\\n\\t);\\n\\n\\t/**\\n\\t * @dev Creates/deploys an iNFT instance bound to already ALI token instance\\n\\t *\\n\\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT is bound to\\n\\t */\\n\\tconstructor(address _ali) {\\n\\t\\t// verify the inputs are set\\n\\t\\trequire(_ali != address(0), \\\"ALI Token addr is not set\\\");\\n\\n\\t\\t// verify _ali is a valid ERC20\\n\\t\\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \\\"unexpected ALI Token type\\\");\\n\\n\\t\\t// setup smart contract internal state\\n\\t\\taliContract = _ali;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc ERC165\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\n\\t\\t// reconstruct from current interface and super interface\\n\\t\\treturn interfaceId == type(IntelligentNFTv2Spec).interfaceId;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which updates base URI used to construct\\n\\t *      ERC721Metadata.tokenURI\\n\\t *\\n\\t * @param _baseURI new base URI to set\\n\\t */\\n\\tfunction setBaseURI(string memory _baseURI) public virtual {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_URI_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// emit an event first - to log both old and new values\\n\\t\\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\\n\\n\\t\\t// and update base URI\\n\\t\\tbaseURI = _baseURI;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns token URI if it was previously set with `setTokenURI`,\\n\\t *      otherwise constructs it as base URI + token ID\\n\\t *\\n\\t * @param _recordId iNFT ID to query metadata link URI for\\n\\t * @return URI link to fetch iNFT metadata from\\n\\t */\\n\\tfunction tokenURI(uint256 _recordId) public view override returns (string memory) {\\n\\t\\t// verify token exists\\n\\t\\trequire(exists(_recordId), \\\"iNFT doesn't exist\\\");\\n\\n\\t\\t// read the token URI for the token specified\\n\\t\\tstring memory _tokenURI = _tokenURIs[_recordId];\\n\\n\\t\\t// if token URI is set\\n\\t\\tif(bytes(_tokenURI).length > 0) {\\n\\t\\t\\t// just return it\\n\\t\\t\\treturn _tokenURI;\\n\\t\\t}\\n\\n\\t\\t// if base URI is not set\\n\\t\\tif(bytes(baseURI).length == 0) {\\n\\t\\t\\t// return an empty string\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\t}\\n\\n\\t\\t// otherwise concatenate base URI + token ID\\n\\t\\treturn StringUtils.concat(baseURI, StringUtils.itoa(_recordId, 10));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets the token URI for the token defined by its ID\\n\\t *\\n\\t * @param _tokenId an ID of the token to set URI for\\n\\t * @param _tokenURI token URI to set\\n\\t */\\n\\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_URI_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// we do not verify token existence: we want to be able to\\n\\t\\t// preallocate token URIs before tokens are actually minted\\n\\n\\t\\t// emit an event first - to log both old and new values\\n\\t\\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\\n\\n\\t\\t// and update token URI\\n\\t\\t_tokenURIs[_tokenId] = _tokenURI;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Verifies if given iNFT exists\\n\\t *\\n\\t * @param recordId iNFT ID to verify existence of\\n\\t * @return true if iNFT exists, false otherwise\\n\\t */\\n\\tfunction exists(uint256 recordId) public view override returns (bool) {\\n\\t\\t// verify if biding exists for that tokenId and return the result\\n\\t\\treturn bindings[recordId].targetContract != address(0);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns an owner of the given iNFT.\\n\\t *      By definition iNFT owner is an owner of the target NFT\\n\\t *\\n\\t * @param recordId iNFT ID to query ownership information for\\n\\t * @return address of the given iNFT owner\\n\\t */\\n\\tfunction ownerOf(uint256 recordId) public view override returns (address) {\\n\\t\\t// get the link to the token binding (we need to access only one field)\\n\\t\\tIntelliBinding storage binding = bindings[recordId];\\n\\n\\t\\t// verify the binding exists and throw standard Zeppelin message if not\\n\\t\\trequire(binding.targetContract != address(0), \\\"iNFT doesn't exist\\\");\\n\\n\\t\\t// delegate `ownerOf` call to the target NFT smart contract\\n\\t\\treturn ERC721(binding.targetContract).ownerOf(binding.targetId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which creates an iNFT, binding it to the specified\\n\\t *      NFT, locking the AI Personality specified, and funded with the amount of ALI specified\\n\\t *\\n\\t * @dev Locks AI Personality defined by its ID within iNFT smart contract;\\n\\t *      AI Personality must be transferred to the iNFT smart contract\\n\\t *      prior to calling the `mint`, but in the same transaction with `mint`\\n\\t *\\n\\t * @dev Locks specified amount of ALI token within iNFT smart contract;\\n\\t *      ALI token amount must be transferred to the iNFT smart contract\\n\\t *      prior to calling the `mint`, but in the same transaction with `mint`\\n\\t *\\n\\t * @dev To summarize, minting transaction (a transaction which executes `mint`) must\\n\\t *      1) transfer AI Personality\\n\\t *      2) transfer ALI tokens if they are to be locked\\n\\t *      3) mint iNFT\\n\\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\\n\\t *            (results in a security risk)\\n\\t *\\n\\t * @dev The NFT to be linked to is not required to owned by the funder, but it must exist;\\n\\t *      throws if target NFT doesn't exist\\n\\t *\\n\\t * @dev This is a restricted function which is accessed by iNFT Linker\\n\\t *\\n\\t * @param recordId ID of the iNFT to mint (create, bind)\\n\\t * @param aliValue amount of ALI tokens to bind to newly created iNFT\\n\\t * @param personalityContract AI Personality contract address\\n\\t * @param personalityId ID of the AI Personality to bind to newly created iNFT\\n\\t * @param targetContract target NFT smart contract\\n\\t * @param targetId target NFT ID (where this iNFT binds to and belongs to)\\n\\t */\\n\\tfunction mint(\\n\\t\\tuint256 recordId,\\n\\t\\tuint96 aliValue,\\n\\t\\taddress personalityContract,\\n\\t\\tuint96 personalityId,\\n\\t\\taddress targetContract,\\n\\t\\tuint256 targetId\\n\\t) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_MINTER), \\\"access denied\\\");\\n\\n\\t\\t// verify personalityContract is a valid ERC721\\n\\t\\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \\\"personality is not ERC721\\\");\\n\\n\\t\\t// verify targetContract is a valid ERC721\\n\\t\\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \\\"target NFT is not ERC721\\\");\\n\\n\\t\\t// verify this iNFT is not yet minted\\n\\t\\trequire(!exists(recordId), \\\"iNFT already exists\\\");\\n\\n\\t\\t// verify target NFT is not yet bound to\\n\\t\\trequire(reverseBindings[targetContract][targetId] == 0, \\\"NFT is already bound\\\");\\n\\n\\t\\t// verify AI Personality is not yet locked\\n\\t\\trequire(personalityBindings[personalityContract][personalityId] == 0, \\\"personality already linked\\\");\\n\\n\\t\\t// verify if AI Personality is already transferred to iNFT\\n\\t\\trequire(ERC721(personalityContract).ownerOf(personalityId) == address(this), \\\"personality is not yet transferred\\\");\\n\\n\\t\\t// retrieve NFT owner and verify if target NFT exists\\n\\t\\taddress owner = ERC721(targetContract).ownerOf(targetId);\\n\\t\\t// Note: we do not require funder to be NFT owner,\\n\\t\\t// if required this constraint should be added by the caller (iNFT Linker)\\n\\t\\trequire(owner != address(0), \\\"target NFT doesn't exist\\\");\\n\\n\\t\\t// in case when ALI tokens are expected to be locked within iNFT\\n\\t\\tif(aliValue > 0) {\\n\\t\\t\\t// verify ALI tokens are already transferred to iNFT\\n\\t\\t\\trequire(aliBalance + aliValue <= ERC20(aliContract).balanceOf(address(this)), \\\"ALI tokens not yet transferred\\\");\\n\\n\\t\\t\\t// update ALI balance on the contract\\n\\t\\t\\taliBalance += aliValue;\\n\\t\\t}\\n\\n\\t\\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\\n\\t\\tbindings[recordId] = IntelliBinding({\\n\\t\\t\\tpersonalityContract : personalityContract,\\n\\t\\t\\tpersonalityId : personalityId,\\n\\t\\t\\taliValue : aliValue,\\n\\t\\t\\ttargetContract : targetContract,\\n\\t\\t\\ttargetId : targetId\\n\\t\\t});\\n\\n\\t\\t// fill in the reverse binding\\n\\t\\treverseBindings[targetContract][targetId] = recordId;\\n\\n\\t\\t// fill in the AI Personality to iNFT binding\\n\\t\\tpersonalityBindings[personalityContract][personalityId] = recordId;\\n\\n\\t\\t// increase total supply counter\\n\\t\\ttotalSupply++;\\n\\n\\t\\t// emit an event\\n\\t\\temit Minted(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\towner,\\n\\t\\t\\trecordId,\\n\\t\\t\\taliValue,\\n\\t\\t\\tpersonalityContract,\\n\\t\\t\\tpersonalityId,\\n\\t\\t\\ttargetContract,\\n\\t\\t\\ttargetId\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which creates several iNFTs, binding them to the specified\\n\\t *      NFTs, locking the AI Personalities specified, each funded with the amount of ALI specified\\n\\t *\\n\\t * @dev Locks AI Personalities defined by their IDs within iNFT smart contract;\\n\\t *      AI Personalities must be transferred to the iNFT smart contract\\n\\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\\n\\t *\\n\\t * @dev Locks specified amount of ALI token within iNFT smart contract for each iNFT minted;\\n\\t *      ALI token amount must be transferred to the iNFT smart contract\\n\\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\\n\\t *\\n\\t * @dev To summarize, minting transaction (a transaction which executes `mintBatch`) must\\n\\t *      1) transfer AI Personality\\n\\t *      2) transfer ALI tokens if they are to be locked\\n\\t *      3) mint iNFT\\n\\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\\n\\t *            (results in a security risk)\\n\\t *\\n\\t * @dev The NFTs to be linked to are not required to owned by the funder, but they must exist;\\n\\t *      throws if target NFTs don't exist\\n\\t *\\n\\t * @dev iNFT IDs to be minted: [recordId, recordId + n)\\n\\t * @dev AI Personality IDs to be locked: [personalityId, personalityId + n)\\n\\t * @dev NFT IDs to be bound to: [targetId, targetId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev This is a restricted function which is accessed by iNFT Linker\\n\\t *\\n\\t * @param recordId ID of the first iNFT to mint (create, bind)\\n\\t * @param aliValue amount of ALI tokens to bind to each newly created iNFT\\n\\t * @param personalityContract AI Personality contract address\\n\\t * @param personalityId ID of the first AI Personality to bind to newly created iNFT\\n\\t * @param targetContract target NFT smart contract\\n\\t * @param targetId first target NFT ID (where this iNFT binds to and belongs to)\\n\\t * @param n how many iNFTs to mint, sequentially increasing the recordId, personalityId, and targetId\\n\\t */\\n\\tfunction mintBatch(\\n\\t\\tuint256 recordId,\\n\\t\\tuint96 aliValue,\\n\\t\\taddress personalityContract,\\n\\t\\tuint96 personalityId,\\n\\t\\taddress targetContract,\\n\\t\\tuint256 targetId,\\n\\t\\tuint96 n\\n\\t) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_MINTER), \\\"access denied\\\");\\n\\n\\t\\t// verify n is set properly\\n\\t\\trequire(n > 1, \\\"n is too small\\\");\\n\\n\\t\\t// verify personalityContract is a valid ERC721\\n\\t\\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \\\"personality is not ERC721\\\");\\n\\n\\t\\t// verify targetContract is a valid ERC721\\n\\t\\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \\\"target NFT is not ERC721\\\");\\n\\n\\t\\t// verifications: for each iNFT in a batch\\n\\t\\tfor(uint96 i = 0; i < n; i++) {\\n\\t\\t\\t// verify this token ID is not yet bound\\n\\t\\t\\trequire(!exists(recordId + i), \\\"iNFT already exists\\\");\\n\\n\\t\\t\\t// verify the AI Personality is not yet bound\\n\\t\\t\\trequire(personalityBindings[personalityContract][personalityId + i] == 0, \\\"personality already linked\\\");\\n\\n\\t\\t\\t// verify if AI Personality is already transferred to iNFT\\n\\t\\t\\trequire(ERC721(personalityContract).ownerOf(personalityId + i) == address(this), \\\"personality is not yet transferred\\\");\\n\\n\\t\\t\\t// retrieve NFT owner and verify if target NFT exists\\n\\t\\t\\taddress owner = ERC721(targetContract).ownerOf(targetId + i);\\n\\t\\t\\t// Note: we do not require funder to be NFT owner,\\n\\t\\t\\t// if required this constraint should be added by the caller (iNFT Linker)\\n\\t\\t\\trequire(owner != address(0), \\\"target NFT doesn't exist\\\");\\n\\n\\t\\t\\t// emit an event - we log owner for each iNFT\\n\\t\\t\\t// and its convenient to do it here when we have the owner inline\\n\\t\\t\\temit Minted(\\n\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\towner,\\n\\t\\t\\t\\trecordId + i,\\n\\t\\t\\t\\taliValue,\\n\\t\\t\\t\\tpersonalityContract,\\n\\t\\t\\t\\tpersonalityId + i,\\n\\t\\t\\t\\ttargetContract,\\n\\t\\t\\t\\ttargetId + i\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t// cumulative ALI value may overflow uint96, store it into uint256 on stack\\n\\t\\tuint256 _aliValue = uint256(aliValue) * n;\\n\\n\\t\\t// in case when ALI tokens are expected to be locked within iNFT\\n\\t\\tif(_aliValue > 0) {\\n\\t\\t\\t// verify ALI tokens are already transferred to iNFT\\n\\t\\t\\trequire(aliBalance + _aliValue <= ERC20(aliContract).balanceOf(address(this)), \\\"ALI tokens not yet transferred\\\");\\n\\t\\t\\t// update ALI balance on the contract\\n\\t\\t\\taliBalance += _aliValue;\\n\\t\\t}\\n\\n\\t\\t// minting: for each iNFT in a batch\\n\\t\\tfor(uint96 i = 0; i < n; i++) {\\n\\t\\t\\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\\n\\t\\t\\tbindings[recordId + i] = IntelliBinding({\\n\\t\\t\\t\\tpersonalityContract : personalityContract,\\n\\t\\t\\t\\tpersonalityId : personalityId + i,\\n\\t\\t\\t\\taliValue : aliValue,\\n\\t\\t\\t\\ttargetContract : targetContract,\\n\\t\\t\\t\\ttargetId : targetId + i\\n\\t\\t\\t});\\n\\n\\t\\t\\t// fill in the AI Personality to iNFT binding\\n\\t\\t\\tpersonalityBindings[personalityContract][personalityId + i] = recordId + i;\\n\\n\\t\\t\\t// fill in the reverse binding\\n\\t\\t\\treverseBindings[targetContract][targetId + i] = recordId + i;\\n\\t\\t}\\n\\n\\t\\t// increase total supply counter\\n\\t\\ttotalSupply += n;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which destroys an iNFT, unbinding it from the\\n\\t *      linked NFT, releasing an AI Personality, and ALI tokens locked in the iNFT\\n\\t *\\n\\t * @dev Transfers an AI Personality locked in iNFT to its owner via ERC721.safeTransferFrom;\\n\\t *      owner must be an EOA or implement ERC721Receiver.onERC721Received properly\\n\\t * @dev Transfers ALI tokens locked in iNFT to its owner\\n\\t * @dev Since iNFT owner is determined as underlying NFT owner, this underlying NFT must\\n\\t *      exist and its ownerOf function must not throw and must return non-zero owner address\\n\\t *      for the underlying NFT ID\\n\\t *\\n\\t * @dev Doesn't verify if it's safe to send ALI tokens to the NFT owner, this check\\n\\t *      must be handled by the transaction executor\\n\\t *\\n\\t * @dev This is a restricted function which is accessed by iNFT Linker\\n\\t *\\n\\t * @param recordId ID of the iNFT to burn (destroy, unbind)\\n\\t */\\n\\tfunction burn(uint256 recordId) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_BURNER), \\\"access denied\\\");\\n\\n\\t\\t// decrease total supply counter\\n\\t\\ttotalSupply--;\\n\\n\\t\\t// read the token binding (we'll need to access all the fields)\\n\\t\\tIntelliBinding memory binding = bindings[recordId];\\n\\n\\t\\t// verify binding exists\\n\\t\\trequire(binding.targetContract != address(0), \\\"not bound\\\");\\n\\n\\t\\t// destroy binding first to protect from any reentrancy possibility\\n\\t\\tdelete bindings[recordId];\\n\\n\\t\\t// free the reverse binding\\n\\t\\tdelete reverseBindings[binding.targetContract][binding.targetId];\\n\\n\\t\\t// free the AI Personality binding\\n\\t\\tdelete personalityBindings[binding.personalityContract][binding.personalityId];\\n\\n\\t\\t// determine an owner of the underlying NFT\\n\\t\\taddress owner = ERC721(binding.targetContract).ownerOf(binding.targetId);\\n\\n\\t\\t// verify that owner address is set (not a zero address)\\n\\t\\trequire(owner != address(0), \\\"no such NFT\\\");\\n\\n\\t\\t// transfer the AI Personality to the NFT owner\\n\\t\\t// using safe transfer since we don't know if owner address can accept the AI Personality right now\\n\\t\\tERC721(binding.personalityContract).safeTransferFrom(address(this), owner, binding.personalityId);\\n\\n\\t\\t// in case when ALI tokens were locked within iNFT\\n\\t\\tif(binding.aliValue > 0) {\\n\\t\\t\\t// update ALI balance on the contract prior to token transfer (reentrancy style)\\n\\t\\t\\taliBalance -= binding.aliValue;\\n\\n\\t\\t\\t// transfer the ALI tokens to the NFT owner\\n\\t\\t\\tERC20(aliContract).transfer(owner, binding.aliValue);\\n\\t\\t}\\n\\n\\t\\t// emit an event\\n\\t\\temit Burnt(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\trecordId,\\n\\t\\t\\towner,\\n\\t\\t\\tbinding.aliValue,\\n\\t\\t\\tbinding.personalityContract,\\n\\t\\t\\tbinding.personalityId,\\n\\t\\t\\tbinding.targetContract,\\n\\t\\t\\tbinding.targetId\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which updates iNFT record by increasing locked ALI tokens value,\\n\\t *      effectively locking additional ALI tokens to the iNFT\\n\\t *\\n\\t * @dev Locks specified amount of ALI token within iNFT smart contract;\\n\\t *      ALI token amount must be transferred to the iNFT smart contract\\n\\t *      prior to calling the `increaseAli`, but in the same transaction with `increaseAli`\\n\\t *\\n\\t * @dev To summarize, update transaction (a transaction which executes `increaseAli`) must\\n\\t *      1) transfer ALI tokens\\n\\t *      2) update the iNFT\\n\\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\\n\\t *            (results in a security risk)\\n\\t *\\n\\t * @dev This is a restricted function which is accessed by iNFT Linker\\n\\t *\\n\\t * @param recordId ID of the iNFT to update\\n\\t * @param aliDelta amount of ALI tokens to lock\\n\\t */\\n\\tfunction increaseAli(uint256 recordId, uint96 aliDelta) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_EDITOR), \\\"access denied\\\");\\n\\n\\t\\t// verify the inputs are set\\n\\t\\trequire(aliDelta != 0, \\\"zero value\\\");\\n\\n\\t\\t// get iNFT owner for logging (check iNFT record exists under the hood)\\n\\t\\taddress owner = ownerOf(recordId);\\n\\n\\t\\t// cache the ALI value of the record\\n\\t\\tuint96 aliValue = bindings[recordId].aliValue;\\n\\n\\t\\t// verify ALI tokens are already transferred to iNFT\\n\\t\\trequire(aliBalance + aliDelta <= ERC20(aliContract).balanceOf(address(this)), \\\"ALI tokens not yet transferred\\\");\\n\\n\\t\\t// update ALI balance on the contract\\n\\t\\taliBalance += aliDelta;\\n\\n\\t\\t// update ALI balance on the binding\\n\\t\\tbindings[recordId].aliValue = aliValue + aliDelta;\\n\\n\\t\\t// emit an event\\n\\t\\temit Updated(msg.sender, owner, recordId, aliValue, aliValue + aliDelta);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which updates iNFT record by decreasing locked ALI tokens value,\\n\\t *      effectively unlocking some or all ALI tokens from the iNFT\\n\\t *\\n\\t * @dev Unlocked tokens are sent to the recipient address specified\\n\\t *\\n\\t * @dev This is a restricted function which is accessed by iNFT Linker\\n\\t *\\n\\t * @param recordId ID of the iNFT to update\\n\\t * @param aliDelta amount of ALI tokens to unlock\\n\\t * @param recipient an address to send unlocked tokens to\\n\\t */\\n\\tfunction decreaseAli(uint256 recordId, uint96 aliDelta, address recipient) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_EDITOR), \\\"access denied\\\");\\n\\n\\t\\t// verify the inputs are set\\n\\t\\trequire(aliDelta != 0, \\\"zero value\\\");\\n\\t\\trequire(recipient != address(0), \\\"zero address\\\");\\n\\n\\t\\t// get iNFT owner for logging (check iNFT record exists under the hood)\\n\\t\\taddress owner = ownerOf(recordId);\\n\\n\\t\\t// cache the ALI value of the record\\n\\t\\tuint96 aliValue = bindings[recordId].aliValue;\\n\\n\\t\\t// positive or zero resulting balance check\\n\\t\\trequire(aliValue >= aliDelta, \\\"not enough ALI\\\");\\n\\n\\t\\t// update ALI balance on the contract\\n\\t\\taliBalance -= aliDelta;\\n\\n\\t\\t// update ALI balance on the binding\\n\\t\\tbindings[recordId].aliValue = aliValue - aliDelta;\\n\\n\\t\\t// transfer the ALI tokens to the recipient\\n\\t\\tERC20(aliContract).transfer(recipient, aliDelta);\\n\\n\\t\\t// emit an event\\n\\t\\temit Updated(msg.sender, owner, recordId, aliValue, aliValue - aliDelta);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines how many tokens are locked in a particular iNFT\\n\\t *\\n\\t * @dev A shortcut for bindings(recordId).aliValue\\n\\t * @dev Throws if iNFT specified doesn't exist\\n\\t *\\n\\t * @param recordId iNFT ID to query locked tokens balance for\\n\\t * @return locked tokens balance, bindings[recordId].aliValue\\n\\t */\\n\\tfunction lockedValue(uint256 recordId) public view returns(uint96) {\\n\\t\\t// ensure iNFT exists\\n\\t\\trequire(exists(recordId), \\\"iNFT doesn't exist\\\");\\n\\n\\t\\t// read and return ALI value locked in the binding\\n\\t\\treturn bindings[recordId].aliValue;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n/**\\n * @title Access Control List\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if specific operation is permitted globally and/or\\n *      if particular user has a permission to execute it.\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable specific\\n *      functions (public functions) of the smart contract for everyone.\\n * @notice User roles are designed to restrict access to specific\\n *      functions (restricted functions) of the smart contract to some users.\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\n *\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\n *      Access managers can only grant/revoke permissions which they have themselves.\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\n *      access manager permission and nothing else.\\n *\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\n *      Access manager with even no other permission can interfere with another account by\\n *      granting own access manager permission to it and effectively creating more powerful\\n *      permission set than its own.\\n *\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\n *      to check/know \\\"who is allowed to do this thing\\\".\\n * @dev Zeppelin implementation is more flexible:\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\n * @dev Current implementation is more lightweight:\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\n *        setting only one role in a single transaction\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @dev Access manager permission has a bit 255 set.\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\n */\\ncontract AccessControl {\\n\\t/**\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\n\\t *      enabling/disabling global features of the smart contract\\n\\t * @notice Access manager can add, remove and update user roles,\\n\\t *      remove and update global features\\n\\t *\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\n\\t */\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\n\\t */\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\n\\n\\t/**\\n\\t * @notice Privileged addresses with defined roles/permissions\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\n\\t *\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\n\\t *      represents a permission\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n\\t *      represents all possible permissions\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\n\\t */\\n\\tmapping(address => uint256) public userRoles;\\n\\n\\t/**\\n\\t * @dev Fired in updateRole() and updateFeatures()\\n\\t *\\n\\t * @param _by operator which called the function\\n\\t * @param _to address which was granted/revoked permissions\\n\\t * @param _requested permissions requested\\n\\t * @param _actual permissions effectively set\\n\\t */\\n\\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\\n\\n\\t/**\\n\\t * @notice Creates an access control instance,\\n\\t *      setting contract creator to have full privileges\\n\\t */\\n\\tconstructor() {\\n\\t\\t// contract creator has full privileges\\n\\t\\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Retrieves globally set of features enabled\\n\\t *\\n\\t * @dev Effectively reads userRoles role for the contract itself\\n\\t *\\n\\t * @return 256-bit bitmask of the features enabled\\n\\t */\\n\\tfunction features() public view returns(uint256) {\\n\\t\\t// features are stored in 'this' address  mapping of `userRoles` structure\\n\\t\\treturn userRoles[address(this)];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of the globally enabled features (`features`),\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t * @dev Function is left for backward compatibility with older versions\\n\\t *\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\n\\t */\\n\\tfunction updateFeatures(uint256 _mask) public {\\n\\t\\t// delegate call to `updateRole`\\n\\t\\tupdateRole(address(this), _mask);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of permissions (role) for a given user,\\n\\t *      taking into account sender's permissions.\\n\\t *\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\n\\t *      copying senders' permissions (role) to the user\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t *\\n\\t * @param operator address of a user to alter permissions for or zero\\n\\t *      to alter global features of the smart contract\\n\\t * @param role bitmask representing a set of permissions to\\n\\t *      enable/disable for a user specified\\n\\t */\\n\\tfunction updateRole(address operator, uint256 role) public {\\n\\t\\t// caller must have a permission to update user roles\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// evaluate the role and reassign it\\n\\t\\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\\n\\n\\t\\t// fire an event\\n\\t\\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines the permission bitmask an operator can set on the\\n\\t *      target permission set\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\n\\t *     in `updateRole` and `updateFeatures` functions\\n\\t *\\n\\t * @dev Calculated based on:\\n\\t *      1) operator's own permission set read from userRoles[operator]\\n\\t *      2) target permission set - what is already set on the target\\n\\t *      3) desired permission set - what do we want set target to\\n\\t *\\n\\t * @dev Corner cases:\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\n\\t *        (what operator sets is what they get)\\n\\t *      2) Operator with no permissions (zero bitset):\\n\\t *        `target` bitset is returned regardless of the `desired` value\\n\\t *        (operator has no authority and cannot modify anything)\\n\\t *\\n\\t * @dev Example:\\n\\t *      Consider an operator with the permissions bitmask     00001111\\n\\t *      is about to modify the target permission set          01010101\\n\\t *      Operator wants to set that permission set to          00110011\\n\\t *      Based on their role, an operator has the permissions\\n\\t *      to update only lowest 4 bits on the target, meaning that\\n\\t *      high 4 bits of the target set in this example is left\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\n\\t *\\n\\t * @param operator address of the contract operator which is about to set the permissions\\n\\t * @param target input set of permissions to operator is going to modify\\n\\t * @param desired desired set of permissions operator would like to set\\n\\t * @return resulting set of permissions given operator will set\\n\\t */\\n\\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\\n\\t\\t// read operator's permissions\\n\\t\\tuint256 p = userRoles[operator];\\n\\n\\t\\t// taking into account operator's permissions,\\n\\t\\t// 1) enable the permissions desired on the `target`\\n\\t\\ttarget |= p & desired;\\n\\t\\t// 2) disable the permissions desired on the `target`\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\n\\n\\t\\t// return calculated result\\n\\t\\treturn target;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\n\\t *\\n\\t * @param required set of features to check against\\n\\t * @return true if all the features requested are enabled, false otherwise\\n\\t */\\n\\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\n\\t\\treturn __hasRole(features(), required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\n\\t *\\n\\t * @param required set of permissions (role) to check against\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isSenderInRole(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if operator has all the permissions (role) required\\n\\t *\\n\\t * @param operator address of the user to check role for\\n\\t * @param required set of permissions (role) to check\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\n\\t\\treturn __hasRole(userRoles[operator], required);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\n\\t *\\n\\t * @param actual existent role\\n\\t * @param required required role\\n\\t * @return true if actual has required role (all permissions), false otherwise\\n\\t */\\n\\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\\n\\t\\t// check the bitmask for the role required and return the result\\n\\t\\treturn actual & required == required;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC20Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n/**\\n * @title EIP-20: ERC-20 Token Standard\\n *\\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\\n *\\n * @notice It provides functionalities like to transfer tokens from one account to another,\\n *      to get the current token balance of an account and also the total supply of the token available on the network.\\n *      Besides these it also has some other functionalities like to approve that an amount of\\n *      token from an account can be spent by a third party account.\\n *\\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\\n *\\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\\n * @notice See https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface ERC20 {\\n\\t/**\\n\\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\\n\\t *\\n\\t * @param from an address tokens were consumed from\\n\\t * @param to an address tokens were sent to\\n\\t * @param value number of tokens transferred\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Fired in approve() to indicate an approval event happened\\n\\t *\\n\\t * @param owner an address which granted a permission to transfer\\n\\t *      tokens on its behalf\\n\\t * @param spender an address which received a permission to transfer\\n\\t *      tokens on behalf of the owner `_owner`\\n\\t * @param value amount of tokens granted to transfer on behalf\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n\\t/**\\n\\t * @return name of the token (ex.: USD Coin)\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @return symbol of the token (ex.: USDC)\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the number of decimals used to get its user representation.\\n\\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\\n\\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n\\t *\\n\\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\\n\\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\\n\\t *      overridden;\\n\\t *\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\n\\t *      no way affects any of the arithmetic of the contract, including\\n\\t *      {IERC20-balanceOf} and {IERC20-transfer}.\\n\\t *\\n\\t * @return token decimals\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function decimals() external view returns (uint8);\\n\\n\\t/**\\n\\t * @return the amount of tokens in existence\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice Gets the balance of a particular address\\n\\t *\\n\\t * @param _owner the address to query the the balance for\\n\\t * @return balance an amount of tokens owned by the address specified\\n\\t */\\n\\tfunction balanceOf(address _owner) external view returns (uint256 balance);\\n\\n\\t/**\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\n\\t *\\n\\t * @dev Called by token owner (an address which has a\\n\\t *      positive token balance tracked by this smart contract)\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * self address or\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transfer(address _to, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to`\\n\\t *\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _from token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Approves address called `_spender` to transfer some amount\\n\\t *      of tokens on behalf of the owner (transaction sender)\\n\\t *\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction approve(address _spender, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\n\\t *\\n\\t * @dev A function to check an amount of tokens owner approved\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\n\\t *\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\n\\t *      of token owner `_owner`\\n\\t */\\n\\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"./ERC165Spec.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\\n *      For example, a payable function in this interface may be implemented as nonpayable\\n *      (no state mutability specified) in implementing contract.\\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\\n *      we have removed all \\\"payable\\\" modifiers.\\n *\\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721 is ERC165 {\\n\\t/// @dev This emits when ownership of any NFT changes by any mechanism.\\n\\t///  This event emits when NFTs are created (`from` == 0) and destroyed\\n\\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n\\t///  may be created and assigned without emitting Transfer. At the time of\\n\\t///  any transfer, the approved address for that NFT (if any) is reset to none.\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when the approved address for an NFT is changed or\\n\\t///  reaffirmed. The zero address indicates there is no approved address.\\n\\t///  When a Transfer event emits, this also indicates that the approved\\n\\t///  address for that NFT (if any) is reset to none.\\n\\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when an operator is enabled or disabled for an owner.\\n\\t///  The operator can manage all NFTs of the owner.\\n\\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n\\t/// @notice Count all NFTs assigned to an owner\\n\\t/// @dev NFTs assigned to the zero address are considered invalid, and this\\n\\t///  function throws for queries about the zero address.\\n\\t/// @param _owner An address for whom to query the balance\\n\\t/// @return The number of NFTs owned by `_owner`, possibly zero\\n\\tfunction balanceOf(address _owner) external view returns (uint256);\\n\\n\\t/// @notice Find the owner of an NFT\\n\\t/// @dev NFTs assigned to zero address are considered invalid, and queries\\n\\t///  about them do throw.\\n\\t/// @param _tokenId The identifier for an NFT\\n\\t/// @return The address of the owner of the NFT\\n\\tfunction ownerOf(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n\\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t///  `onERC721Received` on `_to` and throws if the return value is not\\n\\t///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\t/// @param _data Additional data with no specified format, sent in call to `_to`\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev This works identically to the other function with an extra data parameter,\\n\\t///  except this function just sets data to \\\"\\\".\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n\\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n\\t///  THEY MAY BE PERMANENTLY LOST\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Change or reaffirm the approved address for an NFT\\n\\t/// @dev The zero address indicates there is no approved address.\\n\\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n\\t///  operator of the current owner.\\n\\t/// @param _approved The new approved NFT controller\\n\\t/// @param _tokenId The NFT to approve\\n\\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n\\t///  all of `msg.sender`'s assets\\n\\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\\n\\t///  multiple operators per owner.\\n\\t/// @param _operator Address to add to the set of authorized operators\\n\\t/// @param _approved True if the operator is approved, false to revoke approval\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external;\\n\\n\\t/// @notice Get the approved address for a single NFT\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT.\\n\\t/// @param _tokenId The NFT to find the approved address for\\n\\t/// @return The approved address for this NFT, or the zero address if there is none\\n\\tfunction getApproved(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Query if an address is an authorized operator for another address\\n\\t/// @param _owner The address that owns the NFTs\\n\\t/// @param _operator The address that acts on behalf of the owner\\n\\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n\\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface ERC721TokenReceiver {\\n\\t/// @notice Handle the receipt of an NFT\\n\\t/// @dev The ERC721 smart contract calls this function on the recipient\\n\\t///  after a `transfer`. This function MAY throw to revert and reject the\\n\\t///  transfer. Return of other than the magic value MUST result in the\\n\\t///  transaction being reverted.\\n\\t///  Note: the contract address is always the message sender.\\n\\t/// @param _operator The address which called `safeTransferFrom` function\\n\\t/// @param _from The address which previously owned the token\\n\\t/// @param _tokenId The NFT identifier which is being transferred\\n\\t/// @param _data Additional data with no specified format\\n\\t/// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n\\t///  unless throwing\\n\\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Metadata is ERC721 {\\n\\t/// @notice A descriptive name for a collection of NFTs in this contract\\n\\tfunction name() external view returns (string memory _name);\\n\\n\\t/// @notice An abbreviated name for NFTs in this contract\\n\\tfunction symbol() external view returns (string memory _symbol);\\n\\n\\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n\\t///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n\\t///  Metadata JSON Schema\\\".\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Enumerable is ERC721 {\\n\\t/// @notice Count NFTs tracked by this contract\\n\\t/// @return A count of valid NFTs tracked by this contract, where each one of\\n\\t///  them has an assigned and queryable owner not equal to the zero address\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/// @notice Enumerate valid NFTs\\n\\t/// @dev Throws if `_index` >= `totalSupply()`.\\n\\t/// @param _index A counter less than `totalSupply()`\\n\\t/// @return The token identifier for the `_index`th NFT,\\n\\t///  (sort order not specified)\\n\\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n\\t/// @notice Enumerate NFTs assigned to an owner\\n\\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n\\t///  `_owner` is the zero address, representing invalid NFTs.\\n\\t/// @param _owner An address where we are interested in NFTs owned by them\\n\\t/// @param _index A counter less than `balanceOf(_owner)`\\n\\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n\\t///   (sort order not specified)\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/StringUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n/**\\n * @title String Utils Library\\n *\\n * @dev Library for working with strings, primarily converting\\n *      between strings and integer types\\n */\\nlibrary StringUtils {\\n\\t/**\\n\\t * @dev Converts a string to unsigned integer using the specified `base`\\n\\t * @dev Throws on invalid input\\n\\t *      (wrong characters for a given `base`)\\n\\t * @dev Throws if given `base` is not supported\\n\\t * @param a string to convert\\n\\t * @param base number base, one of 2, 8, 10, 16\\n\\t * @return i a number representing given string\\n\\t */\\n\\tfunction atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\\n\\t\\t// check if the base is valid\\n\\t\\trequire(base == 2 || base == 8 || base == 10 || base == 16);\\n\\n\\t\\t// convert string into bytes for convenient iteration\\n\\t\\tbytes memory buf = bytes(a);\\n\\n\\t\\t// iterate over the string (bytes buffer)\\n\\t\\tfor(uint256 p = 0; p < buf.length; p++) {\\n\\t\\t\\t// extract the digit\\n\\t\\t\\tuint8 digit = uint8(buf[p]) - 0x30;\\n\\n\\t\\t\\t// if digit is greater then 10 - mind the gap\\n\\t\\t\\t// see `itoa` function for more details\\n\\t\\t\\tif(digit > 10) {\\n\\t\\t\\t\\t// remove the gap\\n\\t\\t\\t\\tdigit -= 7;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if digit meets the base\\n\\t\\t\\trequire(digit < base);\\n\\n\\t\\t\\t// move to the next digit slot\\n\\t\\t\\ti *= base;\\n\\n\\t\\t\\t// add digit to the result\\n\\t\\t\\ti += digit;\\n\\t\\t}\\n\\n\\t\\t// return the result\\n\\t\\treturn i;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Converts a integer to a string using the specified `base`\\n\\t * @dev Throws if given `base` is not supported\\n\\t * @param i integer to convert\\n\\t * @param base number base, one of 2, 8, 10, 16\\n\\t * @return a a string representing given integer\\n\\t */\\n\\tfunction itoa(uint256 i, uint8 base) internal pure returns (string memory a) {\\n\\t\\t// check if the base is valid\\n\\t\\trequire(base == 2 || base == 8 || base == 10 || base == 16);\\n\\n\\t\\t// for zero input the result is \\\"0\\\" string for any base\\n\\t\\tif(i == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\n\\t\\t// bytes buffer to put ASCII characters into\\n\\t\\tbytes memory buf = new bytes(256);\\n\\n\\t\\t// position within a buffer to be used in cycle\\n\\t\\tuint256 p = 0;\\n\\n\\t\\t// extract digits one by one in a cycle\\n\\t\\twhile(i > 0) {\\n\\t\\t\\t// extract current digit\\n\\t\\t\\tuint8 digit = uint8(i % base);\\n\\n\\t\\t\\t// convert it to an ASCII code\\n\\t\\t\\t// 0x20 is \\\" \\\"\\n\\t\\t\\t// 0x30-0x39 is \\\"0\\\"-\\\"9\\\"\\n\\t\\t\\t// 0x41-0x5A is \\\"A\\\"-\\\"Z\\\"\\n\\t\\t\\t// 0x61-0x7A is \\\"a\\\"-\\\"z\\\" (\\\"A\\\"-\\\"Z\\\" XOR \\\" \\\")\\n\\t\\t\\tuint8 ascii = digit + 0x30;\\n\\n\\t\\t\\t// if digit is greater then 10,\\n\\t\\t\\t// fix the 0x3A-0x40 gap of punctuation marks\\n\\t\\t\\t// (7 characters in ASCII table)\\n\\t\\t\\tif(digit >= 10) {\\n\\t\\t\\t\\t// jump through the gap\\n\\t\\t\\t\\tascii += 7;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// write character into the buffer\\n\\t\\t\\tbuf[p++] = bytes1(ascii);\\n\\n\\t\\t\\t// move to the next digit\\n\\t\\t\\ti /= base;\\n\\t\\t}\\n\\n\\t\\t// `p` contains real length of the buffer now,\\n\\t\\t// allocate the resulting buffer of that size\\n\\t\\tbytes memory result = new bytes(p);\\n\\n\\t\\t// copy the buffer in the reversed order\\n\\t\\tfor(p = 0; p < result.length; p++) {\\n\\t\\t\\t// copy from the beginning of the original buffer\\n\\t\\t\\t// to the end of resulting smaller buffer\\n\\t\\t\\tresult[result.length - p - 1] = buf[p];\\n\\t\\t}\\n\\n\\t\\t// construct string and return\\n\\t\\treturn string(result);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Concatenates two strings `s1` and `s2`, for example, if\\n\\t *      `s1` == `foo` and `s2` == `bar`, the result `s` == `foobar`\\n\\t * @param s1 first string\\n\\t * @param s2 second string\\n\\t * @return s concatenation result s1 + s2\\n\\t */\\n\\tfunction concat(string memory s1, string memory s2) internal pure returns (string memory s) {\\n\\t\\t// an old way of string concatenation (Solidity 0.4) is commented out\\n/*\\n\\t\\t// convert s1 into buffer 1\\n\\t\\tbytes memory buf1 = bytes(s1);\\n\\t\\t// convert s2 into buffer 2\\n\\t\\tbytes memory buf2 = bytes(s2);\\n\\t\\t// create a buffer for concatenation result\\n\\t\\tbytes memory buf = new bytes(buf1.length + buf2.length);\\n\\n\\t\\t// copy buffer 1 into buffer\\n\\t\\tfor(uint256 i = 0; i < buf1.length; i++) {\\n\\t\\t\\tbuf[i] = buf1[i];\\n\\t\\t}\\n\\n\\t\\t// copy buffer 2 into buffer\\n\\t\\tfor(uint256 j = buf1.length; j < buf2.length; j++) {\\n\\t\\t\\tbuf[j] = buf2[j - buf1.length];\\n\\t\\t}\\n\\n\\t\\t// construct string and return\\n\\t\\treturn string(buf);\\n*/\\n\\n\\t\\t// simply use built in function\\n\\t\\treturn string(abi.encodePacked(s1, s2));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC165Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n/**\\n * @title ERC-165 Standard Interface Detection\\n *\\n * @dev Interface of the ERC165 standard, as defined in the\\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * @dev Implementers can declare support of contract interfaces,\\n *      which can then be queried by others.\\n *\\n * @author Christian Reitwiener, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\\n */\\ninterface ERC165 {\\n\\t/**\\n\\t * @notice Query if a contract implements an interface\\n\\t *\\n\\t * @dev Interface identification is specified in ERC-165.\\n\\t *      This function uses less than 30,000 gas.\\n\\t *\\n\\t * @param interfaceID The interface identifier, as specified in ERC-165\\n\\t * @return `true` if the contract implements `interfaceID` and\\n\\t *      `interfaceID` is not 0xffffffff, `false` otherwise\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ali\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_personality\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_iNft\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_aliValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_itemPrice\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_nextId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_finalId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_saleStart\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_saleEnd\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_batchLimit\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_aliSource\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"_aliValue\",\"type\":\"uint96\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEATURE_PUBLIC_SALE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_ACCESS_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_BUYER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_SALE_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_WITHDRAWAL_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aliContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aliSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aliValue\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchLimit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_amount\",\"type\":\"uint32\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySingle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"buySingleTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_amount\",\"type\":\"uint32\"}],\"name\":\"buyTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desired\",\"type\":\"uint256\"}],\"name\":\"evaluateBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iNftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_itemPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_nextId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_finalId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_saleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_saleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_batchLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_aliSource\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_aliValue\",\"type\":\"uint96\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isOperatorInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemPrice\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemsAvailable\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemsOnSale\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"now256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"personalityContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleEnd\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStart\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soldCounter\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FixedSupplySale","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b0b3a982b4634ac68dd83a4dbf02311ce324181000000000000000000000000c2d6b32e533e7a8da404abb13790a5a2f606ad75000000000000000000000000dd70af84ba86f29bf437756b655110d134b5651c000000000000000000000000a189121ee045aeaa8da80b72f7a1132e3b216237","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}