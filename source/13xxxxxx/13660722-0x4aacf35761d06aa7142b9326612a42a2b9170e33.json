{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.0\r\n\"\"\"\r\n@title Curve CryptoSwap Registry\r\n@license MIT\r\n@author Curve.Fi\r\n\"\"\"\r\n\r\nMAX_COINS: constant(int128) = 8\r\nCALC_INPUT_SIZE: constant(int128) = 100\r\n\r\n\r\nstruct CoinInfo:\r\n    index: uint256\r\n    register_count: uint256\r\n    swap_count: uint256\r\n    swap_for: address[MAX_INT128]\r\n\r\nstruct PoolArray:\r\n    location: uint256\r\n    decimals: uint256\r\n    coins: address[MAX_COINS]\r\n    n_coins: uint256\r\n    name: String[64]\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n    def get_address(_id: uint256) -> address: view\r\n    def get_registry() -> address: view\r\n\r\ninterface ERC20:\r\n    def balanceOf(_addr: address) -> uint256: view\r\n    def decimals() -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n\r\ninterface CurvePool:\r\n    def token() -> address: view\r\n    def coins(i: uint256) -> address: view\r\n    def A() -> uint256: view\r\n    def gamma() -> uint256: view\r\n    def fee() -> uint256: view\r\n    def get_virtual_price() -> uint256: view\r\n    def mid_fee() -> uint256: view\r\n    def out_fee() -> uint256: view\r\n    def admin_fee() -> uint256: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def D() -> uint256: view\r\n\r\ninterface LiquidityGauge:\r\n    def lp_token() -> address: view\r\n\r\ninterface GaugeController:\r\n    def gauge_types(gauge: address) -> int128: view\r\n\r\n\r\nevent PoolAdded:\r\n    pool: indexed(address)\r\n\r\nevent PoolRemoved:\r\n    pool: indexed(address)\r\n\r\n\r\naddress_provider: public(AddressProvider)\r\npool_list: public(address[65536])   # master list of pools\r\npool_count: public(uint256)         # actual length of pool_list\r\n\r\npool_data: HashMap[address, PoolArray]\r\n\r\ncoin_count: public(uint256)  # total unique coins registered\r\ncoins: HashMap[address, CoinInfo]\r\nget_coin: public(address[65536])  # unique list of registered coins\r\n# bitwise_xor(coina, coinb) -> (coina_pos, coinb_pos) sorted\r\n# stored as uint128[2]\r\ncoin_swap_indexes: HashMap[uint256, uint256]\r\n\r\n# lp token -> pool\r\nget_pool_from_lp_token: public(HashMap[address, address])\r\n\r\n# pool -> lp token\r\nget_lp_token: public(HashMap[address, address])\r\n\r\n# mapping of coins -> pools for trading\r\n# a mapping key is generated for each pair of addresses via\r\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\r\nmarkets: HashMap[uint256, address[65536]]\r\nmarket_counts: HashMap[uint256, uint256]\r\n\r\nliquidity_gauges: HashMap[address, address[10]]\r\n\r\nlast_updated: public(uint256)\r\n\r\n\r\n@external\r\ndef __init__(_address_provider: AddressProvider):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    \"\"\"\r\n    self.address_provider = _address_provider\r\n\r\n# internal functionality for getters\r\n\r\n@view\r\n@internal\r\ndef _get_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    for i in range(MAX_COINS):\r\n        if self.pool_data[_pool].coins[i] == ZERO_ADDRESS:\r\n            assert i != 0\r\n            break\r\n\r\n        balances[i] = CurvePool(_pool).balances(i)\r\n\r\n    return balances\r\n\r\n\r\n# targetted external getters, optimized for on-chain calls\r\n\r\n@view\r\n@external\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\r\n    return self.markets[key][i]\r\n\r\n\r\n@view\r\n@external\r\ndef get_n_coins(_pool: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of coins in a pool\r\n    @dev For non-metapools, both returned values are identical\r\n         even when the pool does not use wrapping/lending\r\n    @param _pool Pool address\r\n    @return Number of wrapped coins, number of underlying coins\r\n    \"\"\"\r\n    return self.pool_data[_pool].n_coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_coins(_pool: address) -> address[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @dev For pools using lending, these are the wrapped coin addresses\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coins[i] = self.pool_data[_pool].coins[i]\r\n\r\n    return coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_decimals(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin decimal places\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n\r\n    # decimals are tightly packed as a series of uint8 within a little-endian bytes32\r\n    # the packed value is stored as uint256 to simplify unpacking via shift and modulo\r\n    packed: uint256 = self.pool_data[_pool].decimals\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    n_coins: int128 = convert(self.pool_data[_pool].n_coins, int128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        decimals[i] = shift(packed, -8 * i) % 256\r\n\r\n    return decimals\r\n\r\n\r\n@view\r\n@external\r\ndef get_gauges(_pool: address) -> (address[10], int128[10]):\r\n    \"\"\"\r\n    @notice Get a list of LiquidityGauge contracts associated with a pool\r\n    @param _pool Pool address\r\n    @return address[10] of gauge addresses, int128[10] of gauge types\r\n    \"\"\"\r\n    liquidity_gauges: address[10] = empty(address[10])\r\n    gauge_types: int128[10] = empty(int128[10])\r\n    for i in range(10):\r\n        gauge: address = self.liquidity_gauges[_pool][i]\r\n        if gauge == ZERO_ADDRESS:\r\n            break\r\n        liquidity_gauges[i] = gauge\r\n\r\n    return liquidity_gauges, gauge_types\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    return self._get_balances(_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_virtual_price_from_lp_token(_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the virtual price of a pool LP token\r\n    @param _token LP token address\r\n    @return uint256 Virtual price\r\n    \"\"\"\r\n    return CurvePool(self.get_pool_from_lp_token[_token]).get_virtual_price()\r\n\r\n\r\n@view\r\n@external\r\ndef get_A(_pool: address) -> uint256:\r\n    return CurvePool(_pool).A()\r\n\r\n\r\n@view\r\n@external\r\ndef get_D(_pool: address) -> uint256:\r\n    return CurvePool(_pool).D()\r\n\r\n\r\n@view\r\n@external\r\ndef get_gamma(_pool: address) -> uint256:\r\n    return CurvePool(_pool).gamma()\r\n\r\n\r\n@view\r\n@external\r\ndef get_fees(_pool: address) -> uint256[4]:\r\n    \"\"\"\r\n    @notice Get the fees for a pool\r\n    @dev Fees are expressed as integers\r\n    @return Pool fee as uint256 with 1e10 precision\r\n            Admin fee as 1e10 percentage of pool fee\r\n            Mid fee\r\n            Out fee\r\n    \"\"\"\r\n    return [CurvePool(_pool).fee(), CurvePool(_pool).admin_fee(), CurvePool(_pool).mid_fee(), CurvePool(_pool).out_fee()]\r\n\r\n\r\n@view\r\n@external\r\ndef get_admin_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the current admin balances (uncollected fees) for a pool\r\n    @param _pool Pool address\r\n    @return List of uint256 admin balances\r\n    \"\"\"\r\n    balances: uint256[MAX_COINS] = self._get_balances(_pool)\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins\r\n    for i in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[i]\r\n        if i == n_coins:\r\n            break\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            balances[i] = _pool.balance - balances[i]\r\n        else:\r\n            balances[i] = ERC20(coin).balanceOf(_pool) - balances[i]\r\n\r\n    return balances\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Convert coin addresses to indices for use with pool methods\r\n    @param _from Coin address to be used as `i` within a pool\r\n    @param _to Coin address to be used as `j` within a pool\r\n    @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins\r\n    \"\"\"\r\n    # the return value is stored as `uint256[3]` to reduce gas costs\r\n    # from index, to index, is the market underlying?\r\n    result: uint256[2] = empty(uint256[2])\r\n\r\n    found_market: bool = False\r\n\r\n    # check coin markets\r\n    for x in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[x]\r\n        if coin == ZERO_ADDRESS:\r\n            # if we reach the end of the coins, reset `found_market` and try again\r\n            # with the underlying coins\r\n            found_market = False\r\n            break\r\n        if coin == _from:\r\n            result[0] = x\r\n        elif coin == _to:\r\n            result[1] = x\r\n        else:\r\n            continue\r\n        if found_market:\r\n            # the second time we find a match, break out of the loop\r\n            return result[0], result[1]\r\n        # the first time we find a match, set `found_market` to True\r\n        found_market = True\r\n\r\n    raise \"No available market\"\r\n\r\n\r\n@view\r\n@external\r\ndef get_pool_name(_pool: address) -> String[64]:\r\n    \"\"\"\r\n    @notice Get the given name for a pool\r\n    @param _pool Pool address\r\n    @return The name of a pool\r\n    \"\"\"\r\n    return self.pool_data[_pool].name\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_swap_count(_coin: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of unique coins available to swap `_coin` against\r\n    @param _coin Coin address\r\n    @return The number of unique coins available to swap for\r\n    \"\"\"\r\n    return self.coins[_coin].swap_count\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_swap_complement(_coin: address, _index: uint256) -> address:\r\n    \"\"\"\r\n    @notice Get the coin available to swap against `_coin` at `_index`\r\n    @param _coin Coin address\r\n    @param _index An index in the `_coin`'s set of available counter\r\n        coin's\r\n    @return Address of a coin available to swap against `_coin`\r\n    \"\"\"\r\n    return self.coins[_coin].swap_for[_index]\r\n\r\n\r\n# internal functionality used in admin setters\r\n\r\n\r\n@internal\r\ndef _register_coin(_coin: address):\r\n    if self.coins[_coin].register_count == 0:\r\n        coin_count: uint256 = self.coin_count\r\n        self.coins[_coin].index = coin_count\r\n        self.get_coin[coin_count] = _coin\r\n        self.coin_count += 1\r\n    self.coins[_coin].register_count += 1\r\n\r\n\r\n@internal\r\ndef _register_coin_pair(_coina: address, _coinb: address, _key: uint256):\r\n    # register _coinb in _coina's array of coins\r\n    coin_b_pos: uint256 = self.coins[_coina].swap_count\r\n    self.coins[_coina].swap_for[coin_b_pos] = _coinb\r\n    self.coins[_coina].swap_count += 1\r\n    # register _coina in _coinb's array of coins\r\n    coin_a_pos: uint256 = self.coins[_coinb].swap_count\r\n    self.coins[_coinb].swap_for[coin_a_pos] = _coina\r\n    self.coins[_coinb].swap_count += 1\r\n    # register indexes (coina pos in coinb array, coinb pos in coina array)\r\n    if convert(_coina, uint256) < convert(_coinb, uint256):\r\n        self.coin_swap_indexes[_key] = shift(coin_a_pos, 128) + coin_b_pos\r\n    else:\r\n        self.coin_swap_indexes[_key] = shift(coin_b_pos, 128) + coin_a_pos\r\n\r\n\r\n@internal\r\ndef _unregister_coin(_coin: address):\r\n    self.coins[_coin].register_count -= 1\r\n\r\n    if self.coins[_coin].register_count == 0:\r\n        self.coin_count -= 1\r\n        coin_count: uint256 = self.coin_count\r\n        location: uint256 = self.coins[_coin].index\r\n\r\n        if location < coin_count:\r\n            coin_b: address = self.get_coin[coin_count]\r\n            self.get_coin[location] = coin_b\r\n            self.coins[coin_b].index = location\r\n\r\n        self.coins[_coin].index = 0\r\n        self.get_coin[coin_count] = ZERO_ADDRESS\r\n\r\n\r\n@internal\r\ndef _unregister_coin_pair(_coina: address, _coinb: address, _coinb_idx: uint256):\r\n    \"\"\"\r\n    @param _coinb_idx the index of _coinb in _coina's array of unique coin's\r\n    \"\"\"\r\n    # decrement swap counts for both coins\r\n    self.coins[_coina].swap_count -= 1\r\n\r\n    # retrieve the last currently occupied index in coina's array\r\n    coina_arr_last_idx: uint256 = self.coins[_coina].swap_count\r\n\r\n    # if coinb's index in coina's array is less than the last\r\n    # overwrite it's position with the last coin\r\n    if _coinb_idx < coina_arr_last_idx:\r\n        # here's our last coin in coina's array\r\n        coin_c: address = self.coins[_coina].swap_for[coina_arr_last_idx]\r\n        # get the bitwise_xor of the pair to retrieve their indexes\r\n        key: uint256 = bitwise_xor(convert(_coina, uint256), convert(coin_c, uint256))\r\n        indexes: uint256 = self.coin_swap_indexes[key]\r\n\r\n        # update the pairing's indexes\r\n        if convert(_coina, uint256) < convert(coin_c, uint256):\r\n            # least complicated most readable way of shifting twice to remove the lower order bits\r\n            self.coin_swap_indexes[key] = shift(shift(indexes, -128), 128) + _coinb_idx\r\n        else:\r\n            self.coin_swap_indexes[key] = shift(_coinb_idx, 128) + indexes % 2 ** 128\r\n        # set _coinb_idx in coina's array to coin_c\r\n        self.coins[_coina].swap_for[_coinb_idx] = coin_c\r\n\r\n    self.coins[_coina].swap_for[coina_arr_last_idx] = ZERO_ADDRESS\r\n\r\n\r\n@internal\r\ndef _get_new_pool_coins(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n) -> address[MAX_COINS]:\r\n    coin_list: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    coin: address = ZERO_ADDRESS\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n        coin = CurvePool(_pool).coins(i)\r\n        self.pool_data[_pool].coins[i] = coin\r\n        coin_list[i] = coin\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        self._register_coin(coin_list[i])\r\n        # add pool to markets\r\n        i2: uint256 = i + 1\r\n        for x in range(i2, i2 + MAX_COINS):\r\n            if x == _n_coins:\r\n                break\r\n\r\n            key: uint256 = bitwise_xor(convert(coin_list[i], uint256), convert(coin_list[x], uint256))\r\n            length: uint256 = self.market_counts[key]\r\n            self.markets[key][length] = _pool\r\n            self.market_counts[key] = length + 1\r\n\r\n            # register the coin pair\r\n            if length == 0:\r\n                self._register_coin_pair(coin_list[x], coin_list[i], key)\r\n\r\n    return coin_list\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_new_pool_decimals(_coins: address[MAX_COINS], _n_coins: uint256) -> uint256:\r\n    packed: uint256 = 0\r\n    value: uint256 = 0\r\n\r\n    n_coins: int128 = convert(_n_coins, int128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coin: address = _coins[i]\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            value = 18\r\n        else:\r\n            value = ERC20(coin).decimals()\r\n            assert value < 256  # dev: decimal overflow\r\n\r\n        packed += shift(value, i * 8)\r\n\r\n    return packed\r\n\r\n\r\n@internal\r\ndef _remove_market(_pool: address, _coina: address, _coinb: address):\r\n    key: uint256 = bitwise_xor(convert(_coina, uint256), convert(_coinb, uint256))\r\n    length: uint256 = self.market_counts[key] - 1\r\n    if length == 0:\r\n        indexes: uint256 = self.coin_swap_indexes[key]\r\n        if convert(_coina, uint256) < convert(_coinb, uint256):\r\n            self._unregister_coin_pair(_coina, _coinb, indexes % 2 ** 128)\r\n            self._unregister_coin_pair(_coinb, _coina, shift(indexes, -128))\r\n        else:\r\n            self._unregister_coin_pair(_coina, _coinb, shift(indexes, -128))\r\n            self._unregister_coin_pair(_coinb, _coina, indexes % 2 ** 128)\r\n        self.coin_swap_indexes[key] = 0\r\n    for i in range(65536):\r\n        if i > length:\r\n            break\r\n        if self.markets[key][i] == _pool:\r\n            if i < length:\r\n                self.markets[key][i] = self.markets[key][length]\r\n            self.markets[key][length] = ZERO_ADDRESS\r\n            self.market_counts[key] = length\r\n            break\r\n\r\n\r\n# admin functions\r\n\r\n@external\r\ndef add_pool(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _decimals: uint256,\r\n    _name: String[64],\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\r\n    @param _name The name of the pool\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n    assert _lp_token != ZERO_ADDRESS\r\n    assert self.pool_data[_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n    assert self.get_pool_from_lp_token[_lp_token] == ZERO_ADDRESS\r\n\r\n    # add pool to pool_list\r\n    length: uint256 = self.pool_count\r\n    self.pool_list[length] = _pool\r\n    self.pool_count = length + 1\r\n    self.pool_data[_pool].location = length\r\n    self.pool_data[_pool].n_coins = _n_coins\r\n    self.pool_data[_pool].name = _name\r\n\r\n    # update public mappings\r\n    self.get_pool_from_lp_token[_lp_token] = _pool\r\n    self.get_lp_token[_pool] = _lp_token\r\n\r\n    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins)\r\n    decimals: uint256 = _decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n    self.pool_data[_pool].decimals = decimals\r\n\r\n    self.last_updated = block.timestamp\r\n    log PoolAdded(_pool)\r\n\r\n\r\n@external\r\ndef remove_pool(_pool: address):\r\n    \"\"\"\r\n    @notice Remove a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to remove\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS  # dev: pool does not exist\r\n\r\n\r\n    self.get_pool_from_lp_token[self.get_lp_token[_pool]] = ZERO_ADDRESS\r\n    self.get_lp_token[_pool] = ZERO_ADDRESS\r\n\r\n    # remove _pool from pool_list\r\n    location: uint256 = self.pool_data[_pool].location\r\n    length: uint256 = self.pool_count - 1\r\n\r\n    if location < length:\r\n        # replace _pool with final value in pool_list\r\n        addr: address = self.pool_list[length]\r\n        self.pool_list[location] = addr\r\n        self.pool_data[addr].location = location\r\n\r\n    # delete final pool_list value\r\n    self.pool_list[length] = ZERO_ADDRESS\r\n    self.pool_count = length\r\n\r\n    self.pool_data[_pool].decimals = 0\r\n    self.pool_data[_pool].n_coins = 0\r\n    self.pool_data[_pool].name = \"\"\r\n\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n\r\n    for i in range(MAX_COINS):\r\n        coins[i] = self.pool_data[_pool].coins[i]\r\n        if coins[i] == ZERO_ADDRESS:\r\n            break\r\n        # delete coin address from pool_data\r\n        self.pool_data[_pool].coins[i] = ZERO_ADDRESS\r\n        self._unregister_coin(coins[i])\r\n\r\n    for i in range(MAX_COINS):\r\n        coin: address = coins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n\r\n        # remove pool from markets\r\n        i2: uint256 = i + 1\r\n        for x in range(i2, i2 + MAX_COINS):\r\n            coinx: address = coins[x]\r\n            if coinx == ZERO_ADDRESS:\r\n                break\r\n            self._remove_market(_pool, coin, coinx)\r\n\r\n    self.last_updated = block.timestamp\r\n    log PoolRemoved(_pool)\r\n\r\n\r\n@external\r\ndef set_liquidity_gauges(_pool: address, _liquidity_gauges: address[10]):\r\n    \"\"\"\r\n    @notice Set liquidity gauge contracts``\r\n    @param _pool Pool address\r\n    @param _liquidity_gauges Liquidity gauge address\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    _lp_token: address = self.get_lp_token[_pool]\r\n    for i in range(10):\r\n        _gauge: address = _liquidity_gauges[i]\r\n        if _gauge != ZERO_ADDRESS:\r\n            assert LiquidityGauge(_gauge).lp_token() == _lp_token  # dev: wrong token\r\n            self.liquidity_gauges[_pool][i] = _gauge\r\n        elif self.liquidity_gauges[_pool][i] != ZERO_ADDRESS:\r\n            self.liquidity_gauges[_pool][i] = ZERO_ADDRESS\r\n        else:\r\n            break\r\n    self.last_updated = block.timestamp","ABI":"[{\"name\":\"PoolAdded\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolRemoved\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_address_provider\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3111},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3111},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_n_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2834},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[8]\"}],\"gas\":22975},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":9818},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauges\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[10]\"},{\"name\":\"\",\"type\":\"int128[10]\"}],\"gas\":26055},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":41626},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price_from_lp_token\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5321},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_A\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3139},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_D\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3169},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gamma\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3199},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_fees\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"gas\":10333},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_admin_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":85771},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_indices\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":23608},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_name\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":13576},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_swap_count\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3224},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_swap_complement\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3299},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_pool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"},{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"outputs\":[],\"gas\":18516260},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_pool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":399675341120},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_liquidity_gauges\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_liquidity_gauges\",\"type\":\"address[10]\"}],\"outputs\":[],\"gas\":422284},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"address_provider\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3096},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3171},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3156},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coin_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3186},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3261},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_from_lp_token\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3518},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_lp_token\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3548},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_updated\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3306}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.0","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000022d53366457f9d5e68ec105046fc4383","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}