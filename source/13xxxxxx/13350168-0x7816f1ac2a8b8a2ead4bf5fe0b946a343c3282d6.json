{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/USM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"erc20permit/contracts/ERC20Permit.sol\\\";\\nimport \\\"./IUSM.sol\\\";\\nimport \\\"./OptOutable.sol\\\";\\nimport \\\"./oracles/Oracle.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Delegable.sol\\\";\\nimport \\\"./WadMath.sol\\\";\\nimport \\\"./FUM.sol\\\";\\nimport \\\"./MinOut.sol\\\";\\n\\n\\n/**\\n * @title USM\\n * @author Alberto Cuesta CaÃ±ada, Jacob Eliosoff, Alex Roan\\n * @notice Concept by Jacob Eliosoff (@jacob-eliosoff).\\n */\\ncontract USM is IUSM, ERC20Permit, OptOutable, Delegable {\\n    using Address for address payable;\\n    using WadMath for uint;\\n\\n    uint public constant WAD = 1e18;\\n    uint public constant FOUR_WAD = 4 * WAD;\\n    uint public constant BILLION = 1e9;\\n    uint public constant HALF_BILLION = BILLION / 2;\\n    uint public constant MAX_DEBT_RATIO = WAD * 8 / 10;                             // 80%\\n    uint public constant MIN_FUM_BUY_PRICE_DECAY_PER_SECOND = 999991977495368426;   // 1-sec decay equiv to halving in 1 day\\n    uint public constant BID_ASK_ADJUSTMENT_DECAY_PER_SECOND = 988514020352896135;  // 1-sec decay equiv to halving in 1 minute\\n    uint public constant BID_ASK_ADJUSTMENT_ZERO_OUT_PERIOD = 600;                  // After 10 min, adjustment just goes to 0\\n\\n    uint public constant PREFUND_END_TIMESTAMP = 1633564800;                        // Midnight, morning of Oct 7, 2021\\n    uint public constant PREFUND_FUM_PRICE_IN_ETH = WAD / 4000;                     // Prefund FUM price: 1/4000 = 0.00025 ETH\\n    uint public constant DEPOSIT_END_TIMESTAMP = 1634169600;                        // Midnight, morning of Oct 14, 2021\\n\\n    FUM public immutable fum;\\n    Oracle public immutable oracle;\\n\\n    struct StoredState {\\n        uint32 timeSystemWentUnderwater;    // Time at which (we noticed) debt ratio went > MAX, or 0 if it's currently < MAX\\n        uint32 ethUsdPriceTimestamp;\\n        uint80 ethUsdPrice;                 // Stored in billionths, not WADs: so 123.456 is stored as 123,456,000,000\\n        uint32 bidAskAdjustmentTimestamp;\\n        uint80 bidAskAdjustment;            // Stored in billionths, not WADs\\n    }\\n\\n    struct LoadedState {\\n        uint timeSystemWentUnderwater;\\n        uint ethUsdPriceTimestamp;\\n        uint ethUsdPrice;                   // This one is in WADs, not billionths\\n        uint bidAskAdjustmentTimestamp;\\n        uint bidAskAdjustment;              // WADs, not billionths\\n        uint ethPool;\\n        uint usmTotalSupply;\\n    }\\n\\n    StoredState public storedState = StoredState({\\n        timeSystemWentUnderwater: 0, ethUsdPriceTimestamp: 0, ethUsdPrice: 0,\\n        bidAskAdjustmentTimestamp: 0, bidAskAdjustment: uint80(BILLION)         // Initialize adjustment to 1.0 (scaled by 1b)\\n    });\\n\\n    constructor(Oracle oracle_, address[] memory optedOut_)\\n        ERC20Permit(\\\"Minimalist USD v1.0 - Test 5\\\", \\\"USMTest\\\")\\n        OptOutable(optedOut_)\\n    {\\n        oracle = oracle_;\\n        fum = new FUM(optedOut_);\\n    }\\n\\n    // ____________________ Modifiers ____________________\\n\\n    /**\\n     * @dev Sometimes we want to give FUM privileged access.\\n     */\\n    modifier onlyHolderOrDelegateOrFum(address owner, string memory errorMessage) {\\n        require(\\n            msg.sender == owner || delegated[owner][msg.sender] || msg.sender == address(fum),\\n            errorMessage\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Some operations are only allowed after the initial \\\"prefund\\\" (fixed-price funding) period.\\n     */\\n    modifier onlyAfterPrefund {\\n        require(!isDuringPrefund(), \\\"Not allowed during prefund\\\");\\n        _;\\n    }\\n\\n    // ____________________ External transactional functions ____________________\\n\\n    /**\\n     * @notice Mint new USM, sending it to the given address, and only if the amount minted >= `minUsmOut`.  The amount of ETH\\n     * is passed in as `msg.value`.\\n     * @param to address to send the USM to.\\n     * @param minUsmOut Minimum accepted USM for a successful mint.\\n     */\\n    function mint(address to, uint minUsmOut) external payable override returns (uint usmOut) {\\n        usmOut = _mintUsm(to, minUsmOut);\\n    }\\n\\n    /**\\n     * @dev Burn USM in exchange for ETH.\\n     * @param from address to deduct the USM from.\\n     * @param to address to send the ETH to.\\n     * @param usmToBurn Amount of USM to burn.\\n     * @param minEthOut Minimum accepted ETH for a successful burn.\\n     */\\n    function burn(address from, address payable to, uint usmToBurn, uint minEthOut)\\n        external override\\n        onlyHolderOrDelegate(from, \\\"Only holder or delegate\\\")\\n        returns (uint ethOut)\\n    {\\n        ethOut = _burnUsm(from, to, usmToBurn, minEthOut);\\n    }\\n\\n    /**\\n     * @notice Funds the pool with ETH, minting new FUM and sending it to the given address, but only if the amount minted >=\\n     * `minFumOut`.  The amount of ETH is passed in as `msg.value`.\\n     * @param to address to send the FUM to.\\n     * @param minFumOut Minimum accepted FUM for a successful fund.\\n     */\\n    function fund(address to, uint minFumOut) external payable override returns (uint fumOut) {\\n        fumOut = _fundFum(to, minFumOut);\\n    }\\n\\n    /**\\n     * @notice Defunds the pool by redeeming FUM in exchange for equivalent ETH from the pool.\\n     * @param from address to deduct the FUM from.\\n     * @param to address to send the ETH to.\\n     * @param fumToBurn Amount of FUM to burn.\\n     * @param minEthOut Minimum accepted ETH for a successful defund.\\n     */\\n    function defund(address from, address payable to, uint fumToBurn, uint minEthOut)\\n        external override\\n        onlyHolderOrDelegateOrFum(from, \\\"Only holder or delegate or FUM\\\")\\n        onlyAfterPrefund\\n        returns (uint ethOut)\\n    {\\n        ethOut = _defundFum(from, to, fumToBurn, minEthOut);\\n    }\\n\\n    /**\\n     * @notice If anyone sends ETH here, assume they intend it as a `mint`.  If decimals 8 to 11 (inclusive) of the amount of\\n     * ETH received are `0000`, then the next 7 will be parsed as the minimum number of USM accepted per input ETH, with the\\n     * 7-digit number interpreted as \\\"hundredths of a USM\\\".  See comments in `MinOut`.\\n     */\\n    receive() external payable {\\n        _mintUsm(msg.sender, MinOut.parseMinTokenOut(msg.value));\\n    }\\n\\n    // ____________________ Internal ERC20 transactional functions ____________________\\n\\n    /**\\n     * @notice If a user sends USM tokens directly to this contract (or to the FUM contract), assume they intend it as a\\n     * `burn`.  If using `transfer`/`transferFrom` as `burn`, and if decimals 8 to 11 (inclusive) of the amount transferred\\n     * are `0000`, then the next 7 will be parsed as the maximum number of USM tokens sent per ETH received, with the 7-digit\\n     * number interpreted as \\\"hundredths of a USM\\\".  See comments in `MinOut`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal override noOptOut(recipient) returns (bool) {\\n        if (recipient == address(this) || recipient == address(fum) || recipient == address(0)) {\\n            _burnUsm(sender, payable(sender), amount, MinOut.parseMinEthOut(amount));\\n        } else {\\n            super._transfer(sender, recipient, amount);\\n        }\\n        return true;\\n    }\\n\\n    // ____________________ Internal helper transactional functions (for functions above) ____________________\\n\\n    function _mintUsm(address to, uint minUsmOut) internal returns (uint usmOut)\\n    {\\n        require(block.timestamp < DEPOSIT_END_TIMESTAMP, \\\"Deposit window has ended\\\");\\n\\n        // 1. Load the stored state:\\n        LoadedState memory ls = loadState();\\n        ls.ethPool -= msg.value;    // Backing out the ETH just received, which our calculations should ignore\\n\\n        // 2. Check that fund() has been called first - no minting before funding:\\n        require(ls.ethPool > 0, \\\"Fund before minting\\\");\\n\\n        // 3. Refresh the oracle price (if available - see checkForFreshOraclePrice() below):\\n        (ls.ethUsdPrice, ls.ethUsdPriceTimestamp, ls.bidAskAdjustment) = checkForFreshOraclePrice(ls);\\n\\n        // 4. Calculate usmOut:\\n        uint adjShrinkFactor;\\n        (usmOut, adjShrinkFactor) = usmFromMint(ls, msg.value);\\n        require(usmOut >= minUsmOut, \\\"Limit not reached\\\");\\n\\n        // 5. Update the in-memory LoadedState's bidAskAdjustment and price:\\n        ls.bidAskAdjustment = ls.bidAskAdjustment.wadMulDown(adjShrinkFactor);\\n        ls.ethUsdPrice = ls.ethUsdPrice.wadMulDown(adjShrinkFactor);\\n\\n        // 6. Store the updated state and mint the user's new USM:\\n        _storeState(ls);\\n        _mint(to, usmOut);\\n    }\\n\\n    function _burnUsm(address from, address payable to, uint usmToBurn, uint minEthOut) internal returns (uint ethOut)\\n    {\\n        // 1. Load the stored state:\\n        LoadedState memory ls = loadState();\\n\\n        // 2. Refresh the oracle price:\\n        (ls.ethUsdPrice, ls.ethUsdPriceTimestamp, ls.bidAskAdjustment) = checkForFreshOraclePrice(ls);\\n\\n        // 3. Calculate ethOut:\\n        uint adjGrowthFactor;\\n        (ethOut, adjGrowthFactor) = ethFromBurn(ls, usmToBurn);\\n        require(ethOut >= minEthOut, \\\"Limit not reached\\\");\\n\\n        // 4. Update the in-memory LoadedState's bidAskAdjustment and price:\\n        ls.bidAskAdjustment = ls.bidAskAdjustment.wadMulUp(adjGrowthFactor);\\n        ls.ethUsdPrice = ls.ethUsdPrice.wadMulUp(adjGrowthFactor);\\n\\n        // 5. Burn the input USM, store the updated state, and return the user's ETH:\\n        _burn(from, usmToBurn);\\n        _storeState(ls);\\n        to.sendValue(ethOut);\\n    }\\n\\n    function _fundFum(address to, uint minFumOut) internal returns (uint fumOut)\\n    {\\n        require(block.timestamp < DEPOSIT_END_TIMESTAMP, \\\"Deposit window has ended\\\");\\n\\n        // 1. Load the stored state:\\n        LoadedState memory ls = loadState();\\n        ls.ethPool -= msg.value;    // Backing out the ETH just received, which our calculations should ignore\\n\\n        // 2. Refresh the oracle price:\\n        (ls.ethUsdPrice, ls.ethUsdPriceTimestamp, ls.bidAskAdjustment) = checkForFreshOraclePrice(ls);\\n\\n        // 3. Refresh timeSystemWentUnderwater, and replace ls.usmTotalSupply with the *effective* USM supply for FUM buys:\\n        uint debtRatio_;\\n        (ls.timeSystemWentUnderwater, ls.usmTotalSupply, debtRatio_) =\\n            checkIfUnderwater(ls.usmTotalSupply, ls.ethPool, ls.ethUsdPrice, ls.timeSystemWentUnderwater, block.timestamp);\\n\\n        // 4. Calculate fumOut:\\n        uint fumSupply = fum.totalSupply();\\n        uint adjGrowthFactor;\\n        (fumOut, adjGrowthFactor) = fumFromFund(ls, fumSupply, msg.value, debtRatio_, isDuringPrefund());\\n        require(fumOut >= minFumOut, \\\"Limit not reached\\\");\\n\\n        // 5. Update the in-memory LoadedState's bidAskAdjustment and price:\\n        ls.bidAskAdjustment = ls.bidAskAdjustment.wadMulUp(adjGrowthFactor);\\n        ls.ethUsdPrice = ls.ethUsdPrice.wadMulUp(adjGrowthFactor);\\n\\n        // 6. Update the stored state and mint the user's new FUM:\\n        _storeState(ls);\\n        fum.mint(to, fumOut);\\n    }\\n\\n    function _defundFum(address from, address payable to, uint fumToBurn, uint minEthOut) internal returns (uint ethOut)\\n    {\\n        // 1. Load the stored state:\\n        LoadedState memory ls = loadState();\\n\\n        // 2. Refresh the oracle price:\\n        (ls.ethUsdPrice, ls.ethUsdPriceTimestamp, ls.bidAskAdjustment) = checkForFreshOraclePrice(ls);\\n\\n        // 3. Calculate ethOut:\\n        uint fumSupply = fum.totalSupply();\\n        uint adjShrinkFactor;\\n        (ethOut, adjShrinkFactor) = ethFromDefund(ls, fumSupply, fumToBurn);\\n        require(ethOut >= minEthOut, \\\"Limit not reached\\\");\\n\\n        // 4. Update the in-memory LoadedState's bidAskAdjustment and price:\\n        ls.bidAskAdjustment = ls.bidAskAdjustment.wadMulDown(adjShrinkFactor);\\n        ls.ethUsdPrice = ls.ethUsdPrice.wadMulDown(adjShrinkFactor);\\n\\n        // 5. Check that the defund didn't leave debt ratio > MAX_DEBT_RATIO:\\n        uint newDebtRatio = debtRatio(ls.ethUsdPrice, ls.ethPool - ethOut, ls.usmTotalSupply);\\n        require(newDebtRatio <= MAX_DEBT_RATIO, \\\"Debt ratio > max\\\");\\n\\n        // 6. Burn the input FUM, store the updated state, and return the user's ETH:\\n        fum.burn(from, fumToBurn);\\n        _storeState(ls);\\n        to.sendValue(ethOut);\\n    }\\n\\n    /**\\n     * @notice Stores the current price, `bidAskAdjustment`, and `timeSystemWentUnderwater`.  Note that whereas most calls to\\n     * this function store a fresh `bidAskAdjustmentTimestamp`, most calls do *not* store a fresh `ethUsdPriceTimestamp`: the\\n     * latter isn't updated every time this is called with a new price, but only when the *oracle's* price is refreshed.  The\\n     * oracle price being \\\"refreshed\\\" is itself a subtle idea: see the comment in `Oracle.latestPrice()`.\\n     */\\n    function _storeState(LoadedState memory ls) internal {\\n        require(ls.ethUsdPriceTimestamp <= type(uint32).max, \\\"ethUsdPriceTimestamp overflow\\\");\\n        require(ls.bidAskAdjustmentTimestamp <= type(uint32).max, \\\"bidAskAdjustmentTimestamp overflow\\\");\\n\\n        if (ls.timeSystemWentUnderwater != storedState.timeSystemWentUnderwater) {\\n            require(ls.timeSystemWentUnderwater <= type(uint32).max, \\\"timeSystemWentUnderwater overflow\\\");\\n            bool isUnderwater = (ls.timeSystemWentUnderwater != 0);\\n            bool wasUnderwater = (storedState.timeSystemWentUnderwater != 0);\\n            // timeSystemWentUnderwater should only change between 0 and non-0, never from one non-0 to another:\\n            require(isUnderwater != wasUnderwater, \\\"Unexpected timeSystemWentUnderwater change\\\");\\n            emit UnderwaterStatusChanged(isUnderwater);\\n        }\\n\\n        uint priceToStore = ls.ethUsdPrice + HALF_BILLION;\\n        unchecked { priceToStore /= BILLION; }\\n        if (priceToStore != storedState.ethUsdPrice) {\\n            require(priceToStore <= type(uint80).max, \\\"ethUsdPrice overflow\\\");\\n            unchecked { emit PriceChanged(ls.ethUsdPriceTimestamp, priceToStore * BILLION); }\\n        }\\n\\n        uint adjustmentToStore = ls.bidAskAdjustment + HALF_BILLION;\\n        unchecked { adjustmentToStore /= BILLION; }\\n        if (adjustmentToStore != storedState.bidAskAdjustment) {\\n            require(adjustmentToStore <= type(uint80).max, \\\"bidAskAdjustment overflow\\\");\\n            unchecked { emit BidAskAdjustmentChanged(adjustmentToStore * BILLION); }\\n        }\\n\\n        (storedState.timeSystemWentUnderwater,\\n         storedState.ethUsdPriceTimestamp, storedState.ethUsdPrice,\\n         storedState.bidAskAdjustmentTimestamp, storedState.bidAskAdjustment) =\\n            (uint32(ls.timeSystemWentUnderwater),\\n             uint32(ls.ethUsdPriceTimestamp), uint80(priceToStore),\\n             uint32(ls.bidAskAdjustmentTimestamp), uint80(adjustmentToStore));\\n    }\\n\\n    // ____________________ Public Oracle view functions ____________________\\n\\n    function latestPrice() public virtual override view returns (uint price, uint updateTime) {\\n        (price, updateTime,) = checkForFreshOraclePrice(loadState());\\n    }\\n\\n    // ____________________ Public informational view functions ____________________\\n\\n    /**\\n     * @notice Checks the external oracle for a fresh ETH/USD price.  If it has one, we take it as the new USM system price\\n     * (and update `bidAskAdjustment` as described below); if no fresh oracle price is available, we stick with our existing\\n     * system price, `ls.ethUsdPrice`, which may have been nudged around by mint/burn operations since the last oracle update.\\n     *\\n     * Note that our definition of whether an oracle price is \\\"fresh\\\" (`updateTime > ls.ethUsdPriceTimestamp`) isn't as simple\\n     * as \\\"whether it's changed since our last call.\\\"  Eg, we only consider a Uniswap TWAP price \\\"fresh\\\" when a new price\\n     * observation (trade) occurs, even though `price` may change without such an observation.  See the comment in\\n     * `Oracle.latestPrice()`.\\n     */\\n    function checkForFreshOraclePrice(LoadedState memory ls)\\n        public view returns (uint price, uint updateTime, uint adjustment)\\n    {\\n        (price, updateTime) = oracle.latestPrice();\\n\\n        adjustment = ls.bidAskAdjustment;\\n\\n        if (updateTime <= ls.ethUsdPriceTimestamp) {    // If oracle's price isn't fresher than our stored one, keep stored one\\n            (price, updateTime) = (ls.ethUsdPrice, ls.ethUsdPriceTimestamp);\\n        } else if (ls.ethUsdPrice != 0) {   // If the old price is 0, don't try to use it to adjust the bidAskAdjustment...\\n            /**\\n             * This is a bit subtle.  We want to update the mid stored price to the oracle's fresh value, while updating\\n             * bidAskAdjustment in such a way that the currently adjusted (more expensive than mid) side gets no cheaper/more\\n             * favorably priced for users.  Example:\\n             *\\n             * 1. storedPrice = $1,000, and bidAskAdjustment = 1.02.  So, our current ETH buy price is $1,020, and our current\\n             *    ETH sell price is $1,000 (mid).\\n             * 2. The oracle comes back with a fresh price (newer updateTime) of $990.\\n             * 3. The currently adjusted price is buy price (ie, adj > 1).  So, we want to:\\n             *    a) Update storedPrice (mid) to $990.\\n             *    b) Update bidAskAdj to ensure that buy price remains >= $1,020.\\n             * 4. We do this by upping bidAskAdj 1.02 -> 1.0303.  Then the new buy price will remain $990 * 1.0303 = $1,020.\\n             *    The sell price will remain the unadjusted mid: formerly $1,000, now $990.\\n             *\\n             * Because the bidAskAdjustment reverts to 1 in a few minutes, the new 3.03% buy premium is temporary: buy price\\n             * will revert to the $990 mid soon - unless the new mid is egregiously low, in which case buyers should push it\\n             * back up.  Eg, suppose the oracle gives us a glitchy price of $99.  Then new mid = $99, bidAskAdj = 10.303, buy\\n             * price = $1,020, and the buy price will rapidly drop towards $99; but as it does so, users are incentivized to\\n             * step in and buy, eventually pushing mid back up to the real-world ETH market price (eg $990).\\n             *\\n             * In cases like this, our bidAskAdj update has protected the system, by preventing users from getting any chance\\n             * to buy at the bogus $99 price.\\n             */\\n            if (adjustment > WAD) {\\n                // max(1, old buy price / new mid price):\\n                adjustment = WAD.wadMax(ls.ethUsdPrice.wadMulDivUp(adjustment, price));\\n            } else if (adjustment < WAD) {\\n                // min(1, old sell price / new mid price):\\n                adjustment = WAD.wadMin(ls.ethUsdPrice.wadMulDivDown(adjustment, price));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Total amount of ETH in the pool (ie, in the contract).\\n     * @return pool ETH pool\\n     */\\n    function ethPool() public override view returns (uint pool) {\\n        pool = address(this).balance;\\n    }\\n\\n    function fumTotalSupply() public override view returns (uint supply) {\\n        supply = fum.totalSupply();\\n    }\\n\\n    /**\\n     * @notice The current bid/ask adjustment, equal to the stored value decayed over time towards its stable value, 1.  This\\n     * adjustment is intended as a measure of \\\"how long-ETH recent user activity has been\\\", so that we can slide price\\n     * accordingly: if recent activity was mostly long-ETH (`fund()` and `burn()`), raise FUM buy price/reduce USM sell price;\\n     * if recent activity was short-ETH (`defund()` and `mint()`), reduce FUM sell price/raise USM buy price.\\n     * @return adjustment The sliding-price bid/ask adjustment\\n     */\\n    function bidAskAdjustment() public override view returns (uint adjustment) {\\n        adjustment = loadState().bidAskAdjustment;      // Not just from storedState, b/c need to update it - see loadState()\\n    }\\n\\n    function timeSystemWentUnderwater() public override view returns (uint timestamp) {\\n        timestamp = storedState.timeSystemWentUnderwater;\\n    }\\n\\n    function isDuringPrefund() public override view returns (bool duringPrefund) {\\n        duringPrefund = block.timestamp < PREFUND_END_TIMESTAMP;\\n    }\\n\\n    // ____________________ Public helper view functions (for functions above) ____________________\\n\\n    /**\\n     * @return ls A `LoadedState` object packaging the system's current state: `ethUsdPrice`, `bidAskAdjustment`, etc (see\\n     * `storedState`), plus the ETH and USM balances.  `bidAskAdjustment` is also brought up to date, ie, decayed closer to 1\\n     * according to how much time has passed since it was stored: so if `bidAskAdjustment` was 2.0 five minutes ago, and\\n     * `BID_ASK_ADJUSTMENT_DECAY_PER_SECOND` corresponds to a half-life of 1 minute, `ls.bidAskAdjustment` is set to 1.03125\\n     * (see `bidAskAdjustment(storedTime, storedAdjustment, currentTime)`).\\n     */\\n    function loadState() public view returns (LoadedState memory ls) {\\n        ls.timeSystemWentUnderwater = storedState.timeSystemWentUnderwater;\\n        ls.ethUsdPriceTimestamp = storedState.ethUsdPriceTimestamp;\\n        ls.ethUsdPrice = storedState.ethUsdPrice * BILLION;     // Converting stored BILLION (1e9) format to WAD (1e18)\\n\\n        // Bring bidAskAdjustment up to the present - it gravitates towards 1 over time, so the stored value is obsolete:\\n        ls.bidAskAdjustmentTimestamp = block.timestamp;\\n        ls.bidAskAdjustment = bidAskAdjustment(storedState.bidAskAdjustmentTimestamp,\\n                                               storedState.bidAskAdjustment * BILLION,\\n                                               block.timestamp);\\n\\n        ls.ethPool = ethPool();\\n        ls.usmTotalSupply = totalSupply();\\n    }\\n\\n    // ____________________ Public helper pure functions (for functions above) ____________________\\n\\n    /**\\n     * @notice Calculate the amount of ETH in the buffer.\\n     * @return buffer ETH buffer\\n     */\\n    function ethBuffer(uint ethUsdPrice, uint ethInPool, uint usmSupply, bool roundUp)\\n        public override pure returns (int buffer)\\n    {\\n        // Reverse the input upOrDown, since we're using it for usmToEth(), which will be *subtracted* from ethInPool below:\\n        uint usmValueInEth = usmToEth(ethUsdPrice, usmSupply, !roundUp);    // Iff rounding the buffer up, round usmValue down\\n        require(ethUsdPrice <= uint(type(int).max) && usmValueInEth <= uint(type(int).max), \\\"ethBuffer overflow/underflow\\\");\\n        buffer = int(ethInPool) - int(usmValueInEth);   // After the previous line, no over/underflow should be possible here\\n    }\\n\\n    /**\\n     * @notice Calculate debt ratio for a given eth to USM price: ratio of the outstanding USM (amount of USM in total supply),\\n     * to the current ETH pool value in USD (ETH qty * ETH/USD price).\\n     * @return ratio Debt ratio (or 0 if there's currently 0 ETH in the pool/price = 0: these should never happen after launch)\\n     */\\n    function debtRatio(uint ethUsdPrice, uint ethInPool, uint usmSupply) public override pure returns (uint ratio) {\\n        uint ethPoolValueInUsd = ethInPool.wadMulDown(ethUsdPrice);\\n        ratio = (usmSupply == 0 ? 0 : (ethPoolValueInUsd == 0 ? type(uint).max : usmSupply.wadDivUp(ethPoolValueInUsd)));\\n    }\\n\\n    /**\\n     * @notice Convert ETH amount to USM using a ETH/USD price.\\n     * @param ethAmount The amount of ETH to convert\\n     * @return usmOut The amount of USM\\n     */\\n    function ethToUsm(uint ethUsdPrice, uint ethAmount, bool roundUp) public override pure returns (uint usmOut) {\\n        usmOut = ethAmount.wadMul(ethUsdPrice, roundUp);\\n    }\\n\\n    /**\\n     * @notice Convert USM amount to ETH using a ETH/USD price.\\n     * @param usmAmount The amount of USM to convert\\n     * @return ethOut The amount of ETH\\n     */\\n    function usmToEth(uint ethUsdPrice, uint usmAmount, bool roundUp) public override pure returns (uint ethOut) {\\n        ethOut = usmAmount.wadDiv(ethUsdPrice, roundUp);\\n    }\\n\\n    /**\\n     * @return price The ETH/USD price, adjusted by the `bidAskAdjustment` (if applicable) for the given buy/sell side.\\n     */\\n    function adjustedEthUsdPrice(IUSM.Side side, uint ethUsdPrice, uint adjustment) public override pure returns (uint price) {\\n        price = ethUsdPrice;\\n\\n        // Apply the adjustment if (side == Buy and adj > 1), or (side == Sell and adj < 1):\\n        if (side == IUSM.Side.Buy ? (adjustment > WAD) : (adjustment < WAD)) {\\n            price = price.wadMul(adjustment, side == IUSM.Side.Buy);    // Round up iff side = buy\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the *marginal* price of USM (in ETH terms): that is, of the next unit, before the price start sliding.\\n     * @return price USM price in ETH terms\\n     */\\n    function usmPrice(IUSM.Side side, uint ethUsdPrice) public override pure returns (uint price) {\\n        price = usmToEth(ethUsdPrice, WAD, side == IUSM.Side.Buy);      // Round up iff side = buy\\n    }\\n\\n    /**\\n     * @notice Calculate the *marginal* price of FUM (in ETH terms): that is, of the next unit, before the price starts rising.\\n     * @param usmEffectiveSupply should be either the actual current USM supply, or, when calculating the FUM *buy* price, the\\n     * return value of `usmSupplyForFumBuys()`.\\n     * @return price FUM price in ETH terms\\n     */\\n    function fumPrice(IUSM.Side side, uint ethUsdPrice, uint ethInPool, uint usmEffectiveSupply, uint fumSupply, bool prefund)\\n        public override pure returns (uint price)\\n    {\\n        if (prefund) {\\n            price = PREFUND_FUM_PRICE_IN_ETH;   // We're in the prefund period, so the price is just the prefund's \\\"prix fixe\\\"\\n        } else {\\n            // Using usmEffectiveSupply here, rather than just the raw actual supply, has the effect of bumping the FUM price\\n            // up to the minFumBuyPrice when needed (ie, when debt ratio > MAX_DEBT_RATIO):\\n            bool roundUp = (side == IUSM.Side.Buy);\\n            int buffer = ethBuffer(ethUsdPrice, ethInPool, usmEffectiveSupply, roundUp);\\n            price = (buffer <= 0 ? 0 : uint(buffer).wadDiv(fumSupply, roundUp));\\n        }\\n    }\\n\\n    /**\\n     * @return timeSystemWentUnderwater_ The time at which we first detected the system was underwater (debt ratio >\\n     * `MAX_DEBT_RATIO`), based on the current oracle price and pool ETH and USM; or 0 if we're not currently underwater.\\n     * @return usmSupplyForFumBuys The current supply of USM *for purposes of calculating the FUM buy price,* and therefore\\n     * for `fumFromFund()`.  The \\\"supply for FUM buys\\\" is the *lesser* of the actual current USM supply, and the USM amount\\n     * that would make debt ratio = `MAX_DEBT_RATIO`.  Example:\\n     *\\n     * 1. Suppose the system currently contains 50 ETH at price $1,000 (total pool value: $50,000), with an actual USM supply\\n     *    of 30,000 USM.  Then debt ratio = 30,000 / $50,000 = 60%: < MAX 80%, so `usmSupplyForFumBuys` = 30,000.\\n     * 2. Now suppose ETH/USD halves to $500.  Then pool value halves to $25,000, and debt ratio doubles to 120%.  Now\\n     *    `usmSupplyForFumBuys` instead = 20,000: the USM quantity at which debt ratio would equal 80% (20,000 / $25,000).\\n     *    (Call this the \\\"80% supply\\\".)\\n     * 3. ...Except, we also gradually increase the supply over time while we remain underwater.  This has the effect of\\n     *    *reducing* the FUM buy price inferred from that supply (higher JacobUSM supply -> smaller buffer -> lower FUM price).\\n     *    The math we use gradually increases the supply from its initial \\\"80% supply\\\" value, where debt ratio =\\n     *    `MAX_DEBT_RATIO` (20,000 above), to a theoretical maximum \\\"100% supply\\\" value, where debt ratio = 100% (in the $500\\n     *    example above, this would be 25,000).  (Or the actual supply, whichever is lower: we never increase\\n     *    `usmSupplyForFumBuys` above `usmActualSupply`.)  The climb from the initial 80% supply (20,000) to the 100% supply\\n     *    (25,000) is at a rate that brings it \\\"halfway closer per `minFumBuyPrice` half-life (eg, 1 day)\\\": so three days after\\n     *    going underwater, the supply returned will be 25,000 - 0.5**3 * (25,000 - 20,000) = 24,375.\\n     */\\n    function checkIfUnderwater(uint usmActualSupply, uint ethPool_, uint ethUsdPrice, uint oldTimeUnderwater, uint currentTime)\\n        public override pure returns (uint timeSystemWentUnderwater_, uint usmSupplyForFumBuys, uint debtRatio_)\\n    {\\n        debtRatio_ = debtRatio(ethUsdPrice, ethPool_, usmActualSupply);\\n        if (debtRatio_ <= MAX_DEBT_RATIO) {            // We're not underwater, so leave timeSystemWentUnderwater_ as 0\\n            usmSupplyForFumBuys = usmActualSupply;     // When not underwater, USM supply for FUM buys is just actual supply\\n        } else {                                       // We're underwater\\n            // Set timeSystemWentUnderwater_ to currentTime, if it wasn't already set:\\n            timeSystemWentUnderwater_ = (oldTimeUnderwater != 0 ? oldTimeUnderwater : currentTime);\\n\\n            // Calculate usmSupplyForFumBuys:\\n            uint maxEffectiveDebtRatio = debtRatio_.wadMin(WAD);    // min(actual debt ratio, 100%)\\n            uint decayFactor = MIN_FUM_BUY_PRICE_DECAY_PER_SECOND.wadPowInt(currentTime - timeSystemWentUnderwater_);\\n            uint effectiveDebtRatio = maxEffectiveDebtRatio - decayFactor.wadMulUp(maxEffectiveDebtRatio - MAX_DEBT_RATIO);\\n            usmSupplyForFumBuys = effectiveDebtRatio.wadMulDown(ethPool_.wadMulDown(ethUsdPrice));\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the given stored `bidAskAdjustment` value, updated (decayed towards 1) to the current time.\\n     */\\n    function bidAskAdjustment(uint storedTime, uint storedAdjustment, uint currentTime) public pure returns (uint adjustment) {\\n        uint secsSinceStored = currentTime - storedTime;\\n        // ZERO_OUT_PERIOD here is important, so a long gap between ops doesn't waste a lot of gas calculating the ~0 decay:\\n        uint decayFactor = (secsSinceStored >= BID_ASK_ADJUSTMENT_ZERO_OUT_PERIOD ? 0 :\\n                            BID_ASK_ADJUSTMENT_DECAY_PER_SECOND.wadPowInt(secsSinceStored));\\n        // Here we use the idea that for any b and 0 <= p <= 1, we can crudely approximate b**p by 1 + (b-1)p = 1 + bp - p.\\n        // Eg: 0.6**0.5 pulls 0.6 \\\"about halfway\\\" to 1 (0.8); 0.6**0.25 pulls 0.6 \\\"about 3/4 of the way\\\" to 1 (0.9).\\n        // So b**p =~ b + (1-p)(1-b) = b + 1 - b - p + bp = 1 + bp - p.\\n        // (Don't calculate it as 1 + (b-1)p because we're using uints, b-1 can be negative!)\\n        adjustment = WAD + storedAdjustment.wadMulDown(decayFactor) - decayFactor;\\n    }\\n\\n    /**\\n     * @notice How much USM a minter currently gets back for `ethIn` ETH, accounting for `bidAskAdjustment` and sliding prices.\\n     * @param ethIn The amount of ETH passed to `mint()`\\n     * @return usmOut The amount of USM to receive in exchange\\n     */\\n    function usmFromMint(LoadedState memory ls, uint ethIn)\\n        public pure returns (uint usmOut, uint adjShrinkFactor)\\n    {\\n        // The USM buy price we pay, in ETH terms, \\\"slides up\\\" as we buy, proportional to the ETH in the pool: if the pool\\n        // starts with 100 ETH, and ethIn = 5, so we're increasing it to 105, then our USM/ETH buy price increases smoothly by\\n        // 5% during the mint operation.  (Buying USM with ETH is economically equivalent to selling ETH for USD: so this is\\n        // equivalent to saying that the ETH/USD price used to price our USM *decreases* smoothly by 5% during the operation.)\\n        // Of that 5%, \\\"half\\\" (in log space) is the ETH/USD *mid* price dropping, and the other half is the bidAskAdjustment\\n        // (ETH sell price discount) dropping.\\n        uint adjustedEthUsdPrice0 = adjustedEthUsdPrice(IUSM.Side.Sell, ls.ethUsdPrice, ls.bidAskAdjustment);\\n        uint usmBuyPrice0 = usmPrice(IUSM.Side.Buy, adjustedEthUsdPrice0);      // Minting USM = buying USM = selling ETH\\n        uint ethPool1 = ls.ethPool + ethIn;\\n\\n        uint oneOverEthGrowthFactor = ls.ethPool.wadDivDown(ethPool1);\\n        adjShrinkFactor = oneOverEthGrowthFactor.wadSqrtDown();\\n\\n        // In theory, calculating the total amount of USM minted involves summing an integral over 1 / usmBuyPrice, which gives\\n        // the following simple logarithm:\\n        //int log = ethPool1.wadDivDown(ls.ethPool).wadLog();                   // 2a) Most exact: ~4k more gas\\n        //require(log >= 0, \\\"log underflow\\\");\\n        //usmOut = ls.ethPool.wadMulDivDown(uint(log), usmBuyPrice0);\\n\\n        // But in practice, we can save some gas by approximating the log integral above as follows: take the geometric average\\n        // of the starting and ending usmBuyPrices, and just apply that average price to the entire ethIn passed in.\\n        uint usmBuyPriceAvg = usmBuyPrice0.wadDivUp(adjShrinkFactor);\\n        usmOut = ethIn.wadDivDown(usmBuyPriceAvg);\\n    }\\n\\n    /**\\n     * @notice How much ETH a burner currently gets from burning `usmIn` USM, accounting for `bidAskAdjustment` and sliding\\n     * prices.\\n     * @param usmIn The amount of USM passed to `burn()`\\n     * @return ethOut The amount of ETH to receive in exchange\\n     */\\n    function ethFromBurn(LoadedState memory ls, uint usmIn)\\n        public pure returns (uint ethOut, uint adjGrowthFactor)\\n    {\\n        // Burn USM at a sliding-down USM price (ie, a sliding-up ETH price).  This is just the mirror image of the math in\\n        // usmFromMint() above, but because we're calculating output ETH from input USM rather than the other way around, we\\n        // end up with an exponent (exponent.wadExpDown() below, aka e**exponent) rather than a logarithm.\\n        uint adjustedEthUsdPrice0 = adjustedEthUsdPrice(IUSM.Side.Buy, ls.ethUsdPrice, ls.bidAskAdjustment);\\n        uint usmSellPrice0 = usmPrice(IUSM.Side.Sell, adjustedEthUsdPrice0);    // Burning USM = selling USM = buying ETH\\n\\n        // The USM sell price is capped by the ETH pool value per USM outstanding.  In other words, when the system is\\n        // underwater (debt ratio > 100%), burners \\\"take a haircut\\\" - burning USM yields less than $1 of ETH per USM burned:\\n        usmSellPrice0 = usmSellPrice0.wadMin(ls.ethPool.wadDivDown(ls.usmTotalSupply));\\n\\n        // The exact integral - calculating the amount of ETH yielded by burning the USM at our sliding-down USM price:\\n        uint exponent = usmIn.wadMulDivDown(usmSellPrice0, ls.ethPool);\\n        uint ethPool1 = ls.ethPool.wadDivUp(exponent.wadExpDown());\\n        ethOut = ls.ethPool - ethPool1;\\n\\n        // In this case we back out the adjGrowthFactor (change in mid price and bidAskAdj) from the change in the ETH pool:\\n        adjGrowthFactor = ls.ethPool.wadDivUp(ethPool1).wadSqrtUp();\\n    }\\n\\n    /**\\n     * @notice How much FUM a funder currently gets back for `ethIn` ETH, accounting for `bidAskAdjustment` and sliding prices.\\n     * Note that we expect `ls.usmTotalSupply` of the LoadedState passed in to not necessarily be the actual current total USM\\n     * supply, but the *effective* USM supply for purposes of this operation - which can be a lower number, artificially\\n     * increasing the FUM price.  This is our \\\"minFumBuyPrice\\\" logic, used to prevent FUM buyers from paying tiny or negative\\n     * prices when the system is underwater or near it.\\n     * @param ethIn The amount of ETH passed to `fund()`\\n     * @return fumOut The amount of FUM to receive in exchange\\n     */\\n    function fumFromFund(LoadedState memory ls, uint fumSupply, uint ethIn, uint debtRatio_, bool prefund)\\n        public pure returns (uint fumOut, uint adjGrowthFactor)\\n    {\\n        uint adjustedEthUsdPrice0 = adjustedEthUsdPrice(IUSM.Side.Buy, ls.ethUsdPrice, ls.bidAskAdjustment);\\n        uint fumBuyPrice0 = fumPrice(IUSM.Side.Buy, adjustedEthUsdPrice0, ls.ethPool, ls.usmTotalSupply, fumSupply, prefund);\\n        if (prefund) {\\n            // We're in the prefund period, so no fees - fumOut is just ethIn divided by the fixed prefund FUM price:\\n            adjGrowthFactor = WAD;\\n            fumOut = ethIn.wadDivDown(fumBuyPrice0);\\n        } else {\\n            // Create FUM at a sliding-up FUM price.  We follow the same broad strategy as in usmFromMint(): the effective ETH\\n            // price increases smoothly during the fund() operation, proportionally to the fraction by which the ETH pool\\n            // grows.  But there are a couple of extra nuances in the FUM case:\\n            //\\n            // 1. FUM is \\\"leveraged\\\"/\\\"higher-delta\\\" ETH, so minting 1 ETH worth of FUM should move the price by more than\\n            //    minting 1 ETH worth of USM does.  (More by a \\\"net FUM delta\\\" factor.)\\n            // 2. The theoretical FUM price is based on the ETH buffer (excess ETH beyond what's needed to cover the\\n            //    outstanding USM), which is itself affected by/during this fund operation...\\n            //\\n            // The code below uses a \\\"reasonable approximation\\\" to deal with those complications.  See also the discussion in:\\n            // https://jacob-eliosoff.medium.com/usm-minimalist-decentralized-stablecoin-part-4-fee-math-decisions-a5be6ecfdd6f\\n\\n            { // Scope for adjGrowthFactor, to avoid the dreaded \\\"stack too deep\\\" error.  Thanks Uniswap v2 for the trick!\\n                // 1. Start by calculating the \\\"net FUM delta\\\" described above - the factor by which this operation will move\\n                // the ETH price more than a simple mint() operation would.  Calculating the pure, fluctuating theoretical\\n                // delta is a mess: we calculate the initial delta and pretend it stays fixed thereafter.  The theoretical\\n                // delta *decreases* during a fund() call (as the pool grows, the ETH/USD price increases, and FUM becomes less\\n                // leveraged), so holding it fixed at its initial value is \\\"pessimistic\\\", like we want - ensures we charge more\\n                // fees than the theoretical amount, not less.\\n                uint effectiveDebtRatio0 = debtRatio_.wadMin(MAX_DEBT_RATIO);\\n                uint netFumDelta = effectiveDebtRatio0.wadDivUp(WAD - effectiveDebtRatio0);\\n\\n                // 2. Given the delta, we can calculate the adjGrowthFactor (price impact): for mint() (delta 1), the factor\\n                // was poolChangeFactor**(1 / 2); now instead we use poolChangeFactor**(netFumDelta / 2).\\n                uint ethPool1 = ls.ethPool + ethIn;\\n                adjGrowthFactor = ethPool1.wadDivUp(ls.ethPool).wadPowUp(netFumDelta / 2);\\n            }\\n\\n            // 3. Here we use the same simplifying trick as usmFromMint() above: we pretend our entire FUM purchase is done at\\n            // a single fixed price.  For that fixed FUM price, we again use the trick of taking the geometric average of the\\n            // starting and ending FUM buy prices, which we can calculate exactly now that we know the ending ETH pool quantity\\n            // (from ethIn) and the ending adjusted ETH/USD price (from the adjGrowthFactor calculated above).  This geometric\\n            // average isn't as accurate an approximation of the theoretical integral here as it was for usmFromMint(), since\\n            // the FUM buy price follows a less predictable curve than the USM buy price, but it's close enough for our\\n            // purposes: we mostly just want to charge funders a positive fee, that increases as a % of ethIn as ethIn gets\\n            // larger (\\\"larger trades pay superlinearly larger fees\\\").\\n            uint adjustedEthUsdPrice1 = adjustedEthUsdPrice0.wadMulUp(adjGrowthFactor.wadSquaredUp());\\n            uint fumBuyPrice1 = fumPrice(IUSM.Side.Buy, adjustedEthUsdPrice1, ls.ethPool, ls.usmTotalSupply, fumSupply,\\n                                         prefund);\\n            uint avgFumBuyPrice = fumBuyPrice0.wadMulUp(fumBuyPrice1).wadSqrtUp();      // Taking the geometric avg\\n            fumOut = ethIn.wadDivDown(avgFumBuyPrice);\\n        }\\n    }\\n\\n    /**\\n     * @notice How much ETH a defunder currently gets back for fumIn FUM, accounting for adjustment and sliding prices.\\n     * @param fumIn The amount of FUM passed to `defund()`\\n     * @return ethOut The amount of ETH to receive in exchange\\n     */\\n    function ethFromDefund(LoadedState memory ls, uint fumSupply, uint fumIn)\\n        public pure returns (uint ethOut, uint adjShrinkFactor)\\n    {\\n        // Burn FUM at a sliding-down FUM price.  Our approximation technique here resembles the one in fumFromFund() above,\\n        // but we need to be even more clever this time...\\n\\n        // 1. Calculating the initial FUM sell price we start from is no problem:\\n        uint adjustedEthUsdPrice0 = adjustedEthUsdPrice(IUSM.Side.Sell, ls.ethUsdPrice, ls.bidAskAdjustment);\\n        uint fumSellPrice0 = fumPrice(IUSM.Side.Sell, adjustedEthUsdPrice0, ls.ethPool, ls.usmTotalSupply, fumSupply, false);\\n\\n        { // Scope for adjShrinkFactor, to avoid the dreaded \\\"stack too deep\\\" error.  Thanks Uniswap v2 for the trick!\\n            // 2. Now we want a \\\"pessimistic\\\" lower bound on the ending ETH pool qty.  We can get this by supposing the entire\\n            // burn happened at our initial fumSellPrice0: this is \\\"optimistic\\\" in terms of how much ETH we'd get back, but\\n            // \\\"pessimistic\\\" in the sense we want - how much ETH would be left in the pool:\\n            uint lowerBoundEthQty1 = ls.ethPool - fumIn.wadMulUp(fumSellPrice0);\\n            uint lowerBoundEthShrinkFactor1 = lowerBoundEthQty1.wadDivDown(ls.ethPool);\\n\\n            // 3. From this \\\"pessimistic\\\" lower bound on the ending ETH qty, and a similarly pessimistic netFumDelta value of 4\\n            // (the netFumDelta when debt ratio is at the highest value it can end at here, MAX_DEBT_RATIO), we can calculate a\\n            // \\\"pessimistic\\\" lower bound on our ending adjustedEthUsdPrice, ie, overstating how large an impact our burn could\\n            // have on the ETH/USD price used to calculate our FUM sell price:\\n            uint adjustedEthUsdPrice1 = adjustedEthUsdPrice0.wadMulDown(lowerBoundEthShrinkFactor1.wadPowDown(FOUR_WAD));\\n\\n            // 4. From adjustedEthUsdPrice1, we can calculate a pessimistic (upper-bound) debtRatio2 we'll end up at after the\\n            // defund operation, and from debtRatio2, a pessimistic (upper-bound) netFumDelta2 we can hold fixed during the\\n            // calculation:\\n            uint debtRatio1 = debtRatio(adjustedEthUsdPrice1, lowerBoundEthQty1, ls.usmTotalSupply);\\n            uint debtRatio2 = debtRatio1.wadMin(MAX_DEBT_RATIO);    // defund() fails anyway if dr ends > MAX, so cap it at MAX\\n            uint netFumDelta2 = WAD.wadDivUp(WAD - debtRatio2) - WAD;\\n\\n            // 5. Combining lowerBoundEthShrinkFactor1 and netFumDelta2 gives us our final, pessimistic adjShrinkFactor, from\\n            // our standard formula adjChangeFactor = ethChangeFactor**(netFumDelta / 2):\\n            adjShrinkFactor = lowerBoundEthShrinkFactor1.wadPowDown(netFumDelta2 / 2);\\n        }\\n\\n        // 6. And adjShrinkFactor tells us the adjustedEthUsdPrice2 we'll end the operation at, from which we can also\\n        // calculate the instantaneous FUM sell price we'll end the operation at, just as we calculated our ending fumBuyPrice1\\n        // in fumFromFund():\\n        uint adjustedEthUsdPrice2 = adjustedEthUsdPrice0.wadMulDown(adjShrinkFactor.wadSquaredDown());\\n        uint fumSellPrice2 = fumPrice(IUSM.Side.Sell, adjustedEthUsdPrice2, ls.ethPool, ls.usmTotalSupply, fumSupply, false);\\n\\n        // 7. We now know the starting fumSellPrice0, and the ending fumSellPrice2.  We want to combine these to get a single\\n        // avgFumSellPrice we can use for the entire defund operation, which will trivially give us ethOut.  But taking the\\n        // geometric average again, as we did in usmFromMint() and fumFromFund(), is dicey in the defund() case: fumSellPrice2\\n        // could be arbitrarily close to 0, which would make avgFumSellPrice arbitrarily close to 0, which would have the\\n        // highly perverse result that a *larger* fumIn returns strictly *less* ETH!  What alternative to geometric average\\n        // gives the best results here is a complicated problem, but one simple option that avoids the avgFumSellPrice = 0 flaw\\n        // is to just take the arithmetic average instead, (fumSellPrice0 + fumSellPrice2) / 2:\\n        uint avgFumSellPrice = (fumSellPrice0 + fumSellPrice2) / 2;\\n        ethOut = fumIn.wadMulDown(avgFumSellPrice);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc20permit/contracts/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\\npragma solidity ^0.8.0;\\n\\nimport \\\"acc-erc20/contracts/ERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\n\\n/**\\n * @author Georgios Konstantopoulos\\n * @dev Extension of {ERC20} that allows token holders to use their tokens\\n * without sending any transactions by setting {IERC20-allowance} with a\\n * signature using the {permit} method, and then spend them via\\n * {IERC20-transferFrom}.\\n *\\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\\n */\\nabstract contract ERC20Permit is ERC20, IERC2612 {\\n    mapping (address => uint256) public override nonces;\\n\\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name_)),\\n                keccak256(bytes(version())),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Setting the version as a function so that it can be overriden\\n    function version() public pure virtual returns(string memory) { return \\\"1\\\"; }\\n\\n    /**\\n     * @dev See {IERC2612-permit}.\\n     *\\n     * In cases where the free option is not a concern, deadline can simply be\\n     * set to uint(-1), so it should be seen as an optional parameter\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\\n        require(deadline >= block.timestamp, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                amount,\\n                nonces[owner]++,\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                hashStruct\\n            )\\n        );\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        require(\\n            signer != address(0) && signer == owner,\\n            \\\"ERC20Permit: invalid signature\\\"\\n        );\\n\\n        _approve(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IUSM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"acc-erc20/contracts/IERC20.sol\\\";\\nimport \\\"./oracles/Oracle.sol\\\";\\n\\nabstract contract IUSM is IERC20, Oracle {\\n    event UnderwaterStatusChanged(bool underwater);\\n    event BidAskAdjustmentChanged(uint adjustment);\\n    event PriceChanged(uint timestamp, uint price);\\n\\n    enum Side {Buy, Sell}\\n\\n    // ____________________ External transactional functions ____________________\\n\\n    /**\\n     * @notice Mint new USM, sending it to the given address, and only if the amount minted >= `minUsmOut`.  The amount of ETH\\n     * is passed in as `msg.value`.\\n     * @param to address to send the USM to.\\n     * @param minUsmOut Minimum accepted USM for a successful mint.\\n     */\\n    function mint(address to, uint minUsmOut) external virtual payable returns (uint usmOut);\\n\\n    /**\\n     * @dev Burn USM in exchange for ETH.\\n     * @param from address to deduct the USM from.\\n     * @param to address to send the ETH to.\\n     * @param usmToBurn Amount of USM to burn.\\n     * @param minEthOut Minimum accepted ETH for a successful burn.\\n     */\\n    function burn(address from, address payable to, uint usmToBurn, uint minEthOut) external virtual returns (uint ethOut);\\n\\n    /**\\n     * @notice Funds the pool with ETH, minting new FUM and sending it to the given address, but only if the amount minted >=\\n     * `minFumOut`.  The amount of ETH is passed in as `msg.value`.\\n     * @param to address to send the FUM to.\\n     * @param minFumOut Minimum accepted FUM for a successful fund.\\n     */\\n    function fund(address to, uint minFumOut) external virtual payable returns (uint fumOut);\\n\\n    /**\\n     * @notice Defunds the pool by redeeming FUM in exchange for equivalent ETH from the pool.\\n     * @param from address to deduct the FUM from.\\n     * @param to address to send the ETH to.\\n     * @param fumToBurn Amount of FUM to burn.\\n     * @param minEthOut Minimum accepted ETH for a successful defund.\\n     */\\n    function defund(address from, address payable to, uint fumToBurn, uint minEthOut) external virtual returns (uint ethOut);\\n\\n    // ____________________ Public informational view functions ____________________\\n\\n    /**\\n     * @notice Total amount of ETH in the pool (ie, in the contract).\\n     * @return pool ETH pool\\n     */\\n    function ethPool() public virtual view returns (uint pool);\\n\\n    /**\\n     * @notice Total amount of ETH in the pool (ie, in the contract).\\n     * @return supply the total supply of FUM.  Users of this `IUSM` interface, like `USMView`, need to call this rather than\\n     * `usm.fum().totalSupply()` directly, because `IUSM` doesn't (and shouldn't) know about the `FUM` type.\\n     */\\n    function fumTotalSupply() public virtual view returns (uint supply);\\n\\n    /**\\n     * @notice The current bid/ask adjustment, equal to the stored value decayed over time towards its stable value, 1.  This\\n     * adjustment is intended as a measure of \\\"how long-ETH recent user activity has been\\\", so that we can slide price\\n     * accordingly: if recent activity was mostly long-ETH (`fund()` and `burn()`), raise FUM buy price/reduce USM sell price;\\n     * if recent activity was short-ETH (`defund()` and `mint()`), reduce FUM sell price/raise USM buy price.\\n     * @return adjustment The sliding-price bid/ask adjustment\\n     */\\n    function bidAskAdjustment() public virtual view returns (uint adjustment);\\n\\n    function timeSystemWentUnderwater() public virtual view returns (uint timestamp);\\n\\n    function isDuringPrefund() public virtual view returns (bool duringPrefund);\\n\\n    // ____________________ Public helper pure functions (for functions above) ____________________\\n\\n    /**\\n     * @notice Calculate the amount of ETH in the buffer.\\n     * @return buffer ETH buffer\\n     */\\n    function ethBuffer(uint ethUsdPrice, uint ethInPool, uint usmSupply, bool roundUp) public virtual pure returns (int buffer);\\n\\n    /**\\n     * @notice Calculate debt ratio for a given eth to USM price: ratio of the outstanding USM (amount of USM in total supply),\\n     * to the current ETH pool value in USD (ETH qty * ETH/USD price).\\n     * @return ratio Debt ratio (or 0 if there's currently 0 ETH in the pool/price = 0: these should never happen after launch)\\n     */\\n    function debtRatio(uint ethUsdPrice, uint ethInPool, uint usmSupply) public virtual pure returns (uint ratio);\\n\\n    /**\\n     * @notice Convert ETH amount to USM using a ETH/USD price.\\n     * @param ethAmount The amount of ETH to convert\\n     * @return usmOut The amount of USM\\n     */\\n    function ethToUsm(uint ethUsdPrice, uint ethAmount, bool roundUp) public virtual pure returns (uint usmOut);\\n\\n    /**\\n     * @notice Convert USM amount to ETH using a ETH/USD price.\\n     * @param usmAmount The amount of USM to convert\\n     * @return ethOut The amount of ETH\\n     */\\n    function usmToEth(uint ethUsdPrice, uint usmAmount, bool roundUp) public virtual pure returns (uint ethOut);\\n\\n    /**\\n     * @return price The ETH/USD price, adjusted by the `bidAskAdjustment` (if applicable) for the given buy/sell side.\\n     */\\n    function adjustedEthUsdPrice(Side side, uint ethUsdPrice, uint adjustment) public virtual pure returns (uint price);\\n\\n    /**\\n     * @notice Calculate the *marginal* price of USM (in ETH terms): that is, of the next unit, before the price start sliding.\\n     * @return price USM price in ETH terms\\n     */\\n    function usmPrice(Side side, uint ethUsdPrice) public virtual pure returns (uint price);\\n\\n    /**\\n     * @notice Calculate the *marginal* price of FUM (in ETH terms): that is, of the next unit, before the price starts rising.\\n     * @param usmEffectiveSupply should be either the actual current USM supply, or, when calculating the FUM *buy* price, the\\n     * return value of `usmSupplyForFumBuys()`.\\n     * @return price FUM price in ETH terms\\n     */\\n    function fumPrice(Side side, uint ethUsdPrice, uint ethInPool, uint usmEffectiveSupply, uint fumSupply, bool prefund) public virtual pure returns (uint price);\\n\\n    /**\\n     * @return timeSystemWentUnderwater_ The time at which we first detected the system was underwater (debt ratio >\\n     * `MAX_DEBT_RATIO`), based on the current oracle price and pool ETH and USM; or 0 if we're not currently underwater.\\n     * @return usmSupplyForFumBuys The current supply of USM *for purposes of calculating the FUM buy price,* and therefore\\n     * for `fumFromFund()`.  The \\\"supply for FUM buys\\\" is the *lesser* of the actual current USM supply, and the USM amount\\n     * that would make debt ratio = `MAX_DEBT_RATIO`.  Example:\\n     *\\n     * 1. Suppose the system currently contains 50 ETH at price $1,000 (total pool value: $50,000), with an actual USM supply\\n     *    of 30,000 USM.  Then debt ratio = 30,000 / $50,000 = 60%: < MAX 80%, so `usmSupplyForFumBuys` = 30,000.\\n     * 2. Now suppose ETH/USD halves to $500.  Then pool value halves to $25,000, and debt ratio doubles to 120%.  Now\\n     *    `usmSupplyForFumBuys` instead = 20,000: the USM quantity at which debt ratio would equal 80% (20,000 / $25,000).\\n     *    (Call this the \\\"80% supply\\\".)\\n     * 3. ...Except, we also gradually increase the supply over time while we remain underwater.  This has the effect of\\n     *    *reducing* the FUM buy price inferred from that supply (higher JacobUSM supply -> smaller buffer -> lower FUM price).\\n     *    The math we use gradually increases the supply from its initial \\\"80% supply\\\" value, where debt ratio =\\n     *    `MAX_DEBT_RATIO` (20,000 above), to a theoretical maximum \\\"100% supply\\\" value, where debt ratio = 100% (in the $500\\n     *    example above, this would be 25,000).  (Or the actual supply, whichever is lower: we never increase\\n     *    `usmSupplyForFumBuys` above `usmActualSupply`.)  The climb from the initial 80% supply (20,000) to the 100% supply\\n     *    (25,000) is at a rate that brings it \\\"halfway closer per `MIN_FUM_BUY_PRICE_HALF_LIFE` (eg, 1 day)\\\": so three days\\n     *    after going underwater, the supply returned will be 25,000 - 0.5**3 * (25,000 - 20,000) = 24,375.\\n     */\\n    function checkIfUnderwater(uint usmActualSupply, uint ethPool_, uint ethUsdPrice, uint oldTimeUnderwater, uint currentTime) public virtual pure returns (uint timeSystemWentUnderwater_, uint usmSupplyForFumBuys, uint debtRatio_);\\n}\\n\"\r\n    },\r\n    \"contracts/OptOutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * A general type of contract with a behavior that using contracts can \\\"opt out of\\\".  The practical motivation is, when we have\\n * multiple versions of a token (eg, USMv1 and USMv2), and support \\\"mint/burn via send\\\" - sending ETH/tokens mints/burns tokens\\n * (respectively), there's a UX risk that users might accidentally send (eg) USMv1 tokens to the USMv2 address: resulting in\\n * not a burn (returning ETH), but just the tokens being permanently lost with no ETH sent back in exchange.\\n *\\n * To avoid this, we want the USMv1 contract to be able to \\\"opt out\\\" of receiving USMv2 tokens, and vice versa:\\n *\\n *     1. During creation of USMv2, the address of USMv1 is included in the `optedOut_` argument to the USMv2 constructor.\\n *     2. This puts USMv1 in USMv2's `optedOut` state variable.\\n *     3. Then, if someone accidentally tries to send USMv1 tokens to the USMv2 address, the `_transfer()` call fails, rather\\n *        than the USMv1 tokens being permanently lost.\\n *     4. And to handle the reverse case, USMv2's constructor can call `USMv1.optOut()`, so that sends of USMv2 tokens to the\\n *        USMv1 address also fail cleanly.  (USMv2 couldn't be passed to USMv1's constructor, because USMv2 didn't exist yet!)\\n *\\n * See also https://github.com/usmfum/USM/issues/88 and https://github.com/usmfum/USM/pull/93.\\n *\\n * Note that this would be prone to abuse if users could call `optOut()` on *other* contracts: so we only let a contract opt\\n * *itself* out, ie, `optOut()` takes no argument.  (Or it could be passed to the constructor of the `OptOutable`-implementing\\n * contract.)\\n */\\nabstract contract OptOutable {\\n    event OptOutStatusChanged(address indexed user, bool newStatus);\\n\\n    mapping(address => bool) public optedOut;  // true = address opted out of something\\n\\n    constructor(address[] memory optedOut_) {\\n        for (uint i = 0; i < optedOut_.length; i++) {\\n            optedOut[optedOut_[i]] = true;\\n        }\\n    }\\n\\n    modifier noOptOut(address target) {\\n        require(!optedOut[target], \\\"Target opted out\\\");\\n        _;\\n    }\\n\\n    function optOut() public virtual {\\n        if (!optedOut[msg.sender]) {\\n            optedOut[msg.sender] = true;\\n            emit OptOutStatusChanged(msg.sender, true);\\n        }\\n    }\\n\\n    function optBackIn() public virtual {\\n        if (optedOut[msg.sender]) {\\n            optedOut[msg.sender] = false;\\n            emit OptOutStatusChanged(msg.sender, false);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nabstract contract Oracle {\\n    /**\\n     * @return price WAD-scaled - 18 dec places\\n     * @return updateTime The last time the price was updated.  This is a bit subtle: `price` can change without `updateTime`\\n     * changing.  Suppose, eg, the current Uniswap v3 TWAP price over the last 10 minutes is $3,000, and then Uniswap records a\\n     * new trade observation at a price of $2,980.  This will nudge the 10-minute TWAP slightly below $3,000, and reset\\n     * `updateTime` to the new trade's time.  However, over the subsequent 10 minutes, the 10-minute TWAP will continue to\\n     * decrease, as more and more of \\\"the last 10 minutes\\\" is at $2,980 rather than $3,000: but because this gradual price\\n     * change is only driven by the passage of time, not by any new price observations, it will *not* change `updateTime`,\\n     * which will remain at the time of the $2,980 trade until another trade occurs.\\n     */\\n    function latestPrice() public virtual view returns (uint price, uint updateTime);\\n}\\n\"\r\n    },\r\n    \"contracts/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Delegable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n\\n/// @dev Delegable enables users to delegate their account management to other users.\\n/// Delegable implements addDelegateBySignature, to add delegates using a signature instead of a separate transaction.\\ncontract Delegable {\\n    event Delegate(address indexed user, address indexed delegate, bool enabled);\\n\\n    bytes32 public constant SIGNATURE_TYPEHASH = keccak256(\\\"Signature(address user,address delegate,uint256 nonce,uint256 deadline)\\\"); // 0x0d077601844dd17f704bafff948229d27f33b57445915754dfe3d095fda2beb7;\\n    bytes32 public immutable DELEGABLE_DOMAIN;\\n    mapping(address => uint) public signatureCount;\\n\\n    mapping(address => mapping(address => bool)) public delegated;\\n\\n    constructor () {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        DELEGABLE_DOMAIN = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes('USMFUM')),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Require that msg.sender is the account holder or a delegate\\n    modifier onlyHolderOrDelegate(address holder, string memory errorMessage) {\\n        require(\\n            msg.sender == holder || delegated[holder][msg.sender],\\n            errorMessage\\n        );\\n        _;\\n    }\\n\\n    /// @dev Enable a delegate to act on the behalf of caller\\n    function addDelegate(address delegate) public {\\n        _addDelegate(msg.sender, delegate);\\n    }\\n\\n    /// @dev Stop a delegate from acting on the behalf of caller\\n    function revokeDelegate(address delegate) public {\\n        _revokeDelegate(msg.sender, delegate);\\n    }\\n\\n    /// @dev Allow a delegate to renounce to its delegation\\n    function renounceDelegate(address user) public {\\n        _revokeDelegate(user, msg.sender);\\n    }\\n\\n    /// @dev Add a delegate through an encoded signature\\n    function addDelegateBySignature(address user, address delegate, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\\n        require(deadline >= block.timestamp, 'Delegable: Signature expired');\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                SIGNATURE_TYPEHASH,\\n                user,\\n                delegate,\\n                signatureCount[user]++,\\n                deadline\\n            )\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DELEGABLE_DOMAIN,\\n                hashStruct\\n            )\\n        );\\n        address signer = ecrecover(digest, v, r, s);\\n        require(\\n            signer != address(0) && signer == user,\\n            'Delegable: Invalid signature'\\n        );\\n\\n        _addDelegate(user, delegate);\\n    }\\n\\n    /// @dev Enable a delegate to act on the behalf of an user\\n    function _addDelegate(address user, address delegate) internal {\\n        if (!delegated[user][delegate]) {\\n            delegated[user][delegate] = true;\\n            emit Delegate(user, delegate, true);\\n        }\\n    }\\n\\n    /// @dev Stop a delegate from acting on the behalf of an user\\n    function _revokeDelegate(address user, address delegate) internal {\\n        if (delegated[user][delegate]) {\\n            delegated[user][delegate] = false;\\n            emit Delegate(user, delegate, false);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WadMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @title Fixed point arithmetic library\\n * @author Alberto Cuesta CaÃ±ada, Jacob Eliosoff, Alex Roan\\n */\\nlibrary WadMath {\\n    uint public constant WAD = 1e18;\\n    uint public constant WAD_MINUS_1 = WAD - 1;\\n    uint public constant HALF_WAD = WAD / 2;\\n    uint public constant FLOOR_LOG_2_WAD_SCALED = 158961593653514369813532673448321674075;  // log2(1e18) * 2**121\\n    uint public constant  CEIL_LOG_2_WAD_SCALED = 158961593653514369813532673448321674076;  // log2(1e18) * 2**121\\n    uint public constant FLOOR_LOG_2_E_SCALED_OVER_WAD = 3835341275459348169;               // log2(e) * 2**121 / 1e18\\n    uint public constant  CEIL_LOG_2_E_SCALED_OVER_WAD = 3835341275459348170;               // log2(e) * 2**121 / 1e18\\n\\n    function wadMul(uint x, uint y, bool roundUp) internal pure returns (uint z) {\\n        z = (roundUp ? wadMulUp(x, y) : wadMulDown(x, y));\\n    }\\n\\n    function wadMulDown(uint x, uint y) internal pure returns (uint z) {\\n        z = x * y;                  // Rounds down, truncating the last 18 digits.  So (imagining 2 dec places rather than 18):\\n        unchecked { z /= WAD; }     // 369 (3.69) * 271 (2.71) -> 99999 (9.9999) -> 999 (9.99).\\n    }\\n\\n    function wadMulUp(uint x, uint y) internal pure returns (uint z) {\\n        z = x * y + WAD_MINUS_1;    // Rounds up.  So (again imagining 2 decimal places):\\n        unchecked { z /= WAD; }     // 383 (3.83) * 235 (2.35) -> 90005 (9.0005), + 99 (0.0099) -> 90104, / 100 -> 901 (9.01).\\n    }\\n\\n    function wadSquaredDown(uint x) internal pure returns (uint z) {\\n        z = x * x;\\n        unchecked { z /= WAD; }\\n    }\\n\\n    function wadSquaredUp(uint x) internal pure returns (uint z) {\\n        z = (x * x) + WAD_MINUS_1;\\n        unchecked { z /= WAD; }\\n    }\\n\\n    function wadDiv(uint x, uint y, bool roundUp) internal pure returns (uint z) {\\n        z = (roundUp ? wadDivUp(x, y) : wadDivDown(x, y));\\n    }\\n\\n    function wadDivDown(uint x, uint y) internal pure returns (uint z) {\\n        z = (x * WAD) / y;          // Rounds down: 199 (1.99) / 1000 (10) -> (199 * 100) / 1000 -> 19 (0.19: 0.199 truncated).\\n    }\\n\\n    function wadDivUp(uint x, uint y) internal pure returns (uint z) {\\n        z = x * WAD + y;            // 101 (1.01) / 1000 (10) -> (101 * 100 + 1000 - 1) / 1000 -> 11 (0.11 = 0.101 rounded up).\\n        unchecked { z -= 1; }       // Can do unchecked subtraction since division in next line will catch y = 0 case anyway\\n        z /= y;\\n    }\\n\\n    /**\\n     * @return z The appropriately rounded result of w * x / y, with all three inputs and the result represented in WAD format.\\n     * This function is based on the following simplification - why divide and then multiply by WAD?\\n     *\\n     *        w.wadMul(x).wadDiv(y)\\n     *     =~ (w * x / WAD) * WAD / y\\n     *     =~ w * x / y\\n     *\\n     */\\n    function wadMulDivDown(uint w, uint x, uint y) internal pure returns (uint z) {\\n        z = w * x / y;\\n    }\\n\\n    function wadMulDivUp(uint w, uint x, uint y) internal pure returns (uint z) {\\n        z = w * x + y;              // See wadDivUp() above\\n        unchecked { z -= 1; }\\n        z /= y;\\n    }\\n\\n    function wadMax(uint x, uint y) internal pure returns (uint z) {\\n        z = (x > y ? x : y);\\n    }\\n\\n    function wadMin(uint x, uint y) internal pure returns (uint z) {\\n        z = (x < y ? x : y);\\n    }\\n\\n    /**\\n     * @notice Adapted from rpow() in https://github.com/dapphub/ds-math/blob/master/src/math.sol - thank you!\\n     *\\n     * This famous algorithm is called \\\"exponentiation by squaring\\\" and calculates x^n with x as fixed-point and n as regular\\n     * unsigned.\\n     *\\n     * It's O(log n), instead of O(n) for naive repeated multiplication.\\n     *\\n     * These facts are why it works:\\n     *\\n     * 1. If n is even, then x^n = (x^2)^(n/2).\\n     * 2. If n is odd, then x^n = x * x^(n-1), and substituting the equation for even n gives x^n = x * (x^2)^((n-1)/2).\\n     * 3. Since EVM division is flooring, n /= 2 will give us the recursive exponent we want in both cases: n/2 for even n, and\\n     *    (n-1)/2 for odd n.\\n     *\\n     * @param x base to raise to power n (x is WAD-scaled)\\n     * @param n power to raise x to (n is *not* WAD-scaled - ie, passing n = 3 calculates x cubed)\\n     * @return z x**n, WAD-scaled: so, since x and z are WAD-scaled and n isn't, z = (x / 1e18)**n * 1e18\\n     */\\n    function wadPowInt(uint x, uint n) internal pure returns (uint z) {\\n        unchecked { z = n % 2 != 0 ? x : WAD; }\\n\\n        unchecked { n /= 2; }\\n        bool nIsOdd;\\n        while (n != 0) {\\n            x = wadMulDown(x, x);\\n\\n            unchecked { nIsOdd = n % 2 != 0; }\\n            if (nIsOdd) {\\n                z = wadMulDown(z, x);\\n            }\\n            unchecked { n /= 2; }\\n        }\\n    }\\n\\n    function wadSqrtDown(uint y) internal pure returns (uint root) {\\n        root = wadPowDown(y, HALF_WAD);\\n    }\\n\\n    function wadSqrtUp(uint y) internal pure returns (uint root) {\\n        root = wadPowUp(y, HALF_WAD);\\n    }\\n\\n    /**\\n     * @return z e raised to the given power `y` (approximately!), specified in WAD 18-digit fixed-point form, and in, again,\\n     * WAD form.\\n     * @notice This library works only on positive uint inputs.  If you have a negative exponent (y < 0), you can calculate it\\n     * using this identity:\\n     *\\n     *     wadExpDown(y < 0) = 1 / wadExp(-y > 0) = WAD.div(wadExp(-y > 0))\\n     *\\n     * @dev We're given Y = y * 1e18 (WAD-formatted); we want to return Z = z * 1e18, where z =~ e**y; and we have\\n     * `pow_2(X = x * 2**121)` below, which returns y =~ 2**x = 2**(X / 2**121).  So the math we use is:\\n     *\\n     *     K1 = log2(1e18) * 2**121\\n     *     K2 = log2(e) * 2**121 / 1e18\\n     *     Z = `pow_2(K1 + K2 * Y)`\\n     *       = 2**((K1 + K2 * Y) / 2**121)\\n     *       = 2**((log2(1e18) * 2**121 + (log2(e) * 2**121 / 1e18) * (y * 1e18)) / 2**121)\\n     *       = 2**(log2(1e18) + log2(e) * y)\\n     *       = 2**(log2(1e18)) * 2**(log2(e) * y)\\n     *       = 1e18 * (2**log2(e))**y\\n     *       = e**y * 1e18\\n     */\\n    function wadExpDown(uint y) internal pure returns (uint z) {\\n        uint exponent = FLOOR_LOG_2_WAD_SCALED + FLOOR_LOG_2_E_SCALED_OVER_WAD * y;\\n        require(exponent <= type(uint128).max, \\\"exponent overflow\\\");\\n        z = pow_2(uint128(exponent));\\n    }\\n\\n    function wadExpUp(uint y) internal pure returns (uint z) {\\n        uint exponent = FLOOR_LOG_2_WAD_SCALED - CEIL_LOG_2_E_SCALED_OVER_WAD * y;\\n        require(exponent <= type(uint128).max, \\\"exponent overflow\\\");\\n        uint wadOneOverExpY = pow_2(uint128(exponent));\\n        z = wadDivUp(WAD, wadOneOverExpY);\\n    }\\n\\n    /**\\n     * @return z The given number `x` raised to power `y` (approximately!), with all of `x`, `y` and `z` in WAD 18-digit\\n     * fixed-point form.\\n     * @notice This library works only on positive uint inputs.  If you have a negative base (x < 0) or a negative exponent\\n     * (y < 0), you can calculate them using these identities:\\n     *\\n     *     wadPowDown(x < 0, y) = -wadPowDown(-x > 0, y)\\n     *     wadPowDown(x, y < 0) = 1 / wadPowUp(x, -y > 0) = WAD.div(wadPowUp(x, -y > 0))\\n     *\\n     * @dev We're given X = x * 1e18, and Y = y * 1e18 (both WAD-formatted); we want Z = z * 1e18, where z =~ x**y; and\\n     * we have `log_2(x)`, which returns log2(x) * 2**121, and `pow_2(X = x * 2**121)`, which returns 2**x = 2**(X / 2**121).\\n     * The math we use is:\\n     *\\n     *     K = log2(1e18) * 2**121\\n     *     Z = `pow_2(K + (log_2(X) - K) * Y / 1e18)`\\n     *       = 2**((K + (log2(X) * 2**121 - K) * Y / 1e18) / 2**121)\\n     *       = 2**((log2(1e18) * 2**121 + (log2(x * 1e18) * 2**121 - log2(1e18) * 2**121) * (y * 1e18) / 1e18) / 2**121)\\n     *       = 2**(log2(1e18) + (log2(x * 1e18) - log2(1e18)) * y)\\n     *       = 2**(log2(1e18) + log2(x) * y)\\n     *       = 2**(log2(1e18)) * 2**(log2(x) * y)\\n     *       = 1e18 * (2**log2(x))**y\\n     *       = x**y * 1e18\\n     *\\n     */\\n    function wadPowDown(uint x, uint y) internal pure returns (uint z) {\\n        require(x <= type(uint128).max, \\\"x overflow\\\");\\n        require(y <= uint(type(int).max), \\\"y overflow\\\");\\n        // The logic here is: Z = pow_2(FLOOR_LOG_2_WAD_SCALED + (log_2(X) - CEIL_LOG_2_WAD_SCALED) * Y / WAD)\\n        int exponent = int(uint(log_2(uint128(x))));\\n        unchecked { exponent -= int(CEIL_LOG_2_WAD_SCALED); }   // No chance of overflow here, both operands too small\\n        exponent *= int(y);\\n        unchecked { exponent = exponent / int(WAD) + int(FLOOR_LOG_2_WAD_SCALED); } // Can't overflow (would have in prev line)\\n        require(exponent >= 0, \\\"exponent underflow\\\");\\n        require(uint(exponent) <= type(uint128).max, \\\"exponent overflow\\\");\\n        z = pow_2(uint128(uint(exponent)));     // Apparently Solidity won't let us do this cast in one shot.  Weird eh?\\n     }\\n\\n    function wadPowUp(uint x, uint y) internal pure returns (uint z) {\\n        z = wadDivUp(WAD, wadPowDown(wadDivDown(WAD, x), y));\\n    }\\n\\n    /* ____________________ Exponential/logarithm fns borrowed from Yield Protocol ____________________\\n     *\\n     * See https://github.com/yieldprotocol/yieldspace-v1/blob/master/contracts/YieldMath.sol for Yield's code, originally\\n     * developed by the math gurus at https://www.abdk.consulting/.\\n     */\\n\\n    /**\\n     * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert in case x is zero.\\n     *\\n     * @param x number to calculate base 2 logarithm of\\n     * @return z base 2 logarithm of x, multiplied by 2^121\\n     */\\n    function log_2(uint128 x)\\n        internal pure returns (uint128 z)\\n    {\\n        unchecked {\\n            require (x != 0, \\\"x = 0\\\");\\n\\n            uint b = x;\\n\\n            uint l = 0xFE000000000000000000000000000000;\\n\\n            if (b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\\n            if (b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}\\n            if (b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}\\n            if (b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}\\n            if (b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}\\n            if (b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}\\n            if (b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}\\n\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {/*b >>= 1;*/ l |= 0x10000000000000000;}\\n            /* Precision reduced to 64 bits\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) l |= 0x1;\\n            */\\n\\n            z = uint128(l);\\n        }\\n    }\\n\\n    /**\\n     * Calculate 2 raised into given power.\\n     *\\n     * @param x power to raise 2 into, multiplied by 2^121\\n     * @return z 2 raised into given power\\n     */\\n    function pow_2(uint128 x)\\n        internal pure returns (uint128 z)\\n    {\\n        unchecked {\\n            uint r = 0x80000000000000000000000000000000;\\n            if (x & 0x1000000000000000000000000000000 > 0) r = r * 0xb504f333f9de6484597d89b3754abe9f >> 127;\\n            if (x & 0x800000000000000000000000000000 > 0) r = r * 0x9837f0518db8a96f46ad23182e42f6f6 >> 127;\\n            if (x & 0x400000000000000000000000000000 > 0) r = r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90 >> 127;\\n            if (x & 0x200000000000000000000000000000 > 0) r = r * 0x85aac367cc487b14c5c95b8c2154c1b2 >> 127;\\n            if (x & 0x100000000000000000000000000000 > 0) r = r * 0x82cd8698ac2ba1d73e2a475b46520bff >> 127;\\n            if (x & 0x80000000000000000000000000000 > 0) r = r * 0x8164d1f3bc0307737be56527bd14def4 >> 127;\\n            if (x & 0x40000000000000000000000000000 > 0) r = r * 0x80b1ed4fd999ab6c25335719b6e6fd20 >> 127;\\n            if (x & 0x20000000000000000000000000000 > 0) r = r * 0x8058d7d2d5e5f6b094d589f608ee4aa2 >> 127;\\n            if (x & 0x10000000000000000000000000000 > 0) r = r * 0x802c6436d0e04f50ff8ce94a6797b3ce >> 127;\\n            if (x & 0x8000000000000000000000000000 > 0) r = r * 0x8016302f174676283690dfe44d11d008 >> 127;\\n            if (x & 0x4000000000000000000000000000 > 0) r = r * 0x800b179c82028fd0945e54e2ae18f2f0 >> 127;\\n            if (x & 0x2000000000000000000000000000 > 0) r = r * 0x80058baf7fee3b5d1c718b38e549cb93 >> 127;\\n            if (x & 0x1000000000000000000000000000 > 0) r = r * 0x8002c5d00fdcfcb6b6566a58c048be1f >> 127;\\n            if (x & 0x800000000000000000000000000 > 0) r = r * 0x800162e61bed4a48e84c2e1a463473d9 >> 127;\\n            if (x & 0x400000000000000000000000000 > 0) r = r * 0x8000b17292f702a3aa22beacca949013 >> 127;\\n            if (x & 0x200000000000000000000000000 > 0) r = r * 0x800058b92abbae02030c5fa5256f41fe >> 127;\\n            if (x & 0x100000000000000000000000000 > 0) r = r * 0x80002c5c8dade4d71776c0f4dbea67d6 >> 127;\\n            if (x & 0x80000000000000000000000000 > 0) r = r * 0x8000162e44eaf636526be456600bdbe4 >> 127;\\n            if (x & 0x40000000000000000000000000 > 0) r = r * 0x80000b1721fa7c188307016c1cd4e8b6 >> 127;\\n            if (x & 0x20000000000000000000000000 > 0) r = r * 0x8000058b90de7e4cecfc487503488bb1 >> 127;\\n            if (x & 0x10000000000000000000000000 > 0) r = r * 0x800002c5c8678f36cbfce50a6de60b14 >> 127;\\n            if (x & 0x8000000000000000000000000 > 0) r = r * 0x80000162e431db9f80b2347b5d62e516 >> 127;\\n            if (x & 0x4000000000000000000000000 > 0) r = r * 0x800000b1721872d0c7b08cf1e0114152 >> 127;\\n            if (x & 0x2000000000000000000000000 > 0) r = r * 0x80000058b90c1aa8a5c3736cb77e8dff >> 127;\\n            if (x & 0x1000000000000000000000000 > 0) r = r * 0x8000002c5c8605a4635f2efc2362d978 >> 127;\\n            if (x & 0x800000000000000000000000 > 0) r = r * 0x800000162e4300e635cf4a109e3939bd >> 127;\\n            if (x & 0x400000000000000000000000 > 0) r = r * 0x8000000b17217ff81bef9c551590cf83 >> 127;\\n            if (x & 0x200000000000000000000000 > 0) r = r * 0x800000058b90bfdd4e39cd52c0cfa27c >> 127;\\n            if (x & 0x100000000000000000000000 > 0) r = r * 0x80000002c5c85fe6f72d669e0e76e411 >> 127;\\n            if (x & 0x80000000000000000000000 > 0) r = r * 0x8000000162e42ff18f9ad35186d0df28 >> 127;\\n            if (x & 0x40000000000000000000000 > 0) r = r * 0x80000000b17217f84cce71aa0dcfffe7 >> 127;\\n            if (x & 0x20000000000000000000000 > 0) r = r * 0x8000000058b90bfc07a77ad56ed22aaa >> 127;\\n            if (x & 0x10000000000000000000000 > 0) r = r * 0x800000002c5c85fdfc23cdead40da8d6 >> 127;\\n            if (x & 0x8000000000000000000000 > 0) r = r * 0x80000000162e42fefc25eb1571853a66 >> 127;\\n            if (x & 0x4000000000000000000000 > 0) r = r * 0x800000000b17217f7d97f692baacded5 >> 127;\\n            if (x & 0x2000000000000000000000 > 0) r = r * 0x80000000058b90bfbead3b8b5dd254d7 >> 127;\\n            if (x & 0x1000000000000000000000 > 0) r = r * 0x8000000002c5c85fdf4eedd62f084e67 >> 127;\\n            if (x & 0x800000000000000000000 > 0) r = r * 0x800000000162e42fefa58aef378bf586 >> 127;\\n            if (x & 0x400000000000000000000 > 0) r = r * 0x8000000000b17217f7d24a78a3c7ef02 >> 127;\\n            if (x & 0x200000000000000000000 > 0) r = r * 0x800000000058b90bfbe9067c93e474a6 >> 127;\\n            if (x & 0x100000000000000000000 > 0) r = r * 0x80000000002c5c85fdf47b8e5a72599f >> 127;\\n            if (x & 0x80000000000000000000 > 0) r = r * 0x8000000000162e42fefa3bdb315934a2 >> 127;\\n            if (x & 0x40000000000000000000 > 0) r = r * 0x80000000000b17217f7d1d7299b49c46 >> 127;\\n            if (x & 0x20000000000000000000 > 0) r = r * 0x8000000000058b90bfbe8e9a8d1c4ea0 >> 127;\\n            if (x & 0x10000000000000000000 > 0) r = r * 0x800000000002c5c85fdf4745969ea76f >> 127;\\n            if (x & 0x8000000000000000000 > 0) r = r * 0x80000000000162e42fefa3a0df5373bf >> 127;\\n            if (x & 0x4000000000000000000 > 0) r = r * 0x800000000000b17217f7d1cff4aac1e1 >> 127;\\n            if (x & 0x2000000000000000000 > 0) r = r * 0x80000000000058b90bfbe8e7db95a2f1 >> 127;\\n            if (x & 0x1000000000000000000 > 0) r = r * 0x8000000000002c5c85fdf473e61ae1f8 >> 127;\\n            if (x & 0x800000000000000000 > 0) r = r * 0x800000000000162e42fefa39f121751c >> 127;\\n            if (x & 0x400000000000000000 > 0) r = r * 0x8000000000000b17217f7d1cf815bb96 >> 127;\\n            if (x & 0x200000000000000000 > 0) r = r * 0x800000000000058b90bfbe8e7bec1e0d >> 127;\\n            if (x & 0x100000000000000000 > 0) r = r * 0x80000000000002c5c85fdf473dee5f17 >> 127;\\n            if (x & 0x80000000000000000 > 0) r = r * 0x8000000000000162e42fefa39ef5438f >> 127;\\n            if (x & 0x40000000000000000 > 0) r = r * 0x80000000000000b17217f7d1cf7a26c8 >> 127;\\n            if (x & 0x20000000000000000 > 0) r = r * 0x8000000000000058b90bfbe8e7bcf4a4 >> 127;\\n            if (x & 0x10000000000000000 > 0) r = r * 0x800000000000002c5c85fdf473de72a2 >> 127;\\n            /* Precision reduced to 64 bits\\n            if (x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;\\n            if (x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;\\n            if (x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;\\n            if (x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;\\n            if (x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;\\n            if (x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;\\n            if (x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;\\n            if (x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;\\n            if (x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;\\n            if (x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;\\n            if (x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;\\n            if (x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;\\n            if (x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;\\n            if (x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;\\n            if (x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;\\n            if (x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;\\n            if (x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;\\n            if (x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;\\n            if (x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;\\n            if (x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;\\n            if (x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;\\n            if (x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;\\n            if (x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;\\n            if (x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;\\n            if (x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;\\n            if (x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;\\n            if (x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;\\n            if (x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;\\n            if (x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;\\n            if (x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;\\n            if (x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;\\n            if (x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;\\n            if (x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;\\n            if (x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;\\n            if (x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;\\n            if (x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;\\n            if (x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;\\n            if (x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;\\n            if (x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;\\n            if (x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;\\n            if (x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;\\n            if (x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;\\n            if (x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;\\n            if (x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;\\n            if (x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;\\n            if (x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;\\n            if (x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;\\n            if (x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;\\n            if (x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;\\n            if (x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;\\n            if (x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;\\n            if (x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;\\n            if (x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;\\n            if (x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;\\n            if (x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;\\n            if (x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;\\n            if (x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;\\n            if (x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;\\n            if (x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;\\n            if (x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;\\n            if (x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;\\n            if (x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;\\n            if (x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;\\n            if (x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127;\\n            */\\n\\n            r >>= 127 - (x >> 121);\\n\\n            z = uint128(r);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/FUM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"erc20permit/contracts/ERC20Permit.sol\\\";\\nimport \\\"./IUSM.sol\\\";\\nimport \\\"./OptOutable.sol\\\";\\nimport \\\"./MinOut.sol\\\";\\n\\n\\n/**\\n * @title FUM Token\\n * @author Alberto Cuesta CaÃ±ada, Jacob Eliosoff, Alex Roan\\n *\\n * @notice This should be created and owned by the USM instance.\\n */\\ncontract FUM is ERC20Permit, OptOutable {\\n    IUSM public immutable usm;\\n\\n    constructor(address[] memory optedOut_)\\n        ERC20Permit(\\\"Minimalist Funding v1.0 - Test 5\\\", \\\"FUMTest\\\")\\n        OptOutable(optedOut_)\\n    {\\n        usm = IUSM(msg.sender);     // FUM constructor can only be called by a USM instance\\n    }\\n\\n    /**\\n     * @notice If anyone sends ETH here, assume they intend it as a `fund`.  If decimals 8 to 11 (inclusive) of the amount of\\n     * ETH received are `0000`, then the next 7 will be parsed as the minimum number of FUM accepted per input ETH, with the\\n     * 7-digit number interpreted as \\\"hundredths of a FUM\\\".  See comments in `MinOut`.\\n     */\\n    receive() external payable {\\n        usm.fund{ value: msg.value }(msg.sender, MinOut.parseMinTokenOut(msg.value));\\n    }\\n\\n    /**\\n     * @notice If a user sends FUM tokens directly to this contract (or to the USM contract), assume they intend it as a\\n     * `defund`.  If using `transfer`/`transferFrom` as `defund`, and if decimals 8 to 11 (inclusive) of the amount transferred\\n     * are `0000`, then the next 7 will be parsed as the maximum number of FUM tokens sent per ETH received, with the 7-digit\\n     * number interpreted as \\\"hundredths of a FUM\\\".  See comments in `MinOut`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal override noOptOut(recipient) returns (bool) {\\n        if (recipient == address(this) || recipient == address(usm) || recipient == address(0)) {\\n            usm.defund(sender, payable(sender), amount, MinOut.parseMinEthOut(amount));\\n        } else {\\n            super._transfer(sender, recipient, amount);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Mint new FUM to the _recipient\\n     *\\n     * @param _recipient address to mint to\\n     * @param _amount amount to mint\\n     */\\n    function mint(address _recipient, uint _amount) external {\\n        require(msg.sender == address(usm), \\\"Only USM\\\");\\n        _mint(_recipient, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn FUM from _holder\\n     *\\n     * @param _holder address to burn from\\n     * @param _amount amount to burn\\n     */\\n    function burn(address _holder, uint _amount) external {\\n        require(msg.sender == address(usm), \\\"Only USM\\\");\\n        _burn(_holder, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MinOut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary MinOut {\\n    uint public constant ZEROES_PLUS_LIMIT_PRICE_DIGITS = 1e11; // 4 digits all 0s, + 7 digits to specify the limit price\\n    uint public constant LIMIT_PRICE_DIGITS = 1e7;              // 7 digits to specify the limit price (unscaled)\\n    uint public constant LIMIT_PRICE_SCALING_FACTOR = 100;      // So, last 7 digits \\\"1234567\\\" / 100 = limit price 12345.67\\n\\n    function parseMinTokenOut(uint ethIn) internal pure returns (uint minTokenOut) {\\n        uint minPrice = ethIn % ZEROES_PLUS_LIMIT_PRICE_DIGITS;\\n        if (minPrice != 0 && minPrice < LIMIT_PRICE_DIGITS) {\\n            minTokenOut = ethIn * minPrice / LIMIT_PRICE_SCALING_FACTOR;\\n        }\\n    }\\n\\n    function parseMinEthOut(uint tokenIn) internal pure returns (uint minEthOut) {\\n        uint maxPrice = tokenIn % ZEROES_PLUS_LIMIT_PRICE_DIGITS;\\n        if (maxPrice != 0 && maxPrice < LIMIT_PRICE_DIGITS) {\\n            minEthOut = tokenIn * LIMIT_PRICE_SCALING_FACTOR / maxPrice;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"acc-erc20/contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Inspired on token.sol from DappHub\\n\\npragma solidity  ^0.8.0;\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract ERC20 is IERC20 {\\n    uint256                                           internal  _totalSupply;\\n    mapping (address => uint256)                      internal  _balanceOf;\\n    mapping (address => mapping (address => uint256)) internal  _allowance;\\n    string                                            public    symbol;\\n    uint256                                           public    decimals = 18; // standard token precision. override to customize\\n    string                                            public    name = \\\"\\\";     // Optional token name\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        name = name_;\\n        symbol = symbol_;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address guy) public view virtual override returns (uint256) {\\n        return _balanceOf[guy];\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    function approve(address spender, uint wad) public virtual override returns (bool) {\\n        return _approve(msg.sender, spender, wad);\\n    }\\n\\n    function transfer(address dst, uint wad) public virtual override returns (bool) {\\n        return _transfer(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad) public virtual override returns (bool) {\\n        uint256 allowed = _allowance[src][msg.sender];\\n        if (src != msg.sender && allowed != type(uint).max) {\\n            require(allowed >= wad, \\\"ERC20: Insufficient approval\\\");\\n            _approve(src, msg.sender, allowed - wad);\\n        }\\n\\n        return _transfer(src, dst, wad);\\n    }\\n\\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\\n        require(_balanceOf[src] >= wad, \\\"ERC20: Insufficient balance\\\");\\n        _balanceOf[src] = _balanceOf[src] - wad;\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint wad) internal virtual returns (bool) {\\n        _allowance[owner][spender] = wad;\\n        emit Approval(owner, spender, wad);\\n        return true;\\n    }\\n\\n    function _mint(address dst, uint wad) internal virtual {\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n        _totalSupply = _totalSupply + wad;\\n        emit Transfer(address(0), dst, wad);\\n    }\\n\\n    function _burn(address src, uint wad) internal virtual {\\n        require(_balanceOf[src] >= wad, \\\"ERC20: Insufficient balance\\\");\\n        _balanceOf[src] = _balanceOf[src] - wad;\\n        _totalSupply = _totalSupply - wad;\\n        emit Transfer(src, address(0), wad);\\n    }\\n}\"\r\n    },\r\n    \"erc20permit/contracts/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"acc-erc20/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Oracle\",\"name\":\"oracle_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"optedOut_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"name\":\"BidAskAdjustmentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"OptOutStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"underwater\",\"type\":\"bool\"}],\"name\":\"UnderwaterStatusChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BID_ASK_ADJUSTMENT_DECAY_PER_SECOND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BID_ASK_ADJUSTMENT_ZERO_OUT_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BILLION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DELEGABLE_DOMAIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_END_TIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FOUR_WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HALF_BILLION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DEBT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FUM_BUY_PRICE_DECAY_PER_SECOND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PREFUND_END_TIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PREFUND_FUM_PRICE_IN_ETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGNATURE_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"addDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"addDelegateBySignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IUSM.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"name\":\"adjustedEthUsdPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"storedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"storedAdjustment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"name\":\"bidAskAdjustment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidAskAdjustment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usmToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEthOut\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timeSystemWentUnderwater\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustmentTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmTotalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct USM.LoadedState\",\"name\":\"ls\",\"type\":\"tuple\"}],\"name\":\"checkForFreshOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usmActualSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldTimeUnderwater\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"name\":\"checkIfUnderwater\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeSystemWentUnderwater_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmSupplyForFumBuys\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethInPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmSupply\",\"type\":\"uint256\"}],\"name\":\"debtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fumToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEthOut\",\"type\":\"uint256\"}],\"name\":\"defund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethInPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"roundUp\",\"type\":\"bool\"}],\"name\":\"ethBuffer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"buffer\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timeSystemWentUnderwater\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustmentTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmTotalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct USM.LoadedState\",\"name\":\"ls\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"usmIn\",\"type\":\"uint256\"}],\"name\":\"ethFromBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjGrowthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timeSystemWentUnderwater\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustmentTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmTotalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct USM.LoadedState\",\"name\":\"ls\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"fumSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fumIn\",\"type\":\"uint256\"}],\"name\":\"ethFromDefund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjShrinkFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"roundUp\",\"type\":\"bool\"}],\"name\":\"ethToUsm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usmOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fum\",\"outputs\":[{\"internalType\":\"contract FUM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timeSystemWentUnderwater\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustmentTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmTotalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct USM.LoadedState\",\"name\":\"ls\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"fumSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"prefund\",\"type\":\"bool\"}],\"name\":\"fumFromFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fumOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjGrowthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IUSM.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethInPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmEffectiveSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fumSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"prefund\",\"type\":\"bool\"}],\"name\":\"fumPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fumTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFumOut\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fumOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDuringPrefund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"duringPrefund\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timeSystemWentUnderwater\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustmentTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmTotalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct USM.LoadedState\",\"name\":\"ls\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minUsmOut\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usmOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optBackIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"optedOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract Oracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"renounceDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signatureCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storedState\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timeSystemWentUnderwater\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ethUsdPriceTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint80\",\"name\":\"ethUsdPrice\",\"type\":\"uint80\"},{\"internalType\":\"uint32\",\"name\":\"bidAskAdjustmentTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint80\",\"name\":\"bidAskAdjustment\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSystemWentUnderwater\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timeSystemWentUnderwater\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustmentTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAskAdjustment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmTotalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct USM.LoadedState\",\"name\":\"ls\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"ethIn\",\"type\":\"uint256\"}],\"name\":\"usmFromMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usmOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjShrinkFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IUSM.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"}],\"name\":\"usmPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usmAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"roundUp\",\"type\":\"bool\"}],\"name\":\"usmToEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"USM","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000e0924c0ab6bf613d0472093606074ba8243ba56a0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000003eb7ce2907e202bb70bae3d7b0c588573d3cecc000000000000000000000000f04a5d82ff8a801f7d45e9c14cdcf73deff1a394","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}