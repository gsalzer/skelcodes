{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DAO.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/*\\nThis contract implements a DAO, it's been loosely based on Compound's\\nGovernorAlpha. It supports multiple options per proposal and multiple actions\\nper option. It leverages the `Voters` contract for snapshots of voting power.\\nIt supports gasless voting with voteBySig / EIP-712.\\n*/\\n\\nimport './interfaces/IVoters.sol';\\n\\ncontract DAO {\\n    struct Proposal {\\n        uint id;\\n        address proposer;\\n        string title;\\n        string description;\\n        string[] optionsNames;\\n        bytes[][] optionsActions;\\n        uint[] optionsVotes;\\n        uint startAt;\\n        uint endAt;\\n        uint executableAt;\\n        uint executedAt;\\n        uint snapshotId;\\n        uint votersSupply;\\n        bool cancelled;\\n    }\\n\\n    event Proposed(uint indexed proposalId);\\n    event Voted(uint indexed proposalId, address indexed voter, uint optionId);\\n    event Executed(address indexed to, uint value, bytes data);\\n    event ExecutedProposal(uint indexed proposalId, uint optionId, address executer);\\n\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,uint optionId)\\\");\\n    uint public minBalanceToPropose;\\n    uint public minPercentQuorum;\\n    uint public minVotingTime;\\n    uint public minExecutionDelay;\\n    IVoters public voters;\\n    uint public proposalsCount;\\n    mapping(uint => Proposal) private proposals;\\n    mapping(uint => mapping(address => uint)) public proposalVotes;\\n    mapping (address => uint) private latestProposalIds;\\n\\n    constructor(\\n      address _voters,\\n      uint _minBalanceToPropose,\\n      uint _minPercentQuorum,\\n      uint _minVotingTime,\\n      uint _minExecutionDelay\\n    ) {\\n        voters = IVoters(_voters);\\n        minBalanceToPropose = _minBalanceToPropose;\\n        minPercentQuorum = _minPercentQuorum;\\n        minVotingTime = _minVotingTime;\\n        minExecutionDelay = _minExecutionDelay;\\n    }\\n\\n    function proposal(uint index) public view returns (uint, address, string memory, uint, uint, uint, uint, bool) {\\n        Proposal storage p = proposals[index];\\n        return (\\n          p.id,\\n          p.proposer,\\n          p.title,\\n          p.startAt,\\n          p.endAt,\\n          p.executableAt,\\n          p.executedAt,\\n          p.cancelled\\n        );\\n    }\\n\\n    function proposalDetails(uint index) public view returns (string memory, uint, uint, string[] memory, bytes[][] memory, uint[] memory) {\\n        return (\\n          proposals[index].description,\\n          proposals[index].snapshotId,\\n          proposals[index].votersSupply,\\n          proposals[index].optionsNames,\\n          proposals[index].optionsActions,\\n          proposals[index].optionsVotes\\n        );\\n    }\\n\\n    function propose(string calldata title, string calldata description, uint votingTime, uint executionDelay, string[] calldata optionNames, bytes[][] memory optionActions) external returns (uint) {\\n        uint snapshotId = voters.snapshot();\\n        require(voters.votesAt(msg.sender, snapshotId) >= minBalanceToPropose, \\\"<balance\\\");\\n        require(optionNames.length == optionActions.length && optionNames.length > 0 && optionNames.length <= 100, \\\"option len match or count\\\");\\n        require(optionActions[optionActions.length - 1].length == 0, \\\"last option, no action\\\");\\n        require(votingTime >= minVotingTime, \\\"<voting time\\\");\\n        require(executionDelay >= minExecutionDelay, \\\"<exec delay\\\");\\n\\n        // Check the proposing address doesn't have an other active proposal\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n            require(block.timestamp > proposals[latestProposalId].endAt, \\\"1 live proposal max\\\");\\n        }\\n\\n        // Add new proposal\\n        proposalsCount += 1;\\n        Proposal storage newProposal = proposals[proposalsCount];\\n        newProposal.id = proposalsCount;\\n        newProposal.proposer = msg.sender;\\n        newProposal.title = title;\\n        newProposal.description = description;\\n        newProposal.startAt = block.timestamp + 86400;\\n        newProposal.endAt = block.timestamp + 86400 + votingTime;\\n        newProposal.executableAt = block.timestamp + 86400 + votingTime + executionDelay;\\n        newProposal.snapshotId = snapshotId;\\n        newProposal.votersSupply = voters.totalSupplyAt(snapshotId);\\n        newProposal.optionsNames = new string[](optionNames.length);\\n        newProposal.optionsVotes = new uint[](optionNames.length);\\n        newProposal.optionsActions = optionActions;\\n\\n        for (uint i = 0; i < optionNames.length; i++) {\\n            require(optionActions[i].length <= 10, \\\"actions length > 10\\\");\\n            newProposal.optionsNames[i] = optionNames[i];\\n        }\\n\\n        latestProposalIds[msg.sender] = newProposal.id;\\n        emit Proposed(newProposal.id);\\n        return newProposal.id;\\n    }\\n\\n    function proposeCancel(uint proposalId, string memory title, string memory description) external returns (uint) {\\n        uint snapshotId = voters.snapshot();\\n        require(voters.votesAt(msg.sender, snapshotId) >= minBalanceToPropose, \\\"<balance\\\");\\n\\n        // Check the proposing address doesn't have an other active proposal\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n            require(block.timestamp > proposals[latestProposalId].endAt, \\\"1 live proposal max\\\");\\n        }\\n\\n        // Add new proposal\\n        proposalsCount += 1;\\n        Proposal storage newProposal = proposals[proposalsCount];\\n        newProposal.id = proposalsCount;\\n        newProposal.proposer = msg.sender;\\n        newProposal.title = title;\\n        newProposal.description = description;\\n        newProposal.startAt = block.timestamp;\\n        newProposal.endAt = block.timestamp + 86400; // 24 hours\\n        newProposal.executableAt = block.timestamp + 86400; // Executable immediately\\n        newProposal.snapshotId = snapshotId;\\n        newProposal.votersSupply = voters.totalSupplyAt(snapshotId);\\n        newProposal.optionsNames = new string[](2);\\n        newProposal.optionsVotes = new uint[](2);\\n        newProposal.optionsActions = new bytes[][](2);\\n\\n        newProposal.optionsNames[0] = \\\"Cancel Proposal\\\";\\n        newProposal.optionsNames[1] = \\\"Do Nothing\\\";\\n        newProposal.optionsActions[0] = new bytes[](1);\\n        newProposal.optionsActions[1] = new bytes[](0);\\n        newProposal.optionsActions[0][0] = abi.encode(\\n            address(this), 0,\\n            abi.encodeWithSignature(\\\"cancel(uint256)\\\", proposalId)\\n        );\\n\\n        latestProposalIds[msg.sender] = newProposal.id;\\n        emit Proposed(newProposal.id);\\n        return newProposal.id;\\n    }\\n\\n    function vote(uint proposalId, uint optionId) external {\\n        _vote(msg.sender, proposalId, optionId);\\n    }\\n\\n    function voteBySig(uint proposalId, uint optionId, uint8 v, bytes32 r, bytes32 s) external {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"Thorstarter DAO\\\")), chainId, address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, optionId));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address voter = ecrecover(digest, v, r, s);\\n        require(voter != address(0), \\\"invalid signature\\\");\\n        _vote(voter, proposalId, optionId);\\n    }\\n\\n    function _vote(address voter, uint proposalId, uint optionId) private {\\n        Proposal storage p = proposals[proposalId];\\n        require(block.timestamp < p.endAt, \\\"voting ended\\\");\\n        require(proposalVotes[proposalId][voter] == 0, \\\"already voted\\\");\\n        p.optionsVotes[optionId] = p.optionsVotes[optionId] + voters.votesAt(voter, p.snapshotId);\\n        proposalVotes[proposalId][voter] = optionId + 1;\\n        emit Voted(proposalId, voter, optionId);\\n    }\\n\\n    // Executes an un-executed, with quorum, ready to be executed proposal\\n    // If the pre-conditions are met, anybody can call this\\n    // Part of this is establishing which option \\\"won\\\" and if quorum was reached\\n    function execute(uint proposalId) external {\\n        Proposal storage p = proposals[proposalId];\\n        require(p.executedAt == 0, \\\"already executed\\\");\\n        require(block.timestamp > p.executableAt, \\\"not yet executable\\\");\\n        require(!p.cancelled, \\\"proposal cancelled\\\");\\n        require(p.optionsVotes.length >= 2, \\\"not a proposal\\\");\\n        p.executedAt = block.timestamp; // Mark as executed now to prevent re-entrancy\\n\\n        // Pick the winning option (the one with the most votes, defaulting to the \\\"Against\\\" (last) option\\n        uint votesTotal;\\n        uint winningOptionIndex = p.optionsNames.length - 1; // Default to \\\"Against\\\"\\n        uint winningOptionVotes = 0;\\n        for (int i = int(p.optionsVotes.length) - 1; i >= 0; i--) {\\n            uint votes = p.optionsVotes[uint(i)];\\n            votesTotal = votesTotal + votes;\\n            // Use greater than (not equal) to avoid a proposal with 0 votes\\n            // to default to the 1st option\\n            if (votes > winningOptionVotes) {\\n                winningOptionIndex = uint(i);\\n                winningOptionVotes = votes;\\n            }\\n        }\\n\\n        require((votesTotal * 1e12) / p.votersSupply > minPercentQuorum, \\\"not at quorum\\\");\\n\\n        // Run all actions attached to the winning option\\n        for (uint i = 0; i < p.optionsActions[winningOptionIndex].length; i++) {\\n            (address to, uint value, bytes memory data) = abi.decode(\\n              p.optionsActions[winningOptionIndex][i],\\n              (address, uint, bytes)\\n            );\\n            (bool success,) = to.call{value: value}(data);\\n            require(success, \\\"action reverted\\\");\\n            emit Executed(to, value, data);\\n        }\\n\\n        emit ExecutedProposal(proposalId, winningOptionIndex, msg.sender);\\n    }\\n\\n    function setMinBalanceToPropose(uint value) external {\\n        require(msg.sender == address(this), \\\"!DAO\\\");\\n        minBalanceToPropose = value;\\n    }\\n\\n    function setMinPercentQuorum(uint value) external {\\n        require(msg.sender == address(this), \\\"!DAO\\\");\\n        minPercentQuorum = value;\\n    }\\n\\n    function setMinVotingTime(uint value) external {\\n        require(msg.sender == address(this), \\\"!DAO\\\");\\n        minVotingTime = value;\\n    }\\n\\n    function setMinExecutionDelay(uint value) external {\\n        require(msg.sender == address(this), \\\"!DAO\\\");\\n        minExecutionDelay = value;\\n    }\\n\\n    function setVoters(address newVoters) external {\\n        require(msg.sender == address(this), \\\"!DAO\\\");\\n        voters = IVoters(newVoters);\\n    }\\n\\n    function cancel(uint proposalId) external {\\n        require(msg.sender == address(this), \\\"!DAO\\\");\\n        Proposal storage p = proposals[proposalId];\\n        require(p.executedAt == 0 && !p.cancelled, \\\"already executed or cancelled\\\");\\n        p.cancelled = true;\\n    }\\n\\n    fallback() external payable { }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVoters.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IVoters {\\n  function snapshot() external returns (uint);\\n  function totalSupplyAt(uint snapshotId) external view returns (uint);\\n  function votesAt(address account, uint snapshotId) external view returns (uint);\\n  function balanceOf(address account) external view returns (uint);\\n  function balanceOfAt(address account, uint snapshotId) external view returns (uint);\\n  function donate(uint amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voters\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minBalanceToPropose\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPercentQuorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minVotingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minExecutionDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executer\",\"type\":\"address\"}],\"name\":\"ExecutedProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"Proposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBalanceToPropose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minExecutionDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPercentQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minVotingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"proposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"proposalDetails\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"bytes[][]\",\"name\":\"\",\"type\":\"bytes[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"votingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionDelay\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"optionNames\",\"type\":\"string[]\"},{\"internalType\":\"bytes[][]\",\"name\":\"optionActions\",\"type\":\"bytes[][]\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"proposeCancel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinBalanceToPropose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinExecutionDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinPercentQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinVotingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newVoters\",\"type\":\"address\"}],\"name\":\"setVoters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"voteBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voters\",\"outputs\":[{\"internalType\":\"contract IVoters\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DAO","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ebcd3922a199cd1358277c6458439c13a93531ed00000000000000000000000000000000000000000000021e19e0c9bab2400000000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000697800000000000000000000000000000000000000000000000000000000000015180","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}