{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"AdvancedWithdrawerMainnet.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2021-09-17\\n*/\\n\\n/**\\n *Submitted for verification at Etherscan.io on 2021-09-17\\n*/\\n\\n/**\\n *Submitted for verification at Etherscan.io on 2021-06-20\\n*/\\n\\n// SPDX-License-Identifier: MIXED\\n\\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.2\\n// License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\n// Edited by BoringCrypto\\n\\ncontract BoringOwnableData {\\n    address public owner;\\n    address public pendingOwner;\\n}\\n\\ncontract BoringOwnable is BoringOwnableData {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice `owner` defaults to msg.sender on construction.\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\n    /// Can only be invoked by the current `owner`.\\n    /// @param newOwner Address of the new owner.\\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\\n    function transferOwnership(\\n        address newOwner,\\n        bool direct,\\n        bool renounce\\n    ) public onlyOwner {\\n        if (direct) {\\n            // Checks\\n            require(newOwner != address(0) || renounce, \\\"Ownable: zero address\\\");\\n\\n            // Effects\\n            emit OwnershipTransferred(owner, newOwner);\\n            owner = newOwner;\\n            pendingOwner = address(0);\\n        } else {\\n            // Effects\\n            pendingOwner = newOwner;\\n        }\\n    }\\n\\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\\n    function claimOwnership() public {\\n        address _pendingOwner = pendingOwner;\\n\\n        // Checks\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\n\\n        // Effects\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    /// @notice Only allows the `owner` to execute the function.\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\\n\\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.1\\ninterface IERC20 {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.2\\n\\ninterface IBentoBoxV1 {\\n    function balanceOf(IERC20 token, address user) external view returns (uint256 share);\\n    function deposit(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    function toAmount(\\n        IERC20 token,\\n        uint256 share,\\n        bool roundUp\\n    ) external view returns (uint256 amount);\\n    \\n    function toShare(\\n        IERC20 token,\\n        uint256 amount,\\n        bool roundUp\\n    ) external view returns (uint256 share);\\n    \\n    function transfer(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 share\\n    ) external;\\n\\n    function withdraw(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n}\\n\\n// License-Identifier: MIT\\n\\ninterface Cauldron {\\n    function accrue() external;\\n    function withdrawFees() external;\\n    function accrueInfo() external view returns(uint64, uint128, uint64);\\n    function bentoBox() external returns (address);\\n}\\n\\ninterface CauldronV1 {\\n    function accrue() external;\\n    function withdrawFees() external;\\n    function accrueInfo() external view returns(uint64, uint128);\\n}\\n\\ncontract AdvancedWithdrawer is BoringOwnable {\\n    \\n    Cauldron[] public cauldrons;\\n    CauldronV1[] public cauldronsv1;\\n    Cauldron[] public degens;\\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\\n    \\n    constructor(Cauldron[] memory pools, CauldronV1[] memory poolsv1, Cauldron[] memory degens_) {\\n        cauldrons = pools;\\n        cauldronsv1 = poolsv1;\\n        degens = degens_;\\n    }\\n    \\n    function withdraw() external {\\n        uint256 length = cauldrons.length;\\n        for(uint256 i = 0; i < length; i++) {\\n            cauldrons[i].accrue();\\n            (, uint256 feesEarned, ) = cauldrons[i].accrueInfo();\\n            if(feesEarned > (bentoBox.toAmount(MIM, bentoBox.balanceOf(MIM, address(cauldrons[i])), false))) {\\n                MIM.transferFrom(msg.sender, address(bentoBox), feesEarned);\\n                bentoBox.deposit(MIM, address(bentoBox), address(cauldrons[i]), feesEarned, 0);\\n            }\\n            cauldrons[i].withdrawFees();\\n        }\\n        \\n        length = cauldronsv1.length;\\n        for(uint256 i = 0; i < length; i++) {\\n            cauldronsv1[i].accrue();\\n            (, uint256 feesEarned) = cauldronsv1[i].accrueInfo();\\n            if(feesEarned > (bentoBox.toAmount(MIM, bentoBox.balanceOf(MIM, address(cauldronsv1[i])), false))) {\\n                MIM.transferFrom(msg.sender, address(bentoBox), feesEarned);\\n                bentoBox.deposit(MIM, address(bentoBox), address(cauldronsv1[i]), feesEarned, 0);\\n            }\\n            cauldronsv1[i].withdrawFees();\\n\\n        }\\n        \\n        length = degens.length;\\n        for(uint256 i = 0; i < length; i++) {\\n            degens[i].accrue();\\n            (, uint256 feesEarned, ) = degens[i].accrueInfo();\\n            if(feesEarned > (degenBox.toAmount(MIM, degenBox.balanceOf(MIM, address(degens[i])), false))) {\\n                MIM.transferFrom(msg.sender, address(degenBox), feesEarned);\\n                degenBox.deposit(MIM, address(degenBox), address(degens[i]), feesEarned, 0);\\n            }\\n            degens[i].withdrawFees();\\n        }\\n        \\n    }\\n    \\n    function addPool(Cauldron pool) external onlyOwner {\\n        _addPool(pool);\\n    }\\n    \\n    function _addPool(Cauldron pool) internal onlyOwner {\\n        //allow settings and changing cauldrons that receive staking rewards.\\n        require(address(pool) != address(0), \\\"invalid cauldron\\\");\\n        \\n        if(pool.bentoBox() == address(bentoBox)){\\n            //do not allow doubles\\n            for(uint256 i = 0; i < cauldrons.length; i++){\\n                require(cauldrons[i] != pool, \\\"already added\\\");\\n            }\\n            cauldrons.push(pool);\\n        } else if (pool.bentoBox() == address(degenBox)) {\\n            for(uint256 i = 0; i < degens.length; i++){\\n                require(degens[i] != pool, \\\"already added\\\");\\n            }\\n            degens.push(pool);\\n        }\\n        \\n    }\\n    \\n    function addPoolv1(CauldronV1 pool) external onlyOwner {\\n        cauldronsv1.push(pool);\\n    }\\n    \\n    \\n    function addPools(Cauldron[] memory pools) external onlyOwner {\\n        for(uint256 i = 0; i < pools.length; i++) {\\n            _addPool(pools[i]);\\n        }\\n    }\\n    \\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Cauldron[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"contract CauldronV1[]\",\"name\":\"poolsv1\",\"type\":\"address[]\"},{\"internalType\":\"contract Cauldron[]\",\"name\":\"degens_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIM\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Cauldron\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Cauldron[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"addPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract CauldronV1\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPoolv1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cauldrons\",\"outputs\":[{\"internalType\":\"contract Cauldron\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cauldronsv1\",\"outputs\":[{\"internalType\":\"contract CauldronV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"degenBox\",\"outputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"degens\",\"outputs\":[{\"internalType\":\"contract Cauldron\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AdvancedWithdrawer","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000002e0000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000ebfde87310dc22404d918058faa4d56dc4e93f0a000000000000000000000000003d5a75d284824af736df51933be522de9eed0f00000000000000000000000098a84eff6e008c5ed0289655ccdca899bcb6b99f000000000000000000000000920d9bd936da4eafb5e25c6bdc9f6cb528953f9f00000000000000000000000005500e2ee779329698df35760bedcaac046e7c270000000000000000000000000bca8ebcb26502b013493bf8fe53aa2b1ed401c1000000000000000000000000806e16ec797c69afa8590a55723ce4cc1b54050e0000000000000000000000007b7473a76d6ae86ce19f7352a1e89f6c9dc390200000000000000000000000004eaed76c3a388f4a841e9c765560bbe7b3e4b3a0000000000000000000000000c1879bf24917ebe531fbaa20b0d05da027b592ce000000000000000000000000252dcf1b621cc53bc22c256255d2be5c8c32eae400000000000000000000000035a0dd182e4bca59d5931eae13d0a2332fa303210000000000000000000000009617b633ef905860d919b88e1d9d9a61917953410000000000000000000000003410297d89dcdaf4072b805efc1ef701bb3dd9bf0000000000000000000000006371efe5cd6e3d2d7c477935b7669401143b798500000000000000000000000000000000000000000000000000000000000000030000000000000000000000006cbafee1fab76ca5b5e144c43b3b50d42b7c8c8f000000000000000000000000ffbf4892822e0d552cff317f65e1ee7b5d3d9ae6000000000000000000000000551a7cff4de931f32893c928bbc3d25bf1fc51470000000000000000000000000000000000000000000000000000000000000002000000000000000000000000cfc571f3203756319c231d3bc643cee807e74636000000000000000000000000bc36fde44a7fd8f545d459452ef9539d7a14dd63","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}