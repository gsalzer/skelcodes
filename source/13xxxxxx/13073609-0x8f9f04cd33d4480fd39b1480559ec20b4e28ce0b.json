{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/0xerc1155/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport '../utils/EnumerableSet.sol';\\nimport '../utils/Address.sol';\\nimport '../utils/Context.sol';\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using Address for address;\\n\\n  struct RoleData {\\n    EnumerableSet.AddressSet members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {_setupRole}.\\n   */\\n  event RoleGranted(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  /**\\n   * @dev Returns `true` if `account` has been granted `role`.\\n   */\\n  function hasRole(bytes32 role, address account) public view returns (bool) {\\n    return _roles[role].members.contains(account);\\n  }\\n\\n  /**\\n   * @dev Returns the number of accounts that have `role`. Can be used\\n   * together with {getRoleMember} to enumerate all bearers of a role.\\n   */\\n  function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n    return _roles[role].members.length();\\n  }\\n\\n  /**\\n   * @dev Returns one of the accounts that have `role`. `index` must be a\\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\\n   *\\n   * Role bearers are not sorted in any particular way, and their ordering may\\n   * change at any point.\\n   *\\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n   * you perform all queries on the same block. See the following\\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n   * for more information.\\n   */\\n  function getRoleMember(bytes32 role, uint256 index)\\n    public\\n    view\\n    returns (address)\\n  {\\n    return _roles[role].members.at(index);\\n  }\\n\\n  /**\\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\\n   * {revokeRole}.\\n   *\\n   * To change a role's admin, use {_setRoleAdmin}.\\n   */\\n  function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function grantRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to grant'\\n    );\\n\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from `account`.\\n   *\\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function revokeRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to revoke'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from the calling account.\\n   *\\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n   * purpose is to provide a mechanism for accounts to lose their privileges\\n   * if they are compromised (such as when a trusted device is misplaced).\\n   *\\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must be `account`.\\n   */\\n  function renounceRole(bytes32 role, address account) public virtual {\\n    require(\\n      account == _msgSender(),\\n      'AccessControl: can only renounce roles for self'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event. Note that unlike {grantRole}, this function doesn't perform any\\n   * checks on the calling account.\\n   *\\n   * [WARNING]\\n   * ====\\n   * This function should only be called from the constructor when setting\\n   * up the initial roles for the system.\\n   *\\n   * Using this function in any other way is effectively circumventing the admin\\n   * system imposed by {AccessControl}.\\n   * ====\\n   */\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Sets `adminRole` as ``role``'s admin role.\\n   *\\n   * Emits a {RoleAdminChanged} event.\\n   */\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (_roles[role].members.add(account)) {\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (_roles[role].members.remove(account)) {\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\ninterface IERC1155 {\\n  /****************************************|\\n  |                 Events                 |\\n  |_______________________________________*/\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _id,\\n    uint256 _amount\\n  );\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256[] _ids,\\n    uint256[] _amounts\\n  );\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /****************************************|\\n  |                Functions               |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\\n   * @dev MUST emit TransferSingle event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @dev MUST emit TransferBatch event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeBatchTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner's balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return isOperator True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    external\\n    view\\n    returns (bool isOperator);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n  // Default hash for EOA accounts returned by extcodehash\\n  bytes32 internal constant ACCOUNT_HASH =\\n    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract.\\n   * @param _address address of the account to check\\n   * @return Whether the target address is a contract\\n   */\\n  function isContract(address _address) internal view returns (bool) {\\n    bytes32 codehash;\\n\\n    // Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address or if it has a non-zero code hash or account hash\\n    assembly {\\n      codehash := extcodehash(_address)\\n    }\\n    return (codehash != 0x0 && codehash != ACCOUNT_HASH);\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call(data);\\n\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position of the value in the `values` array, plus 1 because index 0\\n    // means a value is not in the set.\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We read and store the value's index to prevent multiple reads from the same storage slot\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n      // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      // Move the last value to the index where the value to delete is\\n      set._values[toDeleteIndex] = lastvalue;\\n      // Update the index for the moved value\\n      set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the index for the deleted slot\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n   */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n   */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND Apache-2.0\\n\\npragma solidity 0.7.6;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../utils/SafeMath.sol';\\nimport '../utils/Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    // solhint-disable-next-line max-line-length\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(\\n      data,\\n      'SafeERC20: low-level call failed'\\n    );\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(\\n        abi.decode(returndata, (bool)),\\n        'SafeERC20: ERC20 operation did not succeed'\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Multiplies two unsigned integers, reverts on overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath#mul: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, 'SafeMath#div: DIVISION_BY_ZERO');\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, 'SafeMath#sub: UNDERFLOW');\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Adds two unsigned integers, reverts on overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath#add: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n   * reverts when dividing by zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'SafeMath#mod: DIVISION_BY_ZERO');\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/booster/Booster.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport '../../0xerc1155/interfaces/IERC1155.sol';\\nimport '../../0xerc1155/utils/SafeERC20.sol';\\nimport '../../0xerc1155/utils/SafeMath.sol';\\nimport '../../0xerc1155/access/AccessControl.sol';\\n\\nimport '../investment/interfaces/IRewardHandler.sol';\\nimport '../token/interfaces/IWOWSERC1155.sol';\\nimport '../utils/TokenIds.sol';\\n\\nimport './interfaces/IBooster.sol';\\n\\ncontract Booster is IBooster, AccessControl {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n  using TokenIds for uint256;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Constants\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  bytes32 public constant CONTROLLER_ROLE = bytes32('CONTROLLER');\\n\\n  // 30 days in seconds multiplied by 10 (10% per month)\\n  uint256 private constant MONTHLY_REWARD = 25920000;\\n\\n  // Maximum rewards provided from tokenomics\\n  uint256 private constant MAX_TOKENOMICS_REWARDS = 7500000000000000000000;\\n\\n  // SECONDS PER YEAR\\n  uint256 private constant SECONDS_PER_YEAR = 360 * 86400;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  // The rewardHandler to distribute rewards\\n  IRewardHandler public rewardHandler;\\n\\n  // The SFT contract to validate recipients\\n  IWOWSERC1155 public sftHolder;\\n\\n  // Our timelock\\n  struct TimeLock {\\n    uint256 totalAmount;\\n    uint256 pendingAmount;\\n    uint256 providedAmount;\\n    uint256 last;\\n    uint256 end;\\n    uint256 apr;\\n    uint32 fee;\\n  }\\n  mapping(address => TimeLock) public timeLocks;\\n\\n  // Reward definition (1 / 3 / 6 month)\\n  struct RewardDefinition {\\n    uint256 length; // in seconds\\n    uint256 apr; // 1E18 == 100%\\n  }\\n  RewardDefinition[] public rewardDefinitions;\\n\\n  // Overall provided rewards\\n  uint256 public rewardsProvided;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  modifier onlyAdmin() {\\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'B: Only admin');\\n    _;\\n  }\\n\\n  modifier onlyController() {\\n    require(hasRole(CONTROLLER_ROLE, _msgSender()), 'B: Only controller');\\n    _;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Events\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Temporary tokens owned by recipient were locked\\n   *\\n   * Tokens are owned by recipient for a specific duration of seconds.\\n   *\\n   * @param recipient The recipient of the rewards\\n   * @param amountIn The amount of tokens in\\n   * @param amountLocked The amount of tokens locked (amount plus reward)\\n   */\\n  event TokensLocked(\\n    address indexed recipient,\\n    uint256 amountIn,\\n    uint256 amountLocked\\n  );\\n\\n  /**\\n   * @dev More amount was added into existing lock pool\\n   *\\n   * @param recipient The SFT receiving the rewards\\n   * @param amount The amount of tokens claimed\\n   * @param amountLocked The amount of tokens locked\\n   */\\n  event MoreAdded(\\n    address indexed recipient,\\n    uint256 amount,\\n    uint256 amountLocked\\n  );\\n\\n  /**\\n   * @dev Rrewards were claimed either into wallet or re-locked\\n   *\\n   * @param recipient The recipient of the rewards\\n   * @param amount The amount of tokens claimed\\n   */\\n  event RewardsClaimed(address indexed recipient, uint256 amount);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Constructs implementation part and provides admin access\\n   * for a later selfDestruct call.\\n   */\\n  constructor(address admin) {\\n    // For administrative calls\\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\\n  }\\n\\n  /**\\n   * @dev One time initializer for proxy\\n   */\\n  function initialize(address admin, address rewardHandler_) external {\\n    // Validate parameters\\n    require(\\n      getRoleMemberCount(DEFAULT_ADMIN_ROLE) == 0,\\n      'B: Already initialized'\\n    );\\n\\n    // For administrative calls\\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\\n    _setRewardHandler(rewardHandler_);\\n\\n    // Reward definition: 180 days / 175% APR\\n    rewardDefinitions.push(RewardDefinition(15552000, 1750000000000000000));\\n\\n    // Reward definition: 90 days / 130% APR\\n    rewardDefinitions.push(RewardDefinition(7776000, 1300000000000000000));\\n\\n    // Reward definition: 30 days / 100% APR\\n    rewardDefinitions.push(RewardDefinition(2592000, 1000000000000000000));\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation of {IBooster}\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {IBooster-getRewardInfo}\\n   */\\n  function getRewardInfo(uint256[] memory tokenIds)\\n    external\\n    view\\n    override\\n    returns (\\n      uint256[] memory locked,\\n      uint256[] memory pending,\\n      uint256[] memory apr,\\n      uint256[] memory secsLeft\\n    )\\n  {\\n    locked = new uint256[](tokenIds.length);\\n    pending = new uint256[](tokenIds.length);\\n    apr = new uint256[](tokenIds.length);\\n    secsLeft = new uint256[](tokenIds.length);\\n\\n    uint256 ts = _getTimestamp();\\n\\n    for (uint256 i = 0; i < tokenIds.length; ++i) {\\n      address cfolio = sftHolder.tokenIdToAddress(tokenIds[i].toSftTokenId());\\n      require(cfolio != address(0), 'B: Invalid tokenId');\\n\\n      TimeLock storage currentLock = timeLocks[cfolio];\\n      locked[i] = currentLock.totalAmount;\\n      pending[i] = _getPendingAmount(currentLock, ts);\\n      apr[i] = currentLock.apr;\\n      secsLeft[i] = currentLock.end >= ts\\n        ? currentLock.end.sub(ts)\\n        : uint256(-1);\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IBooster-distributeFromFarm}\\n   */\\n  function distributeFromFarm(\\n    address, /* farm*/\\n    address recipient,\\n    uint256 amount,\\n    uint32 fee\\n  ) external override onlyController {\\n    // Validate input\\n    require(recipient != address(0), 'B: Invalid recipient');\\n\\n    if (sftHolder.addressToTokenId(recipient) != uint256(-1)) {\\n      // Prepare locking amount into SFT\\n      TimeLock storage currentLock = timeLocks[recipient];\\n\\n      if (currentLock.end != 0) {\\n        uint256 ts = _getTimestamp();\\n\\n        // Update pending rewards\\n        _updatePendingRewards(currentLock, ts);\\n\\n        // Add more\\n        require(currentLock.fee == fee, 'B: Fee change');\\n\\n        // Add amount to total\\n        _addMore(recipient, currentLock, ts, amount);\\n      } else {\\n        // Validate state\\n        require(\\n          currentLock.totalAmount == 0 || currentLock.fee == fee,\\n          'B: Fee mismatch'\\n        );\\n\\n        // Prepare for a new lock\\n        currentLock.fee = fee;\\n        currentLock.totalAmount = currentLock.totalAmount.add(amount);\\n      }\\n    } else {\\n      rewardHandler.distribute2(recipient, amount, fee);\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IBooster-lock}\\n   */\\n  function lock(address recipient, uint256 lockPeriod)\\n    external\\n    override\\n    onlyController\\n  {\\n    uint256 ts = _getTimestamp();\\n\\n    TimeLock storage currentLock = timeLocks[recipient];\\n\\n    // Verify that we have already updated lock (from preceeding\\n    // {distributeFromFarm} call)\\n    require(currentLock.end == 0 || currentLock.last == ts, 'B: Sync failure');\\n\\n    if (currentLock.end == 0) {\\n      // Start a new lock session. Calculate the amount we provide.\\n      for (uint256 i = 0; i < rewardDefinitions.length; ++i) {\\n        if (lockPeriod >= rewardDefinitions[i].length) {\\n          uint256 reward = (\\n            currentLock.totalAmount.mul(rewardDefinitions[i].length).mul(\\n              rewardDefinitions[i].apr\\n            )\\n          ).div(SECONDS_PER_YEAR.mul(1E18));\\n\\n          currentLock.totalAmount = currentLock.totalAmount.add(reward);\\n          currentLock.end = ts + rewardDefinitions[i].length;\\n          currentLock.apr = rewardDefinitions[i].apr;\\n          currentLock.last = ts;\\n\\n          rewardsProvided.add(reward);\\n\\n          // Validate state\\n          _verifyRewardsProvided();\\n\\n          // Dispatch event\\n          emit TokensLocked(\\n            recipient,\\n            currentLock.totalAmount.sub(reward),\\n            currentLock.totalAmount\\n          );\\n\\n          // Candidate found, return\\n          return;\\n        }\\n      }\\n\\n      // We never should reach this line\\n      revert('B: LockPeriod wrong');\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IBooster-claimRewards}\\n   */\\n  function claimRewards(uint256 sftTokenId, bool reLock) external override {\\n    // Validate access\\n    address cfolio = sftHolder.tokenIdToAddress(sftTokenId);\\n    require(cfolio != address(0), 'B: Invalid cfolio');\\n    require(\\n      IERC1155(address(sftHolder)).balanceOf(_msgSender(), sftTokenId) == 1,\\n      'B: Access denied'\\n    );\\n\\n    TimeLock storage currentLock = timeLocks[cfolio];\\n    uint256 ts = _getTimestamp();\\n\\n    _updatePendingRewards(currentLock, ts);\\n\\n    uint256 claimable = currentLock.pendingAmount;\\n    currentLock.pendingAmount = 0;\\n    currentLock.providedAmount.add(claimable);\\n\\n    // Dispatch event\\n    emit RewardsClaimed(cfolio, claimable);\\n\\n    // Update state\\n    if (reLock) {\\n      _addMore(cfolio, currentLock, ts, claimable);\\n    } else {\\n      rewardHandler.distribute2(_msgSender(), claimable, currentLock.fee);\\n    }\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Maintanance functions\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Self destruct implementation contract\\n   */\\n  function destructContract(address payable newContract) external onlyAdmin {\\n    // slither-disable-next-line suicidal\\n    selfdestruct(newContract);\\n  }\\n\\n  /**\\n   * @dev Set reward handler in case it will be upgraded\\n   */\\n  function setRewardHandler(address rewardHandler_) external onlyAdmin {\\n    _setRewardHandler(rewardHandler_);\\n  }\\n\\n  /**\\n   * @dev Set sftHolder contract which is deployed after Booster\\n   */\\n  function setSftHolder(address sftHolder_) external onlyAdmin {\\n    // Validate input\\n    require(sftHolder_ != address(0), 'B: Invalid sftHolder');\\n\\n    // Update state\\n    sftHolder = IWOWSERC1155(sftHolder_);\\n  }\\n\\n  /**\\n   * @dev Replace reward definition.\\n   * Durations are required to be in descending order\\n   */\\n  function setRewardDefinition(\\n    uint256[] calldata durations,\\n    uint256[] calldata aprs\\n  ) external onlyAdmin {\\n    // Validate input\\n    require(durations.length == aprs.length, 'B: Length mismatch');\\n\\n    // Update state\\n    delete (rewardDefinitions);\\n    for (uint256 i = 0; i < durations.length; ++i) {\\n      require(i == 0 || durations[i] > durations[i - 1], 'B: Wrong sorting');\\n      rewardDefinitions.push(RewardDefinition(durations[i], aprs[i]));\\n    }\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation details\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Helper function to avoid disabling solhint in several places\\n   */\\n  function _getTimestamp() private view returns (uint256) {\\n    // solhint-disable-next-line not-rely-on-time\\n    return block.timestamp;\\n  }\\n\\n  /**\\n   * @dev Internal setRewardhandler which checks for valid address\\n   */\\n  function _setRewardHandler(address rewardHandler_) internal {\\n    // Validate input\\n    require(rewardHandler_ != address(0), 'B: Invalid rewardHandler');\\n\\n    // Update state\\n    rewardHandler = IRewardHandler(rewardHandler_);\\n  }\\n\\n  /**\\n   * @dev Add more amount into existing lock pool\\n   *\\n   * Function will revert in case lock is closed because lock_.end is 0\\n   * and every subtraction with ts > 0 will fail in SafeMath\\n   */\\n  function _addMore(\\n    address recipient,\\n    TimeLock storage lock_,\\n    uint256 ts,\\n    uint256 amount\\n  ) private {\\n    // Following line reverts in SafeMath if timestamps are invalid\\n    uint256 reward = (amount.mul(lock_.end.sub(ts)).mul(lock_.apr)).div(\\n      SECONDS_PER_YEAR.mul(1E18)\\n    );\\n\\n    // Update state\\n    lock_.totalAmount = lock_.totalAmount.add(amount).add(reward);\\n    rewardsProvided.add(reward);\\n\\n    // Validate state\\n    _verifyRewardsProvided();\\n\\n    // Dispatch event\\n    emit MoreAdded(recipient, amount, amount.add(reward));\\n  }\\n\\n  /**\\n   * @dev Write all pending rewards into pendingAmount so we can\\n   * safely add more amounts or finalize the lock pool.\\n   */\\n  function _updatePendingRewards(TimeLock storage lock_, uint256 ts) private {\\n    lock_.pendingAmount = _getPendingAmount(lock_, ts);\\n    if (lock_.end != 0) {\\n      if (ts >= lock_.end) {\\n        lock_.end = 0;\\n        lock_.totalAmount = 0;\\n        lock_.providedAmount = 0;\\n      } else {\\n        lock_.last = ts;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Calculate the current pending amount\\n   */\\n  function _getPendingAmount(TimeLock storage lock_, uint256 ts)\\n    private\\n    view\\n    returns (uint256)\\n  {\\n    if (lock_.end != 0) {\\n      if (ts >= lock_.end) {\\n        return lock_.totalAmount.sub(lock_.providedAmount);\\n      } else {\\n        return\\n          lock_.pendingAmount.add(\\n            lock_.totalAmount.mul(ts.sub(lock_.last)).div(MONTHLY_REWARD)\\n          );\\n      }\\n    } else {\\n      return lock_.pendingAmount;\\n    }\\n  }\\n\\n  /**\\n   * @dev Verify that we never exceed the token supply from tokenomics and fees\\n   */\\n  function _verifyRewardsProvided() private view {\\n    uint256 externalSupply = rewardHandler.getBoosterRewards();\\n\\n    require(\\n      rewardsProvided <= externalSupply.add(MAX_TOKENOMICS_REWARDS),\\n      'B: Cap reached'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/booster/interfaces/IBooster.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @dev Interface to C-folio item contracts\\n */\\ninterface IBooster {\\n  /**\\n   * @dev Return information about the reward state in Booster\\n   *\\n   * @param tokenIds The SFT or TF tokenId\\n   *\\n   * @return locked The total amounts locked\\n   * @return pending The pending amounts claimable\\n   * @return apr The APR of this lock pool\\n   * @return secsLeft Numbers of seconds until unlock, or -1 if unlocked\\n   */\\n  function getRewardInfo(uint256[] calldata tokenIds)\\n    external\\n    view\\n    returns (\\n      uint256[] memory locked,\\n      uint256[] memory pending,\\n      uint256[] memory apr,\\n      uint256[] memory secsLeft\\n    );\\n\\n  /**\\n   * @dev Handles farm distribution, only callable from controller\\n   *\\n   * If recipient is booster contract, amount is temporarily stored and locked\\n   * in a second call.\\n   *\\n   * @param farm The reward farm that the call originates from\\n   * @param recipient The recipient of the rewards\\n   * @param amount The amount to distribute\\n   * @param fee The fee in 6 decimal notation\\n   */\\n  function distributeFromFarm(\\n    address farm,\\n    address recipient,\\n    uint256 amount,\\n    uint32 fee\\n  ) external;\\n\\n  /**\\n   * @dev Locks temporary tokens owned by recipient for a specific duration\\n   * of seconds.\\n   *\\n   * @param recipient The recipient of the rewards\\n   * @param lockPeriod The lock period in seconds\\n   */\\n  function lock(address recipient, uint256 lockPeriod) external;\\n\\n  /**\\n   * @dev Claim rewards either into wallet or re-lock them\\n   *\\n   * @param sftTokenId The tokenId that manages the rewards\\n   * @param reLock True to re-lock existing rewards to earn more\\n   */\\n  function claimRewards(uint256 sftTokenId, bool reLock) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/investment/interfaces/IRewardHandler.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity 0.7.6;\\n\\ninterface IRewardHandler {\\n  /**\\n   * @dev Get the amount allocated for the Booster\\n   *\\n   * @return The amount which is allocated for the Booster (18 decimals)\\n   */\\n  function getBoosterRewards() external view returns (uint256);\\n\\n  /**\\n   * @dev Transfer reward and distribute the fee\\n   *\\n   * This is the new implementation of distribute() which uses internal fees\\n   * defined in the {RewardHandler} contract.\\n   *\\n   * @param recipient The recipient of the reward\\n   * @param amount The amount of WOWS to transfer to the recipient\\n   * @param fee The reward fee in 1e6 factor notation\\n   */\\n  function distribute2(\\n    address recipient,\\n    uint256 amount,\\n    uint32 fee\\n  ) external;\\n\\n  /**\\n   * @dev Transfer reward and distribute the fee\\n   *\\n   * This is the current implementation, needed for backward compatibility.\\n   *\\n   * Current ERC1155Minter and Controller call this function, later\\n   * reward handler clients should call the the new one with internal\\n   * fees specified in this contract.\\n   *\\n   * uint32 values are in 1e6 factor notation.\\n   */\\n  function distribute(\\n    address recipient,\\n    uint256 amount,\\n    uint32 fee,\\n    uint32 toTeam,\\n    uint32 toMarketing,\\n    uint32 toBooster,\\n    uint32 toRewardPool\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSERC1155.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n */\\ninterface IWOWSERC1155 {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Check if the specified address is a known tradefloor\\n   *\\n   * @param account The address to check\\n   *\\n   * @return True if the address is a known tradefloor, false otherwise\\n   */\\n  function isTradeFloor(address account) external view returns (bool);\\n\\n  /**\\n   * @dev Get the token ID of a given address\\n   *\\n   * A cross check is required because token ID 0 is valid.\\n   *\\n   * @param tokenAddress The address to convert to a token ID\\n   *\\n   * @return The token ID on success, or uint256(-1) if `tokenAddress` does not\\n   * belong to a token ID\\n   */\\n  function addressToTokenId(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Get the address for a given token ID\\n   *\\n   * @param tokenId The token ID to convert\\n   *\\n   * @return The address, or address(0) in case the token ID does not belong\\n   * to an NFT\\n   */\\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\\n\\n  /**\\n   * @dev Get the next mintable token ID for the specified card\\n   *\\n   * @param level The level of the card\\n   * @param cardId The ID of the card\\n   *\\n   * @return bool True if a free token ID was found, false otherwise\\n   * @return uint256 The first free token ID if one was found, or invalid otherwise\\n   */\\n  function getNextMintableTokenId(uint8 level, uint8 cardId)\\n    external\\n    view\\n    returns (bool, uint256);\\n\\n  /**\\n   * @dev Return the next mintable custom token ID\\n   */\\n  function getNextMintableCustomToken() external view returns (uint256);\\n\\n  /**\\n   * @dev Return the level and the mint timestamp of tokenId\\n   *\\n   * @param tokenId The tokenId to query\\n   *\\n   * @return mintTimestamp The timestamp token was minted\\n   * @return level The level token belongs to\\n   */\\n  function getTokenData(uint256 tokenId)\\n    external\\n    view\\n    returns (uint64 mintTimestamp, uint8 level);\\n\\n  /**\\n   * @dev Return all tokenIds owned by account\\n   */\\n  function getTokenIds(address account)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the base URI for either predefined cards or custom cards\\n   * which don't have it's own URI.\\n   *\\n   * The resulting uri is baseUri+[hex(tokenId)] + '.json'. where\\n   * tokenId will be reduces to upper 16 bit (>> 16) before building the hex string.\\n   *\\n   */\\n  function setBaseMetadataURI(string memory baseContractMetadata) external;\\n\\n  /**\\n   * @dev Set the contracts metadata URI\\n   *\\n   * @param contractMetadataURI The URI which point to the contract metadata file.\\n   */\\n  function setContractMetadataURI(string memory contractMetadataURI) external;\\n\\n  /**\\n   * @dev Set the URI for a custom card\\n   *\\n   * @param tokenId The token ID whose URI is being set.\\n   * @param customURI The URI which point to an unique metadata file.\\n   */\\n  function setCustomURI(uint256 tokenId, string memory customURI) external;\\n\\n  /**\\n   * @dev Each custom card has its own level. Level will be used when\\n   * calculating rewards and raiding power.\\n   *\\n   * @param tokenId The ID of the token whose level is being set\\n   * @param cardLevel The new level of the specified token\\n   */\\n  function setCustomCardLevel(uint256 tokenId, uint8 cardLevel) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/TokenIds.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary TokenIds {\\n  // 128 bit underlying hash\\n  uint256 public constant HASH_MASK = (1 << 128) - 1;\\n\\n  function isBaseCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 64);\\n  }\\n\\n  function isStockCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 32);\\n  }\\n\\n  function isCFolioCard(uint256 tokenId) internal pure returns (bool) {\\n    return\\n      (tokenId & HASH_MASK) >= (1 << 64) && (tokenId & HASH_MASK) < (1 << 128);\\n  }\\n\\n  function toSftTokenId(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & HASH_MASK;\\n  }\\n\\n  function maskHash(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & ~HASH_MASK;\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLocked\",\"type\":\"uint256\"}],\"name\":\"MoreAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLocked\",\"type\":\"uint256\"}],\"name\":\"TokensLocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"reLock\",\"type\":\"bool\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"destructContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"fee\",\"type\":\"uint32\"}],\"name\":\"distributeFromFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getRewardInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"locked\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"pending\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"apr\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"secsLeft\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardHandler_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardDefinitions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardHandler\",\"outputs\":[{\"internalType\":\"contract IRewardHandler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsProvided\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"durations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"aprs\",\"type\":\"uint256[]\"}],\"name\":\"setRewardDefinition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardHandler_\",\"type\":\"address\"}],\"name\":\"setRewardHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sftHolder_\",\"type\":\"address\"}],\"name\":\"setSftHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sftHolder\",\"outputs\":[{\"internalType\":\"contract IWOWSERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeLocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"fee\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Booster","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000bb5a7c17ade983f03afd8b09922b1c117b9eabc0","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}