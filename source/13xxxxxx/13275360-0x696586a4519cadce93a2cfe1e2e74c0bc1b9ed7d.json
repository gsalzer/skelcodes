{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n// Roboto Player One is an on-chain treausre hunt inspired by Ready Player One (the book, not the movie) and a gift to the Robotos community. \r\n\r\n// Hidden in this smart contract is an NFT that only the holder of a randomly chosen Roboto can claim.\r\n// Anyone is free to check if their wallet holds the key Roboto. 0.02 ETH will check if all of your Robotos are the key, whether you have 1 or 100\r\n// ...or you can end the treasure hunt at any time by buying the mystery NFT from the contract for 10 ETH using the `buyout` function. \r\n// Have fun!\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// File: https://github.com/dapphub/ds-math/blob/master/src/math.sol\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File: @0xcert/ethereum-erc721/src/contracts/tokens/erc721.sol\r\n\r\npragma solidity 0.8.0;\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721\r\n{\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not\r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they mayb be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   * @return Address that _tokenId is approved for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n\r\n// File: @0xcert/ethereum-erc721/src/contracts/ownership/ownable.sol\r\n\r\npragma solidity 0.8.0;\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code at:\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n */\r\ncontract Ownable\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n\r\n  /**\r\n   * @dev Current owner address.\r\n   */\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner()\r\n  {\r\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/RobotoPlayerOne.sol\r\n\r\npragma solidity 0.8.0;\r\n\r\ncontract RobotoPlayerOne is IERC721Receiver, DSMath, Ownable {\r\n    \r\n    // Public Properties\r\n    \r\n    uint8   public nftCount;\r\n    bool    public claimed;\r\n    address public robotosContractAddress = 0x099689220846644F87D1137665CDED7BF3422747;\r\n    \r\n    // A running tally of how many attempts have been made to claim the hidden NFT.\r\n    uint256 public claimAttempts;\r\n    \r\n    // The address of the person who held the winning Roboto!\r\n    address public winnerAddress;\r\n    \r\n    // The address of the wallet who aped in and bought out the contract.\r\n    address public buyoutClaimerAddress;\r\n    \r\n    // Constants\r\n    \r\n    uint256 public constant checkPrice = 0.02 ether;\r\n    \r\n    uint256 public constant buyoutPrice = 10 ether;\r\n    \r\n    // Private Properties\r\n    \r\n    // The number of the magic Roboto you need to claim this contract's prize.\r\n    uint256 private winningRobotoIndex;\r\n    \r\n    // The prize NFT's number in its collection.\r\n    // I used a tool to randomly pick a reply to this tweet: https://twitter.com/backseats_eth/status/1424860091375833096\r\n    uint256 private prizeNftIndex;\r\n    \r\n    // The contract address of the prize NFT.\r\n    address private externalContractAddress;\r\n    \r\n    // Withdraw Addresses\r\n    \r\n    address p1 = 0x3a6372B2013f9876a84761187d933DEe0653E377;\r\n    address p2 = 0xef7639fADB98b76867cE29927B8347816C86A6eD;\r\n    \r\n    // Events\r\n    \r\n    event BuyoutOccurred(address _who);\r\n    event FundsWithdrawn(string _str, uint256 _p1, uint256 _p2);\r\n    event NftReceived();\r\n    event NftCheck(address _checker, string _message);\r\n    event TransferNFTToClaimer(address _keyHolder);\r\n    event ValueReceived(address _from, uint256 _amount);\r\n    \r\n    // Constructor\r\n    \r\n    constructor(\r\n        uint256 _winningRobotoIndex,\r\n        uint256 _prizeNftIndex,\r\n        address _externalContract\r\n    ) {\r\n        winningRobotoIndex = _winningRobotoIndex;\r\n        prizeNftIndex = _prizeNftIndex;\r\n        externalContractAddress = _externalContract;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // IERC721Receiver Conformance Function\r\n\r\n    // @dev: Attribute names not included below because I don't need them in my function's logic.\r\n    function onERC721Received(address, address, uint256, bytes memory) public override returns(bytes4) {\r\n        require(nftCount == 0, \"Already holding NFT!\");\r\n        \r\n        nftCount++;\r\n        emit NftReceived();\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n    \r\n    // Public Functions\r\n    \r\n    // @dev: At any time before being claimed, anyone can buy the mystery NFT from this contract for 10 ETH.\r\n    function buyout() public payable {\r\n        require(!claimed, \"NFT has already been claimed!\");\r\n        require(msg.value == buyoutPrice, \"Send 10 ETH.\");\r\n        \r\n        emit BuyoutOccurred(msg.sender);\r\n        buyoutClaimerAddress = msg.sender;\r\n        _transfer();\r\n    }\r\n\r\n     // @dev: Function checks to see if your wallet holds the magic Roboto, costs 0.02 ETH.\r\n     // If so, transfers; If not, emits event and returns false.\r\n    function checkForKey() public payable returns (bool) {\r\n        require(!claimed, \"NFT has already been claimed!\");\r\n        require(msg.value == checkPrice, \"Send 0.02 ETH\");\r\n\r\n        claimAttempts++;\r\n        if (ERC721(robotosContractAddress).ownerOf(winningRobotoIndex) == msg.sender) {\r\n            emit NftCheck(msg.sender, \"is the key holder!\");\r\n            winnerAddress = msg.sender;\r\n            _transfer();\r\n            return true;\r\n        }\r\n        \r\n        emit NftCheck(msg.sender, \"was not the key holder\");\r\n        return false;\r\n    }\r\n    \r\n    // Fallback Function\r\n\r\n    // @dev: A fallback receive function in case random ETH is sent.\r\n    receive() external payable {\r\n        emit ValueReceived(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Private Function \r\n\r\n    // @dev: Tranfers the prize NFT stored in the contract and sets `claimed` to true, essentially ending the functionality of this contract.\r\n    function _transfer() internal {\r\n        emit TransferNFTToClaimer(msg.sender);\r\n        ERC721(externalContractAddress).safeTransferFrom(address(this), msg.sender, prizeNftIndex);\r\n        claimed = true;\r\n        nftCount --;\r\n    }\r\n    \r\n    // Ownable Function\r\n    \r\n    // @dev: Allows the owner of this contract to withdraw any funds accrued from usage.\r\n    function returnFunds() public onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        uint256 p1bal = wmul(balance, 0.9 ether);\r\n        uint256 p2bal = wmul(balance, 0.1 ether);\r\n        \r\n        require(payable(p1).send(p1bal));\r\n        require(payable(p2).send(p2bal));\r\n        \r\n        emit FundsWithdrawn(\"Paid:\", p1bal, p2bal);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_winningRobotoIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prizeNftIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_externalContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"BuyoutOccurred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_str\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_p1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_p2\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_checker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"NftCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NftReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_keyHolder\",\"type\":\"address\"}],\"name\":\"TransferNFTToClaimer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ValueReceived\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyout\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyoutClaimerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyoutPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkForKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAttempts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"robotosContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"RobotoPlayerOne","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000175f00000000000000000000000000000000000000000000000000000000000013580000000000000000000000002acab3dea77832c09420663b0e1cb386031ba17b","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d2dcd8273b4b129bac6c815f449d917f6cc7f010f91497c643be3f85ae3d5100"}]}