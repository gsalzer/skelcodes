{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"DiggVotingShare.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"ISett.sol\\\";\\nimport \\\"IGeyser.sol\\\";\\nimport \\\"IUniswapV2Pair.sol\\\";\\nimport \\\"ICToken.sol\\\";\\n\\nimport \\\"SafeMath.sol\\\";\\n\\ncontract DiggVotingShare {\\n    using SafeMath for uint256;\\n\\n    IERC20 constant digg = IERC20(0x798D1bE841a82a273720CE31c822C61a67a601C3);\\n    ISett constant sett_digg =\\n        ISett(0x7e7E112A68d8D2E221E11047a72fFC1065c38e1a);\\n\\n    //Digg is token1\\n    IUniswapV2Pair constant digg_wBTC_UniV2 =\\n        IUniswapV2Pair(0xE86204c4eDDd2f70eE00EAd6805f917671F56c52);\\n    ISett constant sett_digg_wBTC_UniV2 =\\n        ISett(0xC17078FDd324CC473F8175Dc5290fae5f2E84714);\\n    IGeyser constant geyser_digg_wBTC_UniV2 =\\n        IGeyser(0x0194B5fe9aB7e0C43a08aCbb771516fc057402e7);\\n\\n    //Digg is token1\\n    IUniswapV2Pair constant digg_wBTC_SLP =\\n        IUniswapV2Pair(0x9a13867048e01c663ce8Ce2fE0cDAE69Ff9F35E3);\\n    ISett constant sett_digg_wBTC_SLP =\\n        ISett(0x88128580ACdD9c04Ce47AFcE196875747bF2A9f6);\\n    IGeyser constant geyser_digg_wBTC_SLP =\\n        IGeyser(0x7F6FE274e172AC7d096A7b214c78584D99ca988B);\\n\\n    // Rari pool - fDIGG-22\\n    ICToken constant fDIGG =\\n        ICToken(0x792a676dD661E2c182435aaEfC806F1d4abdC486);\\n\\n    function decimals() external pure returns (uint8) {\\n        return uint8(9);\\n    }\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"Digg Voting Share\\\";\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return \\\"Digg VS\\\";\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return digg.totalSupply();\\n    }\\n\\n    function uniswapBalanceOf(address _voter) external view returns(uint256) {\\n        return _uniswapBalanceOf(_voter);\\n    }\\n    function sushiswapBalanceOf(address _voter) external view returns(uint256) {\\n        return _sushiswapBalanceOf(_voter);\\n    }\\n    function diggBalanceOf(address _voter) external view returns(uint256) {\\n        return _diggBalanceOf(_voter);\\n    }\\n    function rariBalanceOf(address _voter) external view returns(uint256) {\\n        return _rariBalanceOf(_voter);\\n    }\\n\\n    /*\\n        The voter can have Digg in Uniswap in 3 configurations:\\n         * Staked bUni-V2 in Geyser\\n         * Unstaked bUni-V2 (same as staked Uni-V2 in Sett)\\n         * Unstaked Uni-V2\\n        The top two correspond to more than 1 Uni-V2, so they are multiplied by pricePerFullShare.\\n        After adding all 3 balances we calculate how much DIGG it corresponds to using the pool's reserves.\\n    */\\n    function _uniswapBalanceOf(address _voter) internal view returns (uint256) {\\n        uint256 bUniV2PricePerShare = sett_digg_wBTC_UniV2\\n            .getPricePerFullShare();\\n        (, uint112 reserve1, ) = digg_wBTC_UniV2.getReserves();\\n        uint256 totalUniBalance = digg_wBTC_UniV2.balanceOf(_voter) +\\n            (sett_digg_wBTC_UniV2.balanceOf(_voter) * bUniV2PricePerShare) /\\n            1e18 +\\n            (geyser_digg_wBTC_UniV2.totalStakedFor(_voter) *\\n                bUniV2PricePerShare) /\\n            1e18;\\n        return (totalUniBalance * reserve1) / digg_wBTC_UniV2.totalSupply();\\n    }\\n\\n    /*\\n        The voter can have Digg in Sushiswap in 3 configurations:\\n         * Staked bSushi-V2 in Geyser\\n         * Unstaked bSushi-V2 (same as staked Sushi-V2 in Sett)\\n         * Unstaked Sushi-V2\\n        The top two correspond to more than 1 Sushi-V2, so they are multiplied by pricePerFullShare.\\n        After adding all 3 balances we calculate how much DIGG it corresponds to using the pool's reserves.\\n    */\\n    function _sushiswapBalanceOf(address _voter)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 bSLPPricePerShare = sett_digg_wBTC_SLP.getPricePerFullShare();\\n        (, uint112 reserve1, ) = digg_wBTC_SLP.getReserves();\\n        uint256 totalSLPBalance = digg_wBTC_SLP.balanceOf(_voter) +\\n            (sett_digg_wBTC_SLP.balanceOf(_voter) * bSLPPricePerShare) /\\n            1e18 +\\n            (geyser_digg_wBTC_SLP.totalStakedFor(_voter) *\\n                bSLPPricePerShare) /\\n            1e18;\\n        return (totalSLPBalance * reserve1) / digg_wBTC_SLP.totalSupply();\\n    }\\n\\n    /*\\n        The voter can have regular Digg in 2 configurations (There is no Digg or bDigg geyser):\\n         * Unstaked bDigg (same as staked Digg in Sett)\\n         * Unstaked Digg\\n    */\\n    function _diggBalanceOf(address _voter) internal view returns (uint256) {\\n        uint256 bDiggPricePerShare = sett_digg.balance().mul(1e18).div(sett_digg.totalSupply());\\n        return\\n            digg.balanceOf(_voter) +\\n            (sett_digg.balanceOf(_voter) * bDiggPricePerShare) /\\n            1e18;\\n    }\\n\\n    /*\\n        The voter may have deposited DIGG into the rari pool:\\n         * check current rate\\n         * balanceOf fDigg\\n    */\\n    function _rariBalanceOf(address _voter) internal view returns (uint256) {\\n        uint256 rate = fDIGG.exchangeRateStored();\\n        return (fDIGG.balanceOf(_voter) * rate) / 1e18;\\n    }\\n\\n    function balanceOf(address _voter) external view returns (uint256) {\\n        return\\n            _diggBalanceOf(_voter) +\\n            _uniswapBalanceOf(_voter) +\\n            _sushiswapBalanceOf(_voter) +\\n            _rariBalanceOf(_voter);\\n    }\\n\\n    constructor() {}\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"ISett.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISett {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balance() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function getPricePerFullShare() external view returns (uint256);\\n\\n    function deposit(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"IGeyser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IGeyser {\\n    function totalStakedFor(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Pair {\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n}\\n\"\r\n    },\r\n    \"ICToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICToken {\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"diggBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"rariBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"sushiswapBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"uniswapBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DiggVotingShare","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}