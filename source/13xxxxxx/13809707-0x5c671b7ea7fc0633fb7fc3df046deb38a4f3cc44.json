{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBEP20TokenCloned {\r\n    // initialize cloned token just for BEP20TokenCloned\r\n    function initialize(address newOwner, string calldata name, string calldata symbol, uint8 decimals) external;\r\n    function mint(address user, uint256 amount) external;\r\n    function burnFrom(address account, uint256 amount) external returns(bool);\r\n    function burn(uint256 amount) external returns(bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create2(0, ptr, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            predicted := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt)\r\n        internal\r\n        view\r\n        returns (address predicted)\r\n    {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n\r\n    struct AddressSet {\r\n        // Storage of set values\r\n        address[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (address => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        if (!contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            address lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns 1-based index of value in the set. O(1).\r\n     */\r\n    function indexOf(AddressSet storage set, address value) internal view returns (uint256) {\r\n        return set._indexes[value];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    /* will use initialize instead\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    */\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract CallistoBridge is Ownable {\r\n    using TransferHelper for address;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet authorities; // authority has to sign claim transaction (message)\r\n\r\n    address constant MAX_NATIVE_COINS = address(31); // addresses from address(1) to MAX_NATIVE_COINS are considered as native coins \r\n                                            // CLO = address(1)\r\n    struct Token {\r\n        address token;  // foreign token address\r\n        bool isWrapped; // is native token wrapped of foreign\r\n    }\r\n\r\n    struct Upgrade {\r\n        address newContract;\r\n        uint64  validFrom;\r\n    }\r\n\r\n    uint256 public threshold;   // minimum number of signatures required to approve swap\r\n    address public tokenImplementation;    // implementation of wrapped token\r\n    address public feeTo; // send fee to this address\r\n    bool public frozen; // if frozen - swap will not work\r\n    uint256 public wrapNonce;   // the last nonce used to create wrapped token address begin with 0xCC.... \r\n    mapping(uint256 => mapping(bytes32 => bool)) public isTxProcessed;    // chainID => txID => isProcessed\r\n    mapping(uint256 => mapping(address => Token)) public tokenPair;       // chainID => native token address => Token struct\r\n    mapping(uint256 => mapping(address => address)) public tokenForeign;  // chainID => foreign token address => native token\r\n    mapping(address => uint256) public tokenDeposits;  // amount of tokens were deposited by users\r\n    mapping(address => bool) public isFreezer;  // addresses that have right to freeze contract \r\n    uint256 public setupMode;   // time when setup mode will start, 0 if disable\r\n    Upgrade public upgradeData;\r\n    address public founders;\r\n    address public requiredAuthority;   // authority address that MUST sign swap transaction\r\n\r\n    event SetAuthority(address authority, bool isEnable);\r\n    event SetFeeTo(address previousFeeTo, address newFeeTo);\r\n    event SetThreshold(uint256 threshold);\r\n    event Deposit(address indexed token, address indexed sender, uint256 value, uint256 toChainId, address toToken);\r\n    event Claim(address indexed token, address indexed to, uint256 value, bytes32 txId, uint256 fromChainId, address fromToken);\r\n    event Fee(address indexed sender, uint256 fee);\r\n    event CreatePair(address toToken, bool isWrapped, address fromToken, uint256 fromChainId);\r\n    event Frozen(bool status);\r\n    event RescuedERC20(address token, address to, uint256 value);\r\n    event SetFreezer(address freezer, bool isActive);\r\n    event SetupMode(uint time);\r\n    event UpgradeRequest(address newContract, uint256 validFrom);\r\n    event BridgeToContract(address indexed token, address indexed sender, uint256 value, uint256 toChainId, address toToken, address toContract, bytes data);\r\n    event ClaimToContract(address indexed token, address indexed to, uint256 value, bytes32 txId, uint256 fromChainId, address fromToken, address toContract);\r\n\r\n    // run only once from proxy\r\n    function initialize(address newOwner, address newFounders, address _tokenImplementation) external {\r\n        require(newOwner != address(0) && newFounders != address(0) && founders == address(0)); // run only once\r\n        _owner = newOwner;\r\n        founders = newFounders;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n        require(_tokenImplementation != address(0), \"Wrong tokenImplementation\");\r\n        tokenImplementation = _tokenImplementation;\r\n        feeTo = msg.sender;\r\n        threshold = 1;\r\n        setupMode = 1; // allow setup after deployment\r\n    }\r\n    /*\r\n    constructor (address _tokenImplementation) {\r\n        require(_tokenImplementation != address(0), \"Wrong tokenImplementation\");\r\n        tokenImplementation = _tokenImplementation;\r\n        feeTo = msg.sender;\r\n        threshold = 1;\r\n    }\r\n    */\r\n    modifier notFrozen() {\r\n        require(!frozen, \"Bridge is frozen\");\r\n        _;\r\n    }\r\n\r\n    // allowed only in setup mode\r\n    modifier onlySetup() {\r\n        uint256 mode = setupMode; //use local variable to save gas\r\n        require(mode != 0 && mode < block.timestamp, \"Not in setup mode\");\r\n        _;\r\n    }\r\n\r\n    function upgradeTo() external view returns(address newContract) {\r\n        Upgrade memory upg = upgradeData;\r\n        require(upg.validFrom < block.timestamp && upg.newContract != address(0), \"Upgrade not allowed\");\r\n        newContract = upg.newContract;\r\n    }\r\n\r\n    function requestUpgrade(address newContract) external onlyOwner {\r\n        require(newContract != address(0), \"Zero address\");\r\n        uint256 validFrom = block.timestamp + 3 days;\r\n        upgradeData = Upgrade(newContract, uint64(validFrom));\r\n        emit UpgradeRequest(newContract, validFrom);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n\r\n    function transferOwnership(address newOwner) public {\r\n        require(founders == msg.sender, \"Ownable: caller is not the founders\");\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function ChangeFounder(address newFounders) public {\r\n        require(founders == msg.sender, \"caller is not the founders\");\r\n        require(newFounders != address(0), \"new owner is the zero address\");\r\n        emit OwnershipTransferred(founders, newFounders);\r\n        founders = newFounders;\r\n    }\r\n\r\n    // get number of authorities\r\n    function getAuthoritiesNumber() external view returns(uint256) {\r\n        return authorities.length();\r\n    }\r\n\r\n    // returns list of authorities addresses\r\n    function getAuthorities() external view returns(address[] memory) {\r\n        return authorities._values;\r\n    }\r\n\r\n    // Owner or Authority may freeze bridge in case of anomaly detection\r\n    function freeze() external {\r\n        require(msg.sender == owner() || authorities.contains(msg.sender) || isFreezer[msg.sender]);\r\n        frozen = true;\r\n        emit Frozen(true);\r\n    }\r\n\r\n    // Only owner can manually unfreeze contract\r\n    function unfreeze() external onlyOwner onlySetup {\r\n        frozen = false;\r\n        emit Frozen(false);\r\n    }\r\n\r\n    // add authority\r\n    function setFreezer(address freezer, bool isActive) external onlyOwner {\r\n        require(freezer != address(0), \"Zero address\");\r\n        isFreezer[freezer] = isActive;\r\n        emit SetFreezer(freezer, isActive);\r\n    }\r\n\r\n    // add authority\r\n    function addAuthority(address authority) external onlyOwner onlySetup {\r\n        require(authority != address(0), \"Zero address\");\r\n        require(authorities.length() < 255, \"Too many authorities\");\r\n        require(authorities.add(authority), \"Authority already added\");\r\n        emit SetAuthority(authority, true);\r\n    }\r\n\r\n    // remove authority\r\n    function removeAuthority(address authority) external onlyOwner {\r\n        require(authorities.remove(authority), \"Authority does not exist\");\r\n        emit SetAuthority(authority, false);\r\n    }\r\n\r\n    // set authority address that MUST sign claim request\r\n    function setRequiredAuthority(address authority) external onlyOwner onlySetup {\r\n        requiredAuthority = authority;\r\n    }\r\n\r\n    // set fee receiver address\r\n    function setFeeTo(address newFeeTo) external onlyOwner onlySetup {\r\n        require(newFeeTo != address(0), \"Zero address\");\r\n        address previousFeeTo = feeTo;\r\n        feeTo = newFeeTo;\r\n        emit SetFeeTo(previousFeeTo, newFeeTo);\r\n    }\r\n\r\n    // set threshold - minimum number of signatures required to approve swap\r\n    function setThreshold(uint256 _threshold) external onlyOwner onlySetup {\r\n        require(threshold != 0 && threshold <= authorities.length(), \"Wrong threshold\");\r\n        threshold = _threshold;\r\n        emit SetThreshold(threshold);\r\n    }\r\n\r\n    function disableSetupMode() external onlyOwner {\r\n        setupMode = 0;\r\n        emit SetupMode(0);\r\n    }\r\n\r\n    function enableSetupMode() external onlyOwner {\r\n        setupMode = block.timestamp + 1 days;\r\n        emit SetupMode(setupMode);\r\n    }\r\n\r\n    // returns `nonce` to use in `createWrappedToken()` to create address starting with 0xCC.....\r\n    function calculateNonce() external view returns(uint256 nonce, address addr) {\r\n        nonce = wrapNonce;\r\n        address implementation = tokenImplementation;\r\n        while (true) {\r\n            nonce++;\r\n            addr = Clones.predictDeterministicAddress(implementation, bytes32(nonce));\r\n            if (uint160(addr) & uint160(0xfF00000000000000000000000000000000000000) == uint160(0xCc00000000000000000000000000000000000000))\r\n                break;\r\n        }\r\n    }\r\n\r\n    function rescueERC20(address token, address to) external onlyOwner {\r\n        uint256 value = IBEP20TokenCloned(token).balanceOf(address(this)) - tokenDeposits[token];\r\n        token.safeTransfer(to, value);\r\n        emit RescuedERC20(token, to, value);\r\n    }\r\n\r\n    // Create wrapped token for foreign token\r\n    function createWrappedToken(\r\n        address fromToken,      // foreign token address\r\n        uint256 fromChainId,    // foreign chain ID where token deployed\r\n        string memory name,     // wrapped token name\r\n        string memory symbol,   // wrapped token symbol\r\n        uint8 decimals,         // wrapped token decimals (should be the same as in original token)\r\n        uint256 nonce           // nonce to create wrapped token address begin with 0xCC.... \r\n    )\r\n        external\r\n        onlyOwner\r\n        onlySetup\r\n    {\r\n        require(fromToken != address(0), \"Wrong token address\");\r\n        require(tokenForeign[fromChainId][fromToken] == address(0), \"This token already wrapped\");\r\n        require(nonce > wrapNonce, \"Nonce must be higher then wrapNonce\");\r\n        wrapNonce = nonce;\r\n        address wrappedToken = Clones.cloneDeterministic(tokenImplementation, bytes32(nonce));\r\n        IBEP20TokenCloned(wrappedToken).initialize(owner(), name, symbol, decimals);\r\n        tokenPair[fromChainId][wrappedToken] = Token(fromToken, true);\r\n        tokenForeign[fromChainId][fromToken] = wrappedToken;\r\n        emit CreatePair(wrappedToken, true, fromToken, fromChainId); //wrappedToken - wrapped token contract address\r\n    }\r\n\r\n    /**\r\n     * @dev Create pair between existing tokens on native and foreign chains\r\n     * @param toToken token address on native chain\r\n     * @param fromToken token address on foreign chain\r\n     * @param fromChainId foreign chain ID\r\n     * @param isWrapped `true` if `toToken` is our wrapped token otherwise `false`\r\n     */\r\n    function createPair(address toToken, address fromToken, uint256 fromChainId, bool isWrapped) external onlyOwner onlySetup {\r\n        require(tokenPair[fromChainId][toToken].token == address(0), \"Pair already exist\");\r\n        tokenPair[fromChainId][toToken] = Token(fromToken, isWrapped);\r\n        tokenForeign[fromChainId][fromToken] = toToken;\r\n        emit CreatePair(toToken, isWrapped, fromToken, fromChainId);\r\n    }\r\n\r\n    /**\r\n     * @dev Delete unused pair\r\n     * @param toToken token address on native chain\r\n     * @param fromChainId foreign chain ID\r\n     */\r\n    function deletePair(address toToken, uint256 fromChainId) external onlyOwner onlySetup {\r\n        delete tokenPair[fromChainId][toToken];\r\n    }\r\n\r\n    // Move tokens through the bridge and call the contract with 'data' parameters on the destination chain\r\n    function bridgeToContract(\r\n        address receiver,   // address of token receiver on destination chain\r\n        address token,      // token that user send (if token address < 32, then send native coin)\r\n        uint256 value,      // tokens value\r\n        uint256 toChainId,  // destination chain Id where will be claimed tokens\r\n        address toContract, // this contract will be called on destination chain\r\n        bytes memory data   // this data will be passed to contract call (ABI encoded parameters)\r\n    )\r\n        external\r\n        payable\r\n        notFrozen\r\n    {\r\n        require(receiver != address(0), \"Incorrect receiver address\");\r\n        address pair_token = _deposit(token, value, toChainId);\r\n        emit BridgeToContract(token, receiver, value, toChainId, pair_token, toContract, data);\r\n    }\r\n\r\n    // Claim tokens from the bridge and call the contract with 'data' parameters\r\n    function claimToContract(\r\n        address token,          // token to receive\r\n        bytes32 txId,           // deposit transaction hash on fromChain \r\n        address to,             // user address\r\n        uint256 value,          // value of tokens\r\n        uint256 fromChainId,    // chain ID where user deposited\r\n        address toContract,     // this contract will be called on destination chain\r\n        bytes memory data,      // this data will be passed to contract call (ABI encoded parameters)\r\n        bytes[] memory sig      // authority signatures\r\n    ) \r\n        external\r\n        notFrozen\r\n    {\r\n        require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\r\n        Token memory pair = tokenPair[fromChainId][token];\r\n        require(pair.token != address(0), \"There is no pair\");\r\n        isTxProcessed[fromChainId][txId] = true;\r\n\r\n        // Check signature\r\n        address must = requiredAuthority;\r\n        bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid, toContract, data));\r\n        messageHash = prefixed(messageHash);\r\n        uint256 uniqSig;\r\n        uint256 set;    // maximum number of authorities is 255\r\n        for (uint i = 0; i < sig.length; i++) {\r\n            address authority = recoverSigner(messageHash, sig[i]);\r\n            if (authority == must) must = address(0);\r\n            uint256 index = authorities.indexOf(authority);\r\n            uint256 mask = 1 << index;\r\n            if (index != 0 && (set & mask) == 0 ) {\r\n                set |= mask;\r\n                uniqSig++;\r\n            }\r\n        }\r\n        require(threshold <= uniqSig, \"Require more signatures\");\r\n        require(must == address(0), \"The required authority does not sign\");\r\n\r\n        // Call toContract\r\n        if(isContract(toContract) && toContract != address(this)) {\r\n            if (token <= MAX_NATIVE_COINS) {\r\n                uint balance = address(this).balance;\r\n                (bool success,) = toContract.call{value: value}(data); // transfer coin back to sender (to address(this)) is not supported\r\n                if (!success && balance == address(this).balance) { // double check the coin was not spent\r\n                    to.safeTransferETH(value);  // send coin to user\r\n                }\r\n            } else {\r\n                if(pair.isWrapped) {\r\n                    IBEP20TokenCloned(token).mint(address(this), value);\r\n                } else {\r\n                    tokenDeposits[token] -= value;\r\n                }\r\n                if (IBEP20TokenCloned(token).allowance(address(this), toContract) == 0) { // should be zero\r\n                    IBEP20TokenCloned(token).approve(toContract, value);\r\n                    (bool success,) = toContract.call{value: 0}(data);\r\n                    value = IBEP20TokenCloned(token).allowance(address(this), toContract); // unused amount (the rest) = allowance\r\n                }\r\n                if (value != 0) {   // if not all value used reset approvement\r\n                    IBEP20TokenCloned(token).approve(toContract, 0);\r\n                    token.safeTransfer(to, value);   // send to user rest of tokens\r\n                }                \r\n            }\r\n        } else {    // if not contract\r\n            if (token <= MAX_NATIVE_COINS) {\r\n                to.safeTransferETH(value);\r\n            } else {\r\n                if(pair.isWrapped) {\r\n                    IBEP20TokenCloned(token).mint(to, value);\r\n                } else {\r\n                    tokenDeposits[token] -= value;\r\n                    token.safeTransfer(to, value);\r\n                }\r\n            }\r\n        }\r\n        emit ClaimToContract(token, to, value, txId, fromChainId, pair.token, toContract);\r\n    }\r\n\r\n    function depositTokens(\r\n        address receiver,   // address of token receiver on destination chain\r\n        address token,      // token that user send (if token address < 32, then send native coin)\r\n        uint256 value,      // tokens value\r\n        uint256 toChainId   // destination chain Id where will be claimed tokens\r\n    ) \r\n        external\r\n        payable\r\n        notFrozen\r\n    {\r\n        require(receiver != address(0), \"Incorrect receiver address\");\r\n        address pair_token = _deposit(token, value, toChainId);\r\n        emit Deposit(token, receiver, value, toChainId, pair_token);\r\n    }\r\n    \r\n    function depositTokens(\r\n        address token,      // token that user send (if token address < 32, then send native coin)\r\n        uint256 value,      // tokens value\r\n        uint256 toChainId   // destination chain Id where will be claimed tokens\r\n    ) \r\n        external\r\n        payable\r\n        notFrozen\r\n    {\r\n        address pair_token = _deposit(token, value, toChainId);\r\n        emit Deposit(token, msg.sender, value, toChainId, pair_token);\r\n    }\r\n    \r\n    function _deposit(\r\n        address token,      // token that user send (if token address < 32, then send native coin)\r\n        uint256 value,      // tokens value\r\n        uint256 toChainId   // destination chain Id where will be claimed tokens\r\n    ) \r\n        internal \r\n        returns (address pair_token) \r\n    {\r\n        Token memory pair = tokenPair[toChainId][token];\r\n        require(pair.token != address(0), \"There is no pair\");\r\n        pair_token = pair.token;\r\n        uint256 fee = msg.value;\r\n        if (token <= MAX_NATIVE_COINS) {\r\n            require(value <= msg.value, \"Wrong value\");\r\n            fee -= value;\r\n        } else {\r\n            if(pair.isWrapped) {\r\n                IBEP20TokenCloned(token).burnFrom(msg.sender, value);\r\n            } else {\r\n                tokenDeposits[token] += value;\r\n                token.safeTransferFrom(msg.sender, address(this), value);\r\n            }\r\n        }\r\n        if (fee != 0) {\r\n            feeTo.safeTransferETH(fee);\r\n            emit Fee(msg.sender, fee);\r\n        }\r\n    }\r\n\r\n    // claim\r\n    function claim(\r\n        address token,          // token to receive\r\n        bytes32 txId,           // deposit transaction hash on fromChain \r\n        address to,             // user address\r\n        uint256 value,          // value of tokens\r\n        uint256 fromChainId,    // chain ID where user deposited\r\n        bytes[] memory sig      // authority signatures\r\n    ) \r\n        external\r\n        notFrozen\r\n    {\r\n        require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\r\n        Token memory pair = tokenPair[fromChainId][token];\r\n        require(pair.token != address(0), \"There is no pair\");\r\n        isTxProcessed[fromChainId][txId] = true;\r\n        address must = requiredAuthority;\r\n        bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\r\n        messageHash = prefixed(messageHash);\r\n        uint256 uniqSig;\r\n        uint256 set;    // maximum number of authorities is 255\r\n        for (uint i = 0; i < sig.length; i++) {\r\n            address authority = recoverSigner(messageHash, sig[i]);\r\n            if (authority == must) must = address(0);\r\n            uint256 index = authorities.indexOf(authority);\r\n            uint256 mask = 1 << index;\r\n            if (index != 0 && (set & mask) == 0 ) {\r\n                set |= mask;\r\n                uniqSig++;\r\n            }\r\n        }\r\n        require(threshold <= uniqSig, \"Require more signatures\");\r\n        require(must == address(0), \"The required authority does not sign\");\r\n\r\n        if (token <= MAX_NATIVE_COINS) {\r\n            to.safeTransferETH(value);\r\n        } else {\r\n            if(pair.isWrapped) {\r\n                IBEP20TokenCloned(token).mint(to, value);\r\n            } else {\r\n                tokenDeposits[token] -= value;\r\n                token.safeTransfer(to, value);\r\n            }\r\n        }\r\n        emit Claim(token, to, value, txId, fromChainId, pair.token);\r\n    }\r\n\r\n    // Signature methods\r\n\r\n    function splitSignature(bytes memory sig)\r\n        internal\r\n        pure\r\n        returns (uint8 v, bytes32 r, bytes32 s)\r\n    {\r\n        require(sig.length == 65);\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n\r\n    function recoverSigner(bytes32 message, bytes memory sig)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n\r\n        (v, r, s) = splitSignature(sig);\r\n\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\r\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeToContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"}],\"name\":\"ClaimToContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWrapped\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"}],\"name\":\"CreatePair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Fee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RescuedERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnable\",\"type\":\"bool\"}],\"name\":\"SetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousFeeTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"SetFeeTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"freezer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"SetFreezer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"SetThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetupMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validFrom\",\"type\":\"uint256\"}],\"name\":\"UpgradeRequest\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFounders\",\"type\":\"address\"}],\"name\":\"ChangeFounder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"addAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"bridgeToContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"sig\",\"type\":\"bytes[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"sig\",\"type\":\"bytes[]\"}],\"name\":\"claimToContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWrapped\",\"type\":\"bool\"}],\"name\":\"createPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"createWrappedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"}],\"name\":\"deletePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableSetupMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableSetupMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"founders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorities\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthoritiesNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newFounders\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenImplementation\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFreezer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isTxProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"removeAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"requestUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredAuthority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"freezer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"setFreezer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"setRequiredAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setupMode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenForeign\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWrapped\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"validFrom\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CallistoBridge","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5411fb2ddaa0f42c0a99cfa154d2ac281cb4d4ec0cd2a3998331c334eb1010f3"}]}