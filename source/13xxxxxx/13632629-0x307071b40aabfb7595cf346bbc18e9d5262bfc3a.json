{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute.\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Quoter Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoter {\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CAaveServices.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant GELATO = 0x3CACa7b48D0573D793d3b0279b5F0029180E83b6;\\nstring constant OK = \\\"OK\\\";\\n\"\r\n    },\r\n    \"contracts/constants/CUniswapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant SWAP_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\naddress constant FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\\naddress constant QUOTER = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\nuint24 constant LOW_FEES = 500;\\nuint24 constant MEDIUM_FEES = 3000;\\nuint24 constant HIGH_FEES = 10000;\\n\"\r\n    },\r\n    \"contracts/lib/GelatoString.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.8.7;\\n\\nlibrary GelatoString {\\n    function startsWithOK(string memory _str) internal pure returns (bool) {\\n        if (\\n            bytes(_str).length >= 2 &&\\n            bytes(_str)[0] == \\\"O\\\" &&\\n            bytes(_str)[1] == \\\"K\\\"\\n        ) return true;\\n        return false;\\n    }\\n\\n    function revertWithInfo(string memory _error, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        revert(string(abi.encodePacked(_tracingInfo, _error)));\\n    }\\n\\n    function prefix(string memory _second, string memory _first)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n\\n    function suffix(string memory _first, string memory _second)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/services/aave/resolver/UniswapV3Resolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {GelatoString} from \\\"../../../lib/GelatoString.sol\\\";\\nimport {UniswapV3Data, UniswapV3Result} from \\\"../../../structs/SUniswapV3.sol\\\";\\nimport {IQuoter} from \\\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\\\";\\nimport {\\n    IUniswapV3Factory\\n} from \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\\\";\\nimport {\\n    QUOTER,\\n    LOW_FEES,\\n    MEDIUM_FEES,\\n    HIGH_FEES,\\n    FACTORY\\n} from \\\"../../../constants/CUniswapV3.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {OK} from \\\"../../../constants/CAaveServices.sol\\\";\\nimport {PoolKey} from \\\"../../../structs/SUniswapV3.sol\\\";\\n\\ncontract UniswapV3Resolver {\\n    using GelatoString for string;\\n    using Math for uint256;\\n\\n    // should be called with callstatic of etherjs,\\n    // because quoteExactInputSingle is not a view function.\\n    function multicallGetAmountsOut(UniswapV3Data[] calldata datas_)\\n        public\\n        returns (UniswapV3Result[] memory results)\\n    {\\n        results = new UniswapV3Result[](datas_.length);\\n\\n        for (uint256 i = 0; i < datas_.length; i++) {\\n            try this.getBestPool(datas_[i]) returns (\\n                UniswapV3Result memory result\\n            ) {\\n                results[i] = result;\\n            } catch Error(string memory error) {\\n                results[i] = UniswapV3Result({\\n                    id: datas_[i].id,\\n                    amountOut: 0,\\n                    fee: 0,\\n                    message: error.prefix(\\n                        \\\"UniswapV3Resolver.getBestPool failed:\\\"\\n                    )\\n                });\\n            } catch {\\n                results[i] = UniswapV3Result({\\n                    id: datas_[i].id,\\n                    amountOut: 0,\\n                    fee: 0,\\n                    message: \\\"UniswapV3Resolver.getBestPool failed:undefined\\\"\\n                });\\n            }\\n        }\\n    }\\n\\n    function getBestPool(UniswapV3Data memory data_)\\n        public\\n        returns (UniswapV3Result memory)\\n    {\\n        uint256 amountOut = _quoteExactInputSingle(data_, LOW_FEES);\\n        uint24 fee = LOW_FEES;\\n\\n        uint256 amountOutMediumFee;\\n        if (\\n            (amountOutMediumFee = _quoteExactInputSingle(data_, MEDIUM_FEES)) >\\n            amountOut\\n        ) {\\n            amountOut = amountOutMediumFee;\\n            fee = MEDIUM_FEES;\\n        }\\n\\n        uint256 amountOutHighFee;\\n        if (\\n            (amountOutHighFee = _quoteExactInputSingle(data_, HIGH_FEES)) >\\n            amountOut\\n        ) {\\n            amountOut = amountOutHighFee;\\n            fee = HIGH_FEES;\\n        }\\n\\n        return\\n            UniswapV3Result({\\n                id: data_.id,\\n                amountOut: amountOut,\\n                fee: fee,\\n                message: OK\\n            });\\n    }\\n\\n    function _quoteExactInputSingle(UniswapV3Data memory data_, uint24 fee_)\\n        internal\\n        returns (uint256)\\n    {\\n        PoolKey memory poolKey = _getPoolKey(\\n            data_.tokenIn,\\n            data_.tokenOut,\\n            fee_\\n        );\\n        if (\\n            IUniswapV3Factory(FACTORY).getPool(\\n                poolKey.token0,\\n                poolKey.token1,\\n                poolKey.fee\\n            ) == address(0)\\n        ) return 0;\\n        return\\n            IQuoter(QUOTER).quoteExactInputSingle(\\n                data_.tokenIn,\\n                data_.tokenOut,\\n                fee_,\\n                data_.amountIn,\\n                0\\n            );\\n    }\\n\\n    function _getPoolKey(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) internal pure returns (PoolKey memory) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SUniswapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nstruct UniswapV3Result {\\n    bytes32 id;\\n    uint256 amountOut;\\n    uint24 fee;\\n    string message;\\n}\\n\\nstruct UniswapV3Data {\\n    bytes32 id;\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amountIn;\\n}\\n\\nstruct PoolKey {\\n    address token0;\\n    address token1;\\n    uint24 fee;\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct UniswapV3Data\",\"name\":\"data_\",\"type\":\"tuple\"}],\"name\":\"getBestPool\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct UniswapV3Result\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct UniswapV3Data[]\",\"name\":\"datas_\",\"type\":\"tuple[]\"}],\"name\":\"multicallGetAmountsOut\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct UniswapV3Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapV3Resolver","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}