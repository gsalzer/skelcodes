{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/farm/ERC721Farm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\nimport '@solidstate/contracts/token/ERC721/IERC721.sol';\\nimport '@solidstate/contracts/token/ERC721/IERC721Receiver.sol';\\nimport '@solidstate/contracts/utils/EnumerableSet.sol';\\n\\nimport '../token/IMagic.sol';\\n\\ncontract ERC721Farm is IERC721Receiver {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    address private immutable MAGIC;\\n    address private immutable ERC721_CONTRACT;\\n    uint256 public immutable EXPIRATION;\\n    uint256 private immutable RATE;\\n\\n    mapping(address => EnumerableSet.UintSet) private _deposits;\\n    mapping(address => mapping(uint256 => uint256)) public depositBlocks;\\n\\n    constructor(\\n        address magic,\\n        address erc721,\\n        uint256 rate,\\n        uint256 expiration\\n    ) {\\n        MAGIC = magic;\\n        ERC721_CONTRACT = erc721;\\n        RATE = rate;\\n        EXPIRATION = block.number + expiration;\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    function depositsOf(address account)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        EnumerableSet.UintSet storage depositSet = _deposits[account];\\n        uint256[] memory tokenIds = new uint256[](depositSet.length());\\n\\n        for (uint256 i; i < depositSet.length(); i++) {\\n            tokenIds[i] = depositSet.at(i);\\n        }\\n\\n        return tokenIds;\\n    }\\n\\n    function calculateRewards(address account, uint256[] memory tokenIds)\\n        public\\n        view\\n        returns (uint256[] memory rewards)\\n    {\\n        rewards = new uint256[](tokenIds.length);\\n\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            rewards[i] =\\n                RATE *\\n                (_deposits[account].contains(tokenId) ? 1 : 0) *\\n                (Math.min(block.number, EXPIRATION) -\\n                    depositBlocks[account][tokenId]);\\n        }\\n    }\\n\\n    function claimRewards(uint256[] calldata tokenIds) public {\\n        uint256 reward;\\n        uint256 block = Math.min(block.number, EXPIRATION);\\n\\n        uint256[] memory rewards = calculateRewards(msg.sender, tokenIds);\\n\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            reward += rewards[i];\\n            depositBlocks[msg.sender][tokenIds[i]] = block;\\n        }\\n\\n        if (reward > 0) {\\n            IMagic(MAGIC).mint(msg.sender, reward);\\n        }\\n    }\\n\\n    function deposit(uint256[] calldata tokenIds) external {\\n        claimRewards(tokenIds);\\n\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            IERC721(ERC721_CONTRACT).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                tokenIds[i],\\n                ''\\n            );\\n\\n            _deposits[msg.sender].add(tokenIds[i]);\\n        }\\n    }\\n\\n    function withdraw(uint256[] calldata tokenIds) external {\\n        claimRewards(tokenIds);\\n\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            require(\\n                _deposits[msg.sender].contains(tokenIds[i]),\\n                'ERC721Farm: token not deposited'\\n            );\\n\\n            _deposits[msg.sender].remove(tokenIds[i]);\\n\\n            IERC721(ERC721_CONTRACT).safeTransferFrom(\\n                address(this),\\n                msg.sender,\\n                tokenIds[i],\\n                ''\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC165} from '../../introspection/IERC165.sol';\\nimport {IERC721Internal} from './IERC721Internal.sol';\\n\\n/**\\n * @notice ERC721 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721 is IERC721Internal, IERC165 {\\n  /**\\n   * @notice query the balance of given address\\n   * @return balance quantity of tokens held\\n   */\\n  function balanceOf (\\n    address account\\n  ) external view returns (uint256 balance);\\n\\n  /**\\n   * @notice query the owner of given token\\n   * @param tokenId token to query\\n   * @return owner token owner\\n   */\\n  function ownerOf (\\n    uint256 tokenId\\n  ) external view returns (address owner);\\n\\n  /**\\n   * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n   * @param from sender of token\\n   * @param to receiver of token\\n   * @param tokenId token id\\n   */\\n  function safeTransferFrom (\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external payable;\\n\\n  /**\\n   * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n   * @param from sender of token\\n   * @param to receiver of token\\n   * @param tokenId token id\\n   * @param data data payload\\n   */\\n  function safeTransferFrom (\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external payable;\\n\\n  /**\\n   * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\\n   * @param from sender of token\\n   * @param to receiver of token\\n   * @param tokenId token id\\n   */\\n  function transferFrom (\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external payable;\\n\\n  /**\\n   * @notice grant approval to given account to spend token\\n   * @param operator address to be approved\\n   * @param tokenId token to approve\\n   */\\n  function approve (\\n    address operator,\\n    uint256 tokenId\\n  ) external payable;\\n\\n  /**\\n   * @notice get approval status for given token\\n   * @param tokenId token to query\\n   * @return operator address approved to spend token\\n   */\\n  function getApproved (\\n    uint256 tokenId\\n  ) external view returns (address operator);\\n\\n  /**\\n   * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\\n   * @param operator address to be approved\\n   * @param status approval status\\n   */\\n  function setApprovalForAll (\\n    address operator,\\n    bool status\\n  ) external;\\n\\n  /**\\n   * @notice query approval status of given operator with respect to given address\\n   * @param account address to query for approval granted\\n   * @param operator address to query for approval received\\n   * @return status whether operator is approved to spend tokens held by account\\n   */\\n  function isApprovedForAll (\\n    address account,\\n    address operator\\n  ) external view returns (bool status);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n  function onERC721Received (\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    // 1-indexed to allow 0 to signify nonexistence\\n    mapping (bytes32 => uint) _indexes;\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function at (\\n    Bytes32Set storage set,\\n    uint index\\n  ) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  function at (\\n    AddressSet storage set,\\n    uint index\\n  ) internal view returns (address) {\\n    return address(uint160(uint(_at(set._inner, index))));\\n  }\\n\\n  function at (\\n    UintSet storage set,\\n    uint index\\n  ) internal view returns (uint) {\\n    return uint(_at(set._inner, index));\\n  }\\n\\n  function contains (\\n    Bytes32Set storage set,\\n    bytes32 value\\n  ) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function contains (\\n    AddressSet storage set,\\n    address value\\n  ) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint(uint160(value))));\\n  }\\n\\n  function contains (\\n    UintSet storage set,\\n    uint value\\n  ) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function indexOf (\\n    Bytes32Set storage set,\\n    bytes32 value\\n  ) internal view returns (uint) {\\n    return _indexOf(set._inner, value);\\n  }\\n\\n  function indexOf (\\n    AddressSet storage set,\\n    address value\\n  ) internal view returns (uint) {\\n    return _indexOf(set._inner, bytes32(uint(uint160(value))));\\n  }\\n\\n  function indexOf (\\n    UintSet storage set,\\n    uint value\\n  ) internal view returns (uint) {\\n    return _indexOf(set._inner, bytes32(value));\\n  }\\n\\n  function length (\\n    Bytes32Set storage set\\n  ) internal view returns (uint) {\\n    return _length(set._inner);\\n  }\\n\\n  function length (\\n    AddressSet storage set\\n  ) internal view returns (uint) {\\n    return _length(set._inner);\\n  }\\n\\n  function length (\\n    UintSet storage set\\n  ) internal view returns (uint) {\\n    return _length(set._inner);\\n  }\\n\\n  function add (\\n    Bytes32Set storage set,\\n    bytes32 value\\n  ) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function add (\\n    AddressSet storage set,\\n    address value\\n  ) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint(uint160(value))));\\n  }\\n\\n  function add (\\n    UintSet storage set,\\n    uint value\\n  ) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove (\\n    Bytes32Set storage set,\\n    bytes32 value\\n  ) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function remove (\\n    AddressSet storage set,\\n    address value\\n  ) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint(uint160(value))));\\n  }\\n\\n  function remove (\\n    UintSet storage set,\\n    uint value\\n  ) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function _at (\\n    Set storage set,\\n    uint index\\n  ) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  function _contains (\\n    Set storage set,\\n    bytes32 value\\n  ) private view returns (bool) {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _indexOf (\\n    Set storage set,\\n    bytes32 value\\n  ) private view returns (uint) {\\n    unchecked {\\n      return set._indexes[value] - 1;\\n    }\\n  }\\n\\n  function _length (\\n    Set storage set\\n  ) private view returns (uint) {\\n    return set._values.length;\\n  }\\n\\n  function _add (\\n    Set storage set,\\n    bytes32 value\\n  ) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove (\\n    Set storage set,\\n    bytes32 value\\n  ) private returns (bool) {\\n    uint valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint index = valueIndex - 1;\\n      bytes32 last = set._values[set._values.length - 1];\\n\\n      // move last value to now-vacant index\\n\\n      set._values[index] = last;\\n      set._indexes[last] = index + 1;\\n\\n      // clear last index\\n\\n      set._values.pop();\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/token/IMagic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@solidstate/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IMagic is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 {\\n  /**\\n   * @notice query whether contract has registered support for given interface\\n   * @param interfaceId interface id\\n   * @return bool whether interface is supported\\n   */\\n  function supportsInterface (\\n    bytes4 interfaceId\\n  ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Partial ERC721 interface needed by internal functions\\n */\\ninterface IERC721Internal {\\n  event Transfer (\\n    address indexed from,\\n    address indexed to,\\n    uint256 indexed tokenId\\n  );\\n\\n  event Approval (\\n    address indexed owner,\\n    address indexed operator,\\n    uint256 indexed tokenId\\n  );\\n\\n  event ApprovalForAll (\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Internal} from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n  /**\\n   * @notice query the total minted token supply\\n   * @return token supply\\n   */\\n  function totalSupply () external view returns (uint256);\\n\\n  /**\\n   * @notice query the token balance of given account\\n   * @param account address to query\\n   * @return token balance\\n   */\\n  function balanceOf (\\n    address account\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice query the allowance granted from given holder to given spender\\n   * @param holder approver of allowance\\n   * @param spender recipient of allowance\\n   * @return token allowance\\n   */\\n  function allowance (\\n    address holder,\\n    address spender\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice grant approval to spender to spend tokens\\n   * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n   * @param spender recipient of allowance\\n   * @param amount quantity of tokens approved for spending\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function approve (\\n    address spender,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transfer (\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient on behalf of given holder\\n   * @param holder holder of tokens prior to transfer\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transferFrom (\\n    address holder,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"magic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EXPIRATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"calculateRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositsOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC721Farm","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b0c7a3ba49c7a6eaba6cd4a96c55a1391070ac9a000000000000000000000000ff9c1b15b16263c61d017ee9f65c50e4ae0113d700000000000000000000000000000000000000000000000002501e734690aaaa000000000000000000000000000000000000000000000000000000000002bf20","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}