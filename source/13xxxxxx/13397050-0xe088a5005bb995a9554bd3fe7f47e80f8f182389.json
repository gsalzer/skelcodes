{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\npragma experimental ABIEncoderV2;\n\n\n\n\ninterface IAddressProvider {\n    function admin() external view returns (address);\n    function get_registry() external view returns (address);\n    function get_address(uint256 _id) external view returns (address);\n}\n\n\n\n\ninterface ISwaps {\n\n    ///@notice Perform an exchange using the pool that offers the best rate\n    ///@dev Prior to calling this function, the caller must approve\n    ///        this contract to transfer `_amount` coins from `_from`\n    ///        Does NOT check rates in factory-deployed pools\n    ///@param _from Address of coin being sent\n    ///@param _to Address of coin being received\n    ///@param _amount Quantity of `_from` being sent\n    ///@param _expected Minimum quantity of `_from` received\n    ///        in order for the transaction to succeed\n    ///@param _receiver Address to transfer the received tokens to\n    ///@return uint256 Amount received\n    function exchange_with_best_rate(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint256 _expected,\n        address _receiver\n    ) external payable returns (uint256);\n\n\n    ///@notice Perform an exchange using a specific pool\n    ///@dev Prior to calling this function, the caller must approve\n    ///        this contract to transfer `_amount` coins from `_from`\n    ///        Works for both regular and factory-deployed pools\n    ///@param _pool Address of the pool to use for the swap\n    ///@param _from Address of coin being sent\n    ///@param _to Address of coin being received\n    ///@param _amount Quantity of `_from` being sent\n    ///@param _expected Minimum quantity of `_from` received\n    ///        in order for the transaction to succeed\n    ///@param _receiver Address to transfer the received tokens to\n    ///@return uint256 Amount received\n    function exchange(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint256 _expected,\n        address _receiver\n    ) external payable returns (uint256);\n\n\n\n    ///@notice Find the pool offering the best rate for a given swap.\n    ///@dev Checks rates for regular and factory pools\n    ///@param _from Address of coin being sent\n    ///@param _to Address of coin being received\n    ///@param _amount Quantity of `_from` being sent\n    ///@param _exclude_pools A list of up to 8 addresses which shouldn't be returned\n    ///@return Pool address, amount received\n    function get_best_rate(\n        address _from,\n        address _to,\n        uint256 _amount,\n        address[8] memory _exclude_pools\n    ) external view returns (address, uint256);\n\n\n    ///@notice Get the current number of coins received in an exchange\n    ///@dev Works for both regular and factory-deployed pools\n    ///@param _pool Pool address\n    ///@param _from Address of coin to be sent\n    ///@param _to Address of coin to be received\n    ///@param _amount Quantity of `_from` to be sent\n    ///@return Quantity of `_to` to be received\n    function get_exchange_amount(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external view returns (uint256);\n\n\n    ///@notice Get the current number of coins required to receive the given amount in an exchange\n    ///@param _pool Pool address\n    ///@param _from Address of coin to be sent\n    ///@param _to Address of coin to be received\n    ///@param _amount Quantity of `_to` to be received\n    ///@return Quantity of `_from` to be sent\n    function get_input_amount(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external view returns (uint256);\n\n\n    ///@notice Get the current number of coins required to receive the given amount in an exchange\n    ///@param _pool Pool address\n    ///@param _from Address of coin to be sent\n    ///@param _to Address of coin to be received\n    ///@param _amounts Quantity of `_to` to be received\n    ///@return Quantity of `_from` to be sent\n    function get_exchange_amounts(\n        address _pool,\n        address _from,\n        address _to,\n        uint256[] memory _amounts\n    ) external view returns (uint256[] memory);\n\n\n    ///@notice Set calculator contract\n    ///@dev Used to calculate `get_dy` for a pool\n    ///@param _pool Pool address\n    ///@return `CurveCalc` address\n    function get_calculator(address _pool) external view returns (address);\n}\n\n\n\n\ninterface IRegistry {\n    function get_lp_token(address) external view returns (address);\n    function get_pool_from_lp_token(address) external view returns (address);\n    function get_pool_name(address) external view returns(string memory);\n    function get_coins(address) external view returns (address[8] memory);\n    function get_underlying_coins(address) external view returns (address[8] memory);\n    function get_decimals(address) external view returns (uint256[8] memory);\n    function get_underlying_decimals(address) external view returns (uint256[8] memory);\n    function get_balances(address) external view returns (uint256[8] memory);\n    function get_underlying_balances(address) external view returns (uint256[8] memory);\n    function get_virtual_price_from_lp_token(address) external view returns (uint256);\n    function get_gauges(address) external view returns (address[10] memory, int128[10] memory);\n    function pool_count() external view returns (uint256);\n    function pool_list(uint256) external view returns (address);\n}\n\n\n\n\ninterface IMinter {\n    function mint(address _gaugeAddr) external;\n    function mint_many(address[8] memory _gaugeAddrs) external;\n}\n\n\n\n\ninterface IVotingEscrow {\n    function create_lock(uint256 _amount, uint256 _unlockTime) external;\n    function increase_amount(uint256 _amount) external;\n    function increase_unlock_time(uint256 _unlockTime) external;\n    function withdraw() external;\n}\n\n\n\n\ninterface IFeeDistributor {\n    function claim(address) external returns (uint256);\n}\n\n\n\n\n\n\n\n\n\ncontract CurveHelper {\n    address public constant CRV_TOKEN_ADDR = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n    address public constant CRV_3CRV_TOKEN_ADDR = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\n\n    address public constant ADDRESS_PROVIDER_ADDR = 0x0000000022D53366457F9d5E68Ec105046FC4383;\n    address public constant MINTER_ADDR = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n    address public constant VOTING_ESCROW_ADDR = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\n    address public constant FEE_DISTRIBUTOR_ADDR = 0xA464e6DCda8AC41e03616F95f4BC98a13b8922Dc;\n\n    IAddressProvider public constant AddressProvider = IAddressProvider(ADDRESS_PROVIDER_ADDR);\n    IMinter public constant Minter = IMinter(MINTER_ADDR);\n    IVotingEscrow public constant VotingEscrow = IVotingEscrow(VOTING_ESCROW_ADDR);\n    IFeeDistributor public constant FeeDistributor = IFeeDistributor(FEE_DISTRIBUTOR_ADDR);\n\n    function getSwaps() internal view returns (ISwaps) {\n        return ISwaps(AddressProvider.get_address(2));\n    }\n\n    function getRegistry() internal view returns (IRegistry) {\n        return IRegistry(AddressProvider.get_registry());\n    }\n}\n\n\n\n\ninterface ILiquidityGauge {\n    function lp_token() external view returns (address);\n    function balanceOf(address) external view returns (uint256);\n    \n    function deposit(uint256 _amount, address _receiver) external;\n    function approved_to_deposit(address _depositor, address _recipient) external view returns (bool);\n    function set_approve_deposit(address _depositor, bool _canDeposit) external;\n\n    function withdraw(uint256 _amount) external;\n}\n\n\n\n\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ncontract CurveView is CurveHelper {\n    struct LpBalance {\n        address lpToken;\n        uint256 balance;\n    }\n\n    function gaugeBalance(address _gaugeAddr, address _user) external view returns (uint256) {\n        return ILiquidityGauge(_gaugeAddr).balanceOf(_user);\n    }\n\n    function curveDepositSig(uint256 _nCoins, bool _useUnderlying) external pure returns (bytes4) {\n        if (!_useUnderlying) {\n            if (_nCoins == 2) return bytes4(keccak256(\"add_liquidity(uint256[2],uint256)\"));\n            if (_nCoins == 3) return bytes4(keccak256(\"add_liquidity(uint256[3],uint256)\"));\n            if (_nCoins == 4) return bytes4(keccak256(\"add_liquidity(uint256[4],uint256)\"));\n            if (_nCoins == 5) return bytes4(keccak256(\"add_liquidity(uint256[5],uint256)\"));\n            if (_nCoins == 6) return bytes4(keccak256(\"add_liquidity(uint256[6],uint256)\"));\n            if (_nCoins == 7) return bytes4(keccak256(\"add_liquidity(uint256[7],uint256)\"));\n            if (_nCoins == 8) return bytes4(keccak256(\"add_liquidity(uint256[8],uint256)\"));\n            revert(\"Invalid number of coins in pool.\");\n        }\n        if (_nCoins == 2) return bytes4(keccak256(\"add_liquidity(uint256[2],uint256,bool)\"));\n        if (_nCoins == 3) return bytes4(keccak256(\"add_liquidity(uint256[3],uint256,bool)\"));\n        if (_nCoins == 4) return bytes4(keccak256(\"add_liquidity(uint256[4],uint256,bool)\"));\n        if (_nCoins == 5) return bytes4(keccak256(\"add_liquidity(uint256[5],uint256,bool)\"));\n        if (_nCoins == 6) return bytes4(keccak256(\"add_liquidity(uint256[6],uint256,bool)\"));\n        if (_nCoins == 7) return bytes4(keccak256(\"add_liquidity(uint256[7],uint256,bool)\"));\n        if (_nCoins == 8) return bytes4(keccak256(\"add_liquidity(uint256[8],uint256,bool)\"));\n        revert(\"Invalid number of coins in pool.\");\n    }\n\n    function curveWithdrawSig(uint256 _nCoins, bool _useUnderlying) external pure returns (bytes4) {\n        if (!_useUnderlying) {\n            if (_nCoins == 2) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[2])\"));\n            if (_nCoins == 3) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[3])\"));\n            if (_nCoins == 4) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[4])\"));\n            if (_nCoins == 5) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[5])\"));\n            if (_nCoins == 6) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[6])\"));\n            if (_nCoins == 7) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[7])\"));\n            if (_nCoins == 8) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[8])\"));\n            revert(\"Invalid number of coins in pool.\");\n        }\n        if (_nCoins == 2) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[2],bool)\"));\n        if (_nCoins == 3) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[3],bool)\"));\n        if (_nCoins == 4) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[4],bool)\"));\n        if (_nCoins == 5) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[5],bool)\"));\n        if (_nCoins == 6) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[6],bool)\"));\n        if (_nCoins == 7) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[7],bool)\"));\n        if (_nCoins == 8) return bytes4(keccak256(\"remove_liquidity(uint256,uint256[8],bool)\"));\n        revert(\"Invalid number of coins in pool.\");\n    }\n\n    function curveWithdrawImbalanceSig(uint256 _nCoins, bool _useUnderlying) external pure returns (bytes4) {\n        if (!_useUnderlying) {\n            if (_nCoins == 2) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[2],uint256)\"));\n            if (_nCoins == 3) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[3],uint256)\"));\n            if (_nCoins == 4) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[4],uint256)\"));\n            if (_nCoins == 5) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[5],uint256)\"));\n            if (_nCoins == 6) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[6],uint256)\"));\n            if (_nCoins == 7) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[7],uint256)\"));\n            if (_nCoins == 8) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[8],uint256)\"));\n            revert(\"Invalid number of coins in pool.\");\n        }\n        if (_nCoins == 2) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[2],uint256,bool)\"));\n        if (_nCoins == 3) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[3],uint256,bool)\"));\n        if (_nCoins == 4) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[4],uint256,bool)\"));\n        if (_nCoins == 5) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[5],uint256,bool)\"));\n        if (_nCoins == 6) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[6],uint256,bool)\"));\n        if (_nCoins == 7) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[7],uint256,bool)\"));\n        if (_nCoins == 8) return bytes4(keccak256(\"remove_liquidity_imbalance(uint256[8],uint256,bool)\"));\n        revert(\"Invalid number of coins in pool.\");\n    }\n\n    function getPoolDataFromLpToken(address _lpToken) external view returns (\n        uint256 virtualPrice,\n        address pool,\n        string memory poolName,\n        address[8] memory tokens,\n        uint256[8] memory decimals,\n        uint256[8] memory balances,\n        address[8] memory underlyingTokens,\n        uint256[8] memory underlyingDecimals,\n        uint256[8] memory underlyingBalances,\n        address[10] memory gauges,\n        int128[10] memory gaugeTypes\n    ) {\n        IRegistry Registry = getRegistry();\n        virtualPrice = Registry.get_virtual_price_from_lp_token(_lpToken);\n        pool = Registry.get_pool_from_lp_token(_lpToken);\n        poolName = Registry.get_pool_name(pool);\n        tokens = Registry.get_coins(pool);\n        decimals = Registry.get_decimals(pool);\n        balances = Registry.get_balances(pool);\n        underlyingTokens = Registry.get_underlying_coins(pool);\n        underlyingDecimals = Registry.get_underlying_decimals(pool);\n        underlyingBalances = Registry.get_underlying_balances(pool);\n        (gauges, gaugeTypes) = Registry.get_gauges(pool);\n    }\n\n    function getUserLP(\n        address _user,\n        uint256 _startIndex,\n        uint256 _returnSize,\n        uint256 _loopLimit\n    ) external view returns (\n        LpBalance[] memory lpBalances,\n        uint256 nextIndex\n    ) {\n        lpBalances = new LpBalance[](_returnSize);\n        IRegistry registry = getRegistry();\n        uint256 listSize = registry.pool_count();\n        \n        uint256 nzCount = 0;\n        uint256 index = _startIndex;\n        for (uint256 i = 0; index < listSize && nzCount < _returnSize && i < _loopLimit; i++) {\n            address pool = registry.pool_list(index++);\n            address lpToken = registry.get_lp_token(pool);\n            uint256 balance = IERC20(lpToken).balanceOf(_user);\n            if (balance != 0) {\n                lpBalances[nzCount++] = LpBalance(lpToken, balance);\n            }\n        }\n\n        nextIndex = index < listSize ? index : 0;\n    }\n}\n","ABI":"[{\"inputs\":[],\"name\":\"ADDRESS_PROVIDER_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AddressProvider\",\"outputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CRV_3CRV_TOKEN_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CRV_TOKEN_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_DISTRIBUTOR_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FeeDistributor\",\"outputs\":[{\"internalType\":\"contract IFeeDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Minter\",\"outputs\":[{\"internalType\":\"contract IMinter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTING_ESCROW_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VotingEscrow\",\"outputs\":[{\"internalType\":\"contract IVotingEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nCoins\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useUnderlying\",\"type\":\"bool\"}],\"name\":\"curveDepositSig\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nCoins\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useUnderlying\",\"type\":\"bool\"}],\"name\":\"curveWithdrawImbalanceSig\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nCoins\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useUnderlying\",\"type\":\"bool\"}],\"name\":\"curveWithdrawSig\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gaugeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"gaugeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"getPoolDataFromLpToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"virtualPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"poolName\",\"type\":\"string\"},{\"internalType\":\"address[8]\",\"name\":\"tokens\",\"type\":\"address[8]\"},{\"internalType\":\"uint256[8]\",\"name\":\"decimals\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[8]\",\"name\":\"balances\",\"type\":\"uint256[8]\"},{\"internalType\":\"address[8]\",\"name\":\"underlyingTokens\",\"type\":\"address[8]\"},{\"internalType\":\"uint256[8]\",\"name\":\"underlyingDecimals\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[8]\",\"name\":\"underlyingBalances\",\"type\":\"uint256[8]\"},{\"internalType\":\"address[10]\",\"name\":\"gauges\",\"type\":\"address[10]\"},{\"internalType\":\"int128[10]\",\"name\":\"gaugeTypes\",\"type\":\"int128[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_returnSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_loopLimit\",\"type\":\"uint256\"}],\"name\":\"getUserLP\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct CurveView.LpBalance[]\",\"name\":\"lpBalances\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"nextIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CurveView","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}