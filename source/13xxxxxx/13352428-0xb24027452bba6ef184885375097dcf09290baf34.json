{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.4;\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(\r\n                oldAllowance >= value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    newAllowance\r\n                )\r\n            );\r\n        }\r\n    }\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\nabstract contract LockerTypes {\r\n    enum LockType {\r\n        ERC20,\r\n        LP\r\n    }\r\n    struct LockStorageRecord {\r\n        LockType ltype;\r\n        address token;\r\n        uint256 amount;\r\n        VestingRecord[] vestings;\r\n    }\r\n    struct VestingRecord {\r\n        uint256 unlockTime;\r\n        uint256 amountUnlock;\r\n        bool isNFT;\r\n    }\r\n    struct RegistryShare {\r\n        uint256 lockIndex;\r\n        uint256 sharePercent;\r\n        uint256 claimedAmount;\r\n    }\r\n}\r\ncontract PicipoLocker is LockerTypes {\r\n    using SafeERC20 for IERC20;\r\n    string constant name = \"Lock & Registry v0.0.2\";\r\n    uint256 constant MAX_VESTING_RECORDS_PER_LOCK = 250;\r\n    uint256 constant TOTAL_IN_PERCENT = 10000;\r\n    LockStorageRecord[] lockerStorage;\r\n    mapping(address => RegistryShare[]) public registry;\r\n    mapping(uint256 => address[]) beneficiariesInLock;\r\n    event NewLock(\r\n        address indexed erc20,\r\n        address indexed who,\r\n        uint256 lockedAmount,\r\n        uint256 lockId\r\n    );\r\n    function lockTokens(\r\n        address _ERC20,\r\n        uint256 _amount,\r\n        uint256[] memory _unlockedFrom,\r\n        uint256[] memory _unlockAmount,\r\n        address[] memory _beneficiaries,\r\n        uint256[] memory _beneficiariesShares\r\n    ) external {\r\n        require(_amount > 0, \"Cant lock 0 amount\");\r\n        require(\r\n            IERC20(_ERC20).allowance(msg.sender, address(this)) >= _amount,\r\n            \"Please approve first\"\r\n        );\r\n        require(\r\n            _getArraySum(_unlockAmount) == _amount,\r\n            \"Sum vesting records must be equal lock amount\"\r\n        );\r\n        require(\r\n            _unlockedFrom.length == _unlockAmount.length,\r\n            \"Length of periods and amounts arrays must be equal\"\r\n        );\r\n        require(\r\n            _beneficiaries.length == _beneficiariesShares.length,\r\n            \"Length of beneficiaries and shares arrays must be equal\"\r\n        );\r\n        require(\r\n            _getArraySum(_beneficiariesShares) == TOTAL_IN_PERCENT,\r\n            \"Sum of shares array must be equal to 100%\"\r\n        );\r\n        VestingRecord[] memory v = new VestingRecord[](_unlockedFrom.length);\r\n        for (uint256 i = 0; i < _unlockedFrom.length; i++) {\r\n            v[i].unlockTime = _unlockedFrom[i];\r\n            v[i].amountUnlock = _unlockAmount[i];\r\n        }\r\n        LockStorageRecord storage lock = lockerStorage.push();\r\n        lock.ltype = LockType.ERC20;\r\n        lock.token = _ERC20;\r\n        lock.amount = _amount;\r\n        for (uint256 i = 0; i < _unlockedFrom.length; i++) {\r\n            lock.vestings.push(v[i]);\r\n        }\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n            RegistryShare[] storage shares = registry[_beneficiaries[i]];\r\n            shares.push(\r\n                RegistryShare({\r\n                    lockIndex: lockerStorage.length - 1,\r\n                    sharePercent: _beneficiariesShares[i],\r\n                    claimedAmount: 0\r\n                })\r\n            );\r\n            beneficiariesInLock[lockerStorage.length - 1].push(\r\n                _beneficiaries[i]\r\n            );\r\n        }\r\n        IERC20 token = IERC20(_ERC20);\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        emit NewLock(_ERC20, msg.sender, _amount, lockerStorage.length - 1);\r\n    }\r\n    function claimTokens(uint256 _lockIndex, uint256 _desiredAmount) external {\r\n        require(_lockIndex < lockerStorage.length, \"Lock record not saved yet\");\r\n        require(_desiredAmount > 0, \"Cant claim zero\");\r\n        LockStorageRecord memory lock = lockerStorage[_lockIndex];\r\n        (\r\n            uint256 percentShares,\r\n            uint256 wasClaimed\r\n        ) = _getUserSharePercentAndClaimedAmount(msg.sender, _lockIndex);\r\n        uint256 availableAmount = (_getAvailableAmountByLockIndex(_lockIndex) *\r\n            percentShares) /\r\n            TOTAL_IN_PERCENT -\r\n            wasClaimed;\r\n        require(_desiredAmount <= availableAmount, \"Insufficient for now\");\r\n        availableAmount = _desiredAmount;\r\n        _decreaseAvailableAmount(msg.sender, _lockIndex, availableAmount);\r\n        IERC20 token = IERC20(lock.token);\r\n        token.safeTransfer(msg.sender, availableAmount);\r\n    }\r\n    function getUserShares(address _user)\r\n        external\r\n        view\r\n        returns (RegistryShare[] memory)\r\n    {\r\n        return _getUsersShares(_user);\r\n    }\r\n    function getUserBalances(address _user, uint256 _lockIndex)\r\n        external\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return _getUserBalances(_user, _lockIndex);\r\n    }\r\n    function getLockRecordByIndex(uint256 _index)\r\n        external\r\n        view\r\n        returns (LockStorageRecord memory)\r\n    {\r\n        return _getLockRecordByIndex(_index);\r\n    }\r\n    function getLockCount() external view returns (uint256) {\r\n        return lockerStorage.length;\r\n    }\r\n    function getArraySum(uint256[] memory _array)\r\n        external\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _getArraySum(_array);\r\n    }\r\n    function _decreaseAvailableAmount(\r\n        address user,\r\n        uint256 _lockIndex,\r\n        uint256 _amount\r\n    ) internal {\r\n        RegistryShare[] storage shares = registry[user];\r\n        for (uint256 i = 0; i < shares.length; i++) {\r\n            if (shares[i].lockIndex == _lockIndex) {\r\n                shares[i].claimedAmount += _amount;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    function _getArraySum(uint256[] memory _array)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 res = 0;\r\n        for (uint256 i = 0; i < _array.length; i++) {\r\n            res += _array[i];\r\n        }\r\n        return res;\r\n    }\r\n    function _getAvailableAmountByLockIndex(uint256 _lockIndex)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        VestingRecord[] memory v = lockerStorage[_lockIndex].vestings;\r\n        uint256 res = 0;\r\n        for (uint256 i = 0; i < v.length; i++) {\r\n            if (v[i].unlockTime <= block.timestamp && !v[i].isNFT) {\r\n                res += v[i].amountUnlock;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    function _getUserSharePercentAndClaimedAmount(\r\n        address _user,\r\n        uint256 _lockIndex\r\n    ) internal view returns (uint256 percent, uint256 claimed) {\r\n        RegistryShare[] memory shares = registry[_user];\r\n        for (uint256 i = 0; i < shares.length; i++) {\r\n            if (shares[i].lockIndex == _lockIndex) {\r\n                percent += shares[i].sharePercent;\r\n                claimed += shares[i].claimedAmount;\r\n            }\r\n        }\r\n        return (percent, claimed);\r\n    }\r\n    function _getUsersShares(address _user)\r\n        internal\r\n        view\r\n        returns (RegistryShare[] memory)\r\n    {\r\n        return registry[_user];\r\n    }\r\n    function _getUserBalances(address _user, uint256 _lockIndex)\r\n        internal\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        (\r\n            uint256 percentShares,\r\n            uint256 wasClaimed\r\n        ) = _getUserSharePercentAndClaimedAmount(_user, _lockIndex);\r\n        uint256 totalBalance = (lockerStorage[_lockIndex].amount *\r\n            percentShares) /\r\n            TOTAL_IN_PERCENT -\r\n            wasClaimed;\r\n        uint256 available = (_getAvailableAmountByLockIndex(_lockIndex) *\r\n            percentShares) /\r\n            TOTAL_IN_PERCENT -\r\n            wasClaimed;\r\n        return (totalBalance, available);\r\n    }\r\n    function _getVestingsByLockIndex(uint256 _index)\r\n        internal\r\n        view\r\n        returns (VestingRecord[] memory)\r\n    {\r\n        VestingRecord[] memory v = _getLockRecordByIndex(_index).vestings;\r\n        return v;\r\n    }\r\n    function _getLockRecordByIndex(uint256 _index)\r\n        internal\r\n        view\r\n        returns (LockStorageRecord memory)\r\n    {\r\n        return lockerStorage[_index];\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"}],\"name\":\"NewLock\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_desiredAmount\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_array\",\"type\":\"uint256[]\"}],\"name\":\"getArraySum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLockRecordByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"enum LockerTypes.LockType\",\"name\":\"ltype\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUnlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isNFT\",\"type\":\"bool\"}],\"internalType\":\"struct LockerTypes.VestingRecord[]\",\"name\":\"vestings\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LockerTypes.LockStorageRecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"getUserBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserShares\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LockerTypes.RegistryShare[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ERC20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_unlockedFrom\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_unlockAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_beneficiariesShares\",\"type\":\"uint256[]\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PicipoLocker","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d18d2e3bde512a6a1b6c22ce1500e09a8eab3f1ad7c69e47e9650285fed4ce66"}]}