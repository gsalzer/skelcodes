{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/borrower/feed/navfeed.sol\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.5.15 >=0.7.6;\n\n////// lib/tinlake-auth/src/auth.sol\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\n/* pragma solidity >=0.5.15; */\n\ncontract Auth {\n    mapping (address => uint256) public wards;\n    \n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"not-authorized\");\n        _;\n    }\n\n}\n\n////// lib/tinlake-math/src/math.sol\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n/* pragma solidity >=0.5.15; */\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}\n\n////// src/borrower/feed/discounting.sol\n/* pragma solidity >=0.7.6; */\n\n/* import \"tinlake-math/math.sol\"; */\n\n// contract without a state which defines the relevant formulars for the navfeed\ncontract Discounting is Math {\n\n    function calcDiscount(uint discountRate, uint fv, uint normalizedBlockTimestamp, uint maturityDate_) public pure returns (uint result) {\n        return rdiv(fv, rpow(discountRate, safeSub(maturityDate_, normalizedBlockTimestamp), ONE));\n    }\n\n    // calculate the future value based on the amount, maturityDate interestRate and recoveryRate\n    function calcFutureValue(uint loanInterestRate, uint amount, uint maturityDate_, uint recoveryRatePD_) public view returns(uint) {\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n        uint timeRemaining = 0;\n        if (maturityDate_ > nnow) {\n            timeRemaining = safeSub(maturityDate_, nnow);\n        }\n\n        return rmul(rmul(rpow(loanInterestRate, timeRemaining, ONE), amount), recoveryRatePD_);\n    }\n    function secureSub(uint x, uint y) public pure returns(uint) {\n        if(y > x) {\n            return 0;\n        }\n        return safeSub(x, y);\n    }\n\n    // normalizes a timestamp to round down to the nearest midnight (UTC)\n    function uniqueDayTimestamp(uint timestamp) public pure returns (uint) {\n        return (1 days) * (timestamp/(1 days));\n    }\n\n    function rpow(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                let xx := mul(x, x)\n                if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                let xxRound := add(xx, half)\n                if lt(xxRound, xx) { revert(0,0) }\n                x := div(xxRound, base)\n                if mod(n,2) {\n                    let zx := mul(z, x)\n                    if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                    let zxRound := add(zx, half)\n                    if lt(zxRound, zx) { revert(0,0) }\n                    z := div(zxRound, base)\n                }\n            }\n            }\n        }\n    }\n}\n\n////// src/borrower/feed/navfeed.sol\n/* pragma solidity >=0.7.6; */\n\n/* import \"tinlake-auth/auth.sol\"; */\n/* import { Discounting } from \"./discounting.sol\"; */\n\ninterface ShelfLike_1 {\n    function shelf(uint loan) external view returns (address registry, uint tokenId);\n    function nftlookup(bytes32 nftID) external returns (uint loan);\n    function loanCount() external view returns (uint);\n}\n\ninterface PileLike_1 {\n    function setRate(uint loan, uint rate) external;\n    function debt(uint loan) external view returns (uint);\n    function pie(uint loan) external returns (uint);\n    function changeRate(uint loan, uint newRate) external;\n    function loanRates(uint loan) external view returns (uint);\n    function file(bytes32, uint, uint) external;\n    function rates(uint rate) external view returns (uint, uint, uint ,uint48, uint);\n    function total() external view returns (uint);\n    function rateDebt(uint rate) external view returns (uint);\n}\n\n// The NAV Feed contract calculates the Net Asset Value of a Tinlake pool.\n// NAV is computed as the sum of all discounted future values (fv) of ongoing loans (debt > 0) in the pool.\n// The applied discountRate is dependant on the maturity data of the underlying collateral.\n// The discount decreases with the maturity date approaching.\n// To optimize the NAV calculation, the NAV is calculated as the change in discounted future values since the calculation.\n// When loans are overdue, they are locked at their fv on the maturity date.\n// They can then be written off, using the public writeoff method based on\n// the default writeoff schedule, or using the override writeoff method.\ncontract NAVFeed is Auth, Discounting {\n    PileLike_1    public pile;\n    ShelfLike_1   public shelf;\n\n    struct NFTDetails {\n        uint128 nftValues;\n        uint128 futureValue;\n        uint128 maturityDate;\n        uint128 risk;\n    }\n\n    struct RiskGroup {\n        // denominated in (10^27)\n        uint128 ceilingRatio;\n        // denominated in (10^27)\n        uint128 thresholdRatio;\n        // denominated in (10^27)\n        uint128 recoveryRatePD;\n    }\n\n    struct LoanDetails {\n        uint128 borrowed;\n        // only auth calls can move loan into different writeOff group\n        bool authWriteOff;\n    }\n\n    struct WriteOffGroup {\n        // denominated in (10^27)\n        uint128 percentage;\n        // amount of days after the maturity days that the writeoff group can be applied by default\n        uint128 overdueDays;\n    }\n\n    // nft => details\n    mapping (bytes32 => NFTDetails) public details;\n    // risk => riskGroup\n    mapping (uint => RiskGroup) public riskGroup;\n    // loan => details\n    mapping(uint => LoanDetails) public loanDetails;\n    // timestamp => bucket\n    mapping (uint => uint)      public buckets;\n\n\n    WriteOffGroup[] public writeOffGroups;\n\n    // Write-off groups will be added as rate groups to the pile with their index\n    // in the writeOffGroups array + this number\n    uint public constant WRITEOFF_RATE_GROUP_START = 1000;\n\n    // Discount rate applied on every asset's fv depending on its maturityDate.\n    // The discount decreases with the maturityDate approaching.\n    // denominated in (10^27)\n    uint public discountRate;\n\n    // latestNAV is calculated in case of borrows & repayments between epoch executions.\n    // It decreases/increases the NAV by the repaid/borrowed amount without running the NAV calculation routine.\n    // This is required for more accurate Senior & JuniorAssetValue estimations between epochs\n    uint public latestNAV;\n    uint public latestDiscount;\n    uint public lastNAVUpdate;\n\n    // overdue loans are loans which passed the maturity date but are not written-off\n    uint public overdueLoans;\n\n    // events\n    event Depend(bytes32 indexed name, address addr);\n    event File(bytes32 indexed name, uint risk_, uint thresholdRatio_, uint ceilingRatio_, uint rate_);\n    event Update(bytes32 indexed nftID, uint value);\n    event Update(bytes32 indexed nftID, uint value, uint risk);\n    event File(bytes32 indexed name, uint risk_, uint thresholdRatio_, uint ceilingRatio_,\n        uint rate_, uint recoveryRatePD_);\n    event File(bytes32 indexed name, bytes32 nftID_, uint maturityDate_);\n    event File(bytes32 indexed name, uint value);\n    event File(bytes32 indexed name, uint rate_, uint writeOffPercentage_, uint overdueDays_);\n    event WriteOff(uint indexed loan, uint indexed writeOffGroupsIndex, bool override_);\n\n    // getter functions\n    function maturityDate(bytes32 nft_)     public view returns(uint){ return uint(details[nft_].maturityDate);}\n    function risk(bytes32 nft_)             public view returns(uint){ return uint(details[nft_].risk);}\n    function nftValues(bytes32 nft_)        public view returns(uint){ return uint(details[nft_].nftValues);}\n    function futureValue(bytes32 nft_)      public view returns(uint){ return uint(details[nft_].futureValue);}\n    function ceilingRatio(uint riskID)      public view returns(uint){ return uint(riskGroup[riskID].ceilingRatio);}\n    function thresholdRatio(uint riskID)    public view returns(uint){ return uint(riskGroup[riskID].thresholdRatio);}\n    function recoveryRatePD(uint riskID)    public view returns(uint){ return uint(riskGroup[riskID].recoveryRatePD);}\n    function borrowed(uint loan)            public view returns(uint) {return uint(loanDetails[loan].borrowed);}\n\n    constructor () {\n        wards[msg.sender] = 1;\n        lastNAVUpdate = uniqueDayTimestamp(block.timestamp);\n        emit Rely(msg.sender);\n    }\n\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n    \n    // returns the ceiling of a loan\n    // the ceiling defines the maximum amount which can be borrowed\n    function ceiling(uint loan) public virtual view returns (uint) {\n        bytes32 nftID_ = nftID(loan);\n        uint initialCeiling = rmul(nftValues(nftID_), ceilingRatio(risk(nftID_)));\n\n        if (borrowed(loan) > initialCeiling) {\n            return 0;\n        }\n\n        return safeSub(initialCeiling, borrowed(loan));\n    }\n\n    // --- Administration ---\n    function depend(bytes32 contractName, address addr) external auth {\n        if (contractName == \"pile\") {pile = PileLike_1(addr);}\n        else if (contractName == \"shelf\") { shelf = ShelfLike_1(addr); }\n        else revert();\n        emit Depend(contractName, addr);\n    }\n\n    function file(bytes32 name, uint risk_, uint thresholdRatio_, uint ceilingRatio_, uint rate_, uint recoveryRatePD_) public auth  {\n        if(name == \"riskGroup\") {\n            file(\"riskGroupNFT\", risk_, thresholdRatio_, ceilingRatio_, rate_);\n            riskGroup[risk_].recoveryRatePD= toUint128(recoveryRatePD_);\n            emit File(name, risk_, thresholdRatio_, ceilingRatio_, rate_, recoveryRatePD_);\n\n        } else { revert (\"unknown name\");}\n    }\n\n    function file(bytes32 name, bytes32 nftID_, uint maturityDate_) public auth {\n        // maturity date only can be changed when there is no debt on the collateral -> futureValue == 0\n        if (name == \"maturityDate\") {\n            require((futureValue(nftID_) == 0), \"can-not-change-maturityDate-outstanding-debt\");\n            details[nftID_].maturityDate = toUint128(uniqueDayTimestamp(maturityDate_));\n            emit File(name, nftID_, maturityDate_);\n\n        } else { revert(\"unknown config parameter\");}\n    }\n\n    function file(bytes32 name, uint value) public auth {\n        if (name == \"discountRate\") {\n            uint oldDiscountRate = discountRate;\n            discountRate = value;\n            // the nav needs to be re-calculated based on the new discount rate\n            // no need to recalculate it if initialized the first time\n            if(oldDiscountRate != 0) {\n                reCalcNAV();\n            }\n            emit File(name, value);\n\n        } else { revert(\"unknown config parameter\");}\n    }\n\n    function file(bytes32 name, uint risk_, uint thresholdRatio_, uint ceilingRatio_, uint rate_) public auth {\n        if(name == \"riskGroupNFT\") {\n            require(ceilingRatio(risk_) == 0, \"risk-group-in-usage\");\n            riskGroup[risk_].thresholdRatio = toUint128(thresholdRatio_);\n            riskGroup[risk_].ceilingRatio = toUint128(ceilingRatio_);\n\n            // set interestRate for risk group\n            pile.file(\"rate\", risk_, rate_);\n            emit File(name, risk_, thresholdRatio_, ceilingRatio_, rate_);\n\n        } else { revert (\"unknown name\");}\n    }\n\n    function file(bytes32 name, uint rate_, uint writeOffPercentage_, uint overdueDays_) public auth {\n        if(name == \"writeOffGroup\") {\n            uint index = writeOffGroups.length;\n            writeOffGroups.push(WriteOffGroup(toUint128(writeOffPercentage_), toUint128(overdueDays_)));\n            pile.file(\"rate\", safeAdd(WRITEOFF_RATE_GROUP_START, index), rate_);\n            emit File(name, rate_, writeOffPercentage_, overdueDays_);\n        } else { revert (\"unknown name\");}\n    }\n\n    // --- Actions ---\n    function borrow(uint loan, uint amount) external virtual auth returns(uint navIncrease) {\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n        bytes32 nftID_ = nftID(loan);\n        uint maturityDate_ = maturityDate(nftID_);\n\n        require(ceiling(loan) >= amount, \"borrow-amount-too-high\");\n        require(maturityDate_ > nnow, \"maturity-date-is-not-in-the-future\");\n\n        if(nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n\n        // calculate amount including fixed fee if applicatable\n        (, , uint loanInterestRate, , uint fixedRate) = pile.rates(pile.loanRates(loan));\n        uint amountIncludingFixed = safeAdd(amount, rmul(amount, fixedRate));\n\n        // calculate future value FV\n        uint fv = calcFutureValue(loanInterestRate, amountIncludingFixed, maturityDate_, recoveryRatePD(risk(nftID_)));\n        details[nftID_].futureValue = toUint128(safeAdd(futureValue(nftID_), fv));\n\n        // add future value to the bucket of assets with the same maturity date\n        buckets[maturityDate_] = safeAdd(buckets[maturityDate_], fv);\n\n        // increase borrowed amount for future ceiling computations\n        loanDetails[loan].borrowed = toUint128(safeAdd(borrowed(loan), amount));\n\n        // return increase NAV amount\n        navIncrease = calcDiscount(discountRate, fv, nnow, maturityDate_);\n\n        latestDiscount = safeAdd(latestDiscount, navIncrease);\n        latestNAV = safeAdd(latestNAV, navIncrease);\n        return navIncrease;\n    }\n\n    function repay(uint loan, uint amount) external virtual auth {\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n        if (nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n\n        // In case of successful repayment the latestNAV is decreased by the repaid amount\n        bytes32 nftID_ = nftID(loan);\n        uint maturityDate_ = maturityDate(nftID_);\n\n        // case 1: repayment of a written-off loan\n        if (isLoanWrittenOff(loan)) {\n            // update nav with write-off decrease\n            latestNAV = secureSub(latestNAV, rmul(amount,\n                toUint128(writeOffGroups[pile.loanRates(loan)-WRITEOFF_RATE_GROUP_START].percentage)));\n            return;\n        }\n\n        uint debt = safeSub(pile.debt(loan), amount);\n        uint preFV = futureValue(nftID_);\n        // in case of partial repayment, compute the fv of the remaining debt and add to the according fv bucket\n        uint fv = 0;\n        uint fvDecrease = preFV;\n        if (debt != 0) {\n            (, ,uint loanInterestRate, ,) = pile.rates(pile.loanRates(loan));\n            fv = calcFutureValue(loanInterestRate, debt, maturityDate_, recoveryRatePD(risk(nftID_)));\n            if (preFV >= fv) {\n                fvDecrease = safeSub(preFV, fv);\n            } else {\n                fvDecrease = 0;\n            }\n        }\n\n        details[nftID_].futureValue = toUint128(fv);\n        // case 2: repayment of a loan before or on maturity date\n        if (maturityDate_ >= nnow) {\n            // remove future value decrease from bucket\n            buckets[maturityDate_] = safeSub(buckets[maturityDate_], fvDecrease);\n            uint discountDecrease = calcDiscount(discountRate, fvDecrease, nnow, maturityDate_);\n            latestDiscount = secureSub(latestDiscount, discountDecrease);\n            latestNAV = secureSub(latestNAV, discountDecrease);\n        } else {\n            // case 3: repayment of an overdue loan\n            overdueLoans = safeSub(overdueLoans, fvDecrease);\n            latestNAV = secureSub(latestNAV, fvDecrease);\n        }\n    }\n\n    function borrowEvent(uint loan, uint) public virtual auth {\n        uint risk_ = risk(nftID(loan));\n\n        // when issued every loan has per default interest rate of risk group 0.\n        // correct interest rate has to be set on first borrow event\n        if (pile.loanRates(loan) != risk_) {\n            // set loan interest rate to the one of the correct risk group\n            pile.setRate(loan, risk_);\n        }\n    }\n\n    function repayEvent(uint loan, uint amount) public virtual auth {}\n    function lockEvent(uint loan) public virtual auth {}\n    function unlockEvent(uint loan) public virtual auth {}\n\n    function writeOff(uint loan) public {\n        require(!loanDetails[loan].authWriteOff, \"only-auth-write-off\");\n\n        bytes32 nftID_ = nftID(loan);\n        uint maturityDate_ = maturityDate(nftID_);\n        require(maturityDate_ > 0 && loan < shelf.loanCount(), \"loan-does-not-exist\");\n\n        // can not write-off healthy loans\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n        require(maturityDate_ < nnow, \"maturity-date-in-the-future\");\n        // check the writeoff group based on the amount of days overdue\n        uint writeOffGroupIndex_ = currentValidWriteOffGroup(loan);\n\n        if (writeOffGroupIndex_ < type(uint128).max && pile.loanRates(loan) != WRITEOFF_RATE_GROUP_START + writeOffGroupIndex_) {\n            _writeOff(loan, writeOffGroupIndex_, nftID_, maturityDate_);\n            emit WriteOff(loan, writeOffGroupIndex_, false);\n        }\n    }\n\n    function overrideWriteOff(uint loan, uint writeOffGroupIndex_) public auth {\n        // can not write-off healthy loans\n        bytes32 nftID_ = nftID(loan);\n        uint maturityDate_ = maturityDate(nftID_);\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n        require(maturityDate_ < nnow, \"maturity-date-in-the-future\");\n\n        if (loanDetails[loan].authWriteOff == false) {\n            loanDetails[loan].authWriteOff = true;\n        }\n        _writeOff(loan, writeOffGroupIndex_, nftID_, maturityDate_);\n        emit WriteOff(loan, writeOffGroupIndex_, true);\n    }\n\n    function _writeOff(uint loan, uint writeOffGroupIndex_, bytes32 nftID_, uint maturityDate_) internal {\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n        // Ensure we have an up to date NAV\n        if(nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n        \n        uint latestNAV_ = latestNAV;\n\n        // first time written-off\n        if (isLoanWrittenOff(loan) == false) {\n            uint fv = futureValue(nftID_);\n            if (uniqueDayTimestamp(lastNAVUpdate) > maturityDate_) {\n                // write off after the maturity date\n                overdueLoans = secureSub(overdueLoans, fv);\n                latestNAV_ = secureSub(latestNAV_, fv);\n\n            } else {\n                // write off before or on the maturity date\n                buckets[maturityDate_] = safeSub(buckets[maturityDate_], fv);\n                uint pv = rmul(fv, rpow(discountRate, safeSub(uniqueDayTimestamp(maturityDate_), nnow), ONE));\n                latestDiscount = secureSub(latestDiscount, pv);\n                latestNAV_ = secureSub(latestNAV_, pv);\n            }\n        }\n\n        pile.changeRate(loan, WRITEOFF_RATE_GROUP_START + writeOffGroupIndex_);\n        latestNAV = safeAdd(latestNAV_, rmul(pile.debt(loan), writeOffGroups[writeOffGroupIndex_].percentage));\n    }\n\n    function isLoanWrittenOff(uint loan) public view returns(bool) {\n        return pile.loanRates(loan) >= WRITEOFF_RATE_GROUP_START;\n    }\n\n    // --- NAV calculation ---\n    function currentNAV() public view returns(uint) {\n        (uint totalDiscount, uint overdue, uint writeOffs) = currentPVs();\n        return safeAdd(totalDiscount, safeAdd(overdue, writeOffs));\n    }\n\n    function currentPVs() public view returns(uint totalDiscount, uint overdue, uint writeOffs) {\n        if (latestDiscount == 0) {\n            // all loans are overdue or writtenOff\n            return (0, overdueLoans, currentWriteOffs());\n        }\n\n        uint errPV = 0;\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n\n        // find all new overdue loans since the last update\n        // calculate the discount of the overdue loans which is needed\n        // for the total discount calculation\n        for(uint i = lastNAVUpdate; i < nnow; i = i + 1 days) {\n            uint b = buckets[i];\n            if (b != 0) {\n                errPV = safeAdd(errPV, rmul(b, rpow(discountRate, safeSub(nnow, i), ONE)));\n                overdue = safeAdd(overdue, b);\n            }\n        }\n\n        return\n        (\n            // calculate current totalDiscount based on the previous totalDiscount (optimized calculation)\n            // the overdue loans are incorrectly in this new result with their current PV and need to be removed\n            secureSub(rmul(latestDiscount, rpow(discountRate, safeSub(nnow, lastNAVUpdate), ONE)), errPV),\n            // current overdue loans not written off\n            safeAdd(overdueLoans, overdue),\n            // current write-offs loans\n            currentWriteOffs()\n        );\n    }\n\n    function currentWriteOffs() public view returns(uint) {\n        uint sum = 0;\n        for (uint i = 0; i < writeOffGroups.length; i++) {\n            // multiply writeOffGroupDebt with the writeOff rate\n            sum = safeAdd(sum, rmul(pile.rateDebt(WRITEOFF_RATE_GROUP_START + i), uint(writeOffGroups[i].percentage)));\n        }\n        return sum;\n    }\n\n    function calcUpdateNAV() public returns(uint) {\n        (uint totalDiscount, uint overdue, uint writeOffs) = currentPVs();\n\n        overdueLoans = overdue;\n        latestDiscount = totalDiscount;\n\n        latestNAV = safeAdd(safeAdd(totalDiscount, overdue), writeOffs);\n        lastNAVUpdate = uniqueDayTimestamp(block.timestamp);\n        return latestNAV;\n    }\n\n\n    // re-calculates the nav in a non-optimized way\n    // the method is not updating the NAV to latest block.timestamp\n    function reCalcNAV() public returns (uint) {\n        uint latestDiscount_ = reCalcTotalDiscount();\n\n        latestNAV = safeAdd(latestDiscount_, safeSub(latestNAV, latestDiscount));\n        latestDiscount = latestDiscount_;\n        return latestNAV;\n    }\n\n    // re-calculates the totalDiscount in a non-optimized way based on lastNAVUpdate\n    function reCalcTotalDiscount() public view returns(uint) {\n        uint latestDiscount_ = 0;\n\n        for (uint loanID = 1; loanID < shelf.loanCount(); loanID++) {\n            bytes32 nftID_ = nftID(loanID);\n            uint maturityDate_ = maturityDate(nftID_);\n\n            if (maturityDate_ < lastNAVUpdate) {\n                continue;\n            }\n\n            latestDiscount_= safeAdd(latestDiscount_, calcDiscount(discountRate,\n                futureValue(nftID_), lastNAVUpdate, maturityDate_));\n        }\n        return latestDiscount_;\n    }\n\n    function update(bytes32 nftID_,  uint value) public auth {\n        // switch of collateral risk group results in new: ceiling, threshold for existing loan\n        details[nftID_].nftValues = toUint128(value);\n        emit Update(nftID_, value);\n    }\n\n    function update(bytes32 nftID_, uint value, uint risk_) public auth {\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n        details[nftID_].nftValues  = toUint128(value);\n\n        // no change in risk group\n        if (risk_ == risk(nftID_)) {\n            return;\n        }\n\n        // nfts can only be added to risk groups that are part of the score card\n        require(thresholdRatio(risk_) != 0, \"risk group not defined in contract\");\n        details[nftID_].risk = toUint128(risk_);\n\n        // update nav -> latestNAVUpdate = now\n        if(nnow > lastNAVUpdate) {\n            calcUpdateNAV();\n        }\n\n        // switch of collateral risk group results in new: ceiling, threshold and interest rate for existing loan\n        // change to new rate interestRate immediately in pile if loan debt exists\n        uint loan = shelf.nftlookup(nftID_);\n        if (pile.pie(loan) != 0) {\n            pile.changeRate(loan, risk_);\n        }\n\n        // no currencyAmount borrowed yet\n        if (futureValue(nftID_) == 0) {\n            return;\n        }\n\n\n        uint maturityDate_ = maturityDate(nftID_);\n\n        // Changing the risk group of an nft, might lead to a new interest rate for the dependant loan.\n        // New interest rate leads to a future value.\n        // recalculation required\n        uint fvDecrease = futureValue(nftID_);\n        uint navDecrease = calcDiscount(discountRate, fvDecrease, nnow, maturityDate_);\n        buckets[maturityDate_] = safeSub(buckets[maturityDate_], fvDecrease);\n        latestDiscount = safeSub(latestDiscount, navDecrease);\n        latestNAV = safeSub(latestNAV, navDecrease);\n\n        // update latest NAV\n        // update latest Discount\n        (, ,uint loanInterestRate, ,) = pile.rates(pile.loanRates(loan));\n        details[nftID_].futureValue = toUint128(calcFutureValue(loanInterestRate, pile.debt(loan),\n            maturityDate(nftID_), recoveryRatePD(risk(nftID_))));\n        \n        uint fvIncrease =  futureValue(nftID_);\n        uint navIncrease = calcDiscount(discountRate, fvIncrease, nnow, maturityDate_);\n        buckets[maturityDate_] = safeAdd(buckets[maturityDate_], fvIncrease);\n        latestDiscount = safeAdd(latestDiscount, navIncrease);\n        latestNAV = safeAdd(latestNAV, navIncrease);\n        emit Update(nftID_, value, risk_);\n    }\n\n    // --- Utilities ---\n    // returns the threshold of a loan\n    // if the loan debt is above the loan threshold the NFT can be seized\n    function threshold(uint loan) public view returns (uint) {\n        bytes32 nftID_ = nftID(loan);\n        return rmul(nftValues(nftID_), thresholdRatio(risk(nftID_)));\n    }\n\n    // returns a unique id based on the nft registry and tokenId\n    // the nftID is used to set the risk group and value for nfts\n    function nftID(address registry, uint tokenId) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(registry, tokenId));\n    }\n\n    // returns the nftID for the underlying collateral nft\n    function nftID(uint loan) public view returns (bytes32) {\n        (address registry, uint tokenId) = shelf.shelf(loan);\n        return nftID(registry, tokenId);\n    }\n\n    // returns true if the present value of a loan is zero\n    // true if all debt is repaid or debt is 100% written-off\n    function zeroPV(uint loan) public view returns (bool) {\n        if (pile.debt(loan) == 0) {\n            return true;\n        }\n\n        uint rate = pile.loanRates(loan);\n\n        if(rate < WRITEOFF_RATE_GROUP_START) {\n            return false;\n        }\n\n        return writeOffGroups[safeSub(rate, WRITEOFF_RATE_GROUP_START)].percentage == 0;\n    }\n\n    function currentValidWriteOffGroup(uint loan) public view returns (uint) {\n        bytes32 nftID_ = nftID(loan);\n        uint maturityDate_ = maturityDate(nftID_);\n        uint nnow = uniqueDayTimestamp(block.timestamp);\n\n        uint128 lastValidWriteOff = type(uint128).max;\n        uint128 highestOverdueDays = 0;\n        // it is not guaranteed that writeOff groups are sorted by overdue days\n        for (uint128 i = 0; i < writeOffGroups.length; i++) {\n            uint128 overdueDays = writeOffGroups[i].overdueDays;\n            if (overdueDays >= highestOverdueDays && nnow >= maturityDate_ + overdueDays * 1 days) {\n                lastValidWriteOff = i;\n                highestOverdueDays = overdueDays;\n            }\n        }\n\n        // returns type(uint128).max if no write-off group is valid for this loan\n        return lastValidWriteOff;\n    }\n}\n","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Depend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"risk_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thresholdRatio_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ceilingRatio_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"risk_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thresholdRatio_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ceilingRatio_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recoveryRatePD_\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nftID_\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maturityDate_\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"writeOffPercentage_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"overdueDays_\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nftID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Update\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nftID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"risk\",\"type\":\"uint256\"}],\"name\":\"Update\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"writeOffGroupsIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"override_\",\"type\":\"bool\"}],\"name\":\"WriteOff\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WRITEOFF_RATE_GROUP_START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"navIncrease\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"borrowEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"borrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buckets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"discountRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normalizedBlockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate_\",\"type\":\"uint256\"}],\"name\":\"calcDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recoveryRatePD_\",\"type\":\"uint256\"}],\"name\":\"calcFutureValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcUpdateNAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"ceiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"riskID\",\"type\":\"uint256\"}],\"name\":\"ceilingRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentNAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPVs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overdue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"writeOffs\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"currentValidWriteOffGroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentWriteOffs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"contractName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"depend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"details\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"nftValues\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"futureValue\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maturityDate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"risk\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nftID_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate_\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"risk_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thresholdRatio_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceilingRatio_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"writeOffPercentage_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overdueDays_\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"risk_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thresholdRatio_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceilingRatio_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recoveryRatePD_\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nft_\",\"type\":\"bytes32\"}],\"name\":\"futureValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"isLoanWrittenOff\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastNAVUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestNAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loanDetails\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"borrowed\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"authWriteOff\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"lockEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nft_\",\"type\":\"bytes32\"}],\"name\":\"maturityDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"nftID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"nftID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nft_\",\"type\":\"bytes32\"}],\"name\":\"nftValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overdueLoans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"writeOffGroupIndex_\",\"type\":\"uint256\"}],\"name\":\"overrideWriteOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pile\",\"outputs\":[{\"internalType\":\"contract PileLike_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rdiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reCalcNAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reCalcTotalDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"riskID\",\"type\":\"uint256\"}],\"name\":\"recoveryRatePD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nft_\",\"type\":\"bytes32\"}],\"name\":\"risk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"riskGroup\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"ceilingRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"thresholdRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"recoveryRatePD\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rmul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"}],\"name\":\"rpow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"secureSub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shelf\",\"outputs\":[{\"internalType\":\"contract ShelfLike_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"riskID\",\"type\":\"uint256\"}],\"name\":\"thresholdRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"uniqueDayTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"unlockEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nftID_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"risk_\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nftID_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"writeOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"writeOffGroups\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"percentage\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"overdueDays\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"}],\"name\":\"zeroPV\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NAVFeed","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}