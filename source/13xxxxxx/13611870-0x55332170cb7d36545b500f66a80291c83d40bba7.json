{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LFG.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n// $$\\\\       $$$$$$$$\\\\  $$$$$$\\\\  \\n// $$ |      $$  _____|$$  __$$\\\\ \\n// $$ |      $$ |      $$ /  \\\\__|\\n// $$ |      $$$$$\\\\    $$ |$$$$\\\\ \\n// $$ |      $$  __|   $$ |\\\\_$$ |\\n// $$ |      $$ |      $$ |  $$ |\\n// $$$$$$$$\\\\ $$ |      \\\\$$$$$$  |\\n// \\\\________|\\\\__|       \\\\______/ \\n                                                                                                         \\n\\n\\ncontract LFG is Context, IERC20, Ownable {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  address burn = 0x000000000000000000000000000000000000dEaD;\\n  address public daoContractAddress;\\n  address public tokenPairAddress;\\n  address public royaltyAddress = 0x8e3E7850b360B9C152481aDd56b7A510880495e7; \\n\\n  mapping (address => uint256) private _reserveTokenBalance;\\n  mapping (address => uint256) private _circulatingTokenBalance;\\n  mapping (address => mapping (address => uint256)) private _allowances;\\n\\n  mapping (address => bool) private _isExcluded;\\n  address[] private _excluded;\\n\\n  // The highest possible number.\\n  uint256 private constant MAX = ~uint256(0);\\n\\n  // For the purpose of the bank analogy, this is the circulating supply as opposed to the reserve supply.\\n  // This value never changes. Burning tokens don't reduce this supply, they just get sent to a burn address. Minting doesn't exist.\\n  uint256 private constant _totalSupply = 200000000000 * 10**6 * 10**9;\\n\\n  // Total reserve amount. The amount must be divisible by the circulating supply to reduce rounding errors in calculations,\\n  // hence the calculation of a remainder\\n  uint256 private _totalReserve = (MAX - (MAX % _totalSupply));\\n\\n  // Total accumulated transaction fees.\\n  uint256 private _transactionFeeTotal;\\n\\n  // Duration of initial sell tax.\\n  bool private initialSellTaxActive = false;\\n\\n  // Once the initial sell tax is set once, it cannot be set again.\\n  bool private initialSellTaxSet = false;\\n\\n  uint8 private _decimals = 9;\\n  string private _symbol = \\\"LFG\\\";\\n  string private _name = \\\"Lets Fucking GO!\\\";\\n\\n  // Struct for storing calculated transaction reserve values, fixes the error of too many local variables.\\n  struct ReserveValues {\\n    uint256 reserveAmount;\\n    uint256 reserveFee;\\n    uint256 reserveTransferAmount;\\n    uint256 reserveTransferAmountDao;\\n    uint256 reserveTransferAmountMooncakeRoyalty; \\n  }\\n\\n  // Struct for storing calculated transaction values, fixes the error of too many local variables.\\n  struct TransactionValues {\\n    uint256 transactionFee;\\n    uint256 transferAmount;\\n    uint256 netTransferAmount;\\n    uint256 daoTax;\\n    uint256 mooncakeRoyalty;\\n  }\\n\\n  constructor(\\n    address _daoContractAddress,\\n    address _opsWallet\\n  ) {\\n    daoContractAddress = _daoContractAddress;\\n\\n    // 50% backhole burn. The burn address receives reflect, further accelerating the token's deflationary scheme.\\n    uint256 blackHole = _totalSupply.div(2);\\n\\n    // 30% of remaining tokens for presale. \\n    uint256 presale = blackHole.mul(3).div(10);\\n\\n    // 59% to deployer for LP addition\\n    uint256 lp = blackHole.mul(59).div(100);\\n\\n    // 10% to the DAO\\n    uint256 dao = blackHole.div(10);\\n\\n    // 1% royalty\\n    uint256 royalty = blackHole.div(100);\\n        \\n    // ratio of reserve to total supply\\n    uint256 rate = getRate();\\n    \\n    _reserveTokenBalance[burn] = blackHole.mul(rate);\\n    _reserveTokenBalance[_opsWallet] = presale.mul(rate);\\n    _reserveTokenBalance[_msgSender()] = lp.mul(rate);\\n    _reserveTokenBalance[_daoContractAddress] = dao.mul(rate);\\n    _reserveTokenBalance[royaltyAddress] = royalty.mul(rate);\\n    \\n    emit Transfer(\\n      address(0),\\n      burn,\\n      blackHole\\n    );\\n    emit Transfer(\\n      address(0),\\n      _opsWallet,\\n      presale\\n    );\\n    emit Transfer(\\n      address(0),\\n      _msgSender(),\\n      lp\\n    );\\n    emit Transfer(\\n      address(0),\\n      _daoContractAddress,\\n      dao\\n    );\\n    emit Transfer(\\n      address(0),\\n      royaltyAddress,\\n      royalty\\n    );\\n  }\\n\\n  /// @notice Applies anti-bot sell tax. To be called by the deployer directly before launching the PCS liquidity pool. Can only be called once.\\n  function applyInitialSellTax() public onlyOwner() {\\n    require(!initialSellTaxSet, \\\"Initial sell tax has already been set.\\\");\\n    initialSellTaxSet = true;\\n    initialSellTaxActive = true;\\n  }\\n\\n  /// @notice Removes anti-bot sell tax. To be called by the deployer after a few hours of calling applyInitialSellTax().\\n  function removeInitialSellTax() public onlyOwner() {\\n    initialSellTaxActive = false;\\n  }\\n\\n  /// @notice Change DAO contract address.\\n  function setDaoAddress(address _daoContractAddress) public onlyOwner() {\\n    daoContractAddress = _daoContractAddress;\\n  }\\n\\n  /// @notice Set liquidity pool contract address.\\n  function setTokenPairAddress(address _tokenPairAddress) public onlyOwner() {\\n    tokenPairAddress = _tokenPairAddress;\\n  }\\n\\n  /// @notice Gets the token's name\\n  /// @return Name\\n  function name() public view override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /// @notice Gets the token's symbol\\n  /// @return Symbol\\n  function symbol() public view override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /// @notice Gets the token's decimals\\n  /// @return Decimals\\n  function decimals() public view override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /// @notice Gets the total token supply (circulating supply from the reserve)\\n  /// @return Total token supply\\n  function totalSupply() public pure override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /// @notice Gets the token balance of given account\\n  /// @param account - Address to get the balance of\\n  /// @return Account's token balance\\n  function balanceOf(address account) public view override returns (uint256) {\\n    if (_isExcluded[account]) return _circulatingTokenBalance[account];\\n    return tokenBalanceFromReserveAmount(_reserveTokenBalance[account]);\\n  }\\n\\n  /// @notice Transfers tokens from msg.sender to recipient\\n  /// @param recipient - Recipient of tokens\\n  /// @param amount - Amount of tokens to send\\n  /// @return true\\n  function transfer(\\n    address recipient,\\n    uint256 amount\\n  ) public override returns (bool) {\\n    _transfer(\\n      _msgSender(),\\n      recipient,\\n      amount\\n    );\\n    return true;\\n  }\\n\\n  /// @notice Gets the token spend allowance for spender of owner\\n  /// @param owner - Owner of the tokens\\n  /// @param spender - Account with allowance to spend owner's tokens\\n  /// @return allowance amount\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) public view override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /// @notice Approve token transfers from a 3rd party\\n  /// @param spender - The account to approve for spending funds on behalf of msg.senderds\\n  /// @param amount - The amount of tokens to approve\\n  /// @return true\\n  function approve(\\n    address spender,\\n    uint256 amount\\n  ) public override returns (bool) {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      amount\\n    );\\n    return true;\\n  }\\n\\n  /// @notice Transfer tokens from a 3rd party\\n  /// @param sender - The account sending the funds\\n  /// @param recipient - The account receiving the funds\\n  /// @param amount - The amount of tokens to send\\n  /// @return true\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public override returns (bool) {\\n    _transfer(\\n      sender,\\n      recipient,\\n      amount\\n    );\\n    _approve(\\n      sender,\\n      _msgSender(),\\n      _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\")\\n    );\\n    return true;\\n  }\\n\\n  /// @notice Increase 3rd party allowance to spend funds\\n  /// @param spender - The account being approved to spend on behalf of msg.sender\\n  /// @param addedValue - The amount to add to spending approval\\n  /// @return true\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  ) public virtual returns (bool) {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].add(addedValue)\\n    );\\n    return true;\\n  }\\n\\n  /// @notice Decrease 3rd party allowance to spend funds\\n  /// @param spender - The account having approval revoked to spend on behalf of msg.sender\\n  /// @param subtractedValue - The amount to remove from spending approval\\n  /// @return true\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  ) public virtual returns (bool) {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\")\\n    );\\n    return true;\\n  }\\n\\n  /// @notice Gets the contract owner\\n  /// @return contract owner's address\\n  function getOwner() external override view returns (address) {\\n    return owner();\\n  }\\n\\n  /// @notice Tells whether or not the address is excluded from owning reserve balance\\n  /// @param account - The account to test\\n  /// @return true or false\\n  function isExcluded(\\n    address account\\n  ) public view returns (bool) {\\n    return _isExcluded[account];\\n  }\\n\\n  /// @notice Gets the total amount of fees spent\\n  /// @return Total amount of transaction fees\\n  function totalFees() public view returns (uint256) {\\n    return _transactionFeeTotal;\\n  }\\n\\n  /// @notice Distribute tokens from the msg.sender's balance amongst all holders\\n  /// @param transferAmount - The amount of tokens to distribute\\n  function distributeToAllHolders(\\n    uint256 transferAmount\\n  ) public {\\n    address sender = _msgSender();\\n    require(!_isExcluded[sender], \\\"Excluded addresses cannot call this function\\\");\\n    (\\n      ,\\n      ReserveValues memory reserveValues\\n      ,\\n    ) = _getValues(transferAmount);\\n    _reserveTokenBalance[sender] = _reserveTokenBalance[sender].sub(reserveValues.reserveAmount);\\n    _totalReserve = _totalReserve.sub(reserveValues.reserveAmount);\\n    _transactionFeeTotal = _transactionFeeTotal.add(transferAmount);\\n  }\\n\\n  /// @notice Gets the reserve balance based on amount of tokens \\n  /// @param transferAmount - The amount of tokens to distribute\\n  /// @param deductTransferReserveFee - Whether or not to deduct the transfer fee\\n  /// @return Reserve balance\\n  function reserveBalanceFromTokenAmount(\\n    uint256 transferAmount,\\n    bool deductTransferReserveFee\\n  ) public view returns(uint256) {\\n    (\\n      ,\\n      ReserveValues memory reserveValues\\n      ,\\n    ) = _getValues(transferAmount);\\n    require(transferAmount <= _totalSupply, \\\"Amount must be less than supply\\\");\\n    if (!deductTransferReserveFee) {       \\n      return reserveValues.reserveAmount;\\n    } else {\\n      return reserveValues.reserveTransferAmount;\\n    }\\n  }\\n\\n  /// @notice Gets the token balance based on the reserve amount\\n  /// @param reserveAmount - The amount of reserve tokens owned\\n  /// @dev Dividing the reserveAmount by the currentRate is identical to multiplying the reserve amount by the ratio of totalSupply to totalReserve, which will be much less than 100% \\n  /// @return Token balance\\n  function tokenBalanceFromReserveAmount(\\n    uint256 reserveAmount\\n  ) public view returns(uint256) {\\n    require(reserveAmount <= _totalReserve, \\\"Amount must be less than total reflections\\\");\\n    uint256 currentRate =  getRate();\\n    return reserveAmount.div(currentRate);\\n  }\\n\\n  /// @notice Excludes an account from owning reserve balance. Useful for exchange and pool addresses.\\n  /// @param account - The account to exclude\\n  function excludeAccount(\\n    address account\\n  ) external onlyOwner() {\\n    require(!_isExcluded[account], \\\"Account is already excluded\\\");\\n    if(_reserveTokenBalance[account] > 0) {\\n        _circulatingTokenBalance[account] = tokenBalanceFromReserveAmount(_reserveTokenBalance[account]);\\n    }\\n    _isExcluded[account] = true;\\n    _excluded.push(account);\\n  }\\n\\n  /// @notice Includes an excluded account from owning reserve balance\\n  /// @param account - The account to include\\n  function includeAccount(\\n    address account\\n  ) external onlyOwner() {\\n    require(_isExcluded[account], \\\"Account is already excluded\\\");\\n    for (uint256 i = 0; i < _excluded.length; i++) {\\n      if (_excluded[i] == account) {\\n        _excluded[i] = _excluded[_excluded.length - 1];\\n        _circulatingTokenBalance[account] = 0;\\n        _isExcluded[account] = false;\\n        _excluded.pop();\\n        break;\\n      }\\n    }\\n  }\\n\\n  /// @notice Approves spender to spend owner's tokens\\n  /// @param owner - The account approving spender to spend tokens\\n  /// @param spender - The account to spend the tokens\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) private {\\n    require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /// @notice Transfers 4.5% of every transaction to the LFG DAO\\n  /// @notice Transfers 0.5% of every transaction for contract license.\\n  /// @dev These addresses will never be excluded from receiving reflect, so we only increase their reserve balances\\n  function applyExternalTransactionTax(\\n    ReserveValues memory reserveValues,\\n    TransactionValues memory transactionValues,\\n    address sender\\n  ) private {\\n    _reserveTokenBalance[daoContractAddress] = _reserveTokenBalance[daoContractAddress].add(reserveValues.reserveTransferAmountDao);\\n    emit Transfer(\\n      sender,\\n      daoContractAddress,\\n      transactionValues.daoTax\\n    );  \\n    _reserveTokenBalance[royaltyAddress] = _reserveTokenBalance[royaltyAddress].add(reserveValues.reserveTransferAmountMooncakeRoyalty);\\n    emit Transfer(\\n      sender,\\n      royaltyAddress,\\n      transactionValues.mooncakeRoyalty\\n    );     \\n  }\\n\\n  /// @notice Transfers tokens from sender to recipient differently based on inclusivity and exclusivity to reserve balance holding\\n  /// @param sender - The account sending tokens\\n  /// @param recipient - The account receiving tokens\\n  /// @param amount = The amount of tokens to send\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) private {\\n    require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n    require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n    require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n    if (_isExcluded[sender] && !_isExcluded[recipient]) {\\n        _transferFromExcluded(\\n          sender,\\n          recipient,\\n          amount\\n        );\\n    } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\\n        _transferToExcluded(\\n          sender,\\n          recipient,\\n          amount\\n        );\\n    } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\\n        _transferStandard(\\n          sender,\\n          recipient,\\n          amount\\n        );\\n    } else if (_isExcluded[sender] && _isExcluded[recipient]) {\\n        _transferBothExcluded(\\n          sender,\\n          recipient,\\n          amount\\n        );\\n    } else {\\n        _transferStandard(\\n          sender,\\n          recipient,\\n          amount\\n        );\\n    }\\n  }\\n\\n  /// @notice Transfers tokens from included sender to included recipient \\n  /// @param sender - The account sending tokens\\n  /// @param recipient - The account receiving tokens\\n  /// @param transferAmount = The amount of tokens to send\\n  /// @dev Transferring tokens changes the reserve balances of the sender and recipient + reduces the totalReserve. It doesn't directly change the circulatingTokenBalance \\n  function _transferStandard(\\n    address sender,\\n    address recipient,\\n    uint256 transferAmount\\n  ) private {\\n    (\\n      TransactionValues memory transactionValues,\\n      ReserveValues memory reserveValues\\n      ,\\n    ) = _getValues(transferAmount);\\n    _reserveTokenBalance[sender] = _reserveTokenBalance[sender].sub(reserveValues.reserveAmount);\\n    _reserveTokenBalance[recipient] = _reserveTokenBalance[recipient].add(reserveValues.reserveTransferAmount);\\n    emit Transfer(\\n      sender,\\n      recipient,\\n      transactionValues.netTransferAmount\\n    );\\n    applyExternalTransactionTax(\\n      reserveValues,\\n      transactionValues,\\n      sender\\n    );\\n    _applyFees(\\n      reserveValues.reserveFee,\\n      transactionValues.transactionFee\\n    );\\n  }\\n\\n  /// @notice Transfers tokens from included sender to excluded recipient \\n  /// @param sender - The account sending tokens\\n  /// @param recipient - The account receiving tokens\\n  /// @param transferAmount = The amount of tokens to send\\n  /// @dev Transferring tokens to an excluded address directly increases the circulatingTokenBalance of the recipient, because excluded accounts only use that metric to calculate balances\\n  /// @dev Reserve balance is also transferred, in case the receiving address becomes included again\\n  function _transferToExcluded(\\n    address sender,\\n    address recipient,\\n    uint256 transferAmount\\n  ) private {\\n    (\\n      TransactionValues memory transactionValues,\\n      ReserveValues memory reserveValues\\n      ,\\n    ) = _getValues(transferAmount);\\n\\n    _reserveTokenBalance[sender] = _reserveTokenBalance[sender].sub(reserveValues.reserveAmount);\\n\\n    // No tx fees for funding initial Token Pair contract. Only for transferToExcluded, all pools will be excluded from receiving reflect.\\n    if (recipient == tokenPairAddress) {\\n      _reserveTokenBalance[recipient] = _reserveTokenBalance[recipient].add(reserveValues.reserveAmount);   \\n      _circulatingTokenBalance[recipient] = _circulatingTokenBalance[recipient].add(transferAmount);\\n\\n      emit Transfer(\\n        sender,\\n        recipient,\\n        transferAmount\\n      );\\n\\n    } else {\\n      _reserveTokenBalance[recipient] = _reserveTokenBalance[recipient].add(reserveValues.reserveTransferAmount); \\n      _circulatingTokenBalance[recipient] = _circulatingTokenBalance[recipient].add(transactionValues.netTransferAmount);\\n      emit Transfer(\\n        sender,\\n        recipient,\\n        transactionValues.netTransferAmount\\n      );\\n      applyExternalTransactionTax(\\n        reserveValues,\\n        transactionValues,\\n        sender\\n      );\\n      _applyFees(\\n        reserveValues.reserveFee,\\n        transactionValues.transactionFee\\n      );\\n    }\\n  }\\n\\n  /// @notice Transfers tokens from excluded sender to included recipient\\n  /// @param sender - The account sending tokens\\n  /// @param recipient - The account receiving tokens\\n  /// @param transferAmount = The amount of tokens to send\\n  /// @dev Transferring tokens from an excluded address reduces the circulatingTokenBalance directly but adds only reserve balance to the included recipient\\n  function _transferFromExcluded(\\n    address sender,\\n    address recipient,\\n    uint256 transferAmount\\n  ) private {\\n    (\\n      TransactionValues memory transactionValues,\\n      ReserveValues memory reserveValues\\n      ,\\n    ) = _getValues(transferAmount);\\n    _circulatingTokenBalance[sender] = _circulatingTokenBalance[sender].sub(transferAmount);\\n    _reserveTokenBalance[sender] = _reserveTokenBalance[sender].sub(reserveValues.reserveAmount);\\n\\n    // only matters when transferring from the Pair contract (which is excluded)\\n    if (!initialSellTaxActive) {\\n      _reserveTokenBalance[recipient] = _reserveTokenBalance[recipient].add(reserveValues.reserveTransferAmount);\\n      emit Transfer(\\n        sender,\\n        recipient,\\n        transactionValues.netTransferAmount\\n      );\\n      applyExternalTransactionTax(\\n        reserveValues,\\n        transactionValues,\\n        sender\\n      );\\n      _applyFees(\\n        reserveValues.reserveFee,\\n        transactionValues.transactionFee\\n      );\\n    } else {\\n      // Sell tax of 90% to prevent bots from sniping the liquidity pool. Should be active for a few hours after liquidity pool launch.\\n      _reserveTokenBalance[recipient] = _reserveTokenBalance[recipient].add(reserveValues.reserveAmount.div(10));\\n      emit Transfer(\\n        sender,\\n        recipient,\\n        transferAmount.div(10)\\n      );\\n    }\\n  }\\n\\n  /// @notice Transfers tokens from excluded sender to excluded recipient \\n  /// @param sender - The account sending tokens\\n  /// @param recipient - The account receiving tokens\\n  /// @param transferAmount = The amount of tokens to send\\n  /// @dev Transferring tokens from and to excluded addresses modify both the circulatingTokenBalance & reserveTokenBalance on both sides, in case one address is included in the future\\n  function _transferBothExcluded(\\n    address sender,\\n    address recipient,\\n    uint256 transferAmount\\n  ) private {\\n    (\\n      TransactionValues memory transactionValues,\\n      ReserveValues memory reserveValues\\n      ,\\n    ) = _getValues(transferAmount);\\n    _circulatingTokenBalance[sender] = _circulatingTokenBalance[sender].sub(transferAmount);\\n    _reserveTokenBalance[sender] = _reserveTokenBalance[sender].sub(reserveValues.reserveAmount);\\n    _reserveTokenBalance[recipient] = _reserveTokenBalance[recipient].add(reserveValues.reserveTransferAmount);   \\n    _circulatingTokenBalance[recipient] = _circulatingTokenBalance[recipient].add(transactionValues.netTransferAmount); \\n\\n    emit Transfer(\\n      sender,\\n      recipient,\\n      transactionValues.netTransferAmount\\n    );\\n    applyExternalTransactionTax(\\n      reserveValues,\\n      transactionValues,\\n      sender\\n    );\\n    _applyFees(\\n      reserveValues.reserveFee,\\n      transactionValues.transactionFee\\n    );\\n  }\\n\\n  /// @notice Distributes the fee accordingly by reducing the total reserve supply. Increases the total transaction fees\\n  /// @param reserveFee - The amount to deduct from totalReserve, derived from transactionFee\\n  /// @param transactionFee - The actual token transaction fee\\n  function _applyFees(\\n    uint256 reserveFee,\\n    uint256 transactionFee\\n  ) private {\\n    _totalReserve = _totalReserve.sub(reserveFee);\\n    _transactionFeeTotal = _transactionFeeTotal.add(transactionFee);\\n  }\\n\\n  /// @notice Utility function - gets values necessary to facilitate a token transaction\\n  /// @param transferAmount - The transfer amount specified by the sender\\n  /// @return values for a token transaction\\n  function _getValues(\\n    uint256 transferAmount\\n  ) private view returns (TransactionValues memory, ReserveValues memory, uint256) {\\n    TransactionValues memory transactionValues = _getTValues(transferAmount);\\n    uint256 currentRate = getRate();\\n    ReserveValues memory reserveValues = _getRValues(\\n      transferAmount,\\n      transactionValues,\\n      currentRate\\n    );\\n\\n    return (\\n      transactionValues,\\n      reserveValues,\\n      currentRate\\n    );\\n  }\\n\\n  /// @notice Utility function - gets transaction values\\n  /// @param transferAmount - The transfer amount specified by the sender\\n  /// @return Net transfer amount for the recipient and the transaction fee\\n  function _getTValues(\\n    uint256 transferAmount\\n  ) private pure returns (TransactionValues memory) {\\n    TransactionValues memory transactionValues;\\n    // 5% fee to all LFG Token holders.\\n    transactionValues.transactionFee = transferAmount.div(20);\\n    // 4.5% fee to the LFG DAO contract.\\n    transactionValues.daoTax = transferAmount.mul(9).div(200);\\n    // 0.5% royalty.\\n    transactionValues.mooncakeRoyalty = transferAmount.div(200);\\n    // Net transfer amount to recipient\\n    transactionValues.netTransferAmount = transferAmount.sub(transactionValues.transactionFee).sub(transactionValues.daoTax).sub(transactionValues.mooncakeRoyalty);\\n    \\n    return transactionValues;\\n  }\\n\\n  /// @notice Utility function - gets reserve transaction values\\n  /// @param transferAmount - The transfer amount specified by the sender\\n  /// @param currentRate - The current rate - ratio of reserveSupply to totalSupply\\n  /// @return Net transfer amount for the recipient\\n  function _getRValues(\\n    uint256 transferAmount,\\n    TransactionValues memory transactionValues,\\n    uint256 currentRate\\n  ) private pure returns (ReserveValues memory) {\\n    ReserveValues memory reserveValues;\\n    reserveValues.reserveAmount = transferAmount.mul(currentRate);\\n    reserveValues.reserveFee = transactionValues.transactionFee.mul(currentRate);\\n    reserveValues.reserveTransferAmountDao = transactionValues.daoTax.mul(currentRate);\\n    reserveValues.reserveTransferAmountMooncakeRoyalty = transactionValues.mooncakeRoyalty.mul(currentRate);\\n    reserveValues.reserveTransferAmount = reserveValues.reserveAmount.sub(\\n      reserveValues.reserveFee\\n      ).sub(\\n        reserveValues.reserveTransferAmountDao\\n        ).sub(\\n          reserveValues.reserveTransferAmountMooncakeRoyalty\\n        );\\n\\n    return reserveValues;\\n  }\\n\\n  /// @notice Utility function - gets the current reserve rate - totalReserve / totalSupply\\n  /// @return Reserve rate\\n  function getRate() public view returns(uint256) {\\n    (\\n      uint256 reserveSupply,\\n      uint256 totalTokenSupply\\n    ) = getCurrentSupply();\\n    return reserveSupply.div(totalTokenSupply);\\n  }\\n\\n  /// @notice Utility function - gets total reserve and circulating supply\\n  /// @return Reserve supply, total token supply\\n  function getCurrentSupply() public view returns(uint256, uint256) {\\n    uint256 reserveSupply = _totalReserve;\\n    uint256 totalTokenSupply = _totalSupply;      \\n    for (uint256 i = 0; i < _excluded.length; i++) {\\n      if (_reserveTokenBalance[_excluded[i]] > reserveSupply || _circulatingTokenBalance[_excluded[i]] > totalTokenSupply) return (_totalReserve, _totalSupply);\\n      reserveSupply = reserveSupply.sub(_reserveTokenBalance[_excluded[i]]);\\n      totalTokenSupply = totalTokenSupply.sub(_circulatingTokenBalance[_excluded[i]]);\\n    }\\n    if (reserveSupply < _totalReserve.div(_totalSupply)) return (_totalReserve, _totalSupply);\\n    return (reserveSupply, totalTokenSupply);\\n  }\\n}\\n\\n// The High Table\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function totalSupply() external view returns (uint256);\\n  function decimals() external view returns (uint8);\\n  function symbol() external view returns (string memory);\\n  function name() external view returns (string memory);\\n  function getOwner() external view returns (address);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daoContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_opsWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"applyInitialSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"}],\"name\":\"distributeToAllHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeInitialSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferReserveFee\",\"type\":\"bool\"}],\"name\":\"reserveBalanceFromTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daoContractAddress\",\"type\":\"address\"}],\"name\":\"setDaoAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenPairAddress\",\"type\":\"address\"}],\"name\":\"setTokenPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"}],\"name\":\"tokenBalanceFromReserveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LFG","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000886fa8485aca34881136c92cff0bd8e62218c2af0000000000000000000000006448f9785d6c38608c18e904e2b3a23b0aed25dd","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}