{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Controlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\nimport \\\"../interfaces/IKernel.sol\\\";\\n\\nabstract contract Controlled is Initializable, ModuleMapConsumer {\\n  // controller address => is a controller\\n  mapping(address => bool) internal _controllers;\\n  address[] public controllers;\\n\\n  function __Controlled_init(address[] memory controllers_, address moduleMap_)\\n    public\\n    initializer\\n  {\\n    for (uint256 i; i < controllers_.length; i++) {\\n      _controllers[controllers_[i]] = true;\\n    }\\n    controllers = controllers_;\\n    __ModuleMapConsumer_init(moduleMap_);\\n  }\\n\\n  function addController(address controller) external onlyOwner {\\n    _controllers[controller] = true;\\n    bool added;\\n    for (uint256 i; i < controllers.length; i++) {\\n      if (controller == controllers[i]) {\\n        added = true;\\n      }\\n    }\\n    if (!added) {\\n      controllers.push(controller);\\n    }\\n  }\\n\\n  modifier onlyOwner() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isOwner(msg.sender),\\n      \\\"Controlled::onlyOwner: Caller is not owner\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isManager(msg.sender),\\n      \\\"Controlled::onlyManager: Caller is not manager\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyController() {\\n    require(\\n      _controllers[msg.sender],\\n      \\\"Controlled::onlyController: Caller is not controller\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ModuleMapConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IModuleMap.sol\\\";\\n\\nabstract contract ModuleMapConsumer is Initializable {\\n  IModuleMap public moduleMap;\\n\\n  function __ModuleMapConsumer_init(address moduleMap_) internal initializer {\\n    moduleMap = IModuleMap(moduleMap_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/UniswapTrader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\nimport \\\"../interfaces/IIntegrationMap.sol\\\";\\nimport \\\"../interfaces/IUniswapFactory.sol\\\";\\nimport \\\"../interfaces/IUniswapPositionManager.sol\\\";\\nimport \\\"../interfaces/IUniswapSwapRouter.sol\\\";\\nimport \\\"../interfaces/IUniswapTrader.sol\\\";\\nimport \\\"../interfaces/IUniswapPool.sol\\\";\\nimport \\\"../libraries/FullMath.sol\\\";\\n\\n/// @notice Integrates 0x Nodes to Uniswap v3\\n/// @notice tokenA/tokenB naming implies tokens are unsorted\\n/// @notice token0/token1 naming implies tokens are sorted\\ncontract UniswapTrader is\\n  Initializable,\\n  ModuleMapConsumer,\\n  Controlled,\\n  IUniswapTrader\\n{\\n  using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\\n\\n  struct Pool {\\n    uint24 feeNumerator;\\n    uint24 slippageNumerator;\\n  }\\n\\n  struct TokenPair {\\n    address token0;\\n    address token1;\\n  }\\n\\n  uint24 private constant FEE_DENOMINATOR = 1_000_000;\\n  uint24 private constant SLIPPAGE_DENOMINATOR = 1_000_000;\\n  address private factoryAddress;\\n  address private swapRouterAddress;\\n\\n  mapping(address => mapping(address => Pool[])) private pools;\\n  mapping(address => mapping(address => Path)) private paths;\\n  mapping(address => mapping(address => bool)) private isMultihopPair;\\n\\n  TokenPair[] private tokenPairs;\\n\\n  event UniswapPoolAdded(\\n    address indexed token0,\\n    address indexed token1,\\n    uint24 fee,\\n    uint24 slippageNumerator\\n  );\\n  event UniswapPoolSlippageNumeratorUpdated(\\n    address indexed token0,\\n    address indexed token1,\\n    uint256 poolIndex,\\n    uint24 slippageNumerator\\n  );\\n  event UniswapPairPrimaryPoolUpdated(\\n    address indexed token0,\\n    address indexed token1,\\n    uint256 primaryPoolIndex\\n  );\\n\\n  /// @param controllers_ The addresses of the controlling contracts\\n  /// @param moduleMap_ Module Map address\\n  /// @param factoryAddress_ The address of the Uniswap factory contract\\n  /// @param swapRouterAddress_ The address of the Uniswap swap router contract\\n  function initialize(\\n    address[] memory controllers_,\\n    address moduleMap_,\\n    address factoryAddress_,\\n    address swapRouterAddress_\\n  ) public initializer {\\n    __Controlled_init(controllers_, moduleMap_);\\n    __ModuleMapConsumer_init(moduleMap_);\\n    factoryAddress = factoryAddress_;\\n    swapRouterAddress = swapRouterAddress_;\\n  }\\n\\n  /// @param tokenA The address of tokenA ERC20 contract\\n  /// @param tokenB The address of tokenB ERC20 contract\\n  /// @param feeNumerator The Uniswap pool fee numerator\\n  /// @param slippageNumerator The value divided by the slippage denominator\\n  /// to calculate the allowable slippage\\n  /// positions is enabled for this pool\\n  function addPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 feeNumerator,\\n    uint24 slippageNumerator\\n  ) external override onlyManager {\\n    require(\\n      IIntegrationMap(moduleMap.getModuleAddress(Modules.IntegrationMap))\\n        .getIsTokenAdded(tokenA),\\n      \\\"UniswapTrader::addPool: TokenA has not been added in the Integration Map\\\"\\n    );\\n    require(\\n      IIntegrationMap(moduleMap.getModuleAddress(Modules.IntegrationMap))\\n        .getIsTokenAdded(tokenB),\\n      \\\"UniswapTrader::addPool: TokenB has not been added in the Integration Map\\\"\\n    );\\n    require(\\n      slippageNumerator <= SLIPPAGE_DENOMINATOR,\\n      \\\"UniswapTrader::addPool: Slippage numerator cannot be greater than slippapge denominator\\\"\\n    );\\n    require(\\n      IUniswapFactory(factoryAddress).getPool(tokenA, tokenB, feeNumerator) !=\\n        address(0),\\n      \\\"UniswapTrader::addPool: Pool does not exist\\\"\\n    );\\n\\n    (address token0, address token1) = getTokensSorted(tokenA, tokenB);\\n\\n    bool poolAdded;\\n    for (\\n      uint256 poolIndex;\\n      poolIndex < pools[token0][token1].length;\\n      poolIndex++\\n    ) {\\n      if (pools[token0][token1][poolIndex].feeNumerator == feeNumerator) {\\n        poolAdded = true;\\n      }\\n    }\\n\\n    require(!poolAdded, \\\"UniswapTrader::addPool: Pool has already been added\\\");\\n\\n    Pool memory newPool;\\n    newPool.feeNumerator = feeNumerator;\\n    newPool.slippageNumerator = slippageNumerator;\\n    pools[token0][token1].push(newPool);\\n\\n    bool tokenPairAdded;\\n    for (uint256 pairIndex; pairIndex < tokenPairs.length; pairIndex++) {\\n      if (\\n        tokenPairs[pairIndex].token0 == token0 &&\\n        tokenPairs[pairIndex].token1 == token1\\n      ) {\\n        tokenPairAdded = true;\\n      }\\n    }\\n\\n    if (!tokenPairAdded) {\\n      TokenPair memory newTokenPair;\\n      newTokenPair.token0 = token0;\\n      newTokenPair.token1 = token1;\\n      tokenPairs.push(newTokenPair);\\n\\n      if (\\n        IERC20MetadataUpgradeable(token0).allowance(\\n          address(this),\\n          moduleMap.getModuleAddress(Modules.YieldManager)\\n        ) == 0\\n      ) {\\n        IERC20MetadataUpgradeable(token0).safeApprove(\\n          moduleMap.getModuleAddress(Modules.YieldManager),\\n          type(uint256).max\\n        );\\n      }\\n\\n      if (\\n        IERC20MetadataUpgradeable(token1).allowance(\\n          address(this),\\n          moduleMap.getModuleAddress(Modules.YieldManager)\\n        ) == 0\\n      ) {\\n        IERC20MetadataUpgradeable(token1).safeApprove(\\n          moduleMap.getModuleAddress(Modules.YieldManager),\\n          type(uint256).max\\n        );\\n      }\\n\\n      if (\\n        IERC20MetadataUpgradeable(token0).allowance(\\n          address(this),\\n          swapRouterAddress\\n        ) == 0\\n      ) {\\n        IERC20MetadataUpgradeable(token0).safeApprove(\\n          swapRouterAddress,\\n          type(uint256).max\\n        );\\n      }\\n\\n      if (\\n        IERC20MetadataUpgradeable(token1).allowance(\\n          address(this),\\n          swapRouterAddress\\n        ) == 0\\n      ) {\\n        IERC20MetadataUpgradeable(token1).safeApprove(\\n          swapRouterAddress,\\n          type(uint256).max\\n        );\\n      }\\n    }\\n\\n    emit UniswapPoolAdded(token0, token1, feeNumerator, slippageNumerator);\\n  }\\n\\n  /// @param tokenA The address of tokenA of the pool\\n  /// @param tokenB The address of tokenB of the pool\\n  /// @param poolIndex The index of the pool for the specified token pair\\n  /// @param slippageNumerator The new slippage numerator to update the pool\\n  function updatePoolSlippageNumerator(\\n    address tokenA,\\n    address tokenB,\\n    uint256 poolIndex,\\n    uint24 slippageNumerator\\n  ) external override onlyManager {\\n    require(\\n      slippageNumerator <= SLIPPAGE_DENOMINATOR,\\n      \\\"UniswapTrader:updatePoolSlippageNumerator: Slippage numerator must not be greater than slippage denominator\\\"\\n    );\\n    (address token0, address token1) = getTokensSorted(tokenA, tokenB);\\n    require(\\n      pools[token0][token1][poolIndex].slippageNumerator != slippageNumerator,\\n      \\\"UniswapTrader:updatePoolSlippageNumerator: Slippage numerator must be updated to a new number\\\"\\n    );\\n    require(\\n      pools[token0][token1].length > poolIndex,\\n      \\\"UniswapTrader:updatePoolSlippageNumerator: Pool does not exist\\\"\\n    );\\n\\n    pools[token0][token1][poolIndex].slippageNumerator = slippageNumerator;\\n\\n    emit UniswapPoolSlippageNumeratorUpdated(\\n      token0,\\n      token1,\\n      poolIndex,\\n      slippageNumerator\\n    );\\n  }\\n\\n  /// @notice Updates which Uniswap pool to use as the default pool\\n  /// @notice when swapping between token0 and token1\\n  /// @param tokenA The address of tokenA of the pool\\n  /// @param tokenB The address of tokenB of the pool\\n  /// @param primaryPoolIndex The index of the Uniswap pool to make the new primary pool\\n  function updatePairPrimaryPool(\\n    address tokenA,\\n    address tokenB,\\n    uint256 primaryPoolIndex\\n  ) external override onlyManager {\\n    require(\\n      primaryPoolIndex != 0,\\n      \\\"UniswapTrader::updatePairPrimaryPool: Specified index is already the primary pool\\\"\\n    );\\n    (address token0, address token1) = getTokensSorted(tokenA, tokenB);\\n    require(\\n      primaryPoolIndex < pools[token0][token1].length,\\n      \\\"UniswapTrader::updatePairPrimaryPool: Specified pool index does not exist\\\"\\n    );\\n\\n    uint24 newPrimaryPoolFeeNumerator = pools[token0][token1][primaryPoolIndex]\\n      .feeNumerator;\\n    uint24 newPrimaryPoolSlippageNumerator = pools[token0][token1][\\n      primaryPoolIndex\\n    ].slippageNumerator;\\n\\n    pools[token0][token1][primaryPoolIndex].feeNumerator = pools[token0][\\n      token1\\n    ][0].feeNumerator;\\n    pools[token0][token1][primaryPoolIndex].slippageNumerator = pools[token0][\\n      token1\\n    ][0].slippageNumerator;\\n\\n    pools[token0][token1][0].feeNumerator = newPrimaryPoolFeeNumerator;\\n    pools[token0][token1][0]\\n      .slippageNumerator = newPrimaryPoolSlippageNumerator;\\n\\n    emit UniswapPairPrimaryPoolUpdated(token0, token1, primaryPoolIndex);\\n  }\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param recipient The address to receive the tokens\\n  /// @param amountIn The exact amount of the input to swap\\n  /// @return tradeSuccess Indicates whether the trade succeeded\\n  function swapExactInput(\\n    address tokenIn,\\n    address tokenOut,\\n    address recipient,\\n    uint256 amountIn\\n  ) external override onlyController returns (bool tradeSuccess) {\\n    IERC20MetadataUpgradeable tokenInErc20 = IERC20MetadataUpgradeable(tokenIn);\\n\\n    if (isMultihopPair[tokenIn][tokenOut]) {\\n      Path memory path = getPathFor(tokenIn, tokenOut);\\n      IUniswapSwapRouter.ExactInputParams memory params = IUniswapSwapRouter\\n        .ExactInputParams({\\n          path: abi.encodePacked(\\n            path.tokenIn,\\n            path.firstPoolFee,\\n            path.tokenInTokenOut,\\n            path.secondPoolFee,\\n            path.tokenOut\\n          ),\\n          recipient: recipient,\\n          deadline: block.timestamp,\\n          amountIn: amountIn,\\n          amountOutMinimum: 0\\n        });\\n\\n      // Executes the swap.\\n      try IUniswapSwapRouter(swapRouterAddress).exactInput(params) {\\n        tradeSuccess = true;\\n      } catch {\\n        tradeSuccess = false;\\n        tokenInErc20.safeTransfer(\\n          recipient,\\n          tokenInErc20.balanceOf(address(this))\\n        );\\n      }\\n\\n      return tradeSuccess;\\n    }\\n\\n    (address token0, address token1) = getTokensSorted(tokenIn, tokenOut);\\n\\n    require(\\n      pools[token0][token1].length > 0,\\n      \\\"UniswapTrader::swapExactInput: Pool has not been added\\\"\\n    );\\n    require(\\n      tokenInErc20.balanceOf(address(this)) >= amountIn,\\n      \\\"UniswapTrader::swapExactInput: Balance is less than trade amount\\\"\\n    );\\n\\n    uint256 amountOutMinimum = getAmountOutMinimum(tokenIn, tokenOut, amountIn);\\n\\n    IUniswapSwapRouter.ExactInputSingleParams memory exactInputSingleParams;\\n    exactInputSingleParams.tokenIn = tokenIn;\\n    exactInputSingleParams.tokenOut = tokenOut;\\n    exactInputSingleParams.fee = pools[token0][token1][0].feeNumerator;\\n    exactInputSingleParams.recipient = recipient;\\n    exactInputSingleParams.deadline = block.timestamp;\\n    exactInputSingleParams.amountIn = amountIn;\\n    exactInputSingleParams.amountOutMinimum = amountOutMinimum;\\n    exactInputSingleParams.sqrtPriceLimitX96 = 0;\\n\\n    try\\n      IUniswapSwapRouter(swapRouterAddress).exactInputSingle(\\n        exactInputSingleParams\\n      )\\n    {\\n      tradeSuccess = true;\\n    } catch {\\n      tradeSuccess = false;\\n      tokenInErc20.safeTransfer(\\n        recipient,\\n        tokenInErc20.balanceOf(address(this))\\n      );\\n    }\\n  }\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param recipient The address to receive the tokens\\n  /// @param amountOut The exact amount of the output token to receive\\n  /// @return tradeSuccess Indicates whether the trade succeeded\\n  function swapExactOutput(\\n    address tokenIn,\\n    address tokenOut,\\n    address recipient,\\n    uint256 amountOut\\n  ) external override onlyController returns (bool tradeSuccess) {\\n    IERC20MetadataUpgradeable tokenInErc20 = IERC20MetadataUpgradeable(tokenIn);\\n\\n    if (isMultihopPair[tokenIn][tokenOut]) {\\n      Path memory path = getPathFor(tokenIn, tokenOut);\\n      IUniswapSwapRouter.ExactOutputParams memory params = IUniswapSwapRouter\\n        .ExactOutputParams({\\n          path: abi.encodePacked(\\n            path.tokenIn,\\n            path.firstPoolFee,\\n            path.tokenInTokenOut,\\n            path.secondPoolFee,\\n            path.tokenOut\\n          ),\\n          recipient: recipient,\\n          deadline: block.timestamp,\\n          amountOut: amountOut,\\n          amountInMaximum: 0\\n        });\\n\\n      // Executes the swap.\\n      try IUniswapSwapRouter(swapRouterAddress).exactOutput(params) {\\n        tradeSuccess = true;\\n      } catch {\\n        tradeSuccess = false;\\n        tokenInErc20.safeTransfer(\\n          recipient,\\n          tokenInErc20.balanceOf(address(this))\\n        );\\n      }\\n\\n      return tradeSuccess;\\n    }\\n    (address token0, address token1) = getTokensSorted(tokenIn, tokenOut);\\n    require(\\n      pools[token0][token1][0].feeNumerator > 0,\\n      \\\"UniswapTrader::swapExactOutput: Pool has not been added\\\"\\n    );\\n    uint256 amountInMaximum = getAmountInMaximum(tokenIn, tokenOut, amountOut);\\n    require(\\n      tokenInErc20.balanceOf(address(this)) >= amountInMaximum,\\n      \\\"UniswapTrader::swapExactOutput: Balance is less than trade amount\\\"\\n    );\\n\\n    IUniswapSwapRouter.ExactOutputSingleParams memory exactOutputSingleParams;\\n    exactOutputSingleParams.tokenIn = tokenIn;\\n    exactOutputSingleParams.tokenOut = tokenOut;\\n    exactOutputSingleParams.fee = pools[token0][token1][0].feeNumerator;\\n    exactOutputSingleParams.recipient = recipient;\\n    exactOutputSingleParams.deadline = block.timestamp;\\n    exactOutputSingleParams.amountOut = amountOut;\\n    exactOutputSingleParams.amountInMaximum = amountInMaximum;\\n    exactOutputSingleParams.sqrtPriceLimitX96 = 0;\\n\\n    try\\n      IUniswapSwapRouter(swapRouterAddress).exactOutputSingle(\\n        exactOutputSingleParams\\n      )\\n    {\\n      tradeSuccess = true;\\n    } catch {\\n      tradeSuccess = false;\\n      tokenInErc20.safeTransfer(\\n        recipient,\\n        tokenInErc20.balanceOf(address(this))\\n      );\\n    }\\n  }\\n\\n  /// @param tokenA The address of tokenA ERC20 contract\\n  /// @param tokenB The address of tokenB ERC20 contract\\n  /// @return pool The pool address\\n  function getPoolAddress(address tokenA, address tokenB)\\n    public\\n    view\\n    override\\n    returns (address pool)\\n  {\\n    uint24 feeNumerator = getPoolFeeNumerator(tokenA, tokenB, 0);\\n    pool = IUniswapFactory(factoryAddress).getPool(\\n      tokenA,\\n      tokenB,\\n      feeNumerator\\n    );\\n  }\\n\\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n  function getSqrtPriceX96(address tokenA, address tokenB)\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    (uint160 sqrtPriceX96, , , , , , ) = IUniswapPool(\\n      getPoolAddress(tokenA, tokenB)\\n    ).slot0();\\n    return uint256(sqrtPriceX96);\\n  }\\n\\n  function getPathFor(address tokenIn, address tokenOut)\\n    public\\n    view\\n    override\\n    returns (Path memory)\\n  {\\n    require(\\n      isMultihopPair[tokenIn][tokenOut],\\n      \\\"There is an existing Pool for this pair\\\"\\n    );\\n\\n    return paths[tokenIn][tokenOut];\\n  }\\n\\n  function setPathFor(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 firstPoolFee,\\n    address tokenInTokenOut,\\n    uint256 secondPoolFee\\n  ) public override onlyManager {\\n    paths[tokenIn][tokenOut] = Path(\\n      tokenIn,\\n      firstPoolFee,\\n      tokenInTokenOut,\\n      secondPoolFee,\\n      tokenOut\\n    );\\n    isMultihopPair[tokenIn][tokenOut] = true;\\n  }\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param amountIn The exact amount of the input to swap\\n  /// @return amountOutMinimum The minimum amount of tokenOut to receive, factoring in allowable slippage\\n  function getAmountOutMinimum(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountIn\\n  ) public view returns (uint256 amountOutMinimum) {\\n    uint256 estimatedAmountOut = getEstimatedTokenOut(\\n      tokenIn,\\n      tokenOut,\\n      amountIn\\n    );\\n    uint24 poolSlippageNumerator = getPoolSlippageNumerator(\\n      tokenIn,\\n      tokenOut,\\n      0\\n    );\\n    amountOutMinimum =\\n      (estimatedAmountOut * (SLIPPAGE_DENOMINATOR - poolSlippageNumerator)) /\\n      SLIPPAGE_DENOMINATOR;\\n  }\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param amountOut The exact amount of token being swapped for\\n  /// @return amountInMaximum The maximum amount of tokenIn to spend, factoring in allowable slippage\\n  function getAmountInMaximum(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountOut\\n  ) public view override returns (uint256 amountInMaximum) {\\n    uint256 estimatedAmountIn = getEstimatedTokenIn(\\n      tokenIn,\\n      tokenOut,\\n      amountOut\\n    );\\n    uint24 poolSlippageNumerator = getPoolSlippageNumerator(\\n      tokenIn,\\n      tokenOut,\\n      0\\n    );\\n    amountInMaximum =\\n      (estimatedAmountIn * (SLIPPAGE_DENOMINATOR + poolSlippageNumerator)) /\\n      SLIPPAGE_DENOMINATOR;\\n  }\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param amountIn The exact amount of the input to swap\\n  /// @return amountOut The estimated amount of tokenOut to receive\\n  function getEstimatedTokenOut(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountIn\\n  ) public view override returns (uint256 amountOut) {\\n    if (isMultihopPair[tokenIn][tokenOut]) {\\n      Path memory path = getPathFor(tokenIn, tokenOut);\\n      uint256 amountOutTemp = getEstimatedTokenOut(\\n        path.tokenIn,\\n        path.tokenInTokenOut,\\n        amountIn\\n      );\\n      return\\n        getEstimatedTokenOut(\\n          path.tokenInTokenOut,\\n          path.tokenOut,\\n          amountOutTemp\\n        );\\n    }\\n\\n    uint24 feeNumerator = getPoolFeeNumerator(tokenIn, tokenOut, 0);\\n    uint256 sqrtPriceX96 = getSqrtPriceX96(tokenIn, tokenOut);\\n\\n    // FullMath is used to allow intermediate calculation values of up to 2^512\\n    if (tokenIn < tokenOut) {\\n      amountOut =\\n        (FullMath.mulDiv(\\n          FullMath.mulDiv(amountIn, sqrtPriceX96, 2**96),\\n          sqrtPriceX96,\\n          2**96\\n        ) * (FEE_DENOMINATOR - feeNumerator)) /\\n        FEE_DENOMINATOR;\\n    } else {\\n      amountOut =\\n        (FullMath.mulDiv(\\n          FullMath.mulDiv(amountIn, 2**96, sqrtPriceX96),\\n          2**96,\\n          sqrtPriceX96\\n        ) * (FEE_DENOMINATOR - feeNumerator)) /\\n        FEE_DENOMINATOR;\\n    }\\n  }\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param amountOut The exact amount of the output token to swap for\\n  /// @return amountIn The estimated amount of tokenIn to spend\\n  function getEstimatedTokenIn(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountOut\\n  ) public view returns (uint256 amountIn) {\\n    if (isMultihopPair[tokenIn][tokenOut]) {\\n      Path memory path = getPathFor(tokenIn, tokenOut);\\n      uint256 amountInTemp = getEstimatedTokenIn(\\n        path.tokenInTokenOut,\\n        path.tokenOut,\\n        amountOut\\n      );\\n      return\\n        getEstimatedTokenIn(path.tokenIn, path.tokenInTokenOut, amountInTemp);\\n    }\\n\\n    uint24 feeNumerator = getPoolFeeNumerator(tokenIn, tokenOut, 0);\\n    uint256 sqrtPriceX96 = getSqrtPriceX96(tokenIn, tokenOut);\\n\\n    // FullMath is used to allow intermediate calculation values of up to 2^512\\n    if (tokenIn < tokenOut) {\\n      amountIn =\\n        (FullMath.mulDiv(\\n          FullMath.mulDiv(amountOut, 2**96, sqrtPriceX96),\\n          2**96,\\n          sqrtPriceX96\\n        ) * (FEE_DENOMINATOR - feeNumerator)) /\\n        FEE_DENOMINATOR;\\n    } else {\\n      amountIn =\\n        (FullMath.mulDiv(\\n          FullMath.mulDiv(amountOut, sqrtPriceX96, 2**96),\\n          sqrtPriceX96,\\n          2**96\\n        ) * (FEE_DENOMINATOR - feeNumerator)) /\\n        FEE_DENOMINATOR;\\n    }\\n  }\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @param poolId The index of the pool in the pools mapping\\n  /// @return feeNumerator The numerator that gets divided by the fee denominator\\n  function getPoolFeeNumerator(\\n    address tokenA,\\n    address tokenB,\\n    uint256 poolId\\n  ) public view override returns (uint24 feeNumerator) {\\n    (address token0, address token1) = getTokensSorted(tokenA, tokenB);\\n    require(\\n      poolId < pools[token0][token1].length,\\n      \\\"UniswapTrader::getPoolFeeNumerator: Pool ID does not exist\\\"\\n    );\\n    feeNumerator = pools[token0][token1][poolId].feeNumerator;\\n  }\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @param poolId The index of the pool in the pools mapping\\n  /// @return slippageNumerator The numerator that gets divided by the slippage denominator\\n  function getPoolSlippageNumerator(\\n    address tokenA,\\n    address tokenB,\\n    uint256 poolId\\n  ) public view returns (uint24 slippageNumerator) {\\n    (address token0, address token1) = getTokensSorted(tokenA, tokenB);\\n    return pools[token0][token1][poolId].slippageNumerator;\\n  }\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @return token0 The address of the sorted token0\\n  /// @return token1 The address of the sorted token1\\n  function getTokensSorted(address tokenA, address tokenB)\\n    public\\n    pure\\n    override\\n    returns (address token0, address token1)\\n  {\\n    if (tokenA < tokenB) {\\n      token0 = tokenA;\\n      token1 = tokenB;\\n    } else {\\n      token0 = tokenB;\\n      token1 = tokenA;\\n    }\\n  }\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @param amountA The amount of tokenA\\n  /// @param amountB The amount of tokenB\\n  /// @return token0 The address of sorted token0\\n  /// @return token1 The address of sorted token1\\n  /// @return amount0 The amount of sorted token0\\n  /// @return amount1 The amount of sorted token1\\n  function getTokensAndAmountsSorted(\\n    address tokenA,\\n    address tokenB,\\n    uint256 amountA,\\n    uint256 amountB\\n  )\\n    public\\n    pure\\n    returns (\\n      address token0,\\n      address token1,\\n      uint256 amount0,\\n      uint256 amount1\\n    )\\n  {\\n    if (tokenA < tokenB) {\\n      token0 = tokenA;\\n      token1 = tokenB;\\n      amount0 = amountA;\\n      amount1 = amountB;\\n    } else {\\n      token0 = tokenB;\\n      token1 = tokenA;\\n      amount0 = amountB;\\n      amount1 = amountA;\\n    }\\n  }\\n\\n  /// @return The denominator used to calculate the pool fee percentage\\n  function getFeeDenominator() external pure returns (uint24) {\\n    return FEE_DENOMINATOR;\\n  }\\n\\n  /// @return The denominator used to calculate the allowable slippage percentage\\n  function getSlippageDenominator() external pure returns (uint24) {\\n    return SLIPPAGE_DENOMINATOR;\\n  }\\n\\n  /// @return The number of token pairs configured\\n  function getTokenPairsLength() external view override returns (uint256) {\\n    return tokenPairs.length;\\n  }\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @return The quantity of pools configured for the specified token pair\\n  function getTokenPairPoolsLength(address tokenA, address tokenB)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    (address token0, address token1) = getTokensSorted(tokenA, tokenB);\\n    return pools[token0][token1].length;\\n  }\\n\\n  /// @param tokenPairIndex The index of the token pair\\n  /// @return The address of token0\\n  /// @return The address of token1\\n  function getTokenPair(uint256 tokenPairIndex)\\n    external\\n    view\\n    returns (address, address)\\n  {\\n    require(\\n      tokenPairIndex < tokenPairs.length,\\n      \\\"UniswapTrader::getTokenPair: Token pair does not exist\\\"\\n    );\\n    return (\\n      tokenPairs[tokenPairIndex].token0,\\n      tokenPairs[tokenPairIndex].token1\\n    );\\n  }\\n\\n  /// @param token0 The address of token0 of the pool\\n  /// @param token1 The address of token1 of the pool\\n  /// @param poolIndex The index of the pool\\n  /// @return The pool fee numerator\\n  /// @return The pool slippage numerator\\n  function getPool(\\n    address token0,\\n    address token1,\\n    uint256 poolIndex\\n  ) external view returns (uint24, uint24) {\\n    require(\\n      poolIndex < pools[token0][token1].length,\\n      \\\"UniswapTrader:getPool: Pool does not exist\\\"\\n    );\\n    return (\\n      pools[token0][token1][poolIndex].feeNumerator,\\n      pools[token0][token1][poolIndex].slippageNumerator\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIntegrationMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IIntegrationMap {\\n  struct Integration {\\n    bool added;\\n    string name;\\n  }\\n\\n  struct Token {\\n    uint256 id;\\n    bool added;\\n    bool acceptingDeposits;\\n    bool acceptingWithdrawals;\\n    uint256 biosRewardWeight;\\n    uint256 reserveRatioNumerator;\\n  }\\n\\n  /// @param contractAddress The address of the integration contract\\n  /// @param name The name of the protocol being integrated to\\n  function addIntegration(address contractAddress, string memory name) external;\\n\\n  /// @param tokenAddress The address of the ERC20 token contract\\n  /// @param acceptingDeposits Whether token deposits are enabled\\n  /// @param acceptingWithdrawals Whether token withdrawals are enabled\\n  /// @param biosRewardWeight Token weight for BIOS rewards\\n  /// @param reserveRatioNumerator Number that gets divided by reserve ratio denominator to get reserve ratio\\n  function addToken(\\n    address tokenAddress,\\n    bool acceptingDeposits,\\n    bool acceptingWithdrawals,\\n    uint256 biosRewardWeight,\\n    uint256 reserveRatioNumerator\\n  ) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function enableTokenDeposits(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function disableTokenDeposits(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function enableTokenWithdrawals(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function disableTokenWithdrawals(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @param rewardWeight The updated token BIOS reward weight\\n  function updateTokenRewardWeight(address tokenAddress, uint256 rewardWeight)\\n    external;\\n\\n  /// @param tokenAddress the address of the token ERC20 contract\\n  /// @param reserveRatioNumerator Number that gets divided by reserve ratio denominator to get reserve ratio\\n  function updateTokenReserveRatioNumerator(\\n    address tokenAddress,\\n    uint256 reserveRatioNumerator\\n  ) external;\\n\\n  /// @param integrationId The ID of the integration\\n  /// @return The address of the integration contract\\n  function getIntegrationAddress(uint256 integrationId)\\n    external\\n    view\\n    returns (address);\\n\\n  /// @param integrationAddress The address of the integration contract\\n  /// @return The name of the of the protocol being integrated to\\n  function getIntegrationName(address integrationAddress)\\n    external\\n    view\\n    returns (string memory);\\n\\n  /// @return The address of the WETH token\\n  function getWethTokenAddress() external view returns (address);\\n\\n  /// @return The address of the BIOS token\\n  function getBiosTokenAddress() external view returns (address);\\n\\n  /// @param tokenId The ID of the token\\n  /// @return The address of the token ERC20 contract\\n  function getTokenAddress(uint256 tokenId) external view returns (address);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The index of the token in the tokens array\\n  function getTokenId(address tokenAddress) external view returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The token BIOS reward weight\\n  function getTokenBiosRewardWeight(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return rewardWeightSum reward weight of depositable tokens\\n  function getBiosRewardWeightSum()\\n    external\\n    view\\n    returns (uint256 rewardWeightSum);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return bool indicating whether depositing this token is currently enabled\\n  function getTokenAcceptingDeposits(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return bool indicating whether withdrawing this token is currently enabled\\n  function getTokenAcceptingWithdrawals(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  // @param tokenAddress The address of the token ERC20 contract\\n  // @return bool indicating whether the token has been added\\n  function getIsTokenAdded(address tokenAddress) external view returns (bool);\\n\\n  // @param integrationAddress The address of the integration contract\\n  // @return bool indicating whether the integration has been added\\n  function getIsIntegrationAdded(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  /// @notice get the length of supported tokens\\n  /// @return The quantity of tokens added\\n  function getTokenAddressesLength() external view returns (uint256);\\n\\n  /// @notice get the length of supported integrations\\n  /// @return The quantity of integrations added\\n  function getIntegrationAddressesLength() external view returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The value that gets divided by the reserve ratio denominator\\n  function getTokenReserveRatioNumerator(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return The token reserve ratio denominator\\n  function getReserveRatioDenominator() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IKernel {\\n  /// @param account The address of the account to check if they are a manager\\n  /// @return Bool indicating whether the account is a manger\\n  function isManager(address account) external view returns (bool);\\n\\n  /// @param account The address of the account to check if they are an owner\\n  /// @return Bool indicating whether the account is an owner\\n  function isOwner(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IModuleMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nenum Modules {\\n  Kernel, // 0\\n  UserPositions, // 1\\n  YieldManager, // 2\\n  IntegrationMap, // 3\\n  BiosRewards, // 4\\n  EtherRewards, // 5\\n  SushiSwapTrader, // 6\\n  UniswapTrader, // 7\\n  StrategyMap, // 8\\n  StrategyManager // 9\\n}\\n\\ninterface IModuleMap {\\n  function getModuleAddress(Modules key) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapFactory {\\n  /// @param tokenA The contract address of either token0 or token1\\n  /// @param tokenB The contract address of the other token\\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n  /// @return pool The pool address\\n  function getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 fee\\n  ) external view returns (address pool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapPool {\\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n  /// when accessed externally.\\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n  /// boundary.\\n  /// observationIndex The index of the last oracle observation that was written,\\n  /// observationCardinality The current maximum number of observations stored in the pool,\\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n  /// feeProtocol The protocol fee for both tokens of the pool.\\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n  /// unlocked Whether the pool is currently locked to reentrancy\\n  function slot0()\\n    external\\n    view\\n    returns (\\n      uint160 sqrtPriceX96,\\n      int24 tick,\\n      uint16 observationIndex,\\n      uint16 observationCardinality,\\n      uint16 observationCardinalityNext,\\n      uint8 feeProtocol,\\n      bool unlocked\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapPositionManager {\\n  struct MintParams {\\n    address token0;\\n    address token1;\\n    uint24 fee;\\n    int24 tickLower;\\n    int24 tickUpper;\\n    uint256 amount0Desired;\\n    uint256 amount1Desired;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    address recipient;\\n    uint256 deadline;\\n  }\\n\\n  struct IncreaseLiquidityParams {\\n    uint256 tokenId;\\n    uint256 amount0Desired;\\n    uint256 amount1Desired;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    uint256 deadline;\\n  }\\n\\n  struct DecreaseLiquidityParams {\\n    uint256 tokenId;\\n    uint128 liquidity;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    uint256 deadline;\\n  }\\n\\n  struct CollectParams {\\n    uint256 tokenId;\\n    address recipient;\\n    uint128 amount0Max;\\n    uint128 amount1Max;\\n  }\\n\\n  /// @notice Creates a new position wrapped in a NFT\\n  /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\\n  /// a method does not exist, i.e. the pool is assumed to be initialized.\\n  /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\\n  /// @return tokenId The ID of the token that represents the minted position\\n  /// @return liquidity The amount of liquidity for this position\\n  /// @return amount0 The amount of token0\\n  /// @return amount1 The amount of token1\\n  function mint(MintParams calldata params)\\n    external\\n    payable\\n    returns (\\n      uint256 tokenId,\\n      uint128 liquidity,\\n      uint256 amount0,\\n      uint256 amount1\\n    );\\n\\n  /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\\n  /// @param params tokenId The ID of the token for which liquidity is being increased,\\n  /// amount0Desired The desired amount of token0 to be spent,\\n  /// amount1Desired The desired amount of token1 to be spent,\\n  /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\\n  /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\\n  /// deadline The time by which the transaction must be included to effect the change\\n  /// @return liquidity The new liquidity amount as a result of the increase\\n  /// @return amount0 The amount of token0 to acheive resulting liquidity\\n  /// @return amount1 The amount of token1 to acheive resulting liquidity\\n  function increaseLiquidity(IncreaseLiquidityParams calldata params)\\n    external\\n    payable\\n    returns (\\n      uint128 liquidity,\\n      uint256 amount0,\\n      uint256 amount1\\n    );\\n\\n  /// @notice Decreases the amount of liquidity in a position and accounts it to the position\\n  /// @param params tokenId The ID of the token for which liquidity is being decreased,\\n  /// amount The amount by which liquidity will be decreased,\\n  /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\\n  /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\\n  /// deadline The time by which the transaction must be included to effect the change\\n  /// @return amount0 The amount of token0 accounted to the position's tokens owed\\n  /// @return amount1 The amount of token1 accounted to the position's tokens owed\\n  function decreaseLiquidity(DecreaseLiquidityParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amount0, uint256 amount1);\\n\\n  /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\n  /// @param params tokenId The ID of the NFT for which tokens are being collected,\\n  /// recipient The account that should receive the tokens,\\n  /// amount0Max The maximum amount of token0 to collect,\\n  /// amount1Max The maximum amount of token1 to collect\\n  /// @return amount0 The amount of fees collected in token0\\n  /// @return amount1 The amount of fees collected in token1\\n  function collect(CollectParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amount0, uint256 amount1);\\n\\n  /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\\n  /// must be collected first.\\n  /// @param tokenId The ID of the token that is being burned\\n  function burn(uint256 tokenId) external payable;\\n\\n  /// @notice Returns the position information associated with a given token ID.\\n  /// @dev Throws if the token ID is not valid.\\n  /// @param tokenId The ID of the token that represents the position\\n  /// @return nonce The nonce for permits\\n  /// @return operator The address that is approved for spending\\n  /// @return token0 The address of the token0 for a specific pool\\n  /// @return token1 The address of the token1 for a specific pool\\n  /// @return fee The fee associated with the pool\\n  /// @return tickLower The lower end of the tick range for the position\\n  /// @return tickUpper The higher end of the tick range for the position\\n  /// @return liquidity The liquidity of the position\\n  /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\\n  /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\\n  /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\\n  /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\\n  function positions(uint256 tokenId)\\n    external\\n    view\\n    returns (\\n      uint96 nonce,\\n      address operator,\\n      address token0,\\n      address token1,\\n      uint24 fee,\\n      int24 tickLower,\\n      int24 tickUpper,\\n      uint128 liquidity,\\n      uint256 feeGrowthInside0LastX128,\\n      uint256 feeGrowthInside1LastX128,\\n      uint128 tokensOwed0,\\n      uint128 tokensOwed1\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapSwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapSwapRouter {\\n  struct ExactInputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 amountOutMinimum;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  struct ExactOutputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 amountInMaximum;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  struct ExactInputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 amountOutMinimum;\\n  }\\n\\n  struct ExactOutputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 amountInMaximum;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function exactInputSingle(ExactInputSingleParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountOut);\\n\\n  /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n  /// @return amountIn The amount of the input token\\n  function exactOutputSingle(ExactOutputSingleParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountIn);\\n\\n  function exactInput(ExactInputParams calldata params)\\n    external\\n    returns (uint256 amountOut);\\n\\n  function exactOutput(ExactOutputParams calldata params)\\n    external\\n    returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapTrader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapTrader {\\n  struct Path {\\n    address tokenOut;\\n    uint256 firstPoolFee;\\n    address tokenInTokenOut;\\n    uint256 secondPoolFee;\\n    address tokenIn;\\n  }\\n\\n  /// @param tokenA The address of tokenA ERC20 contract\\n  /// @param tokenB The address of tokenB ERC20 contract\\n  /// @param fee The Uniswap pool fee\\n  /// @param slippageNumerator The value divided by the slippage denominator\\n  /// to calculate the allowable slippage\\n  function addPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 fee,\\n    uint24 slippageNumerator\\n  ) external;\\n\\n  /// @param tokenA The address of tokenA of the pool\\n  /// @param tokenB The address of tokenB of the pool\\n  /// @param poolIndex The index of the pool for the specified token pair\\n  /// @param slippageNumerator The new slippage numerator to update the pool\\n  function updatePoolSlippageNumerator(\\n    address tokenA,\\n    address tokenB,\\n    uint256 poolIndex,\\n    uint24 slippageNumerator\\n  ) external;\\n\\n  /// @notice Changes which Uniswap pool to use as the default pool\\n  /// @notice when swapping between token0 and token1\\n  /// @param tokenA The address of tokenA of the pool\\n  /// @param tokenB The address of tokenB of the pool\\n  /// @param primaryPoolIndex The index of the Uniswap pool to make the new primary pool\\n  function updatePairPrimaryPool(\\n    address tokenA,\\n    address tokenB,\\n    uint256 primaryPoolIndex\\n  ) external;\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param recipient The address to receive the tokens\\n  /// @param amountIn The exact amount of the input to swap\\n  /// @return tradeSuccess Indicates whether the trade succeeded\\n  function swapExactInput(\\n    address tokenIn,\\n    address tokenOut,\\n    address recipient,\\n    uint256 amountIn\\n  ) external returns (bool tradeSuccess);\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param recipient The address to receive the tokens\\n  /// @param amountOut The exact amount of the output token to receive\\n  /// @return tradeSuccess Indicates whether the trade succeeded\\n  function swapExactOutput(\\n    address tokenIn,\\n    address tokenOut,\\n    address recipient,\\n    uint256 amountOut\\n  ) external returns (bool tradeSuccess);\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param amountOut The exact amount of token being swapped for\\n  /// @return amountInMaximum The maximum amount of tokenIn to spend, factoring in allowable slippage\\n  function getAmountInMaximum(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountOut\\n  ) external view returns (uint256 amountInMaximum);\\n\\n  /// @param tokenIn The address of the input token\\n  /// @param tokenOut The address of the output token\\n  /// @param amountIn The exact amount of the input to swap\\n  /// @return amountOut The estimated amount of tokenOut to receive\\n  function getEstimatedTokenOut(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountIn\\n  ) external view returns (uint256 amountOut);\\n\\n  function getPathFor(address tokenOut, address tokenIn)\\n    external\\n    view\\n    returns (Path memory);\\n\\n  function setPathFor(\\n    address tokenOut,\\n    address tokenIn,\\n    uint256 firstPoolFee,\\n    address tokenInTokenOut,\\n    uint256 secondPoolFee\\n  ) external;\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @return token0 The address of the sorted token0\\n  /// @return token1 The address of the sorted token1\\n  function getTokensSorted(address tokenA, address tokenB)\\n    external\\n    pure\\n    returns (address token0, address token1);\\n\\n  /// @return The number of token pairs configured\\n  function getTokenPairsLength() external view returns (uint256);\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @return The quantity of pools configured for the specified token pair\\n  function getTokenPairPoolsLength(address tokenA, address tokenB)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @param tokenA The address of tokenA\\n  /// @param tokenB The address of tokenB\\n  /// @param poolId The index of the pool in the pools mapping\\n  /// @return feeNumerator The numerator that gets divided by the fee denominator\\n  function getPoolFeeNumerator(\\n    address tokenA,\\n    address tokenB,\\n    uint256 poolId\\n  ) external view returns (uint24 feeNumerator);\\n\\n  function getPoolAddress(address tokenA, address tokenB)\\n    external\\n    view\\n    returns (address pool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity >=0.7.6;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = denominator & (~denominator + 1);\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"primaryPoolIndex\",\"type\":\"uint256\"}],\"name\":\"UniswapPairPrimaryPoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"slippageNumerator\",\"type\":\"uint24\"}],\"name\":\"UniswapPoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"slippageNumerator\",\"type\":\"uint24\"}],\"name\":\"UniswapPoolSlippageNumeratorUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"}],\"name\":\"__Controlled_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"addController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"feeNumerator\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"slippageNumerator\",\"type\":\"uint24\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"getAmountInMaximum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountOutMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"getEstimatedTokenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getEstimatedTokenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeDenominator\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getPathFor\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"firstPoolFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenInTokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"secondPoolFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"internalType\":\"struct IUniswapTrader.Path\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getPoolFeeNumerator\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"feeNumerator\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getPoolSlippageNumerator\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"slippageNumerator\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSlippageDenominator\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getSqrtPriceX96\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenPairIndex\",\"type\":\"uint256\"}],\"name\":\"getTokenPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getTokenPairPoolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"getTokensAndAmountsSorted\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getTokensSorted\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factoryAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapRouterAddress_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleMap\",\"outputs\":[{\"internalType\":\"contract IModuleMap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"firstPoolFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenInTokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"secondPoolFee\",\"type\":\"uint256\"}],\"name\":\"setPathFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"swapExactInput\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"tradeSuccess\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"swapExactOutput\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"tradeSuccess\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"primaryPoolIndex\",\"type\":\"uint256\"}],\"name\":\"updatePairPrimaryPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"slippageNumerator\",\"type\":\"uint24\"}],\"name\":\"updatePoolSlippageNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapTrader","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":""}]}