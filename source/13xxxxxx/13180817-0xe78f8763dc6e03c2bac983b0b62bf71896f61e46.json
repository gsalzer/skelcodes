{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function decimals() public view returns (uint256);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\nlibrary ERC20SafeTransfer {\r\n    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\r\n        (success,) = _tokenAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _value));\r\n        require(success, \"Transfer failed\");\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        (success,) = _tokenAddress.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _from, _to, _value));\r\n        require(success, \"Transfer From failed\");\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\r\n        (success,) = _tokenAddress.call(abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _value));\r\n        require(success,  \"Approve failed\");\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function fetchReturnData() internal pure returns (bool success){\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 {\r\n                success := 1\r\n            }\r\n            case 32 {\r\n                returndatacopy(0, 0, 32)\r\n                success := mload(0)\r\n            }\r\n            default {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/*\r\n    Modified Util contract as used by Kyber Network\r\n*/\r\n\r\nlibrary Utils {\r\n\r\n    uint256 constant internal PRECISION = (10**18);\r\n    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint256 constant internal MAX_DECIMALS = 18;\r\n    uint256 constant internal ETH_DECIMALS = 18;\r\n    uint256 constant internal MAX_UINT = 2**256-1;\r\n    address constant internal ETH_ADDRESS = address(0x0);\r\n\r\n    // Currently constants can't be accessed from other contracts, so providing functions to do that here\r\n    function precision() internal pure returns (uint256) { return PRECISION; }\r\n    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\r\n    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\r\n    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\r\n    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\r\n    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\r\n    function eth_address() internal pure returns (address) { return ETH_ADDRESS; }\r\n\r\n    /// @notice Retrieve the number of decimals used for a given ERC20 token\r\n    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\r\n    /// ensure that an exception doesn't cause transaction failure\r\n    /// @param token the token for which we should retrieve the decimals\r\n    /// @return decimals the number of decimals in the given token\r\n    function getDecimals(address token)\r\n        internal\r\n        returns (uint256 decimals)\r\n    {\r\n        bytes4 functionSig = bytes4(keccak256(\"decimals()\"));\r\n\r\n        /// @dev Using assembly due to issues with current solidity `address.call()`\r\n        /// implementation: https://github.com/ethereum/solidity/issues/2884\r\n        assembly {\r\n            // Pointer to next free memory slot\r\n            let ptr := mload(0x40)\r\n            // Store functionSig variable at ptr\r\n            mstore(ptr,functionSig)\r\n            let functionSigLength := 0x04\r\n            let wordLength := 0x20\r\n\r\n            let success := call(\r\n                                gas, // Amount of gas\r\n                                token, // Address to call\r\n                                0, // ether to send\r\n                                ptr, // ptr to input data\r\n                                functionSigLength, // size of data\r\n                                ptr, // where to store output data (overwrite input)\r\n                                wordLength // size of output data (32 bytes)\r\n                               )\r\n\r\n            switch success\r\n            case 0 {\r\n                decimals := 0 // If the token doesn't implement `decimals()`, return 0 as default\r\n            }\r\n            case 1 {\r\n                decimals := mload(ptr) // Set decimals to return data from call\r\n            }\r\n            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\r\n        }\r\n    }\r\n\r\n    /// @dev Checks that a given address has its token allowance and balance set above the given amount\r\n    /// @param tokenOwner the address which should have custody of the token\r\n    /// @param tokenAddress the address of the token to check\r\n    /// @param tokenAmount the amount of the token which should be set\r\n    /// @param addressToAllow the address which should be allowed to transfer the token\r\n    /// @return bool true if the allowance and balance is set, false if not\r\n    function tokenAllowanceAndBalanceSet(\r\n        address tokenOwner,\r\n        address tokenAddress,\r\n        uint256 tokenAmount,\r\n        address addressToAllow\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\r\n            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\r\n        );\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal returns (uint) {\r\n        return calcDstQty(srcAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal returns (uint) {\r\n        return calcSrcQty(destAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns (uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n/*\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address payable public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address payable _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address payable _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"Contract is paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused, \"Contract not paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\ncontract PartnerRegistry is Ownable, Pausable {\r\n\r\n    address target;\r\n    mapping(address => bool) partnerContracts;\r\n    address payable public companyBeneficiary;\r\n    uint256 public basePercentage;\r\n    PartnerRegistry public previousRegistry;\r\n\r\n    event PartnerRegistered(address indexed creator, address indexed beneficiary, address partnerContract);\r\n\r\n    constructor(PartnerRegistry _previousRegistry, address _target, address payable _companyBeneficiary, uint256 _basePercentage) public {\r\n        previousRegistry = _previousRegistry;\r\n        target = _target;\r\n        companyBeneficiary = _companyBeneficiary;\r\n        basePercentage = _basePercentage;\r\n    }\r\n\r\n    function registerPartner(address payable partnerBeneficiary, uint256 partnerPercentage) whenNotPaused external {\r\n        Partner newPartner = Partner(createClone());\r\n        newPartner.init(this,address(0x0000000000000000000000000000000000000000), 0, partnerBeneficiary, partnerPercentage);\r\n        partnerContracts[address(newPartner)] = true;\r\n        emit PartnerRegistered(address(msg.sender), partnerBeneficiary, address(newPartner));\r\n    }\r\n\r\n    function overrideRegisterPartner(\r\n        address payable _companyBeneficiary,\r\n        uint256 _companyPercentage,\r\n        address payable partnerBeneficiary,\r\n        uint256 partnerPercentage\r\n    ) external onlyOwner {\r\n        Partner newPartner = Partner(createClone());\r\n        newPartner.init(PartnerRegistry(0x0000000000000000000000000000000000000000), _companyBeneficiary, _companyPercentage, partnerBeneficiary, partnerPercentage);\r\n        partnerContracts[address(newPartner)] = true;\r\n        emit PartnerRegistered(address(msg.sender), partnerBeneficiary, address(newPartner));\r\n    }\r\n\r\n    function deletePartner(address _partnerAddress) external onlyOwner {\r\n        partnerContracts[_partnerAddress] = false;\r\n    }\r\n\r\n    function createClone() internal returns (address payable result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n\r\n    function isValidPartner(address partnerContract) external view returns(bool) {\r\n        return partnerContracts[partnerContract] || previousRegistry.isValidPartner(partnerContract);\r\n    }\r\n\r\n    function updateCompanyInfo(address payable newCompanyBeneficiary, uint256 newBasePercentage) external onlyOwner {\r\n        companyBeneficiary = newCompanyBeneficiary;\r\n        basePercentage = newBasePercentage;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n}\r\n\r\ncontract Partner {\r\n\r\n    address payable public partnerBeneficiary;\r\n    uint256 public partnerPercentage; //This is out of 1 ETH, e.g. 0.5 ETH is 50% of the fee\r\n\r\n    uint256 public overrideCompanyPercentage;\r\n    address payable public overrideCompanyBeneficiary;\r\n\r\n    PartnerRegistry public registry;\r\n\r\n    event LogPayout(\r\n        address[] tokens,\r\n        uint256[] amount\r\n    );\r\n\r\n    function init(\r\n        PartnerRegistry _registry,\r\n        address payable _overrideCompanyBeneficiary,\r\n        uint256 _overrideCompanyPercentage,\r\n        address payable _partnerBeneficiary,\r\n        uint256 _partnerPercentage\r\n    ) public {\r\n        require(registry == PartnerRegistry(0x0000000000000000000000000000000000000000) &&\r\n          overrideCompanyBeneficiary == address(0x0) && partnerBeneficiary == address(0x0)\r\n        );\r\n        overrideCompanyBeneficiary = _overrideCompanyBeneficiary;\r\n        overrideCompanyPercentage = _overrideCompanyPercentage;\r\n        partnerBeneficiary = _partnerBeneficiary;\r\n        partnerPercentage = _partnerPercentage;\r\n        overrideCompanyPercentage = _overrideCompanyPercentage;\r\n        registry = _registry;\r\n    }\r\n\r\n    function payout(\r\n        address[] memory tokens\r\n    ) public {\r\n        uint totalFeePercentage = getTotalFeePercentage();\r\n        address payable companyBeneficiary = companyBeneficiary();\r\n        uint256[] memory amountsPaidOut = new uint256[](tokens.length);\r\n        // Payout both the partner and the company at the same time\r\n        for(uint256 index = 0; index<tokens.length; index++){\r\n            uint256 balance = tokens[index] == Utils.eth_address() ? address(this).balance : ERC20(tokens[index]).balanceOf(address(this));\r\n            amountsPaidOut[index] = balance;\r\n            uint256 partnerAmount = SafeMath.div(SafeMath.mul(balance, partnerPercentage), getTotalFeePercentage());\r\n            uint256 companyAmount = balance - partnerAmount;\r\n            if(tokens[index] == Utils.eth_address()){\r\n                partnerBeneficiary.transfer(partnerAmount);\r\n                companyBeneficiary.transfer(companyAmount);\r\n            } else {\r\n                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\r\n                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\r\n            }\r\n        }\r\n\t    emit LogPayout(tokens,amountsPaidOut);\r\n    }\r\n\r\n    function getTotalFeePercentage() public view returns (uint256){\r\n        return partnerPercentage + companyPercentage();\r\n    }\r\n\r\n    function companyPercentage() public view returns (uint256){\r\n        if(registry != PartnerRegistry(0x0000000000000000000000000000000000000000)){\r\n            return Math.max(registry.basePercentage(), partnerPercentage);\r\n        } else {\r\n            return overrideCompanyPercentage;\r\n        }\r\n    }\r\n\r\n    function companyBeneficiary() public view returns (address payable) {\r\n        if(registry != PartnerRegistry(0x0000000000000000000000000000000000000000)){\r\n            return registry.companyBeneficiary();\r\n        } else {\r\n            return overrideCompanyBeneficiary;\r\n        }    \r\n    }\r\n\r\n    function() external payable {\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTotalFeePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"overrideCompanyBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"overrideCompanyPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_overrideCompanyBeneficiary\",\"type\":\"address\"},{\"name\":\"_overrideCompanyPercentage\",\"type\":\"uint256\"},{\"name\":\"_partnerBeneficiary\",\"type\":\"address\"},{\"name\":\"_partnerPercentage\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"LogPayout\",\"type\":\"event\"}]","ContractName":"Partner","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://60ee124640108287e33e19408f7c093c019cbe12ba4c631ab4ab0bb0eb3ed7cf"}]}