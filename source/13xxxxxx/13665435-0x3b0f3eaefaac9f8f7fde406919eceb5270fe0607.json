{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./interfaces/IController.sol\\\";\\nimport \\\"./TellorVars.sol\\\";\\nimport \\\"./interfaces/IGovernance.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title Treasury\\n @dev This is the Treasury contract which defines the function for Tellor\\n * treasuries, or staking pools.\\n*/\\ncontract Treasury is TellorVars {\\n    // Storage\\n    uint256 public totalLocked; // amount of TRB locked across all treasuries\\n    uint256 public treasuryCount; // number of total treasuries\\n    mapping(uint256 => TreasuryDetails) public treasury; // maps an ID to a treasury and its corresponding details\\n    mapping(address => uint256) treasuryFundsByUser; // maps a treasury investor to their total treasury funds, in TRB\\n\\n    // Structs\\n    // Internal struct used to keep track of an individual user in a treasury\\n    struct TreasuryUser {\\n        uint256 amount; // the amount the user has placed in a treasury, in TRB\\n        uint256 startVoteCount; // the amount of votes that have been cast when a user deposits their money into a treasury\\n        bool paid; // determines if a user has paid/voted in Tellor governance proposals\\n    }\\n    // Internal struct used to keep track of a treasury and its pertinent attributes (amount, interest rate, etc.)\\n    struct TreasuryDetails {\\n        uint256 dateStarted; // the date that treasury was started\\n        uint256 maxAmount; // the maximum amount stored in the treasury, in TRB\\n        uint256 rate; // the interest rate of the treasury (5% == 500)\\n        uint256 purchasedAmount; // the amount of TRB purchased from the treasury\\n        uint256 duration; // the time during which the treasury locks participants\\n        uint256 endVoteCount; // the end vote count when the treasury duration is over\\n        bool endVoteCountRecorded; // determines whether the end vote count has been calculated or not\\n        address[] owners; // the owners of the treasury\\n        mapping(address => TreasuryUser) accounts; // a mapping of a treasury user address and corresponding details\\n    }\\n\\n    // Events\\n    event TreasuryIssued(uint256 _id, uint256 _amount, uint256 _rate);\\n    event TreasuryPaid(address _investor, uint256 _amount);\\n    event TreasuryPurchased(address _investor, uint256 _amount);\\n\\n    // Functions\\n    /**\\n     * @dev This is an external function that is used to deposit money into a treasury.\\n     * @param _id is the ID for a specific treasury instance\\n     * @param _amount is the amount to deposit into a treasury\\n     */\\n    function buyTreasury(uint256 _id, uint256 _amount) external {\\n        // Transfer sender funds to Treasury\\n        require(_amount > 0, \\\"Amount must be greater than zero.\\\");\\n        require(\\n            IController(TELLOR_ADDRESS).approveAndTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _amount\\n            ),\\n            \\\"Insufficient balance. Try a lower amount.\\\"\\n        );\\n        treasuryFundsByUser[msg.sender] += _amount;\\n        // Check for sufficient treasury funds\\n        TreasuryDetails storage _treas = treasury[_id];\\n        require(\\n            _treas.dateStarted + _treas.duration > block.timestamp,\\n            \\\"Treasury duration has expired.\\\"\\n        );\\n        require(\\n            _amount <= _treas.maxAmount - _treas.purchasedAmount,\\n            \\\"Not enough money in treasury left to purchase.\\\"\\n        );\\n        // Update treasury details -- vote count, purchasedAmount, amount, and owners\\n        address _governanceContract = IController(TELLOR_ADDRESS).addresses(\\n            _GOVERNANCE_CONTRACT\\n        );\\n        if (_treas.accounts[msg.sender].amount == 0) {\\n            _treas.accounts[msg.sender].startVoteCount = IGovernance(\\n                _governanceContract\\n            ).getVoteCount();\\n            _treas.owners.push(msg.sender);\\n        }\\n        _treas.purchasedAmount += _amount;\\n        _treas.accounts[msg.sender].amount += _amount;\\n        totalLocked += _amount;\\n        emit TreasuryPurchased(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev This is an external function that is used to issue a new treasury.\\n     * Note that only the governance contract can call this function.\\n     * @param _maxAmount is the amount of total TRB that treasury stores\\n     * @param _rate is the treasury's interest rate in BP\\n     * @param _duration is the amount of time the treasury locks participants\\n     */\\n    function issueTreasury(\\n        uint256 _maxAmount,\\n        uint256 _rate,\\n        uint256 _duration\\n    ) external {\\n        require(\\n            msg.sender ==\\n                IController(TELLOR_ADDRESS).addresses(_GOVERNANCE_CONTRACT),\\n            \\\"Only governance contract is allowed to issue a treasury.\\\"\\n        );\\n        require(\\n            _maxAmount > 0 &&\\n                _maxAmount <= IController(TELLOR_ADDRESS).totalSupply(),\\n            \\\"Invalid maxAmount value\\\"\\n        );\\n        require(\\n            _duration > 0 && _duration <= 315360000,\\n            \\\"Invalid duration value\\\"\\n        );\\n        require(_rate > 0 && _rate <= 10000, \\\"Invalid rate value\\\");\\n        // Increment treasury count, and define new treasury and its details (start date, total amount, rate, etc.)\\n        treasuryCount++;\\n        TreasuryDetails storage _treas = treasury[treasuryCount];\\n        _treas.dateStarted = block.timestamp;\\n        _treas.maxAmount = _maxAmount;\\n        _treas.rate = _rate;\\n        _treas.duration = _duration;\\n        emit TreasuryIssued(treasuryCount, _maxAmount, _rate);\\n    }\\n\\n    /**\\n     * @dev This functions allows an investor to pay the treasury. Internally, the function calculates the number of\\n     votes in governance contract when issued, and also transfers the amount individually locked + interest to the investor.\\n     * @param _id is the ID of the treasury the account is stored in\\n     * @param _investor is the address of the account in the treasury\\n     */\\n    function payTreasury(address _investor, uint256 _id) external {\\n        // Validate ID of treasury, duration for treasury has not passed, and the user has not paid\\n        TreasuryDetails storage _treas = treasury[_id];\\n        require(\\n            _id <= treasuryCount,\\n            \\\"ID does not correspond to a valid treasury.\\\"\\n        );\\n        require(\\n            _treas.dateStarted + _treas.duration <= block.timestamp,\\n            \\\"Treasury duration has not expired.\\\"\\n        );\\n        require(\\n            !_treas.accounts[_investor].paid,\\n            \\\"Treasury investor has already been paid.\\\"\\n        );\\n        require(\\n            _treas.accounts[_investor].amount > 0,\\n            \\\"Address is not a treasury investor\\\"\\n        );\\n        // Calculate non-voting penalty (treasury holders have to vote)\\n        uint256 numVotesParticipated;\\n        uint256 votesSinceTreasury;\\n        address governanceContract = IController(TELLOR_ADDRESS).addresses(\\n            _GOVERNANCE_CONTRACT\\n        );\\n        // Find endVoteCount if not already calculated\\n        if (!_treas.endVoteCountRecorded) {\\n            uint256 voteCountIter = IGovernance(governanceContract)\\n                .getVoteCount();\\n            if (voteCountIter > 0) {\\n                (, uint256[8] memory voteInfo, , , , , ) = IGovernance(\\n                    governanceContract\\n                ).getVoteInfo(voteCountIter);\\n                while (\\n                    voteCountIter > 0 &&\\n                    voteInfo[1] > _treas.dateStarted + _treas.duration\\n                ) {\\n                    voteCountIter--;\\n                    if (voteCountIter > 0) {\\n                        (, voteInfo, , , , , ) = IGovernance(governanceContract)\\n                            .getVoteInfo(voteCountIter);\\n                    }\\n                }\\n            }\\n            _treas.endVoteCount = voteCountIter;\\n            _treas.endVoteCountRecorded = true;\\n        }\\n        // Add up number of votes _investor has participated in\\n        if (_treas.endVoteCount > _treas.accounts[_investor].startVoteCount) {\\n            for (\\n                uint256 voteCount = _treas.accounts[_investor].startVoteCount;\\n                voteCount < _treas.endVoteCount;\\n                voteCount++\\n            ) {\\n                bool voted = IGovernance(governanceContract).didVote(\\n                    voteCount + 1,\\n                    _investor\\n                );\\n                if (voted) {\\n                    numVotesParticipated++;\\n                }\\n                votesSinceTreasury++;\\n            }\\n        }\\n        // Determine amount of TRB to mint for interest\\n        uint256 _mintAmount = (_treas.accounts[_investor].amount *\\n            _treas.rate) / 10000;\\n        if (votesSinceTreasury > 0) {\\n            _mintAmount =\\n                (_mintAmount * numVotesParticipated) /\\n                votesSinceTreasury;\\n        }\\n        if (_mintAmount > 0) {\\n            IController(TELLOR_ADDRESS).mint(address(this), _mintAmount);\\n        }\\n        // Transfer locked amount + interest amount, and indicate user has paid\\n        totalLocked -= _treas.accounts[_investor].amount;\\n        IController(TELLOR_ADDRESS).transfer(\\n            _investor,\\n            _mintAmount + _treas.accounts[_investor].amount\\n        );\\n        treasuryFundsByUser[_investor] -= _treas.accounts[_investor].amount;\\n        _treas.accounts[_investor].paid = true;\\n        emit TreasuryPaid(\\n            _investor,\\n            _mintAmount + _treas.accounts[_investor].amount\\n        );\\n    }\\n\\n    // Getters\\n    /**\\n     * @dev This function returns the details of an account within a treasury.\\n     * Note: refer to 'TreasuryUser' struct.\\n     * @param _id is the ID of the treasury the account is stored in\\n     * @param _investor is the address of the account in the treasury\\n     * @return uint256 of the amount of TRB the account has staked in the treasury\\n     * @return uint256 of the start vote count of when the account deposited money into the treasury\\n     * @return bool of whether the treasury account has paid or not\\n     */\\n    function getTreasuryAccount(uint256 _id, address _investor)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        return (\\n            treasury[_id].accounts[_investor].amount,\\n            treasury[_id].accounts[_investor].startVoteCount,\\n            treasury[_id].accounts[_investor].paid\\n        );\\n    }\\n\\n    /**\\n     * @dev This function returns the number of treasuries/TellorX staking pools.\\n     * @return uint256 of the number of treasuries\\n     */\\n    function getTreasuryCount() external view returns (uint256) {\\n        return treasuryCount;\\n    }\\n\\n    function getTreasuryDetails(uint256 _id)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            treasury[_id].dateStarted,\\n            treasury[_id].maxAmount,\\n            treasury[_id].rate,\\n            treasury[_id].purchasedAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev This function returns the amount of TRB deposited by a user into treasuries.\\n     * @param _user is the specific account within a treasury to look up\\n     * @return uint256 of the amount of funds the user has, in TRB\\n     */\\n    function getTreasuryFundsByUser(address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return treasuryFundsByUser[_user];\\n    }\\n\\n    /**\\n     * @dev This function returns the addresses of the owners of a treasury\\n     * @param _id is the ID of a specific treasury\\n     * @return address[] memory of the addresses of the owners of the treasury\\n     */\\n    function getTreasuryOwners(uint256 _id)\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        return treasury[_id].owners;\\n    }\\n\\n    /**\\n     * @dev This function is used during the upgrade process to verify valid Tellor Contracts\\n     */\\n    function verify() external pure returns (uint256) {\\n        return 9999;\\n    }\\n\\n    /**\\n     * @dev This function determines whether or not an investor in a treasury has paid/voted on Tellor governance proposals\\n     * @param _id is the ID of the treasury the account is stored in\\n     * @param _investor is the address of the account in the treasury\\n     * @return bool of whether or not the investor was paid\\n     */\\n    function wasPaid(uint256 _id, address _investor)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return treasury[_id].accounts[_investor].paid;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface IController{\\r\\n    function addresses(bytes32) external returns(address);\\r\\n    function uints(bytes32) external returns(uint256);\\r\\n    function burn(uint256 _amount) external;\\r\\n    function changeDeity(address _newDeity) external;\\r\\n    function changeOwner(address _newOwner) external;\\r\\n    function changeTellorContract(address _tContract) external;\\r\\n    function changeControllerContract(address _newController) external;\\r\\n    function changeGovernanceContract(address _newGovernance) external;\\r\\n    function changeOracleContract(address _newOracle) external;\\r\\n    function changeTreasuryContract(address _newTreasury) external;\\r\\n    function changeUint(bytes32 _target, uint256 _amount) external;\\r\\n    function migrate() external;\\r\\n    function mint(address _reciever, uint256 _amount) external;\\r\\n    function init() external;\\r\\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256);\\r\\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool);\\r\\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\\r\\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256);\\r\\n    function getAddressVars(bytes32 _data) external view returns (address);\\r\\n    function getUintVar(bytes32 _data) external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function allowance(address _user, address _spender) external view  returns (uint256);\\r\\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool);\\r\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\r\\n    function approveAndTransferFrom(address _from, address _to, uint256 _amount) external returns(bool);\\r\\n    function balanceOf(address _user) external view returns (uint256);\\r\\n    function balanceOfAt(address _user, uint256 _blockNumber)external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _amount)external returns (bool success);\\r\\n    function transferFrom(address _from,address _to,uint256 _amount) external returns (bool success) ;\\r\\n    function depositStake() external;\\r\\n    function requestStakingWithdraw() external;\\r\\n    function withdrawStake() external;\\r\\n    function changeStakingStatus(address _reporter, uint _status) external;\\r\\n    function slashReporter(address _reporter, address _disputer) external;\\r\\n    function getStakerInfo(address _staker) external view returns (uint256, uint256);\\r\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256);\\r\\n    function getNewCurrentVariables()external view returns (bytes32 _c,uint256[5] memory _r,uint256 _d,uint256 _t);\\r\\n    //in order to call fallback function\\r\\n    function beginDispute(uint256 _requestId, uint256 _timestamp,uint256 _minerIndex) external;\\r\\n    function unlockDisputeFee(uint256 _disputeId) external;\\r\\n    function vote(uint256 _disputeId, bool _supportsDispute) external;\\r\\n    function tallyVotes(uint256 _disputeId) external;\\r\\n    //test functions\\r\\n    function tipQuery(uint,uint,bytes memory) external;\\r\\n    function getNewVariablesOnDeck() external view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TellorVars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./tellor3/TellorVariables.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title TellorVariables\\n @dev Helper contract to store hashes of variables.\\n * For each of the bytes32 constants, the values are equal to\\n * keccak256([VARIABLE NAME])\\n*/\\ncontract TellorVars is TellorVariables {\\n    // Storage\\n    address constant TELLOR_ADDRESS =\\n        0x88dF592F8eb5D7Bd38bFeF7dEb0fBc02cf3778a0; // Address of main Tellor Contract\\n    // Hashes for each pertinent contract\\n    bytes32 constant _GOVERNANCE_CONTRACT =\\n        0xefa19baa864049f50491093580c5433e97e8d5e41f8db1a61108b4fa44cacd93;\\n    bytes32 constant _ORACLE_CONTRACT =\\n        0xfa522e460446113e8fd353d7fa015625a68bc0369712213a42e006346440891e;\\n    bytes32 constant _TREASURY_CONTRACT =\\n        0x1436a1a60dca0ebb2be98547e57992a0fa082eb479e7576303cbd384e934f1fa;\\n    bytes32 constant _SWITCH_TIME =\\n        0x6c0e91a96227393eb6e42b88e9a99f7c5ebd588098b549c949baf27ac9509d8f;\\n    bytes32 constant _MINIMUM_DISPUTE_FEE =\\n        0x7335d16d7e7f6cb9f532376441907fe76aa2ea267285c82892601f4755ed15f0;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface IGovernance{\\r\\n    enum VoteResult {FAILED,PASSED,INVALID}\\r\\n    function setApprovedFunction(bytes4 _func, bool _val) external;\\r\\n    function beginDispute(bytes32 _queryId,uint256 _timestamp) external;\\r\\n    function delegate(address _delegate) external;\\r\\n    function delegateOfAt(address _user, uint256 _blockNumber) external view returns (address);\\r\\n    function executeVote(uint256 _disputeId) external;\\r\\n    function proposeVote(address _contract,bytes4 _function, bytes calldata _data, uint256 _timestamp) external;\\r\\n    function tallyVotes(uint256 _disputeId) external;\\r\\n    function updateMinDisputeFee() external;\\r\\n    function verify() external pure returns(uint);\\r\\n    function vote(uint256 _disputeId, bool _supports, bool _invalidQuery) external;\\r\\n    function voteFor(address[] calldata _addys,uint256 _disputeId, bool _supports, bool _invalidQuery) external;\\r\\n    function getDelegateInfo(address _holder) external view returns(address,uint);\\r\\n    function isApprovedGovernanceContract(address _contract) external view returns(bool);\\r\\n    function isFunctionApproved(bytes4 _func) external view returns(bool);\\r\\n    function getVoteCount() external view returns(uint256);\\r\\n    function getVoteRounds(bytes32 _hash) external view returns(uint256[] memory);\\r\\n    function getVoteInfo(uint256 _disputeId) external view returns(bytes32,uint256[8] memory,bool[2] memory,VoteResult,bytes memory,bytes4,address[2] memory);\\r\\n    function getDisputeInfo(uint256 _disputeId) external view returns(uint256,uint256,bytes memory, address);\\r\\n    function getOpenDisputesOnId(uint256 _queryId) external view returns(uint256);\\r\\n    function didVote(uint256 _disputeId, address _voter) external view returns(bool);\\r\\n    //testing\\r\\n    function testMin(uint256 a, uint256 b) external pure returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tellor3/TellorVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.4;\\n\\n/**\\n @author Tellor Inc.\\n @title TellorVariables\\n @dev Helper contract to store hashes of variables\\n*/\\ncontract TellorVariables {\\n    bytes32 constant _BLOCK_NUMBER =\\n        0x4b4cefd5ced7569ef0d091282b4bca9c52a034c56471a6061afd1bf307a2de7c; //keccak256(\\\"_BLOCK_NUMBER\\\");\\n    bytes32 constant _CURRENT_CHALLENGE =\\n        0xd54702836c9d21d0727ffacc3e39f57c92b5ae0f50177e593bfb5ec66e3de280; //keccak256(\\\"_CURRENT_CHALLENGE\\\");\\n    bytes32 constant _CURRENT_REQUESTID =\\n        0xf5126bb0ac211fbeeac2c0e89d4c02ac8cadb2da1cfb27b53c6c1f4587b48020; //keccak256(\\\"_CURRENT_REQUESTID\\\");\\n    bytes32 constant _CURRENT_REWARD =\\n        0xd415862fd27fb74541e0f6f725b0c0d5b5fa1f22367d9b78ec6f61d97d05d5f8; //keccak256(\\\"_CURRENT_REWARD\\\");\\n    bytes32 constant _CURRENT_TOTAL_TIPS =\\n        0x09659d32f99e50ac728058418d38174fe83a137c455ff1847e6fb8e15f78f77a; //keccak256(\\\"_CURRENT_TOTAL_TIPS\\\");\\n    bytes32 constant _DEITY =\\n        0x5fc094d10c65bc33cc842217b2eccca0191ff24148319da094e540a559898961; //keccak256(\\\"_DEITY\\\");\\n    bytes32 constant _DIFFICULTY =\\n        0xf758978fc1647996a3d9992f611883adc442931dc49488312360acc90601759b; //keccak256(\\\"_DIFFICULTY\\\");\\n    bytes32 constant _DISPUTE_COUNT =\\n        0x310199159a20c50879ffb440b45802138b5b162ec9426720e9dd3ee8bbcdb9d7; //keccak256(\\\"_DISPUTE_COUNT\\\");\\n    bytes32 constant _DISPUTE_FEE =\\n        0x675d2171f68d6f5545d54fb9b1fb61a0e6897e6188ca1cd664e7c9530d91ecfc; //keccak256(\\\"_DISPUTE_FEE\\\");\\n    bytes32 constant _DISPUTE_ROUNDS =\\n        0x6ab2b18aafe78fd59c6a4092015bddd9fcacb8170f72b299074f74d76a91a923; //keccak256(\\\"_DISPUTE_ROUNDS\\\");\\n    bytes32 constant _EXTENSION =\\n        0x2b2a1c876f73e67ebc4f1b08d10d54d62d62216382e0f4fd16c29155818207a4; //keccak256(\\\"_EXTENSION\\\");\\n    bytes32 constant _FEE =\\n        0x1da95f11543c9b03927178e07951795dfc95c7501a9d1cf00e13414ca33bc409; //keccak256(\\\"_FEE\\\");\\n    bytes32 constant _FORK_EXECUTED =\\n        0xda571dfc0b95cdc4a3835f5982cfdf36f73258bee7cb8eb797b4af8b17329875; //keccak256(\\\"_FORK_EXECUTED\\\");\\n    bytes32 constant _LOCK =\\n        0xd051321aa26ce60d202f153d0c0e67687e975532ab88ce92d84f18e39895d907;\\n    bytes32 constant _MIGRATOR =\\n        0xc6b005d45c4c789dfe9e2895b51df4336782c5ff6bd59a5c5c9513955aa06307; //keccak256(\\\"_MIGRATOR\\\");\\n    bytes32 constant _MIN_EXECUTION_DATE =\\n        0x46f7d53798d31923f6952572c6a19ad2d1a8238d26649c2f3493a6d69e425d28; //keccak256(\\\"_MIN_EXECUTION_DATE\\\");\\n    bytes32 constant _MINER_SLOT =\\n        0x6de96ee4d33a0617f40a846309c8759048857f51b9d59a12d3c3786d4778883d; //keccak256(\\\"_MINER_SLOT\\\");\\n    bytes32 constant _NUM_OF_VOTES =\\n        0x1da378694063870452ce03b189f48e04c1aa026348e74e6c86e10738514ad2c4; //keccak256(\\\"_NUM_OF_VOTES\\\");\\n    bytes32 constant _OLD_TELLOR =\\n        0x56e0987db9eaec01ed9e0af003a0fd5c062371f9d23722eb4a3ebc74f16ea371; //keccak256(\\\"_OLD_TELLOR\\\");\\n    bytes32 constant _ORIGINAL_ID =\\n        0xed92b4c1e0a9e559a31171d487ecbec963526662038ecfa3a71160bd62fb8733; //keccak256(\\\"_ORIGINAL_ID\\\");\\n    bytes32 constant _OWNER =\\n        0x7a39905194de50bde334d18b76bbb36dddd11641d4d50b470cb837cf3bae5def; //keccak256(\\\"_OWNER\\\");\\n    bytes32 constant _PAID =\\n        0x29169706298d2b6df50a532e958b56426de1465348b93650fca42d456eaec5fc; //keccak256(\\\"_PAID\\\");\\n    bytes32 constant _PENDING_OWNER =\\n        0x7ec081f029b8ac7e2321f6ae8c6a6a517fda8fcbf63cabd63dfffaeaafa56cc0; //keccak256(\\\"_PENDING_OWNER\\\");\\n    bytes32 constant _REQUEST_COUNT =\\n        0x3f8b5616fa9e7f2ce4a868fde15c58b92e77bc1acd6769bf1567629a3dc4c865; //keccak256(\\\"_REQUEST_COUNT\\\");\\n    bytes32 constant _REQUEST_ID =\\n        0x9f47a2659c3d32b749ae717d975e7962959890862423c4318cf86e4ec220291f; //keccak256(\\\"_REQUEST_ID\\\");\\n    bytes32 constant _REQUEST_Q_POSITION =\\n        0xf68d680ab3160f1aa5d9c3a1383c49e3e60bf3c0c031245cbb036f5ce99afaa1; //keccak256(\\\"_REQUEST_Q_POSITION\\\");\\n    bytes32 constant _SLOT_PROGRESS =\\n        0xdfbec46864bc123768f0d134913175d9577a55bb71b9b2595fda21e21f36b082; //keccak256(\\\"_SLOT_PROGRESS\\\");\\n    bytes32 constant _STAKE_AMOUNT =\\n        0x5d9fadfc729fd027e395e5157ef1b53ef9fa4a8f053043c5f159307543e7cc97; //keccak256(\\\"_STAKE_AMOUNT\\\");\\n    bytes32 constant _STAKE_COUNT =\\n        0x10c168823622203e4057b65015ff4d95b4c650b308918e8c92dc32ab5a0a034b; //keccak256(\\\"_STAKE_COUNT\\\");\\n    bytes32 constant _T_BLOCK =\\n        0xf3b93531fa65b3a18680d9ea49df06d96fbd883c4889dc7db866f8b131602dfb; //keccak256(\\\"_T_BLOCK\\\");\\n    bytes32 constant _TALLY_DATE =\\n        0xf9e1ae10923bfc79f52e309baf8c7699edb821f91ef5b5bd07be29545917b3a6; //keccak256(\\\"_TALLY_DATE\\\");\\n    bytes32 constant _TARGET_MINERS =\\n        0x0b8561044b4253c8df1d9ad9f9ce2e0f78e4bd42b2ed8dd2e909e85f750f3bc1; //keccak256(\\\"_TARGET_MINERS\\\");\\n    bytes32 constant _TELLOR_CONTRACT =\\n        0x0f1293c916694ac6af4daa2f866f0448d0c2ce8847074a7896d397c961914a08; //keccak256(\\\"_TELLOR_CONTRACT\\\");\\n    bytes32 constant _TELLOR_GETTERS =\\n        0xabd9bea65759494fe86471c8386762f989e1f2e778949e94efa4a9d1c4b3545a; //keccak256(\\\"_TELLOR_GETTERS\\\");\\n    bytes32 constant _TIME_OF_LAST_NEW_VALUE =\\n        0x2c8b528fbaf48aaf13162a5a0519a7ad5a612da8ff8783465c17e076660a59f1; //keccak256(\\\"_TIME_OF_LAST_NEW_VALUE\\\");\\n    bytes32 constant _TIME_TARGET =\\n        0xd4f87b8d0f3d3b7e665df74631f6100b2695daa0e30e40eeac02172e15a999e1; //keccak256(\\\"_TIME_TARGET\\\");\\n    bytes32 constant _TIMESTAMP =\\n        0x2f9328a9c75282bec25bb04befad06926366736e0030c985108445fa728335e5; //keccak256(\\\"_TIMESTAMP\\\");\\n    bytes32 constant _TOTAL_SUPPLY =\\n        0xe6148e7230ca038d456350e69a91b66968b222bfac9ebfbea6ff0a1fb7380160; //keccak256(\\\"_TOTAL_SUPPLY\\\");\\n    bytes32 constant _TOTAL_TIP =\\n        0x1590276b7f31dd8e2a06f9a92867333eeb3eddbc91e73b9833e3e55d8e34f77d; //keccak256(\\\"_TOTAL_TIP\\\");\\n    bytes32 constant _VALUE =\\n        0x9147231ab14efb72c38117f68521ddef8de64f092c18c69dbfb602ffc4de7f47; //keccak256(\\\"_VALUE\\\");\\n    bytes32 constant _EIP_SLOT =\\n        0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"TreasuryIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TreasuryPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TreasuryPurchased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getTreasuryAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTreasuryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getTreasuryDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTreasuryFundsByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getTreasuryOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"issueTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"payTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dateStarted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endVoteCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"endVoteCountRecorded\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"wasPaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Treasury","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"300","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}