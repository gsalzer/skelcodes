{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/LootBoxRandomness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\nabstract contract Factory {\\r\\n    function balanceOf(uint256 _tokenId, uint256 _optionId)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (bool);\\r\\n}\\r\\n\\r\\nlibrary LootBoxRandomness {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // Event for logging lootbox opens\\r\\n    event LootBoxOpened(\\r\\n        uint256 indexed optionId,\\r\\n        address indexed buyer,\\r\\n        uint256 boxesPurchased,\\r\\n        uint256 itemsMinted\\r\\n    );\\r\\n    event Warning(string message, address account);\\r\\n\\r\\n    uint256 constant INVERSE_BASIS_POINT = 10000;\\r\\n\\r\\n    struct OptionSettings {\\r\\n        uint256 maxQuantityPerOpen;\\r\\n        uint256[] classProbabilities;\\r\\n        bool hasGuaranteedClasses;\\r\\n        uint256[] guarantees;\\r\\n    }\\r\\n\\r\\n    struct LootBoxRandomnessState {\\r\\n        address factoryAddress;\\r\\n        uint256 numOptions;\\r\\n        uint256 numClasses;\\r\\n        uint256 numBox;\\r\\n        mapping(uint256 => OptionSettings) optionToSettings;\\r\\n        mapping(uint256 => mapping(uint256 => uint256)) classToTokenIds;\\r\\n        uint256 seed;\\r\\n    }\\r\\n\\r\\n    function initState(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        address _factoryAddress,\\r\\n        uint256 _numOptions,\\r\\n        uint256 _numClasses,\\r\\n        uint256 _numBox,\\r\\n        uint256 _seed\\r\\n    ) public {\\r\\n        _state.factoryAddress = _factoryAddress;\\r\\n        _state.numOptions = _numOptions;\\r\\n        _state.numClasses = _numClasses;\\r\\n        _state.numBox = _numBox;\\r\\n        _state.seed = _seed;\\r\\n    }\\r\\n\\r\\n    function setTokenIdsForClass(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _boxId,\\r\\n        uint256 _classId,\\r\\n        uint256 _tokenIds\\r\\n    ) public {\\r\\n        require(_boxId < _state.numBox, \\\"Box out of range\\\");\\r\\n        require(_classId < _state.numClasses, \\\"_class out of range\\\");\\r\\n        _state.classToTokenIds[_boxId][_classId] = _tokenIds;\\r\\n    }\\r\\n\\r\\n    function getTokenIdsForClass(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _boxId,\\r\\n        uint256 _classId\\r\\n    ) public view returns (uint256) {\\r\\n        require(_boxId < _state.numBox, \\\"Box out of range\\\");\\r\\n        require(_classId < _state.numClasses, \\\"_class out of range\\\");\\r\\n        return _state.classToTokenIds[_boxId][_classId];\\r\\n    }\\r\\n\\r\\n    function setOptionSettings(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _option,\\r\\n        uint256 _maxQuantityPerOpen,\\r\\n        uint256[] memory _classProbabilities,\\r\\n        uint256[] memory _guarantees\\r\\n    ) public {\\r\\n        require(_option < _state.numOptions, \\\"_option out of range\\\");\\r\\n\\r\\n        bool hasGuaranteedClasses = false;\\r\\n        for (uint256 i = 0; i < _guarantees.length; i++) {\\r\\n            if (_guarantees[i] > 0) {\\r\\n                hasGuaranteedClasses = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        OptionSettings memory settings = OptionSettings({\\r\\n            maxQuantityPerOpen: _maxQuantityPerOpen,\\r\\n            classProbabilities: _classProbabilities,\\r\\n            hasGuaranteedClasses: hasGuaranteedClasses,\\r\\n            guarantees: _guarantees\\r\\n        });\\r\\n\\r\\n        _state.optionToSettings[uint256(_option)] = settings;\\r\\n    }\\r\\n\\r\\n    function getQuantityPerOpen(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _option\\r\\n    ) public view returns (uint256) {\\r\\n        require(_option < _state.numOptions, \\\"_option out of range\\\");\\r\\n\\r\\n        return _state.optionToSettings[uint256(_option)].maxQuantityPerOpen;\\r\\n    }\\r\\n\\r\\n    function getQuantityGarantee(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _option,\\r\\n        uint256 classId\\r\\n    ) public view returns (uint256) {\\r\\n        require(_option < _state.numOptions, \\\"_option out of range\\\");\\r\\n\\r\\n        return _state.optionToSettings[uint256(_option)].guarantees[classId];\\r\\n    }\\r\\n\\r\\n    function setSeed(LootBoxRandomnessState storage _state, uint256 _newSeed)\\r\\n        public\\r\\n    {\\r\\n        _state.seed = _newSeed;\\r\\n    }\\r\\n\\r\\n    function _normalMint(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _optionId,\\r\\n        uint256 _boxNum\\r\\n    ) internal returns (uint256 _tokenId, uint256 _classId) {\\r\\n        require(_optionId < _state.numOptions, \\\"_option out of range\\\");\\r\\n        require(_boxNum < _state.numBox, \\\"_boxNum out of range\\\");\\r\\n        // Load settings for this box option\\r\\n        OptionSettings memory settings = _state.optionToSettings[_optionId];\\r\\n\\r\\n        require(\\r\\n            settings.maxQuantityPerOpen > 0,\\r\\n            \\\"LootBoxRandomness#_mint: OPTION_NOT_ALLOWED\\\"\\r\\n        );\\r\\n\\r\\n        _classId = (_pickRandomClass(_state, settings.classProbabilities));\\r\\n        _tokenId = _sendTokenWithClass(_state, _boxNum, _classId);\\r\\n        \\r\\n        return (_tokenId, _classId);\\r\\n    }\\r\\n\\r\\n    function _mint(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _optionId,\\r\\n        uint256 _randClassId,\\r\\n        bool hasGuaranteed,\\r\\n        uint256 _boxNum\\r\\n    ) internal returns (uint256 _tokenId, uint256 _classId) {\\r\\n        require(_optionId < _state.numOptions, \\\"_option out of range\\\");\\r\\n        require(_boxNum < _state.numBox, \\\"_boxNum out of range\\\");\\r\\n        // Load settings for this box option\\r\\n        OptionSettings memory settings = _state.optionToSettings[_optionId];\\r\\n\\r\\n        require(\\r\\n            settings.maxQuantityPerOpen > 0,\\r\\n            \\\"LootBoxRandomness#_mint: OPTION_NOT_ALLOWED\\\"\\r\\n        );\\r\\n\\r\\n        if (hasGuaranteed) {\\r\\n            uint256 randClass = _pickRandomClass(_state, settings.classProbabilities);\\r\\n            if (randClass > _randClassId) {\\r\\n                _classId = (randClass);\\r\\n            } else {\\r\\n                _classId = (_randClassId);\\r\\n            }\\r\\n            _tokenId = _sendTokenWithClass(\\r\\n                _state,\\r\\n                _boxNum,\\r\\n                _classId\\r\\n            );\\r\\n        } else {\\r\\n            _classId = (_pickRandomClass(_state, settings.classProbabilities));\\r\\n            _tokenId = _sendTokenWithClass(_state, _boxNum, _classId);\\r\\n        }\\r\\n        \\r\\n        return (_tokenId, _classId);\\r\\n    }\\r\\n\\r\\n    function _sendTokenWithClass(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _boxNum,\\r\\n        uint256 _classId\\r\\n    ) internal returns (uint256) {\\r\\n        require(_classId < _state.numClasses, \\\"_class out of range\\\");\\r\\n        uint256 tokenId = _pickRandomAvailableTokenIdForClass(\\r\\n            _state,\\r\\n            _boxNum,\\r\\n            _classId\\r\\n        );\\r\\n        return tokenId;\\r\\n    }\\r\\n\\r\\n    function _pickRandomClass(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256[] memory _classProbabilities\\r\\n    ) public returns (uint256) {\\r\\n        uint256 value = uint256(_random(_state).mod(INVERSE_BASIS_POINT));\\r\\n        for (uint256 i = uint256(_classProbabilities.length) - 1; i > 0; i--) {\\r\\n            uint256 probability = _classProbabilities[i];\\r\\n            if (value < probability) {\\r\\n                return i;\\r\\n            } else {\\r\\n                value = value - probability;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function _pickRandomAvailableTokenIdForClass(\\r\\n        LootBoxRandomnessState storage _state,\\r\\n        uint256 _boxNum,\\r\\n        uint256 _classId\\r\\n    ) internal returns (uint256) {\\r\\n        require(_classId < _state.numClasses, \\\"_class out of range\\\");\\r\\n        uint256 tokenIds = _state.classToTokenIds[_boxNum][_classId];\\r\\n        require(tokenIds > 0, \\\"No token ids for _classId\\\");\\r\\n        uint256 randIndex = _random(_state).mod(tokenIds);\\r\\n        Factory factory = Factory(_state.factoryAddress);\\r\\n        for (uint256 i = randIndex; i < randIndex + tokenIds; i++) {\\r\\n            uint256 tokenId = i % tokenIds;\\r\\n            if (factory.balanceOf(tokenId, _boxNum)) {\\r\\n                return tokenId;\\r\\n            }\\r\\n        }\\r\\n        revert(\\r\\n            \\\"LootBoxRandomness#_pickRandomAvailableTokenIdForClass: NOT_ENOUGH_TOKENS_FOR_CLASS\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _random(LootBoxRandomnessState storage _state)\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 randomNumber = uint256(\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    blockhash(block.number - 1),\\r\\n                    msg.sender,\\r\\n                    _state.seed\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        _state.seed = randomNumber;\\r\\n        return randomNumber;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxesPurchased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemsMinted\",\"type\":\"uint256\"}],\"name\":\"LootBoxOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Warning\",\"type\":\"event\"}]","ContractName":"LootBoxRandomness","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"20","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}