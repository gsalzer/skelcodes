{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/SynapseVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport { ReentrancyGuard } from \\\"./external/openzeppelin/ReentrancyGuard.sol\\\";\\n\\nimport { StableMath } from \\\"./libraries/StableMath.sol\\\";\\nimport { IERC20 } from \\\"./interfaces/IERC20.sol\\\";\\nimport { Ownable } from \\\"./abstract/Ownable.sol\\\";\\nimport { Lockable } from \\\"./abstract/Lockable.sol\\\";\\n\\n/**\\n * @title   SynapseVesting\\n * @notice  Synapse Network Vesting contract\\n * @dev     Vesting is constantly releasing tokens every block every second\\n */\\ncontract SynapseVesting is Ownable, Lockable, ReentrancyGuard {\\n    using StableMath for uint256;\\n\\n    /// @notice address of Synapse Network token\\n    address public snpToken;\\n    /// @notice total tokens vested in contract\\n    /// @dev tokens from not initialized sale contracts are not included\\n    uint256 public totalVested;\\n    /// @notice total tokens already claimed form vesting\\n    uint256 public totalClaimed;\\n    /// @notice staking contract address\\n    /// @dev set by Owner, for claimAndStake\\n    address public stakingAddress;\\n\\n    struct Vest {\\n        uint256 dateStart; // start of claiming, can claim startTokens\\n        uint256 dateEnd; // after it all tokens can be claimed\\n        uint256 totalTokens; // total tokens to claim\\n        uint256 startTokens; // tokens to claim on start\\n        uint256 claimedTokens; // tokens already claimed\\n    }\\n    /// @notice storage of vestings\\n    Vest[] internal vestings;\\n    /// @notice map of vestings for user\\n    mapping(address => uint256[]) internal user2vesting;\\n\\n    struct SaleContract {\\n        address[] contractAddresses; // list of cross sale contracts from sale round\\n        uint256 tokensPerCent; // amount of tokens per cent for sale round\\n        uint256 maxAmount; // max amount in USD cents for sale round\\n        uint256 percentOnStart; // percent of tokens to claim on start\\n        uint256 startDate; // start of claiming, can claim start tokens\\n        uint256 endDate; // after it all tokens can be claimed\\n    }\\n    /// @notice list of sale contract that will be checked\\n    SaleContract[] internal saleContracts;\\n\\n    /// @notice map of users that initialized vestings from sale contracts\\n    mapping(address => bool) public vestingAdded;\\n    /// @notice map of users that were refunded after sales\\n    mapping(address => bool) public refunded;\\n\\n    /// @dev events\\n    event Claimed(address indexed user, uint256 amount);\\n    event Vested(address indexed user, uint256 totalAmount, uint256 endDate);\\n\\n    /**\\n     * @dev Contract initiator\\n     * @param _token address of SNP token\\n     */\\n    function init(address _token) external onlyOwner {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(snpToken == address(0), \\\"Init already done\\\");\\n        snpToken = _token;\\n    }\\n\\n    /**\\n     * @dev Add multiple vesting to contract by arrays of data\\n     * @param _users[] addresses of holders\\n     * @param _startTokens[] tokens that can be withdrawn at startDate\\n     * @param _totalTokens[] total tokens in vesting\\n     * @param _startDate date from when tokens can be claimed\\n     * @param _endDate date after which all tokens can be claimed\\n     */\\n    function massAddHolders(\\n        address[] calldata _users,\\n        uint256[] calldata _startTokens,\\n        uint256[] calldata _totalTokens,\\n        uint256 _startDate,\\n        uint256 _endDate\\n    ) external onlyOwner whenNotLocked {\\n        uint256 len = _users.length; //cheaper to use one variable\\n        require((len == _startTokens.length) && (len == _totalTokens.length), \\\"data size mismatch\\\");\\n        require(_startDate < _endDate, \\\"startDate cannot exceed endDate\\\");\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            _addHolder(_users[i], _startTokens[i], _totalTokens[i], _startDate, _endDate);\\n        }\\n    }\\n\\n    /**\\n     * @dev Add new vesting to contract\\n     * @param _user address of a holder\\n     * @param _startTokens how many tokens are claimable at start date\\n     * @param _totalTokens total number of tokens in added vesting\\n     * @param _startDate date from when tokens can be claimed\\n     * @param _endDate date after which all tokens can be claimed\\n     */\\n    function _addHolder(\\n        address _user,\\n        uint256 _startTokens,\\n        uint256 _totalTokens,\\n        uint256 _startDate,\\n        uint256 _endDate\\n    ) internal {\\n        require(_user != address(0), \\\"user address cannot be 0\\\");\\n        Vest memory v;\\n        v.startTokens = _startTokens;\\n        v.totalTokens = _totalTokens;\\n        v.dateStart = _startDate;\\n        v.dateEnd = _endDate;\\n\\n        totalVested += _totalTokens;\\n        vestings.push(v);\\n        user2vesting[_user].push(vestings.length); // we are skipping index \\\"0\\\" for reasons\\n        emit Vested(_user, _totalTokens, _endDate);\\n    }\\n\\n    /**\\n     * @dev Claim tokens from msg.sender vestings\\n     */\\n    function claim() external {\\n        _claim(msg.sender, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Claim tokens from msg.sender vestings to external address\\n     * @param _target transfer address for claimed tokens\\n     */\\n    function claimTo(address _target) external {\\n        _claim(msg.sender, _target);\\n    }\\n\\n    /**\\n     * @dev Claim and stake claimed tokens directly in staking contract\\n     *      Ask staking contract if user is not in withdrawing state\\n     */\\n    function claimAndStake() external {\\n        require(stakingAddress != address(0), \\\"Staking contract not configured\\\");\\n        require(IStaking(stakingAddress).canStakeTokens(msg.sender), \\\"Unable to stake\\\");\\n        uint256 amt = _claim(msg.sender, stakingAddress);\\n        IStaking(stakingAddress).onClaimAndStake(msg.sender, amt);\\n    }\\n\\n    /**\\n     * @dev internal claim function\\n     * @param _user address of holder\\n     * @param _target where tokens should be send\\n     * @return amt number of tokens claimed\\n     */\\n    function _claim(address _user, address _target) internal nonReentrant returns (uint256 amt) {\\n        require(_target != address(0), \\\"Claim, then burn\\\");\\n        if (!vestingAdded[_user] && !refunded[_user]) {\\n            _addVesting(_user);\\n        }\\n        uint256 len = user2vesting[_user].length;\\n        require(len > 0, \\\"No vestings for user\\\");\\n        uint256 cl;\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            Vest storage v = vestings[user2vesting[_user][i] - 1];\\n            cl = _claimable(v);\\n            v.claimedTokens += cl;\\n            amt += cl;\\n        }\\n        if (amt > 0) {\\n            totalClaimed += amt;\\n            _transfer(_target, amt);\\n            emit Claimed(_user, amt);\\n        } else revert(\\\"Nothing to claim\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to send out claimed tokens\\n     * @param _user address that we send tokens\\n     * @param _amt amount of tokens\\n     */\\n    function _transfer(address _user, uint256 _amt) internal {\\n        require(IERC20(snpToken).transfer(_user, _amt), \\\"Token transfer failed\\\");\\n    }\\n\\n    /**\\n     * @dev Count how many tokens can be claimed from vesting to date\\n     * @param _vesting Vesting object\\n     * @return canWithdraw number of tokens\\n     */\\n    function _claimable(Vest memory _vesting) internal view returns (uint256 canWithdraw) {\\n        uint256 currentTime = block.timestamp;\\n        if (_vesting.dateStart > currentTime) return 0;\\n        // we are somewhere in the middle\\n        if (currentTime < _vesting.dateEnd) {\\n            // how much time passed (as fraction * 10^18)\\n            // timeRatio = (time passed * 1e18) / duration\\n            uint256 timeRatio = (currentTime - _vesting.dateStart).divPrecisely(_vesting.dateEnd - _vesting.dateStart);\\n            // how much tokens we can get in total to date\\n            canWithdraw = (_vesting.totalTokens - _vesting.startTokens).mulTruncate(timeRatio) + _vesting.startTokens;\\n        }\\n        // time has passed, we can take all tokens\\n        else {\\n            canWithdraw = _vesting.totalTokens;\\n        }\\n        // but maybe we take something earlier?\\n        canWithdraw -= _vesting.claimedTokens;\\n    }\\n\\n    /**\\n     * @dev Read number of claimable tokens by user and vesting no\\n     * @param _user address of holder\\n     * @param _id his vesting number (starts from 0)\\n     * @return amount number of tokens\\n     */\\n    function getClaimable(address _user, uint256 _id) external view returns (uint256 amount) {\\n        amount = _claimable(vestings[user2vesting[_user][_id] - 1]);\\n    }\\n\\n    /**\\n     * @dev Read total amount of tokens that user can claim to date from all vestings\\n     *      Function also includes tokens to claim from sale contracts that were not\\n     *      yet initiated for user.\\n     * @param _user address of holder\\n     * @return amount number of tokens\\n     */\\n    function getAllClaimable(address _user) public view returns (uint256 amount) {\\n        uint256 len = user2vesting[_user].length;\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            amount += _claimable(vestings[user2vesting[_user][i] - 1]);\\n        }\\n\\n        if (!vestingAdded[_user]) {\\n            amount += _claimableFromSaleContracts(_user);\\n        }\\n    }\\n\\n    /**\\n     * @dev Extract all the vestings for the user\\n     *      Also extract not initialized vestings from\\n     *      sale contracts.\\n     * @param _user address of holder\\n     * @return v array of Vest objects\\n     */\\n    function getVestings(address _user) external view returns (Vest[] memory) {\\n        // array of pending vestings\\n        Vest[] memory pV;\\n\\n        if (!vestingAdded[_user]) {\\n            pV = _vestingsFromSaleContracts(_user);\\n        }\\n        uint256 pLen = pV.length;\\n        uint256 len = user2vesting[_user].length;\\n        Vest[] memory v = new Vest[](len + pLen);\\n\\n        // copy normal vestings\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            v[i] = vestings[user2vesting[_user][i] - 1];\\n        }\\n\\n        // copy not initialized vestings\\n        if (!vestingAdded[_user]) {\\n            uint256 j;\\n            for (j; j < pLen; j++) {\\n                v[i + j] = pV[j];\\n            }\\n        }\\n\\n        return v;\\n    }\\n\\n    /**\\n     * @dev Read total number of vestings registered\\n     * @return number of registered vestings on contract\\n     */\\n    function getVestingsCount() external view returns (uint256) {\\n        return vestings.length;\\n    }\\n\\n    /**\\n     * @dev Read single registered vesting entry\\n     * @param _id index of vesting in storage\\n     * @return Vest object\\n     */\\n    function getVestingByIndex(uint256 _id) external view returns (Vest memory) {\\n        return vestings[_id];\\n    }\\n\\n    /**\\n     * @dev Read registered vesting list by range from-to\\n     * @param _start first index\\n     * @param _end last index\\n     * @return array of Vest objects\\n     */\\n    function getVestingsByRange(uint256 _start, uint256 _end) external view returns (Vest[] memory) {\\n        uint256 cnt = _end - _start + 1;\\n        uint256 len = vestings.length;\\n        require(_end < len, \\\"range error\\\");\\n        Vest[] memory v = new Vest[](cnt);\\n        uint256 i;\\n        for (i; i < cnt; i++) {\\n            v[i] = vestings[_start + i];\\n        }\\n        return v;\\n    }\\n\\n    /**\\n     * @dev Extract all sale contracts\\n     * @return array of SaleContract objects\\n     */\\n    function getSaleContracts() external view returns (SaleContract[] memory) {\\n        return saleContracts;\\n    }\\n\\n    /**\\n     * @dev Read total number of sale contracts\\n     * @return number of SaleContracts\\n     */\\n    function getSaleContractsCount() external view returns (uint256) {\\n        return saleContracts.length;\\n    }\\n\\n    /**\\n     * @dev Read single sale contract entry\\n     * @param _id index of sale contract in storage\\n     * @return SaleContract object\\n     */\\n    function getSaleContractByIndex(uint256 _id) external view returns (SaleContract memory) {\\n        return saleContracts[_id];\\n    }\\n\\n    /**\\n     * @dev Register sale contract\\n     * @param _contractAddresses  addresses of sale contracts\\n     * @param _tokensPerCent      sale price\\n     * @param _maxAmount          the maximum amount in USD cents for which user could buy\\n     * @param _percentOnStart     percentage of vested coins that can be claimed on start date\\n     * @param _startDate          date when initial vesting can be released\\n     * @param _endDate            final date of vesting, where all tokens can be claimed\\n     */\\n    function addSaleContract(\\n        address[] memory _contractAddresses,\\n        uint256 _tokensPerCent,\\n        uint256 _maxAmount,\\n        uint256 _percentOnStart,\\n        uint256 _startDate,\\n        uint256 _endDate\\n    ) external onlyOwner whenNotLocked {\\n        require(_contractAddresses.length > 0, \\\"data is missing\\\");\\n        require(_startDate < _endDate, \\\"startDate cannot exceed endDate\\\");\\n        SaleContract memory s;\\n        s.contractAddresses = _contractAddresses;\\n        s.tokensPerCent = _tokensPerCent;\\n        s.maxAmount = _maxAmount;\\n        s.startDate = _startDate;\\n        s.percentOnStart = _percentOnStart;\\n        s.endDate = _endDate;\\n        saleContracts.push(s);\\n    }\\n\\n    /**\\n     * @dev Initialize vestings from sale contracts for msg.sender\\n     */\\n    function addMyVesting() external {\\n        _addVesting(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Initialize vestings from sale contracts for target user\\n     * @param _user address of user that will be initialized\\n     */\\n    function addVesting(address _user) external {\\n        require(_user != address(0), \\\"User address cannot be 0\\\");\\n        _addVesting(_user);\\n    }\\n\\n    /**\\n     * @dev Function iterate sale contracts and initialize corresponding\\n     *      vesting for user.\\n     * @param _user address that will be initialized\\n     */\\n    function _addVesting(address _user) internal {\\n        require(!refunded[_user], \\\"User refunded\\\");\\n        require(!vestingAdded[_user], \\\"Already done\\\");\\n        uint256 len = saleContracts.length;\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            SaleContract memory s = saleContracts[i];\\n            uint256 sLen = s.contractAddresses.length;\\n            uint256 j;\\n            uint256 amt;\\n            for (j; j < sLen; j++) {\\n                amt += ISaleContract(s.contractAddresses[j]).balanceOf(_user);\\n            }\\n            // amt is in cents, so $100 = 10000\\n            if (amt > 0) {\\n                if (amt > s.maxAmount) {\\n                    amt = s.maxAmount;\\n                }\\n                // create Vest object\\n                Vest memory v = _vestFromSaleContractAndAmount(s, amt);\\n                // update contract data\\n                totalVested += v.totalTokens;\\n                vestings.push(v);\\n                user2vesting[_user].push(vestings.length);\\n                emit Vested(_user, v.totalTokens, v.dateEnd);\\n            }\\n        }\\n        vestingAdded[_user] = true;\\n    }\\n\\n    /**\\n     * @dev Function iterate sale contracts and count claimable amounts for given user.\\n     *      Used to calculate claimable amounts from not initialized vestings.\\n     * @param _user address of user to count claimable\\n     * @return claimable amount of tokens\\n     */\\n    function _claimableFromSaleContracts(address _user) internal view returns (uint256 claimable) {\\n        if (refunded[_user]) return 0;\\n        uint256 len = saleContracts.length;\\n        if (len == 0) return 0;\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            SaleContract memory s = saleContracts[i];\\n            uint256 sLen = s.contractAddresses.length;\\n            uint256 j;\\n            uint256 amt;\\n            for (j; j < sLen; j++) {\\n                amt += ISaleContract(s.contractAddresses[j]).balanceOf(_user);\\n            }\\n            // amt is in cents, so $100 = 10000\\n            if (amt > 0) {\\n                if (amt > s.maxAmount) {\\n                    amt = s.maxAmount;\\n                }\\n                claimable += _claimable(_vestFromSaleContractAndAmount(s, amt));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Function iterate sale contracts and extract not initialized user vestings.\\n     *      Used to return all stored and not initialized vestings.\\n     * @param _user address of user to extract vestings\\n     * @return v vesting array\\n     */\\n    function _vestingsFromSaleContracts(address _user) internal view returns (Vest[] memory) {\\n        uint256 len = saleContracts.length;\\n        if (refunded[_user] || len == 0) return new Vest[](0);\\n\\n        Vest[] memory v = new Vest[](_numberOfVestingsFromSaleContracts(_user));\\n        uint256 i;\\n        uint256 idx;\\n        for (i; i < len; i++) {\\n            SaleContract memory s = saleContracts[i];\\n            uint256 sLen = s.contractAddresses.length;\\n            uint256 j;\\n            uint256 amt;\\n            for (j; j < sLen; j++) {\\n                amt += ISaleContract(s.contractAddresses[j]).balanceOf(_user);\\n            }\\n            // amt is in cents, so $100 = 10000\\n            if (amt > 0) {\\n                if (amt > s.maxAmount) {\\n                    amt = s.maxAmount;\\n                }\\n                v[idx] = _vestFromSaleContractAndAmount(s, amt);\\n                idx++;\\n            }\\n        }\\n        return v;\\n    }\\n\\n    /**\\n     * @dev Function iterate sale contracts and return number of not initialized vestings for user.\\n     * @param _user address of user to extract vestings\\n     * @return number of not not initialized user vestings\\n     */\\n    function _numberOfVestingsFromSaleContracts(address _user) internal view returns (uint256 number) {\\n        uint256 len = saleContracts.length;\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            SaleContract memory s = saleContracts[i];\\n            uint256 sLen = s.contractAddresses.length;\\n            uint256 j;\\n            uint256 amt;\\n            for (j; j < sLen; j++) {\\n                amt += ISaleContract(s.contractAddresses[j]).balanceOf(_user);\\n            }\\n            // amt is in cents, so $100 = 10000\\n            if (amt > 0) {\\n                number++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Return vesting created from given sale and usd cent amount.\\n     * @param _sale address of user to extract vestings\\n     * @param _amount address of user to extract vestings\\n     * @return v vesting from given parameters\\n     */\\n    function _vestFromSaleContractAndAmount(SaleContract memory _sale, uint256 _amount) internal pure returns (Vest memory v) {\\n        v.dateStart = _sale.startDate;\\n        v.dateEnd = _sale.endDate;\\n        uint256 total = _amount * _sale.tokensPerCent;\\n        v.totalTokens = total;\\n        v.startTokens = (total * _sale.percentOnStart) / 100;\\n    }\\n\\n    /**\\n     * @dev Set staking contract address for Claim and Stake.\\n     *      Only contract owner can set.\\n     * @param _staking address\\n     */\\n    function setStakingAddress(address _staking) external onlyOwner {\\n        stakingAddress = _staking;\\n    }\\n\\n    /**\\n     * @dev Mark user as refunded\\n     * @param _user address of user\\n     * @param _refunded true=refunded\\n     */\\n    function setRefunded(address _user, bool _refunded) external onlyOwner whenNotLocked {\\n        require(_user != address(0), \\\"user address cannot be 0\\\");\\n        refunded[_user] = _refunded;\\n    }\\n\\n    /**\\n     * @dev Mark multiple refunded users\\n     * @param _users[] addresses of refunded users\\n     */\\n    function massSetRefunded(address[] calldata _users) external onlyOwner whenNotLocked {\\n        uint256 i;\\n        for (i; i < _users.length; i++) {\\n            require(_users[i] != address(0), \\\"user address cannot be 0\\\");\\n            refunded[_users[i]] = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Recover ETH from contract to owner address.\\n     */\\n    function recoverETH() external {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    /**\\n     * @dev Recover given ERC20 token from contract to owner address.\\n     *      Can't recover SNP tokens.\\n     * @param _token address of ERC20 token to recover\\n     */\\n    function recoverErc20(address _token) external {\\n        require(_token != snpToken, \\\"Not permitted\\\");\\n        uint256 amt = IERC20(_token).balanceOf(address(this));\\n        require(amt > 0, \\\"Nothing to recover\\\");\\n        IBadErc20(_token).transfer(owner, amt);\\n    }\\n}\\n\\n/**\\n * @title IStaking\\n * @dev Interface for claim and stake\\n */\\ninterface IStaking {\\n    function canStakeTokens(address _account) external view returns (bool);\\n\\n    function onClaimAndStake(address _from, uint256 _amount) external;\\n}\\n\\n/**\\n * @title ISaleContract\\n * @dev Interface for sale contract\\n */\\ninterface ISaleContract {\\n    function balanceOf(address _account) external view returns (uint256);\\n}\\n\\n/**\\n * @title IBadErc20\\n * @dev Interface for emergency recover any ERC20-tokens,\\n *      even non-erc20-compliant like USDT not returning boolean\\n */\\ninterface IBadErc20 {\\n    function transfer(address _recipient, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\n\\nabstract contract LockableData {\\n    bool public locked;\\n}\\n\\nabstract contract Lockable is LockableData, Ownable {\\n    /**\\n     * @dev Locks functions with whenNotLocked modifier\\n     */\\n    function lock() external onlyOwner {\\n        locked = true;\\n    }\\n\\n    /**\\n     * @dev Throws if called after it was locked.\\n     */\\n    modifier whenNotLocked {\\n        require(!locked, \\\"Lockable: locked\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nabstract contract OwnableData {\\n    address public owner;\\n    address public pendingOwner;\\n}\\n\\nabstract contract Ownable is OwnableData {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev `owner` defaults to msg.sender on construction.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\n     *      Can only be invoked by the current `owner`.\\n     * @param _newOwner Address of the new owner.\\n     * @param _direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\\n     */\\n    function transferOwnership(address _newOwner, bool _direct) external onlyOwner {\\n        if (_direct) {\\n            require(_newOwner != address(0), \\\"zero address\\\");\\n\\n            emit OwnershipTransferred(owner, _newOwner);\\n            owner = _newOwner;\\n            pendingOwner = address(0);\\n        } else {\\n            pendingOwner = _newOwner;\\n        }\\n    }\\n\\n    /**\\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\\n     */\\n    function claimOwnership() external {\\n        address _pendingOwner = pendingOwner;\\n        require(msg.sender == _pendingOwner, \\\"caller != pending owner\\\");\\n\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the Owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    // EIP 2612\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function nonces(address owner) external view returns (uint256);\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/libraries/StableMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n// Based on StableMath from mStable\\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\\n\\nlibrary StableMath {\\n    /**\\n     * @dev Scaling unit for use in specific calculations,\\n     * where 1 * 10**18, or 1e18 represents a unit '1'\\n     */\\n    uint256 private constant FULL_SCALE = 1e18;\\n\\n    /**\\n     * @dev Provides an interface to the scaling unit\\n     * @return Scaling unit (1e18 or 1 * 10**18)\\n     */\\n    function getFullScale() internal pure returns (uint256) {\\n        return FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Scales a given integer to the power of the full scale.\\n     * @param x   Simple uint256 to scale\\n     * @return    Scaled value a to an exact number\\n     */\\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\\n        return x * FULL_SCALE;\\n    }\\n\\n    /***************************************\\n              PRECISE ARITHMETIC\\n    ****************************************/\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulTruncateScale(x, y, FULL_SCALE);\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @param scale Scale unit\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncateScale(\\n        uint256 x,\\n        uint256 y,\\n        uint256 scale\\n    ) internal pure returns (uint256) {\\n        // e.g. assume scale = fullScale\\n        // z = 10e18 * 9e17 = 9e36\\n        // return 9e36 / 1e18 = 9e18\\n        return (x * y) / scale;\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit, rounded up to the closest base unit.\\n     */\\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e17 * 17268172638 = 138145381104e17\\n        uint256 scaled = x * y;\\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\\n        uint256 ceil = scaled + FULL_SCALE - 1;\\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\\n        return ceil / FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\\n     * @param x     Left hand input to division\\n     * @param y     Right hand input to division\\n     * @return      Result after multiplying the left operand by the scale, and\\n     *              executing the division on the right hand input.\\n     */\\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e18 * 1e18 = 8e36\\n        // e.g. 8e36 / 10e18 = 8e17\\n        return (x * FULL_SCALE) / y;\\n    }\\n\\n    /***************************************\\n                    HELPERS\\n    ****************************************/\\n\\n    /**\\n     * @dev Calculates minimum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Minimum of the two inputs\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? y : x;\\n    }\\n\\n    /**\\n     * @dev Calculated maximum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Maximum of the two inputs\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @dev Clamps a value to an upper bound\\n     * @param x           Left hand input\\n     * @param upperBound  Maximum possible value to return\\n     * @return            Input x clamped to a maximum value, upperBound\\n     */\\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\\n        return x > upperBound ? upperBound : x;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addMyVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contractAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_tokensPerCent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentOnStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"}],\"name\":\"addSaleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"claimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getSaleContractByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"contractAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerCent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentOnStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"}],\"internalType\":\"struct SynapseVesting.SaleContract\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSaleContracts\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"contractAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerCent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentOnStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"}],\"internalType\":\"struct SynapseVesting.SaleContract[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSaleContractsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getVestingByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct SynapseVesting.Vest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getVestings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct SynapseVesting.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getVestingsByRange\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct SynapseVesting.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_totalTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"}],\"name\":\"massAddHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"massSetRefunded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_refunded\",\"type\":\"bool\"}],\"name\":\"setRefunded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"}],\"name\":\"setStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snpToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestingAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SynapseVesting","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}