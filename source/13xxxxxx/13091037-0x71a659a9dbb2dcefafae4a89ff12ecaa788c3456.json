{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/bloq/IAddressList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\ninterface IAddressList {\\n    function add(address a) external returns (bool);\\n\\n    function remove(address a) external returns (bool);\\n\\n    function get(address a) external view returns (uint256);\\n\\n    function contains(address a) external view returns (bool);\\n\\n    function length() external view returns (uint256);\\n\\n    function grantRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vesper/IVFRCoveragePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\nimport \\\"./IVesperPool.sol\\\";\\n\\ninterface IVFRCoveragePool is IVesperPool {\\n    function buffer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vesper/IVFRStablePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\nimport \\\"./IVesperPool.sol\\\";\\n\\ninterface IVFRStablePool is IVesperPool {\\n    function targetAPY() external view returns (uint256);\\n\\n    function buffer() external view returns (address);\\n\\n    function targetPricePerShare() external view returns (uint256);\\n\\n    function amountToReachTarget(address _strategy) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vesper/IVesperPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../bloq/IAddressList.sol\\\";\\n\\ninterface IVesperPool is IERC20 {\\n    function deposit() external payable;\\n\\n    function deposit(uint256 _share) external;\\n\\n    function multiTransfer(address[] memory _recipients, uint256[] memory _amounts) external returns (bool);\\n\\n    function excessDebt(address _strategy) external view returns (uint256);\\n\\n    function permit(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        uint8,\\n        bytes32,\\n        bytes32\\n    ) external;\\n\\n    function poolRewards() external returns (address);\\n\\n    function reportEarning(\\n        uint256 _profit,\\n        uint256 _loss,\\n        uint256 _payback\\n    ) external;\\n\\n    function reportLoss(uint256 _loss) external;\\n\\n    function resetApproval() external;\\n\\n    function sweepERC20(address _fromToken) external;\\n\\n    function withdraw(uint256 _amount) external;\\n\\n    function withdrawETH(uint256 _amount) external;\\n\\n    function whitelistedWithdraw(uint256 _amount) external;\\n\\n    function governor() external view returns (address);\\n\\n    function keepers() external view returns (IAddressList);\\n\\n    function maintainers() external view returns (IAddressList);\\n\\n    function feeCollector() external view returns (address);\\n\\n    function pricePerShare() external view returns (uint256);\\n\\n    function strategy(address _strategy)\\n        external\\n        view\\n        returns (\\n            bool _active,\\n            uint256 _interestFee,\\n            uint256 _debtRate,\\n            uint256 _lastRebalance,\\n            uint256 _totalDebt,\\n            uint256 _totalLoss,\\n            uint256 _totalProfit,\\n            uint256 _debtRatio\\n        );\\n\\n    function stopEverything() external view returns (bool);\\n\\n    function token() external view returns (IERC20);\\n\\n    function tokensHere() external view returns (uint256);\\n\\n    function totalDebtOf(address _strategy) external view returns (uint256);\\n\\n    function totalValue() external view returns (uint256);\\n\\n    function withdrawFee() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/VFRBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../interfaces/vesper/IVFRCoveragePool.sol\\\";\\nimport \\\"../interfaces/vesper/IVFRStablePool.sol\\\";\\nimport \\\"../interfaces/vesper/IVesperPool.sol\\\";\\n\\ncontract VFRBuffer {\\n    address public token;\\n    address public stablePool;\\n    address public coveragePool;\\n    // Specifies for how long (in seconds) the buffer should be\\n    // able to cover the stable pool's target APY requirements\\n    uint256 public coverageTime;\\n\\n    event CoverageTimeUpdated(uint256 oldCoverageTime, uint256 newCoverageTime);\\n\\n    constructor(\\n        address _stablePool,\\n        address _coveragePool,\\n        uint256 _coverageTime\\n    ) {\\n        address stablePoolToken = address(IVesperPool(_stablePool).token());\\n        address coveragePoolToken = address(IVesperPool(_coveragePool).token());\\n        require(stablePoolToken == coveragePoolToken, \\\"non-matching-tokens\\\");\\n\\n        token = stablePoolToken;\\n        stablePool = _stablePool;\\n        coveragePool = _coveragePool;\\n        coverageTime = _coverageTime;\\n    }\\n\\n    function target() external view returns (uint256 amount) {\\n        uint256 targetAPY = IVFRStablePool(stablePool).targetAPY();\\n        // Get the current price per share\\n        uint256 fromPricePerShare = IVFRStablePool(stablePool).pricePerShare();\\n        // Get the price per share that would cover the stable pool's APY requirements\\n        uint256 toPricePerShare =\\n            fromPricePerShare + (fromPricePerShare * targetAPY * coverageTime) / (365 * 24 * 3600 * 1e18);\\n        // Get the amount needed to increase the current price per share to the coverage target\\n        uint256 totalSupply = IVFRStablePool(stablePool).totalSupply();\\n        uint256 fromTotalValue = (fromPricePerShare * totalSupply) / 1e18;\\n        uint256 toTotalValue = (toPricePerShare * totalSupply) / 1e18;\\n        if (toTotalValue > fromTotalValue) {\\n            amount = toTotalValue - fromTotalValue;\\n        }\\n    }\\n\\n    function request(uint256 _amount) public {\\n        // Make sure the requester is a valid strategy (either a stable pool one or a coverage pool one)\\n        (bool activeInStablePool, , , , , , , ) = IVFRStablePool(stablePool).strategy(msg.sender);\\n        (bool activeInCoveragePool, , , , , , , ) = IVFRCoveragePool(coveragePool).strategy(msg.sender);\\n        require(activeInStablePool || activeInCoveragePool, \\\"invalid-strategy\\\");\\n        // Make sure enough funds are available\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(balance >= _amount, \\\"insufficient-balance\\\");\\n        IERC20(token).transfer(msg.sender, _amount);\\n    }\\n\\n    function flush() public {\\n        require(IVFRStablePool(stablePool).keepers().contains(msg.sender), \\\"not-a-keeper\\\");\\n        // Transfer any outstanding funds to the coverage pool\\n        IERC20(token).transfer(coveragePool, IERC20(token).balanceOf(address(this)));\\n    }\\n\\n    function updateCoverageTime(uint256 _coverageTime) external {\\n        require(IVFRStablePool(stablePool).keepers().contains(msg.sender), \\\"not-a-keeper\\\");\\n        emit CoverageTimeUpdated(coverageTime, _coverageTime);\\n        coverageTime = _coverageTime;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stablePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coveragePool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coverageTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCoverageTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCoverageTime\",\"type\":\"uint256\"}],\"name\":\"CoverageTimeUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"coveragePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coverageTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flush\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"request\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stablePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coverageTime\",\"type\":\"uint256\"}],\"name\":\"updateCoverageTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"VFRBuffer","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b4c912714f07fcd078d17479010f705f807bb1150000000000000000000000000b1e5e449ca0d7d8937d038e298737e023e86dc50000000000000000000000000000000000000000000000000000000000015180","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}