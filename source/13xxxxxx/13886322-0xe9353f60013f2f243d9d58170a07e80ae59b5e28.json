{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ExchangeWithAtomic.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ExchangeWithOrionPool.sol\\\";\\nimport \\\"./utils/orionpool/periphery/interfaces/IOrionPoolV2Router02Ext.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./libs/LibAtomic.sol\\\";\\n\\ncontract ExchangeWithAtomic is ExchangeWithOrionPool {\\n    mapping(bytes32 => LibAtomic.LockOrder) public atomicSwaps;\\n    mapping(bytes32 => LibAtomic.RedeemInfo) public secrets;\\n\\n    event AtomicLocked(\\n        address sender,\\n        address asset,\\n        bytes32 secretHash\\n    );\\n\\n    event AtomicRedeemed(\\n        address sender,\\n        address receiver,\\n        address asset,\\n        bytes secret\\n    );\\n\\n    event AtomicClaimed(\\n        address receiver,\\n        address asset,\\n        bytes secret\\n    );\\n\\n    event AtomicRefunded(\\n        address receiver,\\n        address asset,\\n        bytes32 secretHash\\n    );\\n\\n    function lockAtomic(LibAtomic.LockOrder memory swap) payable public nonReentrant {\\n        LibAtomic.doLockAtomic(swap, atomicSwaps, secrets, assetBalances, liabilities);\\n\\n        require(checkPosition(swap.sender), \\\"E1PA\\\");\\n\\n        emit AtomicLocked(swap.sender, swap.asset, swap.secretHash);\\n    }\\n\\n    function redeemAtomic(LibAtomic.RedeemOrder calldata order, bytes calldata secret) public nonReentrant {\\n        LibAtomic.doRedeemAtomic(order, secret, secrets, assetBalances, liabilities);\\n        require(checkPosition(order.sender), \\\"E1PA\\\");\\n\\n        emit AtomicRedeemed(order.sender, order.receiver, order.asset, secret);\\n    }\\n\\n    function claimAtomic(address receiver, bytes calldata secret, bytes calldata matcherSignature) public nonReentrant {\\n        LibAtomic.LockOrder storage swap = LibAtomic.doClaimAtomic(\\n                receiver,\\n                secret,\\n                matcherSignature,\\n                _allowedMatcher,\\n                atomicSwaps,\\n                assetBalances,\\n                liabilities\\n        );\\n\\n        emit AtomicClaimed(receiver, swap.asset, secret);\\n    }\\n\\n    function refundAtomic(bytes32 secretHash) public nonReentrant {\\n        LibAtomic.LockOrder storage swap = LibAtomic.doRefundAtomic(secretHash, atomicSwaps, assetBalances, liabilities);\\n\\n        emit AtomicRefunded(swap.sender, swap.asset, swap.secretHash);\\n    }\\n\\n    /* Error Codes\\n        E1: Insufficient Balance, flavor A - Atomic, PA - Position Atomic\\n        E17: Incorrect atomic secret, flavor: U - used, NF - not found, R - redeemed, E/NE - expired/not expired, ETH\\n   */\\n}\\n\\n\"\r\n    },\r\n    \"contracts/ExchangeWithOrionPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Exchange.sol\\\";\\nimport \\\"./interfaces/IPoolSwapCallback.sol\\\";\\nimport \\\"./interfaces/IPoolFunctionality.sol\\\";\\nimport \\\"./libs/LibPool.sol\\\";\\nimport \\\"./utils/orionpool/periphery/interfaces/IOrionPoolV2Router02Ext.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\ncontract ExchangeWithOrionPool is Exchange, IPoolSwapCallback {\\n\\n    using SafeERC20 for IERC20;\\n\\n    address public _orionpoolRouter;\\n    mapping (address => bool) orionpoolAllowances;\\n\\n    address public WETH;\\n\\n    modifier initialized {\\n        require(address(_orionToken)!=address(0), \\\"E16I\\\");\\n        require(_oracleAddress!=address(0), \\\"E16I\\\");\\n        require(_allowedMatcher!=address(0), \\\"E16I\\\");\\n        require(_orionpoolRouter!=address(0), \\\"E16I\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev set basic Exchange params\\n     * @param orionToken - base token address\\n     * @param priceOracleAddress - adress of PriceOracle contract\\n     * @param allowedMatcher - address which has authorization to match orders\\n     * @param orionpoolRouter - OrionPool Functionality contract address for changes through orionpool\\n     */\\n    function setBasicParams(\\n        address orionToken,\\n        address priceOracleAddress,\\n        address allowedMatcher,\\n        address orionpoolRouter\\n    ) public onlyOwner {\\n        _orionToken = IERC20(orionToken);\\n        _oracleAddress = priceOracleAddress;\\n        _allowedMatcher = allowedMatcher;\\n        _orionpoolRouter = orionpoolRouter;\\n        WETH = IPoolFunctionality(_orionpoolRouter).getWETH();\\n    }\\n\\n    //Important catch-all a function that should only accept ethereum and don't allow do something with it\\n    //We accept ETH there only from out router or wrapped ethereum contract.\\n    //If router sends some ETH to us - it's just swap completed, and we don't need to do something\\n    receive() external payable {\\n        require(msg.sender == _orionpoolRouter || msg.sender == WETH, \\\"NPF\\\");\\n    }\\n\\n    function safeAutoTransferFrom(address token, address from, address to, uint value) override external {\\n        require(msg.sender == _orionpoolRouter, \\\"Only _orionpoolRouter allowed\\\");\\n        SafeTransferHelper.safeAutoTransferFrom(WETH, token, from, to, value);\\n    }\\n\\n    /**\\n     * @notice (partially) settle buy order with OrionPool as counterparty\\n     * @dev order and orionpool path are submitted, it is necessary to match them:\\n        check conditions in order for compliance filledPrice and filledAmount\\n        change tokens via OrionPool\\n        check that final price after exchange not worse than specified in order\\n        change balances on the contract respectively\\n     * @param order structure of buy side orderbuyOrderHash\\n     * @param filledAmount amount of purchaseable token\\n     * @param path array of assets addresses (each consequent asset pair is change pair)\\n     */\\n\\n    function fillThroughOrionPool(\\n        LibValidator.Order memory order,\\n        uint112 filledAmount,\\n        uint64 blockchainFee,\\n        address[] calldata path\\n    ) public nonReentrant {\\n\\n        LibPool.OrderExecutionData memory tmp = LibPool.doFillThroughOrionPool(\\n            order,\\n            filledAmount,\\n            blockchainFee,\\n            path,\\n            _allowedMatcher,\\n            assetBalances,\\n            liabilities,\\n            _orionpoolRouter,\\n            filledAmounts\\n        );\\n\\n        require(checkPosition(order.senderAddress), tmp.isInContractTrade ? (order.buySide == 0 ? \\\"E1PS\\\" : \\\"E1PB\\\") : \\\"E1PF\\\");\\n\\n        emit NewTrade(\\n            order.senderAddress,\\n            address(1),\\n            order.baseAsset,\\n            order.quoteAsset,\\n            uint64(tmp.filledPrice),\\n            uint192(tmp.filledBase),\\n            uint192(tmp.filledQuote)\\n        );\\n\\n    }\\n\\n    function swapThroughOrionPool(\\n        uint112     amount_spend,\\n        uint112     amount_receive,\\n        address[] calldata   path,\\n        bool        is_exact_spend\\n    ) public payable nonReentrant {\\n        bool isCheckPosition = LibPool.doSwapThroughOrionPool(amount_spend, amount_receive, path, is_exact_spend,\\n            assetBalances, liabilities, _orionpoolRouter);\\n        if (isCheckPosition) {\\n            require(checkPosition(msg.sender), \\\"E1PS\\\");\\n        }\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/utils/orionpool/periphery/interfaces/IOrionPoolV2Router02Ext.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IOrionPoolV2Router02Ext {\\n    function swapExactTokensForTokensAutoRoute(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactTokensAutoRoute(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to\\n    ) external payable returns (uint[] memory amounts);\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibAtomic.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./LibValidator.sol\\\";\\nimport \\\"./LibExchange.sol\\\";\\n\\nlibrary LibAtomic {\\n    using ECDSA for bytes32;\\n\\n    struct LockOrder {\\n        address sender;\\n        address asset;\\n        uint64 amount;\\n        uint64 expiration;\\n        bytes32 secretHash;\\n        bool used;\\n    }\\n\\n    struct ClaimOrder {\\n        address receiver;\\n        bytes32 secretHash;\\n    }\\n\\n    struct RedeemOrder {\\n        address sender;\\n        address receiver;\\n        address claimReceiver;\\n        address asset;\\n        uint64 amount;\\n        uint64 expiration;\\n        bytes32 secretHash;\\n        bytes signature;\\n    }\\n\\n    struct RedeemInfo {\\n        address sender;\\n        bytes secret;\\n    }\\n\\n    function doLockAtomic(LockOrder memory swap,\\n        mapping(bytes32 => LockOrder) storage atomicSwaps,\\n        mapping(bytes32 => RedeemInfo) storage secrets,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) public {\\n        require(msg.sender == swap.sender, \\\"E3C\\\");\\n        require(swap.expiration/1000 >= block.timestamp, \\\"E17E\\\");\\n        require(secrets[swap.secretHash].sender == address(0), \\\"E17R\\\");\\n        require(atomicSwaps[swap.secretHash].sender == address(0), \\\"E17R\\\");\\n\\n        if (msg.value > 0) {\\n            require(swap.asset == address(0), \\\"E17ETH\\\");\\n            uint112 eth_sent = uint112(LibUnitConverter.baseUnitToDecimal(address(0), msg.value));\\n            require(swap.amount == eth_sent, \\\"E17ETA\\\");\\n        } else {\\n            LibExchange._updateBalance(swap.sender, swap.asset, -1*int(swap.amount), assetBalances, liabilities);\\n            require(assetBalances[swap.sender][swap.asset] >= 0, \\\"E1A\\\");\\n        }\\n\\n        atomicSwaps[swap.secretHash] = swap;\\n    }\\n\\n    function doRedeemAtomic(\\n        LibAtomic.RedeemOrder calldata order,\\n        bytes calldata secret,\\n        mapping(bytes32 => RedeemInfo) storage secrets,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) public {\\n        require(msg.sender == order.receiver, \\\"E3C\\\");\\n        require(secrets[order.secretHash].sender == address(0), \\\"E17R\\\");\\n        require(getEthSignedAtomicOrderHash(order).recover(order.signature) == order.sender, \\\"E2\\\");\\n        require(order.expiration/1000 >= block.timestamp, \\\"E4A\\\");\\n        require(order.secretHash == keccak256(secret), \\\"E17\\\");\\n\\n        LibExchange._updateBalance(order.sender, order.asset, -1*int(order.amount), assetBalances, liabilities);\\n\\n        LibExchange._updateBalance(order.receiver, order.asset, order.amount, assetBalances, liabilities);\\n        secrets[order.secretHash] = RedeemInfo(order.claimReceiver, secret);\\n    }\\n\\n    function doClaimAtomic(\\n        address receiver,\\n        bytes calldata secret,\\n        bytes calldata matcherSignature,\\n        address allowedMatcher,\\n        mapping(bytes32 => LockOrder) storage atomicSwaps,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) public returns (LockOrder storage swap) {\\n        bytes32 secretHash = keccak256(secret);\\n        bytes32 coHash = getEthSignedClaimOrderHash(ClaimOrder(receiver, secretHash));\\n        require(coHash.recover(matcherSignature) == allowedMatcher, \\\"E2\\\");\\n\\n        swap = atomicSwaps[secretHash];\\n        require(swap.sender != address(0), \\\"E17NF\\\");\\n        require(swap.expiration/1000 >= block.timestamp, \\\"E17E\\\");\\n        require(!swap.used, \\\"E17U\\\");\\n\\n        swap.used = true;\\n        LibExchange._updateBalance(receiver, swap.asset, swap.amount, assetBalances, liabilities);\\n    }\\n\\n    function doRefundAtomic(\\n        bytes32 secretHash,\\n        mapping(bytes32 => LockOrder) storage atomicSwaps,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) public returns(LockOrder storage swap) {\\n        swap = atomicSwaps[secretHash];\\n        require(swap.sender != address(0x0), \\\"E17NF\\\");\\n        require(swap.expiration/1000 < block.timestamp, \\\"E17NE\\\");\\n        require(!swap.used, \\\"E17U\\\");\\n\\n        swap.used = true;\\n        LibExchange._updateBalance(swap.sender, swap.asset, int(swap.amount), assetBalances, liabilities);\\n    }\\n\\n    function getEthSignedAtomicOrderHash(RedeemOrder calldata _order) internal pure returns (bytes32) {\\n        return\\n        keccak256(\\n            abi.encodePacked(\\n                \\\"atomicOrder\\\",\\n                _order.sender,\\n                _order.receiver,\\n                _order.claimReceiver,\\n                _order.asset,\\n                _order.amount,\\n                _order.expiration,\\n                _order.secretHash\\n            )\\n        ).toEthSignedMessageHash();\\n    }\\n\\n    function getEthSignedClaimOrderHash(ClaimOrder memory _order) internal pure returns (bytes32) {\\n        return\\n        keccak256(\\n            abi.encodePacked(\\n                \\\"claimOrder\\\",\\n                _order.receiver,\\n                _order.secretHash\\n            )\\n        ).toEthSignedMessageHash();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libs/LibUnitConverter.sol\\\";\\nimport \\\"./libs/LibValidator.sol\\\";\\nimport \\\"./libs/LibExchange.sol\\\";\\nimport \\\"./libs/MarginalFunctionality.sol\\\";\\nimport \\\"./libs/SafeTransferHelper.sol\\\";\\nimport \\\"./OrionVault.sol\\\";\\n\\n/**\\n * @title Exchange\\n * @dev Exchange contract for the Orion Protocol\\n * @author @wafflemakr\\n */\\n\\n/*\\n\\n  Overflow safety:\\n  We do not use SafeMath and control overflows by\\n  not accepting large ints on input.\\n\\n  Balances inside contract are stored as int192.\\n\\n  Allowed input amounts are int112 or uint112: it is enough for all\\n  practically used tokens: for instance if decimal unit is 1e18, int112\\n  allow to encode up to 2.5e15 decimal units.\\n  That way adding/subtracting any amount from balances won't overflow, since\\n  minimum number of operations to reach max int is practically infinite: ~1e24.\\n\\n  Allowed prices are uint64. Note, that price is represented as\\n  price per 1e8 tokens. That means that amount*price always fit uint256,\\n  while amount*price/1e8 not only fit int192, but also can be added, subtracted\\n  without overflow checks: number of malicion operations to overflow ~1e13.\\n*/\\ncontract Exchange is OrionVault, ReentrancyGuard {\\n    using LibValidator for LibValidator.Order;\\n    using SafeERC20 for IERC20;\\n\\n    //  Flags for updateOrders\\n    //      All flags are explicit\\n    uint8 constant kSell = 0;\\n    uint8 constant kBuy = 1; //  if 0 - then sell\\n    uint8 constant kCorrectMatcherFeeByOrderAmount = 2;\\n\\n    // EVENTS\\n    event NewAssetTransaction(\\n        address indexed user,\\n        address indexed assetAddress,\\n        bool isDeposit,\\n        uint112 amount,\\n        uint64 timestamp\\n    );\\n\\n    event NewTrade(\\n        address indexed buyer,\\n        address indexed seller,\\n        address baseAsset,\\n        address quoteAsset,\\n        uint64 filledPrice,\\n        uint192 filledAmount,\\n        uint192 amountQuote\\n    );\\n\\n    // MAIN FUNCTIONS\\n\\n    /**\\n     * @dev Since Exchange will work behind the Proxy contract it can not have constructor\\n     */\\n    function initialize() public payable initializer {\\n        OwnableUpgradeSafe.__Ownable_init();\\n    }\\n\\n    /**\\n     * @dev set marginal settings\\n     * @param _collateralAssets - list of addresses of assets which may be used as collateral\\n     * @param _stakeRisk - risk coefficient for staken orion as uint8 (0=0, 255=1)\\n     * @param _liquidationPremium - premium for liquidator as uint8 (0=0, 255=1)\\n     * @param _priceOverdue - time after that price became outdated\\n     * @param _positionOverdue - time after that liabilities became overdue and may be liquidated\\n     */\\n\\n    function updateMarginalSettings(\\n        address[] calldata _collateralAssets,\\n        uint8 _stakeRisk,\\n        uint8 _liquidationPremium,\\n        uint64 _priceOverdue,\\n        uint64 _positionOverdue\\n    ) public onlyOwner {\\n        collateralAssets = _collateralAssets;\\n        stakeRisk = _stakeRisk;\\n        liquidationPremium = _liquidationPremium;\\n        priceOverdue = _priceOverdue;\\n        positionOverdue = _positionOverdue;\\n    }\\n\\n    /**\\n     * @dev set risk coefficients for collateral assets\\n     * @param assets - list of assets\\n     * @param risks - list of risks as uint8 (0=0, 255=1)\\n     */\\n    function updateAssetRisks(address[] calldata assets, uint8[] calldata risks)\\n        public onlyOwner {\\n        for (uint256 i; i < assets.length; i++)\\n            assetRisks[assets[i]] = risks[i];\\n    }\\n\\n    /**\\n     * @dev Deposit ERC20 tokens to the exchange contract\\n     * @dev User needs to approve token contract first\\n     * @param amount asset amount to deposit in its base unit\\n     */\\n    function depositAsset(address assetAddress, uint112 amount) external {\\n        IERC20(assetAddress).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            uint256(amount)\\n        );\\n        generalDeposit(assetAddress, amount);\\n    }\\n\\n    /**\\n     * @notice Deposit ETH to the exchange contract\\n     * @dev deposit event will be emitted with the amount in decimal format (10^8)\\n     * @dev balance will be stored in decimal format too\\n     */\\n    function deposit() external payable {\\n        generalDeposit(address(0), uint112(msg.value));\\n    }\\n\\n    /**\\n     * @dev internal implementation of deposits\\n     */\\n    function generalDeposit(address assetAddress, uint112 amount) internal {\\n        address user = msg.sender;\\n        bool wasLiability = assetBalances[user][assetAddress] < 0;\\n        int112 safeAmountDecimal = LibUnitConverter.baseUnitToDecimal(\\n            assetAddress,\\n            amount\\n        );\\n        assetBalances[user][assetAddress] += safeAmountDecimal;\\n        if (amount > 0)\\n            emit NewAssetTransaction(\\n                user,\\n                assetAddress,\\n                true,\\n                uint112(safeAmountDecimal),\\n                uint64(block.timestamp)\\n            );\\n        if (wasLiability)\\n            MarginalFunctionality.updateLiability(\\n                user,\\n                assetAddress,\\n                liabilities,\\n                uint112(safeAmountDecimal),\\n                assetBalances[user][assetAddress]\\n            );\\n    }\\n\\n    /**\\n     * @dev Withdrawal of remaining funds from the contract back to the address\\n     * @param assetAddress address of the asset to withdraw\\n     * @param amount asset amount to withdraw in its base unit\\n     */\\n    function withdraw(address assetAddress, uint112 amount)\\n        external nonReentrant {\\n        int112 safeAmountDecimal = LibUnitConverter.baseUnitToDecimal(\\n            assetAddress,\\n            amount\\n        );\\n        address user = msg.sender;\\n\\n        assetBalances[user][assetAddress] -= safeAmountDecimal;\\n        require(assetBalances[user][assetAddress] >= 0, \\\"E1w1\\\"); //TODO\\n        require(checkPosition(user), \\\"E1w2\\\"); //TODO\\n\\n        if (assetAddress == address(0)) {\\n            (bool success, ) = user.call{value: amount}(\\\"\\\");\\n            require(success, \\\"E6w\\\");\\n        } else {\\n            IERC20(assetAddress).safeTransfer(user, amount);\\n        }\\n\\n        emit NewAssetTransaction(\\n            user,\\n            assetAddress,\\n            false,\\n            uint112(safeAmountDecimal),\\n            uint64(block.timestamp)\\n        );\\n    }\\n\\n    /**\\n     * @dev Get asset balance for a specific address\\n     * @param assetAddress address of the asset to query\\n     * @param user user address to query\\n     */\\n    function getBalance(address assetAddress, address user)\\n        public view returns (int192) {\\n        return assetBalances[user][assetAddress];\\n    }\\n\\n    /**\\n     * @dev Batch query of asset balances for a user\\n     * @param assetsAddresses array of addresses of the assets to query\\n     * @param user user address to query\\n     */\\n    function getBalances(address[] memory assetsAddresses, address user)\\n        public view returns (int192[] memory balances) {\\n        balances = new int192[](assetsAddresses.length);\\n        for (uint256 i; i < assetsAddresses.length; i++) {\\n            balances[i] = assetBalances[user][assetsAddresses[i]];\\n        }\\n    }\\n\\n    /**\\n     * @dev Batch query of asset liabilities for a user\\n     * @param user user address to query\\n     */\\n    function getLiabilities(address user)\\n        public view returns (MarginalFunctionality.Liability[] memory liabilitiesArray) {\\n        return liabilities[user];\\n    }\\n\\n    /**\\n     * @dev Return list of assets which can be used for collateral\\n     */\\n    function getCollateralAssets() public view returns (address[] memory) {\\n        return collateralAssets;\\n    }\\n\\n    /**\\n     * @dev get hash for an order\\n     * @dev we use order hash as order id to prevent double matching of the same order\\n     */\\n    function getOrderHash(LibValidator.Order memory order)\\n        public pure returns (bytes32) {\\n        return order.getTypeValueHash();\\n    }\\n\\n    /**\\n     * @dev get filled amounts for a specific order\\n     */\\n\\n    function getFilledAmounts(\\n        bytes32 orderHash,\\n        LibValidator.Order memory order\\n    ) public view returns (int192 totalFilled, int192 totalFeesPaid) {\\n        totalFilled = int192(filledAmounts[orderHash]); //It is safe to convert here: filledAmounts is result of ui112 additions\\n        totalFeesPaid = int192(\\n            (uint256(order.matcherFee) * uint112(totalFilled)) / order.amount\\n        ); //matcherFee is u64; safe multiplication here\\n    }\\n\\n    /**\\n     * @notice Settle a trade with two orders, filled price and amount\\n     * @dev 2 orders are submitted, it is necessary to match them:\\n        check conditions in orders for compliance filledPrice, filledAmountbuyOrderHash\\n        change balances on the contract respectively with buyer, seller, matcbuyOrderHashher\\n     * @param buyOrder structure of buy side orderbuyOrderHash\\n     * @param sellOrder structure of sell side order\\n     * @param filledPrice price at which the order was settled\\n     * @param filledAmount amount settled between orders\\n     */\\n    struct UpdateOrderBalanceData {\\n        uint buyType;\\n        uint sellType;\\n        int buyIn;\\n        int sellIn;\\n    }\\n\\n    function fillOrders(\\n        LibValidator.Order memory buyOrder,\\n        LibValidator.Order memory sellOrder,\\n        uint64 filledPrice,\\n        uint112 filledAmount\\n    ) public nonReentrant {\\n        // --- VARIABLES --- //\\n        // Amount of quote asset\\n        uint256 _amountQuote = (uint256(filledAmount) * filledPrice) / (10**8);\\n        require(_amountQuote < type(uint112).max, \\\"E12G\\\");\\n        uint112 amountQuote = uint112(_amountQuote);\\n\\n        // Order Hashes\\n        bytes32 buyOrderHash = buyOrder.getTypeValueHash();\\n        bytes32 sellOrderHash = sellOrder.getTypeValueHash();\\n\\n        // --- VALIDATIONS --- //\\n\\n        // Validate signatures using eth typed sign V1\\n        require(\\n            LibValidator.checkOrdersInfo(\\n                buyOrder,\\n                sellOrder,\\n                msg.sender,\\n                filledAmount,\\n                filledPrice,\\n                block.timestamp,\\n                _allowedMatcher\\n            ),\\n            \\\"E3G\\\"\\n        );\\n\\n        // --- UPDATES --- //\\n\\n        //updateFilledAmount\\n        filledAmounts[buyOrderHash] += filledAmount; //it is safe to add ui112 to each other to get i192\\n        filledAmounts[sellOrderHash] += filledAmount;\\n        require(filledAmounts[buyOrderHash] <= buyOrder.amount, \\\"E12B\\\");\\n        require(filledAmounts[sellOrderHash] <= sellOrder.amount, \\\"E12S\\\");\\n\\n\\n        // Update User's balances\\n        UpdateOrderBalanceData memory data;\\n        (data.buyType, data.buyIn) = LibExchange.updateOrderBalanceDebit(\\n            buyOrder,\\n            filledAmount,\\n            amountQuote,\\n            kBuy | kCorrectMatcherFeeByOrderAmount,\\n            assetBalances,\\n            liabilities\\n        );\\n        (data.sellType, data.sellIn) = LibExchange.updateOrderBalanceDebit(\\n            sellOrder,\\n            filledAmount,\\n            amountQuote,\\n            kSell | kCorrectMatcherFeeByOrderAmount,\\n            assetBalances,\\n            liabilities\\n        );\\n\\n        LibExchange.creditUserAssets(data.buyType, buyOrder.senderAddress, data.buyIn, buyOrder.baseAsset, assetBalances, liabilities);\\n        LibExchange.creditUserAssets(data.sellType, sellOrder.senderAddress, data.sellIn, sellOrder.quoteAsset, assetBalances, liabilities);\\n\\n        require(checkPosition(buyOrder.senderAddress), \\\"E1PB\\\");\\n        require(checkPosition(sellOrder.senderAddress), \\\"E1PS\\\");\\n\\n        emit NewTrade(\\n            buyOrder.senderAddress,\\n            sellOrder.senderAddress,\\n            buyOrder.baseAsset,\\n            buyOrder.quoteAsset,\\n            filledPrice,\\n            filledAmount,\\n            amountQuote\\n        );\\n    }\\n\\n    /**\\n     * @dev wrapper for LibValidator methods, may be deleted.\\n     */\\n    function validateOrder(LibValidator.Order memory order)\\n        public pure returns (bool isValid) {\\n        isValid = order.isPersonalSign\\n        ? LibValidator.validatePersonal(order)\\n        : LibValidator.validateV3(order);\\n    }\\n\\n    /**\\n     * @dev check user marginal position (compare assets and liabilities)\\n     * @return isPositive - boolean whether liabilities are covered by collateral or not\\n     */\\n    function checkPosition(address user) public view returns (bool) {\\n        if (liabilities[user].length == 0) return true;\\n        return calcPosition(user).state == MarginalFunctionality.PositionState.POSITIVE;\\n    }\\n\\n    /**\\n     * @dev internal methods which collect all variables used by MarginalFunctionality to one structure\\n     * @param user user address to query\\n     * @return UsedConstants - MarginalFunctionality.UsedConstants structure\\n     */\\n    function getConstants(address user)\\n        internal view returns (MarginalFunctionality.UsedConstants memory) {\\n        return\\n        MarginalFunctionality.UsedConstants(\\n            user,\\n            _oracleAddress,\\n            address(_orionToken),\\n            positionOverdue,\\n            priceOverdue,\\n            stakeRisk,\\n            liquidationPremium\\n        );\\n    }\\n\\n    /**\\n     * @dev calc user marginal position (compare assets and liabilities)\\n     * @param user user address to query\\n     * @return position - MarginalFunctionality.Position structure\\n     */\\n    function calcPosition(address user)\\n        public view returns (MarginalFunctionality.Position memory) {\\n        MarginalFunctionality.UsedConstants memory constants = getConstants(\\n            user\\n        );\\n\\n        return MarginalFunctionality.calcPosition(\\n            collateralAssets,\\n            liabilities,\\n            assetBalances,\\n            assetRisks,\\n            constants\\n        );\\n    }\\n\\n    /**\\n     * @dev method to cover some of overdue broker liabilities and get ORN in exchange\\n            same as liquidation or margin call\\n     * @param broker - broker which will be liquidated\\n     * @param redeemedAsset - asset, liability of which will be covered\\n     * @param amount - amount of covered asset\\n     */\\n\\n    function partiallyLiquidate(\\n        address broker,\\n        address redeemedAsset,\\n        uint112 amount\\n    ) public {\\n        MarginalFunctionality.UsedConstants memory constants = getConstants(\\n            broker\\n        );\\n        MarginalFunctionality.partiallyLiquidate(\\n            collateralAssets,\\n            liabilities,\\n            assetBalances,\\n            assetRisks,\\n            constants,\\n            redeemedAsset,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     *  @dev  revert on fallback function\\n     */\\n    fallback() external {\\n        revert(\\\"E6\\\");\\n    }\\n\\n    /* Error Codes\\n        E1: Insufficient Balance, flavor S - stake, L - liabilities, P - Position, B,S - buyer, seller\\n        E2: Invalid Signature, flavor B,S - buyer, seller\\n        E3: Invalid Order Info, flavor G - general, M - wrong matcher, M2 unauthorized matcher, As - asset mismatch,\\n            AmB/AmS - amount mismatch (buyer,seller), PrB/PrS - price mismatch(buyer,seller), D - direction mismatch,\\n            U - Unit Converter Error, C - caller mismatch\\n        E4: Order expired, flavor B,S - buyer,seller\\n        E5: Contract not active,\\n        E6: Transfer error\\n        E7: Incorrect state prior to liquidation\\n        E8: Liquidator doesn't satisfy requirements\\n        E9: Data for liquidation handling is outdated\\n        E10: Incorrect state after liquidation\\n        E11: Amount overflow\\n        E12: Incorrect filled amount, flavor G,B,S: general(overflow), buyer order overflow, seller order overflow\\n        E14: Authorization error, sfs - seizeFromStake\\n        E15: Wrong passed params\\n        E16: Underlying protection mechanism error, flavor: R, I, O: Reentrancy, Initialization, Ownable\\n    */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolSwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\n\\ninterface IPoolSwapCallback {\\n    function safeAutoTransferFrom(address token, address from, address to, uint value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolFunctionality.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\n\\ninterface IPoolFunctionality {\\n    function doSwapThroughOrionPool(\\n        address     user,\\n        uint112     amount_spend,\\n        uint112     amount_receive,\\n        address[]   calldata   path,\\n        bool        is_exact_spend,\\n        address     to\\n    ) external returns (uint amountOut, uint amountIn);\\n\\n    function getWETH() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibPool.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./LibValidator.sol\\\";\\nimport \\\"./LibExchange.sol\\\";\\nimport \\\"./LibUnitConverter.sol\\\";\\nimport \\\"./SafeTransferHelper.sol\\\";\\nimport \\\"../interfaces/IPoolFunctionality.sol\\\";\\n\\nlibrary LibPool {\\n\\n    function updateFilledAmount(\\n        LibValidator.Order memory order,\\n        uint112 filledBase,\\n        mapping(bytes32 => uint192) storage filledAmounts\\n    ) internal {\\n        bytes32 orderHash = LibValidator.getTypeValueHash(order);\\n        uint192 total_amount = filledAmounts[orderHash];\\n        total_amount += filledBase; //it is safe to add ui112 to each other to get i192\\n        require(total_amount >= filledBase, \\\"E12B_0\\\");\\n        require(total_amount <= order.amount, \\\"E12B\\\");\\n        filledAmounts[orderHash] = total_amount;\\n    }\\n\\n    function refundChange(uint amountOut) internal {\\n        uint actualOutBaseUnit = uint(LibUnitConverter.decimalToBaseUnit(address(0), amountOut));\\n        if (msg.value > actualOutBaseUnit) {\\n            SafeTransferHelper.safeTransferTokenOrETH(address(0), msg.sender, msg.value - actualOutBaseUnit);\\n        }\\n    }\\n\\n    function doSwapThroughOrionPool(\\n        uint112     amount_spend,\\n        uint112     amount_receive,\\n        address[] calldata   path,\\n        bool        is_exact_spend,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities,\\n        address orionpoolRouter\\n    ) public returns(bool) {\\n        bool isInContractTrade = assetBalances[msg.sender][path[0]] > 0;\\n        bool isSentETHEnough;\\n        if (msg.value > 0) {\\n            uint112 eth_sent = uint112(LibUnitConverter.baseUnitToDecimal(address(0), msg.value));\\n            if (path[0] == address(0) && eth_sent >= amount_spend) {\\n                isSentETHEnough = true;\\n                isInContractTrade = false;\\n            } else {\\n                LibExchange._updateBalance(msg.sender, address(0), eth_sent, assetBalances, liabilities);\\n            }\\n        }\\n\\n        (uint amountOut, uint amountIn) = IPoolFunctionality(orionpoolRouter).doSwapThroughOrionPool(\\n            isInContractTrade || isSentETHEnough ? address(this) : msg.sender,\\n            amount_spend,\\n            amount_receive,\\n            path,\\n            is_exact_spend,\\n            isInContractTrade ? address(this) : msg.sender\\n        );\\n\\n        if (isSentETHEnough) {\\n            refundChange(amountOut);\\n        } else if (isInContractTrade) {\\n            LibExchange._updateBalance(msg.sender, path[0], -1*int256(amountOut), assetBalances, liabilities);\\n            LibExchange._updateBalance(msg.sender, path[path.length-1], int(amountIn), assetBalances, liabilities);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    //  Just to avoid stack too deep error;\\n    struct OrderExecutionData {\\n        uint filledBase;\\n        uint filledQuote;\\n        uint filledPrice;\\n        uint amount_spend;\\n        uint amount_receive;\\n        uint amountQuote;\\n        bool isInContractTrade;\\n        bool isRetainFee;\\n        address to;\\n    }\\n\\n    function calcAmounts(\\n        LibValidator.Order memory order,\\n        uint112 filledAmount,\\n        address[] calldata path,\\n        mapping(address => mapping(address => int192)) storage assetBalances\\n    ) internal returns (OrderExecutionData memory tmp) {\\n        tmp.amountQuote = uint(filledAmount) * order.price / (10**8);\\n        (tmp.amount_spend, tmp.amount_receive) = order.buySide == 0 ? (uint(filledAmount), tmp.amountQuote)\\n            : (tmp.amountQuote, uint(filledAmount));\\n\\n        tmp.isInContractTrade = path[0] == address(0) || assetBalances[order.senderAddress][path[0]] > 0;\\n        tmp.isRetainFee = !tmp.isInContractTrade && order.matcherFeeAsset == path[path.length-1];\\n\\n        tmp.to = (tmp.isInContractTrade || tmp.isRetainFee) ? address(this) : order.senderAddress;\\n    }\\n\\n    function calcAmountInOutAfterSwap(\\n        OrderExecutionData memory tmp,\\n        LibValidator.Order memory order,\\n        uint64 blockchainFee,\\n        address[] calldata path,\\n        uint amountOut,\\n        uint amountIn,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) internal {\\n        bool isSeller = order.buySide == 0;\\n\\n        (tmp.filledBase, tmp.filledQuote) = isSeller ? (amountOut, amountIn) : (amountIn, amountOut);\\n        tmp.filledPrice = tmp.filledQuote * (10**8) / tmp.filledBase;\\n\\n        if (isSeller) {\\n            require(tmp.filledPrice >= order.price, \\\"EX\\\");\\n        } else {\\n            require(tmp.filledPrice <= order.price, \\\"EX\\\");\\n        }\\n\\n        //  Change fee only after order validation\\n        if (blockchainFee < order.matcherFee)\\n            order.matcherFee = blockchainFee;\\n\\n        if (tmp.isInContractTrade) {\\n            (uint tradeType, int actualIn) = LibExchange.updateOrderBalanceDebit(order, uint112(tmp.filledBase),\\n                uint112(tmp.filledQuote), isSeller ? LibExchange.kSell : LibExchange.kBuy, assetBalances, liabilities);\\n            LibExchange.creditUserAssets(tradeType, order.senderAddress, actualIn, path[path.length-1], assetBalances, liabilities);\\n\\n        } else {\\n            _payMatcherFee(order, assetBalances, liabilities);\\n            if (tmp.isRetainFee) {\\n                LibExchange.creditUserAssets(1, order.senderAddress, int(amountIn), path[path.length-1], assetBalances, liabilities);\\n            }\\n        }\\n    }\\n\\n    function doFillThroughOrionPool(\\n        LibValidator.Order memory order,\\n        uint112 filledAmount,\\n        uint64 blockchainFee,\\n        address[] calldata path,\\n        address allowedMatcher,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities,\\n        address orionpoolRouter,\\n        mapping(bytes32 => uint192) storage filledAmounts\\n    ) public returns (OrderExecutionData memory tmp){\\n\\n        LibValidator.checkOrderSingleMatch(order, msg.sender, allowedMatcher, filledAmount, block.timestamp, path);\\n        bool isSeller = order.buySide == 0;\\n\\n        tmp = calcAmounts(order, filledAmount, path, assetBalances);\\n\\n        try IPoolFunctionality(orionpoolRouter).doSwapThroughOrionPool(\\n            tmp.isInContractTrade ? address(this) : order.senderAddress,\\n            uint112(tmp.amount_spend),\\n            uint112(tmp.amount_receive),\\n            path,\\n            isSeller,\\n            tmp.to\\n        ) returns(uint amountOut, uint amountIn) {\\n            calcAmountInOutAfterSwap(tmp, order, blockchainFee, path, amountOut, amountIn, assetBalances, liabilities);\\n        } catch(bytes memory) {\\n            tmp.filledBase = 0;\\n            tmp.filledPrice = order.price;\\n            _payMatcherFee(order, assetBalances, liabilities);\\n        }\\n\\n        updateFilledAmount(order, uint112(tmp.filledBase), filledAmounts);\\n    }\\n\\n    function _payMatcherFee(\\n        LibValidator.Order memory order,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) internal {\\n        LibExchange._updateBalance(order.senderAddress, order.matcherFeeAsset, -1*int(order.matcherFee), assetBalances, liabilities);\\n        LibExchange._updateBalance(order.matcherAddress, order.matcherFeeAsset, int(order.matcherFee), assetBalances, liabilities);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.4;\\n\\ncontract ReentrancyGuard {\\n\\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\\n\\n    string private constant ERROR_REENTRANT = \\\"REENTRANCY_REENTRANT_CALL\\\";\\n\\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function setStorageBool(bytes32 position, bool data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n\\n    modifier nonReentrant() {\\n        // Ensure mutex is unlocked\\n        require(!getStorageBool(REENTRANCY_MUTEX_POSITION), ERROR_REENTRANT);\\n\\n        // Lock mutex before function call\\n        setStorageBool(REENTRANCY_MUTEX_POSITION,true);\\n\\n        // Perform function call\\n        _;\\n\\n        // Unlock mutex after function call\\n        setStorageBool(REENTRANCY_MUTEX_POSITION, false);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibUnitConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\n\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\n\\nlibrary LibUnitConverter {\\n\\n    using SafeMath for uint;\\n\\n    /**\\n        @notice convert asset amount from8 decimals (10^8) to its base unit\\n     */\\n    function decimalToBaseUnit(address assetAddress, uint amount) internal view returns(int112 baseValue){\\n        uint256 result;\\n\\n        if(assetAddress == address(0)){\\n            result =  amount.mul(1 ether).div(10**8); // 18 decimals\\n        } else {\\n\\n            ERC20 asset = ERC20(assetAddress);\\n            uint decimals = asset.decimals();\\n\\n            result = amount.mul(10**decimals).div(10**8);\\n        }\\n\\n        require(result < uint256(type(int112).max), \\\"E3U\\\");\\n        baseValue = int112(result);\\n    }\\n\\n    /**\\n        @notice convert asset amount from its base unit to 8 decimals (10^8)\\n     */\\n    function baseUnitToDecimal(address assetAddress, uint amount) internal view returns(int112 decimalValue){\\n        uint256 result;\\n\\n        if(assetAddress == address(0)){\\n            result = amount.mul(10**8).div(1 ether);\\n        } else {\\n\\n            ERC20 asset = ERC20(assetAddress);\\n            uint decimals = asset.decimals();\\n\\n            result = amount.mul(10**8).div(10**decimals);\\n        }\\n        require(result < uint256(type(int112).max), \\\"E3U\\\");\\n        decimalValue = int112(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\n\\nlibrary LibValidator {\\n\\n    using ECDSA for bytes32;\\n\\n    string public constant DOMAIN_NAME = \\\"Orion Exchange\\\";\\n    string public constant DOMAIN_VERSION = \\\"1\\\";\\n    uint256 public constant CHAIN_ID = 1;\\n    bytes32 public constant DOMAIN_SALT = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a557;\\n\\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,bytes32 salt)\\\"\\n        )\\n    );\\n    bytes32 public constant ORDER_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"Order(address senderAddress,address matcherAddress,address baseAsset,address quoteAsset,address matcherFeeAsset,uint64 amount,uint64 price,uint64 matcherFee,uint64 nonce,uint64 expiration,uint8 buySide)\\\"\\n        )\\n    );\\n\\n    bytes32 public constant DOMAIN_SEPARATOR = keccak256(\\n        abi.encode(\\n            EIP712_DOMAIN_TYPEHASH,\\n            keccak256(bytes(DOMAIN_NAME)),\\n            keccak256(bytes(DOMAIN_VERSION)),\\n            CHAIN_ID,\\n            DOMAIN_SALT\\n        )\\n    );\\n\\n    struct Order {\\n        address senderAddress;\\n        address matcherAddress;\\n        address baseAsset;\\n        address quoteAsset;\\n        address matcherFeeAsset;\\n        uint64 amount;\\n        uint64 price;\\n        uint64 matcherFee;\\n        uint64 nonce;\\n        uint64 expiration;\\n        uint8 buySide; // buy or sell\\n        bool isPersonalSign;\\n        bytes signature;\\n    }\\n\\n    /**\\n     * @dev validate order signature\\n     */\\n    function validateV3(Order memory order) public pure returns (bool) {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                getTypeValueHash(order)\\n            )\\n        );\\n\\n        return digest.recover(order.signature) == order.senderAddress;\\n    }\\n\\n    /**\\n     * @return hash order\\n     */\\n    function getTypeValueHash(Order memory _order)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    ORDER_TYPEHASH,\\n                    _order.senderAddress,\\n                    _order.matcherAddress,\\n                    _order.baseAsset,\\n                    _order.quoteAsset,\\n                    _order.matcherFeeAsset,\\n                    _order.amount,\\n                    _order.price,\\n                    _order.matcherFee,\\n                    _order.nonce,\\n                    _order.expiration,\\n                    _order.buySide\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev basic checks of matching orders against each other\\n     */\\n    function checkOrdersInfo(\\n        Order memory buyOrder,\\n        Order memory sellOrder,\\n        address sender,\\n        uint256 filledAmount,\\n        uint256 filledPrice,\\n        uint256 currentTime,\\n        address allowedMatcher\\n    ) public pure returns (bool success) {\\n        buyOrder.isPersonalSign ? require(validatePersonal(buyOrder), \\\"E2BP\\\") : require(validateV3(buyOrder), \\\"E2B\\\");\\n        sellOrder.isPersonalSign ? require(validatePersonal(sellOrder), \\\"E2SP\\\") : require(validateV3(sellOrder), \\\"E2S\\\");\\n\\n        // Same matcher address\\n        require(\\n            buyOrder.matcherAddress == sender &&\\n                sellOrder.matcherAddress == sender,\\n            \\\"E3M\\\"\\n        );\\n\\n        if(allowedMatcher != address(0)) {\\n          require(buyOrder.matcherAddress == allowedMatcher, \\\"E3M2\\\");\\n        }\\n\\n\\n        // Check matching assets\\n        require(\\n            buyOrder.baseAsset == sellOrder.baseAsset &&\\n                buyOrder.quoteAsset == sellOrder.quoteAsset,\\n            \\\"E3As\\\"\\n        );\\n\\n        // Check order amounts\\n        require(filledAmount <= buyOrder.amount, \\\"E3AmB\\\");\\n        require(filledAmount <= sellOrder.amount, \\\"E3AmS\\\");\\n\\n        // Check Price values\\n        require(filledPrice <= buyOrder.price, \\\"E3\\\");\\n        require(filledPrice >= sellOrder.price, \\\"E3\\\");\\n\\n        // Check Expiration Time. Convert to seconds first\\n        require(buyOrder.expiration/1000 >= currentTime, \\\"E4B\\\");\\n        require(sellOrder.expiration/1000 >= currentTime, \\\"E4S\\\");\\n\\n        require( buyOrder.buySide==1 && sellOrder.buySide==0, \\\"E3D\\\");\\n        success = true;\\n    }\\n\\n    function getEthSignedOrderHash(Order memory _order) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"order\\\",\\n                    _order.senderAddress,\\n                    _order.matcherAddress,\\n                    _order.baseAsset,\\n                    _order.quoteAsset,\\n                    _order.matcherFeeAsset,\\n                    _order.amount,\\n                    _order.price,\\n                    _order.matcherFee,\\n                    _order.nonce,\\n                    _order.expiration,\\n                    _order.buySide\\n                )\\n            ).toEthSignedMessageHash();\\n    }\\n\\n    function validatePersonal(Order memory order) public pure returns (bool) {\\n\\n        bytes32 digest = getEthSignedOrderHash(order);\\n        return digest.recover(order.signature) == order.senderAddress;\\n    }\\n\\n    function checkOrderSingleMatch(\\n        Order memory buyOrder,\\n        address sender,\\n        address allowedMatcher,\\n        uint112 filledAmount,\\n        uint256 currentTime,\\n        address[] memory path\\n    ) internal pure {\\n        buyOrder.isPersonalSign ? require(validatePersonal(buyOrder), \\\"E2BP\\\") : require(validateV3(buyOrder), \\\"E2B\\\");\\n        require(buyOrder.matcherAddress == sender && buyOrder.matcherAddress == allowedMatcher, \\\"E3M2\\\");\\n        if(buyOrder.buySide==1){\\n            require(\\n                buyOrder.baseAsset == path[path.length-1] &&\\n                buyOrder.quoteAsset == path[0],\\n                \\\"E3As\\\"\\n            );\\n        }else{\\n            require(\\n                buyOrder.quoteAsset == path[path.length-1] &&\\n                buyOrder.baseAsset == path[0],\\n                \\\"E3As\\\"\\n            );\\n        }\\n        require(filledAmount <= buyOrder.amount, \\\"E3AmB\\\");\\n        require(buyOrder.expiration/1000 >= currentTime, \\\"E4B\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibExchange.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./MarginalFunctionality.sol\\\";\\nimport \\\"./LibUnitConverter.sol\\\";\\nimport \\\"./LibValidator.sol\\\";\\nimport \\\"./SafeTransferHelper.sol\\\";\\n\\nlibrary LibExchange {\\n    using SafeERC20 for IERC20;\\n\\n    //  Flags for updateOrders\\n    //      All flags are explicit\\n    uint8 public constant kSell = 0;\\n    uint8 public constant kBuy = 1; //  if 0 - then sell\\n    uint8 public constant kCorrectMatcherFeeByOrderAmount = 2;\\n\\n    function _updateBalance(address user, address asset, int amount,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) internal returns (uint tradeType) { // 0 - in contract, 1 - from wallet\\n        int beforeBalance = int(assetBalances[user][asset]);\\n        int afterBalance = beforeBalance + amount;\\n\\n        if (amount > 0 && beforeBalance < 0) {\\n            MarginalFunctionality.updateLiability(user, asset, liabilities, uint112(amount), int192(afterBalance));\\n        } else if (beforeBalance >= 0 && afterBalance < 0){\\n            if (asset != address(0)) {\\n                afterBalance += int(_tryDeposit(asset, uint(-1*afterBalance), user));\\n            }\\n\\n            // If we failed to deposit balance is still negative then we move user into liability\\n            if (afterBalance < 0) {\\n                setLiability(user, asset, int192(afterBalance), liabilities);\\n            } else {\\n                tradeType = beforeBalance > 0 ? 0 : 1;\\n            }\\n        }\\n\\n        if (beforeBalance != afterBalance) {\\n            assetBalances[user][asset] = int192(afterBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev method to add liability\\n     * @param user - user which created liability\\n     * @param asset - liability asset\\n     * @param balance - current negative balance\\n     */\\n    function setLiability(address user, address asset, int192 balance,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) internal {\\n        liabilities[user].push(\\n            MarginalFunctionality.Liability({\\n                asset : asset,\\n                timestamp : uint64(block.timestamp),\\n                outstandingAmount : uint192(- balance)\\n            })\\n        );\\n    }\\n\\n    function _tryDeposit(\\n        address asset,\\n        uint amount,\\n        address user\\n    ) internal returns(uint) {\\n        uint256 amountInBase = uint256(LibUnitConverter.decimalToBaseUnit(asset, amount));\\n\\n        // Query allowance before trying to transferFrom\\n        if (IERC20(asset).balanceOf(user) >= amountInBase && IERC20(asset).allowance(user, address(this)) >= amountInBase) {\\n            SafeERC20.safeTransferFrom(IERC20(asset), user, address(this), amountInBase);\\n            return amount;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function creditUserAssets(uint tradeType, address user, int amount, address asset,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) internal {\\n        int beforeBalance = int(assetBalances[user][asset]);\\n        int remainingAmount = amount + beforeBalance;\\n        int sentAmount = 0;\\n        if (tradeType == 1 && remainingAmount > 0 && beforeBalance <= 0) {\\n            uint amountInBase = uint(LibUnitConverter.decimalToBaseUnit(asset, uint(remainingAmount)));\\n            uint contractBalance = asset == address(0) ? address(this).balance : IERC20(asset).balanceOf(address(this));\\n            if (contractBalance >= amountInBase) {\\n                SafeTransferHelper.safeTransferTokenOrETH(asset, user, amountInBase);\\n                sentAmount = remainingAmount;\\n            }\\n        }\\n        int toUpdate = amount - sentAmount;\\n        if (toUpdate != 0) {\\n            _updateBalance(user, asset, toUpdate, assetBalances, liabilities);\\n        }\\n    }\\n\\n    struct SwapBalanceChanges {\\n        int amountOut;\\n        address assetOut;\\n        int amountIn;\\n        address assetIn;\\n    }\\n\\n    /**\\n     *  @notice update user balances and send matcher fee\\n     *  @param flags uint8, see constants for possible flags of order\\n     */\\n    function updateOrderBalanceDebit(\\n        LibValidator.Order memory order,\\n        uint112 amountBase,\\n        uint112 amountQuote,\\n        uint8 flags,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) internal returns (uint tradeType, int actualIn) {\\n        bool isSeller = (flags & kBuy) == 0;\\n\\n        {\\n            //  Stack too deep\\n            bool isCorrectFee = ((flags & kCorrectMatcherFeeByOrderAmount) != 0);\\n\\n            if (isCorrectFee) {\\n                // matcherFee: u64, filledAmount u128 => matcherFee*filledAmount fit u256\\n                // result matcherFee fit u64\\n                order.matcherFee = uint64(\\n                    (uint256(order.matcherFee) * amountBase) / order.amount\\n                ); //rewrite in memory only\\n            }\\n        }\\n\\n        if (amountBase > 0) {\\n            SwapBalanceChanges memory swap;\\n\\n            (swap.amountOut, swap.amountIn) = isSeller\\n            ? (-1*int(amountBase), int(amountQuote))\\n            : (-1*int(amountQuote), int(amountBase));\\n\\n            (swap.assetOut, swap.assetIn) = isSeller\\n            ? (order.baseAsset, order.quoteAsset)\\n            : (order.quoteAsset, order.baseAsset);\\n\\n\\n            uint feeTradeType = 1;\\n            if (order.matcherFeeAsset == swap.assetOut) {\\n                swap.amountOut -= order.matcherFee;\\n            } else if (order.matcherFeeAsset == swap.assetIn) {\\n                swap.amountIn -= order.matcherFee;\\n            } else {\\n                feeTradeType = _updateBalance(order.senderAddress, order.matcherFeeAsset, -1*int256(order.matcherFee),\\n                    assetBalances, liabilities);\\n            }\\n\\n            tradeType = feeTradeType & _updateBalance(order.senderAddress, swap.assetOut, swap.amountOut, assetBalances, liabilities);\\n\\n            actualIn = swap.amountIn;\\n\\n            _updateBalance(order.matcherAddress, order.matcherFeeAsset, order.matcherFee, assetBalances, liabilities);\\n        }\\n\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libs/MarginalFunctionality.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport \\\"../PriceOracleInterface.sol\\\";\\n\\nlibrary MarginalFunctionality {\\n\\n    // We have the following approach: when liability is created we store\\n    // timestamp and size of liability. If the subsequent trade will deepen\\n    // this liability or won't fully cover it timestamp will not change.\\n    // However once outstandingAmount is covered we check whether balance on\\n    // that asset is positive or not. If not, liability still in the place but\\n    // time counter is dropped and timestamp set to `now`.\\n    struct Liability {\\n        address asset;\\n        uint64 timestamp;\\n        uint192 outstandingAmount;\\n    }\\n\\n    enum PositionState {\\n        POSITIVE,\\n        NEGATIVE, // weighted position below 0\\n        OVERDUE,  // liability is not returned for too long\\n        NOPRICE,  // some assets has no price or expired\\n        INCORRECT // some of the basic requirements are not met: too many liabilities, no locked stake, etc\\n    }\\n\\n    struct Position {\\n        PositionState state;\\n        int256 weightedPosition; // sum of weighted collateral minus liabilities\\n        int256 totalPosition; // sum of unweighted (total) collateral minus liabilities\\n        int256 totalLiabilities; // total liabilities value\\n    }\\n\\n    // Constants from Exchange contract used for calculations\\n    struct UsedConstants {\\n        address user;\\n        address _oracleAddress;\\n        address _orionTokenAddress;\\n        uint64 positionOverdue;\\n        uint64 priceOverdue;\\n        uint8 stakeRisk;\\n        uint8 liquidationPremium;\\n    }\\n\\n\\n    /**\\n     * @dev method to multiply numbers with uint8 based percent numbers\\n     */\\n    function uint8Percent(int192 _a, uint8 b) internal pure returns (int192 c) {\\n        int a = int256(_a);\\n        int d = 255;\\n        c = int192((a>65536) ? (a/d)*b : a*b/d );\\n    }\\n\\n    /**\\n     * @dev method to fetch asset prices in ORN tokens\\n     */\\n    function getAssetPrice(address asset, address oracle) internal view returns (uint64 price, uint64 timestamp) {\\n        PriceOracleInterface.PriceDataOut memory assetPriceData = PriceOracleInterface(oracle).assetPrices(asset);\\n        (price, timestamp) = (assetPriceData.price, assetPriceData.timestamp);\\n    }\\n\\n    /**\\n     * @dev method to calc weighted and absolute collateral value\\n     * @notice it only count for assets in collateralAssets list, all other\\n               assets will add 0 to position.\\n     * @return outdated whether any price is outdated\\n     * @return weightedPosition in ORN\\n     * @return totalPosition in ORN\\n     */\\n    function calcAssets(\\n        address[] storage collateralAssets,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => uint8) storage assetRisks,\\n        address user,\\n        address orionTokenAddress,\\n        address oracleAddress,\\n        uint64 priceOverdue\\n    ) internal view returns (bool outdated, int192 weightedPosition, int192 totalPosition) {\\n        uint256 collateralAssetsLength = collateralAssets.length;\\n        for(uint256 i = 0; i < collateralAssetsLength; i++) {\\n            address asset = collateralAssets[i];\\n            if(assetBalances[user][asset]<0)\\n                continue; // will be calculated in calcLiabilities\\n            (uint64 price, uint64 timestamp) = (1e8, 0xfffffff000000000);\\n\\n            if(asset != orionTokenAddress) {\\n                (price, timestamp) = getAssetPrice(asset, oracleAddress);\\n            }\\n\\n            // balance: i192, price u64 => balance*price fits i256\\n            // since generally balance <= N*maxInt112 (where N is number operations with it),\\n            // assetValue <= N*maxInt112*maxUInt64/1e8.\\n            // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n\\n            uint8 specificRisk = assetRisks[asset];\\n            int192 balance = assetBalances[user][asset];\\n            int256 _assetValue = int256(balance)*price/1e8;\\n            int192 assetValue = int192(_assetValue);\\n\\n            // Overflows logic holds here as well, except that N is the number of\\n            // operations for all assets\\n\\n            if(assetValue>0) {\\n                weightedPosition += uint8Percent(assetValue, specificRisk);\\n                totalPosition += assetValue;\\n                outdated = outdated || ((timestamp + priceOverdue) < block.timestamp);\\n            }\\n\\n        }\\n\\n        return (outdated, weightedPosition, totalPosition);\\n    }\\n\\n    /**\\n     * @dev method to calc liabilities\\n     * @return outdated whether any price is outdated\\n     * @return overdue whether any liability is overdue\\n     * @return weightedPosition weightedLiability == totalLiability in ORN\\n     * @return totalPosition totalLiability in ORN\\n     */\\n    function calcLiabilities(\\n        mapping(address => Liability[]) storage liabilities,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        address user,\\n        address oracleAddress,\\n        uint64 positionOverdue,\\n        uint64 priceOverdue\\n    ) internal view returns  (bool outdated, bool overdue, int192 weightedPosition, int192 totalPosition) {\\n        uint256 liabilitiesLength = liabilities[user].length;\\n\\n        for(uint256 i = 0; i < liabilitiesLength; i++) {\\n            Liability storage liability = liabilities[user][i];\\n            int192 balance = assetBalances[user][liability.asset];\\n            (uint64 price, uint64 timestamp) = getAssetPrice(liability.asset, oracleAddress);\\n            // balance: i192, price u64 => balance*price fits i256\\n            // since generally balance <= N*maxInt112 (where N is number operations with it),\\n            // assetValue <= N*maxInt112*maxUInt64/1e8.\\n            // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n\\n            int192 liabilityValue = int192(int256(balance) * price / 1e8);\\n            weightedPosition += liabilityValue; //already negative since balance is negative\\n            totalPosition += liabilityValue;\\n            overdue = overdue || ((liability.timestamp + positionOverdue) < block.timestamp);\\n            outdated = outdated || ((timestamp + priceOverdue) < block.timestamp);\\n        }\\n\\n        return (outdated, overdue, weightedPosition, totalPosition);\\n    }\\n\\n    /**\\n     * @dev method to calc Position\\n     * @return result position structure\\n     */\\n    function calcPosition(\\n        address[] storage collateralAssets,\\n        mapping(address => Liability[]) storage liabilities,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => uint8) storage assetRisks,\\n        UsedConstants memory constants\\n    ) public view returns (Position memory result) {\\n\\n        (bool outdatedPrice, int192 weightedPosition, int192 totalPosition) =\\n        calcAssets(\\n            collateralAssets,\\n            assetBalances,\\n            assetRisks,\\n            constants.user,\\n            constants._orionTokenAddress,\\n            constants._oracleAddress,\\n            constants.priceOverdue\\n        );\\n\\n        (bool _outdatedPrice, bool overdue, int192 _weightedPosition, int192 _totalPosition) =\\n        calcLiabilities(\\n            liabilities,\\n            assetBalances,\\n            constants.user,\\n            constants._oracleAddress,\\n            constants.positionOverdue,\\n            constants.priceOverdue\\n        );\\n\\n        weightedPosition += _weightedPosition;\\n        totalPosition += _totalPosition;\\n        outdatedPrice = outdatedPrice || _outdatedPrice;\\n        if(_totalPosition<0) {\\n            result.totalLiabilities = _totalPosition;\\n        }\\n        if(weightedPosition<0) {\\n            result.state = PositionState.NEGATIVE;\\n        }\\n        if(outdatedPrice) {\\n            result.state = PositionState.NOPRICE;\\n        }\\n        if(overdue) {\\n            result.state = PositionState.OVERDUE;\\n        }\\n        result.weightedPosition = weightedPosition;\\n        result.totalPosition = totalPosition;\\n    }\\n\\n    /**\\n     * @dev method removes liability\\n     */\\n    function removeLiability(\\n        address user,\\n        address asset,\\n        mapping(address => Liability[]) storage liabilities\\n    ) public {\\n        uint256 length = liabilities[user].length;\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            if (liabilities[user][i].asset == asset) {\\n                if (length>1) {\\n                    liabilities[user][i] = liabilities[user][length - 1];\\n                }\\n                liabilities[user].pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev method update liability\\n     * @notice implement logic for outstandingAmount (see Liability description)\\n     */\\n    function updateLiability(address user,\\n        address asset,\\n        mapping(address => Liability[]) storage liabilities,\\n        uint112 depositAmount,\\n        int192 currentBalance\\n    ) internal {\\n        if(currentBalance>=0) {\\n            removeLiability(user,asset,liabilities);\\n        } else {\\n            uint256 i;\\n            uint256 liabilitiesLength=liabilities[user].length;\\n            for(; i<liabilitiesLength-1; i++) {\\n                if(liabilities[user][i].asset == asset)\\n                    break;\\n            }\\n            Liability storage liability = liabilities[user][i];\\n            if(depositAmount>=liability.outstandingAmount) {\\n                liability.outstandingAmount = uint192(-currentBalance);\\n                liability.timestamp = uint64(block.timestamp);\\n            } else {\\n                liability.outstandingAmount -= depositAmount;\\n            }\\n        }\\n    }\\n\\n\\n    /**\\n     * @dev partially liquidate, that is cover some asset liability to get\\n            ORN from misbehavior broker\\n     */\\n    function partiallyLiquidate(address[] storage collateralAssets,\\n        mapping(address => Liability[]) storage liabilities,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => uint8) storage assetRisks,\\n        UsedConstants memory constants,\\n        address redeemedAsset,\\n        uint112 amount) public {\\n        //Note: constants.user - is broker who will be liquidated\\n        Position memory initialPosition = calcPosition(collateralAssets,\\n            liabilities,\\n            assetBalances,\\n            assetRisks,\\n            constants);\\n        require(initialPosition.state == PositionState.NEGATIVE ||\\n            initialPosition.state == PositionState.OVERDUE  , \\\"E7\\\");\\n        address liquidator = msg.sender;\\n        require(assetBalances[liquidator][redeemedAsset]>=amount,\\\"E8\\\");\\n        require(assetBalances[constants.user][redeemedAsset]<0,\\\"E15\\\");\\n        assetBalances[liquidator][redeemedAsset] -= amount;\\n        assetBalances[constants.user][redeemedAsset] += amount;\\n\\n        if(assetBalances[constants.user][redeemedAsset] >= 0)\\n            removeLiability(constants.user, redeemedAsset, liabilities);\\n\\n        (uint64 price, uint64 timestamp) = getAssetPrice(redeemedAsset, constants._oracleAddress);\\n        require((timestamp + constants.priceOverdue) > block.timestamp, \\\"E9\\\"); //Price is outdated\\n\\n        reimburseLiquidator(\\n            amount,\\n            price,\\n            liquidator,\\n            assetBalances,\\n            constants.liquidationPremium,\\n            constants.user,\\n            constants._orionTokenAddress\\n        );\\n\\n        Position memory finalPosition = calcPosition(collateralAssets,\\n            liabilities,\\n            assetBalances,\\n            assetRisks,\\n            constants);\\n        require( int(finalPosition.state)<3 && //POSITIVE,NEGATIVE or OVERDUE\\n            (finalPosition.weightedPosition>initialPosition.weightedPosition),\\n            \\\"E10\\\");//Incorrect state position after liquidation\\n        if(finalPosition.state == PositionState.POSITIVE)\\n            require (finalPosition.weightedPosition<10e8,\\\"Can not liquidate to very positive state\\\");\\n\\n    }\\n\\n    /**\\n     * @dev reimburse liquidator with ORN: first from stake, than from broker balance\\n     */\\n    function reimburseLiquidator(\\n        uint112 amount,\\n        uint64 price,\\n        address liquidator,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        uint8 liquidationPremium,\\n        address user,\\n        address orionTokenAddress\\n    ) internal {\\n        int192 _orionAmount = int192(int256(amount)*price/1e8);\\n        _orionAmount += uint8Percent(_orionAmount, liquidationPremium); //Liquidation premium\\n        // There is only 100m Orion tokens, fits i64\\n        require(_orionAmount == int64(_orionAmount), \\\"E11\\\");\\n        int192 onBalanceOrion = assetBalances[user][orionTokenAddress];\\n\\n        require(onBalanceOrion >= _orionAmount, \\\"E10\\\");\\n        assetBalances[user][orionTokenAddress] -= _orionAmount;\\n        assetBalances[liquidator][orionTokenAddress] += _orionAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SafeTransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\n\\nimport \\\"../utils/orionpool/periphery/interfaces/IWETH.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nlibrary SafeTransferHelper {\\n\\n    function safeAutoTransferFrom(address weth, address token, address from, address to, uint value) internal {\\n        if (token == address(0)) {\\n            require(from == address(this), \\\"TransferFrom: this\\\");\\n            IWETH(weth).deposit{value: value}();\\n            assert(IWETH(weth).transfer(to, value));\\n        } else {\\n            if (from == address(this)) {\\n                SafeERC20.safeTransfer(IERC20(token), to, value);\\n            } else {\\n                SafeERC20.safeTransferFrom(IERC20(token), from, to, value);\\n            }\\n        }\\n    }\\n\\n    function safeAutoTransferTo(address weth, address token, address to, uint value) internal {\\n        if (address(this) != to) {\\n            if (token == address(0)) {\\n                IWETH(weth).withdraw(value);\\n                Address.sendValue(payable(to), value);\\n            } else {\\n                SafeERC20.safeTransfer(IERC20(token), to, value);\\n            }\\n        }\\n    }\\n\\n    function safeTransferTokenOrETH(address token, address to, uint value) internal {\\n        if (address(this) != to) {\\n            if (token == address(0)) {\\n                Address.sendValue(payable(to), value);\\n            } else {\\n                SafeERC20.safeTransfer(IERC20(token), to, value);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OrionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./ExchangeStorage.sol\\\";\\n\\nabstract contract OrionVault is ExchangeStorage, OwnableUpgradeSafe {\\n\\n    enum StakePhase{ NOTSTAKED, LOCKED, RELEASING, READYTORELEASE, FROZEN }\\n\\n    struct Stake {\\n        uint64 amount; // 100m ORN in circulation fits uint64\\n        StakePhase phase;\\n        uint64 lastActionTimestamp;\\n    }\\n\\n    uint64 constant releasingDuration = 3600*24;\\n    mapping(address => Stake) private stakingData;\\n\\n    /**\\n     * @dev Returns locked or frozen stake balance only\\n     * @param user address\\n     */\\n    function getLockedStakeBalance(address user) public view returns (uint256) {\\n        return stakingData[user].amount;\\n    }\\n\\n    /**\\n     * @dev Request stake unlock for msg.sender\\n     * @dev If stake phase is LOCKED, that changes phase to RELEASING\\n     * @dev If stake phase is READYTORELEASE, that withdraws stake to balance\\n     * @dev Note, both unlock and withdraw is impossible if user has liabilities\\n     */\\n    function requestReleaseStake() public {\\n        address user = _msgSender();\\n        Stake storage stake = stakingData[user];\\n        assetBalances[user][address(_orionToken)] += stake.amount;\\n        stake.amount = 0;\\n        stake.phase = StakePhase.NOTSTAKED;\\n    }\\n\\n    /**\\n     * @dev Lock some orions from exchange balance sheet\\n     * @param amount orions in 1e-8 units to stake\\n     */\\n    function lockStake(uint64 amount) public {\\n        address user = _msgSender();\\n        require(assetBalances[user][address(_orionToken)]>amount, \\\"E1S\\\");\\n        Stake storage stake = stakingData[user];\\n\\n        assetBalances[user][address(_orionToken)] -= amount;\\n        stake.amount += amount;\\n    }\\n\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PriceOracleDataTypes.sol\\\";\\n\\ninterface PriceOracleInterface is PriceOracleDataTypes {\\n    function assetPrices(address) external view returns (PriceDataOut memory);\\n    function givePrices(address[] calldata assetAddresses) external view returns (PriceDataOut[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracleDataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface PriceOracleDataTypes {\\n    struct PriceDataOut {\\n        uint64 price;\\n        uint64 timestamp;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/utils/orionpool/periphery/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"/**\\nCopied from @openzeppelin/contracts-ethereum-package to update pragma statements\\n */\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n\\n\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/ExchangeStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./libs/MarginalFunctionality.sol\\\";\\n\\n// Base contract which contain state variable of the first version of Exchange\\n// deployed on mainnet. Changes of the state variables should be introduced\\n// not in that contract but down the inheritance chain, to allow safe upgrades\\n// More info about safe upgrades here:\\n// https://blog.openzeppelin.com/the-state-of-smart-contract-upgrades/#upgrade-patterns\\n\\ncontract ExchangeStorage {\\n\\n    //order -> filledAmount\\n    mapping(bytes32 => uint192) public filledAmounts;\\n\\n\\n    // Get user balance by address and asset address\\n    mapping(address => mapping(address => int192)) internal assetBalances;\\n    // List of assets with negative balance for each user\\n    mapping(address => MarginalFunctionality.Liability[]) public liabilities;\\n    // List of assets which can be used as collateral and risk coefficients for them\\n    address[] internal collateralAssets;\\n    mapping(address => uint8) public assetRisks;\\n    // Risk coefficient for locked ORN\\n    uint8 public stakeRisk;\\n    // Liquidation premium\\n    uint8 public liquidationPremium;\\n    // Delays after which price and position become outdated\\n    uint64 public priceOverdue;\\n    uint64 public positionOverdue;\\n\\n    // Base orion tokens (can be locked on stake)\\n    IERC20 _orionToken;\\n    // Address of price oracle contract\\n    address _oracleAddress;\\n    // Address from which matching of orders is allowed\\n    address _allowedMatcher;\\n\\n}\\n\\n\"\r\n    },\r\n    \"contracts/utils/Context.sol\": {\r\n      \"content\": \"/**\\nCopied from @openzeppelin/contracts-ethereum-package to update pragma statements\\n */\\n\\npragma solidity ^0.7.0;\\nimport \\\"./Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Initializable.sol\": {\r\n      \"content\": \"/**\\nCopied from @openzeppelin/contracts-ethereum-package to update pragma statements\\n */\\n\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libs/LibAtomic.sol\": {\r\n        \"LibAtomic\": \"0xafcf7c5d91aea4b3261eff5049198d6bdf06ea7e\"\r\n      },\r\n      \"contracts/libs/LibPool.sol\": {\r\n        \"LibPool\": \"0x22bcbd2424eeb4f1889361ccb62701819746e39d\"\r\n      },\r\n      \"contracts/libs/LibValidator.sol\": {\r\n        \"LibValidator\": \"0xce101ac2373815b171b7c7c38d698261f20f75d6\"\r\n      },\r\n      \"contracts/libs/MarginalFunctionality.sol\": {\r\n        \"MarginalFunctionality\": \"0x9a60bcbe43b37e076c16889bfdc82dd13b014b31\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"secret\",\"type\":\"bytes\"}],\"name\":\"AtomicClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"AtomicLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"secret\",\"type\":\"bytes\"}],\"name\":\"AtomicRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"AtomicRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDeposit\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"NewAssetTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"filledPrice\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"filledAmount\",\"type\":\"uint192\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"amountQuote\",\"type\":\"uint192\"}],\"name\":\"NewTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_orionpoolRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetRisks\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"atomicSwaps\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"used\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calcPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"enum MarginalFunctionality.PositionState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"weightedPosition\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"totalPosition\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"totalLiabilities\",\"type\":\"int256\"}],\"internalType\":\"struct MarginalFunctionality.Position\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkPosition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"secret\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"matcherSignature\",\"type\":\"bytes\"}],\"name\":\"claimAtomic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"}],\"name\":\"depositAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherFeeAsset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"matcherFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"buySide\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isPersonalSign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibValidator.Order\",\"name\":\"buyOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherFeeAsset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"matcherFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"buySide\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isPersonalSign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibValidator.Order\",\"name\":\"sellOrder\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"filledPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint112\",\"name\":\"filledAmount\",\"type\":\"uint112\"}],\"name\":\"fillOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherFeeAsset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"matcherFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"buySide\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isPersonalSign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibValidator.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint112\",\"name\":\"filledAmount\",\"type\":\"uint112\"},{\"internalType\":\"uint64\",\"name\":\"blockchainFee\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"fillThroughOrionPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filledAmounts\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"int192\",\"name\":\"\",\"type\":\"int192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetsAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"int192[]\",\"name\":\"balances\",\"type\":\"int192[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherFeeAsset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"matcherFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"buySide\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isPersonalSign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibValidator.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getFilledAmounts\",\"outputs\":[{\"internalType\":\"int192\",\"name\":\"totalFilled\",\"type\":\"int192\"},{\"internalType\":\"int192\",\"name\":\"totalFeesPaid\",\"type\":\"int192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLiabilities\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"outstandingAmount\",\"type\":\"uint192\"}],\"internalType\":\"struct MarginalFunctionality.Liability[]\",\"name\":\"liabilitiesArray\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLockedStakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherFeeAsset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"matcherFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"buySide\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isPersonalSign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibValidator.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liabilities\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"outstandingAmount\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationPremium\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"used\",\"type\":\"bool\"}],\"internalType\":\"struct LibAtomic.LockOrder\",\"name\":\"swap\",\"type\":\"tuple\"}],\"name\":\"lockAtomic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"}],\"name\":\"lockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"broker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"redeemedAsset\",\"type\":\"address\"},{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"}],\"name\":\"partiallyLiquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionOverdue\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOverdue\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibAtomic.RedeemOrder\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"secret\",\"type\":\"bytes\"}],\"name\":\"redeemAtomic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"refundAtomic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestReleaseStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeAutoTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"secrets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"secret\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"orionToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceOracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowedMatcher\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"orionpoolRouter\",\"type\":\"address\"}],\"name\":\"setBasicParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeRisk\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint112\",\"name\":\"amount_spend\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"amount_receive\",\"type\":\"uint112\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"is_exact_spend\",\"type\":\"bool\"}],\"name\":\"swapThroughOrionPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"risks\",\"type\":\"uint8[]\"}],\"name\":\"updateAssetRisks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_collateralAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"_stakeRisk\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_liquidationPremium\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_priceOverdue\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_positionOverdue\",\"type\":\"uint64\"}],\"name\":\"updateMarginalSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"matcherFeeAsset\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"matcherFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"buySide\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isPersonalSign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibValidator.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"validateOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ExchangeWithAtomic","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}