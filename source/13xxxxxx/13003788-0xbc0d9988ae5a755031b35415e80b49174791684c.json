{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../initializable/Initializable.sol\\\";\\n\\nimport \\\"./IACLOracle.sol\\\";\\n\\nlibrary ACLData {\\n    enum BulkOp { Grant, Revoke, Freeze }\\n\\n    struct BulkItem {\\n        BulkOp op;\\n        bytes4 role;\\n        address who;\\n    }\\n}\\n\\ncontract ACL is Initializable {\\n    bytes4 public constant ROOT_ROLE =\\n        this.grant.selector\\n        ^ this.revoke.selector\\n        ^ this.freeze.selector\\n        ^ this.bulk.selector\\n    ;\\n\\n    // \\\"Who\\\" constants\\n    address internal constant ANY_ADDR = address(-1);\\n\\n    // \\\"Access\\\" flags\\n    address internal constant UNSET_ROLE = address(0);\\n    address internal constant FREEZE_FLAG = address(1); // Also used as \\\"who\\\"\\n    address internal constant ALLOW_FLAG = address(2);\\n\\n    // Role -> Who -> Access flag (unset or allow) or ACLOracle (any other address denominates auth via ACLOracle)\\n    mapping (bytes4 => mapping (address => address)) public roles;\\n\\n    event Granted(bytes4 indexed role, address indexed actor, address indexed who, IACLOracle oracle);\\n    event Revoked(bytes4 indexed role, address indexed actor, address indexed who);\\n    event Frozen(bytes4 indexed role, address indexed actor);\\n\\n    modifier auth(bytes4 _role) {\\n        require(willPerform(_role, msg.sender, msg.data), \\\"acl: auth\\\");\\n        _;\\n    }\\n\\n    modifier initACL(address _initialRoot) {\\n        // ACL might have been already initialized by constructors\\n        if (initBlocks[\\\"acl\\\"] == 0) {\\n            _initializeACL(_initialRoot);\\n        } else {\\n            require(roles[ROOT_ROLE][_initialRoot] == ALLOW_FLAG, \\\"acl: initial root misaligned\\\");\\n        }\\n        _;\\n    }\\n\\n    constructor(address _initialRoot) public initACL(_initialRoot) { }\\n\\n    function grant(bytes4 _role, address _who) external auth(ROOT_ROLE) {\\n        _grant(_role, _who);\\n    }\\n\\n    function grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) external auth(ROOT_ROLE) {\\n        _grantWithOracle(_role, _who, _oracle);\\n    }\\n\\n    function revoke(bytes4 _role, address _who) external auth(ROOT_ROLE) {\\n        _revoke(_role, _who);\\n    }\\n\\n    function freeze(bytes4 _role) external auth(ROOT_ROLE) {\\n        _freeze(_role);\\n    }\\n\\n    function bulk(ACLData.BulkItem[] calldata items) external auth(ROOT_ROLE) {\\n        for (uint256 i = 0; i < items.length; i++) {\\n            ACLData.BulkItem memory item = items[i];\\n\\n            if (item.op == ACLData.BulkOp.Grant) _grant(item.role, item.who);\\n            else if (item.op == ACLData.BulkOp.Revoke) _revoke(item.role, item.who);\\n            else if (item.op == ACLData.BulkOp.Freeze) _freeze(item.role);\\n        }\\n    }\\n\\n    function willPerform(bytes4 _role, address _who, bytes memory _data) internal returns (bool) {\\n        // First check if the given who is auth'd, then if any address is auth'd\\n        return _checkRole(_role, _who, _data) || _checkRole(_role, ANY_ADDR, _data);\\n    }\\n\\n    function isFrozen(bytes4 _role) public view returns (bool) {\\n        return roles[_role][FREEZE_FLAG] == FREEZE_FLAG;\\n    }\\n\\n    function _initializeACL(address _initialRoot) internal onlyInit(\\\"acl\\\") {\\n        _grant(ROOT_ROLE, _initialRoot);\\n    }\\n\\n    function _grant(bytes4 _role, address _who) internal {\\n        _grantWithOracle(_role, _who, IACLOracle(ALLOW_FLAG));\\n    }\\n\\n    function _grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n        require(_who != FREEZE_FLAG, \\\"acl: bad freeze\\\");\\n\\n        roles[_role][_who] = address(_oracle);\\n        emit Granted(_role, msg.sender, _who, _oracle);\\n    }\\n\\n    function _revoke(bytes4 _role, address _who) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n\\n        roles[_role][_who] = UNSET_ROLE;\\n        emit Revoked(_role, msg.sender, _who);\\n    }\\n\\n    function _freeze(bytes4 _role) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n\\n        roles[_role][FREEZE_FLAG] = FREEZE_FLAG;\\n        emit Frozen(_role, msg.sender);\\n    }\\n\\n    function _checkRole(bytes4 _role, address _who, bytes memory _data) internal returns (bool) {\\n        address accessFlagOrAclOracle = roles[_role][_who];\\n        if (accessFlagOrAclOracle != UNSET_ROLE) {\\n            if (accessFlagOrAclOracle == ALLOW_FLAG) return true;\\n\\n            // Since it's not a flag, assume it's an ACLOracle and try-catch to skip failures\\n            try IACLOracle(accessFlagOrAclOracle).willPerform(_role, _who, _data) returns (bool allowed) {\\n                if (allowed) return true;\\n            } catch { }\\n        }\\n\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/acl/IACLOracle.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\ninterface IACLOracle {\\n    function willPerform(bytes4 role, address who, bytes calldata data) external returns (bool allowed);\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nlibrary AddressUtils {\\n    \\n    function toPayable(address addr) internal pure returns (address payable) {\\n        return address(bytes20(addr));\\n    }\\n\\n    /**\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     */\\n    function isContract(address addr) internal view returns (bool result) {\\n        assembly {\\n            result := iszero(iszero(extcodesize(addr)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/erc20/ERC20.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface ERC20 {\\n    // Optional fields \\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address _who) external view returns (uint256);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// From https://github.com/aragon/aragonOS/blob/next/contracts/common/SafeERC20.sol\\n\\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"../address-utils/AddressUtils.sol\\\";\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\\n        private\\n        returns (bool ret)\\n    {\\n        if (!_addr.isContract()) {\\n            return false;\\n        }\\n\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            let success := call(\\n                gas(),                // forward all\\n                _addr,                // address\\n                0,                    // no value\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                // Check number of bytes returned from last function call\\n                switch returndatasize()\\n\\n                // No bytes returned: assume success\\n                case 0 {\\n                    ret := 1\\n                }\\n\\n                // 32 bytes returned: check if non-zero\\n                case 0x20 {\\n                    // Only return success if returned data was true\\n                    // Already have output in ptr\\n                    ret := iszero(iszero(mload(ptr)))\\n                }\\n\\n                // Not sure what was returned: don't mark as success\\n                default { }\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferCallData = abi.encodeWithSelector(\\n            _token.transfer.selector,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), transferCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferFromCallData = abi.encodeWithSelector(\\n            _token.transferFrom.selector,\\n            _from,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\\n        bytes memory approveCallData = abi.encodeWithSelector(\\n            _token.approve.selector,\\n            _spender,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), approveCallData);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity 0.6.8;\\n\\ncontract Initializable {\\n    mapping (string => uint256) public initBlocks;\\n\\n    event Initialized(string indexed key);\\n\\n    modifier onlyInit(string memory key) {\\n        require(initBlocks[key] == 0, \\\"initializable: already initialized\\\");\\n        initBlocks[key] = block.number;\\n        _;\\n        emit Initialized(key);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// Inspired by: https://github.com/optionality/clone-factory\\n\\npragma solidity ^0.6.8;\\n\\nlibrary ERC1167ProxyFactory {\\n    function clone(address _implementation) internal returns (address cloneAddr) {\\n        bytes memory createData = generateCreateData(_implementation);\\n\\n        assembly {\\n            cloneAddr := create(0, add(createData, 0x20), 55)\\n        }\\n\\n        require(cloneAddr != address(0), \\\"proxy-factory: bad create\\\");\\n    }\\n\\n    function clone(address _implementation, bytes memory _initData) internal returns (address cloneAddr) {\\n        cloneAddr = clone(_implementation);\\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\\n\\n        require(ok, _getRevertMsg(ret));\\n    }\\n\\n    function clone2(address _implementation, bytes32 _salt) internal returns (address cloneAddr) {\\n        bytes memory createData = generateCreateData(_implementation);\\n\\n        assembly {\\n            cloneAddr := create2(0, add(createData, 0x20), 55, _salt)\\n        }\\n\\n        require(cloneAddr != address(0), \\\"proxy-factory: bad create2\\\");\\n    }\\n\\n    function clone2(address _implementation, bytes32 _salt, bytes memory _initData) internal returns (address cloneAddr) {\\n        cloneAddr = clone2(_implementation, _salt);\\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\\n\\n        require(ok, _getRevertMsg(ret));\\n    }\\n\\n    function generateCreateData(address _implementation) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\n            //---- constructor -----\\n            bytes10(0x3d602d80600a3d3981f3),\\n            //---- proxy code -----\\n            bytes10(0x363d3d373d3d3d363d73),\\n            _implementation,\\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\\n        );\\n    }\\n\\n    // From: https://ethereum.stackexchange.com/a/83577\\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return '';\\n\\n        assembly {\\n            _returnData := add(_returnData, 0x04) // Slice the sighash.\\n        }\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/safe-math/SafeMath.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\n\\n// A library for performing overflow-safe math, courtesy of DappHub: https://github.com/dapphub/ds-math/blob/d0ef6d6a5f/src/math.sol\\n// Modified to include only the essentials\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"math: overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"math: underflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-token/contracts/GovernMinter.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/acl/ACL.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\\\";\\n\\nimport \\\"./GovernToken.sol\\\";\\nimport \\\"./MerkleDistributor.sol\\\";\\n\\ncontract GovernMinter is ACL {\\n    using ERC1167ProxyFactory for address;\\n\\n    bytes4 constant internal MINT_ROLE =\\n        this.mint.selector ^\\n        this.merkleMint.selector\\n    ;\\n\\n    GovernToken public token;\\n    address public distributorBase;\\n\\n    event MintedSingle(address indexed to, uint256 amount, bytes context);\\n    event MintedMerkle(address indexed distributor, bytes32 indexed merkleRoot, uint256 totalAmount, bytes tree, bytes context);\\n\\n    constructor(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) ACL(_initialMinter) public {\\n        initialize(_token, _initialMinter, _distributorBase);\\n    }\\n\\n    function initialize(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) public initACL(_initialMinter) onlyInit(\\\"minter\\\") {\\n        token = _token;\\n        distributorBase = address(_distributorBase);\\n        _grant(MINT_ROLE, _initialMinter);\\n    }\\n\\n    function mint(address _to, uint256 _amount, bytes calldata _context) external auth(MINT_ROLE) {\\n        token.mint(_to, _amount);\\n        emit MintedSingle(_to, _amount, _context);\\n    }\\n\\n    function merkleMint(bytes32 _merkleRoot, uint256 _totalAmount, bytes calldata _tree, bytes calldata _context) external auth(MINT_ROLE) returns (MerkleDistributor distributor) {\\n        address distributorAddr = distributorBase.clone(abi.encodeWithSelector(distributor.initialize.selector, token, _merkleRoot));\\n        token.mint(distributorAddr, _totalAmount);\\n\\n        emit MintedMerkle(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\\n\\n        return MerkleDistributor(distributorAddr);\\n    }\\n\\n    function eject(address _newMinter) external auth(this.eject.selector) {\\n        token.changeMinter(_newMinter);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-token/contracts/GovernToken.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\n\\nimport '@aragon/govern-contract-utils/contracts/initializable/Initializable.sol';\\nimport '@aragon/govern-contract-utils/contracts/safe-math/SafeMath.sol';\\n\\nimport './interfaces/IERC20.sol';\\n\\n// Copied and slightly modified from https://github.com/aragon/aragon-network-token/blob/v2-v1.0.0/packages/v2/contracts/token.sol\\n// Lightweight token modelled after UNI-LP: https://github.com/Uniswap/uniswap-v2-core/blob/v1.0.1/contracts/UniswapV2ERC20.sol\\n// Adds:\\n//   - An exposed `mint()` with minting role\\n//   - An exposed `burn()`\\n//   - ERC-3009 (`transferWithAuthorization()`)\\ncontract GovernToken is IERC20, Initializable {\\n    using SafeMath for uint256;\\n\\n    // bytes32 private constant EIP712DOMAIN_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    // bytes32 private constant VERSION_HASH = keccak256(\\\"1\\\")\\n    bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\\n    //     keccak256(\\\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\");\\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    address public minter;\\n    uint256 override public totalSupply;\\n    mapping (address => uint256) override public balanceOf;\\n    mapping (address => mapping (address => uint256)) override public allowance;\\n\\n    // ERC-2612, ERC-3009 state\\n    mapping (address => uint256) public nonces;\\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n    event ChangeMinter(address indexed minter);\\n\\n    modifier onlyMinter {\\n        require(msg.sender == minter, \\\"token: not minter\\\");\\n        _;\\n    }\\n\\n    constructor(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public {\\n        initialize(_initialMinter, _name, _symbol, _decimals);\\n    }\\n\\n    function initialize(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public onlyInit(\\\"token\\\") {\\n        _changeMinter(_initialMinter);\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                getDomainSeparator(),\\n                encodeData\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \\\"token: bad sig\\\");\\n    }\\n\\n    function _changeMinter(address newMinter) internal {\\n        minter = newMinter;\\n        emit ChangeMinter(newMinter);\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        // Balance is implicitly checked with SafeMath's underflow protection\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) private {\\n        require(to != address(this) && to != address(0), \\\"token: bad to\\\");\\n\\n        // Balance is implicitly checked with SafeMath's underflow protection\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function getChainId() public pure returns (uint256 chainId) {\\n        assembly { chainId := chainid() }\\n    }\\n\\n    function getDomainSeparator() public view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                EIP712DOMAIN_HASH,\\n                keccak256(abi.encodePacked(name)),\\n                VERSION_HASH,\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function mint(address to, uint256 value) external onlyMinter returns (bool) {\\n        _mint(to, value);\\n        return true;\\n    }\\n\\n    function changeMinter(address newMinter) external onlyMinter {\\n        _changeMinter(newMinter);\\n    }\\n\\n    function burn(uint256 value) external returns (bool) {\\n        _burn(msg.sender, value);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) override external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) override external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) override external returns (bool) {\\n        uint256 fromAllowance = allowance[from][msg.sender];\\n        if (fromAllowance != uint256(-1)) {\\n            // Allowance is implicitly checked with SafeMath's underflow protection\\n            allowance[from][msg.sender] = fromAllowance.sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(deadline >= block.timestamp, \\\"token: auth expired\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\\n        _validateSignedData(owner, encodeData, v, r, s);\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n    {\\n        require(block.timestamp > validAfter, \\\"token: auth wait\\\");\\n        require(block.timestamp < validBefore, \\\"token: auth expired\\\");\\n        require(!authorizationState[from][nonce],  \\\"token: auth used\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\\n        _validateSignedData(from, encodeData, v, r, s);\\n\\n        authorizationState[from][nonce] = true;\\n        emit AuthorizationUsed(from, nonce);\\n\\n        _transfer(from, to, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-token/contracts/GovernTokenFactory.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\\\";\\nimport \\\"./libraries/TokenLib.sol\\\";\\n\\nimport \\\"erc3k/contracts/IERC3000Executor.sol\\\";\\n\\nimport \\\"./GovernToken.sol\\\";\\nimport \\\"./GovernMinter.sol\\\";\\nimport \\\"./MerkleDistributor.sol\\\";\\n\\ncontract GovernTokenFactory {\\n    using ERC1167ProxyFactory for address;\\n    \\n    address public tokenBase;\\n    address public minterBase;\\n    address public distributorBase;\\n\\n    event CreatedToken(GovernToken token, GovernMinter minter);\\n\\n    constructor() public {\\n        setupBases();\\n    }\\n\\n    function newToken(\\n        IERC3000Executor _governExecutor,\\n        TokenLib.TokenConfig calldata _token,\\n        bool _useProxies\\n    ) external returns (\\n        GovernToken token,\\n        GovernMinter minter\\n    ) {\\n        if (!_useProxies) {\\n            (token, minter) = _deployContracts(_token.tokenName, _token.tokenSymbol, _token.tokenDecimals);\\n        } else {\\n            token = GovernToken(tokenBase.clone(abi.encodeWithSelector(\\n                token.initialize.selector,\\n                address(this),\\n                _token.tokenName,\\n                _token.tokenSymbol,\\n                _token.tokenDecimals\\n            ))); \\n            minter = GovernMinter(minterBase.clone(abi.encodeWithSelector(\\n                minter.initialize.selector,\\n                token,\\n                address(this),\\n                MerkleDistributor(distributorBase)\\n            )));\\n        }\\n\\n        token.changeMinter(address(minter));\\n        \\n        if (_token.mintAmount > 0) {\\n            minter.mint(_token.mintAddress, _token.mintAmount, \\\"initial mint\\\");\\n        }\\n\\n        if (_token.merkleRoot != bytes32(0)) {\\n            minter.merkleMint(_token.merkleRoot, _token.merkleMintAmount, _token.merkleTree, _token.merkleContext);\\n        }\\n\\n        bytes4 mintRole = minter.mint.selector ^ minter.merkleMint.selector;\\n        bytes4 rootRole = minter.ROOT_ROLE();\\n\\n        ACLData.BulkItem[] memory items = new ACLData.BulkItem[](4);\\n\\n        items[0] = ACLData.BulkItem(ACLData.BulkOp.Grant, mintRole, address(_governExecutor));\\n        items[1] = ACLData.BulkItem(ACLData.BulkOp.Grant, rootRole, address(_governExecutor));\\n        items[2] = ACLData.BulkItem(ACLData.BulkOp.Revoke, mintRole, address(this));\\n        items[3] = ACLData.BulkItem(ACLData.BulkOp.Revoke, rootRole, address(this));\\n\\n        minter.bulk(items);\\n\\n        emit CreatedToken(token, minter);\\n    }\\n\\n    function setupBases() private {\\n        distributorBase = address(new MerkleDistributor(ERC20(tokenBase), bytes32(0)));\\n        \\n        (GovernToken token, GovernMinter minter) = _deployContracts(\\n            \\\"GovernToken base\\\",\\n            \\\"GTB\\\",\\n            0\\n        );\\n        token.changeMinter(address(minter));\\n\\n        // test the bases\\n        minter.mint(msg.sender, 1, \\\"test mint\\\");\\n        minter.merkleMint(bytes32(0), 1, \\\"no tree\\\", \\\"test merkle mint\\\");\\n\\n        // store bases\\n        tokenBase = address(token);\\n        minterBase = address(minter);\\n    }\\n\\n    function _deployContracts(\\n        string memory _tokenName,\\n        string memory _tokenSymbol,\\n        uint8 _tokenDecimals\\n    ) internal returns (\\n        GovernToken token,\\n        GovernMinter minter\\n    ) {\\n        token = new GovernToken(address(this), _tokenName, _tokenSymbol, _tokenDecimals);\\n        minter = new GovernMinter(GovernToken(token), address(this), MerkleDistributor(distributorBase));\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-token/contracts/MerkleDistributor.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\n// Copied and modified from: https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\\\";\\n\\ncontract MerkleDistributor is Initializable {\\n    \\n    using SafeERC20 for ERC20;\\n\\n    ERC20 public token;\\n    bytes32 public merkleRoot;\\n\\n    // This is a packed array of booleans.\\n    mapping (uint256 => uint256) private claimedBitMap;\\n\\n    event Claimed(uint256 indexed index, address indexed to, uint256 amount);\\n\\n    constructor(ERC20 _token, bytes32 _merkleRoot) public {\\n        initialize(_token, _merkleRoot);\\n    }\\n\\n    function initialize(ERC20 _token, bytes32 _merkleRoot) public onlyInit(\\\"distributor\\\") {\\n        token = _token;\\n        merkleRoot = _merkleRoot;\\n    }\\n\\n    function claim(uint256 _index, address _to, uint256 _amount, bytes32[] calldata _merkleProof) external {\\n        require(!isClaimed(_index), \\\"dist: already claimed\\\");\\n        require(_verifyBalanceOnTree(_index, _to, _amount, _merkleProof), \\\"dist: proof failed\\\");\\n\\n        _setClaimed(_index);\\n        token.safeTransfer(_to, _amount);\\n\\n        emit Claimed(_index, _to, _amount);\\n    }\\n\\n    function unclaimedBalance(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) public view returns (uint256) {\\n        if (isClaimed(_index)) return 0;\\n        return _verifyBalanceOnTree(_index, _to, _amount, _proof) ? _amount : 0;\\n    }\\n\\n    function _verifyBalanceOnTree(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) internal view returns (bool) {\\n        bytes32 node = keccak256(abi.encodePacked(_index, _to, _amount));\\n        return MerkleProof.verify(_proof, merkleRoot, node);\\n    }\\n\\n    function isClaimed(uint256 _index) public view returns (bool) {\\n        uint256 claimedWord_index = _index / 256;\\n        uint256 claimedBit_index = _index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWord_index];\\n        uint256 mask = (1 << claimedBit_index);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    function _setClaimed(uint256 _index) private {\\n        uint256 claimedWord_index = _index / 256;\\n        uint256 claimedBit_index = _index % 256;\\n        claimedBitMap[claimedWord_index] = claimedBitMap[claimedWord_index] | (1 << claimedBit_index);\\n    }\\n}\"\r\n    },\r\n    \"@aragon/govern-token/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-token/contracts/libraries/TokenLib.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary TokenLib {\\n    \\n    struct TokenConfig {\\n        IERC20 tokenAddress;\\n        uint8  tokenDecimals;\\n        string tokenName;\\n        string tokenSymbol;\\n        address mintAddress; // initial minter address\\n        uint256 mintAmount; // how much to mint to initial minter address\\n        // merkle settings\\n        bytes32 merkleRoot; // merkle distribution root.\\n        uint256 merkleMintAmount; // how much to mint for the distributor.\\n        bytes merkleTree; // merkle tree object\\n        bytes merkleContext; // context/string what's the actual reason is...\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/ERC3000Data.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IERC3000Executor.sol\\\";\\n\\nlibrary ERC3000Data {\\n    // TODO: come up with a non-shitty name\\n    struct Container {\\n        Payload payload;\\n        Config config;\\n    }\\n\\n    // WARN: Always remember to change the 'hash' function if modifying the struct\\n    struct Payload {\\n        uint256 nonce;\\n        uint256 executionTime;\\n        address submitter;\\n        IERC3000Executor executor;\\n        Action[] actions;\\n        bytes32 allowFailuresMap;\\n        bytes proof;\\n    }\\n\\n    struct Action {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    struct Config {\\n        uint256 executionDelay; // how many seconds to wait before being able to call `execute`.\\n        Collateral scheduleDeposit; // fees for scheduling\\n        Collateral challengeDeposit; // fees for challenging\\n        address resolver;  // resolver that will rule the disputes\\n        bytes rules; // rules of how DAO should be managed\\n        uint256 maxCalldataSize; // max calldatasize for the schedule\\n    }\\n\\n    struct Collateral {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function containerHash(bytes32 payloadHash, bytes32 configHash) internal view returns (bytes32) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        return keccak256(abi.encodePacked(\\\"erc3k-v1\\\", address(this), chainId, payloadHash, configHash));\\n    }\\n\\n    function hash(Container memory container) internal view returns (bytes32) {\\n        return containerHash(hash(container.payload), hash(container.config));\\n    }\\n\\n    function hash(Payload memory payload) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                payload.nonce,\\n                payload.executionTime,\\n                payload.submitter,\\n                payload.executor,\\n                keccak256(abi.encode(payload.actions)),\\n                payload.allowFailuresMap,\\n                keccak256(payload.proof)\\n            )\\n        );\\n    }\\n\\n    function hash(Config memory config) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(config));\\n    }\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/IERC3000Executor.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC3000Data.sol\\\";\\n\\nabstract contract IERC3000Executor {\\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\\n\\n    /**\\n     * @notice Executes all given actions\\n     * @param actions A array of ERC3000Data.Action for later executing those\\n     * @param allowFailuresMap A map with the allowed failures\\n     * @param memo The hash of the ERC3000Data.Container\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes32 memo, bytes32 failureMap, bytes[] execResults);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract GovernToken\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract GovernMinter\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"CreatedToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"distributorBase\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterBase\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3000Executor\",\"name\":\"_governExecutor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"mintAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"merkleMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"merkleTree\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"merkleContext\",\"type\":\"bytes\"}],\"internalType\":\"struct TokenLib.TokenConfig\",\"name\":\"_token\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_useProxies\",\"type\":\"bool\"}],\"name\":\"newToken\",\"outputs\":[{\"internalType\":\"contract GovernToken\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract GovernMinter\",\"name\":\"minter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBase\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GovernTokenFactory","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}