{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface Erc20 {\r\n\tfunction transfer(address, uint256) external returns (bool);\r\n\tfunction balanceOf(address) external returns (uint256);\r\n\tfunction transferFrom(address, address, uint256) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n  /// @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree defined by `root`.\r\n  /// For this, a `proof` must be provided, containing sibling hashes on the branch from the leaf to the root of the \r\n  /// tree. Each pair of leaves and each pair of pre-images are assumed to be sorted.\r\n  /// @param p Array of merkle proofs\r\n  /// @param r Merkle root\r\n  /// @param l Candidate 'leaf' of the merkle tree\r\n  function verify(bytes32[] memory p, bytes32 r, bytes32 l) internal pure returns (bool) {\r\n    uint256 len = p.length;\r\n    bytes32 hash = l;\r\n\r\n    for (uint256 i = 0; i < len; i++) {\r\n      bytes32 element = p[i];\r\n\r\n      if (hash <= element) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        hash = keccak256(abi.encodePacked(hash, element));\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        hash = keccak256(abi.encodePacked(element, hash));\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return hash == r;\r\n  }\r\n}\r\n\r\ncontract Destributor {\r\n  mapping (uint256 => bytes32) public merkleRoot;\r\n  mapping (uint256 => mapping (uint256 => uint256)) private claims;\r\n  mapping (uint256 => bool) private cancelled;\r\n\r\n  uint256 public distribution;\r\n\r\n  address public immutable token;\r\n  address public admin;\r\n  bool public paused;\r\n\r\n  event Distribute(bytes32 merkleRoot, uint256 distribution);\r\n  event Claim(uint256 index, address owner, uint256 amount);\r\n\r\n  /// @param t Address of an ERC20 token\r\n  /// @param r Initial merkle root\r\n  constructor(address t, bytes32 r) {\r\n    admin = msg.sender;\r\n    token = t;\r\n    merkleRoot[0] = r;\r\n  }\r\n\r\n  /// @notice Generate a new distribution, cancelling the would be current one\r\n  /// @param f The address of the wallet containing tokens to distribute\r\n  /// @param t The address that will receive any currently remaining distributions (will normally be the same as from)\r\n  /// @param a The amount of tokens in the new distribution\r\n  /// @param r The merkle root associated with the new distribution\r\n  function distribute(address f, address t, uint256 a, bytes32 r) external authorized(admin) returns (bool) {\r\n    // remove curent token balance\r\n    Erc20 erc = Erc20(token);\r\n    uint256 balance = erc.balanceOf(address(this));\r\n    erc.transfer(t, balance);\r\n        \r\n    // transfer enough tokens for new distribution\r\n    erc.transferFrom(f, address(this), a);\r\n\r\n    // we are working with the distribution, eventually bumping it...\r\n    uint256 current = distribution;\r\n        \r\n    // cancel the (to-be) previous distribution\r\n    cancelled[current] = true;\r\n\r\n    current++;\r\n    // add the new distribution's merkleRoot\r\n    merkleRoot[current] = r;\r\n\r\n    distribution = current;\r\n\r\n    // unpause redemptions\r\n    pause(false);\r\n\r\n    emit Distribute(r, current);        \r\n\r\n    return true;\r\n  }\r\n\r\n  /// @param i An index which to construct a possible claim from\r\n  /// @param d The distribution to check for a claim\r\n  function claimed(uint256 i, uint256 d) public view returns (bool) {\r\n    require(i > 0, 'passed index must be > 0');\r\n\r\n    uint256 wordIndex = i / 256;\r\n    uint256 bitIndex = i % 256;\r\n    uint256 word = claims[d][wordIndex];\r\n    uint256 mask = (1 << bitIndex);\r\n\r\n    return word & mask == mask;\r\n  }\r\n\r\n  /// @param i An index which to construct a claim from\r\n  /// @param o Owner address of the token being transferred\r\n  /// @param a Amount being transferred\r\n  /// @param p array of merkle proofs\r\n  function claim(uint256 i, address o, uint256 a, bytes32[] calldata p) external returns (bool) {\r\n    require(!paused, 'claiming is paused');\r\n    require(!claimed(i, distribution), 'distribution claimed');\r\n    require(!cancelled[distribution], 'distribution cancelled');\r\n\r\n    // Verify the merkle proof...\r\n    bytes32 node = keccak256(abi.encodePacked(i, o, a));\r\n    require(MerkleProof.verify(p, merkleRoot[distribution], node), 'invalid proof');\r\n\r\n    // Mark it claimed...\r\n    uint256 wordIndex = i / 256;\r\n    uint256 bitIndex = i % 256;\r\n    claims[distribution][wordIndex] = claims[distribution][wordIndex] | (1 << bitIndex);\r\n    \r\n    // send the token...\r\n    require(Erc20(token).transfer(o, a), 'transfer failed.');\r\n\r\n    emit Claim(i, o, a);\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @param a Address of a new admin\r\n  function transferAdmin(address a) external authorized(admin) returns (bool) {\r\n    admin = a;\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @notice Allows admin to pause or unpause claims\r\n  /// @param b Boolean value to set paused to\r\n  function pause(bool b) public authorized(admin) returns (bool) {\r\n    paused = b;\r\n    return true;\r\n  }\r\n\r\n  modifier authorized(address a) {\r\n    require(msg.sender == a, 'sender must be authorized');\r\n    _;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distribution\",\"type\":\"uint256\"}],\"name\":\"Distribute\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"p\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"}],\"name\":\"distribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Destributor","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000bf30461210b37012783957d90dc26b95ce3b6f2d0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4843107ce43bf623ed52096277bc12fadef635253e39b1c07bb3042948ed5a81"}]}