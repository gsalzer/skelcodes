{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"MultiSendPayable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n\\ninterface ISequencer {\\n  function verifySequencer(uint184 id) external returns(bool);\\n}\\n\\n\\n/*\\n * @title payment support for sequencer\\n */\\nabstract contract Payable {\\n    /*\\n     * constants\\n     */\\n    uint8 constant VERSION = 2;\\n    uint184 constant DEFAULT_ID = 0xe7379809afae029d38b76a330a1bdee84f6e03a4979359;\\n    struct Payment {\\n        uint184 relayerId;\\n        uint64 wad;\\n        uint8 version;\\n    }\\n\\n\\n    /*\\n     * storage\\n     */\\n    Payment payment;\\n    ISequencer sequencer;\\n\\n    /*\\n     * functions\\n     */\\n    modifier Payable() {\\n        if (payment.version < VERSION) {\\n            payment.version = VERSION;\\n            payment.wad = 0;\\n            payment.relayerId = DEFAULT_ID;\\n        }\\n\\n        uint used = gasleft();\\n\\n        _;\\n\\n        used = used - gasleft();\\n        unchecked {\\n            payment.wad += uint64(used * tx.gasprice);\\n        }\\n    }\\n\\n\\n    fallback () external Payable {\\n        assembly {\\n          mstore(0, sload(0))\\n          return(0, 32)\\n        }\\n    }\\n\\n\\n    /*\\n     * @notice verify relayer and claim reward\\n     */\\n    function claim() public {\\n        require(payment.version == VERSION, \\\"version\\\");\\n        require(sequencer.verifySequencer(payment.relayerId), \\\"valid relayer\\\");\\n        require(payable(msg.sender).send(payment.wad), \\\"send\\\");\\n        payment.wad = 0;\\n    }\\n}\\n\\n\\n\\n/*\\n * @title Multi Send - Allows to batch multiple transactions into one\\n */\\ncontract MultiSendPayable is Payable {\\n    constructor(ISequencer _sequencer, uint184 _id) {\\n        sequencer = _sequencer;\\n        payment.relayerId = _id;\\n        payment.version = VERSION;\\n    }\\n\\n    /*\\n     * @notice Sends multiple transactions and reverts all if one fails.\\n     * @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\\n     *                     operation has to be uint8(0) in this version (=> 1 byte),\\n     *                     to as a address (=> 20 bytes),\\n     *                     value as a uint256 (=> 32 bytes),\\n     *                     data length as a uint256 (=> 32 bytes),\\n     *                     data as bytes.\\n     *                     see abi.encodePacked for more information on packed encoding\\n     */\\n    function multiSend(bytes memory transactions) public payable Payable {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let length := mload(transactions)\\n            let i := 0x20\\n            for {\\n                // Pre block is not used in \\\"while mode\\\"\\n            } lt(i, length) {\\n                // Post block is not used in \\\"while mode\\\"\\n            } {\\n                // First byte of the data is the operation.\\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\\n                // This will also zero out unused data.\\n                let operation := shr(0xf8, mload(add(transactions, i)))\\n                // We offset the load address by 1 byte (operation byte)\\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\\n                let value := mload(add(transactions, add(i, 0x15)))\\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\\n                let dataLength := mload(add(transactions, add(i, 0x35)))\\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\\n                let data := add(transactions, add(i, 0x55))\\n                let success := 0\\n                switch operation\\n                    case 0 {\\n                        success := call(gas(), to, value, data, dataLength, 0, 0)\\n                    }\\n                    case 1 {\\n                        success := delegatecall(gas(), to, data, dataLength, 0, 0)\\n                    }\\n                if eq(success, 0) {\\n                    revert(0, 0)\\n                }\\n                // Next entry starts at 85 byte + data length\\n                i := add(i, add(0x55, dataLength))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ISequencer\",\"name\":\"_sequencer\",\"type\":\"address\"},{\"internalType\":\"uint184\",\"name\":\"_id\",\"type\":\"uint184\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transactions\",\"type\":\"bytes\"}],\"name\":\"multiSend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"MultiSendPayable","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a57bd00134b2850b2a1c55860c9e9ea100fdd6cf000000000000000000315447c466fc2dbeeef555d65867aa27d8a465a2a314ab","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}