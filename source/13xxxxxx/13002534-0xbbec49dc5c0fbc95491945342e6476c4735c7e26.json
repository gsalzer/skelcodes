{"status":"1","message":"OK","result":[{"SourceCode":"/*\n    ___            _       ___  _                          \n    | .\\ ___  _ _ <_> ___ | __><_>._ _  ___ ._ _  ___  ___ \n    |  _// ._>| '_>| ||___|| _> | || ' |<_> || ' |/ | '/ ._>\n    |_|  \\___.|_|  |_|     |_|  |_||_|_|<___||_|_|\\_|_.\\___.\n    \n* PeriFinance: EtherCollateralpUSD.sol\n*\n* Latest source (may be newer): https://github.com/perifinance/peri-finance/blob/master/contracts/EtherCollateralpUSD.sol\n* Docs: Will be added in the future. \n* https://docs.peri.finance/contracts/source/contracts/EtherCollateralpUSD\n*\n* Contract Dependencies: \n*\t- IAddressResolver\n*\t- IEtherCollateralpUSD\n*\t- MixinResolver\n*\t- Owned\n*\t- Pausable\n*\t- ReentrancyGuard\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2021 PeriFinance\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity 0.5.16;\n\n// https://docs.peri.finance/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// Inheritance\n\n\n// https://docs.peri.finance/contracts/source/contracts/pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    constructor() internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getPynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ipynth\ninterface IPynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferablePynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to PeriFinance\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anyPynthOrPERIRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availablePynthCount() external view returns (uint);\n\n    function availablePynths(uint index) external view returns (IPynth);\n\n    function canBurnPynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function externalTokenLimit() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuablePynths(address issuer) external view returns (uint maxIssuable);\n\n    function externalTokenQuota(\n        address _account,\n        uint _addtionalpUSD,\n        uint _addtionalExToken,\n        bool _isIssue\n    ) external view returns (uint);\n\n    function maxExternalTokenStakeAmount(address _account, bytes32 _currencyKey)\n        external\n        view\n        returns (uint issueAmountToQuota, uint stakeAmountToQuota);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuablePynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function pynths(bytes32 currencyKey) external view returns (IPynth);\n\n    function getPynths(bytes32[] calldata currencyKeys) external view returns (IPynth[] memory);\n\n    function pynthsByAddress(address pynthAddress) external view returns (bytes32);\n\n    function totalIssuedPynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\n\n    function transferablePeriFinanceAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to PeriFinance\n    function issuePynths(\n        address _issuer,\n        bytes32 _currencyKey,\n        uint _issueAmount\n    ) external;\n\n    function issueMaxPynths(address _issuer) external;\n\n    function issuePynthsToMaxQuota(address _issuer, bytes32 _currencyKey) external;\n\n    function burnPynths(\n        address _from,\n        bytes32 _currencyKey,\n        uint _burnAmount\n    ) external;\n\n    function fitToClaimable(address _from) external;\n\n    function exit(address _from) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint pusdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getPynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.pynths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// solhint-disable payable-fallback\n\n// https://docs.peri.finance/contracts/source/contracts/readproxy\ncontract ReadProxy is Owned {\n    address public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(address _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(target);\n    }\n\n    function() external {\n        // The basics of a proxy read call\n        // Note that msg.sender in the underlying will always be the address of this contract.\n        assembly {\n            calldatacopy(0, 0, calldatasize)\n\n            // Use of staticcall - this will revert if the underlying function mutates state\n            let result := staticcall(gas, sload(target_slot), 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n\n            if iszero(result) {\n                revert(0, returndatasize)\n            }\n            return(0, returndatasize)\n        }\n    }\n\n    event TargetUpdated(address newTarget);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iethercollateralsusd\ninterface IEtherCollateralpUSD {\n    // Views\n    function totalIssuedPynths() external view returns (uint256);\n\n    function totalLoansCreated() external view returns (uint256);\n\n    function totalOpenLoanCount() external view returns (uint256);\n\n    // Mutative functions\n    function openLoan(uint256 _loanAmount) external payable returns (uint256 loanID);\n\n    function closeLoan(uint256 loanID) external;\n\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external;\n\n    function depositCollateral(address account, uint256 loanID) external payable;\n\n    function withdrawCollateral(uint256 loanID, uint256 withdrawAmount) external;\n\n    function repayLoan(\n        address _loanCreatorsAddress,\n        uint256 _loanID,\n        uint256 _repayAmount\n    ) external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.peri.finance/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @dev Round down the value with given number\n     */\n    function roundDownDecimal(uint x, uint d) internal pure returns (uint) {\n        return x.div(10**d).mul(10**d);\n    }\n\n    /**\n     * @dev Round up the value with given number\n     */\n    function roundUpDecimal(uint x, uint d) internal pure returns (uint) {\n        uint _decimal = 10**d;\n\n        if (x % _decimal > 0) {\n            x = x.add(10**d);\n        }\n\n        return x.div(_decimal).mul(_decimal);\n    }\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireExchangeBetweenPynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requirePynthActive(bytes32 currencyKey) external view;\n\n    function requirePynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function pynthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function pynthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function getPynthExchangeSuspensions(bytes32[] calldata pynths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getPynthSuspensions(bytes32[] calldata pynths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendPynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    // Restricted: used internally to PeriFinance\n    function appendAccountIssuanceRecord(\n        address account,\n        uint lockedAmount,\n        uint debtEntryIndex\n    ) external;\n\n    function recordFeePaid(uint pUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    struct InversePricing {\n        uint entryPoint;\n        uint upperLimit;\n        uint lowerLimit;\n        bool frozenAtUpperLimit;\n        bool frozenAtLowerLimit;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\n\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint value);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function inversePricing(bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint entryPoint,\n            uint upperLimit,\n            uint lowerLimit,\n            bool frozenAtUpperLimit,\n            bool frozenAtLowerLimit\n        );\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\n        external\n        view\n        returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    // Mutative functions\n    function freezeRate(bytes32 currencyKey) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// ETH Collateral v0.3 (pUSD)\n// https://docs.peri.finance/contracts/source/contracts/ethercollateralsusd\ncontract EtherCollateralpUSD is Owned, Pausable, ReentrancyGuard, MixinResolver, IEtherCollateralpUSD {\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    bytes32 internal constant ETH = \"ETH\";\n\n    // ========== CONSTANTS ==========\n    uint256 internal constant ONE_THOUSAND = 1e18 * 1000;\n    uint256 internal constant ONE_HUNDRED = 1e18 * 100;\n\n    uint256 internal constant SECONDS_IN_A_YEAR = 31536000; // Common Year\n\n    // Where fees are pooled in pUSD.\n    address internal constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    uint256 internal constant ACCOUNT_LOAN_LIMIT_CAP = 1000;\n    bytes32 private constant pUSD = \"pUSD\";\n    bytes32 public constant COLLATERAL = \"ETH\";\n\n    // ========== SETTER STATE VARIABLES ==========\n\n    // The ratio of Collateral to pynths issued\n    uint256 public collateralizationRatio = SafeDecimalMath.unit() * 150;\n\n    // If updated, all outstanding loans will pay this interest rate in on closure of the loan. Default 5%\n    uint256 public interestRate = (5 * SafeDecimalMath.unit()) / 100;\n    uint256 public interestPerSecond = interestRate.div(SECONDS_IN_A_YEAR);\n\n    // Minting fee for issuing the pynths. Default 50 bips.\n    uint256 public issueFeeRate = (5 * SafeDecimalMath.unit()) / 1000;\n\n    // Maximum amount of pUSD that can be issued by the EtherCollateral contract. Default 10MM\n    uint256 public issueLimit = SafeDecimalMath.unit() * 10000000;\n\n    // Minimum amount of ETH to create loan preventing griefing and gas consumption. Min 1ETH\n    uint256 public minLoanCollateralSize = SafeDecimalMath.unit() * 1;\n\n    // Maximum number of loans an account can create\n    uint256 public accountLoanLimit = 50;\n\n    // If true then any wallet addres can close a loan not just the loan creator.\n    bool public loanLiquidationOpen = false;\n\n    // Time when remaining loans can be liquidated\n    uint256 public liquidationDeadline;\n\n    // Liquidation ratio when loans can be liquidated\n    uint256 public liquidationRatio = (150 * SafeDecimalMath.unit()) / 100; // 1.5 ratio\n\n    // Liquidation penalty when loans are liquidated. default 10%\n    uint256 public liquidationPenalty = SafeDecimalMath.unit() / 10;\n\n    // ========== STATE VARIABLES ==========\n\n    // The total number of pynths issued by the collateral in this contract\n    uint256 public totalIssuedPynths;\n\n    // Total number of loans ever created\n    uint256 public totalLoansCreated;\n\n    // Total number of open loans\n    uint256 public totalOpenLoanCount;\n\n    // Pynth loan storage struct\n    struct PynthLoanStruct {\n        //  Acccount that created the loan\n        address payable account;\n        //  Amount (in collateral token ) that they deposited\n        uint256 collateralAmount;\n        //  Amount (in pynths) that they issued to borrow\n        uint256 loanAmount;\n        // Minting Fee\n        uint256 mintingFee;\n        // When the loan was created\n        uint256 timeCreated;\n        // ID for the loan\n        uint256 loanID;\n        // When the loan was paidback (closed)\n        uint256 timeClosed;\n        // Applicable Interest rate\n        uint256 loanInterestRate;\n        // interest amounts accrued\n        uint256 accruedInterest;\n        // last timestamp interest amounts accrued\n        uint40 lastInterestAccrued;\n    }\n\n    // Users Loans by address\n    mapping(address => PynthLoanStruct[]) public accountsPynthLoans;\n\n    // Account Open Loan Counter\n    mapping(address => uint256) public accountOpenLoanCounter;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_PYNTHPUSD = \"PynthpUSD\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n\n    // ========== CONSTRUCTOR ==========\n    constructor(address _owner, address _resolver) public Owned(_owner) Pausable() MixinResolver(_resolver) {\n        liquidationDeadline = block.timestamp + 92 days; // Time before loans can be open for liquidation to end the trial contract\n    }\n\n    // ========== SETTERS ==========\n\n    function setCollateralizationRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= ONE_THOUSAND, \"Too high\");\n        require(ratio >= ONE_HUNDRED, \"Too low\");\n        collateralizationRatio = ratio;\n        emit CollateralizationRatioUpdated(ratio);\n    }\n\n    function setInterestRate(uint256 _interestRate) external onlyOwner {\n        require(_interestRate > SECONDS_IN_A_YEAR, \"Interest rate cannot be less that the SECONDS_IN_A_YEAR\");\n        require(_interestRate <= SafeDecimalMath.unit(), \"Interest cannot be more than 100% APR\");\n        interestRate = _interestRate;\n        interestPerSecond = _interestRate.div(SECONDS_IN_A_YEAR);\n        emit InterestRateUpdated(interestRate);\n    }\n\n    function setIssueFeeRate(uint256 _issueFeeRate) external onlyOwner {\n        issueFeeRate = _issueFeeRate;\n        emit IssueFeeRateUpdated(issueFeeRate);\n    }\n\n    function setIssueLimit(uint256 _issueLimit) external onlyOwner {\n        issueLimit = _issueLimit;\n        emit IssueLimitUpdated(issueLimit);\n    }\n\n    function setMinLoanCollateralSize(uint256 _minLoanCollateralSize) external onlyOwner {\n        minLoanCollateralSize = _minLoanCollateralSize;\n        emit MinLoanCollateralSizeUpdated(minLoanCollateralSize);\n    }\n\n    function setAccountLoanLimit(uint256 _loanLimit) external onlyOwner {\n        require(_loanLimit < ACCOUNT_LOAN_LIMIT_CAP, \"Owner cannot set higher than ACCOUNT_LOAN_LIMIT_CAP\");\n        accountLoanLimit = _loanLimit;\n        emit AccountLoanLimitUpdated(accountLoanLimit);\n    }\n\n    function setLoanLiquidationOpen(bool _loanLiquidationOpen) external onlyOwner {\n        require(block.timestamp > liquidationDeadline, \"Before liquidation deadline\");\n        loanLiquidationOpen = _loanLiquidationOpen;\n        emit LoanLiquidationOpenUpdated(loanLiquidationOpen);\n    }\n\n    function setLiquidationRatio(uint256 _liquidationRatio) external onlyOwner {\n        require(_liquidationRatio > SafeDecimalMath.unit(), \"Ratio less than 100%\");\n        liquidationRatio = _liquidationRatio;\n        emit LiquidationRatioUpdated(liquidationRatio);\n    }\n\n    // ========== PUBLIC VIEWS ==========\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](4);\n        addresses[0] = CONTRACT_SYSTEMSTATUS;\n        addresses[1] = CONTRACT_PYNTHPUSD;\n        addresses[2] = CONTRACT_EXRATES;\n        addresses[3] = CONTRACT_FEEPOOL;\n    }\n\n    function getContractInfo()\n        external\n        view\n        returns (\n            uint256 _collateralizationRatio,\n            uint256 _issuanceRatio,\n            uint256 _interestRate,\n            uint256 _interestPerSecond,\n            uint256 _issueFeeRate,\n            uint256 _issueLimit,\n            uint256 _minLoanCollateralSize,\n            uint256 _totalIssuedPynths,\n            uint256 _totalLoansCreated,\n            uint256 _totalOpenLoanCount,\n            uint256 _ethBalance,\n            uint256 _liquidationDeadline,\n            bool _loanLiquidationOpen\n        )\n    {\n        _collateralizationRatio = collateralizationRatio;\n        _issuanceRatio = issuanceRatio();\n        _interestRate = interestRate;\n        _interestPerSecond = interestPerSecond;\n        _issueFeeRate = issueFeeRate;\n        _issueLimit = issueLimit;\n        _minLoanCollateralSize = minLoanCollateralSize;\n        _totalIssuedPynths = totalIssuedPynths;\n        _totalLoansCreated = totalLoansCreated;\n        _totalOpenLoanCount = totalOpenLoanCount;\n        _ethBalance = address(this).balance;\n        _liquidationDeadline = liquidationDeadline;\n        _loanLiquidationOpen = loanLiquidationOpen;\n    }\n\n    // returns value of 100 / collateralizationRatio.\n    // e.g. 100/150 = 0.6666666667\n    function issuanceRatio() public view returns (uint256) {\n        // this rounds so you get slightly more rather than slightly less\n        return ONE_HUNDRED.divideDecimalRound(collateralizationRatio);\n    }\n\n    function loanAmountFromCollateral(uint256 collateralAmount) public view returns (uint256) {\n        // a fraction more is issued due to rounding\n        return collateralAmount.multiplyDecimal(issuanceRatio()).multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n    }\n\n    function collateralAmountForLoan(uint256 loanAmount) external view returns (uint256) {\n        return\n            loanAmount\n                .multiplyDecimal(collateralizationRatio.divideDecimalRound(exchangeRates().rateForCurrency(ETH)))\n                .divideDecimalRound(ONE_HUNDRED);\n    }\n\n    // compound accrued interest with remaining loanAmount * (now - lastTimestampInterestPaid)\n    function currentInterestOnLoan(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        uint256 currentInterest =\n            accruedInterestOnLoan(pynthLoan.loanAmount.add(pynthLoan.accruedInterest), _timeSinceInterestAccrual(pynthLoan));\n        return pynthLoan.accruedInterest.add(currentInterest);\n    }\n\n    function accruedInterestOnLoan(uint256 _loanAmount, uint256 _seconds) public view returns (uint256 interestAmount) {\n        // Simple interest calculated per second\n        // Interest = Principal * rate * time\n        interestAmount = _loanAmount.multiplyDecimalRound(interestPerSecond.mul(_seconds));\n    }\n\n    function totalFeesOnLoan(address _account, uint256 _loanID)\n        external\n        view\n        returns (uint256 interestAmount, uint256 mintingFee)\n    {\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        uint256 loanAmountWithAccruedInterest = pynthLoan.loanAmount.add(pynthLoan.accruedInterest);\n        interestAmount = pynthLoan.accruedInterest.add(\n            accruedInterestOnLoan(loanAmountWithAccruedInterest, _timeSinceInterestAccrual(pynthLoan))\n        );\n        mintingFee = pynthLoan.mintingFee;\n    }\n\n    function getMintingFee(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        return pynthLoan.mintingFee;\n    }\n\n    /**\n     * r = target issuance ratio\n     * D = debt balance\n     * V = Collateral\n     * P = liquidation penalty\n     * Calculates amount of pynths = (D - V * r) / (1 - (1 + P) * r)\n     */\n    function calculateAmountToLiquidate(uint debtBalance, uint collateral) public view returns (uint) {\n        uint unit = SafeDecimalMath.unit();\n        uint ratio = liquidationRatio;\n\n        uint dividend = debtBalance.sub(collateral.divideDecimal(ratio));\n        uint divisor = unit.sub(unit.add(liquidationPenalty).divideDecimal(ratio));\n\n        return dividend.divideDecimal(divisor);\n    }\n\n    function openLoanIDsByAccount(address _account) external view returns (uint256[] memory) {\n        PynthLoanStruct[] memory pynthLoans = accountsPynthLoans[_account];\n\n        uint256[] memory _openLoanIDs = new uint256[](pynthLoans.length);\n        uint256 _counter = 0;\n\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].timeClosed == 0) {\n                _openLoanIDs[_counter] = pynthLoans[i].loanID;\n                _counter++;\n            }\n        }\n        // Create the fixed size array to return\n        uint256[] memory _result = new uint256[](_counter);\n\n        // Copy loanIDs from dynamic array to fixed array\n        for (uint256 j = 0; j < _counter; j++) {\n            _result[j] = _openLoanIDs[j];\n        }\n        // Return an array with list of open Loan IDs\n        return _result;\n    }\n\n    function getLoan(address _account, uint256 _loanID)\n        external\n        view\n        returns (\n            address account,\n            uint256 collateralAmount,\n            uint256 loanAmount,\n            uint256 timeCreated,\n            uint256 loanID,\n            uint256 timeClosed,\n            uint256 accruedInterest,\n            uint256 totalFees\n        )\n    {\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        account = pynthLoan.account;\n        collateralAmount = pynthLoan.collateralAmount;\n        loanAmount = pynthLoan.loanAmount;\n        timeCreated = pynthLoan.timeCreated;\n        loanID = pynthLoan.loanID;\n        timeClosed = pynthLoan.timeClosed;\n        accruedInterest = pynthLoan.accruedInterest.add(\n            accruedInterestOnLoan(pynthLoan.loanAmount.add(pynthLoan.accruedInterest), _timeSinceInterestAccrual(pynthLoan))\n        );\n        totalFees = accruedInterest.add(pynthLoan.mintingFee);\n    }\n\n    function getLoanCollateralRatio(address _account, uint256 _loanID) external view returns (uint256 loanCollateralRatio) {\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n\n        (loanCollateralRatio, , ) = _loanCollateralRatio(pynthLoan);\n    }\n\n    function _loanCollateralRatio(PynthLoanStruct memory _loan)\n        internal\n        view\n        returns (\n            uint256 loanCollateralRatio,\n            uint256 collateralValue,\n            uint256 interestAmount\n        )\n    {\n        // Any interest accrued prior is rolled up into loan amount\n        uint256 loanAmountWithAccruedInterest = _loan.loanAmount.add(_loan.accruedInterest);\n\n        interestAmount = accruedInterestOnLoan(loanAmountWithAccruedInterest, _timeSinceInterestAccrual(_loan));\n\n        collateralValue = _loan.collateralAmount.multiplyDecimal(exchangeRates().rateForCurrency(COLLATERAL));\n\n        loanCollateralRatio = collateralValue.divideDecimal(loanAmountWithAccruedInterest.add(interestAmount));\n    }\n\n    function timeSinceInterestAccrualOnLoan(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n\n        return _timeSinceInterestAccrual(pynthLoan);\n    }\n\n    // ========== PUBLIC FUNCTIONS ==========\n\n    function openLoan(uint256 _loanAmount)\n        external\n        payable\n        notPaused\n        nonReentrant\n        ETHRateNotInvalid\n        returns (uint256 loanID)\n    {\n        systemStatus().requireIssuanceActive();\n\n        // Require ETH sent to be greater than minLoanCollateralSize\n        require(\n            msg.value >= minLoanCollateralSize,\n            \"Not enough ETH to create this loan. Please see the minLoanCollateralSize\"\n        );\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Each account is limited to creating 50 (accountLoanLimit) loans\n        require(accountsPynthLoans[msg.sender].length < accountLoanLimit, \"Each account is limited to 50 loans\");\n\n        // Calculate issuance amount based on issuance ratio\n        uint256 maxLoanAmount = loanAmountFromCollateral(msg.value);\n\n        // Require requested _loanAmount to be less than maxLoanAmount\n        // Issuance ratio caps collateral to loan value at 150%\n        require(_loanAmount <= maxLoanAmount, \"Loan amount exceeds max borrowing power\");\n\n        uint256 mintingFee = _calculateMintingFee(_loanAmount);\n        uint256 loanAmountMinusFee = _loanAmount.sub(mintingFee);\n\n        // Require pUSD loan to mint does not exceed cap\n        require(totalIssuedPynths.add(_loanAmount) <= issueLimit, \"Loan Amount exceeds the supply cap.\");\n\n        // Get a Loan ID\n        loanID = _incrementTotalLoansCounter();\n\n        // Create Loan storage object\n        PynthLoanStruct memory pynthLoan =\n            PynthLoanStruct({\n                account: msg.sender,\n                collateralAmount: msg.value,\n                loanAmount: _loanAmount,\n                mintingFee: mintingFee,\n                timeCreated: block.timestamp,\n                loanID: loanID,\n                timeClosed: 0,\n                loanInterestRate: interestRate,\n                accruedInterest: 0,\n                lastInterestAccrued: 0\n            });\n\n        // Fee distribution. Mint the pUSD fees into the FeePool and record fees paid\n        if (mintingFee > 0) {\n            pynthpUSD().issue(FEE_ADDRESS, mintingFee);\n            feePool().recordFeePaid(mintingFee);\n        }\n\n        // Record loan in mapping to account in an array of the accounts open loans\n        accountsPynthLoans[msg.sender].push(pynthLoan);\n\n        // Increment totalIssuedPynths\n        totalIssuedPynths = totalIssuedPynths.add(_loanAmount);\n\n        // Issue the pynth (less fee)\n        pynthpUSD().issue(msg.sender, loanAmountMinusFee);\n\n        // Tell the Dapps a loan was created\n        emit LoanCreated(msg.sender, loanID, _loanAmount);\n    }\n\n    function closeLoan(uint256 loanID) external nonReentrant ETHRateNotInvalid {\n        _closeLoan(msg.sender, loanID, false);\n    }\n\n    // Add ETH collateral to an open loan\n    function depositCollateral(address account, uint256 loanID) external payable notPaused {\n        require(msg.value > 0, \"Deposit amount must be greater than 0\");\n\n        systemStatus().requireIssuanceActive();\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(account, loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(pynthLoan);\n\n        uint256 totalCollateral = pynthLoan.collateralAmount.add(msg.value);\n\n        _updateLoanCollateral(pynthLoan, totalCollateral);\n\n        // Tell the Dapps collateral was added to loan\n        emit CollateralDeposited(account, loanID, msg.value, totalCollateral);\n    }\n\n    // Withdraw ETH collateral from an open loan\n    function withdrawCollateral(uint256 loanID, uint256 withdrawAmount) external notPaused nonReentrant ETHRateNotInvalid {\n        require(withdrawAmount > 0, \"Amount to withdraw must be greater than 0\");\n\n        systemStatus().requireIssuanceActive();\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(msg.sender, loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(pynthLoan);\n\n        uint256 collateralAfter = pynthLoan.collateralAmount.sub(withdrawAmount);\n\n        PynthLoanStruct memory loanAfter = _updateLoanCollateral(pynthLoan, collateralAfter);\n\n        // require collateral ratio after to be above the liquidation ratio\n        (uint256 collateralRatioAfter, , ) = _loanCollateralRatio(loanAfter);\n\n        require(collateralRatioAfter > liquidationRatio, \"Collateral ratio below liquidation after withdraw\");\n\n        // transfer ETH to msg.sender\n        msg.sender.transfer(withdrawAmount);\n\n        // Tell the Dapps collateral was added to loan\n        emit CollateralWithdrawn(msg.sender, loanID, withdrawAmount, loanAfter.collateralAmount);\n    }\n\n    function repayLoan(\n        address _loanCreatorsAddress,\n        uint256 _loanID,\n        uint256 _repayAmount\n    ) external ETHRateNotInvalid {\n        systemStatus().requireSystemActive();\n\n        // check msg.sender has sufficient pUSD to pay\n        require(IERC20(address(pynthpUSD())).balanceOf(msg.sender) >= _repayAmount, \"Not enough pUSD balance\");\n\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_loanCreatorsAddress, _loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(pynthLoan);\n\n        // Any interest accrued prior is rolled up into loan amount\n        uint256 loanAmountWithAccruedInterest = pynthLoan.loanAmount.add(pynthLoan.accruedInterest);\n        uint256 interestAmount = accruedInterestOnLoan(loanAmountWithAccruedInterest, _timeSinceInterestAccrual(pynthLoan));\n\n        // repay any accrued interests first\n        // and repay principal loan amount with remaining amounts\n        uint256 accruedInterest = pynthLoan.accruedInterest.add(interestAmount);\n\n        (uint256 interestPaid, uint256 loanAmountPaid, uint256 accruedInterestAfter, uint256 loanAmountAfter) =\n            _splitInterestLoanPayment(_repayAmount, accruedInterest, pynthLoan.loanAmount);\n\n        // burn pUSD from msg.sender for repaid amount\n        pynthpUSD().burn(msg.sender, _repayAmount);\n\n        // Send interest paid to fee pool and record loan amount paid\n        _processInterestAndLoanPayment(interestPaid, loanAmountPaid);\n\n        // update loan with new total loan amount, record accrued interests\n        _updateLoan(pynthLoan, loanAmountAfter, accruedInterestAfter, block.timestamp);\n\n        emit LoanRepaid(_loanCreatorsAddress, _loanID, _repayAmount, loanAmountAfter);\n    }\n\n    // Liquidate loans at or below issuance ratio\n    function liquidateLoan(\n        address _loanCreatorsAddress,\n        uint256 _loanID,\n        uint256 _debtToCover\n    ) external nonReentrant ETHRateNotInvalid {\n        systemStatus().requireSystemActive();\n\n        // check msg.sender (liquidator's wallet) has sufficient pUSD\n        require(IERC20(address(pynthpUSD())).balanceOf(msg.sender) >= _debtToCover, \"Not enough pUSD balance\");\n\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_loanCreatorsAddress, _loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(pynthLoan);\n\n        (uint256 collateralRatio, uint256 collateralValue, uint256 interestAmount) = _loanCollateralRatio(pynthLoan);\n\n        require(collateralRatio < liquidationRatio, \"Collateral ratio above liquidation ratio\");\n\n        // calculate amount to liquidate to fix ratio including accrued interest\n        uint256 liquidationAmount =\n            calculateAmountToLiquidate(\n                pynthLoan.loanAmount.add(pynthLoan.accruedInterest).add(interestAmount),\n                collateralValue\n            );\n\n        // cap debt to liquidate\n        uint256 amountToLiquidate = liquidationAmount < _debtToCover ? liquidationAmount : _debtToCover;\n\n        // burn pUSD from msg.sender for amount to liquidate\n        pynthpUSD().burn(msg.sender, amountToLiquidate);\n\n        (uint256 interestPaid, uint256 loanAmountPaid, uint256 accruedInterestAfter, ) =\n            _splitInterestLoanPayment(\n                amountToLiquidate,\n                pynthLoan.accruedInterest.add(interestAmount),\n                pynthLoan.loanAmount\n            );\n\n        // Send interests paid to fee pool and record loan amount paid\n        _processInterestAndLoanPayment(interestPaid, loanAmountPaid);\n\n        // Collateral value to redeem\n        uint256 collateralRedeemed = exchangeRates().effectiveValue(pUSD, amountToLiquidate, COLLATERAL);\n\n        // Add penalty\n        uint256 totalCollateralLiquidated =\n            collateralRedeemed.multiplyDecimal(SafeDecimalMath.unit().add(liquidationPenalty));\n\n        // update remaining loanAmount less amount paid and update accrued interests less interest paid\n        _updateLoan(pynthLoan, pynthLoan.loanAmount.sub(loanAmountPaid), accruedInterestAfter, block.timestamp);\n\n        // update remaining collateral on loan\n        _updateLoanCollateral(pynthLoan, pynthLoan.collateralAmount.sub(totalCollateralLiquidated));\n\n        // Send liquidated ETH collateral to msg.sender\n        msg.sender.transfer(totalCollateralLiquidated);\n\n        // emit loan liquidation event\n        emit LoanPartiallyLiquidated(\n            _loanCreatorsAddress,\n            _loanID,\n            msg.sender,\n            amountToLiquidate,\n            totalCollateralLiquidated\n        );\n    }\n\n    function _splitInterestLoanPayment(\n        uint256 _paymentAmount,\n        uint256 _accruedInterest,\n        uint256 _loanAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 interestPaid,\n            uint256 loanAmountPaid,\n            uint256 accruedInterestAfter,\n            uint256 loanAmountAfter\n        )\n    {\n        uint256 remainingPayment = _paymentAmount;\n\n        // repay any accrued interests first\n        accruedInterestAfter = _accruedInterest;\n        if (remainingPayment > 0 && _accruedInterest > 0) {\n            // Max repay is the accruedInterest amount\n            interestPaid = remainingPayment > _accruedInterest ? _accruedInterest : remainingPayment;\n            accruedInterestAfter = accruedInterestAfter.sub(interestPaid);\n            remainingPayment = remainingPayment.sub(interestPaid);\n        }\n\n        // Remaining amounts - pay down loan amount\n        loanAmountAfter = _loanAmount;\n        if (remainingPayment > 0) {\n            loanAmountAfter = loanAmountAfter.sub(remainingPayment);\n            loanAmountPaid = remainingPayment;\n        }\n    }\n\n    function _processInterestAndLoanPayment(uint256 interestPaid, uint256 loanAmountPaid) internal {\n        // Fee distribution. Mint the pUSD fees into the FeePool and record fees paid\n        if (interestPaid > 0) {\n            pynthpUSD().issue(FEE_ADDRESS, interestPaid);\n            feePool().recordFeePaid(interestPaid);\n        }\n\n        // Decrement totalIssuedPynths\n        if (loanAmountPaid > 0) {\n            totalIssuedPynths = totalIssuedPynths.sub(loanAmountPaid);\n        }\n    }\n\n    // Liquidation of an open loan available for anyone\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external nonReentrant ETHRateNotInvalid {\n        require(loanLiquidationOpen, \"Liquidation is not open\");\n        // Close the creators loan and send collateral to the closer.\n        _closeLoan(_loanCreatorsAddress, _loanID, true);\n        // Tell the Dapps this loan was liquidated\n        emit LoanLiquidated(_loanCreatorsAddress, _loanID, msg.sender);\n    }\n\n    // ========== PRIVATE FUNCTIONS ==========\n\n    function _closeLoan(\n        address account,\n        uint256 loanID,\n        bool liquidation\n    ) private {\n        systemStatus().requireIssuanceActive();\n\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(account, loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(pynthLoan);\n\n        // Calculate and deduct accrued interest (5%) for fee pool\n        // Accrued interests (captured in loanAmount) + new interests\n        uint256 interestAmount =\n            accruedInterestOnLoan(pynthLoan.loanAmount.add(pynthLoan.accruedInterest), _timeSinceInterestAccrual(pynthLoan));\n        uint256 repayAmount = pynthLoan.loanAmount.add(interestAmount);\n\n        uint256 totalAccruedInterest = pynthLoan.accruedInterest.add(interestAmount);\n\n        require(\n            IERC20(address(pynthpUSD())).balanceOf(msg.sender) >= repayAmount,\n            \"You do not have the required Pynth balance to close this loan.\"\n        );\n\n        // Record loan as closed\n        _recordLoanClosure(pynthLoan);\n\n        // Decrement totalIssuedPynths\n        // subtract the accrued interest from the loanAmount\n        totalIssuedPynths = totalIssuedPynths.sub(pynthLoan.loanAmount.sub(pynthLoan.accruedInterest));\n\n        // Burn all Pynths issued for the loan + the fees\n        pynthpUSD().burn(msg.sender, repayAmount);\n\n        // Fee distribution. Mint the pUSD fees into the FeePool and record fees paid\n        pynthpUSD().issue(FEE_ADDRESS, totalAccruedInterest);\n        feePool().recordFeePaid(totalAccruedInterest);\n\n        uint256 remainingCollateral = pynthLoan.collateralAmount;\n\n        if (liquidation) {\n            // Send liquidator redeemed collateral + 10% penalty\n            uint256 collateralRedeemed = exchangeRates().effectiveValue(pUSD, repayAmount, COLLATERAL);\n\n            // add penalty\n            uint256 totalCollateralLiquidated =\n                collateralRedeemed.multiplyDecimal(SafeDecimalMath.unit().add(liquidationPenalty));\n\n            // ensure remaining ETH collateral sufficient to cover collateral liquidated\n            // will revert if the liquidated collateral + penalty is more than remaining collateral\n            remainingCollateral = remainingCollateral.sub(totalCollateralLiquidated);\n\n            // Send liquidator CollateralLiquidated\n            msg.sender.transfer(totalCollateralLiquidated);\n        }\n\n        // Send remaining collateral to loan creator\n        pynthLoan.account.transfer(remainingCollateral);\n\n        // Tell the Dapps\n        emit LoanClosed(account, loanID, totalAccruedInterest);\n    }\n\n    function _getLoanFromStorage(address account, uint256 loanID) private view returns (PynthLoanStruct memory) {\n        PynthLoanStruct[] memory pynthLoans = accountsPynthLoans[account];\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].loanID == loanID) {\n                return pynthLoans[i];\n            }\n        }\n    }\n\n    function _updateLoan(\n        PynthLoanStruct memory _pynthLoan,\n        uint256 _newLoanAmount,\n        uint256 _newAccruedInterest,\n        uint256 _lastInterestAccrued\n    ) private {\n        // Get storage pointer to the accounts array of loans\n        PynthLoanStruct[] storage pynthLoans = accountsPynthLoans[_pynthLoan.account];\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].loanID == _pynthLoan.loanID) {\n                pynthLoans[i].loanAmount = _newLoanAmount;\n                pynthLoans[i].accruedInterest = _newAccruedInterest;\n                pynthLoans[i].lastInterestAccrued = uint40(_lastInterestAccrued);\n            }\n        }\n    }\n\n    function _updateLoanCollateral(PynthLoanStruct memory _pynthLoan, uint256 _newCollateralAmount)\n        private\n        returns (PynthLoanStruct memory)\n    {\n        // Get storage pointer to the accounts array of loans\n        PynthLoanStruct[] storage pynthLoans = accountsPynthLoans[_pynthLoan.account];\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].loanID == _pynthLoan.loanID) {\n                pynthLoans[i].collateralAmount = _newCollateralAmount;\n                return pynthLoans[i];\n            }\n        }\n    }\n\n    function _recordLoanClosure(PynthLoanStruct memory pynthLoan) private {\n        // Get storage pointer to the accounts array of loans\n        PynthLoanStruct[] storage pynthLoans = accountsPynthLoans[pynthLoan.account];\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].loanID == pynthLoan.loanID) {\n                // Record the time the loan was closed\n                pynthLoans[i].timeClosed = block.timestamp;\n            }\n        }\n\n        // Reduce Total Open Loans Count\n        totalOpenLoanCount = totalOpenLoanCount.sub(1);\n    }\n\n    function _incrementTotalLoansCounter() private returns (uint256) {\n        // Increase the total Open loan count\n        totalOpenLoanCount = totalOpenLoanCount.add(1);\n        // Increase the total Loans Created count\n        totalLoansCreated = totalLoansCreated.add(1);\n        // Return total count to be used as a unique ID.\n        return totalLoansCreated;\n    }\n\n    function _calculateMintingFee(uint256 _loanAmount) private view returns (uint256 mintingFee) {\n        mintingFee = _loanAmount.multiplyDecimalRound(issueFeeRate);\n    }\n\n    function _timeSinceInterestAccrual(PynthLoanStruct memory _pynthLoan) private view returns (uint256 timeSinceAccrual) {\n        // The last interest accrued timestamp for the loan\n        // If lastInterestAccrued timestamp is not set (0), use loan timeCreated\n        uint256 lastInterestAccrual =\n            _pynthLoan.lastInterestAccrued > 0 ? uint256(_pynthLoan.lastInterestAccrued) : _pynthLoan.timeCreated;\n\n        // diff between last interested accrued and now\n        // use loan's timeClosed if loan is closed\n        timeSinceAccrual = _pynthLoan.timeClosed > 0\n            ? _pynthLoan.timeClosed.sub(lastInterestAccrual)\n            : block.timestamp.sub(lastInterestAccrual);\n    }\n\n    function _checkLoanIsOpen(PynthLoanStruct memory _pynthLoan) internal pure {\n        require(_pynthLoan.loanID > 0, \"Loan does not exist\");\n        require(_pynthLoan.timeClosed == 0, \"Loan already closed\");\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function pynthpUSD() internal view returns (IPynth) {\n        return IPynth(requireAndGetAddress(CONTRACT_PYNTHPUSD));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier ETHRateNotInvalid() {\n        require(!exchangeRates().rateIsInvalid(COLLATERAL), \"Blocked as ETH rate is invalid\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n\n    event CollateralizationRatioUpdated(uint256 ratio);\n    event LiquidationRatioUpdated(uint256 ratio);\n    event InterestRateUpdated(uint256 interestRate);\n    event IssueFeeRateUpdated(uint256 issueFeeRate);\n    event IssueLimitUpdated(uint256 issueLimit);\n    event MinLoanCollateralSizeUpdated(uint256 minLoanCollateralSize);\n    event AccountLoanLimitUpdated(uint256 loanLimit);\n    event LoanLiquidationOpenUpdated(bool loanLiquidationOpen);\n    event LoanCreated(address indexed account, uint256 loanID, uint256 amount);\n    event LoanClosed(address indexed account, uint256 loanID, uint256 feesPaid);\n    event LoanLiquidated(address indexed account, uint256 loanID, address liquidator);\n    event LoanPartiallyLiquidated(\n        address indexed account,\n        uint256 loanID,\n        address liquidator,\n        uint256 liquidatedAmount,\n        uint256 liquidatedCollateral\n    );\n    event CollateralDeposited(address indexed account, uint256 loanID, uint256 collateralAmount, uint256 collateralAfter);\n    event CollateralWithdrawn(address indexed account, uint256 loanID, uint256 amountWithdrawn, uint256 collateralAfter);\n    event LoanRepaid(address indexed account, uint256 loanID, uint256 repaidAmount, uint256 newLoanAmount);\n}\n\n    ","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanLimit\",\"type\":\"uint256\"}],\"name\":\"AccountLoanLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAfter\",\"type\":\"uint256\"}],\"name\":\"CollateralDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAfter\",\"type\":\"uint256\"}],\"name\":\"CollateralWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"CollateralizationRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"}],\"name\":\"InterestRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"IssueFeeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueLimit\",\"type\":\"uint256\"}],\"name\":\"IssueLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"LiquidationRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesPaid\",\"type\":\"uint256\"}],\"name\":\"LoanClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LoanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"LoanLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"LoanLiquidationOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatedCollateral\",\"type\":\"uint256\"}],\"name\":\"LoanPartiallyLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repaidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLoanAmount\",\"type\":\"uint256\"}],\"name\":\"LoanRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLoanCollateralSize\",\"type\":\"uint256\"}],\"name\":\"MinLoanCollateralSizeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountLoanLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountOpenLoanCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsPynthLoans\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"lastInterestAccrued\",\"type\":\"uint40\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"accruedInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"debtBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"calculateAmountToLiquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"closeLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"}],\"name\":\"collateralAmountForLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"currentInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralizationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issuanceRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minLoanCollateralSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalIssuedPynths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLoansCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalOpenLoanCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getLoan\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getLoanCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanCollateralRatio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getMintingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtToCover\",\"type\":\"uint256\"}],\"name\":\"liquidateLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"liquidateUnclosedLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"loanAmountFromCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanLiquidationOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minLoanCollateralSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"}],\"name\":\"openLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"openLoanIDsByAccount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"addresses\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanLimit\",\"type\":\"uint256\"}],\"name\":\"setAccountLoanLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"setCollateralizationRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"setIssueFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"}],\"name\":\"setIssueLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidationRatio\",\"type\":\"uint256\"}],\"name\":\"setLiquidationRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"setLoanLiquidationOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minLoanCollateralSize\",\"type\":\"uint256\"}],\"name\":\"setMinLoanCollateralSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"timeSinceInterestAccrualOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"totalFeesOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintingFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuedPynths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLoansCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOpenLoanCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherCollateralpUSD","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000918153d6e806df9d4d33664d1cc580416171f7200000000000000000000000007015cd1e78ba1428d103b0c2513077b2826b64fc","EVMVersion":"Default","Library":"SafeDecimalMath:6e0bff12512a94f3b1ecebe08203fe7f8f8fae64","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}