//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./BitmapHeader.sol";

/**
 * @dev Internal helper library to encapsulate interactions with a "Drawing" contract
 */
library Drawing {
    /**
     * @dev Deploys the given bytecode as a drawing contract
     * @param bytecode The bytecode to pass to the CREATE opcode
     *        Must have been generated by the DBN compiler for predictable results.
     * @param tokenId The tokenId to inject into the bytecode
     * @return the address of the newly created contract
     * 
     * Will also inject the given tokenID into the bytecode before deploy so that
     * It is available in the deployed contract's context via a codecopy.
     * 
     * The bytecode passed needs to be _deploy_ bytecode (so end up returning the
     * actual bytecode). If any issues occur with the CREATE the transaction
     * will fail with an assert (consuming all remaining gas). Detailed reasoning inline.
     */
    function deploy(bytes memory bytecode, uint256 tokenId) internal returns (address) {
        // First, inject the token id into the bytecode.
        // The end of the bytecode is [2 bytes token id][32 bytes ipfs hash]
        // (and we get the tokenID in in bigendian)
        // This clearly assumes some coordination with the compiler (leaving this space blank!)
        bytecode[bytecode.length - 32 - 2] = bytes1(uint8((tokenId & 0xFF00) >> 8));
        bytecode[bytecode.length - 32 - 1] = bytes1(uint8(tokenId & 0xFF));

        address addr;
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
        /*
        if addr is zero, a few things could have happened:
            a) out-of-gas in the create (which gets forwarded [current*(63/64) - 32000])
            b) other exceptional halt (call stack too deep, invalid jump, etc)
            c) revert from the create

        in a): we should drain all existing gas and effectively bubble up the out of gas.
               this makes sure that gas estimators do the right thing
        in b): this is a nasty situation, so let's just drain away our gas anyway (true assert)
        in c): pretty much same as b) — this is a bug in the passed bytecode, and we should fail.
               that said, we _could_ check the μo return buffer for REVERT data, but no need for now. 

        So no matter what, we want to "assert" the addr is not zero
        */
        assert(addr != address(0));

        return addr;
    }

    /**
     * @dev Renders the specified drawing contract as a bitmap
     * @param addr The address of the drawing contract
     * @return an estimation of the gas used and the 10962 bytes of the bitmap
     * 
     * It calls the "0xBD" opcode of the drawing to get just the bitmap pixel data;
     * the bitmap header is generated within this calling contract. This is to ensure
     * that even if the deployed drawing doesn't conform to the DBN-drawing spec,
     * a valid bitmap will always be returned.
     * 
     * To further ensure that a valid bitmap is always returned, if the call
     * to the drawing contract reverts, a bitmap will still be returned
     * (though with the center pixel set to "55" to facilitate debugging)
     */ 
    function render(address addr) internal view returns (uint256, bytes memory) {
        uint bitmapLength = 10962;
        uint headerLength = 40 + 14 + 404;
        uint pixelDataLength = (10962 - headerLength);

        bytes memory result = new bytes(bitmapLength);
        bytes memory input = hex"BD";

        uint256 startGas = gasleft();

        BitmapHeader.writeTo(result);
        uint resultOffset = 0x20 + headerLength; // after the header (and 0x20 for the dynamic byte length)

        assembly {
            let success := staticcall(
                gas(),
                addr,
                add(input, 0x20),
                1,
                0, // return dst, but we're using the returnbuffer
                0  // return length (we're using the returnbuffer)
            )

            let dataDst := add(result, resultOffset)
            switch success
            case 1 {
                // Render call succeeded!
                // copy min(returndataize, pixelDataLength) from the returnbuffer
                // in happy path: returndatasize === pixeldatalength
                //   -> then great, either
                // unexpected (too little data): returndatasize < pixeldatalength
                //   -> then we mustn't copy too much from the buffer! (use returndatasize)
                // unexpected (too much data): returndatasize > pixeldatalength
                //   -> then we mustn't overflow our result! (use pixeldatalength)
                let copySize := returndatasize()
                if gt(copySize, pixelDataLength) {
                    copySize := pixelDataLength
                }
                returndatacopy(
                    dataDst, // dst offset
                    0,       // src offset
                    copySize // length
                )
            }
            case 0 {
                // Render call failed :/
                // Leave a little indicating pixel to hopefully help debugging
                mstore8(
                    add(dataDst, 5250), // location of the center pixel (50 * 104 + 50)
                    0x55
                )
            }
        }

        // this overestimates _some_, but that's fine
        uint256 endGas = gasleft();

        return ((startGas - endGas), result);
    }

    /**
     * @dev Gets the description stored in the code of a drawing contract
     * @param addr The address of the drawing contract
     * @return a (possibly empty) string description of the drawing
     * 
     * It calls the "0xDE" opcode of the drawing to get its description.
     * If the call fails, it will return an empty string.
     */
    function description(address addr) internal view returns (string memory) {
        (bool success, bytes memory desc) = addr.staticcall(hex"DE");
        if (success) {
            return string(desc);
        } else {
            return "";
        }
    }
}

