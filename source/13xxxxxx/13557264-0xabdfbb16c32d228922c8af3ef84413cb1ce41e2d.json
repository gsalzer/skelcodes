{"status":"1","message":"OK","result":[{"SourceCode":"{\"Governance.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// 2021 (C) SUPER HOW Contracts: superhow.ART Auction governance v1.0 \\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Weighting.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC1155.sol\\\";\\n\\n\\ninterface IERC1155extended is IERC1155 {\\n    \\n    function mint(address account, uint256 id, uint256 amount, bytes memory data) external;\\n\\n}\\n\\ncontract Governance {\\n    \\n    uint256 internal _idNFT = 0;\\n    address internal _governanceBeneficiary;\\n    address internal _whaleAddress;\\n    address internal _shrimpAddress;\\n    address internal _erc1155ContractAddress;\\n    uint internal _winner;\\n    uint internal _userAmount;\\n    uint internal _shrimpTransferAmount;\\n    uint internal _governanceAuctionEndTime;\\n    uint internal _totalGovernance;\\n    uint internal _firstDistributionCount;\\n    uint internal _lastDistributionCount;\\n    bool internal _distributedAllNFT;\\n    IERC1155extended internal _erc1155ContractInstance;\\n\\n\\n    modifier onlyGovernanceOwner() {\\n        require(msg.sender == _governanceBeneficiary, \\\"Only the owner can use this function\\\");\\n        _;\\n    }\\n    \\n    modifier afterGovernanceAuction() {\\n        require(block.timestamp \\u003e= _governanceAuctionEndTime, \\\"Auction time is incorrect\\\");\\n        _; \\n    }\\n    \\n    modifier distributedAllNFT() {\\n        require(false == _distributedAllNFT, \\\"NFT\\u0027s have been distributed to all users\\\");\\n        _;\\n    }\\n   \\n    constructor(\\n        address governanceBeneficiary\\n        ){\\n        _governanceBeneficiary = governanceBeneficiary;\\n        _firstDistributionCount = 0;\\n        _lastDistributionCount = 100;\\n        _distributedAllNFT = false;\\n    }\\n    \\n    function distributeNFTToWinner(Weighting weightingContract, Whales whalesContract, Shrimps shrimpsContract)\\n        public\\n        distributedAllNFT()\\n        onlyGovernanceOwner()\\n    {\\n        _governanceAuctionEndTime = weightingContract.getAuctionEndTime();\\n        _winner = weightingContract._passWinner();\\n        require(_winner != 0, \\\"Winner has not been anounced yet or auction has failed to raise funds\\\");\\n        require(_winner != 3, \\\"Minumum has not been reached for the sale of the painting\\\");\\n        if(_winner == 1){\\n            _distributeToWhale(whalesContract);\\n        }else if (_winner == 2){\\n            _distributeToShrimps(shrimpsContract);\\n        }\\n    }\\n    \\n    function _distributeToShrimps(Shrimps shrimpsContract)\\n        internal\\n        afterGovernanceAuction()\\n    {       \\n            _totalGovernance = shrimpsContract.getTotalBid() / 1e17 wei;\\n            require(_totalGovernance \\u003e 0, \\\"Shrimp bid amount was 0 or less\\\");\\n            if(_firstDistributionCount == 0){\\n                _erc1155ContractInstance.mint(_governanceBeneficiary, _idNFT, _totalGovernance, \\\"\\\");\\n            }\\n            _userAmount = shrimpsContract.getTotalAmountOfShrimps();\\n            if (_lastDistributionCount \\u003e shrimpsContract.getTotalAmountOfShrimps()) {\\n                _lastDistributionCount = shrimpsContract.getTotalAmountOfShrimps();\\n            }\\n            for (uint j = _firstDistributionCount; j \\u003c _lastDistributionCount; j++) {\\n                _shrimpAddress = shrimpsContract.getShrimpAddress(j);\\n                _shrimpTransferAmount = shrimpsContract.getShrimpBid(_shrimpAddress);\\n                require(_shrimpTransferAmount \\u003e 0, \\\"Shrimp bid amount must be higher than 0\\\");\\n                _shrimpTransferAmount = _shrimpTransferAmount / 1e17 wei;\\n                _erc1155ContractInstance.safeTransferFrom(_governanceBeneficiary, _shrimpAddress, _idNFT, _shrimpTransferAmount, \\\"\\\");\\n            }\\n            _firstDistributionCount = _lastDistributionCount;\\n            _lastDistributionCount += 100;\\n            if (_firstDistributionCount \\u003e= shrimpsContract.getTotalAmountOfShrimps()) {\\n                _distributedAllNFT = true;\\n            }\\n    }\\n    \\n    function _distributeToWhale(Whales whalesContract)\\n        internal\\n        afterGovernanceAuction()\\n    {\\n            _userAmount = 1;\\n            _totalGovernance = 1;\\n            _whaleAddress = whalesContract.getHighestBidder();\\n            _erc1155ContractInstance.mint(_whaleAddress, _idNFT, _userAmount, \\\"\\\");\\n            \\n            // _erc1155ContractInstance.safeTransferFrom(_governanceBeneficiary, _whaleAddress, 0, _userAmount, \\\"\\\");\\n            _distributedAllNFT = true;\\n    }\\n    \\n    function governanceTransfer(address recipient, uint256 amount)\\n        public \\n        onlyGovernanceOwner()\\n        afterGovernanceAuction()\\n        returns (bool) \\n    {\\n        _governanceTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _governanceTransfer(address sender, address recipient, uint256 amount) \\n        internal\\n        virtual \\n    {\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        uint256 senderBalance = address(this).balance;\\n        require(senderBalance \\u003e= amount, \\\"Transfer amount exceeds balance\\\");\\n\\n        payable(recipient).transfer(amount);\\n    }\\n    \\n    function setERC1155contract(address erc1155ContractAddress) \\n        public\\n        onlyGovernanceOwner()\\n    {\\n        _erc1155ContractAddress = erc1155ContractAddress;\\n        // creates erc1155 interface with set ERC1155 address\\n        _erc1155ContractInstance = IERC1155extended(erc1155ContractAddress);\\n    }\\n    \\n    function setIdNFT(uint256 idNFT) \\n        public\\n        onlyGovernanceOwner()\\n    {\\n        _idNFT = idNFT;\\n    }\\n    \\n    function governanceWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\\n        public\\n        onlyGovernanceOwner()\\n        returns(bool)\\n    {\\n        require(msg.sender != address(0), \\\"Sender is address zero\\\");\\n        require(recipient != address(0), \\\"Receiver is address zero\\\");\\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    function getOwnedGovernanceAmount(address userAddress) \\n        public\\n        view\\n        afterGovernanceAuction()\\n        returns (uint)\\n    {\\n        require(userAddress != address(0), \\\"User address is zero\\\");\\n        require(_totalGovernance != 0, \\\"Governance has yet to be distributed\\\");\\n        uint ownedGovernanceAmount = _erc1155ContractInstance.balanceOf(userAddress, _idNFT);\\n        return ownedGovernanceAmount;\\n    }\\n    function getERC1155contract() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _erc1155ContractAddress;\\n    }\\n    \\n    function getIdNFT() \\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _idNFT;\\n    }\\n    \\n    \\n    function getTotalGovernanceAmount() \\n        public\\n        view\\n        afterGovernanceAuction()\\n        returns (uint)\\n    {\\n        require(_totalGovernance != 0, \\\"Governance has yet to be distributed\\\");\\n        return _totalGovernance;\\n    }\\n\\n    function getGovernanceBeneficiary() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _governanceBeneficiary;\\n    }\\n    \\n}\\n\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\\u0027s tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``\\u0027s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\\u0027s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Shrimps.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// 2021 (C) SUPER HOW Contracts: superhow.ART Shrimps pool v1.0\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Weighting.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract Shrimps {\\n\\n    address payable internal _shrimpBeneficiary;\\n    address internal _shrimpWeightingContract;\\n    uint internal _totalBid;\\n    uint internal _maximumShrimpBid;\\n    uint internal _minimumShrimpBid;\\n    uint internal _shrimpLastBidTime;\\n    uint internal _shrimpIncrement;\\n    uint internal _shrimpReturnFee;\\n    uint internal _firstDistributionCount;\\n    uint internal _lastDistributionCount;\\n    address[] internal shrimpAddresses;   \\n    bool internal _returnedAllFunds;\\n    bool private constant NOT_ENTERED = false;\\n    bool private constant ENTERED = true;\\n    Weighting scon;\\n    \\n    mapping(address =\\u003e uint) internal _shrimpArray;\\n    mapping(address =\\u003e bool) internal _shrimpBid;\\n    mapping(address =\\u003e bool) internal _userShrimpReentrancy;\\n    \\n    receive() external payable {}\\n    fallback() external payable {}\\n    \\n    modifier shrimpMultipleETH(){\\n      require(msg.value % _shrimpIncrement * 10**18 == 0, \\\"Only 0,1 ETH multiples are accepted\\\"); //0.1 ether\\n       _;\\n    }\\n   \\n    modifier beforeShrimpAuction(uint _time) {\\n        require(block.timestamp \\u003c _time, \\\"Shrimp auction has ended\\\");\\n        _;\\n    }\\n    \\n    modifier afterShrimpAuction(uint _time) {\\n        require(block.timestamp \\u003e= _time, \\\"Shrimp auction did not end yet\\\");\\n        _;\\n    }\\n    \\n    modifier notShrimpOwner() {\\n        require(msg.sender != _shrimpBeneficiary, \\\"Contract owner can not interract here\\\");\\n        _;\\n    }\\n    \\n    modifier onlyShrimpOwner(address messageSender) {\\n        require(_shrimpBeneficiary == messageSender, \\\"Only the owner can use this function\\\");\\n        _;\\n    }\\n    \\n    modifier isShrimpWeighting() {\\n        require(address(_shrimpWeightingContract) == msg.sender, \\\"Wrong contract passed. Contract is not Weighting\\\");\\n        _;\\n    }\\n    \\n    modifier highestBidMaximum() {\\n        require(msg.value \\u003c= _maximumShrimpBid, \\\"Bid must be less than the set maximum bid\\\");\\n        require((_shrimpArray[msg.sender] + msg.value) \\u003c= _maximumShrimpBid, \\\"Bid must be less than the set maximum bid\\\");\\n        _;\\n    }\\n    \\n    modifier lowestShrimpBidMinimum() {\\n        require(msg.value \\u003e= _minimumShrimpBid/(1 ether), \\\"Minimum bid amount required\\\");\\n        _;\\n    }\\n    \\n    modifier returnedAllFunds() {\\n        require(false == _returnedAllFunds, \\\"Funds have been returned to all users\\\");\\n        _;\\n    }\\n    \\n    modifier nonShrimpReentrant() {\\n        require(_userShrimpReentrancy[msg.sender] != ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _userShrimpReentrancy[msg.sender] = ENTERED;\\n        _;\\n        _userShrimpReentrancy[msg.sender] = NOT_ENTERED;\\n    }\\n\\n    constructor(\\n        address payable shrimpBeneficiary,\\n        uint maximumShrimpBid,\\n        uint minimumShrimpBid,\\n        address shrimpWeightingContract\\n    )\\n    {\\n        _shrimpBeneficiary = shrimpBeneficiary;\\n        _maximumShrimpBid = maximumShrimpBid;\\n        _minimumShrimpBid = minimumShrimpBid;\\n        _shrimpWeightingContract = shrimpWeightingContract;\\n        scon = Weighting(payable(_shrimpWeightingContract));\\n        _shrimpIncrement = 0.1 ether;\\n        _shrimpReturnFee = 0.001 ether;\\n        _firstDistributionCount = 0;\\n        _lastDistributionCount = 100;\\n        _returnedAllFunds = false;\\n    }\\n    \\n    function shrimpsBid()\\n        public\\n        payable\\n        beforeShrimpAuction(scon.getAuctionEndTime())\\n        notShrimpOwner()\\n        highestBidMaximum()\\n        lowestShrimpBidMinimum()\\n        shrimpMultipleETH()\\n        nonShrimpReentrant()\\n    {\\n        _shrimpsBid();\\n    }\\n   \\n    function _shrimpsBid()\\n        internal\\n    {\\n        uint amount = msg.value;\\n        \\n        if(amount \\u003e 0){\\n            _shrimpArray[msg.sender] = _shrimpArray[msg.sender] + amount;\\n            if(_shrimpBid[msg.sender] == false){\\n                _shrimpBid[msg.sender] = true;\\n                shrimpAddresses.push(msg.sender);\\n            }\\n            _totalBid = _totalBid + amount;\\n            _shrimpLastBidTime = block.timestamp;\\n            \\n            uint timeLeft = scon.getAuctionEndTime() - block.timestamp;\\n            if(timeLeft \\u003c= 15 minutes){\\n                scon.setAuctionEndTime();\\n            }\\n        }\\n    }\\n\\n    function _returnShrimpFunds()\\n        external\\n        payable\\n        isShrimpWeighting()\\n        returnedAllFunds()\\n        afterShrimpAuction(scon.getAuctionEndTime())\\n    {\\n        if (_lastDistributionCount \\u003e shrimpAddresses.length) {\\n            _lastDistributionCount = shrimpAddresses.length;\\n        }\\n        for (uint j = _firstDistributionCount; j \\u003c _lastDistributionCount; j++) {\\n            if(_shrimpArray[shrimpAddresses[j]] \\u003e 0){\\n                uint amount = _shrimpArray[shrimpAddresses[j]] - _shrimpReturnFee;\\n                if(payable(shrimpAddresses[j]).send(amount)){\\n                    _shrimpArray[shrimpAddresses[j]] = 0;\\n                }\\n            }\\n        }\\n        _firstDistributionCount = _lastDistributionCount;\\n        _lastDistributionCount += 100;\\n        if (_firstDistributionCount \\u003e= shrimpAddresses.length) {\\n            _returnedAllFunds = true;\\n        }\\n    }\\n    \\n    function transferShrimpOwnership(address payable newShrimpBeneficiary)\\n        public\\n        onlyShrimpOwner(msg.sender)\\n        beforeShrimpAuction(scon.getAuctionEndTime())\\n    {\\n        _transferShrimpOwnership(newShrimpBeneficiary);\\n    }\\n   \\n    function _transferShrimpOwnership(address payable newShrimpBeneficiary)\\n        internal\\n    {\\n        require(newShrimpBeneficiary != address(0));\\n        _shrimpBeneficiary = newShrimpBeneficiary;  \\n    }\\n    \\n    function transferShrimpOwnershipToZero()\\n        public\\n        onlyShrimpOwner(msg.sender)\\n        beforeShrimpAuction(scon.getAuctionEndTime())\\n    {\\n        _transferShrimpOwnershipToZero();\\n    }\\n   \\n    function _transferShrimpOwnershipToZero()\\n        internal\\n    {\\n        _shrimpBeneficiary = payable(address(0));  \\n    }\\n    \\n    function shrimpsTransfer(address recipient, uint256 amount)\\n        public \\n        onlyShrimpOwner(msg.sender)\\n        afterShrimpAuction(scon.getAuctionEndTime())\\n        returns (bool) \\n    {   \\n        _shrimpsTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _shrimpsTransfer(address sender, address recipient, uint256 amount) \\n        internal\\n        virtual \\n    {\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        uint256 senderBalance = address(this).balance;\\n        require(senderBalance \\u003e= amount, \\\"Transfer amount exceeds balance\\\");\\n\\n        if(_shrimpBid[recipient] == true){\\n            _shrimpArray[recipient] = _shrimpArray[recipient] - amount;\\n            _totalBid = _totalBid - amount;\\n            if(_shrimpArray[recipient] == 0){\\n                delete _shrimpArray[recipient];\\n            }\\n        }\\n        payable(recipient).transfer(amount);\\n    }\\n    \\n    function shrimpsWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\\n        public\\n        onlyShrimpOwner(msg.sender)\\n        returns(bool)\\n    {\\n        require(msg.sender != address(0), \\\"Sender is address zero\\\");\\n        require(recipient != address(0), \\\"Receiver is address zero\\\");\\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    function resetShrimpReentrancy(address user) \\n        public\\n        onlyShrimpOwner(msg.sender)\\n    {\\n        _userShrimpReentrancy[user] = NOT_ENTERED;\\n    }\\n\\n    function getShrimpBeneficiary() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _shrimpBeneficiary;\\n    }\\n    \\n    function getShrimpAuctionEndTime() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return scon.getAuctionEndTime();\\n    }\\n    \\n    function getTotalBid() \\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _totalBid;\\n    }\\n    \\n    function getShrimpReturnFee() \\n        public\\n        view\\n        returns (uint256) \\n    {\\n        return _shrimpReturnFee;\\n    }\\n    \\n    function getMaximumShrimpBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _maximumShrimpBid;\\n    }\\n    \\n    function getMinimumShrimpBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _minimumShrimpBid;\\n    }\\n    \\n    function checkIfShrimpExists(address shrimp) \\n        public\\n        view\\n        returns (bool)\\n    {\\n        if(_shrimpBid[shrimp] == true){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    function getShrimpBid(address shrimpAddress) \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _shrimpArray[shrimpAddress];\\n    }\\n    \\n    function getShrimpReentrancyStatus(address user) \\n        public\\n        view\\n        onlyShrimpOwner(msg.sender)\\n        returns (bool) \\n    {\\n        return _userShrimpReentrancy[user];\\n    }\\n    \\n    function getTotalAmountOfShrimps() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return shrimpAddresses.length;\\n    }\\n    \\n    function getShrimpLastBidTime()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _shrimpLastBidTime;\\n    }\\n    \\n    function getShrimpIncrement() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _shrimpIncrement;\\n    }\\n    \\n    function getShrimpAddress(uint id) \\n        public\\n        view\\n        returns (address)\\n    {\\n        return shrimpAddresses[id];\\n    }\\n    \\n    function getShrimpContractAddress() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(this);\\n    }\\n    \\n    function getShrimpContractBalance() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return address(this).balance;\\n    }\\n    \\n}\\n\"},\"Weighting.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// 2021 (C) SUPER HOW Contracts: superhow.ART Auction engine v1.0\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Whales.sol\\\";\\nimport \\\"./Shrimps.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract Weighting {\\n    \\n    address payable internal _weightingBeneficiary;\\n    address internal _highestWhaleBidder;\\n    address internal _winnerContract;\\n    address internal _shrimpsContractAddress;\\n    address internal _whalesContractAddress;\\n    uint internal _highestWhaleBid;\\n    uint internal _highestShrimpBid;\\n    uint internal _whaleBidTime;\\n    uint internal _shrimpBidTime;\\n    uint internal _auctionEndTime;  \\n    uint internal _paintingMinimalPricing;\\n    uint internal _weightingWinner;\\n    uint internal _weightingWinnerMidAuction;\\n    bool internal _whaleWinnerCheck;\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _weightingBeneficiary, \\\"Only the owner can use this function\\\");\\n        _;\\n    }\\n    \\n    modifier afterAuction() {\\n        require(block.timestamp \\u003e= _auctionEndTime, \\\"Auction time is incorrect\\\");\\n        _;\\n    }\\n    \\n    modifier beforeAuction() {\\n        require(block.timestamp \\u003c _auctionEndTime, \\\"Auction time is incorrect\\\");\\n        _;\\n    }\\n    modifier onlyShrimpsOrWhales() {\\n        require(msg.sender == _whalesContractAddress || msg.sender == _shrimpsContractAddress, \\\"Not shrimps or whales contract calling\\\");\\n        _;\\n    }\\n    \\n   \\n    constructor(\\n        address payable weightingBeneficiary,\\n        uint paintingMinimalPricing,\\n        uint auctionEndTime\\n    )\\n    {\\n        _weightingBeneficiary = weightingBeneficiary;\\n        _paintingMinimalPricing = paintingMinimalPricing;\\n        _auctionEndTime = auctionEndTime;\\n        \\n        _weightingWinner = 0;\\n        _weightingWinnerMidAuction = 0;\\n        _whaleWinnerCheck = false;\\n    }\\n   \\n    function returnWhaleFunds(Whales whalesContract) \\n        public\\n        payable\\n        onlyOwner()\\n        afterAuction()\\n    {\\n        whalesContract._returnWhaleFunds();\\n    }\\n    \\n    function returnShrimpFunds(Shrimps shrimpContract) \\n        public\\n        payable\\n        onlyOwner()\\n        afterAuction()\\n    {\\n        shrimpContract._returnShrimpFunds();\\n    }\\n    \\n    function determineWinner(Whales whalesContract, Shrimps shrimpContract)\\n        public\\n        onlyOwner()\\n        afterAuction()\\n        returns(uint)\\n    {\\n        _highestWhaleBid = whalesContract.getHighestBid();\\n        _highestShrimpBid = shrimpContract.getTotalBid();\\n        \\n        _whaleBidTime = whalesContract.getWhaleLastBidTime();\\n        _shrimpBidTime = shrimpContract.getShrimpLastBidTime();\\n    \\n        if(_highestShrimpBid \\u003c _paintingMinimalPricing \\u0026\\u0026 _highestWhaleBid \\u003c _paintingMinimalPricing){\\n            _weightingWinner = 3;\\n            return(_weightingWinner);\\n        }else{\\n            if(_highestWhaleBid \\u003e _highestShrimpBid){\\n                _weightingWinner = 1;\\n                _winnerContract = address(whalesContract);\\n            }else if (_highestWhaleBid \\u003c _highestShrimpBid){\\n                _weightingWinner = 2;\\n                _winnerContract = address(shrimpContract);\\n            }else{\\n                if(_whaleBidTime \\u003c _shrimpBidTime){\\n                    _weightingWinner = 1;\\n                    _winnerContract = address(whalesContract);\\n                }else{\\n                    _weightingWinner = 2;\\n                    _winnerContract = address(shrimpContract);\\n                }\\n            }\\n        }\\n\\n        return(_weightingWinner);\\n    }\\n    \\n    function determineWinnerMidAuction(Whales whalesContract, Shrimps shrimpContract)\\n        public\\n        returns(uint, uint)\\n    {\\n        uint _highestWinnerBidMidAuction;\\n        _highestWhaleBid = whalesContract.getHighestBid();\\n        _highestShrimpBid = shrimpContract.getTotalBid();\\n        \\n        _whaleBidTime = whalesContract.getWhaleLastBidTime();\\n        _shrimpBidTime = shrimpContract.getShrimpLastBidTime();\\n        \\n        if(_highestWhaleBid \\u003e _highestShrimpBid){\\n            _weightingWinnerMidAuction = 1;\\n            _highestWinnerBidMidAuction = _highestWhaleBid;\\n        }else if (_highestWhaleBid \\u003c _highestShrimpBid){\\n            _weightingWinnerMidAuction = 2;\\n            _highestWinnerBidMidAuction = _highestShrimpBid;\\n        }else{\\n            if(_whaleBidTime \\u003c _shrimpBidTime){\\n                _weightingWinnerMidAuction = 1;\\n                _highestWinnerBidMidAuction = _highestWhaleBid;\\n            }else{\\n                _weightingWinnerMidAuction = 2;\\n                _highestWinnerBidMidAuction = _highestShrimpBid;\\n            }\\n        }\\n        return(_weightingWinnerMidAuction, _highestWinnerBidMidAuction);\\n    }\\n    \\n    function weightingTransfer(address recipient, uint256 amount)\\n        public \\n        onlyOwner()\\n        afterAuction()\\n        returns (bool) \\n    {\\n        _weightingTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _weightingTransfer(address sender, address recipient, uint256 amount) \\n        internal\\n        virtual \\n    {\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        uint256 senderBalance = address(this).balance;\\n        require(senderBalance \\u003e= amount, \\\"Transfer amount exceeds balance\\\");\\n\\n        payable(recipient).transfer(amount);\\n    }\\n    \\n    function weightingWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\\n        public\\n        onlyOwner()\\n        returns(bool)\\n    {\\n        require(msg.sender != address(0), \\\"Sender is address zero\\\");\\n        require(recipient != address(0), \\\"Receiver is address zero\\\");\\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    function setAuctionEndTime() \\n        external\\n        onlyShrimpsOrWhales()\\n    {\\n        _auctionEndTime = block.timestamp + 15 minutes;\\n    }\\n    \\n    function setPaintingMinimalPricing(uint newPrice) \\n        public\\n        onlyOwner()\\n    {\\n        _paintingMinimalPricing = newPrice;\\n    }\\n    \\n    function setAuctionEndTimeManual(uint256 newtime) \\n        public\\n        onlyOwner()\\n    {\\n        _auctionEndTime = newtime;\\n    }\\n\\n    function confirmWhaleWinner()\\n        public\\n        afterAuction()\\n    {\\n        require(msg.sender == _highestWhaleBidder, \\\"False winner interaction\\\");\\n        _whaleWinnerCheck = true;\\n    }\\n    \\n    function setWhalesContract(address whalesContractAddress) \\n        public\\n        onlyOwner()\\n    {\\n        _whalesContractAddress = whalesContractAddress;\\n    }\\n    \\n    function setShrimpsContract(address shrimpsContractAddress) \\n        public\\n        onlyOwner()\\n    {\\n        _shrimpsContractAddress = shrimpsContractAddress;\\n    }\\n\\n    function _passWinner()\\n        external\\n        view\\n        afterAuction()\\n        returns(uint)\\n    {\\n        return (_weightingWinner);\\n    }\\n    \\n    function getWhaleData(Whales whalesContract)\\n        public\\n        onlyOwner()\\n        returns (address, uint)\\n    {\\n        _highestWhaleBidder = whalesContract.getHighestBidder();\\n        _highestWhaleBid = whalesContract.getHighestBid();\\n        return (_highestWhaleBidder, _highestWhaleBid);\\n    }\\n    \\n    function getShrimpData(Shrimps shrimpContract)\\n        public\\n        onlyOwner()\\n        returns (uint)\\n    {\\n        _highestShrimpBid = shrimpContract.getTotalBid();\\n        return (_highestShrimpBid);\\n    }\\n    \\n    function getBeneficiary() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _weightingBeneficiary;\\n    }\\n    \\n    function getHighestWhaleBidder() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _highestWhaleBidder;\\n    }\\n    \\n    function getWinnerContract() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _winnerContract;\\n    }\\n    \\n    function getHighestWhaleBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _highestWhaleBid;\\n    }\\n    \\n    function getHighestShrimpBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _highestShrimpBid;\\n    }\\n    \\n    function getAuctionEndTime() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _auctionEndTime;\\n    }\\n    \\n    function whaleWinnerContractInteraction() \\n        public\\n        afterAuction()\\n        view\\n        returns (bool) \\n    {\\n        return _whaleWinnerCheck;\\n    }\\n \\n    function getWeightingContractAddress() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return address(this);\\n    }\\n    \\n    function getShrimpsContractAddress() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _shrimpsContractAddress;\\n    }\\n    \\n    function getWhalesContractAddress() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _whalesContractAddress;\\n    }\\n    \\n}\\n\"},\"Whales.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// 2021 (C) SUPER HOW Contracts: superhow.ART Whales bidding v1.0\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Weighting.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract Whales {\\n   \\n    address payable internal _whaleBeneficiary;\\n    address internal _whaleWeightingContract;\\n    address internal _whaleHighestBidder;\\n    uint internal _highestBid;\\n    uint internal _whaleLastBidTime;\\n    uint internal _minimumWhaleBid;\\n    uint internal _whaleIncrement;\\n    uint internal _whaleReturnFee;\\n    bool private constant NOT_ENTERED = false;\\n    bool private constant ENTERED = true;\\n    Weighting wcon;\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n   \\n    mapping(address =\\u003e uint) internal _pendingReturns;\\n    mapping(address =\\u003e bool) internal _userWhaleReentrancy;\\n    \\n    modifier whaleMultipleETH(){\\n       require(msg.value % _whaleIncrement == 0, \\\"Only 1 ETH multiples are accepted\\\"); //1 ether\\n       _;\\n    }\\n   \\n    modifier beforeWhaleAuction(uint _time) {\\n        require(block.timestamp \\u003c _time, \\\"Whale auction has ended\\\");\\n        _;\\n    }\\n    \\n    modifier afterWhaleAuction(uint _time) {\\n        require(block.timestamp \\u003e= _time, \\\"Whale auction did not end yet\\\");\\n        _;\\n    }\\n    \\n    modifier notWhaleOwner() {\\n        require(msg.sender != _whaleBeneficiary, \\\"Contract owner can not interract here\\\");\\n        _;\\n    }\\n    \\n    modifier onlyWhaleOwner(address messageSender) {\\n        require(_whaleBeneficiary == messageSender, \\\"Only the owner can use this function\\\");\\n        _;\\n    }\\n    \\n    modifier isWhaleWeighting() {\\n        require(address(_whaleWeightingContract) == msg.sender, \\\"Wrong contract passed. Contract is not Weighting\\\");\\n        _;\\n    }\\n    \\n    modifier cantBeFutureOwner(address newBeneficiaryW) {\\n        require(_whaleHighestBidder != newBeneficiaryW, \\\"Can not pass ownership to highest bidder\\\");\\n        _;\\n    }\\n    \\n    modifier lowestWhaleBidMinimum() {\\n        require(msg.value \\u003e= _minimumWhaleBid/(1 ether), \\\"Minimum bid amount required\\\");\\n        _;\\n    }\\n    \\n    modifier highestBidRequired() {\\n        require(msg.value \\u003e _highestBid, \\\"Highest bidder amount required\\\");\\n        _;\\n    }\\n    \\n    modifier sameBidder() {\\n        require(msg.sender == _whaleHighestBidder, \\\"Only the same bidder can add to amount\\\");\\n        _;   \\n    }\\n    \\n    modifier nonWhaleReentrant() {\\n        require(_userWhaleReentrancy[msg.sender] != ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _userWhaleReentrancy[msg.sender] = ENTERED;\\n        _;\\n        _userWhaleReentrancy[msg.sender] = NOT_ENTERED;\\n    }\\n\\n    constructor(\\n        address payable whaleBeneficiary,\\n        uint minimumWhaleBid,\\n        address whaleWeightingContract\\n    )\\n    {\\n        _whaleBeneficiary = whaleBeneficiary;\\n        _minimumWhaleBid = minimumWhaleBid;\\n        _whaleWeightingContract = whaleWeightingContract;\\n        wcon = Weighting(payable(_whaleWeightingContract));\\n        \\n        _whaleIncrement = 1 ether;\\n        _whaleReturnFee = 0.01 ether;\\n    }\\n    \\n    function whalesBid()\\n        public\\n        payable\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n        notWhaleOwner()\\n        lowestWhaleBidMinimum()\\n        highestBidRequired()\\n        whaleMultipleETH()\\n        nonWhaleReentrant()\\n    {\\n        _whalesBid();\\n    }\\n   \\n    function _whalesBid()\\n        internal\\n    {\\n        if (_highestBid != 0) {\\n            _pendingReturns[_whaleHighestBidder] = _pendingReturns[_whaleHighestBidder] + _highestBid;\\n            uint amount = _pendingReturns[_whaleHighestBidder];\\n            if (amount \\u003e 0) {\\n                _pendingReturns[_whaleHighestBidder] = 0;\\n                if (!payable(_whaleHighestBidder).send(amount)) {\\n                    _pendingReturns[_whaleHighestBidder] = amount;\\n                }\\n            }\\n        }\\n        \\n        _whaleHighestBidder = msg.sender;\\n        _highestBid = msg.value;\\n        \\n        uint timeLeft = wcon.getAuctionEndTime() - block.timestamp;\\n        if(timeLeft \\u003c= 15 minutes){\\n            wcon.setAuctionEndTime();\\n        }\\n        _whaleLastBidTime = block.timestamp;\\n    }\\n    \\n    function addToWhalesBid()\\n        public\\n        payable\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n        notWhaleOwner()\\n        sameBidder()\\n        whaleMultipleETH()\\n        nonWhaleReentrant()\\n    {\\n        _addToBid();\\n    }\\n    \\n    function _addToBid()\\n        internal\\n    {\\n        if(msg.value \\u003e 0 \\u0026\\u0026 _highestBid \\u003e 0){\\n            _highestBid = _highestBid + msg.value;\\n            _whaleLastBidTime = block.timestamp;\\n        }\\n    }\\n\\n    function _returnWhaleFunds() \\n        external\\n        payable\\n        isWhaleWeighting()\\n        afterWhaleAuction(wcon.getAuctionEndTime())\\n    {\\n        if (_highestBid \\u003e 0) {\\n            uint amount =  address(this).balance - _whaleReturnFee;\\n            payable(_whaleHighestBidder).transfer(amount);\\n        }\\n    }\\n    \\n    function transferWhaleOwnership(address payable newWhaleBeneficiary)\\n        public\\n        onlyWhaleOwner(msg.sender)\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n        cantBeFutureOwner(newWhaleBeneficiary)\\n    {\\n        _transferWhaleOwnership(newWhaleBeneficiary);\\n    }\\n   \\n    function _transferWhaleOwnership(address payable newWhaleBeneficiary)\\n        internal\\n    {\\n        require(newWhaleBeneficiary != address(0));\\n        _whaleBeneficiary = newWhaleBeneficiary;  \\n    }\\n    \\n        \\n    function transferWhaleOwnershipToZero()\\n        public\\n        onlyWhaleOwner(msg.sender)\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n    {\\n        _transferWhaleOwnershipToZero();\\n    }\\n   \\n    function _transferWhaleOwnershipToZero()\\n        internal\\n    {\\n        _whaleBeneficiary = payable(address(0));  \\n    }\\n    \\n    function whalesTransfer(address recipient, uint256 amount)\\n        public \\n        onlyWhaleOwner(msg.sender)\\n        afterWhaleAuction(wcon.getAuctionEndTime())\\n        returns (bool) \\n    {\\n        _whalesTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _whalesTransfer(address sender, address recipient, uint256 amount) \\n        internal\\n        virtual \\n    {\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        uint256 senderBalance = address(this).balance;\\n        require(senderBalance \\u003e= amount, \\\"Transfer amount exceeds balance\\\");\\n        \\n        if(recipient == _whaleHighestBidder){\\n            _highestBid = _highestBid - amount;\\n            if(_highestBid == 0){\\n                _whaleHighestBidder = address(0);\\n            }\\n        }\\n        payable(recipient).transfer(amount);\\n    }\\n    \\n    function whalesWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\\n        public\\n        onlyWhaleOwner(msg.sender)\\n        returns(bool)\\n    {\\n        require(msg.sender != address(0), \\\"Sender is address zero\\\");\\n        require(recipient != address(0), \\\"Receiver is address zero\\\");\\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    function resetWhaleReentrancy(address user) \\n        public\\n        onlyWhaleOwner(msg.sender)\\n    {\\n        _userWhaleReentrancy[user] = NOT_ENTERED;\\n    }\\n    \\n    function getPendingReturns(address user) \\n        public\\n        view\\n        onlyWhaleOwner(msg.sender)\\n        returns (uint256) \\n    {\\n        return _pendingReturns[user];\\n    }\\n    \\n    function getWhaleReturnFee() \\n        public\\n        view\\n        returns (uint256) \\n    {\\n        return _whaleReturnFee;\\n    }\\n    \\n    function getWhaleReentrancyStatus(address user) \\n        public\\n        view\\n        onlyWhaleOwner(msg.sender)\\n        returns (bool) \\n    {\\n        return _userWhaleReentrancy[user];\\n    }\\n\\n    function getWhaleBeneficiary() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _whaleBeneficiary;\\n    }\\n    \\n    function getHighestBidder() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _whaleHighestBidder;\\n    }\\n    \\n    function getWhaleAuctionEndTime() \\n        public\\n        view\\n        returns (uint)\\n    {\\n        return wcon.getAuctionEndTime();\\n    }\\n    \\n    function getWhaleLastBidTime()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _whaleLastBidTime;\\n    }\\n    \\n    function getHighestBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _highestBid;\\n    }\\n    \\n    function getWhaleIncrement() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _whaleIncrement;\\n    }\\n    \\n    function getMinimumWhaleBid() \\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _minimumWhaleBid;\\n    }\\n\\n    function getWhaleContractAddress() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(this);\\n    }\\n    \\n    function getWhaleContractBalance() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return address(this).balance;\\n    }\\n    \\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceBeneficiary\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract Weighting\",\"name\":\"weightingContract\",\"type\":\"address\"},{\"internalType\":\"contract Whales\",\"name\":\"whalesContract\",\"type\":\"address\"},{\"internalType\":\"contract Shrimps\",\"name\":\"shrimpsContract\",\"type\":\"address\"}],\"name\":\"distributeNFTToWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getERC1155contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernanceBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getOwnedGovernanceAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalGovernanceAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"governanceTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"governanceWithdrawERC20ContractTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc1155ContractAddress\",\"type\":\"address\"}],\"name\":\"setERC1155contract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idNFT\",\"type\":\"uint256\"}],\"name\":\"setIdNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000d4b34fad94f12958f31bcc1c06ef5640ff382cb","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://882e1599b712f574e82aade6a330b6c54d50bc44fd0c8aa75d0d3d96d417c4c7"}]}