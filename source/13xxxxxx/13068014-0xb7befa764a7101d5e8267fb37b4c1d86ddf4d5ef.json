{"status":"1","message":"OK","result":[{"SourceCode":"#------------------------------------------------------------------------------\r\n#\r\n#   Copyright 2019 Fetch.AI Limited\r\n#\r\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n#   you may not use this file except in compliance with the License.\r\n#   You may obtain a copy of the License at\r\n#\r\n#       http://www.apache.org/licenses/LICENSE-2.0\r\n#\r\n#   Unless required by applicable law or agreed to in writing, software\r\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n#   See the License for the specific language governing permissions and\r\n#   limitations under the License.\r\n#\r\n#------------------------------------------------------------------------------\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\n# maximum possible number of stakers a new auction can specify\r\nMAX_SLOTS: constant(uint256) = 200\r\n# number of blocks during which the auction remains open at reserve price\r\nRESERVE_PRICE_DURATION: constant(uint256) = 25  # number of blocks\r\n# number of seconds before deletion of the contract becomes possible after last lockupEnd() call\r\nDELETE_PERIOD: constant(uint256) = 60 * (3600 * 24)\r\n# defining the decimals supported in pool rewards per token\r\nREWARD_PER_TOK_DENOMINATOR: constant(uint256) = 100000\r\n\r\n@internal\r\ndef as_unitless_number (x: uint256) -> uint256: \r\n    return x\r\n\r\n# Structs\r\nstruct Auction:\r\n    finalPrice: uint256\r\n    lockupEnd: uint256\r\n    slotsSold: uint256\r\n    start: uint256\r\n    end: uint256\r\n    startStake: uint256\r\n    reserveStake: uint256\r\n    declinePerBlock: uint256\r\n    slotsOnSale: uint256\r\n    rewardPerSlot: uint256\r\n    uniqueStakers: uint256\r\n\r\nstruct VirtTokenHolder:\r\n    isHolder: bool\r\n    limit: uint256\r\n    rewards: uint256\r\n\r\n# Events\r\nevent Bid:\r\n    AID: uint256\r\n    _from: indexed(address)\r\n    currentPrice: uint256\r\n    amount: uint256\r\nevent BidTest: \r\n    totaltok: uint256\r\n\r\nevent NewAuction: \r\n    AID: uint256\r\n    start: uint256\r\n    end: uint256\r\n    lockupEnd: uint256\r\n    startStake: uint256\r\n    reserveStake: uint256\r\n    declinePerBlock: uint256\r\n    slotsOnSale: uint256\r\n    rewardPerSlot: uint256\r\n    \r\nevent AuctionFinalised: \r\n    AID: uint256\r\n    finalPrice: uint256\r\n    slotsSold: uint256\r\nevent LockupEnded: \r\n    AID: uint256\r\nevent AuctionAborted: \r\n    AID: uint256\r\n    rewardsPaid: bool\r\nevent SelfStakeWithdrawal: \r\n    _from: indexed(address)\r\n    amount: uint256\r\nevent PledgeWithdrawal: \r\n    _from: indexed(address)\r\n    amount: uint256\r\n\r\n# Contract state\r\ntoken: ERC20\r\nowner: public(address)\r\nearliestDelete: public(uint256)\r\n\r\n# address -> uint256 Slots a staker has won in the current auction (cleared at endLockup())\r\nstakerSlots: HashMap[address, uint256]\r\n\r\n# auction winners\r\nstakers: address[MAX_SLOTS]\r\n\r\n# pledged stake + committed pool reward, excl. selfStakerDeposit; pool -> deposits\r\npoolDeposits: public(HashMap[address, uint256])\r\n\r\n# staker (directly) -> amount\r\nselfStakerDeposits: public(HashMap[address, uint256])\r\n\r\n# staker (directly) -> price at which the bid was made\r\npriceAtBid: public(HashMap[address, uint256])\r\n\r\n# Auction details\r\ncurrentAID: public(uint256)\r\nauction: public(Auction)\r\ntotalAuctionRewards: public(uint256)\r\n\r\n# Virtual token management\r\nvirtTokenHolders: public(HashMap[address, VirtTokenHolder])\r\n\r\n################################################################################\r\n# Constant functions\r\n################################################################################\r\n# @notice True from auction initialisation until either we hit the lower bound on being clear or\r\n#   the auction finalised through finaliseAuction()\r\n@internal\r\n@view\r\ndef _isBiddingPhase() -> bool:\r\n    return ((self.auction.lockupEnd > 0)\r\n            and (block.number < self.auction.end)\r\n            and (self.auction.slotsSold < self.auction.slotsOnSale)\r\n            and (self.auction.finalPrice == 0))\r\n\r\n# @notice Returns true if either the auction has been finalised or the lockup has ended\r\n# @dev self.auction will be cleared in endLockup() call\r\n# @dev reserveStake > 0 condition in initialiseAuction() guarantees that finalPrice = 0 can never be\r\n#   a valid final price\r\n@internal\r\n@view\r\ndef _isFinalised() -> bool:\r\n    return (self.auction.finalPrice > 0) or (self.auction.lockupEnd == 0)\r\n\r\n# @notice Calculate the scheduled, linearly declining price of the dutch auction\r\n@internal\r\n@view\r\ndef _getScheduledPrice() -> uint256:\r\n    startStake_: uint256 = self.auction.startStake\r\n    start: uint256 = self.auction.start\r\n    if (block.number <= start):\r\n        return startStake_\r\n    else:\r\n        # do not calculate max(startStake - decline, reserveStake) as that could throw on negative startStake - decline\r\n        decline: uint256 = min(self.auction.declinePerBlock * (block.number - start),\r\n                                    startStake_ - self.auction.reserveStake)\r\n        return startStake_ - decline\r\n\r\n# @notice Returns the scheduled price of the auction until the auction is finalised. Then returns\r\n#   the final price.\r\n# @dev Auction price declines linearly from auction.start over _duration, then\r\n# stays at _reserveStake for RESERVE_PRICE_DURATION\r\n# @dev Returns zero If no auction is in bidding or lock-up phase\r\n@internal\r\n@view\r\ndef _getCurrentPrice() -> (uint256):\r\n    if self._isFinalised():\r\n        return self.auction.finalPrice\r\n    else:\r\n        scheduledPrice: uint256 = self._getScheduledPrice()\r\n        return scheduledPrice\r\n\r\n# @notice Returns the lockup needed by an address that stakes directly\r\n# @dev Will throw if _address is a bidder in current auction & auciton not yet finalised, as the\r\n#   slot number & price are not final yet\r\n# @dev Calling endLockup() will clear all stakerSlots flags and thereby set the required\r\n#   lockups to 0 for all participants\r\n@internal\r\n@view\r\ndef _calculateSelfStakeNeeded(_address: address) -> uint256:\r\n    selfStakeNeeded: uint256 = 0\r\n    # these slots can be outdated if auction is not yet finalised / lockup hasn't ended yet\r\n    slotsWon: uint256 = self.stakerSlots[_address]\r\n\r\n    if slotsWon > 0:\r\n        assert self._isFinalised(), \"Is bidder and auction not finalised yet\"\r\n        poolDeposit: uint256 = self.poolDeposits[_address]\r\n        currentPrice: uint256 = self._getCurrentPrice()\r\n\r\n        if (slotsWon * currentPrice) > poolDeposit:\r\n            selfStakeNeeded += (slotsWon * currentPrice) - poolDeposit\r\n    return selfStakeNeeded\r\n\r\n################################################################################\r\n# Main functions\r\n################################################################################\r\n@external\r\ndef __init__(_ERC20Address: address):\r\n    self.owner = msg.sender\r\n    self.token = ERC20(_ERC20Address)\r\n\r\n# @notice Owner can initialise new auctions\r\n# @dev First auction starts with AID 1\r\n# @dev Requires the transfer of _reward to the contract to be approved with the\r\n#   underlying ERC20 token\r\n# @param _start: start of the price decay\r\n# @param _startStake: initial auction price\r\n# @param _reserveStake: lowest possible auction price >= 1\r\n# @param _duration: duration over which the auction price declines. Total bidding\r\n#   duration is _duration + RESERVE_PRICE_DURATION\r\n# @param _lockup_duration: number of blocks the lockup phase will last\r\n# @param _slotsOnSale: size of the assembly in this cycle\r\n# @param _reward: added to any remaining reward of past auctions\r\n@external\r\ndef initialiseAuction(_start: uint256,\r\n                      _startStake: uint256,\r\n                      _reserveStake: uint256,\r\n                      _duration: uint256,\r\n                      _lockup_duration: uint256,\r\n                      _slotsOnSale: uint256,\r\n                      _reward: uint256):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert _startStake > _reserveStake, \"Invalid startStake\"\r\n    assert (_slotsOnSale > 0) and (_slotsOnSale <= MAX_SLOTS), \"Invald slot number\"\r\n    assert _start >= block.number, \"Start before current block\"\r\n    # NOTE: _isFinalised() relies on this requirement\r\n    assert _reserveStake > 0, \"Reserve stake has to be at least 1\"\r\n    assert self.auction.lockupEnd == 0, \"End current auction\"\r\n    self.currentAID += 1\r\n\r\n    # Use integer-ceil() of the fraction with (+ _duration - 1)\r\n    declinePerBlock: uint256 = (_startStake - _reserveStake + _duration - 1) / _duration\r\n    end: uint256 = _start + _duration + RESERVE_PRICE_DURATION\r\n    self.auction.start = _start\r\n    self.auction.end = end\r\n    self.auction.lockupEnd = end + _lockup_duration\r\n    self.auction.startStake = _startStake\r\n    self.auction.reserveStake = _reserveStake\r\n    self.auction.declinePerBlock = declinePerBlock\r\n    self.auction.slotsOnSale = _slotsOnSale\r\n    # Also acts as the last checked price in _updatePrice()\r\n    self.auction.finalPrice = 0\r\n\r\n    # add auction rewards\r\n    self.totalAuctionRewards += _reward\r\n    self.auction.rewardPerSlot = self.totalAuctionRewards / self.auction.slotsOnSale\r\n    success: bool = self.token.transferFrom(msg.sender, self, self.as_unitless_number(_reward))\r\n    assert success, \"Transfer failed\"\r\n\r\n    log NewAuction(self.currentAID, _start, end, end + _lockup_duration, _startStake,\r\n                   _reserveStake, declinePerBlock, _slotsOnSale, self.auction.rewardPerSlot)\r\n\r\n# @notice Move unclaimed auction rewards back to the contract owner\r\n# @dev Requires that no auction is in bidding or lockup phase\r\n@external\r\ndef retrieveUndistributedAuctionRewards():\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.auction.lockupEnd == 0, \"Auction ongoing\"\r\n    undistributed: uint256 = self.totalAuctionRewards\r\n    self.totalAuctionRewards = empty(uint256)\r\n\r\n    success: bool = self.token.transfer(self.owner, self.as_unitless_number(undistributed))\r\n    assert success, \"Transfer failed\"\r\n\r\n# @notice Enter a bid into the auction. Requires the sender's deposits + _topup >= currentPrice or\r\n#   specify _topup = 0 to automatically calculate and transfer the topup needed to make a bid at the\r\n#   current price. Beforehand the sender must have approved the ERC20 contract to allow the transfer\r\n#   of at least the topup to the auction contract via ERC20.approve(auctionContract.address, amount)\r\n# @param _topup: Set to 0 to bid current price (automatically calculating and transfering required topup),\r\n#   o/w it will be interpreted as a topup to the existing deposits\r\n# @dev Only one bid per address and auction allowed, as time of bidding also specifies the priority\r\n#   in slot allocation\r\n# @dev No bids below current auction price allowed\r\n@external\r\ndef bid(_topup: uint256):\r\n    assert self._isBiddingPhase(), \"Not in bidding phase\"\r\n    assert self.stakerSlots[msg.sender] == 0, \"Sender already bid\"\r\n\r\n    _currentAID: uint256 = self.currentAID\r\n    currentPrice: uint256 = self._getCurrentPrice()\r\n    _isVirtTokenHolder: bool = self.virtTokenHolders[msg.sender].isHolder\r\n\r\n    assert (_isVirtTokenHolder == False) or (_topup <= self.virtTokenHolders[msg.sender].limit), \"Virtual tokens above limit\"\r\n\r\n    totDeposit: uint256 = self.selfStakerDeposits[msg.sender]\r\n\r\n    # cannot modify input argument\r\n    topup: uint256 = _topup\r\n    if (currentPrice > totDeposit) and(_topup == 0):\r\n        topup = currentPrice - totDeposit\r\n    else:\r\n        assert totDeposit + topup >= currentPrice, \"Bid below current price\"\r\n\r\n    # Update deposits & stakers\r\n    self.priceAtBid[msg.sender] = currentPrice\r\n    self.selfStakerDeposits[msg.sender] += topup\r\n    slots: uint256 = min((totDeposit + topup) / currentPrice, self.auction.slotsOnSale - self.auction.slotsSold)\r\n    self.stakerSlots[msg.sender] = slots\r\n    self.auction.slotsSold += slots\r\n    self.stakers[self.auction.uniqueStakers] = msg.sender\r\n    self.auction.uniqueStakers += 1\r\n\r\n    # Transfer topup if necessary\r\n    if (topup > 0) and (_isVirtTokenHolder == False):\r\n        success: bool = self.token.transferFrom(msg.sender, self, self.as_unitless_number(topup))\r\n        assert success, \"Transfer failed\"\r\n    log Bid(_currentAID, msg.sender, currentPrice, totDeposit + topup)\r\n\r\n# @Notice Anyone can supply the correct final price to finalise the auction and calculate the number of slots each\r\n#   staker has won. Required before lock-up can be ended or withdrawals can be made\r\n# @param finalPrice: proposed solution for the final price. Throws if not the correct solution\r\n# @dev Allows to move the calculation of the price that clear the auction off-chain\r\n@external\r\ndef finaliseAuction(finalPrice: uint256):\r\n    currentPrice: uint256 = self._getCurrentPrice()\r\n    assert finalPrice >= currentPrice, \"Suggested solution below current price\"\r\n    assert self.auction.finalPrice == 0, \"Auction already finalised\"\r\n    assert self.auction.lockupEnd >= 0, \"Lockup has already ended\"\r\n\r\n    slotsOnSale: uint256 = self.auction.slotsOnSale\r\n    slotsRemaining: uint256 = slotsOnSale\r\n    slotsRemainingP1: uint256 = slotsOnSale\r\n    finalPriceP1: uint256 = finalPrice + 1\r\n\r\n    uniqueStakers_int128: int128 = convert(self.auction.uniqueStakers, int128)\r\n    staker: address = ZERO_ADDRESS\r\n    totDeposit: uint256 = 0\r\n    slots: uint256 = 0\r\n    currentSlots: uint256 = 0\r\n    _priceAtBid: uint256= 0\r\n\r\n    for i in range(MAX_SLOTS):\r\n        if i >= uniqueStakers_int128:\r\n            break\r\n\r\n        staker = self.stakers[i]\r\n        _priceAtBid = self.priceAtBid[staker]\r\n        slots = 0\r\n\r\n        if finalPrice <= _priceAtBid:\r\n            totDeposit = self.selfStakerDeposits[staker] + self.poolDeposits[staker]\r\n\r\n            if slotsRemaining > 0:\r\n                # finalPrice will always be > 0 as reserveStake required to be > 0\r\n                slots = min(totDeposit / finalPrice, slotsRemaining)\r\n                currentSlots = self.stakerSlots[staker]\r\n                if slots != currentSlots:\r\n                    self.stakerSlots[staker] = slots\r\n                slotsRemaining -= slots\r\n\r\n            if finalPriceP1 <= _priceAtBid:\r\n                slotsRemainingP1 -= min(totDeposit / finalPriceP1, slotsRemainingP1)\r\n\r\n        # later bidders dropping out of slot-allocation as earlier bidders already claim all slots at the final price\r\n        if slots == 0:\r\n            self.stakerSlots[staker] = empty(uint256)\r\n            self.stakers[i] = empty(address)\r\n\r\n    if (finalPrice == self.auction.reserveStake) and (self._isBiddingPhase() == False):\r\n        # a) reserveStake clears the auction and reserveStake + 1 does not\r\n        doesClear: bool = (slotsRemaining == 0) and (slotsRemainingP1 > 0)\r\n        # b) reserveStake does not clear the auction, accordingly neither will any other higher price\r\n        assert (doesClear or (slotsRemaining > 0)), \"reserveStake is not the best solution\"\r\n    else:\r\n        assert slotsRemaining == 0, \"finalPrice does not clear auction\"\r\n        assert slotsRemainingP1 > 0, \"Not largest price clearing the auction\"\r\n\r\n    self.auction.finalPrice = finalPrice\r\n    self.auction.slotsSold = slotsOnSale - slotsRemaining\r\n    log AuctionFinalised(self.currentAID, finalPrice, slotsOnSale - slotsRemaining)\r\n\r\n# @notice Anyone can end the lock-up of an auction, thereby allowing everyone to\r\n#   withdraw their stakes and rewards. Auction must first be finalised through finaliseAuction().\r\n@internal\r\ndef _endLockup(payoutRewards: bool):\r\n    assert self.auction.lockupEnd > 0, \"No lockup to end\"\r\n\r\n    slotsSold: uint256 = self.auction.slotsSold\r\n    rewardPerSlot_: uint256 = 0\r\n    self.earliestDelete = block.timestamp + DELETE_PERIOD\r\n\r\n    if payoutRewards:\r\n        assert self._isFinalised(), \"Not finalised\"\r\n        rewardPerSlot_ = self.auction.rewardPerSlot\r\n        self.totalAuctionRewards -= slotsSold * rewardPerSlot_\r\n\r\n    # distribute rewards & cleanup\r\n    staker: address = ZERO_ADDRESS\r\n\r\n    for i in range(MAX_SLOTS):\r\n        staker = self.stakers[i]\r\n        if staker == ZERO_ADDRESS:\r\n            break\r\n\r\n        if payoutRewards:\r\n            if self.virtTokenHolders[staker].isHolder:\r\n                self.virtTokenHolders[staker].rewards += self.stakerSlots[staker] * rewardPerSlot_\r\n            else:\r\n                self.selfStakerDeposits[staker] += self.stakerSlots[staker] * rewardPerSlot_\r\n\r\n        self.stakerSlots[staker] = empty(uint256)\r\n        if self.virtTokenHolders[staker].isHolder:\r\n            self.selfStakerDeposits[staker] = empty(uint256)\r\n\r\n    self.stakers = empty(address[MAX_SLOTS])\r\n    self.auction = empty(Auction)\r\n\r\n@external\r\ndef endLockup():\r\n    # Prevents repeated calls of this function as self.auction will get reset here\r\n    assert self.auction.finalPrice > 0, \"Auction not finalised yet or no auction to end\"\r\n    assert block.number >= self.auction.lockupEnd, \"Lockup not over\"\r\n    self._endLockup(True)\r\n    log LockupEnded(self.currentAID)\r\n\r\n# @notice The owner can clear the auction and all recorded slots in the case of an emergency and\r\n# thereby immediately lift any lockups and allow the immediate withdrawal of any made deposits.\r\n# @param payoutRewards: whether rewards get distributed to bidders\r\n@external\r\ndef abortAuction(payoutRewards: bool):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n\r\n    self._endLockup(payoutRewards)\r\n    log AuctionAborted(self.currentAID, payoutRewards)\r\n\r\n# @notice Withdraw any self-stake exceeding the required lockup. In case sender is a bidder in the\r\n#   current auction, this requires the auction to be finalised through finaliseAuction(),\r\n#   o/w _calculateSelfStakeNeeded() will throw\r\n@external\r\ndef withdrawSelfStake() -> uint256:\r\n    # not guaranteed to be initialised to 0 without setting it explicitly\r\n    withdrawal: uint256 = 0\r\n\r\n    if self.virtTokenHolders[msg.sender].isHolder:\r\n        withdrawal = self.virtTokenHolders[msg.sender].rewards\r\n        self.virtTokenHolders[msg.sender].rewards = empty(uint256)\r\n    else:\r\n        selfStake: uint256 = self.selfStakerDeposits[msg.sender]\r\n        selfStakeNeeded: uint256 = self._calculateSelfStakeNeeded(msg.sender)\r\n\r\n        if selfStake > selfStakeNeeded:\r\n            withdrawal = selfStake - selfStakeNeeded\r\n            self.selfStakerDeposits[msg.sender] -= withdrawal\r\n        elif selfStake < selfStakeNeeded:\r\n            assert False, \"Critical failure\"\r\n\r\n    success: bool = self.token.transfer(msg.sender, self.as_unitless_number(withdrawal))\r\n    assert success, \"Transfer failed\"\r\n\r\n    log SelfStakeWithdrawal(msg.sender, withdrawal)\r\n\r\n    return withdrawal\r\n\r\n# @notice Allow the owner to remove the contract, given that no auction is\r\n#   active and at least DELETE_PERIOD blocks have past since the last lock-up end.\r\n@external\r\ndef deleteContract():\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.auction.lockupEnd == 0, \"In lockup phase\"\r\n    assert block.timestamp >= self.earliestDelete, \"earliestDelete not reached\"\r\n\r\n    contractBalance: uint256 = self.token.balanceOf(self)\r\n    success: bool = self.token.transfer(self.owner, contractBalance)\r\n    assert success, \"Transfer failed\"\r\n\r\n    selfdestruct(self.owner)\r\n\r\n# @notice Allow the owner to set virtTokenHolder status for addresses, allowing them to participate\r\n#   with virtual tokens\r\n# @dev Throws if the address has existing selfStakerDeposits, active slots, a registered pool for\r\n#   this auction, unretrieved pool rewards or existing pledges\r\n# @param _address: address for which to set the value\r\n# @param _isVirtTokenHolder: new value indicating whether isVirtTokenHolder or not\r\n# @param preserveRewards: if setting isVirtTokenHolder to false and that address still has remaining rewards:\r\n#   whether to move those rewards into selfStakerDeposits or to add them back to the control of the owner\r\n#   by adding them to totalAuctionRewards\r\n@external\r\ndef setVirtTokenHolder(_address: address, _isVirtTokenHolder: bool, limit: uint256, preserveRewards: bool):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.stakerSlots[_address] == 0, \"Address has active slots\"\r\n    assert self.selfStakerDeposits[_address] == 0, \"Address has positive selfStakerDeposits\"\r\n    # assert self.registeredPools[_address].remainingReward == 0, \"Address has remainingReward\"\r\n    # assert self.pledges[_address].amount == 0, \"Address has positive pledges\"\r\n    # assert (self.registeredPools[_address].AID < self.currentAID) or (self.auction.finalPrice == 0), \"Address has a pool in ongoing auction\"\r\n\r\n    existingRewards: uint256 = self.virtTokenHolders[_address].rewards\r\n\r\n    if (_isVirtTokenHolder == False) and (existingRewards > 0):\r\n        if preserveRewards:\r\n            self.selfStakerDeposits[_address] += existingRewards\r\n        else:\r\n            self.totalAuctionRewards += existingRewards\r\n        self.virtTokenHolders[_address].rewards = empty(uint256)\r\n\r\n    self.virtTokenHolders[_address].isHolder = _isVirtTokenHolder\r\n    self.virtTokenHolders[_address].limit = limit\r\n\r\n@external\r\ndef setVirtTokenLimit(_address: address, _virtTokenLimit: uint256):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.virtTokenHolders[_address].isHolder, \"Not a virtTokenHolder\"\r\n    self.virtTokenHolders[_address].limit = _virtTokenLimit\r\n\r\n################################################################################\r\n# Getters\r\n################################################################################\r\n@external\r\n@view\r\ndef getERC20Address() -> address:\r\n    return self.token.address\r\n\r\n@external\r\n@view\r\ndef getDenominator() -> uint256:\r\n    return REWARD_PER_TOK_DENOMINATOR\r\n\r\n@external\r\n@view\r\ndef getFinalStakerSlots(staker: address) -> uint256:\r\n    assert self._isFinalised(), \"Slots not yet final\"\r\n    return self.stakerSlots[staker]\r\n\r\n# @dev Always returns an array of MAX_SLOTS with elements > unique bidders = zero\r\n@external\r\n@view\r\ndef getFinalStakers() -> address[MAX_SLOTS]:\r\n    assert self._isFinalised(), \"Stakers not yet final\"\r\n    return self.stakers\r\n\r\n@external\r\n@view\r\ndef getFinalSlotsSold() -> uint256:\r\n    assert self._isFinalised(), \"Slots not yet final\"\r\n    return self.auction.slotsSold\r\n\r\n@external\r\n@view\r\ndef getCurrentStakers() -> address[MAX_SLOTS]:\r\n   return self.stakers\r\n\r\n@external\r\n@view\r\ndef isBiddingPhase() -> bool:\r\n    return self._isBiddingPhase()\r\n\r\n@external\r\n@view\r\ndef isFinalised() -> bool:\r\n    return self._isFinalised()\r\n\r\n@external\r\n@view\r\ndef getCurrentPrice() -> uint256:\r\n    return self._getCurrentPrice()\r\n\r\n@external\r\n@view\r\ndef calculateSelfStakeNeeded(_address: address) -> uint256:\r\n    return self._calculateSelfStakeNeeded(_address)","ABI":"[{\"name\":\"Bid\",\"inputs\":[{\"name\":\"AID\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"currentPrice\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BidTest\",\"inputs\":[{\"name\":\"totaltok\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewAuction\",\"inputs\":[{\"name\":\"AID\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"start\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"end\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"lockupEnd\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"startStake\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"reserveStake\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"declinePerBlock\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"slotsOnSale\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rewardPerSlot\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AuctionFinalised\",\"inputs\":[{\"name\":\"AID\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"finalPrice\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"slotsSold\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LockupEnded\",\"inputs\":[{\"name\":\"AID\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AuctionAborted\",\"inputs\":[{\"name\":\"AID\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rewardsPaid\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SelfStakeWithdrawal\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PledgeWithdrawal\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_ERC20Address\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialiseAuction\",\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_startStake\",\"type\":\"uint256\"},{\"name\":\"_reserveStake\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_lockup_duration\",\"type\":\"uint256\"},{\"name\":\"_slotsOnSale\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":401723},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"retrieveUndistributedAuctionRewards\",\"inputs\":[],\"outputs\":[],\"gas\":34084},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"bid\",\"inputs\":[{\"name\":\"_topup\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":286285},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"finaliseAuction\",\"inputs\":[{\"name\":\"finalPrice\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":17693379},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"endLockup\",\"inputs\":[],\"outputs\":[],\"gas\":21783073},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"abortAuction\",\"inputs\":[{\"name\":\"payoutRewards\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":21781417},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdrawSelfStake\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":124931},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deleteContract\",\"inputs\":[],\"outputs\":[],\"gas\":45483},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setVirtTokenHolder\",\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_isVirtTokenHolder\",\"type\":\"bool\"},{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"preserveRewards\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":138084},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setVirtTokenLimit\",\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_virtTokenLimit\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40426},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getERC20Address\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2688},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getDenominator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getFinalStakerSlots\",\"inputs\":[{\"name\":\"staker\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":7842},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getFinalStakers\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address[200]\"}],\"gas\":443658},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getFinalSlotsSold\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":7765},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getCurrentStakers\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address[200]\"}],\"gas\":438857},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isBiddingPhase\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":12091},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isFinalised\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":5560},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getCurrentPrice\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":30721},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calculateSelfStakeNeeded\",\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":76376},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2988},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"earliestDelete\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3018},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"poolDeposits\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3263},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"selfStakerDeposits\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3293},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"priceAtBid\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3323},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"currentAID\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3138},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"auction\",\"inputs\":[],\"outputs\":[{\"name\":\"finalPrice\",\"type\":\"uint256\"},{\"name\":\"lockupEnd\",\"type\":\"uint256\"},{\"name\":\"slotsSold\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"startStake\",\"type\":\"uint256\"},{\"name\":\"reserveStake\",\"type\":\"uint256\"},{\"name\":\"declinePerBlock\",\"type\":\"uint256\"},{\"name\":\"slotsOnSale\",\"type\":\"uint256\"},{\"name\":\"rewardPerSlot\",\"type\":\"uint256\"},{\"name\":\"uniqueStakers\",\"type\":\"uint256\"}],\"gas\":26240},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalAuctionRewards\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3198},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"virtTokenHolders\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"isHolder\",\"type\":\"bool\"},{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"rewards\",\"type\":\"uint256\"}],\"gas\":8259}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000aea46a60368a7bd060eec7df8cba43b7ef41ad85","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}