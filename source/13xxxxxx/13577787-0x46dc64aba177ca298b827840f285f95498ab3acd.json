{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.7 https://hardhat.org\r\n\r\n// File contracts/helpers/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter = 1;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one `nonReentrant` function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and an `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IABCTreasury.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IABCTreasury {\r\n    function sendABCToken(address recipient, uint _amount) external;\r\n\r\n    function getTokensClaimed() external view returns(uint);\r\n    \r\n    function updateNftPriced() external;\r\n    \r\n    function updateProfitGenerated(uint _amount) external;\r\n\r\n}\r\n\r\n\r\n// File contracts/libraries/SafeMath.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/sqrtLibrary.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary sqrtLibrary {\r\n    \r\n    function sqrt(uint x) pure internal returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/PostSessionLibrary.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary PostSessionLibrary {\r\n\r\n    using sqrtLibrary for *;\r\n\r\n    /////////////////////\r\n    ///      Base     ///\r\n    /////////////////////\r\n\r\n    function calculateBase(uint finalAppraisalValue, uint userAppraisalValue) pure internal returns(uint){\r\n        uint base = 1;\r\n        uint userVal = 100 * userAppraisalValue;\r\n        for(uint i=5; i >= 1; i--) {\r\n            uint lowerOver = (100 + (i - 1)) * finalAppraisalValue;\r\n            uint upperOver = (100 + i) * finalAppraisalValue;\r\n            uint lowerUnder = (100 - i) * finalAppraisalValue;\r\n            uint upperUnder = (100 - i + 1) * finalAppraisalValue;\r\n            if (lowerOver < userVal && userVal <= upperOver) {\r\n                return base; \r\n            }\r\n            if (lowerUnder < userVal && userVal <= upperUnder) {\r\n                return base;\r\n            }\r\n            base += 1;\r\n        }\r\n        if(userVal == 100*finalAppraisalValue) {\r\n            return 6;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /////////////////////\r\n    ///    Harvest    ///\r\n    /////////////////////\r\n\r\n    // function harvestUserOver(uint _stake, uint _userAppraisal, uint _finalAppraisal) pure internal returns(uint) {\r\n    //     return _stake * (_userAppraisal*100 - 105*_finalAppraisal)/(_finalAppraisal*100);\r\n    // }\r\n    \r\n    // function harvestUserUnder(uint _stake, uint _userAppraisal, uint _finalAppraisal) pure internal returns(uint) {\r\n    //     return _stake * (95*_finalAppraisal - 100*_userAppraisal)/(_finalAppraisal*100);\r\n    // }\r\n\r\n    function harvest(uint _stake, uint _userAppraisal, uint _finalAppraisal) pure internal returns(uint) {\r\n        if(_userAppraisal*100 > 105*_finalAppraisal) {\r\n            return _stake * (_userAppraisal*100 - 105*_finalAppraisal)/(_finalAppraisal*100);\r\n        }\r\n        else if(_userAppraisal*100 < 95*_finalAppraisal) {\r\n            return _stake * (95*_finalAppraisal - 100*_userAppraisal)/(_finalAppraisal*100);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /////////////////////\r\n    ///   Commission  ///\r\n    /////////////////////   \r\n    function setCommission(uint _treasurySize) pure internal returns(uint) {\r\n        if (_treasurySize < 25000 ether) {\r\n            return 500;\r\n        }\r\n        else if(_treasurySize >= 25000 ether && _treasurySize < 50000 ether) {\r\n            return 400;\r\n        }\r\n        else if(_treasurySize >= 50000 ether && _treasurySize < 100000 ether) {\r\n            return 300;\r\n        }\r\n        else if(_treasurySize >= 100000 ether && _treasurySize < 2000000 ether) {\r\n            return 200;\r\n        }\r\n        else if(_treasurySize >= 200000 ether && _treasurySize < 400000 ether) {\r\n            return 100;\r\n        }\r\n        else if(_treasurySize >= 400000 ether && _treasurySize < 700000 ether) {\r\n            return 50;\r\n        }\r\n        else {\r\n            return 25;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/ABCTreasury.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @author Medici\r\n/// @title Treasury contract for Abacus\r\ncontract ABCTreasury {\r\n    \r\n    /* ======== UINT ======== */\r\n\r\n    uint public nftsPriced;\r\n    uint public profitGenerated;\r\n    uint public tokensClaimed;\r\n\r\n    /* ======== ADDRESS ======== */\r\n\r\n    address public auction;\r\n    address public pricingSessionFactory;\r\n    address public admin;\r\n    address public ABCToken;\r\n    address public multisig;\r\n\r\n    /* ======== CONSTRUCTOR ======== */\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /* ======== ADMIN FUNCTIONS ======== */\r\n\r\n    /// @notice set ABC token contract address \r\n    /// @param _ABCToken desired ABC token to be stored and referenced in contract\r\n    function setABCTokenAddress(address _ABCToken) onlyAdmin external {\r\n        require(ABCToken == address(0));\r\n        ABCToken = _ABCToken;\r\n    }\r\n\r\n    function setMultisig(address _multisig) onlyAdmin external {\r\n        multisig = _multisig;\r\n    }\r\n\r\n    /// @notice allow admin to withdraw funds to multisig in the case of emergency (ONLY USED IN THE CASE OF EMERGENCY)\r\n    /// @param _amountAbc value of ABC to be withdrawn from the treasury to multisig (ONLY USED IN THE CASE OF EMERGENCY)\r\n    /// @param _amountEth value of ETH to be withdrawn from the treasury to multisig (ONLY USED IN THE CASE OF EMERGENCY)\r\n    function withdraw(uint _amountAbc, uint _amountEth) onlyAdmin external {\r\n        IERC20(ABCToken).transfer(multisig, _amountAbc);\r\n        (bool sent, ) = payable(multisig).call{value: _amountEth}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n\r\n    /// @notice set newAdmin (or burn admin when the time comes)\r\n    /// @param _newAdmin desired admin address to be stored and referenced in contract\r\n    function setAdmin(address _newAdmin) onlyAdmin external {\r\n        admin = _newAdmin;\r\n    }\r\n\r\n    /// @notice set pricing factory address to allow for updates\r\n    /// @param _pricingFactory desired pricing session principle address to be stored and referenced in contract\r\n    function setPricingFactory(address _pricingFactory) onlyAdmin external {\r\n        pricingSessionFactory = _pricingFactory;\r\n    }\r\n\r\n    /// @notice set auction contract for bounty auction period\r\n    /// @param _auction desired auction address to be stored and referenced in contract\r\n    function setAuction(address _auction) onlyAdmin external {\r\n        auction = _auction;\r\n    }\r\n\r\n    /* ======== CHILD FUNCTIONS ======== */\r\n    \r\n    /// @notice send ABC to users that earn \r\n    /// @param recipient the user that will be receiving ABC \r\n    /// @param _amount the amount of ABC to be transferred to the recipient\r\n    function sendABCToken(address recipient, uint _amount) external {\r\n        require(msg.sender == pricingSessionFactory || msg.sender == admin || msg.sender == auction);\r\n        IERC20(ABCToken).transfer(recipient, _amount);\r\n        tokensClaimed += _amount;\r\n    }\r\n\r\n    /// @notice Allows Factory contract to update the profit generated value\r\n    /// @param _amount the amount of profit to update profitGenerated count\r\n    function updateProfitGenerated(uint _amount) isFactory external { \r\n        profitGenerated += _amount;\r\n    }\r\n    \r\n    /// @notice Allows Factory contract to update the amount of NFTs that have been priced\r\n    function updateNftPriced() isFactory external {\r\n        nftsPriced++;\r\n    }\r\n\r\n    /* ======== FALLBACKS ======== */\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    ///@notice check that msg.sender is admin\r\n    modifier onlyAdmin() {\r\n        require(admin == msg.sender, \"not admin\");\r\n        _;\r\n    }\r\n    \r\n    ///@notice check that msg.sender is factory\r\n    modifier isFactory() {\r\n        require(msg.sender == pricingSessionFactory, \"not factory\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/PricingSession.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @author Medici\r\n/// @title Pricing session contract for Abacus\r\ncontract PricingSession is ReentrancyGuard {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /* ======== ADDRESS ======== */\r\n\r\n    address public ABCToken;\r\n    ABCTreasury public Treasury;\r\n    address public admin;\r\n    address auction;\r\n\r\n    /* ======== BOOL ======== */\r\n\r\n    bool auctionStatus;\r\n    \r\n    /* ======== MAPPINGS ======== */\r\n\r\n    /// @notice maps each user to their total profit earned\r\n    mapping(address => uint) public payoutStored;\r\n\r\n    /// @notice maps each NFT to its current nonce value\r\n    mapping(address => mapping (uint => uint)) public nftNonce; \r\n\r\n    mapping(uint => mapping(address => mapping(uint => VotingSessionMapping))) NftSessionMap;\r\n\r\n    /// @notice maps each NFT pricing session (nonce dependent) to its necessary session checks (i.e. checking session progression)\r\n    /// @dev nonce => tokenAddress => tokenId => session metadata\r\n    mapping(uint => mapping(address => mapping(uint => VotingSessionChecks))) public NftSessionCheck;\r\n\r\n    /// @notice maps each NFT pricing session (nonce dependent) to its necessary session core values (i.e. total participants, total stake, etc...)\r\n    mapping(uint => mapping(address => mapping(uint => VotingSessionCore))) public NftSessionCore;\r\n\r\n    /// @notice maps each NFT pricing session (nonce dependent) to its final appraisal value output\r\n    mapping(uint => mapping(address => mapping(uint => uint))) public finalAppraisalValue;\r\n    \r\n    /* ======== STRUCTS ======== */\r\n\r\n    /// @notice tracks all of the mappings necessary to operate a session\r\n    struct VotingSessionMapping {\r\n\r\n        mapping (address => uint) voterCheck;\r\n        mapping (address => uint) winnerPoints;\r\n        mapping (address => uint) amountHarvested;\r\n        mapping (address => Voter) nftVotes;\r\n    }\r\n\r\n    /// @notice track necessary session checks (i.e. whether its time to weigh votes or harvest)\r\n    struct VotingSessionChecks {\r\n\r\n        uint sessionProgression;\r\n        uint calls;\r\n        uint correct;\r\n        uint incorrect;\r\n        uint timeFinalAppraisalSet;\r\n    }\r\n\r\n    /// @notice track the core values of a session (max appraisal value, total session stake, etc...)\r\n    struct VotingSessionCore {\r\n\r\n        uint endTime;\r\n        uint lowestStake;\r\n        uint maxAppraisal;\r\n        uint totalAppraisalValue;\r\n        uint totalSessionStake;\r\n        uint totalProfit;\r\n        uint totalWinnerPoints;\r\n        uint totalVotes;\r\n        uint uniqueVoters;\r\n        uint votingTime;\r\n    }\r\n\r\n    /// @notice track voter information\r\n    struct Voter {\r\n\r\n        bytes32 concealedAppraisal;\r\n        uint base;\r\n        uint appraisal;\r\n        uint stake;\r\n    }\r\n\r\n    /* ======== EVENTS ======== */\r\n\r\n    event PricingSessionCreated(address creator_, address nftAddress_, uint tokenid_, uint initialAppraisal_, uint bounty_);\r\n    event newAppraisalAdded(address voter_, uint stake_, uint appraisal, uint weight);\r\n    event finalAppraisalDetermined(uint finalAppraisal, uint amountOfParticipants, uint totalStake);\r\n    event lossHarvestedFromUser(address user_, uint harvested);\r\n    event ethClaimedByUser(address user_, uint ethClaimed);\r\n    event ethToPPExchange(address user_, uint ethExchanged, uint ppSent);\r\n    event sessionEnded(address nftAddress, uint tokenid, uint nonce);\r\n\r\n    /* ======== CONSTRUCTOR ======== */\r\n\r\n    constructor(address _ABCToken, address _treasury, address _auction) {\r\n        ABCToken = _ABCToken;\r\n        Treasury = ABCTreasury(payable(_treasury));\r\n        auction = _auction;\r\n        admin = msg.sender;\r\n        auctionStatus = true;\r\n    }\r\n\r\n    /// @notice set the auction address to be referenced throughout the contract\r\n    /// @param _auction desired auction address to be stored and referenced in contract\r\n    function setAuction(address _auction) external {\r\n        require(msg.sender == admin);\r\n        auction = _auction;\r\n    }\r\n\r\n    /// @notice set the auction status based on the active/inactive status of the bounty auction\r\n    /// @param status desired auction status to be stored and referenced in contract\r\n    function setAuctionStatus(bool status) external {\r\n        require(msg.sender == admin); \r\n        auctionStatus = status;\r\n    }\r\n\r\n    /// @notice Allow user to create new session and attach initial bounty\r\n    /**\r\n    @dev NFT sessions are indexed using a nonce per specific nft.\r\n    The mapping is done by mapping a nonce to an NFT address to the \r\n    NFT token id. \r\n    */ \r\n    /// @param nftAddress NFT contract address of desired NFT to be priced\r\n    /// @param tokenid NFT token id of desired NFT to be priced \r\n    /// @param _initialAppraisal appraisal value for max value to be instantiated against\r\n    /// @param _votingTime voting window duration\r\n    function createNewSession(\r\n        address nftAddress,\r\n        uint tokenid,\r\n        uint _initialAppraisal,\r\n        uint _votingTime\r\n    ) stopOverwrite(nftAddress, tokenid) external payable {\r\n        require(_votingTime <= 1 days && (!auctionStatus || msg.sender == auction));\r\n        VotingSessionCore storage sessionCore = NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        uint abcCost = 0.005 ether *(ethToAbc());\r\n        (bool abcSent) = IERC20(ABCToken).transferFrom(msg.sender, address(Treasury), abcCost);\r\n        require(abcSent);\r\n        if(nftNonce[nftAddress][tokenid] == 0 || getStatus(nftAddress, tokenid) == 5) {}\r\n        else if(block.timestamp > sessionCore.endTime + sessionCore.votingTime * 3) {\r\n            _executeEnd(nftAddress, tokenid);\r\n        }\r\n        nftNonce[nftAddress][tokenid]++;\r\n        VotingSessionCore storage sessionCoreNew = NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        sessionCoreNew.votingTime = _votingTime;\r\n        sessionCoreNew.maxAppraisal = 69420 * _initialAppraisal / 1000;\r\n        sessionCoreNew.lowestStake = 100000 ether;\r\n        sessionCoreNew.endTime = block.timestamp + _votingTime;\r\n        sessionCoreNew.totalSessionStake = msg.value;\r\n        emit PricingSessionCreated(msg.sender, nftAddress, tokenid, _initialAppraisal, msg.value);\r\n    }\r\n\r\n    /* ======== USER VOTE FUNCTIONS ======== */\r\n    \r\n    /// @notice Allows user to set vote in party \r\n    /** \r\n    @dev Users appraisal is hashed so users can't track final appraisal and submit vote right before session ends.\r\n    Therefore, users must remember their appraisal in order to reveal their appraisal in the next function.\r\n    */\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    /// @param concealedAppraisal concealed bid that is a hash of the appraisooooors appraisal value, wallet address, and seed number\r\n    function setVote(\r\n        address nftAddress,\r\n        uint tokenid,\r\n        bytes32 concealedAppraisal\r\n    ) properVote(nftAddress, tokenid) payable external {\r\n        uint currentNonce = nftNonce[nftAddress][tokenid];\r\n        VotingSessionCore storage sessionCore = NftSessionCore[currentNonce][nftAddress][tokenid];\r\n        VotingSessionMapping storage sessionMap = NftSessionMap[currentNonce][nftAddress][tokenid];\r\n        require(sessionCore.endTime > block.timestamp);\r\n        sessionMap.voterCheck[msg.sender] = 1;\r\n        if (msg.value < sessionCore.lowestStake) {\r\n            sessionCore.lowestStake = msg.value;\r\n        }\r\n        sessionCore.uniqueVoters++;\r\n        sessionCore.totalSessionStake = sessionCore.totalSessionStake.add(msg.value);\r\n        sessionMap.nftVotes[msg.sender].concealedAppraisal = concealedAppraisal;\r\n        sessionMap.nftVotes[msg.sender].stake = msg.value;\r\n    }\r\n\r\n    /// @notice allow user to update value inputs of their vote while voting is still active\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    /// @param concealedAppraisal concealed bid that is a hash of the appraisooooors new appraisal value, wallet address, and seed number\r\n    function updateVote(\r\n        address nftAddress,\r\n        uint tokenid,\r\n        bytes32 concealedAppraisal\r\n    ) external {\r\n        uint currentNonce = nftNonce[nftAddress][tokenid];\r\n        VotingSessionCore storage sessionCore = NftSessionCore[currentNonce][nftAddress][tokenid];\r\n        VotingSessionMapping storage sessionMap = NftSessionMap[currentNonce][nftAddress][tokenid];\r\n        require(sessionMap.voterCheck[msg.sender] == 1);\r\n        require(sessionCore.endTime > block.timestamp);\r\n        sessionMap.nftVotes[msg.sender].concealedAppraisal = concealedAppraisal;\r\n    }\r\n\r\n    /// @notice Reveals user vote and weights based on the sessions lowest stake\r\n    /**\r\n    @dev calculation can be found in the weightVoteLibrary.sol file. \r\n    Votes are weighted as sqrt(userStake/lowestStake). Depending on a votes weight\r\n    it is then added as multiple votes of that appraisal (i.e. if someoneone has\r\n    voting weight of 8, 8 votes are submitted using their appraisal).\r\n    */\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    /// @param appraisal appraisooooor appraisal value used to unlock concealed appraisal\r\n    /// @param seedNum appraisooooor seed number used to unlock concealed appraisal\r\n    function weightVote(address nftAddress, uint tokenid, uint appraisal, uint seedNum) checkParticipation(nftAddress, tokenid) nonReentrant external {\r\n        uint currentNonce = nftNonce[nftAddress][tokenid];\r\n        VotingSessionCore storage sessionCore = NftSessionCore[currentNonce][nftAddress][tokenid];\r\n        VotingSessionChecks storage sessionCheck = NftSessionCheck[currentNonce][nftAddress][tokenid];\r\n        VotingSessionMapping storage sessionMap = NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        require(sessionCheck.sessionProgression < 2\r\n                && sessionCore.endTime < block.timestamp\r\n                && sessionMap.voterCheck[msg.sender] == 1\r\n                && sessionMap.nftVotes[msg.sender].concealedAppraisal == keccak256(abi.encodePacked(appraisal, msg.sender, seedNum))\r\n                && sessionCore.maxAppraisal >= appraisal\r\n        );\r\n        sessionMap.voterCheck[msg.sender] = 2;\r\n        if(sessionCheck.sessionProgression == 0) {\r\n            sessionCheck.sessionProgression = 1;\r\n        }\r\n        sessionMap.nftVotes[msg.sender].appraisal = appraisal;\r\n        uint weight = sqrtLibrary.sqrt(sessionMap.nftVotes[msg.sender].stake/sessionCore.lowestStake);\r\n        sessionCore.totalVotes += weight;\r\n        sessionCheck.calls++;\r\n        \r\n        sessionCore.totalAppraisalValue = sessionCore.totalAppraisalValue.add((weight) * appraisal);\r\n        emit newAppraisalAdded(msg.sender, sessionMap.nftVotes[msg.sender].stake, appraisal, weight);\r\n        if(sessionCheck.calls == sessionCore.uniqueVoters || sessionCore.endTime + sessionCore.votingTime < block.timestamp) {\r\n            sessionCheck.sessionProgression = 2;\r\n            sessionCore.uniqueVoters = sessionCheck.calls;\r\n            sessionCheck.calls = 0;\r\n        }\r\n    }\r\n    \r\n    /// @notice takes average of appraisals and outputs a final appraisal value.\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function setFinalAppraisal(address nftAddress, uint tokenid) nonReentrant external {\r\n        VotingSessionCore storage sessionCore = NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        VotingSessionChecks storage sessionCheck = NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        require(\r\n            (block.timestamp > sessionCore.endTime + sessionCore.votingTime || sessionCheck.sessionProgression == 2)\r\n            && sessionCheck.sessionProgression <= 2\r\n        );\r\n        Treasury.updateNftPriced();\r\n        if(sessionCheck.calls != 0) {\r\n            sessionCore.uniqueVoters = sessionCheck.calls;\r\n        }\r\n        sessionCheck.calls = 0;\r\n        sessionCheck.timeFinalAppraisalSet = block.timestamp;\r\n        finalAppraisalValue[nftNonce[nftAddress][tokenid]][nftAddress][tokenid] = (sessionCore.totalAppraisalValue)/(sessionCore.totalVotes);\r\n        sessionCheck.sessionProgression = 3;\r\n        emit finalAppraisalDetermined(finalAppraisalValue[nftNonce[nftAddress][tokenid]][nftAddress][tokenid], sessionCore.uniqueVoters, sessionCore.totalSessionStake);\r\n    }\r\n\r\n    /// @notice Calculates users base and harvests their loss before returning remaining stake\r\n    /**\r\n    @dev A couple notes:\r\n    1. Base is calculated based on margin of error.\r\n        > +/- 5% = 1\r\n        > +/- 4% = 2\r\n        > +/- 3% = 3\r\n        > +/- 2% = 4\r\n        > +/- 1% = 5\r\n        > Exact = 6\r\n    2. winnerPoints are calculated based on --> base * stake\r\n    3. Losses are harvested based on --> (margin of error - 5%) * stake\r\n    */\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function harvest(address nftAddress, uint tokenid) checkParticipation(nftAddress, tokenid) nonReentrant external {\r\n        VotingSessionCore storage sessionCore = NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        VotingSessionChecks storage sessionCheck = NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        VotingSessionMapping storage sessionMap = NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        require(\r\n            sessionCheck.sessionProgression == 3\r\n            && sessionMap.voterCheck[msg.sender] == 2\r\n        );\r\n        sessionCheck.calls++;\r\n        sessionMap.voterCheck[msg.sender] = 3;\r\n        sessionMap.nftVotes[msg.sender].base = \r\n            PostSessionLibrary.calculateBase(\r\n                finalAppraisalValue[nftNonce[nftAddress][tokenid]][nftAddress][tokenid], \r\n                sessionMap.nftVotes[msg.sender].appraisal\r\n            );\r\n        uint weight = sqrtLibrary.sqrt(sessionMap.nftVotes[msg.sender].stake/sessionCore.lowestStake);\r\n        \r\n        if(NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].nftVotes[msg.sender].base > 0) {\r\n            sessionCore.totalWinnerPoints += sessionMap.nftVotes[msg.sender].base * weight;\r\n            sessionMap.winnerPoints[msg.sender] = sessionMap.nftVotes[msg.sender].base * weight;\r\n            sessionCheck.correct += weight;\r\n        }\r\n        else {\r\n            sessionCheck.incorrect += weight;\r\n        }\r\n        \r\n       sessionMap.amountHarvested[msg.sender] = PostSessionLibrary.harvest( \r\n            sessionMap.nftVotes[msg.sender].stake, \r\n            sessionMap.nftVotes[msg.sender].appraisal,\r\n            finalAppraisalValue[nftNonce[nftAddress][tokenid]][nftAddress][tokenid]\r\n        );\r\n\r\n        sessionMap.nftVotes[msg.sender].stake -= sessionMap.amountHarvested[msg.sender];\r\n        uint commission = PostSessionLibrary.setCommission(address(Treasury).balance).mul(sessionMap.amountHarvested[msg.sender]).div(10000);\r\n        sessionCore.totalSessionStake -= commission;\r\n        sessionMap.amountHarvested[msg.sender] -= commission;\r\n        sessionCore.totalProfit += sessionMap.amountHarvested[msg.sender];\r\n        Treasury.updateProfitGenerated(sessionMap.amountHarvested[msg.sender]);\r\n        (bool sent, ) = payable(Treasury).call{value: commission}(\"\");\r\n        require(sent);\r\n        emit lossHarvestedFromUser(msg.sender, sessionMap.amountHarvested[msg.sender]);\r\n\r\n        if(sessionCheck.calls == sessionCore.uniqueVoters) {\r\n            sessionCheck.sessionProgression = 4;\r\n            sessionCore.uniqueVoters = sessionCheck.calls;\r\n            sessionCheck.calls = 0;\r\n        }\r\n    }\r\n\r\n    /// @notice User claims principal stake along with any earned profits in ETH or ABC form\r\n    /**\r\n    @dev \r\n    1. Calculates user principal return value\r\n    2. Enacts sybil defense mechanism\r\n    3. Edits totalProfits and totalSessionStake to reflect claim\r\n    5. Pays out principal\r\n    6. Adds profit credit to payoutStored\r\n    */\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function claim(address nftAddress, uint tokenid) checkHarvestLoss(nftAddress, tokenid) checkParticipation(nftAddress, tokenid) nonReentrant external returns(uint) {\r\n        VotingSessionCore storage sessionCore = NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        VotingSessionChecks storage sessionCheck = NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        VotingSessionMapping storage sessionMap = NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        require(\r\n            (block.timestamp > sessionCheck.timeFinalAppraisalSet + sessionCore.votingTime || sessionCheck.sessionProgression == 4)\r\n            && sessionCheck.sessionProgression <= 4\r\n            && sessionMap.voterCheck[msg.sender] == 3\r\n        );\r\n        uint principalReturn;\r\n        sessionMap.voterCheck[msg.sender] = 4;\r\n        if(sessionCheck.sessionProgression == 3) {\r\n            sessionCore.uniqueVoters = sessionCheck.calls;\r\n            sessionCheck.calls = 0;\r\n            sessionCheck.sessionProgression = 4;\r\n        }\r\n        if(sessionCheck.correct * 100 / (sessionCheck.correct + sessionCheck.incorrect) >= 90) {\r\n            principalReturn = sessionMap.nftVotes[msg.sender].stake + sessionMap.amountHarvested[msg.sender];\r\n        }\r\n        else {\r\n            principalReturn = sessionMap.nftVotes[msg.sender].stake;\r\n        }\r\n        sessionCheck.calls++;\r\n        uint payout;\r\n        if(sessionMap.winnerPoints[msg.sender] == 0) {\r\n            payout = 0;\r\n        }\r\n        else {\r\n            payout = sessionCore.totalProfit * sessionMap.winnerPoints[msg.sender] / sessionCore.totalWinnerPoints;\r\n        }\r\n        payoutStored[msg.sender] += payout;\r\n        sessionCore.totalProfit -= payout;\r\n        sessionCore.totalSessionStake -= payout + principalReturn;\r\n        sessionCore.totalWinnerPoints -= sessionMap.winnerPoints[msg.sender];\r\n        sessionMap.winnerPoints[msg.sender] = 0;\r\n        (bool sent1, ) = payable(msg.sender).call{value: principalReturn}(\"\");\r\n        require(sent1);\r\n        if(sessionCheck.calls == sessionCore.uniqueVoters || block.timestamp > sessionCheck.timeFinalAppraisalSet + sessionCore.votingTime*2) {\r\n            _executeEnd(nftAddress, tokenid);\r\n            return 0;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n    \r\n    /// @notice Custodial function to clear funds and remove session as child\r\n    /// @dev Caller receives 10% of the funds that are meant to be cleared\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function endSession(address nftAddress, uint tokenid) public {\r\n        VotingSessionCore storage sessionCore = NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        VotingSessionChecks storage sessionCheck = NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        require((block.timestamp > sessionCheck.timeFinalAppraisalSet + sessionCore.votingTime * 2) || sessionCheck.sessionProgression == 5, \"Session not complete\");\r\n        _executeEnd(nftAddress, tokenid);\r\n    }\r\n\r\n    /// @notice allows user to claim batched earnings\r\n    /// @param trigger denotes whether the user desires it in ETH (1) or ABC (2)\r\n    function claimProfitsEarned(uint trigger, uint _amount) nonReentrant external {\r\n        require(trigger == 1 || trigger == 2);\r\n        require(payoutStored[msg.sender] >= _amount);\r\n        if(trigger == 1) {\r\n            (bool sent1, ) = payable(msg.sender).call{value: _amount}(\"\");\r\n            require(sent1);\r\n            payoutStored[msg.sender] -= _amount;\r\n            emit ethClaimedByUser(msg.sender, _amount);\r\n        }\r\n        else if(trigger == 2) {\r\n            uint abcAmount = _amount / (0.00005 ether + 0.000015 ether * Treasury.tokensClaimed()/(1000000*1e18));\r\n            uint abcPayout = ((_amount / (0.00005 ether + 0.000015 ether * Treasury.tokensClaimed()/(1000000*1e18))) + (_amount / (0.00005 ether + 0.000015 ether * Treasury.tokensClaimed() + abcAmount) / (1000000*1e18)) / 2);\r\n            (bool sent3, ) = payable(Treasury).call{value: _amount}(\"\");\r\n            require(sent3);\r\n            payoutStored[msg.sender] -= _amount;\r\n            Treasury.sendABCToken(msg.sender, abcPayout * 1e18);\r\n            emit ethToPPExchange(msg.sender, _amount, abcPayout);\r\n        }\r\n    } \r\n\r\n    /* ======== INTERNAL FUNCTIONS ======== */\r\n\r\n    /// @notice executes custodial actions to end a session\r\n    /** @dev Clears session claims to funds, distributes 95% of residual funds\r\n    to treasury and the other 5% to the caller. Then proceeds to set the total\r\n    session stake to 0 and emit an end session event to signify session completion. \r\n     */\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function _executeEnd(address nftAddress, uint tokenid) internal {\r\n        VotingSessionCore storage sessionCore = NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        VotingSessionChecks storage sessionCheck = NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid];\r\n        sessionCheck.sessionProgression = 5;\r\n        uint tPayout = 95*sessionCore.totalSessionStake/100;\r\n        uint cPayout = sessionCore.totalSessionStake - tPayout;\r\n        (bool sent, ) = payable(Treasury).call{value: tPayout}(\"\");\r\n        require(sent);\r\n        (bool sent1, ) = payable(msg.sender).call{value: cPayout}(\"\");\r\n        require(sent1);\r\n        sessionCore.totalSessionStake = 0;\r\n        emit sessionEnded(nftAddress, tokenid, nftNonce[nftAddress][tokenid]);\r\n    }\r\n\r\n    /* ======== FUND INCREASE ======== */\r\n\r\n    /// @notice allow any user to add additional bounty on session of their choice\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function addToBounty(address nftAddress, uint tokenid) payable external {\r\n        require(NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].endTime > block.timestamp);\r\n        NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].totalSessionStake += msg.value;\r\n    }\r\n    \r\n    /// @notice allow any user to support any user of their choice\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    /// @param user target appraisooooor address for stake to be added to\r\n    function addToAppraisal(address nftAddress, uint tokenid, address user) payable external {\r\n        require(\r\n            NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].voterCheck[user] == 1\r\n            && NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].endTime > block.timestamp\r\n        );\r\n        NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].nftVotes[user].stake += msg.value;\r\n    }\r\n\r\n    /* ======== VIEW FUNCTIONS ======== */\r\n\r\n    /// @notice returns the status of the session in question\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function getStatus(address nftAddress, uint tokenid) view public returns(uint) {\r\n        return NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].sessionProgression;\r\n    }\r\n\r\n    /// @notice returns the current spot exchange rate of ETH to ABC\r\n    function ethToAbc() view public returns(uint) {\r\n        return 1e18 / (0.00005 ether + 0.000015 ether * Treasury.tokensClaimed() / (1000000*1e18));\r\n    }\r\n\r\n    /// @notice returns the payout earned from the current session\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    function getEthPayout(address nftAddress, uint tokenid) view external returns(uint) {\r\n        if(NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].totalWinnerPoints == 0) {\r\n            return 0;\r\n        }\r\n        return NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].totalSessionStake * NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].winnerPoints[msg.sender] / NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].totalWinnerPoints;\r\n    }\r\n\r\n    /// @notice check the users status in terms of session interaction\r\n    /// @param nftAddress NFT contract address of NFT being appraised\r\n    /// @param tokenid NFT tokenid of NFT being appraised\r\n    /// @param _user appraisooooor who's session progress is of interest\r\n    function getVoterCheck(address nftAddress, uint tokenid, address _user) view external returns(uint) {\r\n        return NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].voterCheck[_user];\r\n    }\r\n\r\n    /* ======== FALLBACK FUNCTIONS ======== */\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /// @notice stop users from being able to create multiple sessions for the same NFT at the same time\r\n    modifier stopOverwrite(\r\n        address nftAddress, \r\n        uint tokenid\r\n    ) {\r\n        require(\r\n            nftNonce[nftAddress][tokenid] == 0 \r\n            || getStatus(nftAddress, tokenid) == 5\r\n            || block.timestamp > NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].endTime + NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].votingTime * 3\r\n        );\r\n        _;\r\n    }\r\n    \r\n    /// @notice makes sure that a user that submits a vote satisfies the proper voting parameters\r\n    modifier properVote(\r\n        address nftAddress,\r\n        uint tokenid\r\n    ) {\r\n        require(\r\n            NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].voterCheck[msg.sender] == 0\r\n            && msg.value >= 0.005 ether\r\n        );\r\n        _;\r\n    }\r\n    \r\n    /// @notice checks the participation of the msg.sender \r\n    modifier checkParticipation(\r\n        address nftAddress,\r\n        uint tokenid\r\n    ) {\r\n        require(NftSessionMap[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].voterCheck[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    /// @notice makes sure harvest loss is either complete or the time constraint is up so now users can go claim\r\n    modifier checkHarvestLoss(\r\n        address nftAddress,\r\n        uint tokenid\r\n    ) {\r\n        require(\r\n            NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].sessionProgression == 4\r\n            || block.timestamp > (NftSessionCheck[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].timeFinalAppraisalSet + NftSessionCore[nftNonce[nftAddress][tokenid]][nftAddress][tokenid].votingTime)\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Auction.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n///@author Medici\r\n///@title Bounty auction contract for Abacus\r\ncontract BountyAuction is ReentrancyGuard {\r\n\r\n    /// @notice store pricing session address \r\n    PricingSession public session;\r\n\r\n    /// @notice store treasury address\r\n    ABCTreasury public treasury;\r\n\r\n    /* ======== ADDRESS ======== */\r\n\r\n    /// @notice store contract admin address\r\n    address public admin;\r\n\r\n    /// @notice store ABC token contract\r\n    address public ABCToken;\r\n\r\n    /* ======== BOOL ======== */\r\n\r\n    /// @notice track auction active status \r\n    bool public auctionStatus;\r\n\r\n    /// @notice used for customizable first session timeline\r\n    bool public firstSession;\r\n\r\n    /* ======== UINT ======== */\r\n\r\n    /// @notice used to map to current bounty auction\r\n    uint public nonce;\r\n\r\n    /* ======== MAPPINGS ======== */\r\n\r\n    /*//////////////////////////////\r\n    //     PER AUCTION STORAGE    //\r\n    //////////////////////////////*/\r\n\r\n    /// @notice maps the auction nonce to it's highest bid value\r\n    mapping(uint => uint) public highestBid;\r\n    \r\n    /// @notice maps the auction nonce to it's highest bidder\r\n    mapping(uint => address) public highestBidder;\r\n\r\n    /// @notice maps the auction nonce to it's end timestamp\r\n    mapping(uint => uint) public endTime;\r\n    \r\n    /// @notice maps the auction nonce to it's winner\r\n    mapping(uint => address) public winners;\r\n    \r\n    /// @notice maps the action to all it's votes mapped to the voter\r\n    mapping(uint => mapping(address => AuctionVote)) public userVote;\r\n\r\n    /*//////////////////////////////\r\n    //     PER ACCOUNT STORAGE    //\r\n    //////////////////////////////*/\r\n\r\n    mapping(address => uint) bidTime;\r\n\r\n    mapping(address => uint) tvl;\r\n\r\n    /* ======== STRUCTS ======== */\r\n\r\n    /// @notice stores bidders core information\r\n    struct AuctionVote {\r\n\r\n        address nftAddress;\r\n        uint tokenid;\r\n        uint intitialAppraisal;\r\n        uint bid;\r\n    }\r\n\r\n    /* ======== EVENTS ======== */\r\n    event newBidSubmitted(address _bidder, uint _bidAmount, address _nftAddress, uint _tokenid, uint _initialAppraisal);\r\n    event auctionEnded(address _highestBidder, uint _highestBid, address _nftAddress, uint _tokenid, uint _initialAppraisal);\r\n\r\n    /* ======== Constructor ======== */\r\n\r\n    constructor() {\r\n        \r\n        /// @notice set contract admin\r\n        admin = msg.sender;\r\n\r\n        /// @notice set session account status to signify auction is active\r\n        auctionStatus = true;\r\n    }\r\n\r\n    /* ======== ADMIN ======== */\r\n    \r\n    ///@notice toggles active status of Auction contract\r\n    function toggleAuction() external {\r\n        require(msg.sender == admin);\r\n        auctionStatus = !auctionStatus;\r\n        nonce++;\r\n    }\r\n\r\n    /// @notice set session contract to be stored\r\n    /// @param _session address of desired Pricing Session principle contract\r\n    function setSessionContract(address _session) external {\r\n        require(msg.sender == admin);\r\n        session = PricingSession(payable(_session));\r\n    }\r\n\r\n    /// @notice set treasury contract to be stored\r\n    /// @param _treasury address of desired ABC treasury address\r\n    function setTreasury(address _treasury) external {\r\n        require(msg.sender == admin);\r\n        treasury = ABCTreasury(payable(_treasury));\r\n    }\r\n\r\n    /// @notice set token contract to be stored\r\n    /// @param _token address of desired ABC token contract\r\n    function setToken(address _token) external {\r\n        require(msg.sender == admin);\r\n        ABCToken = _token;\r\n    }\r\n\r\n    /// @notice change the state of first session once first auction is complete\r\n    /// @param _state bool representative of whether or not we're currently in the first session\r\n    function setFirst(bool _state) external {\r\n        require(msg.sender == admin);\r\n        firstSession = _state;\r\n    }\r\n\r\n    /* ======== AUCTION INTERACTION ======== */\r\n\r\n    /// @notice allow user to submit new bid\r\n    /// @param _nftAddress - address of the ERC721/ERC1155 token\r\n    /// @param _tokenid - ID of the token\r\n    /// @param _initialAppraisal - initial nft appraisal \r\n    function newBid(address _nftAddress, uint _tokenid, uint _initialAppraisal) nonReentrant payable external {\r\n        require(\r\n            msg.value > highestBid[nonce]\r\n            && auctionStatus\r\n            && (session.nftNonce(_nftAddress,_tokenid) == 0 || session.getStatus(_nftAddress, _tokenid) == 5)\r\n        );\r\n        bidTime[msg.sender] = block.timestamp;\r\n        highestBidder[nonce] = msg.sender;\r\n        highestBid[nonce] = msg.value;\r\n        tvl[msg.sender] -= userVote[nonce][msg.sender].bid;\r\n        (bool sent, ) = payable(msg.sender).call{value: userVote[nonce][msg.sender].bid}(\"\");\r\n        require(sent);\r\n        userVote[nonce][msg.sender].nftAddress = _nftAddress;\r\n        userVote[nonce][msg.sender].tokenid = _tokenid;\r\n        userVote[nonce][msg.sender].intitialAppraisal = _initialAppraisal;\r\n        userVote[nonce][msg.sender].bid = msg.value;\r\n        tvl[msg.sender] += msg.value;\r\n        emit newBidSubmitted(msg.sender, msg.value, _nftAddress, _tokenid, _initialAppraisal);\r\n    }\r\n\r\n    /// @notice allow user to change nft that they'd like appraised if they win\r\n    /// @param _nftAddress users desired NFT address for session to be created\r\n    /// @param _tokenid users desired tokenid for session to be created\r\n    /// @param _initialAppraisal users desired initial appraisal value for session to be created\r\n    function changeInfo(address _nftAddress, uint _tokenid, uint _initialAppraisal) external {\r\n        require(userVote[nonce][msg.sender].nftAddress != address(0));\r\n        userVote[nonce][msg.sender].nftAddress = _nftAddress;\r\n        userVote[nonce][msg.sender].tokenid = _tokenid;\r\n        userVote[nonce][msg.sender].intitialAppraisal = _initialAppraisal;\r\n    }\r\n\r\n    /// @notice triggered when auction ends, starts session for highest bidder\r\n    function endAuction() nonReentrant external {\r\n        if(firstSession) {\r\n            require(msg.sender == admin);\r\n        }\r\n        require(endTime[nonce] < block.timestamp && auctionStatus);\r\n        treasury.sendABCToken(address(this), 0.005 ether * session.ethToAbc());\r\n        session.createNewSession(\r\n            userVote[nonce][highestBidder[nonce]].nftAddress, \r\n            userVote[nonce][highestBidder[nonce]].tokenid,\r\n            userVote[nonce][highestBidder[nonce]].intitialAppraisal,\r\n            86400\r\n        );\r\n        uint bountySend = userVote[nonce][highestBidder[nonce]].bid;\r\n        userVote[nonce][highestBidder[nonce]].bid = 0;\r\n        tvl[highestBidder[nonce]] -= bountySend;\r\n        endTime[++nonce] = block.timestamp + 86400;\r\n        (bool sent, ) = payable(session).call{value: bountySend}(\"\");\r\n        require(sent);\r\n        emit auctionEnded(\r\n            highestBidder[nonce], \r\n            userVote[nonce][highestBidder[nonce]].bid, \r\n            userVote[nonce][highestBidder[nonce]].nftAddress, \r\n            userVote[nonce][highestBidder[nonce]].tokenid, \r\n            userVote[nonce][highestBidder[nonce]].intitialAppraisal\r\n        );\r\n    }\r\n\r\n    /// @notice allows users to claim non-employed funds\r\n    function claim() nonReentrant external {\r\n        uint returnValue;\r\n        if(highestBidder[nonce] != msg.sender) {\r\n            returnValue = tvl[msg.sender];\r\n            userVote[nonce][msg.sender].bid = 0;\r\n        }\r\n        else {\r\n            returnValue = tvl[msg.sender] - userVote[nonce][msg.sender].bid;\r\n        }\r\n        tvl[msg.sender] -= returnValue;\r\n        (bool sent, ) = payable(msg.sender).call{value: returnValue}(\"\");\r\n        require(sent);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_highestBidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_highestBid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_initialAppraisal\",\"type\":\"uint256\"}],\"name\":\"auctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_initialAppraisal\",\"type\":\"uint256\"}],\"name\":\"newBidSubmitted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ABCToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialAppraisal\",\"type\":\"uint256\"}],\"name\":\"changeInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstSession\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"highestBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"highestBidder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialAppraisal\",\"type\":\"uint256\"}],\"name\":\"newBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"session\",\"outputs\":[{\"internalType\":\"contract PricingSession\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setFirst\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_session\",\"type\":\"address\"}],\"name\":\"setSessionContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"contract ABCTreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intitialAppraisal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BountyAuction","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://de3ade7582de7776d817050a6dc334fc3a1439dffe3ae5dcf7d34be59944df60"}]}