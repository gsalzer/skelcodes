{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/distribution/DistributionLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {BeaconStorage} from \\\"../lib/upgradable/BeaconStorage.sol\\\";\\nimport {Governable} from \\\"../lib/Governable.sol\\\";\\nimport {IBeacon} from \\\"../lib/upgradable/interface/IBeacon.sol\\\";\\nimport {DistributionStorage} from \\\"./DistributionStorage.sol\\\";\\nimport {IDistributionLogic} from \\\"./interface/IDistributionLogic.sol\\\";\\nimport {IMirrorTokenLogic} from \\\"../governance/token/interface/IMirrorTokenLogic.sol\\\";\\nimport {Pausable} from \\\"../lib/Pausable.sol\\\";\\n\\ncontract DistributionLogic is\\n    BeaconStorage,\\n    Governable,\\n    DistributionStorage,\\n    Pausable,\\n    IDistributionLogic\\n{\\n    /// @notice Logic version\\n    uint256 public constant override version = 0;\\n\\n    // ============ Structs ============\\n\\n    struct Registrable {\\n        address member;\\n        string label;\\n        uint256 blockNumber;\\n    }\\n\\n    // ============ Events ============\\n\\n    event Registered(address account, string label);\\n\\n    event Epoch(uint256 startBlock, uint256 claimablePerBlock);\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyTreasury() {\\n        require(msg.sender == treasury, \\\"only treasury can distribute\\\");\\n        _;\\n    }\\n\\n    modifier onlyRegistered(address account) {\\n        require(registered[account] != 0, \\\"must be registered to claim\\\");\\n        _;\\n    }\\n\\n    modifier notBanned(address account) {\\n        require(!banned[account], \\\"account banned\\\");\\n        _;\\n    }\\n\\n    // ============ Configuration ============\\n    /**\\n     * @dev The owner will be the owner of the logic contract, not the proxy.\\n     */\\n    constructor(\\n        address beacon,\\n        address owner_,\\n        bytes32 rootNode_,\\n        address ensRegistry_\\n    )\\n        BeaconStorage(beacon)\\n        Governable(owner_)\\n        DistributionStorage(rootNode_, ensRegistry_)\\n        Pausable(true)\\n    {}\\n\\n    // ============ Configuration ============\\n\\n    /*\\n        These should all be `onlyGovernance`\\n    */\\n\\n    function changeRegistrationReward(uint256 registrationReward_)\\n        public\\n        onlyGovernance\\n    {\\n        registrationReward = registrationReward_;\\n    }\\n\\n    function changeTreasury(address treasury_) public onlyGovernance {\\n        treasury = treasury_;\\n    }\\n\\n    function changeTeamRatio(uint256 teamRatio_) public onlyGovernance {\\n        teamRatio = teamRatio_;\\n    }\\n\\n    function changeTeam(address team_) public onlyGovernance {\\n        team = team_;\\n    }\\n\\n    function changeContributionFactor(uint256 contributionsFactor_)\\n        public\\n        onlyGovernance\\n    {\\n        contributionsFactor = contributionsFactor_;\\n    }\\n\\n    function createEpoch(DistributionEpoch memory epoch) public onlyGovernance {\\n        if (numEpochs > 0) {\\n            DistributionEpoch memory currentEpoch = epochs[numEpochs - 1];\\n            require(\\n                epoch.startBlock > currentEpoch.startBlock,\\n                \\\"epoch startBlock must be ahead of current epoch\\\"\\n            );\\n        }\\n\\n        epochs.push(epoch);\\n        numEpochs += 1;\\n\\n        emit Epoch(epoch.startBlock, epoch.claimablePerBlock);\\n    }\\n\\n    function ban(address account) public onlyGovernance {\\n        banned[account] = true;\\n    }\\n\\n    function unban(address account) public onlyGovernance {\\n        banned[account] = false;\\n    }\\n\\n    /// @notice pause reward claims\\n    function pause() public onlyGovernance {\\n        _pause();\\n    }\\n\\n    /// @notice unpause reward claims\\n    function unpause() public onlyGovernance {\\n        _unpause();\\n    }\\n\\n    function getLogic() public view returns (address proxyLogic) {\\n        proxyLogic = IBeacon(beacon).logic();\\n    }\\n\\n    // ============ Rewards Modifiers ============\\n\\n    function distribute(address tributary, uint256 contribution)\\n        public\\n        override\\n        onlyTreasury\\n    {\\n        contributions[tributary] += contribution;\\n    }\\n\\n    // Governance can give a single member an adjusted reward.\\n    function increaseAwards(address member, uint256 amount)\\n        public\\n        override\\n        onlyGovernance\\n    {\\n        awards[member] += amount;\\n    }\\n\\n    // ============ Claimable Views ============\\n\\n    // All members receive gov tokens over time, according to epochs.\\n    function drip(address member)\\n        public\\n        view\\n        returns (uint256 membershipReward)\\n    {\\n        // Add membership drip.\\n        for (uint256 i; i < numEpochs; i++) {\\n            membershipReward += _claimablePerEpoch(member, i);\\n        }\\n    }\\n\\n    function claimable(address member) public view override returns (uint256) {\\n        return\\n            drip(member) +\\n            awards[member] +\\n            (contributions[member] * contributionsFactor) -\\n            claimed[member];\\n    }\\n\\n    // ============ Claim Execution ============\\n\\n    function claim(address account)\\n        public\\n        override\\n        whenNotPaused\\n        notBanned(account)\\n        onlyRegistered(account)\\n    {\\n        uint256 payout = claimable(account);\\n        claimed[account] += payout;\\n\\n        // Mint the payout, don't allocate.\\n        // Also mint the team some tokens,\\n        uint256 teamTokens = (teamRatio * payout) / (100 - teamRatio);\\n\\n        _mint(team, teamTokens);\\n        _mint(account, payout);\\n\\n        lastClaimed[account] = block.number;\\n    }\\n\\n    function migrate(address from, address to) public notBanned(from) {\\n        require(msg.sender == from && msg.sender != to, \\\"cannot migrate\\\");\\n\\n        // migrate registration\\n        registered[to] = registered[from];\\n        registered[from] = 0;\\n\\n        // migrate contributions\\n        contributions[to] = contributions[from];\\n        contributions[from] = 0;\\n\\n        // migrate claimed amount\\n        claimed[to] = claimed[from];\\n        claimed[from] = 0;\\n\\n        // migrate last claimed\\n        lastClaimed[to] = lastClaimed[from];\\n        lastClaimed[from] = 0;\\n\\n        // migrate awards\\n        awards[to] = awards[from];\\n        awards[from] = 0;\\n    }\\n\\n    // ============ Registration ============\\n\\n    /*\\n        Members must register to start receiving the drip,\\n        and to receive the registration reward.\\n     */\\n\\n    function register(address member, string calldata label) public {\\n        _registerMember(member, label, block.number);\\n    }\\n\\n    // Allows governance to back-date registration timestamp.\\n    function setRegistration(Registrable calldata registration)\\n        public\\n        onlyGovernance\\n    {\\n        _registerMember(\\n            registration.member,\\n            registration.label,\\n            registration.blockNumber\\n        );\\n    }\\n\\n    // Allows governance to set registration for multiple members.\\n    function setBulkRegistration(Registrable[] calldata registrations)\\n        public\\n        onlyGovernance\\n    {\\n        for (uint256 i = 0; i < registrations.length; i++) {\\n            _registerMember(\\n                registrations[i].member,\\n                registrations[i].label,\\n                registrations[i].blockNumber\\n            );\\n        }\\n    }\\n\\n    // ============ Utility Functions ============\\n\\n    function isMirrorDAO(address member, string calldata label)\\n        public\\n        view\\n        returns (bool mirrorDAO)\\n    {\\n        bytes32 labelNode = keccak256(abi.encodePacked(label));\\n        bytes32 node = keccak256(abi.encodePacked(rootNode, labelNode));\\n        mirrorDAO = member == ensRegistry.owner(node);\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _mint(address to, uint256 amount) internal {\\n        IMirrorTokenLogic(token).mint(to, amount);\\n    }\\n\\n    function _registerMember(\\n        address member,\\n        string calldata label,\\n        uint256 blockNumber\\n    ) internal {\\n        require(isMirrorDAO(member, label), \\\"must be a MirrorDAO to register\\\");\\n        require(registered[member] == 0, \\\"member already registered\\\");\\n\\n        registered[member] = blockNumber;\\n        awards[member] += registrationReward;\\n        registeredMembers += 1;\\n        emit Registered(member, label);\\n    }\\n\\n    function _claimablePerEpoch(address member, uint256 epochIndex)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        DistributionEpoch memory epoch = epochs[epochIndex];\\n\\n        uint256 startBlock = max(registered[member], epoch.startBlock);\\n\\n        uint256 endBlock;\\n        if (numEpochs > epochIndex + 1) {\\n            endBlock = epochs[epochIndex + 1].startBlock;\\n        } else {\\n            endBlock = block.number;\\n        }\\n\\n        if (\\n            registered[member] > 0 &&\\n            registered[member] < endBlock &&\\n            lastClaimed[member] < endBlock\\n        ) {\\n            return epoch.claimablePerBlock * (endBlock - startBlock);\\n        }\\n\\n        return 0;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a >= b) {\\n            return a;\\n        } else {\\n            return b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/upgradable/BeaconStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract BeaconStorage {\\n    /// @notice Holds the address of the upgrade beacon\\n    address internal immutable beacon;\\n\\n    constructor(address beacon_) {\\n        beacon = beacon_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\nimport {IGovernable} from \\\"../lib/interface/IGovernable.sol\\\";\\n\\ncontract Governable is Ownable, IGovernable {\\n    // ============ Mutable Storage ============\\n\\n    // Mirror governance contract.\\n    address public override governor;\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyGovernance() {\\n        require(isOwner() || isGovernor(), \\\"caller is not governance\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"caller is not governor\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    // ============ Administration ============\\n\\n    function changeGovernor(address governor_) public override onlyGovernance {\\n        governor = governor_;\\n    }\\n\\n    // ============ Utility Functions ============\\n\\n    function isGovernor() public view override returns (bool) {\\n        return msg.sender == governor;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/upgradable/interface/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IBeacon {\\n    /// @notice Logic for this contract.\\n    function logic() external view returns (address);\\n\\n    /// @notice Emitted when the logic is updated.\\n    event Update(address oldLogic, address newLogic);\\n\\n    /// @notice Updates logic address.\\n    function update(address newLogic) external;\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/DistributionStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {IENS} from \\\"../interface/IENS.sol\\\";\\nimport {IDistributionStorage} from \\\"./interface/IDistributionStorage.sol\\\";\\n\\n/**\\n * @title DistributionStorage\\n * @author MirrorXYZ\\n */\\ncontract DistributionStorage is IDistributionStorage {\\n    // ============ Immutable Storage ============\\n\\n    // The node of the root name (e.g. namehash(mirror.xyz))\\n    bytes32 public immutable rootNode;\\n    /**\\n     * The address of the public ENS registry.\\n     * @dev Dependency-injectable for testing purposes, but otherwise this is the\\n     * canonical ENS registry at 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e.\\n     */\\n    IENS public immutable ensRegistry;\\n\\n    // ============ Mutable Storage ============\\n\\n    // The address for Mirror team and investors.\\n    address team;\\n    // The address of the governance token that this contract is allowed to mint.\\n    address token;\\n    // The address that is allowed to distribute.\\n    address treasury;\\n    // The amount that has been contributed to the treasury.\\n    mapping(address => uint256) public contributions;\\n    mapping(address => uint256) public awards;\\n    // The number of rewards that are created per 1 ETH contribution to the treasury.\\n    uint256 contributionsFactor = 1000;\\n    // The amount that has been claimed per address.\\n    mapping(address => uint256) public claimed;\\n    // The block number that an address last claimed\\n    mapping(address => uint256) public lastClaimed;\\n    // The block number that an address registered\\n    mapping(address => uint256) public override registered;\\n    // Banned accounts\\n    mapping(address => bool) public banned;\\n    // The percentage of tokens issued that are taken by the Mirror team.\\n    uint256 teamRatio = 40;\\n    uint256 public registrationReward = 100 * 1e18;\\n    uint256 public registeredMembers;\\n\\n    struct DistributionEpoch {\\n        uint256 startBlock;\\n        uint256 claimablePerBlock;\\n    }\\n\\n    DistributionEpoch[] public epochs;\\n    uint256 numEpochs = 0;\\n\\n    constructor(bytes32 rootNode_, address ensRegistry_) {\\n        rootNode = rootNode_;\\n        ensRegistry = IENS(ensRegistry_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/interface/IDistributionLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IDistributionLogic {\\n    function version() external returns (uint256);\\n\\n    function distribute(address tributary, uint256 contribution) external;\\n\\n    function claim(address claimant) external;\\n\\n    function claimable(address claimant) external view returns (uint256);\\n\\n    function increaseAwards(address member, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/token/interface/IMirrorTokenLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\nimport {IGovernable} from \\\"../../../lib/interface/IGovernable.sol\\\";\\n\\ninterface IMirrorTokenLogic is IGovernable {\\n    function version() external returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function setTreasuryConfig(address newTreasuryConfig) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IPausable {\\n    /// @notice Emitted when the pause is triggered by `account`.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted by `account`.\\n    event Unpaused(address account);\\n\\n    function paused() external returns (bool);\\n}\\n\\ncontract Pausable is IPausable {\\n    bool public override paused;\\n\\n    // Modifiers\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Initializes the contract in unpaused state.\\n    constructor(bool paused_) {\\n        paused = paused_;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Ownable {\\n    address public owner;\\n    address private nextOwner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IGovernable {\\n    function changeGovernor(address governor_) external;\\n\\n    function isGovernor() external view returns (bool);\\n\\n    function governor() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IENS.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/interface/IDistributionStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IDistributionStorage {\\n    function registered(address claimant) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rootNode_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"ensRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimablePerBlock\",\"type\":\"uint256\"}],\"name\":\"Epoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"awards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ban\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"banned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contributionsFactor_\",\"type\":\"uint256\"}],\"name\":\"changeContributionFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"registrationReward_\",\"type\":\"uint256\"}],\"name\":\"changeRegistrationReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"team_\",\"type\":\"address\"}],\"name\":\"changeTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamRatio_\",\"type\":\"uint256\"}],\"name\":\"changeTeamRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"name\":\"changeTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimablePerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct DistributionStorage.DistributionEpoch\",\"name\":\"epoch\",\"type\":\"tuple\"}],\"name\":\"createEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tributary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"contribution\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"drip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"membershipReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"internalType\":\"contract IENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimablePerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxyLogic\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAwards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"isMirrorDAO\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"mirrorDAO\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registeredMembers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DistributionLogic.Registrable[]\",\"name\":\"registrations\",\"type\":\"tuple[]\"}],\"name\":\"setBulkRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DistributionLogic.Registrable\",\"name\":\"registration\",\"type\":\"tuple\"}],\"name\":\"setRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unban\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DistributionLogic","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000007b84e7d94311ed294f74c5fdb166d4bf6e90ac320000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b571aaf79d9b3323ad0212f6a2f34f8c627d8d45e45a55c774d080e3077334bfad900000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}