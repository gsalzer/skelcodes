{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n  pragma solidity 0.8.4;\r\n\r\n  library SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n      // benefit is lost if 'b' is also tested.\r\n      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n\r\n      uint256 c = a * b;\r\n      require(c / a == b, \"SafeMath#mul: OVERFLOW\");\r\n\r\n      return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      // Solidity only automatically asserts when dividing by 0\r\n      require(b > 0, \"SafeMath#div: DIVISION_BY_ZERO\");\r\n      uint256 c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n      return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      require(b <= a, \"SafeMath#sub: UNDERFLOW\");\r\n      uint256 c = a - b;\r\n\r\n      return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      uint256 c = a + b;\r\n      require(c >= a, \"SafeMath#add: OVERFLOW\");\r\n\r\n      return c; \r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      require(b != 0, \"SafeMath#mod: DIVISION_BY_ZERO\");\r\n      return a % b;\r\n    }\r\n\r\n  }\r\n\r\n  abstract contract Context {\r\n      function _msgSender() internal view virtual returns (address) {\r\n          return msg.sender;\r\n      }\r\n\r\n      function _msgData() internal view virtual returns (bytes calldata) {\r\n          return msg.data;\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev Contract module which provides a basic access control mechanism, where\r\n   * there is an account (an owner) that can be granted exclusive access to\r\n   * specific functions.\r\n   *\r\n   * This module is used through inheritance. It will make available the modifier\r\n   * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n   * the owner.\r\n   */\r\n  abstract contract Ownable is Context {\r\n      address private _owner;\r\n\r\n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n      /**\r\n       * @dev Initializes the contract setting the deployer as the initial owner.\r\n       */\r\n      constructor() {\r\n          _setOwner(_msgSender());\r\n      }\r\n\r\n      /**\r\n       * @dev Returns the address of the current owner.\r\n       */\r\n      function owner() public view virtual returns (address) {\r\n          return _owner;\r\n      }\r\n\r\n      /**\r\n       * @dev Throws if called by any account other than the owner.\r\n       */\r\n      modifier onlyOwner() {\r\n          require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n          _;\r\n      }\r\n\r\n      /**\r\n       * @dev Leaves the contract without owner. It will not be possible to call\r\n       * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n       *\r\n       * NOTE: Renouncing ownership will leave the contract without an owner,\r\n       * thereby removing any functionality that is only available to the owner.\r\n       */\r\n      function renounceOwnership() public virtual onlyOwner {\r\n          _setOwner(address(0));\r\n      }\r\n\r\n      /**\r\n       * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n       * Can only be called by the current owner.\r\n       */\r\n      function transferOwnership(address newOwner) public virtual onlyOwner {\r\n          require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n          _setOwner(newOwner);\r\n      }\r\n\r\n      function _setOwner(address newOwner) private {\r\n          address oldOwner = _owner;\r\n          _owner = newOwner;\r\n          emit OwnershipTransferred(oldOwner, newOwner);\r\n      }\r\n  }\r\n\r\n  contract Gen0DistributorMarker is Ownable {\r\n      \r\n      using SafeMath for uint256;\r\n      \r\n      uint256 private claimingFee;\r\n      mapping(address => bool) public claimers;\r\n      event Claimed(address indexed _from);\r\n      \r\n      constructor() \r\n       {\r\n          claimingFee = 0.004 * 10 ** 18; //  (Varies by network)\r\n      }\r\n      \r\n        \r\n        function changeClaimingFees(uint256 _claimingFee) onlyOwner public {\r\n            claimingFee = _claimingFee;\r\n        }\r\n      \r\n      function claim() payable public {\r\n            require (msg.value >= claimingFee, \"E01\");\r\n            require (claimers[msg.sender] == false, \"E02\");\r\n            claimers[msg.sender] = true;\r\n            emit Claimed(msg.sender);\r\n      }\r\n      \r\n      function getClaimer(address _user) public view returns (bool) {\r\n          return claimers[_user];\r\n      }\r\n      \r\n     function withdrawFees() onlyOwner external {\r\n        require(payable(msg.sender).send(address(this).balance));\r\n    }\r\n  }","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimingFee\",\"type\":\"uint256\"}],\"name\":\"changeClaimingFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getClaimer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Gen0DistributorMarker","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f13552010875cf8686d0091894d655ef31a4200dfd7df7927d109b6dad936ef3"}]}