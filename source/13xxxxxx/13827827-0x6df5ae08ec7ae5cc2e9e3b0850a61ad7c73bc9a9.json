{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"brink-verifiers/Verifiers/TransferVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\n/**\\n *    ,,                           ,,                                \\n *   *MM                           db                      `7MM      \\n *    MM                                                     MM      \\n *    MM,dMMb.      `7Mb,od8     `7MM      `7MMpMMMb.        MM  ,MP'\\n *    MM    `Mb       MM' \\\"'       MM        MM    MM        MM ;Y   \\n *    MM     M8       MM           MM        MM    MM        MM;Mm   \\n *    MM.   ,M9       MM           MM        MM    MM        MM `Mb. \\n *    P^YbmdP'      .JMML.       .JMML.    .JMML  JMML.    .JMML. YA.\\n *\\n *    TransferVerifier.sol :: 0x6df5AE08Ec7aE5CC2E9e3b0850A61AD7C73bC9A9\\n *    etherscan.io verified 2021-12-18\\n */ \\n\\nimport \\\"../Libraries/Bit.sol\\\";\\nimport \\\"../Libraries/TransferHelper.sol\\\";\\n\\n/// @title Verifier for ETH and ERC20 transfers\\n/// @notice These functions should be executed by metaDelegateCall() on Brink account proxy contracts\\ncontract TransferVerifier {\\n  /// @dev Revert when transfer is expired\\n  error Expired();\\n\\n  /// @dev Executes an ETH transfer with replay protection and expiry\\n  /// @notice This should be executed by metaDelegateCall() with the following signed params\\n  /// @param bitmapIndex The index of the replay bit's bytes32 slot\\n  /// @param bit The value of the replay bit\\n  /// @param recipient The recipient of the transfer\\n  /// @param amount Amount of token to transfer\\n  /// @param expiryBlock The block when the transfer expires\\n  function ethTransfer(\\n    uint256 bitmapIndex, uint256 bit, address recipient, uint256 amount, uint256 expiryBlock\\n  )\\n    external\\n  {\\n    if (expiryBlock <= block.number) {\\n      revert Expired();\\n    }\\n    Bit.useBit(bitmapIndex, bit);\\n    TransferHelper.safeTransferETH(recipient, amount);\\n  }\\n\\n  /// @dev Executes an ERC20 token transfer with replay protection and expiry\\n  /// @notice This should be executed by metaDelegateCall() with the following signed params\\n  /// @param bitmapIndex The index of the replay bit's bytes32 slot\\n  /// @param bit The value of the replay bit\\n  /// @param token The token to transfer\\n  /// @param recipient The recipient of the transfer\\n  /// @param amount Amount of token to transfer\\n  /// @param expiryBlock The block when the transfer expires\\n  function tokenTransfer(\\n    uint256 bitmapIndex, uint256 bit, address token, address recipient, uint256 amount, uint256 expiryBlock\\n  )\\n    external\\n  {\\n    if (expiryBlock <= block.number) {\\n      revert Expired();\\n    }\\n    Bit.useBit(bitmapIndex, bit);\\n    TransferHelper.safeTransfer(token, recipient, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"brink-verifiers/Libraries/Bit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\n/// @title Bit replay protection library\\n/// @notice Handles storage and loads for replay protection bits\\n/// @dev Solution adapted from https://github.com/PISAresearch/metamask-comp/blob/77fa8295c168ee0b6bf801cbedab797d6f8cfd5d/src/contracts/BitFlipMetaTransaction/README.md\\n/// @dev This is a gas optimized technique that stores up to 256 replay protection bits per bytes32 slot\\nlibrary Bit {\\n  /// @dev Revert when bit provided is not valid\\n  error InvalidBit();\\n\\n  /// @dev Revert when bit provided is used\\n  error BitUsed();\\n\\n  /// @dev Initial pointer for bitmap storage ptr computation\\n  /// @notice This is the uint256 representation of keccak(\\\"bmp\\\")\\n  uint256 constant INITIAL_BMP_PTR = \\n  48874093989078844336340380824760280705349075126087700760297816282162649029611;\\n\\n  /// @dev Adds a bit to the uint256 bitmap at bitmapIndex\\n  /// @dev Value of bit cannot be zero and must represent a single bit\\n  /// @param bitmapIndex The index of the uint256 bitmap\\n  /// @param bit The value of the bit within the uint256 bitmap\\n  function useBit(uint256 bitmapIndex, uint256 bit) internal {\\n    if (!validBit(bit)) {\\n      revert InvalidBit();\\n    }\\n    bytes32 ptr = bitmapPtr(bitmapIndex);\\n    uint256 bitmap = loadUint(ptr);\\n    if (bitmap & bit != 0) {\\n      revert BitUsed();\\n    }\\n    uint256 updatedBitmap = bitmap | bit;\\n    assembly { sstore(ptr, updatedBitmap) }\\n  }\\n\\n  /// @dev Check that a bit is valid\\n  /// @param bit The bit to check\\n  /// @return isValid True if bit is greater than zero and represents a single bit\\n  function validBit(uint256 bit) internal pure returns (bool isValid) {\\n    assembly {\\n      // equivalent to: isValid = (bit > 0 && bit & bit-1) == 0;\\n      isValid := and(\\n        iszero(iszero(bit)), \\n        iszero(and(bit, sub(bit, 1)))\\n      )\\n    } \\n  }\\n\\n  /// @dev Get a bitmap storage pointer\\n  /// @return The bytes32 pointer to the storage location of the uint256 bitmap at bitmapIndex\\n  function bitmapPtr (uint256 bitmapIndex) internal pure returns (bytes32) {\\n    return bytes32(INITIAL_BMP_PTR + bitmapIndex);\\n  }\\n\\n  /// @dev Returns the uint256 value at storage location ptr\\n  /// @param ptr The storage location pointer\\n  /// @return val The uint256 value at storage location ptr\\n  function loadUint(bytes32 ptr) internal view returns (uint256 val) {\\n    assembly { val := sload(ptr) }\\n  }\\n}\\n\"\r\n    },\r\n    \"brink-verifiers/Libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n  function safeApprove(\\n    address token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'APPROVE_FAILED');\\n  }\\n\\n  function safeTransfer(\\n    address token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\\n  }\\n\\n  function safeTransferFrom(\\n    address token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FROM_FAILED');\\n  }\\n\\n  function safeTransferETH(address to, uint256 value) internal {\\n    (bool success, ) = to.call{value: value}(new bytes(0));\\n    require(success, 'ETH_TRANSFER_FAILED');\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"BitUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bitmapIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryBlock\",\"type\":\"uint256\"}],\"name\":\"ethTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bitmapIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryBlock\",\"type\":\"uint256\"}],\"name\":\"tokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TransferVerifier","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}