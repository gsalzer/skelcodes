{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/libwallet/ERC1271Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../lib/SignatureUtil.sol\\\";\\nimport \\\"./WalletData.sol\\\";\\n\\n\\n/// @title ERC1271Lib\\n/// @author Brecht Devos - <brecht@loopring.org>\\nlibrary ERC1271Lib\\n{\\n    using SignatureUtil     for bytes32;\\n\\n    // Note that we allow chained wallet ownership:\\n    // Wallet1 owned by Wallet2, Wallet2 owned by Wallet3, ..., WaleltN owned by an EOA.\\n    // The verificaiton of Wallet1's signature will succeed if the final EOA's signature is\\n    // valid.\\n    function isValidSignature(\\n        Wallet storage wallet,\\n        bytes4         ERC1271_MAGICVALUE,\\n        bytes32        signHash,\\n        bytes memory   signature\\n        )\\n        public\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        if (wallet.locked) {\\n            return 0;\\n        }\\n\\n        if (signHash.verifySignature(wallet.owner, signature)) {\\n            return ERC1271_MAGICVALUE;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SignatureUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../thirdparty/BytesUtil.sol\\\";\\nimport \\\"./AddressUtil.sol\\\";\\nimport \\\"./ERC1271.sol\\\";\\nimport \\\"./MathUint.sol\\\";\\n\\n\\n/// @title SignatureUtil\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @dev This method supports multihash standard. Each signature's last byte indicates\\n///      the signature's type.\\nlibrary SignatureUtil\\n{\\n    using BytesUtil     for bytes;\\n    using MathUint      for uint;\\n    using AddressUtil   for address;\\n\\n    enum SignatureType {\\n        ILLEGAL,\\n        INVALID,\\n        EIP_712,\\n        ETH_SIGN,\\n        WALLET   // deprecated\\n    }\\n\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function verifySignatures(\\n        bytes32          signHash,\\n        address[] memory signers,\\n        bytes[]   memory signatures\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(signers.length == signatures.length, \\\"BAD_SIGNATURE_DATA\\\");\\n        address lastSigner;\\n        for (uint i = 0; i < signers.length; i++) {\\n            require(signers[i] > lastSigner, \\\"INVALID_SIGNERS_ORDER\\\");\\n            lastSigner = signers[i];\\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function verifySignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        return signer.isContract()?\\n            verifyERC1271Signature(signHash, signer, signature):\\n            verifyEOASignature(signHash, signer, signature);\\n    }\\n\\n    function recoverECDSASigner(\\n        bytes32      signHash,\\n        bytes memory signature\\n        )\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        if (signature.length != 65) {\\n            return address(0);\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8   v;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := and(mload(add(signature, 0x41)), 0xff)\\n        }\\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n        if (v == 27 || v == 28) {\\n            return ecrecover(signHash, v, r, s);\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function verifyEOASignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        private\\n        pure\\n        returns (bool success)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        uint signatureTypeOffset = signature.length.sub(1);\\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\\n\\n        // Strip off the last byte of the signature by updating the length\\n        assembly {\\n            mstore(signature, signatureTypeOffset)\\n        }\\n\\n        if (signatureType == SignatureType.EIP_712) {\\n            success = (signer == recoverECDSASigner(signHash, signature));\\n        } else if (signatureType == SignatureType.ETH_SIGN) {\\n            bytes32 hash = keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", signHash)\\n            );\\n            success = (signer == recoverECDSASigner(hash, signature));\\n        } else {\\n            success = false;\\n        }\\n\\n        // Restore the signature length\\n        assembly {\\n            mstore(signature, add(signatureTypeOffset, 1))\\n        }\\n\\n        return success;\\n    }\\n\\n    function verifyERC1271Signature(\\n        bytes32 signHash,\\n        address signer,\\n        bytes   memory signature\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        bytes memory callData = abi.encodeWithSelector(\\n            ERC1271.isValidSignature.selector,\\n            signHash,\\n            signature\\n        );\\n        (bool success, bytes memory result) = signer.staticcall(callData);\\n        return (\\n            success &&\\n            result.length == 32 &&\\n            result.toBytes4(0) == ERC1271_MAGICVALUE\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/WalletData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nenum SigRequirement\\n{\\n    MAJORITY_OWNER_NOT_ALLOWED,\\n    MAJORITY_OWNER_ALLOWED,\\n    MAJORITY_OWNER_REQUIRED,\\n    OWNER_OR_ANY_GUARDIAN,\\n    ANY_GUARDIAN\\n}\\n\\nstruct Approval\\n{\\n    address[] signers;\\n    bytes[]   signatures;\\n    uint      validUntil;\\n    address   wallet;\\n}\\n\\n// Optimized to fit into 64 bytes (2 slots)\\nstruct Quota\\n{\\n    uint128 currentQuota;\\n    uint128 pendingQuota;\\n    uint128 spentAmount;\\n    uint64  spentTimestamp;\\n    uint64  pendingUntil;\\n}\\n\\nenum GuardianStatus\\n{\\n    REMOVE,    // Being removed or removed after validUntil timestamp\\n    ADD        // Being added or added after validSince timestamp.\\n}\\n\\n// Optimized to fit into 32 bytes (1 slot)\\nstruct Guardian\\n{\\n    address addr;\\n    uint8   status;\\n    uint64  timestamp; // validSince if status = ADD; validUntil if adding = REMOVE;\\n}\\n\\nstruct Wallet\\n{\\n    address owner;\\n    uint64  creationTimestamp;\\n\\n    // relayer => nonce\\n    uint nonce;\\n    // hash => consumed\\n    mapping (bytes32 => bool) hashes;\\n\\n    bool    locked;\\n\\n    Guardian[] guardians;\\n    mapping (address => uint)  guardianIdx;\\n\\n    address    inheritor;\\n    uint32     inheritWaitingPeriod;\\n    uint64     lastActive; // the latest timestamp the owner is considered to be active\\n\\n    Quota quota;\\n\\n    // whitelisted address => effective timestamp\\n    mapping (address => uint) whitelisted;\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/BytesUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\npragma solidity ^0.7.0;\\n\\nlibrary BytesUtil {\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1));\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2));\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\\n        require(_bytes.length >= (_start + 3));\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4));\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\\n        require(_bytes.length >= (_start + 8));\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\\n        require(_bytes.length >= (_start + 12));\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\\n        require(_bytes.length >= (_start + 16));\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\\n        require(_bytes.length >= (_start + 4));\\n        bytes4 tempBytes4;\\n\\n        assembly {\\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes4;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32));\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function fastSHA256(\\n        bytes memory data\\n        )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32[] memory result = new bytes32[](1);\\n        bool success;\\n        assembly {\\n             let ptr := add(data, 32)\\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\\n        }\\n        require(success, \\\"SHA256_FAILED\\\");\\n        return result[0];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for addresses\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @author Brecht Devos - <brecht@loopring.org>\\nlibrary AddressUtil\\n{\\n    using AddressUtil for *;\\n\\n    function isContract(\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(addr) }\\n        return (codehash != 0x0 &&\\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\\n    }\\n\\n    function toPayable(\\n        address addr\\n        )\\n        internal\\n        pure\\n        returns (address payable)\\n    {\\n        return payable(addr);\\n    }\\n\\n    // Works like address.send but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETH(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        if (amount == 0) {\\n            return true;\\n        }\\n        address payable recipient = to.toPayable();\\n        /* solium-disable-next-line */\\n        (success,) = recipient.call{value: amount, gas: gasLimit}(\\\"\\\");\\n    }\\n\\n    // Works like address.transfer but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETHAndVerify(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        success = to.sendETH(amount, gasLimit);\\n        require(success, \\\"TRANSFER_FAILURE\\\");\\n    }\\n\\n    // Works like call but is slightly more efficient when data\\n    // needs to be copied from memory to do the call.\\n    function fastCall(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bool success, bytes memory returnData)\\n    {\\n        if (to != address(0)) {\\n            assembly {\\n                // Do the call\\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\\n                // Copy the return data\\n                let size := returndatasize()\\n                returnData := mload(0x40)\\n                mstore(returnData, size)\\n                returndatacopy(add(returnData, 32), 0, size)\\n                // Update free memory pointer\\n                mstore(0x40, add(returnData, add(32, size)))\\n            }\\n        }\\n    }\\n\\n    // Like fastCall, but throws when the call is unsuccessful.\\n    function fastCallAndVerify(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bytes memory returnData)\\n    {\\n        bool success;\\n        (success, returnData) = fastCall(to, gasLimit, value, data);\\n        if (!success) {\\n            assembly {\\n                revert(add(returnData, 32), mload(returnData))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nabstract contract ERC1271 {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function isValidSignature(\\n        bytes32      _hash,\\n        bytes memory _signature)\\n        public\\n        view\\n        virtual\\n        returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MathUint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for uint\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary MathUint\\n{\\n    function mul(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a * b;\\n        require(a == 0 || c / a == b, \\\"MUL_OVERFLOW\\\");\\n    }\\n\\n    function sub(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        require(b <= a, \\\"SUB_UNDERFLOW\\\");\\n        return a - b;\\n    }\\n\\n    function add(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"ERC1271Lib","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}