{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ethereum/token/MagicAdminMint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol';\\nimport '@solidstate/contracts/access/OwnableInternal.sol';\\n\\ncontract MagicAdminMint is ERC20BaseInternal, OwnableInternal {\\n    function adminMint(address account, uint256 amount) external onlyOwner {\\n        _mint(account, amount);\\n    }\\n\\n    function adminBurn(address account, uint256 amount) external onlyOwner {\\n        _burn(account, amount);\\n    }\\n\\n    function adminTransfer(\\n        address holder,\\n        address receiver,\\n        uint256 amount\\n    ) external onlyOwner {\\n        _transfer(holder, receiver, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20Internal } from '../IERC20Internal.sol';\\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20BaseInternal is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function _totalSupply() internal view virtual returns (uint256) {\\n        return ERC20BaseStorage.layout().totalSupply;\\n    }\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function _balanceOf(address account)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return ERC20BaseStorage.layout().balances[account];\\n    }\\n\\n    /**\\n     * @notice enable spender to spend tokens on behalf of holder\\n     * @param holder address on whose behalf tokens may be spent\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     */\\n    function _approve(\\n        address holder,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(holder != address(0), 'ERC20: approve from the zero address');\\n        require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\\n\\n        emit Approval(holder, spender, amount);\\n    }\\n\\n    /**\\n     * @notice mint tokens for given account\\n     * @param account recipient of minted tokens\\n     * @param amount quantity of tokens minted\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: mint to the zero address');\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        l.totalSupply += amount;\\n        l.balances[account] += amount;\\n\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @notice burn tokens held by given account\\n     * @param account holder of burned tokens\\n     * @param amount quantity of tokens burned\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: burn from the zero address');\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        uint256 balance = l.balances[account];\\n        require(balance >= amount, 'ERC20: burn amount exceeds balance');\\n        unchecked {\\n            l.balances[account] = balance - amount;\\n        }\\n        l.totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @notice transfer tokens from holder to recipient\\n     * @param holder owner of tokens to be transferred\\n     * @param recipient beneficiary of transfer\\n     * @param amount quantity of tokens transferred\\n     */\\n    function _transfer(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(holder != address(0), 'ERC20: transfer from the zero address');\\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n        _beforeTokenTransfer(holder, recipient, amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        uint256 holderBalance = l.balances[holder];\\n        require(\\n            holderBalance >= amount,\\n            'ERC20: transfer amount exceeds balance'\\n        );\\n        unchecked {\\n            l.balances[holder] = holderBalance - amount;\\n        }\\n        l.balances[recipient] += amount;\\n\\n        emit Transfer(holder, recipient, amount);\\n    }\\n\\n    /**\\n     * @notice ERC20 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param amount quantity of tokens transferred\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == OwnableStorage.layout().owner,\\n            'Ownable: sender must be owner'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20BaseStorage {\\n    struct Layout {\\n        mapping(address => uint256) balances;\\n        mapping(address => mapping(address => uint256)) allowances;\\n        uint256 totalSupply;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setOwner(Layout storage l, address owner) internal {\\n        l.owner = owner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MagicAdminMint","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}