{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Tournament.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\n/**\\n * @title Tournament\\n * @notice This contract manages the matches in a NFT tournament in order to elect a NFT winner through voting\\n */\\ncontract Tournament {\\n    using Counters for Counters.Counter;\\n\\n    uint8 private constant MAX_NUMBER_OF_PLAYERS = 8;\\n\\n    struct TournamentData {\\n        address[MAX_NUMBER_OF_PLAYERS] wallets; // Player wallet\\n        address[MAX_NUMBER_OF_PLAYERS] tokenAddresses; // Corresponding NFT contract address\\n        uint256[MAX_NUMBER_OF_PLAYERS] tokenIds; // Player NFT ID\\n        uint256[MAX_NUMBER_OF_PLAYERS] currentBalances; // Player balance in the current round\\n        uint8[MAX_NUMBER_OF_PLAYERS] bracketWinners; // Array of player IDs in the current round\\n        uint256 currentRound; // Current round\\n    }\\n\\n    address private _owner;\\n    Counters.Counter private tournamentIds;\\n    mapping(uint256 => TournamentData) private tournaments;\\n\\n    event TournamentCreated(uint256 indexed tournamentId);\\n    event RoundEnded(uint256 indexed tournamentId, uint256 indexed round, uint8[MAX_NUMBER_OF_PLAYERS] bracketWinners, uint256[] playersScores);\\n    event TournamentEnded(uint256 indexed tournamentId, uint8 indexed bracketWinner, uint256[] playersScores);\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @return Array of addresses of players wallets\\n    function getWallets(uint256 _tournamentId)\\n        external\\n        view\\n        returns (address[MAX_NUMBER_OF_PLAYERS] memory)\\n    {\\n        return tournaments[_tournamentId].wallets;\\n    }\\n\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @return Array of corresponding player NFT addresses\\n    function getTokenAddresses(uint256 _tournamentId)\\n        external\\n        view\\n        returns (address[MAX_NUMBER_OF_PLAYERS] memory)\\n    {\\n        return tournaments[_tournamentId].tokenAddresses;\\n    }\\n\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @return Array of corresponding player NFT ID\\n    function getTokenIds(uint256 _tournamentId)\\n        external\\n        view\\n        returns (uint256[MAX_NUMBER_OF_PLAYERS] memory)\\n    {\\n        return tournaments[_tournamentId].tokenIds;\\n    }\\n\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @return Array of current player balance\\n    function getCurrentBalances(uint256 _tournamentId)\\n        external\\n        view\\n        returns (uint256[MAX_NUMBER_OF_PLAYERS] memory)\\n    {\\n        return tournaments[_tournamentId].currentBalances;\\n    }\\n\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @return Array of current winners in the tournament\\n    function getBracketWinners(uint256 _tournamentId)\\n        external\\n        view\\n        returns (uint8[MAX_NUMBER_OF_PLAYERS] memory)\\n    {\\n        return tournaments[_tournamentId].bracketWinners;\\n    }\\n\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @return Current round number\\n    function getCurrentRound(uint256 _tournamentId)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return tournaments[_tournamentId].currentRound;\\n    }\\n\\n    /// @dev Creates a new TournamentData object and store in the tournament mapping\\n    /// @dev Auto increments the current tournament ID created\\n    /// @param _playerWallets Array of player wallet addresses. The winner will receive the NFTs in this wallet\\n    /// @param _tokenAddresses Array of corresponding player NFT addresses\\n    /// @param _tokenIds Array of corresponding player NFT ID\\n    function createTournament(\\n        address[MAX_NUMBER_OF_PLAYERS] calldata _playerWallets,\\n        address[MAX_NUMBER_OF_PLAYERS] calldata _tokenAddresses,\\n        uint256[MAX_NUMBER_OF_PLAYERS] calldata _tokenIds\\n    ) external onlyOwner {\\n        tournamentIds.increment();\\n        uint256 newTournamentId = tournamentIds.current();\\n\\n        tournaments[newTournamentId] = TournamentData({\\n            wallets: _playerWallets,\\n            tokenAddresses: _tokenAddresses,\\n            tokenIds: _tokenIds,\\n            currentBalances: [uint256(0), 0, 0, 0, 0, 0, 0, 0],\\n            bracketWinners: [0, 1, 2, 3, 4, 5, 6, 7],\\n            currentRound: 3\\n        });\\n\\n        emit TournamentCreated(newTournamentId);\\n    }\\n\\n    /// @dev Ends the current round decrementing the round counter\\n    /// @dev Calculates the new voting balance for each player\\n    /// @dev Updates the winner bracket maintaining an orderly structure\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @param _playersRoundScores The scores of each player in the current round\\n    function endCurrentRound(\\n        uint256 _tournamentId,\\n        uint256[] calldata _playersRoundScores\\n    ) external onlyOwner {\\n        require(\\n            tournaments[_tournamentId].currentRound > 1,\\n            \\\"Tournament must not be reached the last round\\\"\\n        );\\n        tournaments[_tournamentId].currentRound--;\\n\\n        // Calculates the needed bracket size based on the current round\\n        uint256 currentBracketSize = 2**tournaments[_tournamentId].currentRound;\\n        uint256 playerId1;\\n        uint256 playerId2;\\n        uint256 i = 0;\\n\\n        // Iterates until the max size of the bracket winner array for the current round\\n        // Compares player balances in each match and assign the winner to the bracketWinner array\\n        for (\\n            uint256 bracketIndex = 0;\\n            bracketIndex < currentBracketSize;\\n            bracketIndex++\\n        ) {\\n            // Get the corresponding player IDs for each match from the current bracketWinners array\\n            playerId1 = tournaments[_tournamentId].bracketWinners[i];\\n            playerId2 = tournaments[_tournamentId].bracketWinners[i + 1];\\n\\n            // Stores the player cumulative balance\\n            tournaments[_tournamentId].currentBalances[playerId1] += _playersRoundScores[i];\\n            tournaments[_tournamentId].currentBalances[playerId2] += _playersRoundScores[i + 1];\\n\\n            // Save match winner in the bracketWinners array\\n            tournaments[_tournamentId].bracketWinners[bracketIndex] = \\n                _playersRoundScores[i] > _playersRoundScores[i + 1]\\n                ? tournaments[_tournamentId].bracketWinners[i]\\n                : tournaments[_tournamentId].bracketWinners[i + 1];\\n\\n            i += 2;\\n        }\\n\\n        emit RoundEnded(_tournamentId, tournaments[_tournamentId].currentRound + 1, tournaments[_tournamentId].bracketWinners, _playersRoundScores);\\n    }\\n\\n    /// @dev Ends the tournament decrementing the round counter\\n    /// @dev Calculates the new voting balance for each player\\n    /// @dev Updates the winner bracket with the tournament winner in the first position\\n    /// @param _tournamentId The corresponding tournament ID\\n    /// @param _playersRoundScores The scores of each player in the current round\\n    function endTournament(\\n        uint256 _tournamentId,\\n        uint256[] calldata _playersRoundScores\\n    ) external onlyOwner {\\n        require(\\n            tournaments[_tournamentId].currentRound == 1,\\n            \\\"Tournament must be in the last round\\\"\\n        );\\n        tournaments[_tournamentId].currentRound--;\\n\\n        // Get the corresponding player IDs for each match from the current bracketWinners array\\n        uint256 playerId1 = tournaments[_tournamentId].bracketWinners[0];\\n        uint256 playerId2 = tournaments[_tournamentId].bracketWinners[1];\\n\\n        // Stores the player cumulative balance\\n        tournaments[_tournamentId].currentBalances[playerId1] += _playersRoundScores[0];\\n        tournaments[_tournamentId].currentBalances[playerId2] += _playersRoundScores[1];\\n\\n        // Save the tournament winner in the first position bracketWinners array\\n        tournaments[_tournamentId].bracketWinners[0] =\\n            _playersRoundScores[0] > _playersRoundScores[1]\\n            ? tournaments[_tournamentId].bracketWinners[0]\\n            : tournaments[_tournamentId].bracketWinners[1];\\n\\n    emit TournamentEnded(_tournamentId, tournaments[_tournamentId].bracketWinners[0], _playersRoundScores);\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8[8]\",\"name\":\"bracketWinners\",\"type\":\"uint8[8]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"playersScores\",\"type\":\"uint256[]\"}],\"name\":\"RoundEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"}],\"name\":\"TournamentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"bracketWinner\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"playersScores\",\"type\":\"uint256[]\"}],\"name\":\"TournamentEnded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[8]\",\"name\":\"_playerWallets\",\"type\":\"address[8]\"},{\"internalType\":\"address[8]\",\"name\":\"_tokenAddresses\",\"type\":\"address[8]\"},{\"internalType\":\"uint256[8]\",\"name\":\"_tokenIds\",\"type\":\"uint256[8]\"}],\"name\":\"createTournament\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_playersRoundScores\",\"type\":\"uint256[]\"}],\"name\":\"endCurrentRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_playersRoundScores\",\"type\":\"uint256[]\"}],\"name\":\"endTournament\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"}],\"name\":\"getBracketWinners\",\"outputs\":[{\"internalType\":\"uint8[8]\",\"name\":\"\",\"type\":\"uint8[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"}],\"name\":\"getCurrentBalances\",\"outputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"\",\"type\":\"uint256[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"}],\"name\":\"getCurrentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"}],\"name\":\"getTokenAddresses\",\"outputs\":[{\"internalType\":\"address[8]\",\"name\":\"\",\"type\":\"address[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"}],\"name\":\"getTokenIds\",\"outputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"\",\"type\":\"uint256[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"}],\"name\":\"getWallets\",\"outputs\":[{\"internalType\":\"address[8]\",\"name\":\"\",\"type\":\"address[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Tournament","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}