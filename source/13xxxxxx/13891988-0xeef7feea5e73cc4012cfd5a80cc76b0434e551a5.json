{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Unlicense\r\npragma solidity 0.8.7;\r\n\r\ninterface IERC20 {\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction allowance(address owner, address spender) external returns (uint256);\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\tfunction balanceOf(address owner) external view returns (uint256);\r\n\tfunction totalSupply() external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\tusing Address for address;\r\n\r\n\tfunction safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n\t}\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n\t/**\r\n\t* @dev Deprecated. This function has issues similar to the ones found in\r\n\t* {IERC20-approve}, and its usage is discouraged.\r\n\t*\r\n\t* Whenever possible, use {safeIncreaseAllowance} and\r\n\t* {safeDecreaseAllowance} instead.\r\n\t*/\r\n\tfunction safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n\t\t// safeApprove should only be called when setting an initial allowance,\r\n\t\t// or when resetting it to zero. To increase and decrease it, use\r\n\t\t// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n\t\t// solhint-disable-next-line max-line-length\r\n\t\trequire((value == 0) || (token.allowance(address(this), spender) == 0),\r\n\t\t\t\"SafeERC20: approve from non-zero to non-zero allowance\"\r\n\t\t);\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n\t* on the return value: the return value is optional (but if data is returned, it must not be false).\r\n\t* @param token The token targeted by the call.\r\n\t* @param data The call data (encoded using abi.encode or one of its variants).\r\n\t*/\r\n\tfunction _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n\t\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n\t\tbytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n\t\tif (returndata.length > 0) { // Return data is optional\r\n\t\t\t// solhint-disable-next-line max-line-length\r\n\t\t\trequire(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\nlibrary Address {\r\n\t/**\r\n\t* @dev Returns true if `account` is a contract.\r\n\t*\r\n\t* [IMPORTANT]\r\n\t* ====\r\n\t* It is unsafe to assume that an address for which this function returns\r\n\t* false is an externally-owned account (EOA) and not a contract.\r\n\t*\r\n\t* Among others, `isContract` will return false for the following\r\n\t* types of addresses:\r\n\t*\r\n\t*  - an externally-owned account\r\n\t*  - a contract in construction\r\n\t*  - an address where a contract will be created\r\n\t*  - an address where a contract lived, but was destroyed\r\n\t* ====\r\n\t*/\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\r\n\t\t// construction, since the code is only stored at the end of the\r\n\t\t// constructor execution.\r\n\r\n\t\tuint256 size;\r\n\t\t// solhint-disable-next-line no-inline-assembly\r\n\t\tassembly { size := extcodesize(account) }\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Performs a Solidity function call using a low level `call`. A\r\n\t* plain`call` is an unsafe replacement for a function call: use this\r\n\t* function instead.\r\n\t*\r\n\t* If `target` reverts with a revert reason, it is bubbled up by this\r\n\t* function (like regular Solidity function calls).\r\n\t*\r\n\t* Returns the raw returned data. To convert to the expected return value,\r\n\t* use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t*\r\n\t* Requirements:\r\n\t*\r\n\t* - `target` must be a contract.\r\n\t* - calling `target` with `data` must not revert.\r\n\t*\r\n\t* _Available since v3.1._\r\n\t*/\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t* `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t*\r\n\t* _Available since v3.1._\r\n\t*/\r\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t* but also transferring `value` wei to `target`.\r\n\t*\r\n\t* Requirements:\r\n\t*\r\n\t* - the calling contract must have an ETH balance of at least `value`.\r\n\t* - the called Solidity function must be `payable`.\r\n\t*\r\n\t* _Available since v3.1._\r\n\t*/\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t* with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t*\r\n\t* _Available since v3.1._\r\n\t*/\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\t\t// solhint-disable-next-line avoid-low-level-calls\r\n\t\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t// Look for revert reason and bubble it up if present\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n\t\t\t\t// solhint-disable-next-line no-inline-assembly\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\ninterface IUniswapV3Pair {\r\n\tfunction flash(\r\n        address recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\nstruct FundManagement {\r\n\taddress sender;\r\n\tbool fromInternalBalance;\r\n\taddress payable recipient;\r\n\tbool toInternalBalance;\r\n}\r\n\r\nenum SwapKind { GIVEN_IN, GIVEN_OUT }\r\n\r\nstruct SingleSwap {\r\n\tbytes32 poolId;\r\n\tSwapKind kind;\r\n\taddress assetIn;\r\n\taddress assetOut;\r\n\tuint256 amount;\r\n\tbytes userData;\r\n}\r\n\r\ninterface IVault {\r\n    function getPoolTokens(bytes32 poolD) external view returns (address[] memory, uint256[] memory);\r\n\tfunction swap(SingleSwap memory singleSwap, FundManagement memory funds, uint256 limit, uint256 deadline) external payable returns (uint256);\r\n}\r\n\r\ninterface WAToken {\r\n\tfunction staticToDynamicAmount(uint256) external view returns (uint256);\r\n\tfunction deposit(address, uint256, uint16, bool) external returns (uint256);\r\n\tfunction withdraw(address, uint256, bool) external returns (uint256, uint256);\r\n}\r\n\r\ninterface LinearPool {\r\n   \t//BasePool\r\n\tfunction getPoolId() external view returns (bytes32);\r\n\tfunction getSwapFeePercentage() external view returns (uint256);\r\n\tfunction getScalingFactors() external view returns (uint256[] memory);\r\n\r\n\t//LinearPool\r\n\tfunction getMainToken() external view returns (address);\r\n\tfunction getWrappedToken() external view returns (address);\r\n\tfunction getBptIndex() external view returns (uint256);\r\n\tfunction getMainIndex() external view returns (uint256);\r\n\tfunction getWrappedIndex() external view returns (uint256);\r\n\tfunction getRate() external view returns (uint256);\r\n\tfunction getWrappedTokenRate() external view returns (uint256);\r\n\tfunction getTargets() external view returns (uint256 lowerTarget, uint256 upperTarget);\r\n}\r\n\r\ncontract Rebalancer {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 private constant MAX_UINT = 2 ** 256 - 1;\r\n\r\n    IVault constant private VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\r\n\r\n    IUniswapV3Pair constant private DAI_POOL = IUniswapV3Pair(0x5777d92f208679DB4b9778590Fa3CAB3aC9e2168);\r\n\tIUniswapV3Pair constant private USDC_USDT_POOL = IUniswapV3Pair(0x3416cF6C708Da44DB2624D63ea0AAef7113527C6);\r\n\r\n\taddress constant private DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n\taddress constant private USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n\taddress constant private USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n\r\n\taddress constant private WDAI = 0x02d60b84491589974263d922D9cC7a3152618Ef6;\r\n\taddress constant private WUSDC = 0xd093fA4Fb80D09bB30817FDcd442d4d02eD3E5de;\r\n\taddress constant private WUSDT = 0xf8Fd466F12e236f4c96F7Cce6c79EAdB819abF58;\r\n\r\n    uint256 constant private ONE = 10**18;\r\n\r\n    address public owner;\r\n\r\n\tconstructor(address _owner) {\r\n\t\tIERC20(DAI).approve(address(WDAI), MAX_UINT);\r\n\t\tIERC20(USDC).approve(address(WUSDC), MAX_UINT);\r\n\t\tIERC20(USDT).safeApprove(address(WUSDT), MAX_UINT);\r\n\r\n\t\tIERC20(DAI).approve(address(VAULT), MAX_UINT);\r\n\t\tIERC20(USDC).approve(address(VAULT), MAX_UINT);\r\n\t\tIERC20(USDT).safeApprove(address(VAULT), MAX_UINT);\r\n\r\n\t\tIERC20(WDAI).approve(address(VAULT), MAX_UINT);\r\n\t\tIERC20(WUSDC).approve(address(VAULT), MAX_UINT);\r\n\t\tIERC20(WUSDT).approve(address(VAULT), MAX_UINT);\r\n\r\n        owner = _owner;\r\n\t}\r\n\r\n    function setNewOwner(address _newOwner) external {\r\n        require( msg.sender == owner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function balanceOf(IERC20 _token) public view returns (uint){\r\n        return _token.balanceOf(address(this));\r\n    }\r\n\r\n    function sweep(address _to) external {\r\n        require( msg.sender == owner);\r\n        IERC20(DAI).safeTransfer(_to, IERC20(DAI).balanceOf(address(this)));\r\n        IERC20(USDC).safeTransfer(_to, IERC20(USDC).balanceOf(address(this)));\r\n        IERC20(USDT).safeTransfer(_to, IERC20(USDT).balanceOf(address(this)));\r\n    }\r\n\r\n    function rebalance(LinearPool _pool, uint256 _desiredBalance) public payable {\r\n        (SingleSwap memory _swap, uint256 _amountInNeededForSwap) = getSwapAndAmountInNeeded(_pool, _desiredBalance);\r\n        address _mainToken = _swap.kind == SwapKind.GIVEN_IN ? _swap.assetIn : _swap.assetOut;\r\n\r\n        // perform flash loan\r\n        IUniswapV3Pair _uniswapPool = _mainToken == DAI ? DAI_POOL : USDC_USDT_POOL;\r\n        uint256 _amountNeededForFlashLoan = _swap.kind == SwapKind.GIVEN_IN ? _amountInNeededForSwap : WAToken(address(_swap.assetIn)).staticToDynamicAmount(_amountInNeededForSwap);\r\n        bytes memory _swapData = abi.encode(_swap, _amountNeededForFlashLoan, _amountInNeededForSwap, msg.sender);\r\n        if (_mainToken == USDT) _uniswapPool.flash(address(this), 0, _amountNeededForFlashLoan, _swapData);\r\n        else _uniswapPool.flash(address(this), _amountNeededForFlashLoan, 0, _swapData);\r\n    }\r\n\r\n    function getSwapAndAmountInNeeded(LinearPool _pool, uint256 _desiredBalance) public view returns (SingleSwap memory _swap, uint256 _amountInNeededForSwap) {\r\n        LinearMath.Params memory _params = LinearMath.Params({\r\n            fee: _pool.getSwapFeePercentage(),\r\n            lowerTarget: 0,\r\n            upperTarget: 0\r\n        });\r\n        (_params.lowerTarget, _params.upperTarget) = _pool.getTargets();\r\n        uint256[] memory _scalingFactors = _pool.getScalingFactors();\r\n        uint256 _mainTokenIndex = _pool.getMainIndex();\r\n        (address[] memory _tokenAddresses, uint256[] memory _tokenBalances) = VAULT.getPoolTokens(_pool.getPoolId());\r\n        uint256 _mainTokenBalance = _tokenBalances[_mainTokenIndex];\r\n\r\n        if (_desiredBalance == 0) {\r\n\t\t\tuint256 _scaledUpperTarget = _params.upperTarget * ONE / _scalingFactors[_mainTokenIndex];\r\n\t\t\tuint256 _scaledLowerTarget = _params.upperTarget * ONE / _scalingFactors[_mainTokenIndex];\r\n\r\n            if (_mainTokenBalance > _scaledUpperTarget) {\r\n                _desiredBalance = _scaledUpperTarget;\r\n            } else if (_mainTokenBalance < _scaledLowerTarget) {\r\n                _desiredBalance = _scaledLowerTarget;\r\n            } else {\r\n\t\t\t\trevert(\"Already in range and no desired balance specified\");\r\n\t\t\t}\r\n        }\r\n\r\n        // calculate amount needed.\r\n        uint256 _swapAmount = _mainTokenBalance < _desiredBalance ? _desiredBalance - _mainTokenBalance : _mainTokenBalance - _desiredBalance;\r\n        _amountInNeededForSwap = _mainTokenBalance < _desiredBalance ? _swapAmount : getWrappedInForMainOut(_swapAmount, _mainTokenBalance * _scalingFactors[_mainTokenIndex] / ONE, _scalingFactors[_mainTokenIndex], _scalingFactors[_pool.getWrappedIndex()], _params);\r\n        _swap = SingleSwap(\r\n\t\t\t_pool.getPoolId(),\r\n\t\t\t_mainTokenBalance > _desiredBalance ? SwapKind.GIVEN_OUT : SwapKind.GIVEN_IN,\r\n\t\t\t_mainTokenBalance > _desiredBalance ? _tokenAddresses[_pool.getWrappedIndex()] : _tokenAddresses[_mainTokenIndex],\r\n\t\t\t_mainTokenBalance > _desiredBalance ? _tokenAddresses[_mainTokenIndex] : _tokenAddresses[_pool.getWrappedIndex()],\r\n\t\t\t_swapAmount,\r\n\t\t\tnew bytes(0)\r\n\t\t);\r\n        return (_swap, _amountInNeededForSwap);\r\n    }\r\n\r\n    // Uniswap V3 Flash Callback\r\n\tfunction uniswapV3FlashCallback(uint256, uint256, bytes calldata _data) external payable {\r\n\t\t(SingleSwap memory _swap, uint256 _initialAmount, uint256 _requiredBalance, address _msgSender) = abi.decode(_data, (SingleSwap, uint256, uint256, address));\r\n\t\taddress mainToken = address(_swap.kind == SwapKind.GIVEN_IN ? _swap.assetIn : _swap.assetOut);\r\n\t\trequire(msg.sender == address(DAI_POOL) || msg.sender == address(USDC_USDT_POOL), \"bad 3. no\");\r\n\t\trequire(IERC20(mainToken).balanceOf(address(this)) >= _initialAmount, \"Flash loan didnt do it\");\r\n\r\n\t\tdoSwap(_swap, _initialAmount, _requiredBalance);\r\n\r\n\t\tuint256 _repayment = _initialAmount + (_initialAmount / 10000) + 1;\r\n\r\n        uint256 _balance = IERC20(mainToken).balanceOf(address(this));\r\n        if (_balance < _repayment) {\r\n            uint256 _deficit = _repayment - _balance;\r\n            IERC20(mainToken).safeTransferFrom(_msgSender, address(this), _deficit);\r\n        }\r\n\r\n\t\tIERC20(mainToken).safeTransfer(msg.sender, _repayment);\r\n\t}\r\n\r\n    function getWrappedInForMainOut(uint256 _mainOut, uint256 _mainBalance, uint256 _mainScalingFactor, uint256 _wrappedScalingFactor, LinearMath.Params memory _params) public pure returns (uint256) {\r\n        _mainOut = _mainOut * _mainScalingFactor / ONE;\r\n\r\n        uint256 amountIn = LinearMath._calcWrappedInPerMainOut(_mainOut, _mainBalance, _params);\r\n\r\n        return (((amountIn * ONE) - 1) /  _wrappedScalingFactor) + 1;\r\n    }\r\n\r\n    function getWrappedOutForMainIn(uint256 _mainIn, uint256 _mainBalance, uint256 _mainScalingFactor, uint256 _wrappedScalingFactor, LinearMath.Params memory _params) public pure returns (uint256) {\r\n        _mainIn = _mainIn * _mainScalingFactor / ONE;\r\n\r\n        uint256 amountOut = LinearMath._calcWrappedOutPerMainIn(_mainIn, _mainBalance, _params);\r\n\r\n        return amountOut * ONE / _wrappedScalingFactor;\r\n    }\r\n\r\n    function estimateDeficitRequirement(LinearPool _pool, uint256 _desiredBalance) external view returns (uint256) {\r\n        (SingleSwap memory _swap, uint256 _amountInNeededForSwap) = getSwapAndAmountInNeeded(_pool, _desiredBalance);\r\n\r\n        uint256 _amountNeededForFlashLoan = _swap.kind == SwapKind.GIVEN_IN ? _amountInNeededForSwap : WAToken(address(_swap.assetIn)).staticToDynamicAmount(_amountInNeededForSwap);\r\n\t\t_amountNeededForFlashLoan += (_amountNeededForFlashLoan / 10000) + 1;\r\n\r\n\t\tuint256 _amountOut =  _swap.amount;\r\n\t\tif (_swap.kind == SwapKind.GIVEN_IN) {\r\n\t\t\tLinearMath.Params memory _params = LinearMath.Params({\r\n\t\t\t\tfee: _pool.getSwapFeePercentage(),\r\n\t\t\t\tlowerTarget: 0,\r\n\t\t\t\tupperTarget: 0\r\n\t\t\t});\r\n\t\t\t(_params.lowerTarget, _params.upperTarget) = _pool.getTargets();\r\n\t\t\tuint256[] memory _scalingFactors = _pool.getScalingFactors();\r\n\t\t\tuint256 _mainTokenIndex = _pool.getMainIndex();\r\n\t\t\tuint256 _wrappedTokenIndex = _pool.getWrappedIndex();\r\n\t\t\t(, uint256[] memory _tokenBalances) = VAULT.getPoolTokens(_pool.getPoolId());\r\n\t\t\tuint256 _mainTokenBalance = _tokenBalances[_mainTokenIndex];\r\n\t\t\t_amountOut = getWrappedOutForMainIn(_swap.amount, _mainTokenBalance, _scalingFactors[_mainTokenIndex], _scalingFactors[_wrappedTokenIndex], _params);\r\n\t\t\t_amountOut = WAToken(address(_swap.assetOut)).staticToDynamicAmount(_amountOut);\r\n\t\t}\r\n\r\n\t\treturn _amountOut >= _amountNeededForFlashLoan ? 0 : _amountNeededForFlashLoan - _amountOut;\r\n    }\r\n\r\n    function doSwap(SingleSwap memory swap, uint256 _initialAmount, uint256 _requiredBalance) private {\r\n\t\tuint256 limit = swap.kind == SwapKind.GIVEN_IN ? 0 : MAX_UINT;\r\n\t\tFundManagement memory fundManagement = FundManagement(address(this), false, payable(address(this)), false);\r\n\t\tif (swap.kind == SwapKind.GIVEN_OUT) wrapToken(address(swap.assetIn), _initialAmount);\r\n\t\trequire(IERC20(swap.assetIn).balanceOf(address(this)) >= _requiredBalance, \"Not enough asset in balance\");\r\n\t\tVAULT.swap(swap, fundManagement, limit, block.timestamp);\r\n\t\tif (swap.kind == SwapKind.GIVEN_IN) unwrapToken(address(swap.assetOut), IERC20(swap.assetOut).balanceOf(address(this)));\r\n\t}\r\n\r\n\tfunction wrapToken(address _wrappedToken, uint256 _amount) private {\r\n\t\tWAToken(_wrappedToken).deposit(address(this), _amount, 0, true);\r\n\t}\r\n\r\n\tfunction unwrapToken(address _wrappedToken, uint256 _amount) private {\r\n\t\tWAToken(_wrappedToken).withdraw(address(this), _amount, true);\r\n\t}\r\n\r\n\treceive() payable external {}\r\n}\r\n\r\n\r\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\r\n// should be fixed.\r\n// solhint-disable private-vars-leading-underscore\r\n\r\nlibrary LinearMath {\r\n    using FixedPoint for uint256;\r\n\r\n    // A thorough derivation of the formulas and derivations found here exceeds the scope of this file, so only\r\n    // introductory notions will be presented.\r\n\r\n    // A Linear Pool holds three tokens: the main token, the wrapped token, and the Pool share token (BPT). It is\r\n    // possible to exchange any of these tokens for any of the other two (so we have three trading pairs) in both\r\n    // directions (the first token of each pair can be bought or sold for the second) and by specifying either the input\r\n    // or output amount (typically referred to as 'given in' or 'given out'). A full description thus requires\r\n    // 3*2*2 = 12 functions.\r\n    // Wrapped tokens have a known, trusted exchange rate to main tokens. All functions here assume such a rate has\r\n    // already been applied, meaning main and wrapped balances can be compared as they are both expressed in the same\r\n    // units (those of main token).\r\n    // Additionally, Linear Pools feature a lower and upper target that represent the desired range of values for the\r\n    // main token balance. Any action that moves the main balance away from this range is charged a proportional fee,\r\n    // and any action that moves it towards this range is incentivized by paying the actor using these collected fees.\r\n    // The collected fees are not stored in a separate data structure: they are a function of the current main balance,\r\n    // targets and fee percentage. The main balance sans fees is known as the 'nominal balance', which is always smaller\r\n    // than the real balance except when the real balance is within the targets.\r\n    // The rule under which Linear Pools conduct trades between main and wrapped tokens is by keeping the sum of nominal\r\n    // main balance and wrapped balance constant: this value is known as the 'invariant'. BPT is backed by nominal\r\n    // reserves, meaning its supply is proportional to the invariant. As the wrapped token appreciates in value and its\r\n    // exchange rate to the main token increases, so does the invariant and thus the value of BPT (in main token units).\r\n\r\n    struct Params {\r\n        uint256 fee;\r\n        uint256 lowerTarget;\r\n        uint256 upperTarget;\r\n    }\r\n\r\n    function _calcWrappedOutPerMainIn(\r\n        uint256 mainIn,\r\n        uint256 mainBalance,\r\n        Params memory params\r\n    ) internal pure returns (uint256) {\r\n        // Amount out, so we round down overall.\r\n\r\n        uint256 previousNominalMain = _toNominal(mainBalance, params);\r\n        uint256 afterNominalMain = _toNominal(mainBalance.add(mainIn), params);\r\n        return afterNominalMain.sub(previousNominalMain);\r\n    }\r\n\r\n    function _calcWrappedInPerMainOut(\r\n        uint256 mainOut,\r\n        uint256 mainBalance,\r\n        Params memory params\r\n    ) internal pure returns (uint256) {\r\n        // Amount in, so we round up overall.\r\n\r\n        uint256 previousNominalMain = _toNominal(mainBalance, params);\r\n        uint256 afterNominalMain = _toNominal(mainBalance.sub(mainOut), params);\r\n        return previousNominalMain.sub(afterNominalMain);\r\n    }\r\n\r\n    function _toNominal(uint256 real, Params memory params) internal pure returns (uint256) {\r\n        // Fees are always rounded down: either direction would work but we need to be consistent, and rounding down\r\n        // uses less gas.\r\n\r\n        if (real < params.lowerTarget) {\r\n            uint256 fees = (params.lowerTarget - real).mulDown(params.fee);\r\n            return real.sub(fees);\r\n        } else if (real <= params.upperTarget) {\r\n            return real;\r\n        } else {\r\n            uint256 fees = (real - params.upperTarget).mulDown(params.fee);\r\n            return real.sub(fees);\r\n        }\r\n    }\r\n\r\n    function _fromNominal(uint256 nominal, Params memory params) internal pure returns (uint256) {\r\n        // Since real = nominal + fees, rounding down fees is equivalent to rounding down real.\r\n\r\n        if (nominal < params.lowerTarget) {\r\n            return (nominal.add(params.fee.mulDown(params.lowerTarget))).divDown(FixedPoint.ONE.add(params.fee));\r\n        } else if (nominal <= params.upperTarget) {\r\n            return nominal;\r\n        } else {\r\n            return (nominal.sub(params.fee.mulDown(params.upperTarget)).divDown(FixedPoint.ONE.sub(params.fee)));\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary FixedPoint {\r\n    uint256 internal constant ONE = 1e18; // 18 decimal places\r\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\r\n\r\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\r\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Fixed Point addition is the same as regular checked addition\r\n\r\n        uint256 c = a + b;\r\n        _require(c >= a, Errors.ADD_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Fixed Point addition is the same as regular checked addition\r\n\r\n        _require(b <= a, Errors.SUB_OVERFLOW);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 product = a * b;\r\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\r\n\r\n        return product / ONE;\r\n    }\r\n\r\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 product = a * b;\r\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\r\n\r\n        if (product == 0) {\r\n            return 0;\r\n        } else {\r\n            // The traditional divUp formula is:\r\n            // divUp(x, y) := (x + y - 1) / y\r\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\r\n            // divUp(x, y) := (x - 1) / y + 1\r\n            // Note that this requires x != 0, which we already tested for.\r\n\r\n            return ((product - 1) / ONE) + 1;\r\n        }\r\n    }\r\n\r\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b != 0, Errors.ZERO_DIVISION);\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 aInflated = a * ONE;\r\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\r\n\r\n            return aInflated / b;\r\n        }\r\n    }\r\n\r\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b != 0, Errors.ZERO_DIVISION);\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 aInflated = a * ONE;\r\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\r\n\r\n            // The traditional divUp formula is:\r\n            // divUp(x, y) := (x + y - 1) / y\r\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\r\n            // divUp(x, y) := (x - 1) / y + 1\r\n            // Note that this requires x != 0, which we already tested for.\r\n\r\n            return ((aInflated - 1) / b) + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\r\n     * the true value (that is, the error function expected - actual is always positive).\r\n     */\r\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 raw = LogExpMath.pow(x, y);\r\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\r\n\r\n        if (raw < maxError) {\r\n            return 0;\r\n        } else {\r\n            return sub(raw, maxError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\r\n     * the true value (that is, the error function expected - actual is always negative).\r\n     */\r\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 raw = LogExpMath.pow(x, y);\r\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\r\n\r\n        return add(raw, maxError);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\r\n     *\r\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\r\n     * prevents intermediate negative values.\r\n     */\r\n    function complement(uint256 x) internal pure returns (uint256) {\r\n        return (x < ONE) ? (ONE - x) : 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\r\n * Adapted from OpenZeppelin's SafeMath library.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the absolute value of a signed integer.\r\n     */\r\n    function abs(int256 a) internal pure returns (uint256) {\r\n        return a > 0 ? uint256(a) : uint256(-a);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        _require(c >= a, Errors.ADD_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b <= a, Errors.SUB_OVERFLOW);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers of 256 bits.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers of 256 bits.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\r\n        return c;\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        bool roundUp\r\n    ) internal pure returns (uint256) {\r\n        return roundUp ? divUp(a, b) : divDown(a, b);\r\n    }\r\n\r\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b != 0, Errors.ZERO_DIVISION);\r\n        return a / b;\r\n    }\r\n\r\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        _require(b != 0, Errors.ZERO_DIVISION);\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            return 1 + (a - 1) / b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\r\n * supported.\r\n */\r\nfunction _require(bool condition, uint256 errorCode) pure {\r\n    if (!condition) _revert(errorCode);\r\n}\r\n\r\n/**\r\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\r\n */\r\nfunction _revert(uint256 errorCode) pure {\r\n    // We're going to dynamically create a revert string based on the error code, with the following format:\r\n    // 'BAL#{errorCode}'\r\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\r\n    //\r\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\r\n    // number (8 to 16 bits) than the individual string characters.\r\n    //\r\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\r\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\r\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\r\n    assembly {\r\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\r\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\r\n        // the '0' character.\r\n\r\n        let units := add(mod(errorCode, 10), 0x30)\r\n\r\n        errorCode := div(errorCode, 10)\r\n        let tenths := add(mod(errorCode, 10), 0x30)\r\n\r\n        errorCode := div(errorCode, 10)\r\n        let hundreds := add(mod(errorCode, 10), 0x30)\r\n\r\n        // With the individual characters, we can now construct the full string. The \"BAL#\" part is a known constant\r\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\r\n        // characters to it, each shifted by a multiple of 8.\r\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\r\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\r\n        // array).\r\n\r\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\r\n\r\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\r\n        // message will have the following layout:\r\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\r\n\r\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\r\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\r\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\r\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n        // The string length is fixed: 7 characters.\r\n        mstore(0x24, 7)\r\n        // Finally, the string itself is stored.\r\n        mstore(0x44, revertReason)\r\n\r\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\r\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\r\n        revert(0, 100)\r\n    }\r\n}\r\n\r\nlibrary Errors {\r\n    // Math\r\n    uint256 internal constant ADD_OVERFLOW = 0;\r\n    uint256 internal constant SUB_OVERFLOW = 1;\r\n    uint256 internal constant SUB_UNDERFLOW = 2;\r\n    uint256 internal constant MUL_OVERFLOW = 3;\r\n    uint256 internal constant ZERO_DIVISION = 4;\r\n    uint256 internal constant DIV_INTERNAL = 5;\r\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\r\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\r\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\r\n    uint256 internal constant INVALID_EXPONENT = 9;\r\n\r\n    // Input\r\n    uint256 internal constant OUT_OF_BOUNDS = 100;\r\n    uint256 internal constant UNSORTED_ARRAY = 101;\r\n    uint256 internal constant UNSORTED_TOKENS = 102;\r\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\r\n    uint256 internal constant ZERO_TOKEN = 104;\r\n\r\n    // Shared pools\r\n    uint256 internal constant MIN_TOKENS = 200;\r\n    uint256 internal constant MAX_TOKENS = 201;\r\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\r\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\r\n    uint256 internal constant MINIMUM_BPT = 204;\r\n    uint256 internal constant CALLER_NOT_VAULT = 205;\r\n    uint256 internal constant UNINITIALIZED = 206;\r\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\r\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\r\n    uint256 internal constant EXPIRED_PERMIT = 209;\r\n    uint256 internal constant NOT_TWO_TOKENS = 210;\r\n\r\n    // Pools\r\n    uint256 internal constant MIN_AMP = 300;\r\n    uint256 internal constant MAX_AMP = 301;\r\n    uint256 internal constant MIN_WEIGHT = 302;\r\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\r\n    uint256 internal constant MAX_IN_RATIO = 304;\r\n    uint256 internal constant MAX_OUT_RATIO = 305;\r\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\r\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\r\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\r\n    uint256 internal constant INVALID_TOKEN = 309;\r\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\r\n    uint256 internal constant ZERO_INVARIANT = 311;\r\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\r\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\r\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\r\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\r\n    uint256 internal constant ORACLE_BAD_SECS = 316;\r\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\r\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\r\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\r\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\r\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\r\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\r\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\r\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\r\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\r\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\r\n    uint256 internal constant SWAPS_DISABLED = 327;\r\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\r\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\r\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\r\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\r\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\r\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\r\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\r\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\r\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\r\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\r\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\r\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\r\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\r\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\r\n    uint256 internal constant INVALID_INITIALIZATION = 342;\r\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\r\n    uint256 internal constant UNAUTHORIZED_OPERATION = 344;\r\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\r\n\r\n    // Lib\r\n    uint256 internal constant REENTRANCY = 400;\r\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\r\n    uint256 internal constant PAUSED = 402;\r\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\r\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\r\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\r\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\r\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\r\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\r\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\r\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\r\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\r\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\r\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\r\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\r\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\r\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\r\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\r\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\r\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\r\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\r\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\r\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\r\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\r\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\r\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\r\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\r\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\r\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\r\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\r\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\r\n    uint256 internal constant NOT_PAUSED = 431;\r\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\r\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\r\n\r\n    // Vault\r\n    uint256 internal constant INVALID_POOL_ID = 500;\r\n    uint256 internal constant CALLER_NOT_POOL = 501;\r\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\r\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\r\n    uint256 internal constant INVALID_SIGNATURE = 504;\r\n    uint256 internal constant EXIT_BELOW_MIN = 505;\r\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\r\n    uint256 internal constant SWAP_LIMIT = 507;\r\n    uint256 internal constant SWAP_DEADLINE = 508;\r\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\r\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\r\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\r\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\r\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\r\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\r\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\r\n    uint256 internal constant INSUFFICIENT_ETH = 516;\r\n    uint256 internal constant UNALLOCATED_ETH = 517;\r\n    uint256 internal constant ETH_TRANSFER = 518;\r\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\r\n    uint256 internal constant TOKENS_MISMATCH = 520;\r\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\r\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\r\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\r\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\r\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\r\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\r\n    uint256 internal constant POOL_NO_TOKENS = 527;\r\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\r\n\r\n    // Fees\r\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\r\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\r\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\r\n}\r\n\r\n\r\n/* solhint-disable */\r\n\r\n/**\r\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\r\n *\r\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\r\n * exponentiation and logarithm (where the base is Euler's number).\r\n *\r\n * @author Fernando Martinelli - @fernandomartinelli\r\n * @author Sergio Yuhjtman - @sergioyuhjtman\r\n * @author Daniel Fernandez - @dmf7z\r\n */\r\nlibrary LogExpMath {\r\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\r\n    // two numbers, and multiply by ONE when dividing them.\r\n\r\n    // All arguments and return values are 18 decimal fixed point numbers.\r\n    int256 constant ONE_18 = 1e18;\r\n\r\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\r\n    // case of ln36, 36 decimals.\r\n    int256 constant ONE_20 = 1e20;\r\n    int256 constant ONE_36 = 1e36;\r\n\r\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\r\n    //\r\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\r\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\r\n    // The smallest possible result is 10^(-18), which makes largest negative argument\r\n    // ln(10^(-18)) = -41.446531673892822312.\r\n    // We use 130.0 and -41.0 to have some safety margin.\r\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\r\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\r\n\r\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\r\n    // 256 bit integer.\r\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\r\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\r\n\r\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\r\n\r\n    // 18 decimal constants\r\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\r\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\r\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\r\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\r\n\r\n    // 20 decimal constants\r\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\r\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\r\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\r\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\r\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\r\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\r\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\r\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\r\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\r\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\r\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\r\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\r\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\r\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\r\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\r\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\r\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\r\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\r\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\r\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\r\n\r\n    /**\r\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\r\n     *\r\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\r\n     */\r\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (y == 0) {\r\n            // We solve the 0^0 indetermination by making it equal one.\r\n            return uint256(ONE_18);\r\n        }\r\n\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\r\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\r\n        // x^y = exp(y * ln(x)).\r\n\r\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\r\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\r\n        int256 x_int256 = int256(x);\r\n\r\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\r\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\r\n\r\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\r\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\r\n        int256 y_int256 = int256(y);\r\n\r\n        int256 logx_times_y;\r\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\r\n            int256 ln_36_x = _ln_36(x_int256);\r\n\r\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\r\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\r\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\r\n            // (downscaled) last 18 decimals.\r\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\r\n        } else {\r\n            logx_times_y = _ln(x_int256) * y_int256;\r\n        }\r\n        logx_times_y /= ONE_18;\r\n\r\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\r\n        _require(\r\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\r\n            Errors.PRODUCT_OUT_OF_BOUNDS\r\n        );\r\n\r\n        return uint256(exp(logx_times_y));\r\n    }\r\n\r\n    /**\r\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\r\n     *\r\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\r\n     */\r\n    function exp(int256 x) internal pure returns (int256) {\r\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\r\n\r\n        if (x < 0) {\r\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\r\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\r\n            // Fixed point division requires multiplying by ONE_18.\r\n            return ((ONE_18 * ONE_18) / exp(-x));\r\n        }\r\n\r\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\r\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\r\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\r\n        // decomposition.\r\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\r\n        // decomposition, which will be lower than the smallest x_n.\r\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\r\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\r\n\r\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\r\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\r\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\r\n        // decomposition.\r\n\r\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\r\n        // it and compute the accumulated product.\r\n\r\n        int256 firstAN;\r\n        if (x >= x0) {\r\n            x -= x0;\r\n            firstAN = a0;\r\n        } else if (x >= x1) {\r\n            x -= x1;\r\n            firstAN = a1;\r\n        } else {\r\n            firstAN = 1; // One with no decimal places\r\n        }\r\n\r\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\r\n        // smaller terms.\r\n        x *= 100;\r\n\r\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\r\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\r\n        int256 product = ONE_20;\r\n\r\n        if (x >= x2) {\r\n            x -= x2;\r\n            product = (product * a2) / ONE_20;\r\n        }\r\n        if (x >= x3) {\r\n            x -= x3;\r\n            product = (product * a3) / ONE_20;\r\n        }\r\n        if (x >= x4) {\r\n            x -= x4;\r\n            product = (product * a4) / ONE_20;\r\n        }\r\n        if (x >= x5) {\r\n            x -= x5;\r\n            product = (product * a5) / ONE_20;\r\n        }\r\n        if (x >= x6) {\r\n            x -= x6;\r\n            product = (product * a6) / ONE_20;\r\n        }\r\n        if (x >= x7) {\r\n            x -= x7;\r\n            product = (product * a7) / ONE_20;\r\n        }\r\n        if (x >= x8) {\r\n            x -= x8;\r\n            product = (product * a8) / ONE_20;\r\n        }\r\n        if (x >= x9) {\r\n            x -= x9;\r\n            product = (product * a9) / ONE_20;\r\n        }\r\n\r\n        // x10 and x11 are unnecessary here since we have high enough precision already.\r\n\r\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\r\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\r\n\r\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\r\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\r\n\r\n        // The first term is simply x.\r\n        term = x;\r\n        seriesSum += term;\r\n\r\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\r\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\r\n\r\n        term = ((term * x) / ONE_20) / 2;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 3;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 4;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 5;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 6;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 7;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 8;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 9;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 10;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 11;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 12;\r\n        seriesSum += term;\r\n\r\n        // 12 Taylor terms are sufficient for 18 decimal precision.\r\n\r\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\r\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\r\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\r\n        // and then drop two digits to return an 18 decimal value.\r\n\r\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\r\n     */\r\n    function log(int256 arg, int256 base) internal pure returns (int256) {\r\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\r\n\r\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\r\n        // upscaling.\r\n\r\n        int256 logBase;\r\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\r\n            logBase = _ln_36(base);\r\n        } else {\r\n            logBase = _ln(base) * ONE_18;\r\n        }\r\n\r\n        int256 logArg;\r\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\r\n            logArg = _ln_36(arg);\r\n        } else {\r\n            logArg = _ln(arg) * ONE_18;\r\n        }\r\n\r\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\r\n        return (logArg * ONE_18) / logBase;\r\n    }\r\n\r\n    /**\r\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\r\n     */\r\n    function ln(int256 a) internal pure returns (int256) {\r\n        // The real natural logarithm is not defined for negative numbers or zero.\r\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\r\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\r\n            return _ln_36(a) / ONE_18;\r\n        } else {\r\n            return _ln(a);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\r\n     */\r\n    function _ln(int256 a) private pure returns (int256) {\r\n        if (a < ONE_18) {\r\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\r\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\r\n            // Fixed point division requires multiplying by ONE_18.\r\n            return (-_ln((ONE_18 * ONE_18) / a));\r\n        }\r\n\r\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\r\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\r\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\r\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\r\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\r\n        // decomposition, which will be lower than the smallest a_n.\r\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\r\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\r\n\r\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\r\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\r\n        // ONE_18 to convert them to fixed point.\r\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\r\n        // by it and compute the accumulated sum.\r\n\r\n        int256 sum = 0;\r\n        if (a >= a0 * ONE_18) {\r\n            a /= a0; // Integer, not fixed point division\r\n            sum += x0;\r\n        }\r\n\r\n        if (a >= a1 * ONE_18) {\r\n            a /= a1; // Integer, not fixed point division\r\n            sum += x1;\r\n        }\r\n\r\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\r\n        sum *= 100;\r\n        a *= 100;\r\n\r\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\r\n\r\n        if (a >= a2) {\r\n            a = (a * ONE_20) / a2;\r\n            sum += x2;\r\n        }\r\n\r\n        if (a >= a3) {\r\n            a = (a * ONE_20) / a3;\r\n            sum += x3;\r\n        }\r\n\r\n        if (a >= a4) {\r\n            a = (a * ONE_20) / a4;\r\n            sum += x4;\r\n        }\r\n\r\n        if (a >= a5) {\r\n            a = (a * ONE_20) / a5;\r\n            sum += x5;\r\n        }\r\n\r\n        if (a >= a6) {\r\n            a = (a * ONE_20) / a6;\r\n            sum += x6;\r\n        }\r\n\r\n        if (a >= a7) {\r\n            a = (a * ONE_20) / a7;\r\n            sum += x7;\r\n        }\r\n\r\n        if (a >= a8) {\r\n            a = (a * ONE_20) / a8;\r\n            sum += x8;\r\n        }\r\n\r\n        if (a >= a9) {\r\n            a = (a * ONE_20) / a9;\r\n            sum += x9;\r\n        }\r\n\r\n        if (a >= a10) {\r\n            a = (a * ONE_20) / a10;\r\n            sum += x10;\r\n        }\r\n\r\n        if (a >= a11) {\r\n            a = (a * ONE_20) / a11;\r\n            sum += x11;\r\n        }\r\n\r\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\r\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\r\n        // Let z = (a - 1) / (a + 1).\r\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\r\n\r\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\r\n        // division by ONE_20.\r\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\r\n        int256 z_squared = (z * z) / ONE_20;\r\n\r\n        // num is the numerator of the series: the z^(2 * n + 1) term\r\n        int256 num = z;\r\n\r\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\r\n        int256 seriesSum = num;\r\n\r\n        // In each step, the numerator is multiplied by z^2\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 3;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 5;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 7;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 9;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 11;\r\n\r\n        // 6 Taylor terms are sufficient for 36 decimal precision.\r\n\r\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\r\n        seriesSum *= 2;\r\n\r\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\r\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\r\n        // value.\r\n\r\n        return (sum + seriesSum) / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\r\n     * for x close to one.\r\n     *\r\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\r\n     */\r\n    function _ln_36(int256 x) private pure returns (int256) {\r\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\r\n        // worthwhile.\r\n\r\n        // First, we transform x to a 36 digit fixed point value.\r\n        x *= ONE_18;\r\n\r\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\r\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\r\n\r\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\r\n        // division by ONE_36.\r\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\r\n        int256 z_squared = (z * z) / ONE_36;\r\n\r\n        // num is the numerator of the series: the z^(2 * n + 1) term\r\n        int256 num = z;\r\n\r\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\r\n        int256 seriesSum = num;\r\n\r\n        // In each step, the numerator is multiplied by z^2\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 3;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 5;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 7;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 9;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 11;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 13;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 15;\r\n\r\n        // 8 Taylor terms are sufficient for 36 decimal precision.\r\n\r\n        // All that remains is multiplying by 2 (non fixed point).\r\n        return seriesSum * 2;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LinearPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_desiredBalance\",\"type\":\"uint256\"}],\"name\":\"estimateDeficitRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LinearPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_desiredBalance\",\"type\":\"uint256\"}],\"name\":\"getSwapAndAmountInNeeded\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"assetIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleSwap\",\"name\":\"_swap\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_amountInNeededForSwap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mainOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mainBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mainScalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wrappedScalingFactor\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lowerTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upperTarget\",\"type\":\"uint256\"}],\"internalType\":\"struct LinearMath.Params\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"getWrappedInForMainOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mainIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mainBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mainScalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wrappedScalingFactor\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lowerTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upperTarget\",\"type\":\"uint256\"}],\"internalType\":\"struct LinearMath.Params\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"getWrappedOutForMainIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LinearPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_desiredBalance\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3FlashCallback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Rebalancer","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000621bcfaa87ba0b7c57ca49e1bb1a8b917c34ed2f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://33e2dbb8b873c7bb85357843a69e7b1bf81a38b18d1c88eea53e9b6f9c686e97"}]}