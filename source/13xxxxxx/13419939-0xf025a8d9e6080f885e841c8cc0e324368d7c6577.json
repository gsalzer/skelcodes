{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@pooltogether/owner-manager-contracts/contracts/Manageable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Abstract manageable contract that can be inherited by other contracts\\n * @notice Contract module based on Ownable which provides a basic access control mechanism, where\\n * there is an owner and a manager that can be granted exclusive access to specific functions.\\n *\\n * By default, the owner is the deployer of the contract.\\n *\\n * The owner account is set through a two steps process.\\n *      1. The current `owner` calls {transferOwnership} to set a `pendingOwner`\\n *      2. The `pendingOwner` calls {acceptOwnership} to accept the ownership transfer\\n *\\n * The manager account needs to be set using {setManager}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyManager`, which can be applied to your functions to restrict their use to\\n * the manager.\\n */\\nabstract contract Manageable is Ownable {\\n    address private _manager;\\n\\n    /**\\n     * @dev Emitted when `_manager` has been changed.\\n     * @param previousManager previous `_manager` address.\\n     * @param newManager new `_manager` address.\\n     */\\n    event ManagerTransferred(address indexed previousManager, address indexed newManager);\\n\\n    /* ============ External Functions ============ */\\n\\n    /**\\n     * @notice Gets current `_manager`.\\n     * @return Current `_manager` address.\\n     */\\n    function manager() public view virtual returns (address) {\\n        return _manager;\\n    }\\n\\n    /**\\n     * @notice Set or change of manager.\\n     * @dev Throws if called by any account other than the owner.\\n     * @param _newManager New _manager address.\\n     * @return Boolean to indicate if the operation was successful or not.\\n     */\\n    function setManager(address _newManager) external onlyOwner returns (bool) {\\n        return _setManager(_newManager);\\n    }\\n\\n    /* ============ Internal Functions ============ */\\n\\n    /**\\n     * @notice Set or change of manager.\\n     * @param _newManager New _manager address.\\n     * @return Boolean to indicate if the operation was successful or not.\\n     */\\n    function _setManager(address _newManager) private returns (bool) {\\n        address _previousManager = _manager;\\n\\n        require(_newManager != _previousManager, \\\"Manageable/existing-manager-address\\\");\\n\\n        _manager = _newManager;\\n\\n        emit ManagerTransferred(_previousManager, _newManager);\\n        return true;\\n    }\\n\\n    /* ============ Modifier Functions ============ */\\n\\n    /**\\n     * @dev Throws if called by any account other than the manager.\\n     */\\n    modifier onlyManager() {\\n        require(manager() == msg.sender, \\\"Manageable/caller-not-manager\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the manager or the owner.\\n     */\\n    modifier onlyManagerOrOwner() {\\n        require(manager() == msg.sender || owner() == msg.sender, \\\"Manageable/caller-not-manager-or-owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Abstract ownable contract that can be inherited by other contracts\\n * @notice Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner is the deployer of the contract.\\n *\\n * The owner account is set through a two steps process.\\n *      1. The current `owner` calls {transferOwnership} to set a `pendingOwner`\\n *      2. The `pendingOwner` calls {acceptOwnership} to accept the ownership transfer\\n *\\n * The manager account needs to be set using {setManager}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n    address private _pendingOwner;\\n\\n    /**\\n     * @dev Emitted when `_pendingOwner` has been changed.\\n     * @param pendingOwner new `_pendingOwner` address.\\n     */\\n    event OwnershipOffered(address indexed pendingOwner);\\n\\n    /**\\n     * @dev Emitted when `_owner` has been changed.\\n     * @param previousOwner previous `_owner` address.\\n     * @param newOwner new `_owner` address.\\n     */\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /* ============ Deploy ============ */\\n\\n    /**\\n     * @notice Initializes the contract setting `_initialOwner` as the initial owner.\\n     * @param _initialOwner Initial owner of the contract.\\n     */\\n    constructor(address _initialOwner) {\\n        _setOwner(_initialOwner);\\n    }\\n\\n    /* ============ External Functions ============ */\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Gets current `_pendingOwner`.\\n     * @return Current `_pendingOwner` address.\\n     */\\n    function pendingOwner() external view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @notice Renounce ownership of the contract.\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() external virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n    * @notice Allows current owner to set the `_pendingOwner` address.\\n    * @param _newOwner Address to transfer ownership to.\\n    */\\n    function transferOwnership(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0), \\\"Ownable/pendingOwner-not-zero-address\\\");\\n\\n        _pendingOwner = _newOwner;\\n\\n        emit OwnershipOffered(_newOwner);\\n    }\\n\\n    /**\\n    * @notice Allows the `_pendingOwner` address to finalize the transfer.\\n    * @dev This function is only callable by the `_pendingOwner`.\\n    */\\n    function claimOwnership() external onlyPendingOwner {\\n        _setOwner(_pendingOwner);\\n        _pendingOwner = address(0);\\n    }\\n\\n    /* ============ Internal Functions ============ */\\n\\n    /**\\n     * @notice Internal function to set the `_owner` of the contract.\\n     * @param _newOwner New `_owner` address.\\n     */\\n    function _setOwner(address _newOwner) private {\\n        address _oldOwner = _owner;\\n        _owner = _newOwner;\\n        emit OwnershipTransferred(_oldOwner, _newOwner);\\n    }\\n\\n    /* ============ Modifier Functions ============ */\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable/caller-not-owner\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any account other than the `pendingOwner`.\\n    */\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == _pendingOwner, \\\"Ownable/caller-not-pendingOwner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@pooltogether/v4-core/contracts/PrizeDistributionBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@pooltogether/owner-manager-contracts/contracts/Manageable.sol\\\";\\n\\nimport \\\"./libraries/DrawRingBufferLib.sol\\\";\\nimport \\\"./interfaces/IPrizeDistributionBuffer.sol\\\";\\n\\n/**\\n  * @title  PoolTogether V4 PrizeDistributionBuffer\\n  * @author PoolTogether Inc Team\\n  * @notice The PrizeDistributionBuffer contract provides historical lookups of PrizeDistribution struct parameters (linked with a Draw ID) via a\\n            circular ring buffer. Historical PrizeDistribution parameters can be accessed on-chain using a drawId to calculate\\n            ring buffer storage slot. The PrizeDistribution parameters can be created by manager/owner and existing PrizeDistribution\\n            parameters can only be updated the owner. When adding a new PrizeDistribution basic sanity checks will be used to\\n            validate the incoming parameters.\\n*/\\ncontract PrizeDistributionBuffer is IPrizeDistributionBuffer, Manageable {\\n    using DrawRingBufferLib for DrawRingBufferLib.Buffer;\\n\\n    /// @notice The maximum cardinality of the prize distribution ring buffer.\\n    /// @dev even with daily draws, 256 will give us over 8 months of history.\\n    uint256 internal constant MAX_CARDINALITY = 256;\\n\\n    /// @notice The ceiling for prize distributions.  1e9 = 100%.\\n    /// @dev It's fixed point 9 because 1e9 is the largest \\\"1\\\" that fits into 2**32\\n    uint256 internal constant TIERS_CEILING = 1e9;\\n\\n    /// @notice Emitted when the contract is deployed.\\n    /// @param cardinality The maximum number of records in the buffer before they begin to expire.\\n    event Deployed(uint8 cardinality);\\n\\n    /// @notice PrizeDistribution ring buffer history.\\n    IPrizeDistributionBuffer.PrizeDistribution[MAX_CARDINALITY]\\n        internal prizeDistributionRingBuffer;\\n\\n    /// @notice Ring buffer metadata (nextIndex, lastId, cardinality)\\n    DrawRingBufferLib.Buffer internal bufferMetadata;\\n\\n    /* ============ Constructor ============ */\\n\\n    /**\\n     * @notice Constructor for PrizeDistributionBuffer\\n     * @param _owner Address of the PrizeDistributionBuffer owner\\n     * @param _cardinality Cardinality of the `bufferMetadata`\\n     */\\n    constructor(address _owner, uint8 _cardinality) Ownable(_owner) {\\n        bufferMetadata.cardinality = _cardinality;\\n        emit Deployed(_cardinality);\\n    }\\n\\n    /* ============ External Functions ============ */\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function getBufferCardinality() external view override returns (uint32) {\\n        return bufferMetadata.cardinality;\\n    }\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function getPrizeDistribution(uint32 _drawId)\\n        external\\n        view\\n        override\\n        returns (IPrizeDistributionBuffer.PrizeDistribution memory)\\n    {\\n        return _getPrizeDistribution(bufferMetadata, _drawId);\\n    }\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function getPrizeDistributions(uint32[] calldata _drawIds)\\n        external\\n        view\\n        override\\n        returns (IPrizeDistributionBuffer.PrizeDistribution[] memory)\\n    {\\n        uint256 drawIdsLength = _drawIds.length;\\n        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;\\n        IPrizeDistributionBuffer.PrizeDistribution[]\\n            memory _prizeDistributions = new IPrizeDistributionBuffer.PrizeDistribution[](\\n                drawIdsLength\\n            );\\n\\n        for (uint256 i = 0; i < drawIdsLength; i++) {\\n            _prizeDistributions[i] = _getPrizeDistribution(buffer, _drawIds[i]);\\n        }\\n\\n        return _prizeDistributions;\\n    }\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function getPrizeDistributionCount() external view override returns (uint32) {\\n        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;\\n\\n        if (buffer.lastDrawId == 0) {\\n            return 0;\\n        }\\n\\n        uint32 bufferNextIndex = buffer.nextIndex;\\n\\n        // If the buffer is full return the cardinality, else retun the nextIndex\\n        if (prizeDistributionRingBuffer[bufferNextIndex].matchCardinality != 0) {\\n            return buffer.cardinality;\\n        } else {\\n            return bufferNextIndex;\\n        }\\n    }\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function getNewestPrizeDistribution()\\n        external\\n        view\\n        override\\n        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId)\\n    {\\n        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;\\n\\n        return (prizeDistributionRingBuffer[buffer.getIndex(buffer.lastDrawId)], buffer.lastDrawId);\\n    }\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function getOldestPrizeDistribution()\\n        external\\n        view\\n        override\\n        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId)\\n    {\\n        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;\\n\\n        // if the ring buffer is full, the oldest is at the nextIndex\\n        prizeDistribution = prizeDistributionRingBuffer[buffer.nextIndex];\\n\\n        // The PrizeDistribution at index 0 IS by default the oldest prizeDistribution.\\n        if (buffer.lastDrawId == 0) {\\n            drawId = 0; // return 0 to indicate no prizeDistribution ring buffer history\\n        } else if (prizeDistribution.bitRangeSize == 0) {\\n            // IF the next PrizeDistribution.bitRangeSize == 0 the ring buffer HAS NOT looped around so the oldest is the first entry.\\n            prizeDistribution = prizeDistributionRingBuffer[0];\\n            drawId = (buffer.lastDrawId + 1) - buffer.nextIndex;\\n        } else {\\n            // Calculates the drawId using the ring buffer cardinality\\n            // Sequential drawIds are gauranteed by DrawRingBufferLib.push()\\n            drawId = (buffer.lastDrawId + 1) - buffer.cardinality;\\n        }\\n    }\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function pushPrizeDistribution(\\n        uint32 _drawId,\\n        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution\\n    ) external override onlyManagerOrOwner returns (bool) {\\n        return _pushPrizeDistribution(_drawId, _prizeDistribution);\\n    }\\n\\n    /// @inheritdoc IPrizeDistributionBuffer\\n    function setPrizeDistribution(\\n        uint32 _drawId,\\n        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution\\n    ) external override onlyOwner returns (uint32) {\\n        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;\\n        uint32 index = buffer.getIndex(_drawId);\\n        prizeDistributionRingBuffer[index] = _prizeDistribution;\\n\\n        emit PrizeDistributionSet(_drawId, _prizeDistribution);\\n\\n        return _drawId;\\n    }\\n\\n    /* ============ Internal Functions ============ */\\n\\n    /**\\n     * @notice Gets the PrizeDistributionBuffer for a drawId\\n     * @param _buffer DrawRingBufferLib.Buffer\\n     * @param _drawId drawId\\n     */\\n    function _getPrizeDistribution(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)\\n        internal\\n        view\\n        returns (IPrizeDistributionBuffer.PrizeDistribution memory)\\n    {\\n        return prizeDistributionRingBuffer[_buffer.getIndex(_drawId)];\\n    }\\n\\n    /**\\n     * @notice Set newest PrizeDistributionBuffer in ring buffer storage.\\n     * @param _drawId       drawId\\n     * @param _prizeDistribution PrizeDistributionBuffer struct\\n     */\\n    function _pushPrizeDistribution(\\n        uint32 _drawId,\\n        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution\\n    ) internal returns (bool) {\\n        require(_drawId > 0, \\\"DrawCalc/draw-id-gt-0\\\");\\n        require(_prizeDistribution.matchCardinality > 0, \\\"DrawCalc/matchCardinality-gt-0\\\");\\n        require(\\n            _prizeDistribution.bitRangeSize <= 256 / _prizeDistribution.matchCardinality,\\n            \\\"DrawCalc/bitRangeSize-too-large\\\"\\n        );\\n\\n        require(_prizeDistribution.bitRangeSize > 0, \\\"DrawCalc/bitRangeSize-gt-0\\\");\\n        require(_prizeDistribution.maxPicksPerUser > 0, \\\"DrawCalc/maxPicksPerUser-gt-0\\\");\\n        require(_prizeDistribution.expiryDuration > 0, \\\"DrawCalc/expiryDuration-gt-0\\\");\\n\\n        // ensure that the sum of the tiers are not gt 100%\\n        uint256 sumTotalTiers = 0;\\n        uint256 tiersLength = _prizeDistribution.tiers.length;\\n\\n        for (uint256 index = 0; index < tiersLength; index++) {\\n            uint256 tier = _prizeDistribution.tiers[index];\\n            sumTotalTiers += tier;\\n        }\\n\\n        // Each tier amount stored as uint32 - summed can't exceed 1e9\\n        require(sumTotalTiers <= TIERS_CEILING, \\\"DrawCalc/tiers-gt-100%\\\");\\n\\n        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;\\n\\n        // store the PrizeDistribution in the ring buffer\\n        prizeDistributionRingBuffer[buffer.nextIndex] = _prizeDistribution;\\n\\n        // update the ring buffer data\\n        bufferMetadata = buffer.push(_drawId);\\n\\n        emit PrizeDistributionSet(_drawId, _prizeDistribution);\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\n/** @title  IPrizeDistributionBuffer\\n  * @author PoolTogether Inc Team\\n  * @notice The PrizeDistributionBuffer interface.\\n*/\\ninterface IPrizeDistributionBuffer {\\n\\n    ///@notice PrizeDistribution struct created every draw\\n    ///@param bitRangeSize Decimal representation of bitRangeSize\\n    ///@param matchCardinality The number of numbers to consider in the 256 bit random number. Must be > 1 and < 256/bitRangeSize.\\n    ///@param startTimestampOffset The starting time offset in seconds from which Ticket balances are calculated.\\n    ///@param endTimestampOffset The end time offset in seconds from which Ticket balances are calculated.\\n    ///@param maxPicksPerUser Maximum number of picks a user can make in this draw\\n    ///@param expiryDuration Length of time in seconds the PrizeDistribution is valid for. Relative to the Draw.timestamp.\\n    ///@param numberOfPicks Number of picks this draw has (may vary across networks according to how much the network has contributed to the Reserve)\\n    ///@param tiers Array of prize tiers percentages, expressed in fraction form with base 1e9. Ordering: index0: grandPrize, index1: runnerUp, etc.\\n    ///@param prize Total prize amount available in this draw calculator for this draw (may vary from across networks)\\n    struct PrizeDistribution {\\n        uint8 bitRangeSize;\\n        uint8 matchCardinality;\\n        uint32 startTimestampOffset;\\n        uint32 endTimestampOffset;\\n        uint32 maxPicksPerUser;\\n        uint32 expiryDuration;\\n        uint104 numberOfPicks;\\n        uint32[16] tiers;\\n        uint256 prize;\\n    }\\n\\n    /**\\n     * @notice Emit when PrizeDistribution is set.\\n     * @param drawId       Draw id\\n     * @param prizeDistribution IPrizeDistributionBuffer.PrizeDistribution\\n     */\\n    event PrizeDistributionSet(\\n        uint32 indexed drawId,\\n        IPrizeDistributionBuffer.PrizeDistribution prizeDistribution\\n    );\\n\\n    /**\\n     * @notice Read a ring buffer cardinality\\n     * @return Ring buffer cardinality\\n     */\\n    function getBufferCardinality() external view returns (uint32);\\n\\n    /**\\n     * @notice Read newest PrizeDistribution from prize distributions ring buffer.\\n     * @dev    Uses nextDrawIndex to calculate the most recently added PrizeDistribution.\\n     * @return prizeDistribution\\n     * @return drawId\\n     */\\n    function getNewestPrizeDistribution()\\n        external\\n        view\\n        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId);\\n\\n    /**\\n     * @notice Read oldest PrizeDistribution from prize distributions ring buffer.\\n     * @dev    Finds the oldest Draw by buffer.nextIndex and buffer.lastDrawId\\n     * @return prizeDistribution\\n     * @return drawId\\n     */\\n    function getOldestPrizeDistribution()\\n        external\\n        view\\n        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId);\\n\\n    /**\\n     * @notice Gets PrizeDistribution list from array of drawIds\\n     * @param drawIds drawIds to get PrizeDistribution for\\n     * @return prizeDistributionList\\n     */\\n    function getPrizeDistributions(uint32[] calldata drawIds)\\n        external\\n        view\\n        returns (IPrizeDistributionBuffer.PrizeDistribution[] memory);\\n\\n    /**\\n     * @notice Gets the PrizeDistributionBuffer for a drawId\\n     * @param drawId drawId\\n     * @return prizeDistribution\\n     */\\n    function getPrizeDistribution(uint32 drawId)\\n        external\\n        view\\n        returns (IPrizeDistributionBuffer.PrizeDistribution memory);\\n\\n    /**\\n     * @notice Gets the number of PrizeDistributions stored in the prize distributions ring buffer.\\n     * @dev If no Draws have been pushed, it will return 0.\\n     * @dev If the ring buffer is full, it will return the cardinality.\\n     * @dev Otherwise, it will return the NewestPrizeDistribution index + 1.\\n     * @return Number of PrizeDistributions stored in the prize distributions ring buffer.\\n     */\\n    function getPrizeDistributionCount() external view returns (uint32);\\n\\n    /**\\n     * @notice Adds new PrizeDistribution record to ring buffer storage.\\n     * @dev    Only callable by the owner or manager\\n     * @param drawId            Draw ID linked to PrizeDistribution parameters\\n     * @param prizeDistribution PrizeDistribution parameters struct\\n     */\\n    function pushPrizeDistribution(\\n        uint32 drawId,\\n        IPrizeDistributionBuffer.PrizeDistribution calldata prizeDistribution\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice Sets existing PrizeDistribution with new PrizeDistribution parameters in ring buffer storage.\\n     * @dev    Retroactively updates an existing PrizeDistribution and should be thought of as a \\\"safety\\\"\\n               fallback. If the manager is setting invalid PrizeDistribution parameters the Owner can update\\n               the invalid parameters with correct parameters.\\n     * @return drawId\\n     */\\n    function setPrizeDistribution(uint32 drawId, IPrizeDistributionBuffer.PrizeDistribution calldata draw)\\n        external\\n        returns (uint32);\\n}\\n\"\r\n    },\r\n    \"@pooltogether/v4-core/contracts/libraries/DrawRingBufferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"./RingBufferLib.sol\\\";\\n\\n/// @title Library for creating and managing a draw ring buffer.\\nlibrary DrawRingBufferLib {\\n    /// @notice Draw buffer struct.\\n    struct Buffer {\\n        uint32 lastDrawId;\\n        uint32 nextIndex;\\n        uint32 cardinality;\\n    }\\n\\n    /// @notice Helper function to know if the draw ring buffer has been initialized.\\n    /// @dev since draws start at 1 and are monotonically increased, we know we are uninitialized if nextIndex = 0 and lastDrawId = 0.\\n    /// @param _buffer The buffer to check.\\n    function isInitialized(Buffer memory _buffer) internal pure returns (bool) {\\n        return !(_buffer.nextIndex == 0 && _buffer.lastDrawId == 0);\\n    }\\n\\n    /// @notice Push a draw to the buffer.\\n    /// @param _buffer The buffer to push to.\\n    /// @param _drawId The drawID to push.\\n    /// @return The new buffer.\\n    function push(Buffer memory _buffer, uint32 _drawId) internal pure returns (Buffer memory) {\\n        require(!isInitialized(_buffer) || _drawId == _buffer.lastDrawId + 1, \\\"DRB/must-be-contig\\\");\\n\\n        return\\n            Buffer({\\n                lastDrawId: _drawId,\\n                nextIndex: uint32(RingBufferLib.nextIndex(_buffer.nextIndex, _buffer.cardinality)),\\n                cardinality: _buffer.cardinality\\n            });\\n    }\\n\\n    /// @notice Get draw ring buffer index pointer.\\n    /// @param _buffer The buffer to get the `nextIndex` from.\\n    /// @param _drawId The draw id to get the index for.\\n    /// @return The draw ring buffer index pointer.\\n    function getIndex(Buffer memory _buffer, uint32 _drawId) internal pure returns (uint32) {\\n        require(isInitialized(_buffer) && _drawId <= _buffer.lastDrawId, \\\"DRB/future-draw\\\");\\n\\n        uint32 indexOffset = _buffer.lastDrawId - _drawId;\\n        require(indexOffset < _buffer.cardinality, \\\"DRB/expired-draw\\\");\\n\\n        uint256 mostRecent = RingBufferLib.newestIndex(_buffer.nextIndex, _buffer.cardinality);\\n\\n        return uint32(RingBufferLib.offset(uint32(mostRecent), indexOffset, _buffer.cardinality));\\n    }\\n}\\n\"\r\n    },\r\n    \"@pooltogether/v4-core/contracts/libraries/RingBufferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nlibrary RingBufferLib {\\n    /**\\n    * @notice Returns wrapped TWAB index.\\n    * @dev  In order to navigate the TWAB circular buffer, we need to use the modulo operator.\\n    * @dev  For example, if `_index` is equal to 32 and the TWAB circular buffer is of `_cardinality` 32,\\n    *       it will return 0 and will point to the first element of the array.\\n    * @param _index Index used to navigate through the TWAB circular buffer.\\n    * @param _cardinality TWAB buffer cardinality.\\n    * @return TWAB index.\\n    */\\n    function wrap(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\\n        return _index % _cardinality;\\n    }\\n\\n    /**\\n    * @notice Computes the negative offset from the given index, wrapped by the cardinality.\\n    * @dev  We add `_cardinality` to `_index` to be able to offset even if `_amount` is superior to `_cardinality`.\\n    * @param _index The index from which to offset\\n    * @param _amount The number of indices to offset.  This is subtracted from the given index.\\n    * @param _cardinality The number of elements in the ring buffer\\n    * @return Offsetted index.\\n     */\\n    function offset(\\n        uint256 _index,\\n        uint256 _amount,\\n        uint256 _cardinality\\n    ) internal pure returns (uint256) {\\n        return wrap(_index + _cardinality - _amount, _cardinality);\\n    }\\n\\n    /// @notice Returns the index of the last recorded TWAB\\n    /// @param _nextIndex The next available twab index.  This will be recorded to next.\\n    /// @param _cardinality The cardinality of the TWAB history.\\n    /// @return The index of the last recorded TWAB\\n    function newestIndex(uint256 _nextIndex, uint256 _cardinality)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (_cardinality == 0) {\\n            return 0;\\n        }\\n\\n        return wrap(_nextIndex + _cardinality - 1, _cardinality);\\n    }\\n\\n    /// @notice Computes the ring buffer index that follows the given one, wrapped by cardinality\\n    /// @param _index The index to increment\\n    /// @param _cardinality The number of elements in the Ring Buffer\\n    /// @return The next index relative to the given index.  Will wrap around to 0 if the next index == cardinality\\n    function nextIndex(uint256 _index, uint256 _cardinality)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return wrap(_index + 1, _cardinality);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_cardinality\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cardinality\",\"type\":\"uint8\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"drawId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bitRangeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matchCardinality\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPicksPerUser\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint104\",\"name\":\"numberOfPicks\",\"type\":\"uint104\"},{\"internalType\":\"uint32[16]\",\"name\":\"tiers\",\"type\":\"uint32[16]\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IPrizeDistributionBuffer.PrizeDistribution\",\"name\":\"prizeDistribution\",\"type\":\"tuple\"}],\"name\":\"PrizeDistributionSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBufferCardinality\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNewestPrizeDistribution\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bitRangeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matchCardinality\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPicksPerUser\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint104\",\"name\":\"numberOfPicks\",\"type\":\"uint104\"},{\"internalType\":\"uint32[16]\",\"name\":\"tiers\",\"type\":\"uint32[16]\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrizeDistributionBuffer.PrizeDistribution\",\"name\":\"prizeDistribution\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"drawId\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOldestPrizeDistribution\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bitRangeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matchCardinality\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPicksPerUser\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint104\",\"name\":\"numberOfPicks\",\"type\":\"uint104\"},{\"internalType\":\"uint32[16]\",\"name\":\"tiers\",\"type\":\"uint32[16]\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrizeDistributionBuffer.PrizeDistribution\",\"name\":\"prizeDistribution\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"drawId\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_drawId\",\"type\":\"uint32\"}],\"name\":\"getPrizeDistribution\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bitRangeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matchCardinality\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPicksPerUser\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint104\",\"name\":\"numberOfPicks\",\"type\":\"uint104\"},{\"internalType\":\"uint32[16]\",\"name\":\"tiers\",\"type\":\"uint32[16]\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrizeDistributionBuffer.PrizeDistribution\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrizeDistributionCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_drawIds\",\"type\":\"uint32[]\"}],\"name\":\"getPrizeDistributions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bitRangeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matchCardinality\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPicksPerUser\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint104\",\"name\":\"numberOfPicks\",\"type\":\"uint104\"},{\"internalType\":\"uint32[16]\",\"name\":\"tiers\",\"type\":\"uint32[16]\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrizeDistributionBuffer.PrizeDistribution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_drawId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bitRangeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matchCardinality\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPicksPerUser\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint104\",\"name\":\"numberOfPicks\",\"type\":\"uint104\"},{\"internalType\":\"uint32[16]\",\"name\":\"tiers\",\"type\":\"uint32[16]\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrizeDistributionBuffer.PrizeDistribution\",\"name\":\"_prizeDistribution\",\"type\":\"tuple\"}],\"name\":\"pushPrizeDistribution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_drawId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bitRangeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matchCardinality\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"startTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestampOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPicksPerUser\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint104\",\"name\":\"numberOfPicks\",\"type\":\"uint104\"},{\"internalType\":\"uint32[16]\",\"name\":\"tiers\",\"type\":\"uint32[16]\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrizeDistributionBuffer.PrizeDistribution\",\"name\":\"_prizeDistribution\",\"type\":\"tuple\"}],\"name\":\"setPrizeDistribution\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PrizeDistributionBuffer","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000e0f4217390221af47855e094f6e112d43c8698fe00000000000000000000000000000000000000000000000000000000000000b4","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}