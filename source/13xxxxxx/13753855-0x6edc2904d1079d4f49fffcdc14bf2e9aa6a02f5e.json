{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MultiNodeV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IMultiNode.sol\\\";\\nimport \\\"./interfaces/IStrongPool.sol\\\";\\nimport \\\"./interfaces/IStrongNFTBonus.sol\\\";\\nimport \\\"./lib/InternalCalls.sol\\\";\\nimport \\\"./lib/MultiNodeSettings.sol\\\";\\nimport \\\"./lib/SbMath.sol\\\";\\n\\ncontract MultiNodeV1 is IMultiNode, InternalCalls, MultiNodeSettings {\\n\\n  uint private constant _SECONDS_IN_ONE_MINUTE = 60;\\n\\n  IERC20 public strongToken;\\n  IStrongNFTBonus public strongNFTBonus;\\n\\n  uint public totalNodes;\\n  uint public nodesLimit;\\n  uint public takeStrongBips;\\n  address payable public feeCollector;\\n  mapping(address => bool) private serviceContractEnabled;\\n\\n  mapping(address => uint) public entityNodeCount;\\n  mapping(address => uint) public entityCreditUsed;\\n  mapping(address => mapping(uint => uint)) public entityNodeTypeCount;\\n  mapping(bytes => uint) public entityNodeType;\\n  mapping(bytes => uint) public entityNodeCreatedAt;\\n  mapping(bytes => uint) public entityNodeLastPaidAt;\\n  mapping(bytes => uint) public entityNodeLastClaimedAt;\\n\\n  // Events\\n\\n  event Created(address indexed entity, uint nodeType, uint nodeId, bool usedCredit, uint timestamp);\\n  event Paid(address indexed entity, uint nodeType, uint nodeId, uint timestamp);\\n  event Claimed(address indexed entity, uint nodeId, uint reward);\\n  event MigratedFromService(address indexed service, address indexed entity, uint nodeType, uint nodeId, uint lastPaidAt);\\n  event SetFeeCollector(address payable collector);\\n  event SetNFTBonusContract(address strongNFTBonus);\\n  event SetNodesLimit(uint limit);\\n  event SetServiceContractEnabled(address service, bool enabled);\\n  event SetTakeStrongBips(uint bips);\\n\\n  function init(\\n    IERC20 _strongToken,\\n    IStrongNFTBonus _strongNFTBonus,\\n    address payable _feeCollector\\n  ) external onlyRole(adminControl.SUPER_ADMIN()) {\\n    require(_feeCollector != address(0), \\\"no address\\\");\\n\\n    strongToken = _strongToken;\\n    strongNFTBonus = _strongNFTBonus;\\n    feeCollector = _feeCollector;\\n\\n    InternalCalls.init();\\n  }\\n\\n  //\\n  // Getters\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function getRewardBalance() external view returns (uint) {\\n    return strongToken.balanceOf(address(this));\\n  }\\n\\n  function calcDecayedReward(uint _baseRate, uint _decayFactor, uint _minutesPassed) public pure returns (uint) {\\n    uint power = SbMath._decPow(_decayFactor, _minutesPassed);\\n    uint cumulativeFraction = SbMath.DECIMAL_PRECISION - power;\\n\\n    return _baseRate * cumulativeFraction / SbMath.DECIMAL_PRECISION;\\n  }\\n\\n  function canNodeBePaid(address _entity, uint _nodeId) public view returns (bool) {\\n    return doesNodeExist(_entity, _nodeId) && !hasNodeExpired(_entity, _nodeId) && !hasMaxPayments(_entity, _nodeId);\\n  }\\n\\n  function doesNodeExist(address _entity, uint _nodeId) public view returns (bool) {\\n    return entityNodeLastPaidAt[getNodeId(_entity, _nodeId)] > 0;\\n  }\\n\\n  function isNodePastDue(address _entity, uint _nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(_entity, _nodeId);\\n    uint nodeType = entityNodeType[id];\\n    uint lastPaidAt = entityNodeLastPaidAt[id];\\n\\n    return block.timestamp > (lastPaidAt + getRecurringPaymentCycle(nodeType));\\n  }\\n\\n  function hasNodeExpired(address _entity, uint _nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(_entity, _nodeId);\\n    uint nodeType = entityNodeType[id];\\n    uint lastPaidAt = entityNodeLastPaidAt[id];\\n    if (lastPaidAt == 0) return true;\\n\\n    return block.timestamp > (lastPaidAt + getRecurringPaymentCycle(nodeType) + getGracePeriod(nodeType));\\n  }\\n\\n  function hasMaxPayments(address _entity, uint _nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(_entity, _nodeId);\\n    uint nodeType = entityNodeType[id];\\n    uint lastPaidAt = entityNodeLastPaidAt[id];\\n    uint recurringPaymentCycle = getRecurringPaymentCycle(nodeType);\\n    uint limit = block.timestamp + recurringPaymentCycle * getPayCyclesLimit(nodeType);\\n\\n    return lastPaidAt + recurringPaymentCycle >= limit;\\n  }\\n\\n  function getNodeId(address _entity, uint _nodeId) public view returns (bytes memory) {\\n    uint id = _nodeId != 0 ? _nodeId : entityNodeCount[_entity] + 1;\\n    return abi.encodePacked(_entity, id);\\n  }\\n\\n  function getNodeType(address _entity, uint _nodeId) public view returns (uint) {\\n    return entityNodeType[getNodeId(_entity, _nodeId)];\\n  }\\n\\n  function getNodeRecurringFee(address _entity, uint _nodeId) external view returns (uint) {\\n    return getRecurringFeeInWei(entityNodeType[getNodeId(_entity, _nodeId)]);\\n  }\\n\\n  function getNodeClaimingFee(address _entity, uint _nodeId, uint _timestamp) external view returns (uint) {\\n    uint nodeType = entityNodeType[getNodeId(_entity, _nodeId)];\\n    uint reward = getRewardAt(_entity, _nodeId, _timestamp);\\n    return reward * getClaimingFeeNumerator(nodeType) / getClaimingFeeDenominator(nodeType);\\n  }\\n\\n  function getNodePaidOn(address _entity, uint _nodeId) external view returns (uint) {\\n    return entityNodeLastPaidAt[getNodeId(_entity, _nodeId)];\\n  }\\n\\n  function getNodeReward(address _entity, uint _nodeId) external view returns (uint) {\\n    return getRewardAt(_entity, _nodeId, block.timestamp);\\n  }\\n\\n  function getRewardAt(address _entity, uint _nodeId, uint _timestamp) public view returns (uint) {\\n    bytes memory id = getNodeId(_entity, _nodeId);\\n    uint nodeType = entityNodeType[id];\\n    uint lastClaimedAt = entityNodeLastClaimedAt[id] != 0 ? entityNodeLastClaimedAt[id] : entityNodeCreatedAt[id];\\n    uint registeredAt = entityNodeCreatedAt[id];\\n\\n    if (!doesNodeExist(_entity, _nodeId)) return 0;\\n    if (hasNodeExpired(_entity, _nodeId)) return 0;\\n    if (_timestamp > block.timestamp) return 0;\\n    if (_timestamp <= lastClaimedAt) return 0;\\n\\n    uint minutesTotal = (_timestamp - registeredAt) / _SECONDS_IN_ONE_MINUTE;\\n\\n    uint reward = calcDecayedReward(\\n      getRewardBaseRate(nodeType),\\n      getRewardDecayFactor(nodeType),\\n      minutesTotal\\n    );\\n\\n    if (lastClaimedAt > 0) {\\n      uint minutesToLastClaim = (lastClaimedAt - registeredAt) / _SECONDS_IN_ONE_MINUTE;\\n      uint rewardAtLastClaim = calcDecayedReward(getRewardBaseRate(nodeType), getRewardDecayFactor(nodeType), minutesToLastClaim);\\n      reward = reward - rewardAtLastClaim;\\n    }\\n\\n    uint bonus = getNftBonusAt(_entity, _nodeId, _timestamp);\\n\\n    return reward + bonus;\\n  }\\n\\n  function getNftBonusAt(address _entity, uint _nodeId, uint _timestamp) public view returns (uint) {\\n    if (address(strongNFTBonus) == address(0)) return 0;\\n\\n    bytes memory id = getNodeId(_entity, _nodeId);\\n    uint nodeType = entityNodeType[id];\\n    uint lastClaimedAt = entityNodeLastClaimedAt[id] != 0 ? entityNodeLastClaimedAt[id] : entityNodeCreatedAt[id];\\n    string memory bonusName = strongNFTBonus.getStakedNftBonusName(_entity, uint128(_nodeId), address(this));\\n\\n    if (keccak256(abi.encode(bonusName)) == keccak256(abi.encode(\\\"\\\"))) return 0;\\n\\n    uint bonusValue = getNftBonusValue(nodeType, bonusName);\\n\\n    return bonusValue > 0\\n    ? strongNFTBonus.getBonusValue(_entity, uint128(_nodeId), lastClaimedAt, _timestamp, bonusValue)\\n    : 0;\\n  }\\n\\n  function getEntityRewards(address _entity, uint _timestamp) public view returns (uint) {\\n    uint reward = 0;\\n\\n    for (uint nodeId = 1; nodeId <= entityNodeCount[_entity]; nodeId++) {\\n      reward = reward + getRewardAt(_entity, nodeId, _timestamp > 0 ? _timestamp : block.timestamp);\\n    }\\n\\n    return reward;\\n  }\\n\\n  function getEntityCreditAvailable(address _entity, uint _timestamp) public view returns (uint) {\\n    return getEntityRewards(_entity, _timestamp) - entityCreditUsed[_entity];\\n  }\\n\\n  function getNodesRecurringFee(address _entity, uint _fromNode, uint _toNode) external view returns (uint) {\\n    uint fee = 0;\\n    uint fromNode = _fromNode > 0 ? _fromNode : 1;\\n    uint toNode = _toNode > 0 ? _toNode : entityNodeCount[_entity];\\n\\n    for (uint nodeId = fromNode; nodeId <= toNode; nodeId++) {\\n      if (canNodeBePaid(_entity, nodeId)) fee = fee + getRecurringFeeInWei(getNodeType(_entity, nodeId));\\n    }\\n\\n    return fee;\\n  }\\n\\n  function getNodesClaimingFee(address _entity, uint _timestamp, uint _fromNode, uint _toNode) external view returns (uint) {\\n    uint fee = 0;\\n    uint fromNode = _fromNode > 0 ? _fromNode : 1;\\n    uint toNode = _toNode > 0 ? _toNode : entityNodeCount[_entity];\\n\\n    for (uint nodeId = fromNode; nodeId <= toNode; nodeId++) {\\n      uint reward = getRewardAt(_entity, nodeId, _timestamp > 0 ? _timestamp : block.timestamp);\\n      if (reward > 0) {\\n        uint nodeType = getNodeType(_entity, nodeId);\\n        fee = fee + reward * getClaimingFeeNumerator(nodeType) / getClaimingFeeDenominator(nodeType);\\n      }\\n    }\\n\\n    return fee;\\n  }\\n\\n  //\\n  // Actions\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function createNode(uint _nodeType, bool _useCredit) external payable {\\n    uint fee = getCreatingFeeInWei(_nodeType);\\n    uint strongFee = getStrongFeeInWei(_nodeType);\\n    uint nodeTypeLimit = getNodesLimit(_nodeType);\\n\\n    require(nodeTypeActive[_nodeType], \\\"invalid type\\\");\\n    require(nodesLimit == 0 || entityNodeCount[msg.sender] < nodesLimit, \\\"over limit\\\");\\n    require(nodeTypeLimit == 0 || entityNodeTypeCount[msg.sender][_nodeType] < nodeTypeLimit, \\\"over limit\\\");\\n    require(msg.value >= fee, \\\"invalid fee\\\");\\n\\n    uint nodeId = entityNodeCount[msg.sender] + 1;\\n    bytes memory id = getNodeId(msg.sender, nodeId);\\n\\n    totalNodes = totalNodes + 1;\\n    entityNodeType[id] = _nodeType;\\n    entityNodeCreatedAt[id] = block.timestamp;\\n    entityNodeLastPaidAt[id] = block.timestamp;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\\n    entityNodeTypeCount[msg.sender][_nodeType] = entityNodeTypeCount[msg.sender][_nodeType] + 1;\\n\\n    emit Created(msg.sender, _nodeType, nodeId, _useCredit, block.timestamp);\\n\\n    if (_useCredit) {\\n      require(getEntityCreditAvailable(msg.sender, block.timestamp) >= strongFee, \\\"not enough\\\");\\n      entityCreditUsed[msg.sender] = entityCreditUsed[msg.sender] + strongFee;\\n    } else {\\n      uint takeStrong = strongFee * takeStrongBips / 10000;\\n      require(strongToken.transferFrom(msg.sender, feeCollector, takeStrong), \\\"transfer failed\\\");\\n      if (strongFee > takeStrong) {\\n        require(strongToken.transferFrom(msg.sender, address(this), strongFee - takeStrong), \\\"transfer failed\\\");\\n      }\\n    }\\n\\n    sendValue(feeCollector, fee);\\n    if (msg.value > fee) sendValue(payable(msg.sender), msg.value - fee);\\n  }\\n\\n  function claim(uint _nodeId, uint _timestamp, address _toStrongPool) public payable returns (uint) {\\n    address entity = msg.sender == address(strongNFTBonus) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(entity, _nodeId);\\n    uint nodeType = entityNodeType[id];\\n    uint lastClaimedAt = entityNodeLastClaimedAt[id] != 0 ? entityNodeLastClaimedAt[id] : entityNodeCreatedAt[id];\\n\\n    require(doesNodeExist(entity, _nodeId), \\\"doesnt exist\\\");\\n    require(!hasNodeExpired(entity, _nodeId), \\\"node expired\\\");\\n    require(!isNodePastDue(entity, _nodeId), \\\"past due\\\");\\n    require(_timestamp <= block.timestamp, \\\"bad timestamp\\\");\\n    require(lastClaimedAt + 900 < _timestamp, \\\"too soon\\\");\\n\\n    uint reward = getRewardAt(entity, _nodeId, _timestamp);\\n    require(reward > 0, \\\"no reward\\\");\\n    require(strongToken.balanceOf(address(this)) >= reward, \\\"over balance\\\");\\n\\n    uint fee = reward * getClaimingFeeNumerator(nodeType) / getClaimingFeeDenominator(nodeType);\\n    require(msg.value >= fee, \\\"invalid fee\\\");\\n\\n    entityNodeLastClaimedAt[id] = _timestamp;\\n\\n    emit Claimed(entity, _nodeId, reward);\\n\\n    if (entityCreditUsed[msg.sender] > 0) {\\n      if (entityCreditUsed[msg.sender] > reward) {\\n        entityCreditUsed[msg.sender] = entityCreditUsed[msg.sender] - reward;\\n        reward = 0;\\n      } else {\\n        reward = reward - entityCreditUsed[msg.sender];\\n        entityCreditUsed[msg.sender] = 0;\\n      }\\n    }\\n\\n    if (reward > 0) {\\n      if (_toStrongPool != address(0)) IStrongPool(_toStrongPool).mineFor(entity, reward);\\n      else require(strongToken.transfer(entity, reward), \\\"transfer failed\\\");\\n    }\\n\\n    sendValue(feeCollector, fee);\\n    if (isUserCall() && msg.value > fee) sendValue(payable(msg.sender), msg.value - fee);\\n\\n    return fee;\\n  }\\n\\n  function claimAll(uint _timestamp, address _toStrongPool, uint _fromNode, uint _toNode) external payable makesInternalCalls {\\n    require(entityNodeCount[msg.sender] > 0, \\\"no nodes\\\");\\n\\n    uint valueLeft = msg.value;\\n    uint fromNode = _fromNode > 0 ? _fromNode : 1;\\n    uint toNode = _toNode > 0 ? _toNode : entityNodeCount[msg.sender];\\n\\n    for (uint nodeId = fromNode; nodeId <= toNode; nodeId++) {\\n      uint reward = getRewardAt(msg.sender, nodeId, _timestamp);\\n\\n      if (reward > 0) {\\n        require(valueLeft > 0, \\\"not enough\\\");\\n        uint paid = claim(nodeId, _timestamp, _toStrongPool);\\n        valueLeft = valueLeft - paid;\\n      }\\n    }\\n\\n    if (valueLeft > 0) sendValue(payable(msg.sender), valueLeft);\\n  }\\n\\n  function pay(uint _nodeId) public payable returns (uint) {\\n    bytes memory id = getNodeId(msg.sender, _nodeId);\\n    uint nodeType = entityNodeType[id];\\n    uint fee = getRecurringFeeInWei(nodeType);\\n\\n    require(canNodeBePaid(msg.sender, _nodeId), \\\"cant pay\\\");\\n    require(msg.value >= fee, \\\"invalid fee\\\");\\n\\n    entityNodeLastPaidAt[id] = entityNodeLastPaidAt[id] + getRecurringPaymentCycle(nodeType);\\n    emit Paid(msg.sender, nodeType, _nodeId, entityNodeLastPaidAt[id]);\\n\\n    sendValue(feeCollector, fee);\\n    if (isUserCall() && msg.value > fee) sendValue(payable(msg.sender), msg.value - fee);\\n\\n    return fee;\\n  }\\n\\n  function payAll(uint _fromNode, uint _toNode) external payable makesInternalCalls {\\n    require(entityNodeCount[msg.sender] > 0, \\\"no nodes\\\");\\n\\n    uint valueLeft = msg.value;\\n    uint fromNode = _fromNode > 0 ? _fromNode : 1;\\n    uint toNode = _toNode > 0 ? _toNode : entityNodeCount[msg.sender];\\n\\n    for (uint nodeId = fromNode; nodeId <= toNode; nodeId++) {\\n      if (!canNodeBePaid(msg.sender, nodeId)) continue;\\n\\n      require(valueLeft > 0, \\\"not enough\\\");\\n      uint paid = pay(nodeId);\\n      valueLeft = valueLeft - paid;\\n    }\\n\\n    if (valueLeft > 0) sendValue(payable(msg.sender), valueLeft);\\n  }\\n\\n  function migrateNode(address _entity, uint _nodeType, uint _lastPaidAt) external returns (uint) {\\n    require(serviceContractEnabled[msg.sender], \\\"no service\\\");\\n    require(nodeTypeActive[_nodeType], \\\"invalid type\\\");\\n\\n    uint nodeId = entityNodeCount[_entity] + 1;\\n    bytes memory id = getNodeId(_entity, nodeId);\\n\\n    totalNodes = totalNodes + 1;\\n\\n    entityNodeType[id] = _nodeType;\\n    entityNodeCreatedAt[id] = _lastPaidAt;\\n    entityNodeLastPaidAt[id] = _lastPaidAt;\\n    entityNodeCount[_entity] = entityNodeCount[_entity] + 1;\\n    entityNodeTypeCount[_entity][_nodeType] = entityNodeTypeCount[_entity][_nodeType] + 1;\\n\\n    emit MigratedFromService(msg.sender, _entity, _nodeType, nodeId, _lastPaidAt);\\n\\n    return nodeId;\\n  }\\n\\n  //\\n  // Admin\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function deposit(uint _amount) external onlyRole(adminControl.SUPER_ADMIN()) {\\n    require(_amount > 0);\\n    require(strongToken.transferFrom(msg.sender, address(this), _amount), \\\"transfer failed\\\");\\n  }\\n\\n  function withdraw(address _destination, uint _amount) external onlyRole(adminControl.SUPER_ADMIN()) {\\n    require(_amount > 0);\\n    require(strongToken.balanceOf(address(this)) >= _amount, \\\"over balance\\\");\\n    require(strongToken.transfer(_destination, _amount), \\\"transfer failed\\\");\\n  }\\n\\n  function approveStrongPool(IStrongPool _strongPool, uint _amount) external onlyRole(adminControl.SUPER_ADMIN()) {\\n    require(strongToken.approve(address(_strongPool), _amount), \\\"approve failed\\\");\\n  }\\n\\n  function setFeeCollector(address payable _feeCollector) external onlyRole(adminControl.SUPER_ADMIN()) {\\n    require(_feeCollector != address(0));\\n    feeCollector = _feeCollector;\\n    emit SetFeeCollector(_feeCollector);\\n  }\\n\\n  function setNFTBonusContract(address _contract) external onlyRole(adminControl.SERVICE_ADMIN()) {\\n    strongNFTBonus = IStrongNFTBonus(_contract);\\n    emit SetNFTBonusContract(_contract);\\n  }\\n\\n  function setNodesLimit(uint _limit) external onlyRole(adminControl.SERVICE_ADMIN()) {\\n    nodesLimit = _limit;\\n    emit SetNodesLimit(_limit);\\n  }\\n\\n  function setServiceContractEnabled(address _contract, bool _enabled) external onlyRole(adminControl.SERVICE_ADMIN()) {\\n    serviceContractEnabled[_contract] = _enabled;\\n    emit SetServiceContractEnabled(_contract, _enabled);\\n  }\\n\\n  function setTakeStrongBips(uint _bips) external onlyRole(adminControl.SUPER_ADMIN()) {\\n    require(_bips <= 10000, \\\"invalid value\\\");\\n    takeStrongBips = _bips;\\n    emit SetTakeStrongBips(_bips);\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"insufficient balance\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success,) = recipient.call{value : amount}(\\\"\\\");\\n    require(success, \\\"send failed\\\");\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMultiNode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\ninterface IMultiNode {\\n  function doesNodeExist(address entity, uint nodeId) external view returns (bool);\\n\\n  function hasNodeExpired(address entity, uint nodeId) external view returns (bool);\\n\\n  function claim(uint nodeId, uint timestamp, address toStrongPool) external payable returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrongPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\ninterface IStrongPool {\\n  function mineFor(address miner, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrongNFTBonus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\ninterface IStrongNFTBonus {\\n  function getBonus(address _entity, uint128 _nodeId, uint256 _from, uint256 _to) external view returns (uint256);\\n\\n  function getBonusValue(address _entity, uint128 _nodeId, uint256 _from, uint256 _to, uint256 _bonusValue) external view returns (uint256);\\n\\n  function getStakedNftBonusName(address _entity, uint128 _nodeId, address _serviceContract) external view returns (string memory);\\n\\n  function migrateNFT(address _entity, uint128 _fromNodeId, uint128 _toNodeId, address _toServiceContract) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/InternalCalls.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract InternalCalls is Context {\\n\\n  uint private constant _NOT_MAKING_INTERNAL_CALLS = 1;\\n  uint private constant _MAKING_INTERNAL_CALLS = 2;\\n\\n  uint private _internal_calls_status;\\n\\n  modifier makesInternalCalls() {\\n    _internal_calls_status = _MAKING_INTERNAL_CALLS;\\n    _;\\n    _internal_calls_status = _NOT_MAKING_INTERNAL_CALLS;\\n  }\\n\\n  function init() internal {\\n    _internal_calls_status = _NOT_MAKING_INTERNAL_CALLS;\\n  }\\n\\n  function isInternalCall() internal view returns (bool) {\\n    return _internal_calls_status == _MAKING_INTERNAL_CALLS;\\n  }\\n\\n  function isContractCall() internal view returns (bool) {\\n    return _msgSender() != tx.origin;\\n  }\\n\\n  function isUserCall() internal view returns (bool) {\\n    return !isInternalCall() && !isContractCall();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MultiNodeSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"./AdminAccess.sol\\\";\\n\\ncontract MultiNodeSettings is AdminAccess {\\n\\n  uint constant public NODE_TYPE_REWARD_BASE_RATE = 0;\\n  uint constant public NODE_TYPE_REWARD_DECAY_FACTOR = 1;\\n  uint constant public NODE_TYPE_FEE_STRONG = 2;\\n  uint constant public NODE_TYPE_FEE_CREATE = 3;\\n  uint constant public NODE_TYPE_FEE_RECURRING = 4;\\n  uint constant public NODE_TYPE_FEE_CLAIMING_NUMERATOR = 5;\\n  uint constant public NODE_TYPE_FEE_CLAIMING_DENOMINATOR = 6;\\n  uint constant public NODE_TYPE_RECURRING_CYCLE_SECONDS = 7;\\n  uint constant public NODE_TYPE_GRACE_PERIOD_SECONDS = 8;\\n  uint constant public NODE_TYPE_PAY_CYCLES_LIMIT = 9;\\n  uint constant public NODE_TYPE_NODES_LIMIT = 10;\\n\\n  mapping(uint => bool) public nodeTypeActive;\\n  mapping(uint => bool) public nodeTypeHasSettings;\\n  mapping(uint => mapping(uint => uint)) public nodeTypeSettings;\\n  mapping(uint => mapping(string => uint)) public nodeTypeNFTBonus;\\n\\n  // Events\\n\\n  event SetNodeTypeActive(uint nodeType, bool active);\\n  event SetNodeTypeSetting(uint nodeType, uint settingId, uint value);\\n  event SetNodeTypeHasSettings(uint nodeType, bool hasSettings);\\n  event SetNodeTypeNFTBonus(uint nodeType, string bonusName, uint value);\\n\\n  //\\n  // Getters\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function getRewardBaseRate(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_REWARD_BASE_RATE);\\n  }\\n\\n  function getRewardDecayFactor(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_REWARD_DECAY_FACTOR);\\n  }\\n\\n  function getClaimingFeeNumerator(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_FEE_CLAIMING_NUMERATOR);\\n  }\\n\\n  function getClaimingFeeDenominator(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_FEE_CLAIMING_DENOMINATOR);\\n  }\\n\\n  function getCreatingFeeInWei(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_FEE_CREATE);\\n  }\\n\\n  function getRecurringFeeInWei(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_FEE_RECURRING);\\n  }\\n\\n  function getStrongFeeInWei(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_FEE_STRONG);\\n  }\\n\\n  function getRecurringPaymentCycle(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_RECURRING_CYCLE_SECONDS);\\n  }\\n\\n  function getGracePeriod(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_GRACE_PERIOD_SECONDS);\\n  }\\n\\n  function getPayCyclesLimit(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_PAY_CYCLES_LIMIT);\\n  }\\n\\n  function getNodesLimit(uint _nodeType) public view returns (uint) {\\n    return getCustomSettingOrDefaultIfZero(_nodeType, NODE_TYPE_NODES_LIMIT);\\n  }\\n\\n  function getNftBonusValue(uint _nodeType, string memory _bonusName) public view returns (uint) {\\n    return nodeTypeNFTBonus[_nodeType][_bonusName] > 0\\n    ? nodeTypeNFTBonus[_nodeType][_bonusName]\\n    : nodeTypeNFTBonus[0][_bonusName];\\n  }\\n\\n  //\\n  // Setters\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function setNodeTypeActive(uint _nodeType, bool _active) external onlyRole(adminControl.SERVICE_ADMIN()) {\\n    // Node type 0 is being used as a placeholder for the default settings for node types that don't have custom ones,\\n    // So it shouldn't be activated and used to create nodes\\n    require(_nodeType > 0, \\\"invalid type\\\");\\n    nodeTypeActive[_nodeType] = _active;\\n    emit SetNodeTypeActive(_nodeType, _active);\\n  }\\n\\n  function setNodeTypeHasSettings(uint _nodeType, bool _hasSettings) external onlyRole(adminControl.SERVICE_ADMIN()) {\\n    nodeTypeHasSettings[_nodeType] = _hasSettings;\\n    emit SetNodeTypeHasSettings(_nodeType, _hasSettings);\\n  }\\n\\n  function setNodeTypeSetting(uint _nodeType, uint _settingId, uint _value) external onlyRole(adminControl.SERVICE_ADMIN()) {\\n    nodeTypeHasSettings[_nodeType] = true;\\n    nodeTypeSettings[_nodeType][_settingId] = _value;\\n    emit SetNodeTypeSetting(_nodeType, _settingId, _value);\\n  }\\n\\n  function setNodeTypeNFTBonus(uint _nodeType, string memory _bonusName, uint _value) external onlyRole(adminControl.SERVICE_ADMIN()) {\\n    nodeTypeNFTBonus[_nodeType][_bonusName] = _value;\\n    emit SetNodeTypeNFTBonus(_nodeType, _bonusName, _value);\\n  }\\n\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function getCustomSettingOrDefaultIfZero(uint _nodeType, uint _setting) internal view returns (uint) {\\n    return nodeTypeHasSettings[_nodeType] && nodeTypeSettings[_nodeType][_setting] > 0\\n    ? nodeTypeSettings[_nodeType][_setting]\\n    : nodeTypeSettings[0][_setting];\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SbMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nlibrary SbMath {\\n\\n  uint internal constant DECIMAL_PRECISION = 1e18;\\n\\n  /*\\n  * Multiply two decimal numbers and use normal rounding rules:\\n  * -round product up if 19'th mantissa digit >= 5\\n  * -round product down if 19'th mantissa digit < 5\\n  *\\n  * Used only inside the exponentiation, _decPow().\\n  */\\n  function decMul(uint x, uint y) internal pure returns (uint decProd) {\\n    uint prod_xy = x * y;\\n\\n    decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\\n  }\\n\\n  /*\\n  * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n  *\\n  * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\n  *\\n  * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n  * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n  */\\n  function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\\n\\n    if (_minutes > 525_600_000) _minutes = 525_600_000;  // cap to avoid overflow\\n\\n    if (_minutes == 0) return DECIMAL_PRECISION;\\n\\n    uint y = DECIMAL_PRECISION;\\n    uint x = _base;\\n    uint n = _minutes;\\n\\n    // Exponentiation-by-squaring\\n    while (n > 1) {\\n      if (n % 2 == 0) {\\n        x = decMul(x, x);\\n        n = n / 2;\\n      } else { // if (n % 2 != 0)\\n        y = decMul(x, y);\\n        x = decMul(x, x);\\n        n = (n - 1) / 2;\\n      }\\n    }\\n\\n    return decMul(x, y);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AdminAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../interfaces/IAdminControl.sol\\\";\\n\\nabstract contract AdminAccess {\\n\\n  IAdminControl public adminControl;\\n\\n  modifier onlyRole(uint8 _role) {\\n    require(address(adminControl) == address(0) || adminControl.hasRole(_role, msg.sender), \\\"no access\\\");\\n    _;\\n  }\\n\\n  function addAdminControlContract(IAdminControl _contract) external onlyRole(0) {\\n    adminControl = _contract;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAdminControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\ninterface IAdminControl {\\n  function hasRole(uint8 _role, address _account) external view returns (bool);\\n\\n  function SUPER_ADMIN() external view returns (uint8);\\n\\n  function ADMIN() external view returns (uint8);\\n\\n  function SERVICE_ADMIN() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"usedCredit\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastPaidAt\",\"type\":\"uint256\"}],\"name\":\"MigratedFromService\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Paid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"collector\",\"type\":\"address\"}],\"name\":\"SetFeeCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strongNFTBonus\",\"type\":\"address\"}],\"name\":\"SetNFTBonusContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"SetNodeTypeActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"hasSettings\",\"type\":\"bool\"}],\"name\":\"SetNodeTypeHasSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"bonusName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetNodeTypeNFTBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settingId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetNodeTypeSetting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetNodesLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SetServiceContractEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bips\",\"type\":\"uint256\"}],\"name\":\"SetTakeStrongBips\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NODE_TYPE_FEE_CLAIMING_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_FEE_CLAIMING_NUMERATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_FEE_CREATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_FEE_RECURRING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_FEE_STRONG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_GRACE_PERIOD_SECONDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_NODES_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_PAY_CYCLES_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_RECURRING_CYCLE_SECONDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_REWARD_BASE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_TYPE_REWARD_DECAY_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAdminControl\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"addAdminControlContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminControl\",\"outputs\":[{\"internalType\":\"contract IAdminControl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStrongPool\",\"name\":\"_strongPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approveStrongPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decayFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minutesPassed\",\"type\":\"uint256\"}],\"name\":\"calcDecayedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"canNodeBePaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toStrongPool\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toStrongPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fromNode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toNode\",\"type\":\"uint256\"}],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useCredit\",\"type\":\"bool\"}],\"name\":\"createNode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"doesNodeExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"entityCreditUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"entityNodeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"entityNodeCreatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"entityNodeLastClaimedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"entityNodeLastPaidAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"entityNodeType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entityNodeTypeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getClaimingFeeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getClaimingFeeNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getCreatingFeeInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getEntityCreditAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getEntityRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getGracePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getNftBonusAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_bonusName\",\"type\":\"string\"}],\"name\":\"getNftBonusValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getNodeClaimingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"getNodeId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"getNodePaidOn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"getNodeRecurringFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"getNodeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"getNodeType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromNode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toNode\",\"type\":\"uint256\"}],\"name\":\"getNodesClaimingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getNodesLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fromNode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toNode\",\"type\":\"uint256\"}],\"name\":\"getNodesRecurringFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getPayCyclesLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getRecurringFeeInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getRecurringPaymentCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getRewardAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getRewardBaseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getRewardDecayFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"}],\"name\":\"getStrongFeeInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"hasMaxPayments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"hasNodeExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_strongToken\",\"type\":\"address\"},{\"internalType\":\"contract IStrongNFTBonus\",\"name\":\"_strongNFTBonus\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"isNodePastDue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastPaidAt\",\"type\":\"uint256\"}],\"name\":\"migrateNode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeTypeActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeTypeHasSettings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nodeTypeNFTBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeTypeSettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodesLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeId\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromNode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toNode\",\"type\":\"uint256\"}],\"name\":\"payAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setNFTBonusContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setNodeTypeActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_hasSettings\",\"type\":\"bool\"}],\"name\":\"setNodeTypeHasSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_bonusName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setNodeTypeNFTBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_settingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setNodeTypeSetting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setNodesLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setServiceContractEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bips\",\"type\":\"uint256\"}],\"name\":\"setTakeStrongBips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strongNFTBonus\",\"outputs\":[{\"internalType\":\"contract IStrongNFTBonus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strongToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeStrongBips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNodes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MultiNodeV1","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}