{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n\"},\"CyberGorillas.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.10;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\nerror SoldOut();\\nerror SaleClosed();\\nerror InvalidMintParameters();\\nerror MintingTooMany();\\nerror NotWhitelisted();\\nerror NotAuthorized();\\n\\n/*\\n   ______      __              ______           _ ____          \\n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\\n / /   / / / / __ \\\\/ _ \\\\/ ___/ / __/ __ \\\\/ ___/ / / / __ `/ ___/\\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \\n\\\\____/\\\\__, /_.___/\\\\___/_/   \\\\____/\\\\____/_/  /_/_/_/\\\\__,_/____/  \\n     /____/                                                     \\n\\n*/\\n\\n/// @author distractedm1nd\\ncontract CyberGorillas is ERC721, Ownable {\\n    using Strings for uint256;\\n    address private passwordSigner;\\n    address private gorillaBurner;\\n\\n    bool public publicSale;\\n\\n    uint256 constant PRESALE_MAX_TX = 2;\\n    uint256 constant PUBLIC_MAX_TX = 5;\\n    uint256 constant public MAX_SUPPLY = 3333;\\n    uint256 constant PRICE = 0.08 ether;\\n\\n    string public baseURI;\\n\\n    mapping (address =\\u003e uint256) private presaleWalletLimits;\\n    mapping (address =\\u003e uint256) private mainsaleWalletLimits;\\n\\n    constructor(string memory initialBaseURI, address initialPasswordSigner) ERC721(\\\"Cyber Gorillas\\\", \\\"CyberGorillas\\\"){\\n        baseURI = initialBaseURI;\\n        passwordSigner = initialPasswordSigner;\\n    }\\n\\n    function airdrop(address[] calldata airdropAddresses) public onlyOwner {\\n        for(uint256 i = 0; i \\u003c airdropAddresses.length; i++) {\\n            _mint(airdropAddresses[i], totalSupply);\\n        }\\n    }\\n\\n    function setGorilliaBurner(address newGorillaBurner) public onlyOwner {\\n        gorillaBurner = newGorillaBurner;\\n    }\\n\\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\\n        baseURI = newBaseURI;\\n    }\\n\\n    function setSaleStatus(bool mainsaleOpen) public onlyOwner {\\n        publicSale = mainsaleOpen;\\n    }\\n\\n    function purchase(uint256 amount) public payable {\\n        if(!publicSale) revert SaleClosed();\\n        if(totalSupply + amount \\u003e MAX_SUPPLY) revert SoldOut();\\n        if(mainsaleWalletLimits[msg.sender] + amount \\u003e PUBLIC_MAX_TX || msg.value \\u003c PRICE * amount) revert InvalidMintParameters(); \\n\\n        mainsaleWalletLimits[msg.sender] += amount;\\n        for(uint256 i = 0; i \\u003c amount; i++) {\\n            _mint(msg.sender, totalSupply);\\n        }\\n    }\\n\\n    function presale(uint256 amount, bytes memory signature) public payable {\\n        if(publicSale) revert SaleClosed();\\n        if(totalSupply + amount \\u003e MAX_SUPPLY) revert SoldOut();\\n        if(!isWhitelisted(msg.sender, signature)) revert NotWhitelisted();\\n        if(balanceOf[msg.sender] + amount \\u003e PRESALE_MAX_TX || msg.value \\u003c PRICE * amount) revert InvalidMintParameters(); \\n\\n        for(uint256 i = 0; i \\u003c amount; i++) {\\n            _mint(msg.sender, totalSupply);\\n        }\\n    }\\n\\n    function withdraw(address payable recipient) external onlyOwner {\\n        recipient.transfer(address(this).balance);\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        return bytes(baseURI).length \\u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), \\\".json\\\")) : \\\"\\\";\\n    }\\n\\n    function isWhitelisted(address user, bytes memory signature) public view returns (bool) {\\n        bytes32 messageHash = keccak256(abi.encode(user));\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n\\n        return recoverSigner(ethSignedMessageHash, signature) == passwordSigner;\\n    }\\n\\n    function getEthSignedMessageHash(bytes32 _messageHash) private pure returns (bytes32) {\\n        /*\\n        Signature is produced by signing a keccak256 hash with the following format:\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\n        */\\n        return\\n        keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _messageHash)\\n        );\\n    }\\n\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) private pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function recoverSignerTest(bytes32 _ethSignedMessageHash, bytes memory _signature) private pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory sig) private pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        require(sig.length == 65, \\\"sig invalid\\\");\\n\\n        assembly {\\n        /*\\n        First 32 bytes stores the length of the signature\\n\\n        add(sig, 32) = pointer of sig + 32\\n        effectively, skips first 32 bytes of signature\\n\\n        mload(p) loads next 32 bytes starting at the memory address p into memory\\n        */\\n\\n        // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n        // second 32 bytes\\n            s := mload(add(sig, 64))\\n        // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // implicitly return (r, s, v)\\n    }\\n\\n    function burn(uint tokenId) public {\\n        if(msg.sender != gorillaBurner) revert NotAuthorized();\\n        _burn(tokenId);\\n    }\\n}\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\\n/// including the MetaData, and partially, Enumerable extensions.\\n/// @author from an unmerged solmate PR from z0r0z \\u0026 distractedm1nd\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    string public name;\\n\\n    string public symbol;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC-721 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    uint256 public totalSupply;\\n    \\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(uint256 =\\u003e address) public ownerOf;\\n\\n    mapping(uint256 =\\u003e address) public getApproved;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            EIP-2612-LIKE STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\\\");\\n\\n    bytes32 public constant PERMIT_ALL_TYPEHASH = \\n        keccak256(\\\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\\\");\\n    \\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(uint256 =\\u003e uint256) public nonces;\\n\\n    mapping(address =\\u003e uint256) public noncesForAll;\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n        \\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC-20-LIKE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transfer(address to, uint256 tokenId) public virtual returns (bool success) {\\n        require(msg.sender == ownerOf[tokenId], \\\"NOT_OWNER\\\");\\n        \\n        // Cannot overflow because because ownership is checked\\n        // against decrement, and sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[msg.sender]--; \\n        \\n            balanceOf[to]++;\\n        }\\n        \\n        delete getApproved[tokenId];\\n        \\n        ownerOf[tokenId] = to;\\n        \\n        emit Transfer(msg.sender, to, tokenId); \\n        \\n        success = true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC-721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool supported) {\\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f || interfaceId == 0x01ffc9a7;\\n    }\\n    \\n    function approve(address spender, uint256 tokenId) public virtual {\\n        address owner = ownerOf[tokenId];\\n        \\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_APPROVED\\\");\\n        \\n        getApproved[tokenId] = spender;\\n        \\n        emit Approval(owner, spender, tokenId); \\n    }\\n    \\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n        \\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n    \\n    function transferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId\\n    ) public virtual {\\n        require(from == ownerOf[tokenId], \\u0027NOT_OWNER\\u0027);\\n        \\n        require(\\n            msg.sender == from \\n            || msg.sender == getApproved[tokenId]\\n            || isApprovedForAll[from][msg.sender], \\n            \\u0027NOT_APPROVED\\u0027\\n        );\\n        \\n        // this is safe because ownership is checked\\n        // against decrement, and sum of all user\\n        // balances can\\u0027t exceed \\u0027type(uint256).max\\u0027\\n        unchecked { \\n            balanceOf[from]--; \\n        \\n            balanceOf[to]++;\\n        }\\n        \\n        delete getApproved[tokenId];\\n        \\n        ownerOf[tokenId] = to;\\n        \\n        emit Transfer(from, to, tokenId); \\n    }\\n    \\n    function safeTransferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId\\n    ) public virtual {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n    \\n    function safeTransferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId, \\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, tokenId); \\n        \\n        if (to.code.length \\u003e 0) {\\n            // selector = \\\"onERC721Received(address,address,uint256,bytes)\\\".\\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\\n                msg.sender, from, tokenId, data));\\n                \\n            bytes4 selector = abi.decode(returned, (bytes4));\\n            \\n            require(selector == 0x150b7a02, \\u0027NOT_ERC721_RECEIVER\\u0027);\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            EIP-2612-LIKE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    function permit(\\n        address spender,\\n        uint256 tokenId,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(block.timestamp \\u003c= deadline, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n        \\n        address owner = ownerOf[tokenId];\\n        \\n        // Unchecked because the only math done is incrementing\\n        // the owner\\u0027s nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0), \\\"INVALID_PERMIT_SIGNATURE\\\");\\n\\n            require(recoveredAddress == owner || isApprovedForAll[owner][recoveredAddress], \\\"INVALID_SIGNER\\\");\\n        }\\n        \\n        getApproved[tokenId] = spender;\\n\\n        emit Approval(owner, spender, tokenId);\\n    }\\n    \\n    function permitAll(\\n        address owner,\\n        address operator,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(block.timestamp \\u003c= deadline, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n        \\n        // Unchecked because the only math done is incrementing\\n        // the owner\\u0027s nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n            \\n            require(\\n                (recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress],\\n                \\u0027INVALID_PERMIT_SIGNATURE\\u0027\\n            );\\n        }\\n        \\n        isApprovedForAll[owner][operator] = true;\\n\\n        emit ApprovalForAll(owner, operator, true);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 domainSeparator) {\\n        domainSeparator = block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32 domainSeparator) {\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    function _mint(\\n        address to, \\n        uint256 tokenId\\n    ) internal virtual { \\n        require(ownerOf[tokenId] == address(0), \\\"ALREADY_MINTED\\\");\\n  \\n        // Cannot realistically overflow from incrementing total supply beyond\\n        // the max uint256 value, and because the sum of all user balances \\n        // can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            totalSupply++;\\n            \\n            balanceOf[to]++;\\n        }\\n        \\n        ownerOf[tokenId] = to;\\n        \\n        emit Transfer(address(0), to, tokenId); \\n    }\\n    \\n    function _burn(uint256 tokenId) internal virtual { \\n        address owner = ownerOf[tokenId];\\n        \\n        require(ownerOf[tokenId] != address(0), \\\"NOT_MINTED\\\");\\n        \\n        // Cannot underflow because a user\\u0027s balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply--;\\n        \\n            balanceOf[owner]--;\\n        }\\n        \\n        delete ownerOf[tokenId];\\n        \\n        emit Transfer(owner, address(0), tokenId); \\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"initialBaseURI\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"initialPasswordSigner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidMintParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SoldOut\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_ALL_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"airdropAddresses\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noncesForAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permitAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"presale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGorillaBurner\",\"type\":\"address\"}],\"name\":\"setGorilliaBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"mainsaleOpen\",\"type\":\"bool\"}],\"name\":\"setSaleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CyberGorillas","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"9999","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000007d262e9df38c0d98f7f9d2968f580f484fccf76a0000000000000000000000000000000000000000000000000000000000000036697066733a2f2f516d574a45334a5364575a5578793641683334576a54354b474d354d504474514e783470566b73415442616f43352f00000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://87a7c667db0bd475db65d0fb2223bd71be0d2d8d51f471526eac98ef0706be4a"}]}