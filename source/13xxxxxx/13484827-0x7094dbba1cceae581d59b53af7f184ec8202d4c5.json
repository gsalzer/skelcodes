{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n// Copyright 2021 David Huber (@cxkoda)\r\n// All Rights Reserved\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @notice Interpolation between ColorAnchors to generate a colormap.\r\n * @dev A color anchor is encoded composed of four uint8 numbers in the order\r\n * `colorAnchor = | red | green | blue | position |`. Every `uint32` typed \r\n * variable in the following code will correspond to such anchors, while \r\n * `uint24`s correspond to rgb colors.\r\n * @author David Huber (@cxkoda)\r\n */\r\nlibrary ColorMixer {\r\n    /**\r\n     * @dev The internal fixed-point accuracy\r\n     */\r\n    uint8 private constant PRECISION = 32;\r\n    uint256 private constant ONE = 2**32;\r\n\r\n    /**\r\n     * @notice Interpolate linearily between two colors.\r\n     * @param fraction Fixed-point number in [0,1] giving the relative\r\n     * contribution of `left` (0) and `right` (1).\r\n     * The interpolation follows the equation \r\n     * `color = fraction * right + (1 - fraction) * left`.\r\n     */\r\n    function interpolate(\r\n        uint24 left,\r\n        uint24 right,\r\n        uint256 fraction\r\n    ) internal pure returns (uint24 color) {\r\n        assembly {\r\n            color := shr(\r\n                PRECISION,\r\n                add(\r\n                    mul(fraction, and(shr(16, right), 0xff)),\r\n                    mul(sub(ONE, fraction), and(shr(16, left), 0xff))\r\n                )\r\n            )\r\n            color := add(\r\n                shl(8, color),\r\n                shr(\r\n                    PRECISION,\r\n                    add(\r\n                        mul(fraction, and(shr(8, right), 0xff)),\r\n                        mul(sub(ONE, fraction), and(shr(8, left), 0xff))\r\n                    )\r\n                )\r\n            )\r\n            color := add(\r\n                shl(8, color),\r\n                shr(\r\n                    PRECISION,\r\n                    add(\r\n                        mul(fraction, and(right, 0xff)),\r\n                        mul(sub(ONE, fraction), and(left, 0xff))\r\n                    )\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Generate a colormap from a list of anchors.\r\n     * @dev Anchors have to be sorted by position.\r\n     */\r\n    function getColormap(uint32[] calldata anchors)\r\n        external\r\n        pure\r\n        returns (bytes memory colormap)\r\n    {\r\n        require(anchors.length > 0);\r\n        colormap = new bytes(768);\r\n        uint256 offset = 0;\r\n        // Left extrapolation (below the leftmost anchor)\r\n        {\r\n            uint32 anchor = anchors[0];\r\n            uint8 anchorPos = uint8(anchor & 0xff);\r\n            for (uint32 position = 0; position < anchorPos; position++) {\r\n                colormap[offset++] = bytes1(uint8((anchor >> 24) & 0xff));\r\n                colormap[offset++] = bytes1(uint8((anchor >> 16) & 0xff));\r\n                colormap[offset++] = bytes1(uint8((anchor >> 8) & 0xff));\r\n            }\r\n        }\r\n        // Interpolation\r\n        if (anchors.length > 1) {\r\n            for (uint256 idx = 0; idx < anchors.length - 1; idx++) {\r\n                uint32 left = anchors[idx];\r\n                uint32 right = anchors[idx + 1];\r\n                uint8 leftPosition = uint8(left & 0xff);\r\n                uint8 rightPosition = uint8(right & 0xff);\r\n\r\n                if (leftPosition == rightPosition) {\r\n                    continue;\r\n                }\r\n                \r\n                uint256 rangeInv = ONE / (rightPosition - leftPosition);\r\n                for (\r\n                    uint256 position = leftPosition;\r\n                    position < rightPosition;\r\n                    position++\r\n                ) {\r\n                    uint256 fraction = (position - leftPosition) * rangeInv;\r\n                    uint32 interpolated = interpolate(\r\n                        uint24(left >> 8),\r\n                        uint24(right >> 8),\r\n                        fraction\r\n                    );\r\n                    colormap[offset++] = bytes1(\r\n                        uint8((interpolated >> 16) & 0xff)\r\n                    );\r\n                    colormap[offset++] = bytes1(\r\n                        uint8((interpolated >> 8) & 0xff)\r\n                    );\r\n                    colormap[offset++] = bytes1(uint8(interpolated & 0xff));\r\n                }\r\n            }\r\n        }\r\n        // Right extrapolation (above the rightmost anchor)\r\n        {\r\n            uint32 anchor = anchors[anchors.length - 1];\r\n            uint8 anchorPos = uint8(anchor & 0xff);\r\n            for (uint256 position = anchorPos; position < 256; position++) {\r\n                colormap[offset++] = bytes1(uint8((anchor >> 24) & 0xff));\r\n                colormap[offset++] = bytes1(uint8((anchor >> 16) & 0xff));\r\n                colormap[offset++] = bytes1(uint8((anchor >> 8) & 0xff));\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"anchors\",\"type\":\"uint32[]\"}],\"name\":\"getColormap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"colormap\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ColorMixer","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cd9c2fd42012d5a167e420f6cc9e7758e2952adec0940fc6fb0da2336789a8b3"}]}