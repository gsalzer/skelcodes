{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/contract/RocketBase.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../interface/RocketStorageInterface.sol\\\";\\n\\n/// @title Base settings / modifiers for each contract in Rocket Pool\\n/// @author David Rugendyke\\n\\nabstract contract RocketBase {\\n\\n    // Calculate using this as the base\\n    uint256 constant calcBase = 1 ether;\\n\\n    // Version of the contract\\n    uint8 public version;\\n\\n    // The main storage contract where primary persistant storage is maintained\\n    RocketStorageInterface rocketStorage = RocketStorageInterface(0);\\n\\n\\n    /*** Modifiers **********************************************************/\\n\\n    /**\\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\\n    */\\n    modifier onlyLatestNetworkContract() {\\n        require(getBool(keccak256(abi.encodePacked(\\\"contract.exists\\\", msg.sender))), \\\"Invalid or outdated network contract\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\\n    */\\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName))), \\\"Invalid or outdated contract\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a registered node\\n    */\\n    modifier onlyRegisteredNode(address _nodeAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"node.exists\\\", _nodeAddress))), \\\"Invalid node\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\\n    */\\n    modifier onlyTrustedNode(address _nodeAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"dao.trustednodes.\\\", \\\"member\\\", _nodeAddress))), \\\"Invalid trusted node\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a registered minipool\\n    */\\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"minipool.exists\\\", _minipoolAddress))), \\\"Invalid minipool\\\");\\n        _;\\n    }\\n    \\n\\n    /**\\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\\n    */\\n    modifier onlyGuardian() {\\n        require(msg.sender == rocketStorage.getGuardian(), \\\"Account is not a temporary guardian\\\");\\n        _;\\n    }\\n\\n\\n\\n\\n    /*** Methods **********************************************************/\\n\\n    /// @dev Set the main Rocket Storage address\\n    constructor(RocketStorageInterface _rocketStorageAddress) {\\n        // Update the contract address\\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\\n    }\\n\\n\\n    /// @dev Get the address of a network contract by name\\n    function getContractAddress(string memory _contractName) internal view returns (address) {\\n        // Get the current contract address\\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        // Check it\\n        require(contractAddress != address(0x0), \\\"Contract not found\\\");\\n        // Return\\n        return contractAddress;\\n    }\\n\\n\\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\\n        // Get the current contract address\\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        // Return\\n        return contractAddress;\\n    }\\n\\n\\n    /// @dev Get the name of a network contract by address\\n    function getContractName(address _contractAddress) internal view returns (string memory) {\\n        // Get the contract name\\n        string memory contractName = getString(keccak256(abi.encodePacked(\\\"contract.name\\\", _contractAddress)));\\n        // Check it\\n        require(bytes(contractName).length > 0, \\\"Contract not found\\\");\\n        // Return\\n        return contractName;\\n    }\\n\\n    /// @dev Get revert error message from a .call method\\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return \\\"Transaction reverted silently\\\";\\n        assembly {\\n            // Slice the sighash.\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\n    }\\n\\n\\n\\n    /*** Rocket Storage Methods ****************************************/\\n\\n    // Note: Unused helpers have been removed to keep contract sizes down\\n\\n    /// @dev Storage get methods\\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\\n\\n    /// @dev Storage set methods\\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\\n\\n    /// @dev Storage delete methods\\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\\n\\n    /// @dev Storage arithmetic methods\\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\\n}\\n\"\r\n    },\r\n    \"/contracts/contract/minipool/RocketMinipool.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"./RocketMinipoolStorageLayout.sol\\\";\\nimport \\\"../../interface/RocketStorageInterface.sol\\\";\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\n\\n// An individual minipool in the Rocket Pool network\\n\\ncontract RocketMinipool is RocketMinipoolStorageLayout {\\n\\n    // Events\\n    event EtherReceived(address indexed from, uint256 amount, uint256 time);\\n    event DelegateUpgraded(address oldDelegate, address newDelegate, uint256 time);\\n    event DelegateRolledBack(address oldDelegate, address newDelegate, uint256 time);\\n\\n    // Modifiers\\n\\n    // Only allow access from the owning node address\\n    modifier onlyMinipoolOwner() {\\n        // Only the node operator can upgrade\\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\\n        require(msg.sender == nodeAddress || msg.sender == withdrawalAddress, \\\"Only the node operator can access this method\\\");\\n        _;\\n    }\\n\\n    // Construct\\n    constructor(RocketStorageInterface _rocketStorageAddress, address _nodeAddress, MinipoolDeposit _depositType) {\\n        // Initialise RocketStorage\\n        require(address(_rocketStorageAddress) != address(0x0), \\\"Invalid storage address\\\");\\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\\n        // Set storage state to uninitialised\\n        storageState = StorageState.Uninitialised;\\n        // Set the current delegate\\n        address delegateAddress = getContractAddress(\\\"rocketMinipoolDelegate\\\");\\n        rocketMinipoolDelegate = delegateAddress;\\n        // Check for contract existence\\n        require(contractExists(delegateAddress), \\\"Delegate contract does not exist\\\");\\n        // Call initialise on delegate\\n        (bool success, bytes memory data) = delegateAddress.delegatecall(abi.encodeWithSignature('initialise(address,uint8)', _nodeAddress, uint8(_depositType)));\\n        if (!success) { revert(getRevertMessage(data)); }\\n    }\\n\\n    // Receive an ETH deposit\\n    receive() external payable {\\n        // Emit ether received event\\n        emit EtherReceived(msg.sender, msg.value, block.timestamp);\\n    }\\n\\n    // Upgrade this minipool to the latest network delegate contract\\n    function delegateUpgrade() external onlyMinipoolOwner {\\n        // Set previous address\\n        rocketMinipoolDelegatePrev = rocketMinipoolDelegate;\\n        // Set new delegate\\n        rocketMinipoolDelegate = getContractAddress(\\\"rocketMinipoolDelegate\\\");\\n        // Verify\\n        require(rocketMinipoolDelegate != rocketMinipoolDelegatePrev, \\\"New delegate is the same as the existing one\\\");\\n        // Log event\\n        emit DelegateUpgraded(rocketMinipoolDelegatePrev, rocketMinipoolDelegate, block.timestamp);\\n    }\\n\\n    // Rollback to previous delegate contract\\n    function delegateRollback() external onlyMinipoolOwner {\\n        // Make sure they have upgraded before\\n        require(rocketMinipoolDelegatePrev != address(0x0), \\\"Previous delegate contract is not set\\\");\\n        // Store original\\n        address originalDelegate = rocketMinipoolDelegate;\\n        // Update delegate to previous and zero out previous\\n        rocketMinipoolDelegate = rocketMinipoolDelegatePrev;\\n        rocketMinipoolDelegatePrev = address(0x0);\\n        // Log event\\n        emit DelegateRolledBack(originalDelegate, rocketMinipoolDelegate, block.timestamp);\\n    }\\n\\n    // If set to true, will automatically use the latest delegate contract\\n    function setUseLatestDelegate(bool _setting) external onlyMinipoolOwner {\\n        useLatestDelegate = _setting;\\n    }\\n\\n    // Getter for useLatestDelegate setting\\n    function getUseLatestDelegate() external view returns (bool) {\\n        return useLatestDelegate;\\n    }\\n\\n    // Returns the address of the minipool's stored delegate\\n    function getDelegate() external view returns (address) {\\n        return rocketMinipoolDelegate;\\n    }\\n\\n    // Returns the address of the minipool's previous delegate (or address(0) if not set)\\n    function getPreviousDelegate() external view returns (address) {\\n        return rocketMinipoolDelegatePrev;\\n    }\\n\\n    // Returns the delegate which will be used when calling this minipool taking into account useLatestDelegate setting\\n    function getEffectiveDelegate() external view returns (address) {\\n        return useLatestDelegate ? getContractAddress(\\\"rocketMinipoolDelegate\\\") : rocketMinipoolDelegate;\\n    }\\n\\n    // Delegate all other calls to minipool delegate contract\\n    fallback(bytes calldata _input) external payable returns (bytes memory) {\\n        // If useLatestDelegate is set, use the latest delegate contract\\n        address delegateContract = useLatestDelegate ? getContractAddress(\\\"rocketMinipoolDelegate\\\") : rocketMinipoolDelegate;\\n        // Check for contract existence\\n        require(contractExists(delegateContract), \\\"Delegate contract does not exist\\\");\\n        // Execute delegatecall\\n        (bool success, bytes memory data) = delegateContract.delegatecall(_input);\\n        if (!success) { revert(getRevertMessage(data)); }\\n        return data;\\n    }\\n\\n    // Get the address of a Rocket Pool network contract\\n    function getContractAddress(string memory _contractName) private view returns (address) {\\n        address contractAddress = rocketStorage.getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        require(contractAddress != address(0x0), \\\"Contract not found\\\");\\n        return contractAddress;\\n    }\\n\\n    // Get a revert message from delegatecall return data\\n    function getRevertMessage(bytes memory _returnData) private pure returns (string memory) {\\n        if (_returnData.length < 68) { return \\\"Transaction reverted silently\\\"; }\\n        assembly {\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        return abi.decode(_returnData, (string));\\n    }\\n\\n    // Returns true if contract exists at _contractAddress (if called during that contract's construction it will return a false negative)\\n    function contractExists(address _contractAddress) private returns (bool) {\\n        uint32 codeSize;\\n        assembly {\\n            codeSize := extcodesize(_contractAddress)\\n        }\\n        return codeSize > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/contract/minipool/RocketMinipoolManager.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./RocketMinipool.sol\\\";\\nimport \\\"../RocketBase.sol\\\";\\nimport \\\"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolManagerInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolQueueInterface.sol\\\";\\nimport \\\"../../interface/node/RocketNodeStakingInterface.sol\\\";\\nimport \\\"../../interface/util/AddressSetStorageInterface.sol\\\";\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../interface/network/RocketNetworkPricesInterface.sol\\\";\\nimport \\\"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\\\";\\nimport \\\"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\\\";\\nimport \\\"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\\\";\\n\\n// Minipool creation, removal and management\\n\\ncontract RocketMinipoolManager is RocketBase, RocketMinipoolManagerInterface {\\n\\n    // Libs\\n    using SafeMath for uint;\\n\\n    // Events\\n    event MinipoolCreated(address indexed minipool, address indexed node, uint256 time);\\n    event MinipoolDestroyed(address indexed minipool, address indexed node, uint256 time);\\n\\n    // Construct\\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\\n        version = 1;\\n    }\\n\\n    // Get the number of minipools in the network\\n    function getMinipoolCount() override public view returns (uint256) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        return addressSetStorage.getCount(keccak256(bytes(\\\"minipools.index\\\")));\\n    }\\n\\n    // Get the number of minipools in the network in the Staking state\\n    function getStakingMinipoolCount() override external view returns (uint256) {\\n        return getUint(keccak256(bytes(\\\"minipools.staking.count\\\")));\\n    }\\n\\n    // Get the number of finalised minipools in the network\\n    function getFinalisedMinipoolCount() override external view returns (uint256) {\\n        return getUint(keccak256(bytes(\\\"minipools.finalised.count\\\")));\\n    }\\n\\n    // Get the number of active minipools in the network\\n    function getActiveMinipoolCount() override public view returns (uint256) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        uint256 total = addressSetStorage.getCount(keccak256(bytes(\\\"minipools.index\\\")));\\n        uint256 finalised = getUint(keccak256(bytes(\\\"minipools.finalised.count\\\")));\\n        return total.sub(finalised);\\n    }\\n\\n    // Get the number of minipools in each status.\\n    // Returns the counts for Initialised, Prelaunch, Staking, Withdrawable, and Dissolved in that order.\\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) override external view \\n    returns (uint256 initialisedCount, uint256 prelaunchCount, uint256 stakingCount, uint256 withdrawableCount, uint256 dissolvedCount) {\\n        // Get contracts\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        // Precompute minipool key\\n        bytes32 minipoolKey = keccak256(abi.encodePacked(\\\"minipools.index\\\"));\\n        // Iterate over the requested minipool range\\n        uint256 totalMinipools = getMinipoolCount();\\n        uint256 max = offset.add(limit);\\n        if (max > totalMinipools || limit == 0) { max = totalMinipools; }\\n        for (uint256 i = offset; i < max; i++) {\\n            // Get the minipool at index i\\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(addressSetStorage.getItem(minipoolKey, i));\\n            // Get the minipool's status, and update the appropriate counter\\n            MinipoolStatus status = minipool.getStatus();\\n            if (status == MinipoolStatus.Initialised) {\\n                initialisedCount++;\\n            }\\n            else if (status == MinipoolStatus.Prelaunch) {\\n                prelaunchCount++;\\n            }\\n            else if (status == MinipoolStatus.Staking) {\\n                stakingCount++;\\n            }\\n            else if (status == MinipoolStatus.Withdrawable) {\\n                withdrawableCount++;\\n            }\\n            else if (status == MinipoolStatus.Dissolved) {\\n                dissolvedCount++;\\n            }\\n        }\\n    }\\n\\n    // Get a network minipool address by index\\n    function getMinipoolAt(uint256 _index) override external view returns (address) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\\\"minipools.index\\\")), _index);\\n    }\\n\\n    // Get the number of minipools owned by a node\\n    function getNodeMinipoolCount(address _nodeAddress) override external view returns (uint256) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\\\"node.minipools.index\\\", _nodeAddress)));\\n    }\\n\\n    // Get the number of minipools owned by a node that are not finalised\\n    function getNodeActiveMinipoolCount(address _nodeAddress) override public view returns (uint256) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        uint256 finalised = getUint(keccak256(abi.encodePacked(\\\"node.minipools.finalised.count\\\", _nodeAddress)));\\n        uint256 total = addressSetStorage.getCount(keccak256(abi.encodePacked(\\\"node.minipools.index\\\", _nodeAddress)));\\n        return total.sub(finalised);\\n    }\\n\\n    // Get the number of minipools owned by a node that are finalised\\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) override external view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"node.minipools.finalised.count\\\", _nodeAddress)));\\n    }\\n\\n    // Get the number of minipools owned by a node that are in staking status\\n    function getNodeStakingMinipoolCount(address _nodeAddress) override external view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"node.minipools.staking.count\\\", _nodeAddress)));\\n    }\\n\\n    // Get a node minipool address by index\\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\\\"node.minipools.index\\\", _nodeAddress)), _index);\\n    }\\n\\n    // Get the number of validating minipools owned by a node\\n    function getNodeValidatingMinipoolCount(address _nodeAddress) override external view returns (uint256) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\\\"node.minipools.validating.index\\\", _nodeAddress)));\\n    }\\n\\n    // Get a validating node minipool address by index\\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\\\"node.minipools.validating.index\\\", _nodeAddress)), _index);\\n    }\\n\\n    // Get a minipool address by validator pubkey\\n    function getMinipoolByPubkey(bytes memory _pubkey) override external view returns (address) {\\n        return getAddress(keccak256(abi.encodePacked(\\\"validator.minipool\\\", _pubkey)));\\n    }\\n\\n    // Check whether a minipool exists\\n    function getMinipoolExists(address _minipoolAddress) override external view returns (bool) {\\n        return getBool(keccak256(abi.encodePacked(\\\"minipool.exists\\\", _minipoolAddress)));\\n    }\\n\\n    // Get a minipool's validator pubkey\\n    function getMinipoolPubkey(address _minipoolAddress) override external view returns (bytes memory) {\\n        return getBytes(keccak256(abi.encodePacked(\\\"minipool.pubkey\\\", _minipoolAddress)));\\n    }\\n\\n    // Increments _nodeAddress' number of minipools in staking status\\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\\\"rocketMinipoolManager\\\", address(this)) onlyRegisteredMinipool(msg.sender) {\\n        // Update the node specific count\\n        bytes32 nodeKey = keccak256(abi.encodePacked(\\\"node.minipools.staking.count\\\", _nodeAddress));\\n        uint256 nodeValue = getUint(nodeKey);\\n        setUint(nodeKey, nodeValue.add(1));\\n        // Update the total count\\n        bytes32 totalKey = keccak256(abi.encodePacked(\\\"minipools.staking.count\\\"));\\n        uint256 totalValue = getUint(totalKey);\\n        setUint(totalKey, totalValue.add(1));\\n        // Update total effective stake\\n        updateTotalEffectiveRPLStake(_nodeAddress, nodeValue, nodeValue.add(1));\\n    }\\n\\n    // Decrements _nodeAddress' number of minipools in staking status\\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\\\"rocketMinipoolManager\\\", address(this)) onlyRegisteredMinipool(msg.sender) {\\n        // Update the node specific count\\n        bytes32 nodeKey = keccak256(abi.encodePacked(\\\"node.minipools.staking.count\\\", _nodeAddress));\\n        uint256 nodeValue = getUint(nodeKey);\\n        setUint(nodeKey, nodeValue.sub(1));\\n        // Update the total count\\n        bytes32 totalKey = keccak256(abi.encodePacked(\\\"minipools.staking.count\\\"));\\n        uint256 totalValue = getUint(totalKey);\\n        setUint(totalKey, totalValue.sub(1));\\n        // Update total effective stake\\n        updateTotalEffectiveRPLStake(_nodeAddress, nodeValue, nodeValue.sub(1));\\n    }\\n\\n    // Increments _nodeAddress' number of minipools that have been finalised\\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) override external onlyLatestContract(\\\"rocketMinipoolManager\\\", address(this)) onlyRegisteredMinipool(msg.sender) {\\n        // Update the node specific count\\n        addUint(keccak256(abi.encodePacked(\\\"node.minipools.finalised.count\\\", _nodeAddress)), 1);\\n        // Update the total count\\n        addUint(keccak256(bytes(\\\"minipools.finalised.count\\\")), 1);\\n    }\\n\\n    // Create a minipool\\n    // Only accepts calls from the RocketNodeDeposit contract\\n    function createMinipool(address _nodeAddress, MinipoolDeposit _depositType) override external onlyLatestContract(\\\"rocketMinipoolManager\\\", address(this)) onlyLatestContract(\\\"rocketNodeDeposit\\\", msg.sender) returns (RocketMinipoolInterface) {\\n        // Load contracts\\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\\\"rocketNodeStaking\\\"));\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        // Check node minipool limit based on RPL stake\\n        require(\\n            getNodeActiveMinipoolCount(_nodeAddress) < rocketNodeStaking.getNodeMinipoolLimit(_nodeAddress),\\n            \\\"Minipool count after deposit exceeds limit based on node RPL stake\\\"\\n        );\\n        { // Local scope to prevent stack too deep error\\n          RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n          // Check global minipool limit\\n          uint256 totalMinipoolCount = getActiveMinipoolCount();\\n          require(totalMinipoolCount.add(1) <= rocketDAOProtocolSettingsMinipool.getMaximumCount(), \\\"Global minipool limit reached\\\");\\n        }\\n        // Create minipool contract\\n        address contractAddress = address(new RocketMinipool(RocketStorageInterface(rocketStorage), _nodeAddress, _depositType));\\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(contractAddress);\\n        // Initialize minipool data\\n        setBool(keccak256(abi.encodePacked(\\\"minipool.exists\\\", contractAddress)), true);\\n        // Add minipool to indexes\\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\\\"minipools.index\\\")), contractAddress);\\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\\\"node.minipools.index\\\", _nodeAddress)), contractAddress);\\n        // Update unbonded validator count if minipool is unbonded\\n        if (_depositType == MinipoolDeposit.Empty) {\\n            RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\\\"rocketDAONodeTrusted\\\"));\\n            rocketDAONodeTrusted.incrementMemberUnbondedValidatorCount(_nodeAddress);\\n        }\\n        // Emit minipool created event\\n        emit MinipoolCreated(contractAddress, _nodeAddress, block.timestamp);\\n        // Add minipool to queue\\n        RocketMinipoolQueueInterface(getContractAddress(\\\"rocketMinipoolQueue\\\")).enqueueMinipool(_depositType, contractAddress);\\n        // Return created minipool address\\n        return minipool;\\n    }\\n\\n    // Destroy a minipool\\n    // Only accepts calls from registered minipools\\n    function destroyMinipool() override external onlyLatestContract(\\\"rocketMinipoolManager\\\", address(this)) onlyRegisteredMinipool(msg.sender) {\\n        // Load contracts\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        // Initialize minipool & get properties\\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\\n        address nodeAddress = minipool.getNodeAddress();\\n        // Update minipool data\\n        setBool(keccak256(abi.encodePacked(\\\"minipool.exists\\\", msg.sender)), false);\\n        // Remove minipool from indexes\\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\\\"minipools.index\\\")), msg.sender);\\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\\\"node.minipools.index\\\", nodeAddress)), msg.sender);\\n        // Emit minipool destroyed event\\n        emit MinipoolDestroyed(msg.sender, nodeAddress, block.timestamp);\\n    }\\n\\n    // Updates the stored total effective rate based on a node's changing minipool count\\n    function updateTotalEffectiveRPLStake(address _nodeAddress, uint256 _oldCount, uint256 _newCount) private {\\n        // Load contracts\\n        RocketNetworkPricesInterface rocketNetworkPrices = RocketNetworkPricesInterface(getContractAddress(\\\"rocketNetworkPrices\\\"));\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\\\"rocketDAOProtocolSettingsNode\\\"));\\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\\\"rocketNodeStaking\\\"));\\n        // Require price consensus\\n        require(rocketNetworkPrices.inConsensus(), \\\"Network is not in consensus\\\");\\n        // Get node's RPL stake\\n        uint256 rplStake = rocketNodeStaking.getNodeRPLStake(_nodeAddress);\\n        // Get the node's maximum possible stake\\n        uint256 maxRplStakePerMinipool = rocketDAOProtocolSettingsMinipool.getHalfDepositUserAmount()\\n            .mul(rocketDAOProtocolSettingsNode.getMaximumPerMinipoolStake());\\n        uint256 oldMaxRplStake = maxRplStakePerMinipool\\n            .mul(_oldCount)\\n            .div(rocketNetworkPrices.getRPLPrice());\\n        uint256 newMaxRplStake = maxRplStakePerMinipool\\n            .mul(_newCount)\\n            .div(rocketNetworkPrices.getRPLPrice());\\n        // Check if we have to decrease total\\n        if (_oldCount > _newCount) {\\n            if (rplStake <= newMaxRplStake) {\\n                return;\\n            }\\n            uint256 decrease = oldMaxRplStake.sub(newMaxRplStake);\\n            uint256 delta = rplStake.sub(newMaxRplStake);\\n            if (delta > decrease) { delta = decrease; }\\n            rocketNetworkPrices.decreaseEffectiveRPLStake(delta);\\n            return;\\n        }\\n        // Check if we have to increase total\\n        if (_newCount > _oldCount) {\\n            if (rplStake <= oldMaxRplStake) {\\n                return;\\n            }\\n            uint256 increase = newMaxRplStake.sub(oldMaxRplStake);\\n            uint256 delta = rplStake.sub(oldMaxRplStake);\\n            if (delta > increase) { delta = increase; }\\n            rocketNetworkPrices.increaseEffectiveRPLStake(delta);\\n            return;\\n        }\\n        // _oldCount == _newCount (do nothing but shouldn't happen)\\n    }\\n\\n    // Set a minipool's validator pubkey\\n    // Only accepts calls from registered minipools\\n    function setMinipoolPubkey(bytes calldata _pubkey) override external onlyLatestContract(\\\"rocketMinipoolManager\\\", address(this)) onlyRegisteredMinipool(msg.sender) {\\n        // Load contracts\\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\\\"addressSetStorage\\\"));\\n        // Initialize minipool & get properties\\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\\n        address nodeAddress = minipool.getNodeAddress();\\n        // Set minipool validator pubkey & validator minipool address\\n        setBytes(keccak256(abi.encodePacked(\\\"minipool.pubkey\\\", msg.sender)), _pubkey);\\n        setAddress(keccak256(abi.encodePacked(\\\"validator.minipool\\\", _pubkey)), msg.sender);\\n        // Add minipool to node validating minipools index\\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\\\"node.minipools.validating.index\\\", nodeAddress)), msg.sender);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/contract/minipool/RocketMinipoolStorageLayout.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../interface/RocketStorageInterface.sol\\\";\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\n\\n// The RocketMinipool contract storage layout, shared by RocketMinipoolDelegate\\n\\n// ******************************************************\\n// Note: This contract MUST NOT BE UPDATED after launch.\\n// All deployed minipool contracts must maintain a\\n// Consistent storage layout with RocketMinipoolDelegate.\\n// ******************************************************\\n\\nabstract contract RocketMinipoolStorageLayout {\\n    // Storage state enum\\n    enum StorageState {\\n        Undefined,\\n        Uninitialised,\\n        Initialised\\n    }\\n\\n\\t// Main Rocket Pool storage contract\\n    RocketStorageInterface internal rocketStorage = RocketStorageInterface(0);\\n\\n    // Status\\n    MinipoolStatus internal status;\\n    uint256 internal statusBlock;\\n    uint256 internal statusTime;\\n    uint256 internal withdrawalBlock;\\n\\n    // Deposit type\\n    MinipoolDeposit internal depositType;\\n\\n    // Node details\\n    address internal nodeAddress;\\n    uint256 internal nodeFee;\\n    uint256 internal nodeDepositBalance;\\n    bool internal nodeDepositAssigned;\\n    uint256 internal nodeRefundBalance;\\n    uint256 internal nodeSlashBalance;\\n\\n    // User deposit details\\n    uint256 internal userDepositBalance;\\n    uint256 internal userDepositAssignedTime;\\n\\n    // Upgrade options\\n    bool internal useLatestDelegate = false;\\n    address internal rocketMinipoolDelegate;\\n    address internal rocketMinipoolDelegatePrev;\\n\\n    // Local copy of RETH address\\n    address internal rocketTokenRETH;\\n\\n    // Local copy of penalty contract\\n    address internal rocketMinipoolPenalty;\\n\\n    // Used to prevent direct access to delegate and prevent calling initialise more than once\\n    StorageState storageState = StorageState.Undefined;\\n\\n    // Whether node operator has finalised the pool\\n    bool internal finalised;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/RocketStorageInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketStorageInterface {\\n\\n    // Guardian\\n    function getGuardian() external view returns(address);\\n    function setGuardian(address _newAddress) external;\\n    function confirmGuardian() external;\\n\\n    // Getters\\n    function getAddress(bytes32 _key) external view returns (address);\\n    function getUint(bytes32 _key) external view returns (uint);\\n    function getString(bytes32 _key) external view returns (string memory);\\n    function getBytes(bytes32 _key) external view returns (bytes memory);\\n    function getBool(bytes32 _key) external view returns (bool);\\n    function getInt(bytes32 _key) external view returns (int);\\n    function getBytes32(bytes32 _key) external view returns (bytes32);\\n\\n    // Setters\\n    function setAddress(bytes32 _key, address _value) external;\\n    function setUint(bytes32 _key, uint _value) external;\\n    function setString(bytes32 _key, string calldata _value) external;\\n    function setBytes(bytes32 _key, bytes calldata _value) external;\\n    function setBool(bytes32 _key, bool _value) external;\\n    function setInt(bytes32 _key, int _value) external;\\n    function setBytes32(bytes32 _key, bytes32 _value) external;\\n\\n    // Deleters\\n    function deleteAddress(bytes32 _key) external;\\n    function deleteUint(bytes32 _key) external;\\n    function deleteString(bytes32 _key) external;\\n    function deleteBytes(bytes32 _key) external;\\n    function deleteBool(bytes32 _key) external;\\n    function deleteInt(bytes32 _key) external;\\n    function deleteBytes32(bytes32 _key) external;\\n\\n    // Arithmetic\\n    function addUint(bytes32 _key, uint256 _amount) external;\\n    function subUint(bytes32 _key, uint256 _amount) external;\\n\\n    // Protected storage\\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\\n    function confirmWithdrawalAddress(address _nodeAddress) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/dao/node/RocketDAONodeTrustedInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDAONodeTrustedInterface {\\n    function getBootstrapModeDisabled() external view returns (bool);\\n    function getMemberQuorumVotesRequired() external view returns (uint256);\\n    function getMemberAt(uint256 _index) external view returns (address);\\n    function getMemberCount() external view returns (uint256);\\n    function getMemberMinRequired() external view returns (uint256);\\n    function getMemberIsValid(address _nodeAddress) external view returns (bool);\\n    function getMemberLastProposalTime(address _nodeAddress) external view returns (uint256);\\n    function getMemberID(address _nodeAddress) external view returns (string memory);\\n    function getMemberUrl(address _nodeAddress) external view returns (string memory);\\n    function getMemberJoinedTime(address _nodeAddress) external view returns (uint256);\\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) external view returns (uint256);\\n    function getMemberRPLBondAmount(address _nodeAddress) external view returns (uint256);\\n    function getMemberIsChallenged(address _nodeAddress) external view returns (bool);\\n    function getMemberUnbondedValidatorCount(address _nodeAddress) external view returns (uint256);\\n    function incrementMemberUnbondedValidatorCount(address _nodeAddress) external;\\n    function decrementMemberUnbondedValidatorCount(address _nodeAddress) external;\\n    function bootstrapMember(string memory _id, string memory _url, address _nodeAddress) external;\\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) external;\\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) external;\\n    function memberJoinRequired(string memory _id, string memory _url) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../../../types/MinipoolDeposit.sol\\\";\\n\\ninterface RocketDAOProtocolSettingsMinipoolInterface {\\n    function getLaunchBalance() external view returns (uint256);\\n    function getDepositNodeAmount(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getFullDepositNodeAmount() external view returns (uint256);\\n    function getHalfDepositNodeAmount() external view returns (uint256);\\n    function getEmptyDepositNodeAmount() external view returns (uint256);\\n    function getDepositUserAmount(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getFullDepositUserAmount() external view returns (uint256);\\n    function getHalfDepositUserAmount() external view returns (uint256);\\n    function getEmptyDepositUserAmount() external view returns (uint256);\\n    function getSubmitWithdrawableEnabled() external view returns (bool);\\n    function getLaunchTimeout() external view returns (uint256);\\n    function getMaximumCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDAOProtocolSettingsNodeInterface {\\n    function getRegistrationEnabled() external view returns (bool);\\n    function getDepositEnabled() external view returns (bool);\\n    function getMinimumPerMinipoolStake() external view returns (uint256);\\n    function getMaximumPerMinipoolStake() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/minipool/RocketMinipoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\nimport \\\"../RocketStorageInterface.sol\\\";\\n\\ninterface RocketMinipoolInterface {\\n    function initialise(address _nodeAddress, MinipoolDeposit _depositType) external;\\n    function getStatus() external view returns (MinipoolStatus);\\n    function getFinalised() external view returns (bool);\\n    function getStatusBlock() external view returns (uint256);\\n    function getStatusTime() external view returns (uint256);\\n    function getDepositType() external view returns (MinipoolDeposit);\\n    function getNodeAddress() external view returns (address);\\n    function getNodeFee() external view returns (uint256);\\n    function getNodeDepositBalance() external view returns (uint256);\\n    function getNodeRefundBalance() external view returns (uint256);\\n    function getNodeDepositAssigned() external view returns (bool);\\n    function getUserDepositBalance() external view returns (uint256);\\n    function getUserDepositAssigned() external view returns (bool);\\n    function getUserDepositAssignedTime() external view returns (uint256);\\n    function getWithdrawalCredentials() external view returns (bytes memory);\\n    function calculateNodeShare(uint256 _balance) external view returns (uint256);\\n    function calculateUserShare(uint256 _balance) external view returns (uint256);\\n    function nodeDeposit() external payable;\\n    function userDeposit() external payable;\\n    function distributeBalance() external;\\n    function distributeBalanceAndFinalise() external;\\n    function refund() external;\\n    function slash() external;\\n    function finalise() external;\\n    function stake(bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external;\\n    function setWithdrawable() external;\\n    function dissolve() external;\\n    function close() external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/minipool/RocketMinipoolManagerInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"./RocketMinipoolInterface.sol\\\";\\n\\ninterface RocketMinipoolManagerInterface {\\n    function getMinipoolCount() external view returns (uint256);\\n    function getStakingMinipoolCount() external view returns (uint256);\\n    function getFinalisedMinipoolCount() external view returns (uint256);\\n    function getActiveMinipoolCount() external view returns (uint256);\\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) external view returns (uint256, uint256, uint256, uint256, uint256);\\n    function getMinipoolAt(uint256 _index) external view returns (address);\\n    function getNodeMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeActiveMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeStakingMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\\n    function getNodeValidatingMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\\n    function getMinipoolByPubkey(bytes calldata _pubkey) external view returns (address);\\n    function getMinipoolExists(address _minipoolAddress) external view returns (bool);\\n    function getMinipoolPubkey(address _minipoolAddress) external view returns (bytes memory);\\n    function createMinipool(address _nodeAddress, MinipoolDeposit _depositType) external returns (RocketMinipoolInterface);\\n    function destroyMinipool() external;\\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) external;\\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) external;\\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) external;\\n    function setMinipoolPubkey(bytes calldata _pubkey) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/minipool/RocketMinipoolQueueInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\n\\ninterface RocketMinipoolQueueInterface {\\n    function getTotalLength() external view returns (uint256);\\n    function getLength(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getTotalCapacity() external view returns (uint256);\\n    function getEffectiveCapacity() external view returns (uint256);\\n    function getNextCapacity() external view returns (uint256);\\n    function getNextDeposit() external view returns (MinipoolDeposit, uint256);\\n    function enqueueMinipool(MinipoolDeposit _depositType, address _minipool) external;\\n    function dequeueMinipool() external returns (address minipoolAddress);\\n    function dequeueMinipoolByDeposit(MinipoolDeposit _depositType) external returns (address minipoolAddress);\\n    function removeMinipool(MinipoolDeposit _depositType) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/network/RocketNetworkPricesInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNetworkPricesInterface {\\n    function getPricesBlock() external view returns (uint256);\\n    function getRPLPrice() external view returns (uint256);\\n    function getEffectiveRPLStake() external view returns (uint256);\\n    function getEffectiveRPLStakeUpdatedBlock() external view returns (uint256);\\n    function getLatestReportableBlock() external view returns (uint256);\\n    function inConsensus() external view returns (bool);\\n    function submitPrices(uint256 _block, uint256 _rplPrice, uint256 _effectiveRplStake) external;\\n    function executeUpdatePrices(uint256 _block, uint256 _rplPrice, uint256 _effectiveRplStake) external;\\n    function increaseEffectiveRPLStake(uint256 _amount) external;\\n    function decreaseEffectiveRPLStake(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/node/RocketNodeStakingInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNodeStakingInterface {\\n    function getTotalRPLStake() external view returns (uint256);\\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\\n    function getTotalEffectiveRPLStake() external view returns (uint256);\\n    function calculateTotalEffectiveRPLStake(uint256 offset, uint256 limit, uint256 rplPrice) external view returns (uint256);\\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinipoolLimit(address _nodeAddress) external view returns (uint256);\\n    function stakeRPL(uint256 _amount) external;\\n    function withdrawRPL(uint256 _amount) external;\\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/util/AddressSetStorageInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface AddressSetStorageInterface {\\n    function getCount(bytes32 _key) external view returns (uint);\\n    function getItem(bytes32 _key, uint _index) external view returns (address);\\n    function getIndexOf(bytes32 _key, address _value) external view returns (int);\\n    function addItem(bytes32 _key, address _value) external;\\n    function removeItem(bytes32 _key, address _value) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/types/MinipoolDeposit.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Represents the type of deposits required by a minipool\\n\\nenum MinipoolDeposit {\\n    None,    // Marks an invalid deposit type\\n    Full,    // The minipool requires 32 ETH from the node operator, 16 ETH of which will be refinanced from user deposits\\n    Half,    // The minipool required 16 ETH from the node operator to be matched with 16 ETH from user deposits\\n    Empty    // The minipool requires 0 ETH from the node operator to be matched with 32 ETH from user deposits (trusted nodes only)\\n}\\n\"\r\n    },\r\n    \"/contracts/types/MinipoolStatus.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Represents a minipool's status within the network\\n\\nenum MinipoolStatus {\\n    Initialised,    // The minipool has been initialised and is awaiting a deposit of user ETH\\n    Prelaunch,      // The minipool has enough ETH to begin staking and is awaiting launch by the node operator\\n    Staking,        // The minipool is currently staking\\n    Withdrawable,   // The minipool has become withdrawable on the beacon chain and can be withdrawn from by the node operator\\n    Dissolved       // The minipool has been dissolved and its user deposited ETH has been returned to the deposit pool\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract RocketStorageInterface\",\"name\":\"_rocketStorageAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minipool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MinipoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minipool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MinipoolDestroyed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"},{\"internalType\":\"enum MinipoolDeposit\",\"name\":\"_depositType\",\"type\":\"uint8\"}],\"name\":\"createMinipool\",\"outputs\":[{\"internalType\":\"contract RocketMinipoolInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"decrementNodeStakingMinipoolCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyMinipool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalisedMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getMinipoolAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubkey\",\"type\":\"bytes\"}],\"name\":\"getMinipoolByPubkey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getMinipoolCountPerStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialisedCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prelaunchCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dissolvedCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minipoolAddress\",\"type\":\"address\"}],\"name\":\"getMinipoolExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minipoolAddress\",\"type\":\"address\"}],\"name\":\"getMinipoolPubkey\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"getNodeActiveMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"getNodeFinalisedMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getNodeMinipoolAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"getNodeMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"getNodeStakingMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getNodeValidatingMinipoolAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"getNodeValidatingMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingMinipoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"incrementNodeFinalisedMinipoolCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"incrementNodeStakingMinipoolCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubkey\",\"type\":\"bytes\"}],\"name\":\"setMinipoolPubkey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RocketMinipoolManager","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"15000","ConstructorArguments":"0000000000000000000000001d8f8f00cfa6758d7be78336684788fb0ee0fa46","EVMVersion":"istanbul","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9275fa7280f6aaa261e74c3518fd3797eb837f7e65c58d4d2be2881d555745ae"}]}