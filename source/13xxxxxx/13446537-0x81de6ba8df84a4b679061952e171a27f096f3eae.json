{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/oracle/collateralization/CollateralizationOracleGuardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ICollateralizationOracleWrapper.sol\\\";\\nimport \\\"../../refs/CoreRef.sol\\\";\\nimport \\\"../../utils/Timed.sol\\\";\\nimport \\\"../../Constants.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\n/** \\n    @title Fei Protocol's Collateralization Oracle Guardian\\n    @author Fei Protocol\\n    This contract needs to be granted the ORACLE_ADMIN role\\n    The guardian can leverage this contract to make small bounded changes to CR\\n    This is intended to be used only in emergencies when the base CollateralizationOracle is compromised\\n    The guardian should be able to approximate manual changes to CR via this contract without retaining too much power\\n*/\\ncontract CollateralizationOracleGuardian is CoreRef, Timed {\\n    using SafeCast for uint256;\\n\\n    event DeviationThresholdUpdate(uint256 oldDeviationThresholdBasisPoints, uint256 newDeviationThresholdBasisPoints);\\n\\n    /// @notice the oracle wrapper to update\\n    ICollateralizationOracleWrapper public immutable oracleWrapper;\\n\\n    /// @notice the maximum update size relative to current, measured in basis points (1/10000)\\n    uint256 public deviationThresholdBasisPoints;\\n    \\n    /**\\n        @notice The constructor for CollateralizationOracleGuardian\\n        @param _core the core address to reference\\n        @param _oracleWrapper the instance of CollateralizationOracleWrapper\\n        @param _frequency the maximum frequency a guardian can update the cache\\n        @param _deviationThresholdBasisPoints the maximum percent change in a cache value for a given update\\n     */\\n    constructor(\\n        address _core, \\n        ICollateralizationOracleWrapper _oracleWrapper, \\n        uint256 _frequency,\\n        uint256 _deviationThresholdBasisPoints\\n    ) CoreRef(_core) Timed(_frequency) {\\n        oracleWrapper = _oracleWrapper;\\n\\n        _setDeviationThresholdBasisPoints(_deviationThresholdBasisPoints);\\n\\n        _initTimed();\\n    }\\n\\n    /// @notice guardian set the cache values on collateralization oracle\\n    /// @param protocolControlledValue new PCV value\\n    /// @param userCirculatingFei new user FEI value\\n    /// @dev make sure to pause the CR oracle wrapper or else the set value would be overwritten on next update\\n    function setCache(\\n        uint256 protocolControlledValue, \\n        uint256 userCirculatingFei\\n    ) external onlyGuardianOrGovernor afterTime {\\n        // Reset timer\\n        _initTimed();\\n\\n        // Check boundaries on new update values\\n        uint256 cachedPCV = oracleWrapper.cachedProtocolControlledValue();\\n        require(\\n            calculateDeviationThresholdBasisPoints(protocolControlledValue, cachedPCV) <= deviationThresholdBasisPoints,\\n            \\\"CollateralizationOracleGuardian: Cached PCV exceeds deviation\\\"\\n        );\\n\\n        uint256 cachedUserFei = oracleWrapper.cachedUserCirculatingFei();\\n        require(\\n            calculateDeviationThresholdBasisPoints(userCirculatingFei, cachedUserFei) <= deviationThresholdBasisPoints,\\n            \\\"CollateralizationOracleGuardian: Cached User FEI exceeds deviation\\\"\\n        );\\n\\n        // Set the new cache values\\n        int256 equity = protocolControlledValue.toInt256() - userCirculatingFei.toInt256();\\n        oracleWrapper.setCache(protocolControlledValue, userCirculatingFei, equity);\\n\\n        assert(oracleWrapper.cachedProtocolEquity() == equity);\\n    }\\n\\n    /// @notice return the percent deviation between a and b in basis points terms\\n    function calculateDeviationThresholdBasisPoints(uint256 a, uint256 b) public pure returns (uint256) {\\n        uint256 delta = (a < b) ? (b - a) : (a - b);\\n        return delta * Constants.BASIS_POINTS_GRANULARITY / a;\\n    }\\n\\n    /// @notice governance setter for maximum deviation the guardian can change per update\\n    function setDeviationThresholdBasisPoints(uint256 newDeviationThresholdBasisPoints) external onlyGovernor {\\n        _setDeviationThresholdBasisPoints(newDeviationThresholdBasisPoints);\\n    }\\n\\n    function _setDeviationThresholdBasisPoints(uint256 newDeviationThresholdBasisPoints) internal {\\n        require(newDeviationThresholdBasisPoints <= Constants.BASIS_POINTS_GRANULARITY, \\\"CollateralizationOracleGuardian: deviation exceeds granularity\\\");\\n\\n        uint256 oldDeviationThresholdBasisPoints = deviationThresholdBasisPoints;\\n        deviationThresholdBasisPoints = newDeviationThresholdBasisPoints;\\n\\n        emit DeviationThresholdUpdate(oldDeviationThresholdBasisPoints, newDeviationThresholdBasisPoints);\\n    }\\n}\"\r\n    },\r\n    \"./contracts/oracle/collateralization/ICollateralizationOracleWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ICollateralizationOracle.sol\\\";\\n\\n/// @title Collateralization ratio oracle interface for Fei Protocol\\n/// @author Fei Protocol\\ninterface ICollateralizationOracleWrapper is ICollateralizationOracle {\\n\\n    // ----------- Events ------------------------------------------------------\\n\\n    event CachedValueUpdate(\\n        address from,\\n        uint256 indexed protocolControlledValue,\\n        uint256 indexed userCirculatingFei,\\n        int256 indexed protocolEquity\\n    );\\n\\n    event CollateralizationOracleUpdate(\\n        address from,\\n        address indexed oldOracleAddress,\\n        address indexed newOracleAddress\\n    );\\n\\n    event DeviationThresholdUpdate(\\n        address from,\\n        uint256 indexed oldThreshold,\\n        uint256 indexed newThreshold\\n    );\\n\\n    event ReadPauseOverrideUpdate(\\n        bool readPauseOverride\\n    );\\n    // ----------- Public state changing api -----------\\n\\n    function updateIfOutdated() external;\\n\\n    // ----------- Governor only state changing api -----------\\n    function setValidityDuration(uint256 _validityDuration) external;\\n\\n    function setReadPauseOverride(bool newReadPauseOverride) external;\\n\\n    function setDeviationThresholdBasisPoints(uint256 _newDeviationThresholdBasisPoints) external;\\n\\n    function setCollateralizationOracle(address _newCollateralizationOracle) external;\\n\\n    function setCache(\\n        uint256 protocolControlledValue,\\n        uint256 userCirculatingFei,\\n        int256 protocolEquity\\n    ) external;\\n\\n    // ----------- Getters -----------\\n    \\n    function cachedProtocolControlledValue() external view returns (uint256);\\n    \\n    function cachedUserCirculatingFei() external view returns (uint256);\\n\\n    function cachedProtocolEquity() external view returns (int256);\\n\\n    function deviationThresholdBasisPoints() external view returns (uint256);\\n\\n    function collateralizationOracle() external view returns(address);\\n\\n    function isOutdatedOrExceededDeviationThreshold() external view returns (bool);\\n\\n    function pcvStatsCurrent() external view returns (\\n        uint256 protocolControlledValue,\\n        uint256 userCirculatingFei,\\n        int256 protocolEquity,\\n        bool validityStatus\\n    );\\n\\n    function isExceededDeviationThreshold() external view returns (bool);\\n\\n    function readPauseOverride() external view returns(bool);\\n}\"\r\n    },\r\n    \"./contracts/oracle/collateralization/ICollateralizationOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"../IOracle.sol\\\";\\n\\n/// @title Collateralization ratio oracle interface for Fei Protocol\\n/// @author Fei Protocol\\ninterface ICollateralizationOracle is IOracle {\\n\\n    // ----------- Getters -----------\\n\\n    // returns the PCV value, User-circulating FEI, and Protocol Equity, as well\\n    // as a validity status.\\n    function pcvStats() external view returns (\\n        uint256 protocolControlledValue,\\n        uint256 userCirculatingFei,\\n        int256 protocolEquity,\\n        bool validityStatus\\n    );\\n\\n    // true if Protocol Equity > 0\\n    function isOvercollateralized() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"../external/Decimal.sol\\\";\\n\\n/// @title generic oracle interface for Fei Protocol\\n/// @author Fei Protocol\\ninterface IOracle {\\n    // ----------- Events -----------\\n\\n    event Update(uint256 _peg);\\n\\n    // ----------- State changing API -----------\\n\\n    function update() external;\\n\\n    // ----------- Getters -----------\\n\\n    function read() external view returns (Decimal.D256 memory, bool);\\n\\n    function isOutdated() external view returns (bool);\\n    \\n}\\n\"\r\n    },\r\n    \"./contracts/external/Decimal.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2019 dYdX Trading Inc.\\n    Copyright 2020 Empty Set Squad <emptysetsquad@protonmail.com>\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n    http://www.apache.org/licenses/LICENSE-2.0\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n*/\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title Decimal\\n * @author dYdX\\n *\\n * Library that defines a fixed-point number with 18 decimal places.\\n */\\nlibrary Decimal {\\n    using SafeMath for uint256;\\n\\n    // ============ Constants ============\\n\\n    uint256 private constant BASE = 10**18;\\n\\n    // ============ Structs ============\\n\\n\\n    struct D256 {\\n        uint256 value;\\n    }\\n\\n    // ============ Static Functions ============\\n\\n    function zero()\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: 0 });\\n    }\\n\\n    function one()\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: BASE });\\n    }\\n\\n    function from(\\n        uint256 a\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: a.mul(BASE) });\\n    }\\n\\n    function ratio(\\n        uint256 a,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: getPartial(a, BASE, b) });\\n    }\\n\\n    // ============ Self Functions ============\\n\\n    function add(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.add(b.mul(BASE)) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.mul(BASE)) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        uint256 b,\\n        string memory reason\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.mul(BASE), reason) });\\n    }\\n\\n    function mul(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.mul(b) });\\n    }\\n\\n    function div(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.div(b) });\\n    }\\n\\n    function pow(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        if (b == 0) {\\n            return from(1);\\n        }\\n\\n        D256 memory temp = D256({ value: self.value });\\n        for (uint256 i = 1; i < b; i++) {\\n            temp = mul(temp, self);\\n        }\\n\\n        return temp;\\n    }\\n\\n    function add(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.add(b.value) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.value) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        D256 memory b,\\n        string memory reason\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.value, reason) });\\n    }\\n\\n    function mul(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: getPartial(self.value, b.value, BASE) });\\n    }\\n\\n    function div(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: getPartial(self.value, BASE, b.value) });\\n    }\\n\\n    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return self.value == b.value;\\n    }\\n\\n    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) == 2;\\n    }\\n\\n    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) == 0;\\n    }\\n\\n    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) > 0;\\n    }\\n\\n    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) < 2;\\n    }\\n\\n    function isZero(D256 memory self) internal pure returns (bool) {\\n        return self.value == 0;\\n    }\\n\\n    function asUint256(D256 memory self) internal pure returns (uint256) {\\n        return self.value.div(BASE);\\n    }\\n\\n    // ============ Core Methods ============\\n\\n    function getPartial(\\n        uint256 target,\\n        uint256 numerator,\\n        uint256 denominator\\n    )\\n    private\\n    pure\\n    returns (uint256)\\n    {\\n        return target.mul(numerator).div(denominator);\\n    }\\n\\n    function compareTo(\\n        D256 memory a,\\n        D256 memory b\\n    )\\n    private\\n    pure\\n    returns (uint256)\\n    {\\n        if (a.value == b.value) {\\n            return 1;\\n        }\\n        return a.value > b.value ? 2 : 0;\\n    }\\n}\"\r\n    },\r\n    \"./contracts/refs/CoreRef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ICoreRef.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\n/// @title A Reference to Core\\n/// @author Fei Protocol\\n/// @notice defines some modifiers and utilities around interacting with Core\\nabstract contract CoreRef is ICoreRef, Pausable {\\n    ICore private _core;\\n\\n    /// @notice a role used with a subset of governor permissions for this contract only\\n    bytes32 public override CONTRACT_ADMIN_ROLE;\\n\\n    /// @notice boolean to check whether or not the contract has been initialized.\\n    /// cannot be initialized twice.\\n    bool private _initialized;\\n\\n    constructor(address coreAddress) {\\n        _initialize(coreAddress);\\n    }\\n\\n    /// @notice CoreRef constructor\\n    /// @param coreAddress Fei Core to reference\\n    function _initialize(address coreAddress) internal {\\n        require(!_initialized, \\\"CoreRef: already initialized\\\");\\n        _initialized = true;\\n\\n        _core = ICore(coreAddress);\\n        _setContractAdminRole(_core.GOVERN_ROLE());\\n    }\\n\\n    modifier ifMinterSelf() {\\n        if (_core.isMinter(address(this))) {\\n            _;\\n        }\\n    }\\n\\n    modifier onlyMinter() {\\n        require(_core.isMinter(msg.sender), \\\"CoreRef: Caller is not a minter\\\");\\n        _;\\n    }\\n\\n    modifier onlyBurner() {\\n        require(_core.isBurner(msg.sender), \\\"CoreRef: Caller is not a burner\\\");\\n        _;\\n    }\\n\\n    modifier onlyPCVController() {\\n        require(\\n            _core.isPCVController(msg.sender),\\n            \\\"CoreRef: Caller is not a PCV controller\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyGovernorOrAdmin() {\\n        require(\\n            _core.isGovernor(msg.sender) ||\\n            isContractAdmin(msg.sender),\\n            \\\"CoreRef: Caller is not a governor or contract admin\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(\\n            _core.isGovernor(msg.sender),\\n            \\\"CoreRef: Caller is not a governor\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyGuardianOrGovernor() {\\n        require(\\n            _core.isGovernor(msg.sender) || \\n            _core.isGuardian(msg.sender),\\n            \\\"CoreRef: Caller is not a guardian or governor\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyFei() {\\n        require(msg.sender == address(fei()), \\\"CoreRef: Caller is not FEI\\\");\\n        _;\\n    }\\n\\n    /// @notice set new Core reference address\\n    /// @param newCore the new core address\\n    function setCore(address newCore) external override onlyGovernor {\\n        require(newCore != address(0), \\\"CoreRef: zero address\\\");\\n        address oldCore = address(_core);\\n        _core = ICore(newCore);\\n        emit CoreUpdate(oldCore, newCore);\\n    }\\n\\n    /// @notice sets a new admin role for this contract\\n    function setContractAdminRole(bytes32 newContractAdminRole) external override onlyGovernor {\\n        _setContractAdminRole(newContractAdminRole);\\n    }\\n\\n    /// @notice returns whether a given address has the admin role for this contract\\n    function isContractAdmin(address _admin) public view override returns (bool) {\\n        return _core.hasRole(CONTRACT_ADMIN_ROLE, _admin);\\n    }\\n\\n    /// @notice set pausable methods to paused\\n    function pause() public override onlyGuardianOrGovernor {\\n        _pause();\\n    }\\n\\n    /// @notice set pausable methods to unpaused\\n    function unpause() public override onlyGuardianOrGovernor {\\n        _unpause();\\n    }\\n\\n    /// @notice address of the Core contract referenced\\n    /// @return ICore implementation address\\n    function core() public view override returns (ICore) {\\n        return _core;\\n    }\\n\\n    /// @notice address of the Fei contract referenced by Core\\n    /// @return IFei implementation address\\n    function fei() public view override returns (IFei) {\\n        return _core.fei();\\n    }\\n\\n    /// @notice address of the Tribe contract referenced by Core\\n    /// @return IERC20 implementation address\\n    function tribe() public view override returns (IERC20) {\\n        return _core.tribe();\\n    }\\n\\n    /// @notice fei balance of contract\\n    /// @return fei amount held\\n    function feiBalance() public view override returns (uint256) {\\n        return fei().balanceOf(address(this));\\n    }\\n\\n    /// @notice tribe balance of contract\\n    /// @return tribe amount held\\n    function tribeBalance() public view override returns (uint256) {\\n        return tribe().balanceOf(address(this));\\n    }\\n\\n    function _burnFeiHeld() internal {\\n        fei().burn(feiBalance());\\n    }\\n\\n    function _mintFei(address to, uint256 amount) internal virtual {\\n        if (amount != 0) {\\n            fei().mint(to, amount);\\n        }\\n    }\\n\\n    function _setContractAdminRole(bytes32 newContractAdminRole) internal {\\n        bytes32 oldContractAdminRole = CONTRACT_ADMIN_ROLE;\\n        CONTRACT_ADMIN_ROLE = newContractAdminRole;\\n        emit ContractAdminRoleUpdate(oldContractAdminRole, newContractAdminRole);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/refs/ICoreRef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"../core/ICore.sol\\\";\\n\\n/// @title CoreRef interface\\n/// @author Fei Protocol\\ninterface ICoreRef {\\n    // ----------- Events -----------\\n\\n    event CoreUpdate(address indexed oldCore, address indexed newCore);\\n\\n    event ContractAdminRoleUpdate(bytes32 indexed oldContractAdminRole, bytes32 indexed newContractAdminRole);\\n\\n    // ----------- Governor only state changing api -----------\\n\\n    function setCore(address newCore) external;\\n\\n    function setContractAdminRole(bytes32 newContractAdminRole) external;\\n\\n    // ----------- Governor or Guardian only state changing api -----------\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    // ----------- Getters -----------\\n\\n    function core() external view returns (ICore);\\n\\n    function fei() external view returns (IFei);\\n\\n    function tribe() external view returns (IERC20);\\n\\n    function feiBalance() external view returns (uint256);\\n\\n    function tribeBalance() external view returns (uint256);\\n\\n    function CONTRACT_ADMIN_ROLE() external view returns (bytes32);\\n\\n    function isContractAdmin(address admin) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"./contracts/core/ICore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IPermissions.sol\\\";\\nimport \\\"../token/IFei.sol\\\";\\n\\n/// @title Core Interface\\n/// @author Fei Protocol\\ninterface ICore is IPermissions {\\n    // ----------- Events -----------\\n\\n    event FeiUpdate(address indexed _fei);\\n    event TribeUpdate(address indexed _tribe);\\n    event GenesisGroupUpdate(address indexed _genesisGroup);\\n    event TribeAllocation(address indexed _to, uint256 _amount);\\n    event GenesisPeriodComplete(uint256 _timestamp);\\n\\n    // ----------- Governor only state changing api -----------\\n\\n    function init() external;\\n\\n    // ----------- Governor only state changing api -----------\\n\\n    function setFei(address token) external;\\n\\n    function setTribe(address token) external;\\n\\n    function allocateTribe(address to, uint256 amount) external;\\n\\n    // ----------- Getters -----------\\n\\n    function fei() external view returns (IFei);\\n\\n    function tribe() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"./contracts/core/IPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\n/// @title Permissions interface\\n/// @author Fei Protocol\\ninterface IPermissions is IAccessControl {\\n    // ----------- Governor only state changing api -----------\\n\\n    function createRole(bytes32 role, bytes32 adminRole) external;\\n\\n    function grantMinter(address minter) external;\\n\\n    function grantBurner(address burner) external;\\n\\n    function grantPCVController(address pcvController) external;\\n\\n    function grantGovernor(address governor) external;\\n\\n    function grantGuardian(address guardian) external;\\n\\n    function revokeMinter(address minter) external;\\n\\n    function revokeBurner(address burner) external;\\n\\n    function revokePCVController(address pcvController) external;\\n\\n    function revokeGovernor(address governor) external;\\n\\n    function revokeGuardian(address guardian) external;\\n\\n    // ----------- Revoker only state changing api -----------\\n\\n    function revokeOverride(bytes32 role, address account) external;\\n\\n    // ----------- Getters -----------\\n\\n    function isBurner(address _address) external view returns (bool);\\n\\n    function isMinter(address _address) external view returns (bool);\\n\\n    function isGovernor(address _address) external view returns (bool);\\n\\n    function isGuardian(address _address) external view returns (bool);\\n\\n    function isPCVController(address _address) external view returns (bool);\\n\\n    function GUARDIAN_ROLE() external view returns (bytes32);\\n\\n    function GOVERN_ROLE() external view returns (bytes32);\\n\\n    function BURNER_ROLE() external view returns (bytes32);\\n\\n    function MINTER_ROLE() external view returns (bytes32);\\n\\n    function PCV_CONTROLLER_ROLE() external view returns (bytes32);\\n\\n}\\n\"\r\n    },\r\n    \"./contracts/token/IFei.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title FEI stablecoin interface\\n/// @author Fei Protocol\\ninterface IFei is IERC20 {\\n    // ----------- Events -----------\\n\\n    event Minting(\\n        address indexed _to,\\n        address indexed _minter,\\n        uint256 _amount\\n    );\\n\\n    event Burning(\\n        address indexed _to,\\n        address indexed _burner,\\n        uint256 _amount\\n    );\\n\\n    event IncentiveContractUpdate(\\n        address indexed _incentivized,\\n        address indexed _incentiveContract\\n    );\\n\\n    // ----------- State changing api -----------\\n\\n    function burn(uint256 amount) external;\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    // ----------- Burner only state changing api -----------\\n\\n    function burnFrom(address account, uint256 amount) external;\\n\\n    // ----------- Minter only state changing api -----------\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    // ----------- Governor only state changing api -----------\\n\\n    function setIncentiveContract(address account, address incentive) external;\\n\\n    // ----------- Getters -----------\\n\\n    function incentiveContract(address account) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/Timed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\n/// @title an abstract contract for timed events\\n/// @author Fei Protocol\\nabstract contract Timed {\\n\\n    /// @notice the start timestamp of the timed period\\n    uint256 public startTime;\\n\\n    /// @notice the duration of the timed period\\n    uint256 public duration;\\n\\n    event DurationUpdate(uint256 oldDuration, uint256 newDuration);\\n\\n    event TimerReset(uint256 startTime);\\n\\n    constructor(uint256 _duration) {\\n        _setDuration(_duration);\\n    }\\n\\n    modifier duringTime() {\\n        require(isTimeStarted(), \\\"Timed: time not started\\\");\\n        require(!isTimeEnded(), \\\"Timed: time ended\\\");\\n        _;\\n    }\\n\\n    modifier afterTime() {\\n        require(isTimeEnded(), \\\"Timed: time not ended\\\");\\n        _;\\n    }\\n\\n    /// @notice return true if time period has ended\\n    function isTimeEnded() public view returns (bool) {\\n        return remainingTime() == 0;\\n    }\\n\\n    /// @notice number of seconds remaining until time is up\\n    /// @return remaining\\n    function remainingTime() public view returns (uint256) {\\n        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\\n    }\\n\\n    /// @notice number of seconds since contract was initialized\\n    /// @return timestamp\\n    /// @dev will be less than or equal to duration\\n    function timeSinceStart() public view returns (uint256) {\\n        if (!isTimeStarted()) {\\n            return 0; // uninitialized\\n        }\\n        uint256 _duration = duration;\\n        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\\n        return timePassed > _duration ? _duration : timePassed;\\n    }\\n\\n    function isTimeStarted() public view returns (bool) {\\n        return startTime != 0;\\n    }\\n\\n    function _initTimed() internal {\\n        startTime = block.timestamp;\\n        \\n        emit TimerReset(block.timestamp);\\n    }\\n\\n    function _setDuration(uint256 newDuration) internal {\\n        require(newDuration != 0, \\\"Timed: zero duration\\\");\\n\\n        uint256 oldDuration = duration;\\n        duration = newDuration;\\n        emit DurationUpdate(oldDuration, newDuration);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\\\";\\n\\nlibrary Constants {\\n    /// @notice the denominator for basis points granularity (10,000)\\n    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;\\n    \\n    uint256 public constant ONE_YEAR = 365.25 days;\\n\\n    /// @notice WETH9 address\\n    IWETH public constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n    /// @notice USD stand-in address\\n    address public constant USD = 0x1111111111111111111111111111111111111111;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_core\",\"type\":\"address\"},{\"internalType\":\"contract ICollateralizationOracleWrapper\",\"name\":\"_oracleWrapper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_frequency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deviationThresholdBasisPoints\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"oldContractAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newContractAdminRole\",\"type\":\"bytes32\"}],\"name\":\"ContractAdminRoleUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldCore\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCore\",\"type\":\"address\"}],\"name\":\"CoreUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeviationThresholdBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeviationThresholdBasisPoints\",\"type\":\"uint256\"}],\"name\":\"DeviationThresholdUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"DurationUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"TimerReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTRACT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"calculateDeviationThresholdBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"contract ICore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deviationThresholdBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fei\",\"outputs\":[{\"internalType\":\"contract IFei\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feiBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"isContractAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleWrapper\",\"outputs\":[{\"internalType\":\"contract ICollateralizationOracleWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"protocolControlledValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCirculatingFei\",\"type\":\"uint256\"}],\"name\":\"setCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newContractAdminRole\",\"type\":\"bytes32\"}],\"name\":\"setContractAdminRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCore\",\"type\":\"address\"}],\"name\":\"setCore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDeviationThresholdBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setDeviationThresholdBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSinceStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tribe\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tribeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CollateralizationOracleGuardian","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008d5ed43dca8c2f7dfb20cf7b53cc7e593635d7b9000000000000000000000000d1866289b4bd22d453fff676760961e0898ee9bf000000000000000000000000000000000000000000000000000000000000a8c000000000000000000000000000000000000000000000000000000000000001f4","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1e843c56a749346d75c72327a2e7b0b315d9fe149b02cd55f999d500603fa53e"}]}