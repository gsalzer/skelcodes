{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract ADM312 {\r\n\r\n  address public COO;\r\n  address public CTO;\r\n  address public CFO;\r\n  address private coreAddress;\r\n  address public logicAddress;\r\n  address public superAddress;\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == COO || msg.sender == CTO || msg.sender == CFO);\r\n    _;\r\n  }\r\n  \r\n  modifier onlyContract() {\r\n    require(msg.sender == coreAddress || msg.sender == logicAddress || msg.sender == superAddress);\r\n    _;\r\n  }\r\n    \r\n  modifier onlyContractAdmin() {\r\n    require(msg.sender == coreAddress || msg.sender == logicAddress || msg.sender == superAddress || msg.sender == COO || msg.sender == CTO || msg.sender == CFO);\r\n     _;\r\n  }\r\n  \r\n  function transferAdmin(address _newAdminAddress1, address _newAdminAddress2) public onlyAdmin {\r\n    if(msg.sender == COO)\r\n    {\r\n        CTO = _newAdminAddress1;\r\n        CFO = _newAdminAddress2;\r\n    }\r\n    if(msg.sender == CTO)\r\n    {\r\n        COO = _newAdminAddress1;\r\n        CFO = _newAdminAddress2;\r\n    }\r\n    if(msg.sender == CFO)\r\n    {\r\n        COO = _newAdminAddress1;\r\n        CTO = _newAdminAddress2;\r\n    }\r\n  }\r\n  \r\n  function transferContract(address _newCoreAddress, address _newLogicAddress, address _newSuperAddress) external onlyAdmin {\r\n    coreAddress  = _newCoreAddress;\r\n    logicAddress = _newLogicAddress;\r\n    superAddress = _newSuperAddress;\r\n    SetCoreInterface(_newLogicAddress).setCoreContract(_newCoreAddress);\r\n    SetCoreInterface(_newSuperAddress).setCoreContract(_newCoreAddress);\r\n  }\r\n\r\n\r\n}\r\n\r\ncontract ERC721 {\r\n    \r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n  function totalSupply() public view returns (uint256 total);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function takeOwnership(uint256 _tokenId) public;\r\n  \r\n}\r\n\r\ncontract SetCoreInterface {\r\n   function setCoreContract(address _neWCoreAddress) external; \r\n}\r\n\r\ncontract CaData is ADM312, ERC721 {\r\n    \r\n    function CaData() public {\r\n        COO = msg.sender;\r\n        CTO = msg.sender;\r\n        CFO = msg.sender;\r\n        createCustomAtom(0,0,4,0,0,0,0);\r\n    }\r\n    \r\n    function kill() external\r\n\t{\r\n\t    require(msg.sender == COO);\r\n\t\tselfdestruct(msg.sender);\r\n\t}\r\n    \r\n    function() public payable{}\r\n    \r\n    uint public randNonce  = 0;\r\n    \r\n    struct Atom \r\n    {\r\n      uint64   dna;\r\n      uint8    gen;\r\n      uint8    lev;\r\n      uint8    cool;\r\n      uint32   sons;\r\n      uint64   fath;\r\n\t  uint64   moth;\r\n\t  uint128  isRent;\r\n\t  uint128  isBuy;\r\n\t  uint32   isReady;\r\n    }\r\n    \r\n    Atom[] public atoms;\r\n    \r\n    mapping (uint64  => bool) public dnaExist;\r\n    mapping (address => bool) public bonusReceived;\r\n    mapping (address => uint) public ownerAtomsCount;\r\n    mapping (uint => address) public atomOwner;\r\n    \r\n    event NewWithdraw(address sender, uint balance);\r\n\r\n    \r\n    //ADMIN\r\n    \r\n    function createCustomAtom(uint64 _dna, uint8 _gen, uint8 _lev, uint8 _cool, uint128 _isRent, uint128 _isBuy, uint32 _isReady) public onlyAdmin {\r\n        require(dnaExist[_dna]==false && _cool+_lev>=4);\r\n        Atom memory newAtom = Atom(_dna, _gen, _lev, _cool, 0, 2**50, 2**50, _isRent, _isBuy, _isReady);\r\n        uint id = atoms.push(newAtom) - 1;\r\n        atomOwner[id] = msg.sender;\r\n        ownerAtomsCount[msg.sender]++;\r\n        dnaExist[_dna] = true;\r\n    }\r\n    \r\n    function withdrawBalance() public payable onlyAdmin {\r\n\t\tNewWithdraw(msg.sender, address(this).balance);\r\n        CFO.transfer(address(this).balance);\r\n    }\r\n    \r\n    //MAPPING_SETTERS\r\n    \r\n    function incRandNonce() external onlyContract {\r\n        randNonce++;\r\n    }\r\n    \r\n    function setDnaExist(uint64 _dna, bool _newDnaLocking) external onlyContractAdmin {\r\n        dnaExist[_dna] = _newDnaLocking;\r\n    }\r\n    \r\n    function setBonusReceived(address _add, bool _newBonusLocking) external onlyContractAdmin {\r\n        bonusReceived[_add] = _newBonusLocking;\r\n    }\r\n    \r\n    function setOwnerAtomsCount(address _owner, uint _newCount) external onlyContract {\r\n        ownerAtomsCount[_owner] = _newCount;\r\n    }\r\n    \r\n    function setAtomOwner(uint _atomId, address _owner) external onlyContract {\r\n        atomOwner[_atomId] = _owner;\r\n    }\r\n    \r\n    //ATOM_SETTERS\r\n    \r\n    function pushAtom(uint64 _dna, uint8 _gen, uint8 _lev, uint8 _cool, uint32 _sons, uint64 _fathId, uint64 _mothId, uint128 _isRent, uint128 _isBuy, uint32 _isReady) external onlyContract returns (uint id) {\r\n        Atom memory newAtom = Atom(_dna, _gen, _lev, _cool, _sons, _fathId, _mothId, _isRent, _isBuy, _isReady);\r\n        id = atoms.push(newAtom) -1;\r\n    }\r\n\t\r\n\tfunction setAtomDna(uint _atomId, uint64 _dna) external onlyAdmin {\r\n        atoms[_atomId].dna = _dna;\r\n    }\r\n\t\r\n\tfunction setAtomGen(uint _atomId, uint8 _gen) external onlyAdmin {\r\n        atoms[_atomId].gen = _gen;\r\n    }\r\n    \r\n    function setAtomLev(uint _atomId, uint8 _lev) external onlyContract {\r\n        atoms[_atomId].lev = _lev;\r\n    }\r\n    \r\n    function setAtomCool(uint _atomId, uint8 _cool) external onlyContract {\r\n        atoms[_atomId].cool = _cool;\r\n    }\r\n    \r\n    function setAtomSons(uint _atomId, uint32 _sons) external onlyContract {\r\n        atoms[_atomId].sons = _sons;\r\n    }\r\n    \r\n    function setAtomFath(uint _atomId, uint64 _fath) external onlyContract {\r\n        atoms[_atomId].fath = _fath;\r\n    }\r\n    \r\n    function setAtomMoth(uint _atomId, uint64 _moth) external onlyContract {\r\n        atoms[_atomId].moth = _moth;\r\n    }\r\n    \r\n    function setAtomIsRent(uint _atomId, uint128 _isRent) external onlyContract {\r\n        atoms[_atomId].isRent = _isRent;\r\n    }\r\n    \r\n    function setAtomIsBuy(uint _atomId, uint128 _isBuy) external onlyContract {\r\n        atoms[_atomId].isBuy = _isBuy;\r\n    }\r\n    \r\n    function setAtomIsReady(uint _atomId, uint32 _isReady) external onlyContractAdmin {\r\n        atoms[_atomId].isReady = _isReady;\r\n    }\r\n    \r\n    //ERC721\r\n    \r\n    mapping (uint => address) tokenApprovals;\r\n    \r\n    function totalSupply() public view returns (uint256 total){\r\n  \t    return atoms.length;\r\n  \t}\r\n  \t\r\n  \tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return ownerAtomsCount[_owner];\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) public view returns (address owner) {\r\n        return atomOwner[_tokenId];\r\n    }\r\n      \r\n    function _transfer(address _from, address _to, uint256 _tokenId) private {\r\n        atoms[_tokenId].isBuy  = 0;\r\n        atoms[_tokenId].isRent = 0;\r\n        ownerAtomsCount[_to]++;\r\n        ownerAtomsCount[_from]--;\r\n        atomOwner[_tokenId] = _to;\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n  \r\n    function transfer(address _to, uint256 _tokenId) public {\r\n        require(msg.sender == atomOwner[_tokenId]);\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n    \r\n    function approve(address _to, uint256 _tokenId) public {\r\n        require(msg.sender == atomOwner[_tokenId]);\r\n        tokenApprovals[_tokenId] = _to;\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n    \r\n    function takeOwnership(uint256 _tokenId) public {\r\n        require(tokenApprovals[_tokenId] == msg.sender);\r\n        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n    }\r\n    \r\n}\r\n\r\ncontract CaTokenInterface {\r\n    function emitTransfer(address, address, uint) external;\r\n}\r\n\r\ncontract CryptoAtomsCore {\r\n    \r\n    address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5;\r\n    CaData public CaDataContract = CaData(CaDataAddress);\r\n    \r\n    CaTokenInterface public CaTokenContract = CaTokenInterface(0xbdaed67214641b7eda3bf8d7431c3ae5fc46f466);\r\n    \r\n    uint64    dnaModulus = 2 ** 50;\r\n    uint16    nucModulus = 2 ** 12;\r\n    uint32    colModulus = 10 ** 8; //=> (16-8) = 8 inherited digits (7 are significant)\r\n                                \r\n    uint32[8] public cooldownValues = [uint32(5 minutes), \r\n                                       uint32(30 minutes), \r\n                                       uint32(2 hours), \r\n                                       uint32(6 hours), \r\n                                       uint32(12 hours), \r\n                                       uint32(24 hours), \r\n                                       uint32(36 hours), \r\n                                       uint32(48 hours)];\r\n                                       \r\n    uint128[4] public mintedAtomFee = [50 finney, 100 finney, 200 finney, 500 finney];\r\n\r\n    event NewMintedAtom(address sender, uint atom);                         \r\n    \r\n    function kill() external\r\n\t{\r\n\t    require(msg.sender == CaDataContract.CTO());\r\n\t\tselfdestruct(msg.sender); \r\n\t}\r\n    \r\n    modifier onlyLogic() {\r\n      require(msg.sender == CaDataContract.logicAddress());\r\n      _;\r\n    }\r\n    \r\n     modifier onlyAdmin() {\r\n      require(msg.sender == CaDataContract.COO() || msg.sender == CaDataContract.CTO() || msg.sender == CaDataContract.CFO());\r\n      _;\r\n    }\r\n     \r\n    function setFee(uint128 _newFee, uint8 _level) external onlyAdmin {\r\n        require(_level > 0 && _level < 5);\r\n        mintedAtomFee[_level-1] = _newFee;\r\n    }\r\n     \r\n    function setCooldown(uint32[8] _newCooldown) external onlyAdmin {\r\n        cooldownValues = _newCooldown;\r\n    }\r\n\r\n    function setTokenAddr(address _newTokenAddr) external onlyAdmin {\r\n        CaTokenContract = CaTokenInterface(_newTokenAddr);\r\n    }\r\n    \r\n    function emitTransferBatch(address[200] _fromArray, address[200] _toArray, uint256[200] _tokenIdArray, uint8 _eventsNum) external onlyAdmin {\r\n        require(_eventsNum <= 200);\r\n        for(uint8 tx=0; tx<_eventsNum; tx++)\r\n        {\r\n            CaTokenContract.emitTransfer(_fromArray[tx], _toArray[tx], _tokenIdArray[tx]);\r\n        }\r\n    }\r\n    \r\n    function _defineDna(uint64 _dna1, uint64 _dna2) private returns (uint64 definedDna) {\r\n        uint16 binModulus = nucModulus;\r\n        uint64 decModulus = colModulus;\r\n        uint64 nucDna;\r\n        uint64 colDna;\r\n        uint64 random;\r\n        for (uint8 attemp=16; attemp>0; attemp--)\r\n        {\r\n            CaDataContract.incRandNonce();\r\n            random = uint64(keccak256(now, tx.origin, CaDataContract.randNonce()));\r\n            if (random%2 == 0)\r\n            {\r\n                nucDna = _dna1;\r\n                colDna = _dna2;\r\n            }\r\n            else\r\n            {\r\n                nucDna = _dna2;\r\n                colDna = _dna1;\r\n            }\r\n            definedDna = ((colDna/decModulus)*decModulus) + (random % decModulus);\r\n            definedDna = definedDna - (definedDna % binModulus) + (nucDna % binModulus);\r\n            definedDna = definedDna % dnaModulus;\r\n            if(CaDataContract.dnaExist(definedDna)==true)\r\n            {\r\n                if(attemp > 8)\r\n                {\r\n                    decModulus = decModulus*10;//if attemp=16,15,14,13,12,11,10,9 -> 1 inherited digit removed\r\n                }\r\n                else\r\n                {\r\n                    binModulus = binModulus/2;//if attemp=8,7,6,5,4,3,2,1 -> 1 inherited digit removed\r\n                }\r\n                definedDna = 0;\r\n            }\r\n            else\r\n            {\r\n                attemp = 1;//forced end\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _defineGen(uint8 _gen1, uint8 _lev1, uint8 _gen2, uint8 _lev2) private pure returns (uint8 definedGen) {\r\n        if(_gen1 == _gen2)\r\n        {\r\n            definedGen = _gen1;\r\n            if(_lev1+_lev2 > 6)\r\n            {\r\n                definedGen++;\r\n            }\r\n        }\r\n        if(_gen1 < _gen2)\r\n        {\r\n            definedGen = _gen1;\r\n            if(_lev1 > 2)\r\n            {\r\n                definedGen++;\r\n            }\r\n        }\r\n        if(_gen1 > _gen2)\r\n        {\r\n            definedGen = _gen2;\r\n            if(_lev2 > 2)\r\n            {\r\n                definedGen++;\r\n            }\r\n        }\r\n        if(definedGen > 4)\r\n        {\r\n        \tdefinedGen = 4;\r\n        }\r\n    }\r\n    \r\n    function _beParents(uint _atomId1, uint _atomId2) private {\r\n        uint8 cool1;\r\n        uint8 cool2;\r\n        uint32 sons1;\r\n        uint32 sons2;\r\n        (,,,cool1,sons1,,,,,) = CaDataContract.atoms(_atomId1);\r\n        (,,,cool2,sons2,,,,,) = CaDataContract.atoms(_atomId2);\r\n        CaDataContract.setAtomIsReady(_atomId1, uint32(now + cooldownValues[cool1]));\r\n        CaDataContract.setAtomIsReady(_atomId2, uint32(now + cooldownValues[cool2]));\r\n        CaDataContract.setAtomSons(_atomId1, sons1+1);\r\n        CaDataContract.setAtomSons(_atomId2, sons2+1);\r\n        CaDataContract.setAtomIsRent(_atomId1,0);\r\n        CaDataContract.setAtomIsRent(_atomId2,0);\r\n    }\r\n    \r\n    function _createAtom(uint64 _dna, uint8 _gen, uint8 _lev, uint8 _cool, uint _fathId, uint _mothId) private returns (uint id) {\r\n        require(CaDataContract.totalSupply()<3000);\r\n        require(CaDataContract.dnaExist(_dna)==false);\r\n        id = CaDataContract.pushAtom(_dna, _gen, _lev, _cool, 0, uint64(_fathId), uint64(_mothId), 0, 0, 0);\r\n        CaDataContract.setAtomOwner(id,tx.origin);\r\n        CaDataContract.setOwnerAtomsCount(tx.origin,CaDataContract.ownerAtomsCount(tx.origin)+1);\r\n        CaDataContract.setDnaExist(_dna,true);\r\n        CaTokenContract.emitTransfer(0x0,tx.origin,id);\r\n    }\r\n\r\n    function createCombinedAtom(uint _atomId1, uint _atomId2) external onlyLogic returns (uint id) {\r\n        uint64 dna1;\r\n        uint64 dna2;\r\n        uint8 gen1;\r\n        uint8 gen2;\r\n        uint8 lev1;\r\n        uint8 lev2;\r\n        (dna1,gen1,lev1,,,,,,,) = CaDataContract.atoms(_atomId1);\r\n        (dna2,gen2,lev2,,,,,,,) = CaDataContract.atoms(_atomId2);\r\n        uint8  combGen  = _defineGen(gen1,lev1,gen2,lev2);\r\n        uint64 combDna  = _defineDna(dna1, dna2);\r\n        _beParents(_atomId1, _atomId2);\r\n        id = _createAtom(combDna, combGen, 1, combGen+3, _atomId1, _atomId2);\r\n    }\r\n    \r\n    function createRandomAtom() external onlyLogic returns (uint id) {\r\n        CaDataContract.incRandNonce();\r\n        uint64 randDna = uint64(keccak256(now, tx.origin, CaDataContract.randNonce())) % dnaModulus;\r\n        while(CaDataContract.dnaExist(randDna)==true)\r\n        {\r\n            CaDataContract.incRandNonce();\r\n            randDna = uint64(keccak256(now, tx.origin, CaDataContract.randNonce())) % dnaModulus;\r\n        }\r\n        id = _createAtom(randDna, 1, 1, 4, dnaModulus, dnaModulus);\r\n    }\r\n    \r\n    function createTransferAtom(address _from, address _to, uint _tokenId) external onlyLogic {\r\n        CaTokenContract.emitTransfer(_from, _to, _tokenId);\r\n    }\r\n\t\r\n    function shapeAtom(uint _atomId, uint8 _level) external payable {\r\n  \t    require(_level > 0 && _level < 5 && CaDataContract.atomOwner(_atomId) == msg.sender && mintedAtomFee[_level-1]/2 == msg.value);\r\n  \t    CaDataAddress.transfer(msg.value);\r\n        CaDataContract.setAtomLev(_atomId, _level);\r\n    }\r\n    \r\n    function mintAtom(uint8 _level) external payable {\r\n  \t    require(_level > 0 && _level < 5 && mintedAtomFee[_level-1] == msg.value);\r\n\t\tCaDataAddress.transfer(msg.value);\r\n        CaDataContract.incRandNonce();\r\n        uint64 randDna = uint64(keccak256(now, tx.origin, CaDataContract.randNonce())) % dnaModulus;\r\n        while(CaDataContract.dnaExist(randDna)==true)\r\n        {\r\n            CaDataContract.incRandNonce();\r\n            randDna = uint64(keccak256(now, tx.origin, CaDataContract.randNonce())) % dnaModulus;\r\n        }\r\n        uint id = _createAtom(randDna, 1, _level, 4-_level, dnaModulus, dnaModulus);\r\n        NewMintedAtom(tx.origin, id);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"createTransferAtom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenAddr\",\"type\":\"address\"}],\"name\":\"setTokenAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CaTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CaDataContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CaDataAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintedAtomFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCooldown\",\"type\":\"uint32[8]\"}],\"name\":\"setCooldown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_atomId1\",\"type\":\"uint256\"},{\"name\":\"_atomId2\",\"type\":\"uint256\"}],\"name\":\"createCombinedAtom\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createRandomAtom\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_atomId\",\"type\":\"uint256\"},{\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"shapeAtom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint128\"},{\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cooldownValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromArray\",\"type\":\"address[200]\"},{\"name\":\"_toArray\",\"type\":\"address[200]\"},{\"name\":\"_tokenIdArray\",\"type\":\"uint256[200]\"},{\"name\":\"_eventsNum\",\"type\":\"uint8\"}],\"name\":\"emitTransferBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"mintAtom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"atom\",\"type\":\"uint256\"}],\"name\":\"NewMintedAtom\",\"type\":\"event\"}]","ContractName":"CryptoAtomsCore","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://93dab0c7b9937d33428216878d89d35c899f9b638445626deca0e3b496a293f7"}]}