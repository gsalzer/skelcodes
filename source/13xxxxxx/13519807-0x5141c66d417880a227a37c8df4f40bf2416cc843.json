{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/MemeNumbersRenderer.sol\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 >=0.8.0 <0.9.0;\n\n////// lib/base64/base64.sol\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n        \n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n            \n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n            \n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            \n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n            \n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               dataPtr := add(dataPtr, 3)\n               \n               // read 3 bytes\n               let input := mload(dataPtr)\n               \n               // write 4 characters\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\n               resultPtr := add(resultPtr, 1)\n            }\n            \n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n        \n        return result;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Strings.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n////// src/MemeNumbersRenderer.sol\n/* pragma solidity >=0.8.4; */\n\n/* import '@openzeppelin/contracts/utils/Strings.sol'; */\n\n/* import \"base64/base64.sol\"; */\n\ninterface IMemeNumbers{\n}\n\ninterface ITokenRenderer {\n    function tokenURI(IMemeNumbers instance, uint256 tokenId) external view returns (string memory);\n}\n\ncontract MemeNumbersRenderer is ITokenRenderer {\n  using Strings for uint;\n\n  function renderNFTImage(IMemeNumbers instance, uint256 tokenId) public view returns (string memory) {\n    return Base64.encode(bytes(abi.encodePacked(\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMidyMid meet\" viewBox=\"0 0 400 400\" style=\"background:black\">',\n        '<text x=\"200\" y=\"200\" style=\"text-anchor:middle;dominant-baseline:middle;fill:white;font-size:24px;\">',\n          tokenId.toString(),\n        '</text>',\n      '</svg>')));\n  }\n\n  function _generateAttributes(uint256 tokenId) internal pure returns (string memory) {\n    string memory parity = \"Odd\";\n    if (tokenId % 2 == 0) {\n      parity = \"Even\";\n    }\n\n    uint256 i = tokenId;\n    uint256 digits = 0;\n    while (i != 0) {\n      digits++;\n      i /= 10;\n    }\n\n    return string(abi.encodePacked(\n      '[',\n         '{',\n            '\"trait_type\": \"Digits\",',\n            '\"value\": ', digits.toString(),\n          '},',\n          '{',\n              '\"trait_type\": \"Parity\",',\n              '\"value\": ','\"',parity,'\"'\n          '}',\n      ']'\n    ));\n  }\n\n  function tokenURI(IMemeNumbers instance, uint256 tokenId) public view override(ITokenRenderer) returns (string memory) {\n    return string(\n      abi.encodePacked(\n        'data:application/json;base64,',\n        Base64.encode(bytes(abi.encodePacked(\n              '{\"name\":\"', tokenId.toString(), '\"',\n              ',\"description\":\"What is your meme number?\"', // FIXME: Write something better\n              ',\"external_url\":\"https://memenumbers.com\"',\n              ',\"image\":\"data:image/svg+xml;base64,', renderNFTImage(instance, tokenId), '\"',\n              ',\"attributes\":', _generateAttributes(tokenId),\n              '}'\n        )))\n      )\n    );\n  }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"contract IMemeNumbers\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"renderNFTImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMemeNumbers\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MemeNumbersRenderer","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}