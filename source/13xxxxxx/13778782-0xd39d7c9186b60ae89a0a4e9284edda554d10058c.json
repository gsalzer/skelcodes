{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Raffle.ts\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\n//This contract allows the recovered 33 rare Timeless NFTs to be claimed by \\n//a series of addresses that interacted with the NFTSale contract within\\n//5 minutes of the sale becoming active.\\n//The raffle and assigning tokenIds to winning addresses is performed offchain\\n//The raffle algorithm can be verified here: https://treeverse.mypinata.cloud/ipfs/QmWMUb9P5VpQbWZj2GqTjHLFNLFkYJcbX85RAsqBx4YJkm \\n\\npragma solidity 0.8.10;\\n\\ninterface IERC721 {\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\\ncontract timelessRaffle  {\\n\\n    address public owner;\\n    address public timelessAddr;\\n    address public addressHoldingNFTs;\\n\\n    mapping(uint256 => address) public tokenIdToAddress;\\n    mapping(uint256 => bool) claimed;\\n    uint256 public leftUnclaimed;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        timelessAddr = 0x704bf12276f5c4Bc9349d0e119027eAD839b081b;  \\n        addressHoldingNFTs = 0x229c487eaF50369e1ADA49893A1ECdDD4d513114; \\n        leftUnclaimed = 33;\\n    }\\n\\n    function updateTokenIdToAddress(address[] calldata winningAddresses, uint256[] calldata timelessIds) external {\\n        require(msg.sender == owner, \\\"only owner can pull this off\\\");\\n        require(winningAddresses.length == timelessIds.length, \\\"Two arrays must be of same length\\\");\\n\\n        for (uint256 i; i < winningAddresses.length; i++) {\\n            tokenIdToAddress[timelessIds[i]] = winningAddresses[i];\\n        }\\n    }\\n\\n    function changeAddressHoldingNFTs(address _newAddress) external {\\n         require(msg.sender == owner, \\\"only owner can pull this off\\\");\\n         addressHoldingNFTs = _newAddress;\\n    }\\n\\n    //@dev Prior approval by the \\\"addressHoldingNFTs\\\" of this deployed contract\\n    // to the Timeless contract is required for all IDs that should be allowed to be exchanged\\n\\n    function exchangeTimeless(uint256 tokenId) external payable {\\n        require(tokenIdToAddress[tokenId] == msg.sender, \\\"You are not allowed to buy one!\\\");\\n        require(claimed[tokenId] == false, \\\"TokenID already claimed!\\\");\\n        require(msg.value == 0.222 ether, \\\"Please send exactly 0.222 ETH\\\");\\n\\n        IERC721(timelessAddr).safeTransferFrom(addressHoldingNFTs, msg.sender, tokenId);\\n\\n        claimed[tokenId] = true;\\n        leftUnclaimed--;\\n    }\\n\\n    function isClaimed(uint256 _tokenId) public view returns (bool) {\\n        return claimed[_tokenId];\\n    }\\n\\n    function getTokenIdForAddress(address addrToCheck, uint256[] calldata tokenIdsUpForclaim) public view returns (uint256) {\\n        for (uint256 i; i < tokenIdsUpForclaim.length; i++) {\\n            if (tokenIdToAddress[tokenIdsUpForclaim[i]] == addrToCheck && !isClaimed(tokenIdsUpForclaim[i])) {\\n                return tokenIdsUpForclaim[i];\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n   \\n    function withdrawNativeToken(uint256 amount) external payable {\\n        require(msg.sender == owner, \\\"only owner can pull this off\\\");\\n\\n        if (amount > 0) {\\n            payable(owner).transfer(amount);\\n        }\\n        else if (amount <= 0) {\\n            payable(owner).transfer(address(this).balance);\\n        }\\n    } \\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"addressHoldingNFTs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeAddressHoldingNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exchangeTimeless\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addrToCheck\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIdsUpForclaim\",\"type\":\"uint256[]\"}],\"name\":\"getTokenIdForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leftUnclaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelessAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"winningAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"timelessIds\",\"type\":\"uint256[]\"}],\"name\":\"updateTokenIdToAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawNativeToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"timelessRaffle","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}