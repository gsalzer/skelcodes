{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\npragma abicoder v2;\r\n\r\n\r\ncontract IndexedRebalanceLens {\r\n  using DynamicArrays for address[];\r\n\r\n  enum IndexVersion { NONE, CORE, SIGMA }\r\n  enum RebalanceType { REWEIGH, REINDEX }\r\n  enum Troolean { UNKNOWN, TRUE, FALSE }\r\n\r\n  struct IndexInfo {\r\n    IPool pool;\r\n    IndexVersion version;\r\n    RebalanceType next;\r\n  }\r\n\r\n  struct RebalanceRequirements {\r\n    bool delayOK;\r\n    bool twapOK;\r\n    bool sortOK;\r\n    Troolean tokenCountOK;\r\n    Troolean strategyOK;\r\n  }\r\n\r\n  uint256 internal constant MAX_SORT_DELAY = 1 days;\r\n  uint256 internal constant POOL_REWEIGH_DELAY = 1 weeks;\r\n\r\n  uint32 internal constant SHORT_MIN = 20 minutes;\r\n  uint32 internal constant SHORT_MAX = 2 days;\r\n\r\n  uint32 internal constant LONG_MIN = 1 days;\r\n  uint32 internal constant LONG_MAX = 1.5 weeks;\r\n\r\n  ICoreController public constant CORE_CONTROLLER = ICoreController(0xF00A38376C8668fC1f3Cd3dAeef42E0E44A7Fcdb);\r\n  ISigmaController public constant SIGMA_CONTROLLER = ISigmaController(0x5B470A8C134D397466A1a603678DadDa678CBC29);\r\n  IOracle public constant ORACLE = IOracle(0xFa5a44D3Ba93D666Bf29C8804a36e725ecAc659A);\r\n\r\n  function init(IndexInfo memory info) internal view {\r\n    address controller = info.pool.getController();\r\n    info.version =\r\n      controller == address(CORE_CONTROLLER)\r\n        ? IndexVersion.CORE\r\n        : controller == address(SIGMA_CONTROLLER)\r\n          ? IndexVersion.SIGMA\r\n          : IndexVersion.NONE;\r\n  }\r\n\r\n  function timeSince(uint256 ts) internal view returns (uint256) {\r\n    return block.timestamp - ts;\r\n  }\r\n\r\n  function checkUpdateNeeded(address token, uint256 min, uint256 max) public view returns (bool needsUpdate) {\r\n    try ORACLE.computeAverageEthPrice(token, min, max) returns (IOracle.uq112x112 memory) {\r\n      return false;\r\n    } catch {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function checkUpdateNeeded(\r\n    address[] memory tokens,\r\n    uint256 min,\r\n    uint256 max\r\n  ) public view returns (address[] memory needUpdate) {\r\n    uint256 len = tokens.length;\r\n    needUpdate = DynamicArrays.dynamicAddressArray(len + 1);\r\n    for (uint256 i; i < len; i++) {\r\n      address token = tokens[i];\r\n      if (checkUpdateNeeded(token, min, max)) {\r\n        needUpdate.dynamicPush(token);\r\n      }\r\n    }\r\n  }\r\n\r\n  function checkCurrentTokens(\r\n    IPool pool,\r\n    uint256 minTimeElapsed,\r\n    uint256 maxTimeElapsed\r\n  ) internal view returns (address[] memory tokensNeedingUpdate) {\r\n    tokensNeedingUpdate = checkUpdateNeeded(\r\n      pool.getCurrentTokens(),\r\n      minTimeElapsed,\r\n      maxTimeElapsed\r\n    );\r\n  }\r\n\r\n  function getPoolStatus(address pool) external view returns (\r\n    IndexInfo memory info,\r\n    RebalanceRequirements memory reqs,\r\n    address[] memory tokensNeedingUpdate\r\n  ) {\r\n    info.pool = IPool(pool);\r\n    init(info);\r\n    require(info.version != IndexVersion.NONE, \"Invalid pool\");\r\n    if (info.version == IndexVersion.CORE) {\r\n      (reqs, tokensNeedingUpdate) = checkCorePool(info);\r\n    } else {\r\n      (reqs, tokensNeedingUpdate) = checkSigmaPool(info);\r\n    }\r\n  }\r\n\r\n  function troolify(bool b) internal pure returns (Troolean) {\r\n    return b ? Troolean.TRUE : Troolean.FALSE;\r\n  }\r\n\r\n  function checkCorePool(IndexInfo memory info)\r\n    internal\r\n    view\r\n    returns (RebalanceRequirements memory reqs, address[] memory tokensNeedingUpdate)\r\n  {\r\n    ICoreController.IndexPoolMeta memory meta = CORE_CONTROLLER.getPoolMeta(address(info.pool));\r\n    info.next = meta.reweighIndex % 4 == 3 ? RebalanceType.REINDEX : RebalanceType.REWEIGH;\r\n    reqs.delayOK = timeSince(meta.lastReweigh) >= POOL_REWEIGH_DELAY;\r\n    reqs.strategyOK = Troolean.TRUE;\r\n    if (info.next == RebalanceType.REWEIGH) {\r\n      tokensNeedingUpdate = checkCurrentTokens(info.pool, LONG_MIN, LONG_MAX);\r\n      reqs.tokenCountOK = Troolean.TRUE;\r\n    } else {\r\n      address[] memory categoryTokens = CORE_CONTROLLER.getCategoryTokens(meta.categoryID);\r\n      tokensNeedingUpdate = checkUpdateNeeded(\r\n        categoryTokens,\r\n        LONG_MIN,\r\n        LONG_MAX\r\n      );\r\n      reqs.sortOK = timeSince(CORE_CONTROLLER.getLastCategoryUpdate(meta.categoryID)) <= MAX_SORT_DELAY;\r\n      reqs.tokenCountOK = troolify(categoryTokens.length >= meta.indexSize);\r\n      (address eToken,) = info.pool.extrapolatePoolValueFromToken();\r\n      if (!tokensNeedingUpdate.includes(eToken)) {\r\n        if (checkUpdateNeeded(eToken, SHORT_MIN, SHORT_MAX)) {\r\n          tokensNeedingUpdate.dynamicPush(eToken);\r\n        }\r\n      }\r\n    }\r\n    reqs.twapOK = tokensNeedingUpdate.length == 0;\r\n  }\r\n\r\n  function tryGetScores(\r\n    address strategy,\r\n    address[] memory tokens\r\n  ) internal view returns (uint256[] memory scores) {\r\n    try IScoringStrategy(strategy).getTokenScores(tokens) returns (uint256[] memory _scores) {\r\n      scores = _scores;\r\n    } catch {}\r\n  }\r\n\r\n  // Used to reduce stack overhead\r\n  struct SigmaMeta {\r\n    uint16 listID;\r\n    uint8 indexSize;\r\n    uint8 reweighIndex;\r\n    uint64 lastReweigh;\r\n    address strategy;\r\n    uint256 minScore;\r\n    uint256 maxScore;\r\n  }\r\n\r\n  function getSigmaMeta(address pool) internal view returns (SigmaMeta memory meta) {\r\n    ISigmaController.IndexPoolMeta memory _meta = SIGMA_CONTROLLER.indexPoolMetadata(pool);\r\n    meta.listID = _meta.listID;\r\n    meta.indexSize = _meta.indexSize;\r\n    meta.reweighIndex = _meta.reweighIndex;\r\n    meta.lastReweigh = _meta.lastReweigh;\r\n    (meta.strategy, meta.minScore, meta.maxScore) = SIGMA_CONTROLLER.getTokenListConfig(_meta.listID);\r\n  }\r\n\r\n  function checkSigmaScores(SigmaMeta memory meta) internal view returns (Troolean strategyOK, Troolean tokenCountOK) {\r\n    address[] memory categoryTokens = SIGMA_CONTROLLER.getTokenList(meta.listID);\r\n    uint256[] memory scores = tryGetScores(meta.strategy, categoryTokens);\r\n    strategyOK = troolify(scores.length > 0);\r\n    if (strategyOK == Troolean.FALSE) {\r\n      tokenCountOK = Troolean.UNKNOWN;\r\n    } else {\r\n      uint256 numValid;\r\n      for (uint256 i; i < scores.length; i++) {\r\n        uint256 score = scores[i];\r\n        if (score >= meta.minScore && score <= meta.maxScore) {\r\n          numValid++;\r\n        }\r\n      }\r\n      tokenCountOK = troolify(numValid >= meta.indexSize);\r\n    }\r\n  }\r\n\r\n  function checkSigmaPool(IndexInfo memory info)\r\n    internal\r\n    view\r\n    returns (RebalanceRequirements memory reqs, address[] memory tokensNeedingUpdate)\r\n  {\r\n    reqs.sortOK = true;\r\n    SigmaMeta memory meta = getSigmaMeta(address(info.pool));\r\n    info.next = meta.reweighIndex % 4 == 3 ? RebalanceType.REINDEX : RebalanceType.REWEIGH;\r\n    reqs.delayOK = timeSince(meta.lastReweigh) >= POOL_REWEIGH_DELAY;\r\n    if (info.next == RebalanceType.REWEIGH) {\r\n      reqs.tokenCountOK = Troolean.TRUE;\r\n      address[] memory poolTokens = info.pool.getCurrentTokens();\r\n      tokensNeedingUpdate = checkUpdateNeeded(poolTokens, SHORT_MIN, SHORT_MAX);\r\n      if (tokensNeedingUpdate.length == 0) {\r\n        uint256[] memory scores = tryGetScores(meta.strategy, poolTokens);\r\n        reqs.strategyOK = troolify(scores.length > 0);\r\n      } else {\r\n        reqs.strategyOK = Troolean.UNKNOWN;\r\n      }\r\n    } else {\r\n      address[] memory categoryTokens = SIGMA_CONTROLLER.getTokenList(meta.listID);\r\n      tokensNeedingUpdate = checkUpdateNeeded(\r\n        categoryTokens,\r\n        LONG_MIN,\r\n        LONG_MAX\r\n      );\r\n      (address eToken,) = info.pool.extrapolatePoolValueFromToken();\r\n      if (!tokensNeedingUpdate.includes(eToken)) {\r\n        if (checkUpdateNeeded(eToken, SHORT_MIN, SHORT_MAX)) {\r\n          tokensNeedingUpdate.dynamicPush(eToken);\r\n        }\r\n      }\r\n      // If prices are ready, check if scores can be queried.\r\n      // If scores can be queried, tokenCountOK = # of scores between min/max scores >= meta.indexSize.\r\n      // If scores can not be queried, strategyOK = false\r\n      // If prices are not ready, strategyOK and tokenCountOK both UNKNOWN\r\n      if (tokensNeedingUpdate.length == 0) {\r\n        (reqs.strategyOK, reqs.tokenCountOK) = checkSigmaScores(meta);\r\n      } else {\r\n        reqs.strategyOK = Troolean.UNKNOWN;\r\n        reqs.tokenCountOK = Troolean.UNKNOWN;\r\n      }\r\n    }\r\n    reqs.twapOK = tokensNeedingUpdate.length == 0;\r\n  }\r\n}\r\n\r\n\r\ninterface IScoringStrategy {\r\n  function getTokenScores(address[] calldata tokens) external view returns (uint256[] memory scores);\r\n}\r\n\r\n\r\ninterface IOracle {\r\n  struct uq112x112 { uint224 _x; }\r\n\r\n  function computeAverageEthPrice(\r\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\r\n  ) external view returns (uq112x112 memory);\r\n}\r\n\r\n\r\ninterface IPool {\r\n  function getController() external view returns (address);\r\n\r\n  function getCurrentTokens() external view returns (address[] memory tokens);\r\n\r\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\r\n}\r\n\r\n\r\ninterface ISigmaController {\r\n  struct IndexPoolMeta {\r\n    bool initialized;\r\n    uint16 listID;\r\n    uint8 indexSize;\r\n    uint8 reweighIndex;\r\n    uint64 lastReweigh;\r\n  }\r\n\r\n  function indexPoolMetadata(address) external view returns (IndexPoolMeta memory);\r\n\r\n  function getTokenList(uint256 listID) external view returns (address[] memory tokens);\r\n\r\n  function getTokenListConfig(uint256 listID)\r\n    external\r\n    view\r\n    returns (\r\n      address scoringStrategy,\r\n      uint128 minimumScore,\r\n      uint128 maximumScore\r\n    );\r\n}\r\n\r\ninterface ICoreController {\r\n  struct IndexPoolMeta {\r\n    bool initialized;\r\n    uint16 categoryID;\r\n    uint8 indexSize;\r\n    uint8 reweighIndex;\r\n    uint64 lastReweigh;\r\n  }\r\n  function getPoolMeta(address poolAddress) external view returns (IndexPoolMeta memory meta);\r\n\r\n  function getLastCategoryUpdate(uint256 categoryID) external view returns (uint256);\r\n\r\n  function getCategoryTokens(uint256 categoryID) external view returns (address[] memory tokens);\r\n}\r\n\r\n\r\nlibrary DynamicArrays {\r\n  /**\r\n   * @dev Reserves space in memory for an array of length `size`, but sets the length to 0.\r\n   * This can be safely used for a dynamic array so long as the maximum possible size is\r\n   * known beforehand. If the array can exceed `size`, pushing to it will corrupt memory.\r\n   */\r\n  function dynamicAddressArray(uint256 size) internal pure returns (address[] memory arr) {\r\n    arr = new address[](size);\r\n    assembly { mstore(arr, 0) }\r\n  }\r\n\r\n  /**\r\n   * @dev Reserves space in memory for an array of length `size`, but sets the length to 0.\r\n   * This can be safely used for a dynamic array so long as the maximum possible size is\r\n   * known beforehand. If the array can exceed length `size`, pushing to it will corrupt memory.\r\n   */\r\n  function dynamicUint256Array(uint256 size) internal pure returns (uint256[] memory arr) {\r\n    arr = new uint256[](size);\r\n    assembly { mstore(arr, 0) }\r\n  }\r\n\r\n  /**\r\n   * @dev Pushes an address to an in-memory array by reassigning the array length and storing\r\n   * the element in the position used by solidity for the current array index.\r\n   * Note: This should ONLY be used on an array created with `dynamicAddressArray`. Using it\r\n   * on a typical array created with `new address[]()` will almost certainly have unintended\r\n   * and unpredictable side effects.\r\n   */\r\n  function dynamicPush(address[] memory arr, address element) internal pure {\r\n    assembly {\r\n      let size := mload(arr)\r\n      let ptr := add(\r\n        add(arr, 32),\r\n        mul(size, 32)\r\n      )\r\n      mstore(ptr, element)\r\n      mstore(arr, add(size, 1))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Pushes a uint256 to an in-memory array by reassigning the array length and storing\r\n   * the element in the position used by solidity for the current array index.\r\n   * Note: This should ONLY be used on an array created with `dynamicUint256Array`. Using it\r\n   * on a typical array created with `new uint256[]()` will almost certainly have unintended\r\n   * and unpredictable side effects.\r\n   */\r\n  function dynamicPush(uint256[] memory arr, uint256 element) internal pure {\r\n    assembly {\r\n      let size := mload(arr)\r\n      let ptr := add(\r\n        add(arr, 32),\r\n        mul(size, 32)\r\n      )\r\n      mstore(ptr, element)\r\n      mstore(arr, add(size, 1))\r\n    }\r\n  }\r\n\r\n  function includes(address[] memory arr, address find) internal pure returns (bool) {\r\n    uint256 len = arr.length;\r\n    for (uint256 i; i < len; i++) if (arr[i] == find) return true;\r\n    return false;\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"CORE_CONTROLLER\",\"outputs\":[{\"internalType\":\"contract ICoreController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGMA_CONTROLLER\",\"outputs\":[{\"internalType\":\"contract ISigmaController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"checkUpdateNeeded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"needsUpdate\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"checkUpdateNeeded\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"needUpdate\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getPoolStatus\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"enum IndexedRebalanceLens.IndexVersion\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"enum IndexedRebalanceLens.RebalanceType\",\"name\":\"next\",\"type\":\"uint8\"}],\"internalType\":\"struct IndexedRebalanceLens.IndexInfo\",\"name\":\"info\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"delayOK\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"twapOK\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sortOK\",\"type\":\"bool\"},{\"internalType\":\"enum IndexedRebalanceLens.Troolean\",\"name\":\"tokenCountOK\",\"type\":\"uint8\"},{\"internalType\":\"enum IndexedRebalanceLens.Troolean\",\"name\":\"strategyOK\",\"type\":\"uint8\"}],\"internalType\":\"struct IndexedRebalanceLens.RebalanceRequirements\",\"name\":\"reqs\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"tokensNeedingUpdate\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IndexedRebalanceLens","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c4f9eca72922491614db1574b5ef2f595e10fdefd2bd46de7ae66d2803ae7e03"}]}