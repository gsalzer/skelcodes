{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Metalend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.9;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nimport {Sunsetable} from \\\"./Sunsetable.sol\\\";\\nimport {Constants} from \\\"./Constants.sol\\\";\\n\\ncontract Metalend is IERC721Receiver, Ownable, Pausable, Sunsetable {\\n  /** -----------------------------------------------------------------------------\\n   *   State variable definitions\\n   *   -----------------------------------------------------------------------------\\n   */\\n  // struct object that represents a single instance of a loan:\\n  struct LoanItem {\\n    // Storage packing - try and use the smallest number of slots!\\n    // (One slot is 32 bytes, or 256 bits, and you have to declare\\n    // these in order for the EVM to pack them together. . .)\\n    // Addresses are 20 bytes.\\n    // Slot 1, 256:\\n    uint128 loanId;\\n    uint128 currentBalance;\\n    // Slot 2, 248:\\n    bool isCurrent;\\n    address payable borrower;\\n    uint32 startDate;\\n    uint32 endDate;\\n    uint16 tokenId;\\n  }\\n\\n  // Slot 1 192 (160 + 16 + 16)\\n  // This designates the eligible NFT address, i.e. the address from which NFTs can\\n  // receive loans in exchange for custodied collateral (the NFT itself):\\n  // Contract implementation of ERC721\\n  IERC721 public tokenContract;\\n  // Term in days:\\n  uint16 public termInDays;\\n  // How close to the end date do we need to be to extend in days?\\n  uint16 public extensionHorizon;\\n\\n  // Slot 2 256 (128 + 64 + 64)\\n  // In this version the loan amount is a fixed amount:\\n  uint128 public loanAmount;\\n  // Each loan attracts a lending fee. The amount the borrower has to repay to redeem the\\n  // NFT is the loan amount plus the lending fee:\\n  uint64 public lendingFee;\\n  // A fee to extend the loan by another loan term:\\n  uint64 public extensionFee;\\n\\n  // Slot 3 - 160 (160)\\n  // Reposession address - this is the address that NFTs will be send to on the expiry\\n  // of the loan term.\\n  address public repoAddress;\\n\\n  // The array of items under loan:\\n  LoanItem[] public itemsUnderLoan;\\n\\n  /** -----------------------------------------------------------------------------\\n   *   Contract event definitions\\n   *   -----------------------------------------------------------------------------\\n   */\\n  // Events are broadcast and can be watched and tracked on chain:\\n  event lendingTransaction(\\n    uint128 indexed loanId,\\n    uint256 indexed transactionCode,\\n    address indexed borrower,\\n    uint16 tokenId,\\n    uint256 transactionValue,\\n    uint256 transactionFee,\\n    uint256 loanEndDate,\\n    uint256 effectiveDate\\n  );\\n  event eligibleNFTAddressSet(address indexed nftAddress);\\n  event repoAddressSet(address indexed repoAddress);\\n  event loanAmountSet(uint128 indexed loanAmount);\\n  event lendingFeeSet(uint64 indexed lendingFee);\\n  event extensionFeeSet(uint64 indexed extensionFee);\\n  event termInDaysSet(uint16 indexed termInDays);\\n  event extensionHorizonSet(uint16 indexed extensionHorizon);\\n  event ethWithdrawn(uint256 indexed withdrawal, uint256 effectiveDate);\\n  event ethDeposited(uint256 indexed deposit, uint256 effectiveDate);\\n\\n  constructor(\\n    address _tokenAddress,\\n    uint128 _loanAmount,\\n    uint16 _termInDays,\\n    address _repoAddress,\\n    uint64 _lendingFee,\\n    uint64 _extensionFee,\\n    uint16 _extensionHorizon\\n  ) {\\n    tokenContract = IERC721(_tokenAddress);\\n    loanAmount = _loanAmount;\\n    termInDays = _termInDays;\\n    repoAddress = _repoAddress;\\n    lendingFee = _lendingFee;\\n    extensionFee = _extensionFee;\\n    extensionHorizon = _extensionHorizon;\\n    pause();\\n  }\\n\\n  /** -----------------------------------------------------------------------------\\n   *   Modifier definitions\\n   *   -----------------------------------------------------------------------------\\n   */\\n\\n  // Check to see if the array item has the borrower as the calling address:\\n  modifier OnlyItemBorrower(uint128 _loanId) {\\n    require(\\n      itemsUnderLoan[_loanId].borrower == msg.sender,\\n      \\\"Payments can only be made by the borrower\\\"\\n    );\\n    _;\\n  }\\n\\n  // Check to see if the array item returned is no longer current:\\n  modifier IsUnderLoan(uint128 _loanId) {\\n    require(\\n      itemsUnderLoan[_loanId].isCurrent == true,\\n      \\\"Item is not currently under loan\\\"\\n    );\\n    _;\\n  }\\n\\n  // Check to see if loan can be extended:\\n  modifier LoanEligibleForExtension(uint128 _loanId) {\\n    require(\\n      extensionsAllowed() == true,\\n      \\\"Extensions currently not allowed\\\"\\n    );\\n    require(\\n      isWithinExtensionHorizon(_loanId) == true,\\n      \\\"Loan is not within extension horizon\\\"\\n    );\\n    _;\\n  }\\n\\n  // Check to see if loan is within term:\\n  modifier LoanWithinLoanTerm(uint128 _loanId) {\\n    require(\\n      isWithinLoanTerm(_loanId) == true,\\n      \\\"Loan term has expired\\\");\\n    _;\\n  }\\n\\n  /** -----------------------------------------------------------------------------\\n   *   Set routines - these routines allow the owner to set parameters on this contract:\\n   *   -----------------------------------------------------------------------------\\n   */\\n\\n  // Set the address that assets are transfered to on repossession:\\n  function setRepoAddress(address _repoAddress)\\n    external\\n    onlyOwner\\n    returns (bool)\\n  {\\n    repoAddress = _repoAddress;\\n    emit repoAddressSet(_repoAddress);\\n    return true;\\n  }\\n\\n  // Set the loan amount:\\n  function setLoanAmount(uint128 _loanAmount)\\n    external\\n    onlyOwner\\n    returns (bool)\\n  {\\n    require(_loanAmount != loanAmount, \\\"No change to loan amount\\\");\\n    if (_loanAmount > loanAmount) {\\n        require(\\n            (_loanAmount - loanAmount) <=\\n                Constants.LOAN_AMOUNT_MAX_INCREMENT,\\n            \\\"Change exceeds max increment\\\"\\n        );\\n    } else {\\n        require(\\n            (loanAmount - _loanAmount) <=\\n                Constants.LOAN_AMOUNT_MAX_INCREMENT,\\n            \\\"Change exceeds max increment\\\"\\n        );\\n    }\\n    loanAmount = _loanAmount;\\n    emit loanAmountSet(_loanAmount);\\n    return true;\\n  }\\n\\n  // Set the lending fee:\\n  function setLendingFee(uint64 _lendingFee) external onlyOwner returns (bool) {\\n    require(_lendingFee != lendingFee, \\\"No change to lending fee\\\");\\n    if (_lendingFee > lendingFee) {\\n      require(\\n        (_lendingFee - lendingFee) <= Constants.FEE_MAX_INCREMENT,\\n        \\\"Change exceeds max increment\\\"\\n      );\\n      } else {\\n        require(\\n          (lendingFee - _lendingFee) <= Constants.FEE_MAX_INCREMENT,\\n          \\\"Change exceeds max increment\\\"\\n          );\\n      }\\n    lendingFee = _lendingFee;\\n    emit lendingFeeSet(_lendingFee);\\n    return true;\\n  }\\n\\n  // Set the extension fee:\\n  function setExtensionFee(uint64 _extensionFee)\\n    external\\n    onlyOwner\\n    returns (bool)\\n  {\\n    require(_extensionFee != extensionFee, \\\"No change to extension fee\\\");\\n    if (_extensionFee > extensionFee) {\\n        require(\\n            (_extensionFee - extensionFee) <= Constants.FEE_MAX_INCREMENT,\\n            \\\"Change exceeds max increment\\\"\\n        );\\n    } else {\\n        require(\\n            (extensionFee - _extensionFee) <= Constants.FEE_MAX_INCREMENT,\\n            \\\"Change exceeds max increment\\\"\\n        );\\n    }\\n    extensionFee = _extensionFee;\\n    emit extensionFeeSet(_extensionFee);\\n    return true;\\n  }\\n\\n  // Set the term in days:\\n  function setTermInDays(uint16 _termInDays) external onlyOwner returns (bool) {\\n    require(_termInDays != termInDays, \\\"No change to term\\\");\\n    require(\\n      _termInDays <= Constants.LOAN_TERM_MAX,\\n      \\\"Change is more than max term\\\"\\n    );\\n    require(\\n      _termInDays >= Constants.LOAN_TERM_MIN,\\n      \\\"Change is less than min term\\\"\\n    );\\n    require(\\n      _termInDays >= extensionHorizon,\\n      \\\"Term must be greater than or equal to extension horizon\\\"\\n    );\\n    termInDays = _termInDays;\\n    emit termInDaysSet(_termInDays);\\n    return true;\\n  }\\n\\n  // Set extension horizon in days:\\n  function setExtensionHorizon(uint16 _extensionHorizon)\\n    external\\n    onlyOwner\\n    returns (bool)\\n  {\\n    require(_extensionHorizon != extensionHorizon, \\\"No change to horizon\\\");\\n    require(\\n      _extensionHorizon <= Constants.LOAN_TERM_MAX,\\n      \\\"Change is more than max term\\\"\\n    );\\n    require(\\n      _extensionHorizon >= Constants.LOAN_TERM_MIN,\\n      \\\"Change is less than min term\\\"\\n    );\\n    require(\\n      _extensionHorizon <= termInDays,\\n      \\\"Extension horizon must be less than or equal to term\\\"\\n    );\\n    extensionHorizon = _extensionHorizon;\\n    emit extensionHorizonSet(_extensionHorizon);\\n    return true;\\n  }\\n\\n  /** -----------------------------------------------------------------------------\\n   *   Contract routines - these do all the work:\\n   *   -----------------------------------------------------------------------------\\n   */\\n  //Always returns `IERC721Receiver.onERC721Received.selector`. We need this to custody NFTs on the contract:\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes memory\\n  ) external virtual override returns (bytes4) {\\n    return this.onERC721Received.selector;\\n  }\\n\\n  // Allow contract to receive ETH:\\n  receive() external payable {\\n    require(msg.sender == owner(), \\\"Only owner can fund contract.\\\");\\n    require(msg.value > 0, \\\"No ether was sent.\\\");\\n    emit ethDeposited(msg.value, block.timestamp);\\n  }\\n\\n  // The fallback function is executed on a call to the contract if\\n  // none of the other functions match the given function signature.\\n  fallback() external payable {\\n    revert();\\n  }\\n\\n  function getParameters()\\n    external\\n    view\\n    returns (\\n      address _tokenAddress,\\n      uint32 _loanTerm,\\n      uint128 _loanAmount,\\n      uint128 _loanFee,\\n      uint64 _extensionHorizon,\\n      uint128 _extensionFee,\\n      bool _isPaused,\\n      bool _isSunset\\n    )\\n  {\\n    return (\\n      address(tokenContract),\\n      termInDays,\\n      loanAmount,\\n      lendingFee,\\n      extensionHorizon,\\n      extensionFee,\\n      paused(),\\n      sunsetModeActive()\\n    );\\n  }\\n\\n  function getLoans() external view returns (LoanItem[] memory) {\\n    return itemsUnderLoan;\\n  }\\n\\n  function pause() public onlyOwner {\\n    _pause();\\n  }\\n\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  function sunset() external onlyOwner {\\n    _sunset();\\n  }\\n\\n  function sunrise() external onlyOwner {\\n    _sunrise();\\n  }\\n\\n  function extensionsAllowed() public view returns (bool) {\\n    return (extensionFee > 0);\\n  }\\n\\n  function isWithinExtensionHorizon(uint128 _loanId) public view returns (bool) {\\n    return\\n      (block.timestamp +\\n      (extensionHorizon * Constants.SECONDS_TO_DAYS_FACTOR) >=\\n      itemsUnderLoan[_loanId].endDate);\\n  }\\n\\n  function isWithinLoanTerm(uint128 _loanId) public view returns (bool) {\\n    return (block.timestamp <= itemsUnderLoan[_loanId].endDate);\\n  }\\n\\n  // Ensure that the owner can withdraw deposited ETH:\\n  function withdraw(uint256 _withdrawal) external onlyOwner returns (bool) {\\n    (bool success, ) = msg.sender.call{value: _withdrawal}(\\\"\\\");\\n    require(success, \\\"Transfer failed.\\\");\\n    emit ethWithdrawn(_withdrawal, block.timestamp);\\n    return true;\\n  }\\n\\n  // This function is called to advance the borrower ETH in exchange for taking\\n  // custody of the asset.\\n  function takeLoan(uint16 tokenId) external whenNotPaused whenSun {\\n    // The id is the length of the current array as this is the next item:\\n    uint256 newItemId = itemsUnderLoan.length;\\n    uint32 endDate = uint32(block.timestamp) +\\n      (termInDays * Constants.SECONDS_TO_DAYS_FACTOR);\\n    // Add this to the array:\\n    itemsUnderLoan.push(\\n      LoanItem(\\n        uint128(newItemId),\\n        loanAmount + lendingFee,\\n        true,\\n        payable(msg.sender),\\n        uint32(block.timestamp),\\n        endDate,\\n        tokenId\\n      )\\n    );\\n    // Custody the asset to this contract:\\n    tokenContract.safeTransferFrom(msg.sender, address(this), tokenId);\\n    // Send the borrower their ETH:\\n    payable(msg.sender).transfer(loanAmount);\\n    emit lendingTransaction(\\n      uint128(newItemId),\\n      Constants.TXNCODE_LOAN_ADVANCED,\\n      msg.sender,\\n      tokenId,\\n      loanAmount,\\n      lendingFee,\\n      endDate,\\n      block.timestamp\\n    );\\n  }\\n\\n  // This function is called when the borrower makes a payment. If the payment\\n  // clears the balance of the loan this routine will also return the NFT to the\\n  // borrower:\\n  function makeLoanPayment(uint128 _loanId)\\n    external\\n    payable\\n    IsUnderLoan(_loanId)\\n    OnlyItemBorrower(_loanId)\\n    LoanWithinLoanTerm(_loanId)\\n    whenNotPaused\\n  {\\n    require(\\n      msg.value <= itemsUnderLoan[_loanId].currentBalance,\\n      \\\"Payment exceeds current balance\\\"\\n    );\\n    // Reduce the balance outstanding by the amount of ETH received:\\n    itemsUnderLoan[_loanId].currentBalance -= uint128(msg.value);\\n\\n    // See if this payment means the loan is done and we can return the asset:\\n    if (itemsUnderLoan[_loanId].currentBalance == 0) {\\n      _closeLoan(_loanId, msg.sender);\\n\\n      emit lendingTransaction(\\n        _loanId,\\n        Constants.TXNCODE_ASSET_REDEEMED,\\n        msg.sender,\\n        itemsUnderLoan[_loanId].tokenId,\\n        msg.value,\\n        0,\\n        itemsUnderLoan[_loanId].endDate,\\n        block.timestamp\\n      );\\n    } else {\\n      // Emit this payment event:\\n      emit lendingTransaction(\\n        _loanId,\\n        Constants.TXNCODE_LOAN_PAYMENT_MADE,\\n        msg.sender,\\n        itemsUnderLoan[_loanId].tokenId,\\n        msg.value,\\n        0,\\n        itemsUnderLoan[_loanId].endDate,\\n        block.timestamp\\n      );\\n    }\\n  }\\n\\n  // This function is called when the borrower extends a loan. The loan can be extended\\n  // by the original term in days for payment of the extension fee (if allowed):\\n  function extendLoan(uint128 _loanId)\\n    external\\n    payable\\n    IsUnderLoan(_loanId)\\n    OnlyItemBorrower(_loanId)\\n    LoanWithinLoanTerm(_loanId)\\n    LoanEligibleForExtension(_loanId)\\n    whenNotPaused\\n    whenSun\\n  {\\n    require(msg.value == extensionFee, \\\"Payment must equal the extension fee\\\");\\n    // Extend the term, that's all we need to do\\n    itemsUnderLoan[_loanId].endDate += (termInDays *\\n      Constants.SECONDS_TO_DAYS_FACTOR);\\n    // Emit the extension events:\\n    emit lendingTransaction(\\n      _loanId,\\n      Constants.TXNCODE_ASSET_EXTENDED,\\n      msg.sender,\\n      itemsUnderLoan[_loanId].tokenId,\\n      msg.value,\\n      msg.value,\\n      itemsUnderLoan[_loanId].endDate,\\n      block.timestamp\\n    );\\n  }\\n\\n  // This function is called when an item is repossessed. This is ONLY possible when the\\n  // loan has lapsed.\\n  function repossessItem(uint128 _loanId) public IsUnderLoan(_loanId) {\\n    require(\\n      itemsUnderLoan[_loanId].endDate < block.timestamp,\\n      \\\"Loan term has not yet elapsed\\\"\\n    );\\n\\n    _closeLoan(_loanId, repoAddress);\\n\\n    emit lendingTransaction(\\n      _loanId,\\n      Constants.TXNCODE_ASSET_REPOSSESSED,\\n      itemsUnderLoan[_loanId].borrower,\\n      itemsUnderLoan[_loanId].tokenId,\\n      itemsUnderLoan[_loanId].currentBalance,\\n      0,\\n      itemsUnderLoan[_loanId].endDate,\\n      block.timestamp\\n    );\\n  }\\n\\n  // Repossess eligible items in batches:\\n  function repossessItems(uint128[] calldata repoItems) external {\\n    for (uint256 i = 0; i < repoItems.length; i++) {\\n      repossessItem(repoItems[i]);\\n    }\\n  }\\n\\n  // Handle loan closure and asset transfer:\\n  function _closeLoan(uint128 _closeLoanId, address _tokenTransferTo) internal {\\n    itemsUnderLoan[_closeLoanId].isCurrent = false;\\n    tokenContract.safeTransferFrom(\\n      address(this),\\n      _tokenTransferTo,\\n      itemsUnderLoan[_closeLoanId].tokenId\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/Sunsetable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an sunset\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenSun` and `whenMoon`, which can be applied to\\n * the functions of your contract. Note that they will not be useable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Sunsetable is Context {\\n    /**\\n     * @dev Emitted when the sunset is triggered by `account`.\\n     */\\n    event Sunset(address account);\\n\\n    /**\\n     * @dev Emitted when the sunrise is triggered by `account`.\\n     */\\n    event Sunrise(address account);\\n\\n    bool private _sunsetModeActive;\\n\\n    /**\\n     * @dev Initializes the contract in sunrised state.\\n     */\\n    constructor() {\\n        _sunsetModeActive = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the sun has set, and false otherwise.\\n     */\\n    function sunsetModeActive() public view virtual returns (bool) {\\n        return _sunsetModeActive;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the sun is up.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be in sunset mode.\\n     */\\n    modifier whenSun() {\\n        require(!sunsetModeActive(), \\\"Sunset: Sun has set on this contract\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the sun has set.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be in sunset mode.\\n     */\\n    modifier whenMoon() {\\n        require(sunsetModeActive(), \\\"Sunset: Sun has not set on this contract\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers sunset state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be in sunset already.\\n     */\\n    function _sunset() internal virtual whenSun {\\n        _sunsetModeActive = true;\\n        emit Sunset(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be in sunset mode.\\n     */\\n    function _sunrise() internal virtual whenMoon {\\n        _sunsetModeActive = false;\\n        emit Sunrise(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nlibrary Constants {\\n    // Transaction events\\n    uint256 constant TXNCODE_LOAN_ADVANCED = 1000;\\n    uint256 constant TXNCODE_LOAN_PAYMENT_MADE = 2000;\\n    uint256 constant TXNCODE_ASSET_REDEEMED = 3000;\\n    uint256 constant TXNCODE_ASSET_EXTENDED = 4000;\\n    uint256 constant TXNCODE_ASSET_REPOSSESSED = 5000;\\n    uint32 constant SECONDS_TO_DAYS_FACTOR = 86400;\\n    uint128 constant LOAN_AMOUNT_MAX_INCREMENT = 300000000000000000;\\n    uint64 constant FEE_MAX_INCREMENT = 30000000000000000;\\n    uint16 constant LOAN_TERM_MAX = 180;\\n    uint16 constant LOAN_TERM_MIN = 14;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_loanAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"_termInDays\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_repoAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_lendingFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_extensionFee\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"_extensionHorizon\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Sunrise\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Sunset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"eligibleNFTAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"effectiveDate\",\"type\":\"uint256\"}],\"name\":\"ethDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"effectiveDate\",\"type\":\"uint256\"}],\"name\":\"ethWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"extensionFee\",\"type\":\"uint64\"}],\"name\":\"extensionFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"extensionHorizon\",\"type\":\"uint16\"}],\"name\":\"extensionHorizonSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"lendingFee\",\"type\":\"uint64\"}],\"name\":\"lendingFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"loanId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionCode\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanEndDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"effectiveDate\",\"type\":\"uint256\"}],\"name\":\"lendingTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"loanAmount\",\"type\":\"uint128\"}],\"name\":\"loanAmountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"repoAddress\",\"type\":\"address\"}],\"name\":\"repoAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"termInDays\",\"type\":\"uint16\"}],\"name\":\"termInDaysSet\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_loanId\",\"type\":\"uint128\"}],\"name\":\"extendLoan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionFee\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionHorizon\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionsAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLoans\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"loanId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentBalance\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isCurrent\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endDate\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"internalType\":\"struct Metalend.LoanItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getParameters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_loanTerm\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"_loanAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_loanFee\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"_extensionHorizon\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_extensionFee\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isSunset\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_loanId\",\"type\":\"uint128\"}],\"name\":\"isWithinExtensionHorizon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_loanId\",\"type\":\"uint128\"}],\"name\":\"isWithinLoanTerm\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemsUnderLoan\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"loanId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentBalance\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isCurrent\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endDate\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingFee\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_loanId\",\"type\":\"uint128\"}],\"name\":\"makeLoanPayment\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_loanId\",\"type\":\"uint128\"}],\"name\":\"repossessItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128[]\",\"name\":\"repoItems\",\"type\":\"uint128[]\"}],\"name\":\"repossessItems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_extensionFee\",\"type\":\"uint64\"}],\"name\":\"setExtensionFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_extensionHorizon\",\"type\":\"uint16\"}],\"name\":\"setExtensionHorizon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_lendingFee\",\"type\":\"uint64\"}],\"name\":\"setLendingFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_loanAmount\",\"type\":\"uint128\"}],\"name\":\"setLoanAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_repoAddress\",\"type\":\"address\"}],\"name\":\"setRepoAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_termInDays\",\"type\":\"uint16\"}],\"name\":\"setTermInDays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sunrise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sunset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sunsetModeActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"takeLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termInDays\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawal\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Metalend","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001d20a51f088492a0f1c57f047a9e30c9ab5c07ea000000000000000000000000000000000000000000000000058d15e176280000000000000000000000000000000000000000000000000000000000000000005a0000000000000000000000001f3621d2d57ee42d3e0cc0aa42156d0c3f7744a5000000000000000000000000000000000000000000000000006a94d74f430000000000000000000000000000000000000000000000000000006a94d74f430000000000000000000000000000000000000000000000000000000000000000001e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}