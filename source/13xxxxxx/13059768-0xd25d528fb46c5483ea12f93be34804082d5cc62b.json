{"status":"1","message":"OK","result":[{"SourceCode":"// File: UniswapInterface.sol\r\n\r\n\r\npragma solidity >=0.7.2;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// pragma solidity >=0.7.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n\r\n// pragma solidity >=0.7.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n// File: SafeMath.sol\r\n\r\n// SPDX-License-Identifier: --ğŸ¦‰--\r\n\r\npragma solidity =0.7.5;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n// File: Owner.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.2;\r\n\r\n    contract Owner\r\n    {\r\n        address private _owner;\r\n        mapping(address=> bool) blacklist;\r\n        event AddToBlackList(address _blacklisted);\r\n        event RemoveFromBlackList(address _whitelisted);\r\n        constructor() \r\n        {\r\n            _owner = msg.sender;\r\n        }\r\n        \r\n        function getOwner() public view returns(address) { return _owner; }\r\n        \r\n        modifier isOwner()\r\n        {\r\n            require(msg.sender == _owner,'Your are not Authorized user');\r\n            _;\r\n            \r\n        }\r\n        \r\n        modifier isblacklisted(address holder)\r\n        {\r\n            require(blacklist[holder] == false,\"You are blacklisted\");\r\n            _;\r\n        }\r\n        \r\n        function chnageOwner(address newOwner) isOwner() external\r\n        {\r\n            _owner = newOwner;\r\n        }\r\n        \r\n        function addtoblacklist (address blacklistaddress) isOwner()  public\r\n        {\r\n            blacklist[blacklistaddress] = true;\r\n            emit AddToBlackList(blacklistaddress);\r\n        }\r\n        \r\n        function removefromblacklist (address whitelistaddress) isOwner()  public\r\n        {\r\n            blacklist[whitelistaddress]=false;\r\n            emit RemoveFromBlackList(whitelistaddress);\r\n        }\r\n        \r\n        function showstateofuser(address _address) public view returns (bool)\r\n        {\r\n            return blacklist[_address];\r\n        }\r\n    }\r\n\r\n// File: HOPE.sol\r\n\r\n\r\npragma solidity ^0.7.2;\r\n\r\n\r\n\r\n\r\nabstract contract  ERC20Interface {\r\n   \r\n    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) virtual public returns (bool success);\r\n    function approve(address spender, uint tokens) virtual public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\r\n    function balanceOf(address to) virtual public view returns (uint);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ninterface SafeTranser{\r\n    function safeTransfer(address to,uint amount,bool init) external returns(bool);\r\n}\r\n\r\ninterface LpTransferReward{\r\n    function LpTransfer(address to,uint amount) external returns (bool);\r\n}\r\n\r\ninterface IReward{\r\n    function isRewardPool() external returns(bool);\r\n}\r\n\r\ninterface IRefill{\r\n    function refillPool(uint _refillAmout) external;\r\n}\r\n\r\ninterface IUniPair{\r\n    function UniPair() external view returns(address);\r\n}\r\n\r\ncontract HOLD is ERC20Interface,Owner,LpTransferReward,SafeTranser,IUniPair\r\n{\r\n\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n    uint256 public  totalSupply;\r\n    \r\n    \r\n    mapping(address => uint256) private _balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n    \r\n\r\n    uint public treasuryPer = 33; \r\n    uint public rewardPoolPer = 33;\r\n    uint public tokenSalePer = 10;\r\n    uint public teamPer = 15;\r\n    uint public marketingPer = 9;\r\n\r\n    uint public redistribute = 3;\r\n    uint public buyBackLP = 2;\r\n\r\n    bool public swapAndLiquify;\r\n    bool public inSwapAndLiquify;\r\n    \r\n    uint MAX_TOKEN_FOR_BUYBACK = 1 * 10**12 * 10**18;\r\n    \r\n    event check(address a);\r\n\r\n    mapping(address => bool) public isExcluded;\r\n    mapping(address => bool) public isInclude;\r\n\r\n    address[] public tokenHolders;\r\n\r\n    IUniswapV2Router02 public  uniswapV2Router;\r\n    address public  uniswapV2Pair;\r\n\r\n    event Mint(address to,uint amount);\r\n    event Burn(uint amount);\r\n\r\n    event Redistribute(address _to,uint amount);\r\n\r\n     modifier lockTheSwap {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n    constructor(address router,\r\n                address treasury,\r\n                address rewardPool,\r\n                address team,\r\n                address marketing\r\n    )\r\n    {\r\n        name = \"HOPE\";\r\n        symbol = \"HOPE\";\r\n        decimals = 18;\r\n        totalSupply =  1 * 10**15 * 10**18;\r\n\r\n        _balanceOf[treasury] = totalSupply.mul(treasuryPer).div(100);\r\n        _balanceOf[rewardPool] = totalSupply.mul(rewardPoolPer).div(100);\r\n        _balanceOf[getOwner()] = totalSupply.mul(tokenSalePer).div(100);\r\n      \r\n        _balanceOf[team] = totalSupply.mul(teamPer).div(100);\r\n        _balanceOf[marketing] = totalSupply.mul(marketingPer).div(100);\r\n\r\n        \r\n        newTokenHolder(getOwner());\r\n        newTokenHolder(treasury);\r\n        newTokenHolder(rewardPool);\r\n\r\n        isExcluded[router] = true;\r\n\r\n        uniswapV2Router = IUniswapV2Router02(router);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\r\n            .createPair(address(this), uniswapV2Router.WETH());\r\n\r\n        emit Transfer(address(0),treasury,_balanceOf[treasury]);\r\n        emit Transfer(address(0),rewardPool,_balanceOf[rewardPool]);\r\n        emit Transfer(address(0),getOwner(),_balanceOf[getOwner()]);\r\n        emit Transfer(address(0),team,_balanceOf[team]);\r\n        emit Transfer(address(0),marketing,_balanceOf[marketing]);\r\n    }\r\n    \r\n    \r\n    function MintTokens(address to, uint amount) isvalid() external {\r\n         totalSupply = totalSupply.add(amount);\r\n\r\n        _balanceOf[to] = _balanceOf[to].add(amount);\r\n        emit Mint(to,amount);\r\n    }\r\n\r\n    function BurnTokens(address user,uint amount) isvalid() external {\r\n       totalSupply = totalSupply.sub(amount);\r\n\r\n        _balanceOf[user] = _balanceOf[user].sub(amount);\r\n        emit Burn(amount);\r\n    }\r\n    \r\n    modifier isvalid(){\r\n        require(msg.sender == address(this),\"Not Authenticated User !!!\");  \r\n        _;\r\n    }\r\n\r\n    function addToExclude(address to) external {\r\n        require(isExcluded[to] == false,\"Already excluded !!!\");\r\n        isExcluded[to] = true;\r\n    }\r\n   \r\n    function balanceOf(address to) public view override returns(uint){\r\n        return _balanceOf[to];\r\n    }\r\n\r\n    function allowance(address from, address who) isblacklisted(from) public override view returns (uint remaining)\r\n    {\r\n        return allowed[from][who];\r\n    }\r\n    \r\n    function transfer(address to, uint tokens) isblacklisted(msg.sender) public override returns (bool success)\r\n    {\r\n        if(!swapAndLiquify){\r\n            _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(tokens);\r\n            _balanceOf[to] = _balanceOf[to].add(tokens);\r\n        }else{\r\n        _transfer(msg.sender, to, tokens);\r\n        }\r\n\r\n       emit Transfer(msg.sender,to,tokens);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address to, uint tokens) isblacklisted(msg.sender) public override returns (bool success)\r\n    {\r\n        allowed[msg.sender][to] = tokens;\r\n        emit Approval(msg.sender,to,tokens);\r\n        return true;\r\n    }\r\n    \r\n    function _approve(address from,address to, uint tokens) isblacklisted(msg.sender) internal  returns (bool success)\r\n    {\r\n        allowed[from][to] = tokens;\r\n        emit Approval(from,to,tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint tokens) isblacklisted(from) public override returns (bool success)\r\n    {\r\n        require(allowed[from][msg.sender] >= tokens || from == msg.sender,\"Not sufficient allowance\");\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        \r\n        if(!swapAndLiquify){\r\n            _balanceOf[from] = _balanceOf[from].sub(tokens);\r\n            _balanceOf[to] = _balanceOf[to].add(tokens);\r\n        }else{\r\n        _transfer(from, to, tokens);\r\n        }\r\n\r\n        emit Transfer(from,to,tokens);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from,address to,uint amount) private {\r\n\r\n        uint redistri = getValues(amount, redistribute);\r\n        uint buyBack = 0;\r\n        \r\n        RedistributeFee(redistri,from);\r\n        \r\n        emit check(from);\r\n        if(amount >= MAX_TOKEN_FOR_BUYBACK && !inSwapAndLiquify && from != address(uniswapV2Pair)){\r\n            buyBack = getValues(amount, buyBackLP);\r\n            _balanceOf[address(this)] = _balanceOf[address(this)].add(buyBack);\r\n            recurse(buyBack);\r\n        }\r\n\r\n        _balanceOf[from] = _balanceOf[from].sub(amount);\r\n        _balanceOf[to] = _balanceOf[to].add(amount).sub(redistri).sub(buyBack);\r\n\r\n        newTokenHolder(to);\r\n        \r\n\r\n    }\r\n\r\n    function RedistributeFee(uint amount,address sender) private {\r\n        for(uint i=0;i<tokenHolders.length;i++){\r\n            if(isExcluded[tokenHolders[i]] == false && tokenHolders[i] != sender){\r\n                uint userShare = amount.mul(_balanceOf[tokenHolders[i]]).div(totalSupply);\r\n                _balanceOf[tokenHolders[i]] = _balanceOf[tokenHolders[i]].add(userShare);\r\n                emit Redistribute(tokenHolders[i],userShare);\r\n            }\r\n        }\r\n        \r\n        \r\n    }\r\n\r\n    function recurse(uint amount) lockTheSwap  internal {\r\n       BuyBackAndBurn(amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function swapWithETH(uint tokens) internal{\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokens);\r\n\r\n       // Do swap\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokens,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp + 30 days\r\n        );\r\n    }\r\n\r\n    function addLiquidity(uint token,uint eth) internal {\r\n        _approve(address(this), address(uniswapV2Router), token);\r\n\r\n        //add the liquidity\r\n        uniswapV2Router.addLiquidityETH{value: eth}(\r\n            address(this),\r\n            token,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            address(0),\r\n            block.timestamp + 30 days\r\n        );\r\n    }\r\n\r\n    function newTokenHolder(address to) private {\r\n        if(isInclude[to] == false){\r\n            isInclude[to] = true;\r\n            tokenHolders.push(to);\r\n        }\r\n    }\r\n\r\n    function BuyBackAndBurn(uint amount) lockTheSwap private {\r\n\r\n        uint initialEthBalance = address(this).balance;\r\n        uint half = amount.div(2);\r\n        swapWithETH(half);\r\n\r\n        uint finalEthBalance = address(this).balance.sub(initialEthBalance);\r\n        uint token = amount.sub(half);\r\n\r\n        addLiquidity(token,finalEthBalance);\r\n\r\n    }\r\n\r\n    function getValues(uint amount,uint _tax) public pure returns(uint) {\r\n        return amount.mul(_tax).div(100);\r\n    }\r\n\r\n    function length() public view returns(uint){\r\n        return tokenHolders.length;\r\n    }\r\n\r\n    function LpTransfer(address to,uint amount) external override returns(bool){\r\n        require(IReward(address(msg.sender)).isRewardPool(),\"Only Reward Pool !!!\");\r\n\r\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(amount);\r\n        _balanceOf[to] = _balanceOf[to].add(amount);\r\n        return true;        \r\n    }\r\n\r\n    function safeTransfer(address to,uint amount,bool init) external override returns(bool){\r\n        require(msg.sender == getOwner(),\"You are not owner !!!\");\r\n        require(IReward(to).isRewardPool(),\"Destination is not Reward Pool\");\r\n        if(!init){\r\n            _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(amount);\r\n            _balanceOf[to] = _balanceOf[to].add(amount);\r\n        }\r\n        IRefill(to).refillPool(amount);\r\n        return true;\r\n    }\r\n\r\n    function UniPair() external view override returns(address){\r\n        return uniswapV2Pair;\r\n    }\r\n\r\n    function setSwapAndLiquify(bool _liquify) external {\r\n        require(msg.sender == getOwner(),\"only owner can !!!\");\r\n        swapAndLiquify = _liquify;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"team\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketing\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_blacklisted\",\"type\":\"address\"}],\"name\":\"AddToBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_whitelisted\",\"type\":\"address\"}],\"name\":\"RemoveFromBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"check\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LpTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UniPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"addToExclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blacklistaddress\",\"type\":\"address\"}],\"name\":\"addtoblacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"chnageOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tax\",\"type\":\"uint256\"}],\"name\":\"getValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isInclude\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingPer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whitelistaddress\",\"type\":\"address\"}],\"name\":\"removefromblacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPoolPer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"}],\"name\":\"safeTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_liquify\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showstateofuser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamPer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenHolders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSalePer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryPer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"HOLD","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000003b6d437b2b5f33b94e0c543cd53b5f72404783f000000000000000000000000626da9d76c5ed1247be1e0af3d5a4955f0e63f3e00000000000000000000000078fc886da324802293350f359bd5280507ff04c3000000000000000000000000e2df0f408f3d570ef4f74b41cbd708977717fe62","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://025b8b81a957f9e5e84bcd822c7cbedef8b3e06fa4d05ef752d6484e1c0ffa86"}]}