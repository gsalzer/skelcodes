{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Attack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport \\\"./ICryptoBees.sol\\\";\\nimport \\\"./IHoney.sol\\\";\\nimport \\\"./IHive.sol\\\";\\nimport \\\"./IAttack.sol\\\";\\n\\ncontract Attack is IAttack, Ownable, Pausable {\\n    event BearsAttackPrepared(address indexed owner, uint256 indexed nonce, uint256 indexed tokenId, uint256 hiveId);\\n    event BearsAttackResolved(address indexed owner, uint256 indexed nonce, uint256 tokenId, uint256 successes, uint256 value, uint256 err);\\n    event BeekeeperAttackPrepared(address indexed owner, uint256 indexed nonce, uint256 indexed tokenId, uint256 hiveId);\\n    event BeekeeperAttackResolved(address indexed owner, uint256 indexed nonce, uint256 tokenId, uint256 value, uint256 err);\\n\\n    Settings settings;\\n\\n    ICryptoBees beesContract;\\n    IHive hiveContract;\\n\\n    mapping(uint256 => UnresolvedAttack) public unresolvedAttacks;\\n    mapping(uint256 => UnresolvedAttack) public unresolvedCollections;\\n\\n    constructor() {\\n        settings.bearChance = 40;\\n        settings.hiveProtectionBear = 4 * 60 * 60; // per success\\n        settings.beekeeperMultiplier = 4;\\n        settings.bearCooldownBase = 16 * 60 * 60;\\n        settings.bearCooldownPerHiveDay = 4 * 60 * 60;\\n        settings.beekeeperCooldownBase = 16 * 60 * 60;\\n        settings.beekeeperCooldownPerHiveDay = 4 * 60 * 60;\\n        settings.attacksToRestart = 7;\\n    }\\n\\n    function setContracts(address _BEES, address _HIVE) external onlyOwner {\\n        beesContract = ICryptoBees(_BEES);\\n        hiveContract = IHive(_HIVE);\\n    }\\n\\n    function setSettings(\\n        uint8 chance,\\n        uint24 protectionBear,\\n        uint8 multiplier,\\n        uint24 bearCooldown,\\n        uint24 bearPerHive,\\n        uint24 keeperCooldown,\\n        uint24 keeperPerHive,\\n        uint8 attacksToRestart\\n    ) external onlyOwner {\\n        settings.bearChance = chance;\\n        settings.beekeeperMultiplier = multiplier;\\n        settings.hiveProtectionBear = protectionBear;\\n        settings.bearCooldownBase = bearCooldown;\\n        settings.bearCooldownPerHiveDay = bearPerHive;\\n        settings.beekeeperCooldownBase = keeperCooldown;\\n        settings.beekeeperCooldownPerHiveDay = keeperPerHive;\\n        settings.attacksToRestart = attacksToRestart;\\n    }\\n\\n    /** ATTACKS */\\n    function checkCanAttack(uint16[] calldata hiveIds, uint16[] calldata tokenIds) internal view {\\n        require(tokenIds.length == hiveIds.length, \\\"ATTACK: THE ARGUMENTS LENGTHS DO NOT MATCH\\\");\\n        bool duplicates;\\n        for (uint256 i = 0; i < hiveIds.length; i++) {\\n            require(beesContract.getTokenData(tokenIds[i])._type == 2, \\\"ATTACK: MUST BE BEAR\\\");\\n            require(beesContract.getOwnerOf(tokenIds[i]) == _msgSender() || hiveContract.getWaitingRoomOwner(tokenIds[i]) == _msgSender(), \\\"ATTACK: YOU ARE NOT THE OWNER\\\");\\n            for (uint256 y = 0; y < hiveIds.length; y++) {\\n                if (i != y && hiveIds[i] == hiveIds[y]) {\\n                    duplicates = true;\\n                    break;\\n                }\\n            }\\n        }\\n        require(!duplicates, \\\"CANNOT ATTACK SAME HIVE WITH TWO BEARS\\\");\\n    }\\n\\n    function _resolveAttack(uint256 hiveId) private {\\n        UnresolvedAttack memory a = unresolvedAttacks[hiveId];\\n        // there is no unresolved attack for this hive\\n        if (a.block == 0) return;\\n        ICryptoBees.Token memory t = beesContract.getTokenData(a.tokenId);\\n        uint256 owed = 0;\\n        uint256 successes = 0;\\n        uint256 err = 0;\\n\\n        // check if hive is attackable\\n        if ((hiveContract.getHiveProtectionBears(hiveId) > block.timestamp)) {\\n            err = 1;\\n        }\\n\\n        if (err == 0) {\\n            uint256 seed = random(a.block);\\n\\n            (owed, successes) = _attack(t.strength, hiveId, seed);\\n\\n            // attack was successful let's update some stats\\n            if (successes >= 1) {\\n                hiveContract.incSuccessfulAttacks(hiveId);\\n                hiveContract.setBearAttackData(hiveId, uint32(block.timestamp), uint32(block.timestamp + (settings.hiveProtectionBear * successes)));\\n\\n                // blow up the hive\\n                if (hiveContract.getHiveSuccessfulAttacks(hiveId) >= settings.attacksToRestart) {\\n                    hiveContract.resetHive(hiveId);\\n                }\\n                // get the rightful owner (the token might possibly be in the waiting room/staked)\\n                address _owner;\\n                if (beesContract.getOwnerOf(a.tokenId) != address(hiveContract)) _owner = beesContract.getOwnerOf(a.tokenId);\\n                else _owner = hiveContract.getWaitingRoomOwner(a.tokenId);\\n                beesContract.increaseTokensPot(_owner, owed);\\n            }\\n            hiveContract.incTotalAttacks(hiveId);\\n        }\\n        emit BearsAttackResolved(_msgSender(), a.nonce, a.tokenId, successes, owed, err);\\n    }\\n\\n    function _attack(\\n        uint256 strength,\\n        uint256 hiveId,\\n        uint256 seed\\n    ) private returns (uint256, uint256) {\\n        uint256 owed = 0;\\n        uint256 successes = 0;\\n        // 5% of the hive\\n        uint256 beesAffected = hiveContract.getHiveOccupancy(hiveId) / 20;\\n        if (beesAffected < 5) beesAffected++;\\n\\n        for (uint256 y = 0; y < beesAffected; y++) {\\n            if (((seed & 0xFFFF) % 100) < settings.bearChance + (strength * 3)) {\\n                uint256 beeId = hiveContract.getBeeTokenId(hiveId, y);\\n                owed += hiveContract.calculateBeeOwed(hiveId, beeId);\\n                // reset bee's honey\\n                hiveContract.setBeeSince(hiveId, beeId, uint48(block.timestamp));\\n                successes += 1;\\n            }\\n            if (beesAffected > 1) seed >>= 16;\\n        }\\n        return (owed, successes);\\n    }\\n\\n    function resolveAttacks(uint16[] calldata hiveIds) public whenNotPaused {\\n        for (uint256 i = 0; i < hiveIds.length; i++) {\\n            _resolveAttack(hiveIds[i]);\\n            delete unresolvedAttacks[hiveIds[i]];\\n        }\\n    }\\n\\n    function manyBearsAttack(\\n        uint256 nonce,\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds\\n    ) external whenNotPaused {\\n        checkCanAttack(hiveIds, tokenIds);\\n\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            _resolveAttack(hiveIds[i]);\\n            // check if bear can attack\\n            if (beesContract.getTokenData(tokenIds[i]).cooldownTillTimestamp < block.timestamp && (hiveContract.getHiveProtectionBears(hiveIds[i]) < block.timestamp)) {\\n                unresolvedAttacks[hiveIds[i]] = UnresolvedAttack({tokenId: tokenIds[i], block: uint64(block.number), nonce: uint48(nonce), howMuch: 0});\\n\\n                uint48 hiveAge = uint48(block.timestamp) - hiveContract.getHiveAge(hiveIds[i]);\\n                uint256 cooldown = (((hiveAge / 86400) * settings.bearCooldownPerHiveDay) + settings.bearCooldownBase);\\n                beesContract.updateTokensLastAttack(tokenIds[i], uint48(block.timestamp), uint48(block.timestamp + cooldown));\\n                emit BearsAttackPrepared(_msgSender(), nonce, tokenIds[i], hiveIds[i]);\\n            } else {\\n                delete unresolvedAttacks[hiveIds[i]];\\n            }\\n        }\\n    }\\n\\n    /** COLLECTION */\\n    function checkCanCollect(\\n        uint16[] calldata hiveIds,\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata howMuch\\n    ) internal view {\\n        require(tokenIds.length == hiveIds.length && howMuch.length == hiveIds.length, \\\"ATTACK: THE ARGUMENTS LENGTHS DO NOT MATCH\\\");\\n        bool duplicates;\\n        for (uint256 i = 0; i < hiveIds.length; i++) {\\n            require(beesContract.getTokenData(tokenIds[i])._type == 3, \\\"ATTACK: MUST BE BEEKEEPER\\\");\\n            require(beesContract.getOwnerOf(tokenIds[i]) == _msgSender() || hiveContract.getWaitingRoomOwner(tokenIds[i]) == _msgSender(), \\\"ATTACK: YOU ARE NOT THE OWNER\\\");\\n            for (uint256 y = 0; y < hiveIds.length; y++) {\\n                if (i != y && hiveIds[i] == hiveIds[y]) {\\n                    duplicates = true;\\n                    break;\\n                }\\n            }\\n        }\\n        require(!duplicates, \\\"CANNOT ATTACK SAME HIVE WITH TWO BEEKEEPERS\\\");\\n    }\\n\\n    function _resolveCollection(uint256 hiveId) private {\\n        UnresolvedAttack memory a = unresolvedCollections[hiveId];\\n        // there is no unresolved attack for this hive\\n        if (a.block == 0) return;\\n        ICryptoBees.Token memory t = beesContract.getTokenData(a.tokenId);\\n        uint256 owed = 0;\\n        uint256 owedPerBee = 0;\\n        uint256 err = 0;\\n\\n        // check if hive is attackable\\n        if (hiveContract.isHiveProtectedFromKeepers(hiveId) == true) {\\n            err = 1;\\n        }\\n\\n        if (err == 0) {\\n            uint256 seed = random(a.block);\\n\\n            (owed, owedPerBee) = _collect(t.strength, hiveId, seed, a.howMuch);\\n\\n            if (owed > 0) {\\n                hiveContract.setKeeperAttackData(hiveId, uint32(block.timestamp), uint32(owed), uint32(owedPerBee));\\n                address _owner;\\n                if (beesContract.getOwnerOf(a.tokenId) != address(hiveContract)) _owner = beesContract.getOwnerOf(a.tokenId);\\n                else _owner = hiveContract.getWaitingRoomOwner(a.tokenId);\\n                beesContract.increaseTokensPot(_owner, owed);\\n            }\\n        }\\n        emit BeekeeperAttackResolved(_msgSender(), a.nonce, a.tokenId, owed, err);\\n    }\\n\\n    function _collect(\\n        uint256 strength,\\n        uint256 hiveId,\\n        uint256 seed,\\n        uint256 howMuch\\n    ) private view returns (uint256, uint256) {\\n        uint256 owed = 0;\\n        uint256 owedPerBee = 0;\\n\\n        if (((seed & 0xFFFF) % 100) < 100 - (howMuch * settings.beekeeperMultiplier) + (strength * 3)) {\\n            uint256 beesTotal = hiveContract.getHiveOccupancy(hiveId);\\n\\n            uint256 beeFirst = hiveContract.getBeeTokenId(hiveId, 0);\\n            uint256 beeLast = hiveContract.getBeeTokenId(hiveId, beesTotal - 1);\\n            uint256 avg = (hiveContract.calculateBeeOwed(hiveId, beeFirst) + hiveContract.calculateBeeOwed(hiveId, beeLast)) / 2;\\n            owed = (avg * beesTotal * howMuch) / 100;\\n            owedPerBee = (avg * howMuch) / 100;\\n        }\\n        return (owed, owedPerBee);\\n    }\\n\\n    function resolveCollections(uint16[] calldata hiveIds) public whenNotPaused {\\n        for (uint256 i = 0; i < hiveIds.length; i++) {\\n            _resolveCollection(hiveIds[i]);\\n            delete unresolvedCollections[hiveIds[i]];\\n        }\\n    }\\n\\n    function manyBeekeepersCollect(\\n        uint256 nonce,\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds,\\n        uint16[] calldata howMuch\\n    ) external whenNotPaused {\\n        checkCanCollect(hiveIds, tokenIds, howMuch);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            _resolveCollection(hiveIds[i]);\\n            // check if keeper can attack\\n            if (beesContract.getTokenData(tokenIds[i]).cooldownTillTimestamp < block.timestamp && hiveContract.isHiveProtectedFromKeepers(hiveIds[i]) == false) {\\n                unresolvedCollections[hiveIds[i]] = UnresolvedAttack({tokenId: tokenIds[i], block: uint64(block.number), nonce: uint48(nonce), howMuch: uint8(howMuch[i])});\\n                uint48 hiveAge = uint48(block.timestamp) - hiveContract.getHiveAge(hiveIds[i]);\\n                uint256 cooldown = (((hiveAge / 1 days) * settings.beekeeperCooldownPerHiveDay) + settings.beekeeperCooldownBase);\\n                beesContract.updateTokensLastAttack(tokenIds[i], uint48(block.timestamp), uint48(block.timestamp + cooldown));\\n                emit BeekeeperAttackPrepared(_msgSender(), nonce, tokenIds[i], hiveIds[i]);\\n            } else {\\n                delete unresolvedCollections[hiveIds[i]];\\n            }\\n        }\\n    }\\n\\n    /**\\n     * generates a pseudorandom number\\n     * @param blockNumber value ensure an attacker doesn't know\\n     * @return a pseudorandom value\\n     */\\n    function random(uint256 blockNumber) internal view returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(tx.origin, blockhash(blockNumber))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ICryptoBees.sol\": {\r\n      \"content\": \"//Contract based on https://docs.openzeppelin.com/contracts/3.x/erc721\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// import \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ICryptoBees {\\n    struct Token {\\n        uint8 _type;\\n        uint8 color;\\n        uint8 eyes;\\n        uint8 mouth;\\n        uint8 nose;\\n        uint8 hair;\\n        uint8 accessory;\\n        uint8 feelers;\\n        uint8 strength;\\n        uint48 lastAttackTimestamp;\\n        uint48 cooldownTillTimestamp;\\n    }\\n\\n    function getMinted() external view returns (uint256 m);\\n\\n    function increaseTokensPot(address _owner, uint256 amount) external;\\n\\n    function updateTokensLastAttack(\\n        uint256 tokenId,\\n        uint48 timestamp,\\n        uint48 till\\n    ) external;\\n\\n    function mint(\\n        address addr,\\n        uint256 tokenId,\\n        bool stake\\n    ) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function getTokenData(uint256 tokenId) external view returns (Token memory token);\\n\\n    function getOwnerOf(uint256 tokenId) external view returns (address);\\n\\n    function doesExist(uint256 tokenId) external view returns (bool exists);\\n\\n    function performTransferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function performSafeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IHoney.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\ninterface IHoney {\\n    function mint(address to, uint256 amount) external;\\n\\n    function mintGiveaway(address[] calldata addresses, uint256 amount) external;\\n\\n    function burn(address from, uint256 amount) external;\\n\\n    function disableGiveaway() external;\\n\\n    function addController(address controller) external;\\n\\n    function removeController(address controller) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IHive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\ninterface IHive {\\n    struct Bee {\\n        address owner;\\n        uint32 tokenId;\\n        uint48 since;\\n        uint8 index;\\n    }\\n\\n    struct BeeHive {\\n        uint32 startedTimestamp;\\n        uint32 lastCollectedHoneyTimestamp;\\n        uint32 hiveProtectionBears;\\n        uint32 lastStolenHoneyTimestamp;\\n        uint32 collectionAmount;\\n        uint32 collectionAmountPerBee;\\n        uint8 successfulAttacks;\\n        uint8 totalAttacks;\\n        mapping(uint256 => Bee) bees;\\n        uint16[] beesArray;\\n    }\\n\\n    function addManyToHive(\\n        address account,\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds\\n    ) external;\\n\\n    function claimManyFromHive(\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds,\\n        uint16[] calldata newHiveIds\\n    ) external;\\n\\n    function addToWaitingRoom(address account, uint256 tokenId) external;\\n\\n    function removeFromWaitingRoom(uint256 tokenId, uint256 hiveId) external;\\n\\n    function setRescueEnabled(bool _enabled) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setBeeSince(\\n        uint256 hiveId,\\n        uint256 tokenId,\\n        uint48 since\\n    ) external;\\n\\n    function calculateBeeOwed(uint256 hiveId, uint256 tokenId) external view returns (uint256 owed);\\n\\n    function incSuccessfulAttacks(uint256 hiveId) external;\\n\\n    function incTotalAttacks(uint256 hiveId) external;\\n\\n    function setBearAttackData(\\n        uint256 hiveId,\\n        uint32 timestamp,\\n        uint32 protection\\n    ) external;\\n\\n    function setKeeperAttackData(\\n        uint256 hiveId,\\n        uint32 timestamp,\\n        uint32 collected,\\n        uint32 collectedPerBee\\n    ) external;\\n\\n    function getLastStolenHoneyTimestamp(uint256 hiveId) external view returns (uint256 lastStolenHoneyTimestamp);\\n\\n    function getHiveProtectionBears(uint256 hiveId) external view returns (uint256 hiveProtectionBears);\\n\\n    function isHiveProtectedFromKeepers(uint256 hiveId) external view returns (bool);\\n\\n    function getHiveOccupancy(uint256 hiveId) external view returns (uint256 occupancy);\\n\\n    function getBeeSinceTimestamp(uint256 hiveId, uint256 tokenId) external view returns (uint256 since);\\n\\n    function getBeeTokenId(uint256 hiveId, uint256 index) external view returns (uint256 tokenId);\\n\\n    function getHiveAge(uint256 hiveId) external view returns (uint32);\\n\\n    function getHiveSuccessfulAttacks(uint256 hiveId) external view returns (uint8);\\n\\n    function getWaitingRoomOwner(uint256 tokenId) external view returns (address);\\n\\n    function resetHive(uint256 hiveId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IAttack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\ninterface IAttack {\\n    struct Settings {\\n        uint8 bearChance;\\n        uint8 beekeeperMultiplier;\\n        uint24 hiveProtectionBear;\\n        uint24 hiveProtectionKeeper;\\n        uint24 bearCooldownBase;\\n        uint24 bearCooldownPerHiveDay;\\n        uint24 beekeeperCooldownBase;\\n        uint24 beekeeperCooldownPerHiveDay;\\n        uint8 attacksToRestart;\\n    }\\n    struct UnresolvedAttack {\\n        uint24 tokenId;\\n        uint48 nonce;\\n        uint64 block;\\n        uint32 howMuch;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"BearsAttackPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"successes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"}],\"name\":\"BearsAttackResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"BeekeeperAttackPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"}],\"name\":\"BeekeeperAttackResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"hiveIds\",\"type\":\"uint16[]\"}],\"name\":\"manyBearsAttack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"hiveIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"howMuch\",\"type\":\"uint16[]\"}],\"name\":\"manyBeekeepersCollect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"hiveIds\",\"type\":\"uint16[]\"}],\"name\":\"resolveAttacks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"hiveIds\",\"type\":\"uint16[]\"}],\"name\":\"resolveCollections\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BEES\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_HIVE\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"chance\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"protectionBear\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"multiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"bearCooldown\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"bearPerHive\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"keeperCooldown\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"keeperPerHive\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"attacksToRestart\",\"type\":\"uint8\"}],\"name\":\"setSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unresolvedAttacks\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"tokenId\",\"type\":\"uint24\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"uint64\",\"name\":\"block\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"howMuch\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unresolvedCollections\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"tokenId\",\"type\":\"uint24\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"uint64\",\"name\":\"block\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"howMuch\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Attack","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}