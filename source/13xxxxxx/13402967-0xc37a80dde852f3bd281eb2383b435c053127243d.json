{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/lender/tranche.sol\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.5.15 >=0.7.6;\n\n////// lib/tinlake-auth/src/auth.sol\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\n/* pragma solidity >=0.5.15; */\n\ncontract Auth {\n    mapping (address => uint256) public wards;\n    \n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"not-authorized\");\n        _;\n    }\n\n}\n\n////// lib/tinlake-math/src/math.sol\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n/* pragma solidity >=0.5.15; */\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}\n\n////// src/fixed_point.sol\n/* pragma solidity >=0.7.6; */\n\nabstract contract FixedPoint {\n    struct Fixed27 {\n        uint value;\n    }\n}\n\n////// src/lender/tranche.sol\n/* pragma solidity >=0.7.6; */\n\n/* import \"tinlake-auth/auth.sol\"; */\n/* import \"tinlake-math/math.sol\"; */\n/* import \"./../fixed_point.sol\"; */\n\ninterface ERC20Like_3 {\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address, address, uint) external returns (bool);\n    function transfer(address to, uint amount) external returns (bool);\n    function mint(address, uint) external;\n    function burn(address, uint) external;\n    function totalSupply() external view returns (uint);\n    function approve(address usr, uint amount) external;\n}\n\ninterface ReserveLike_5 {\n    function deposit(uint amount) external;\n    function payout(uint amount) external;\n    function totalBalanceAvailable() external returns (uint);\n}\n\ninterface CoordinatorLike_4 {\n    function currentEpoch() external view returns (uint);\n    function lastEpochExecuted() external view returns(uint);\n}\n\ncontract Tranche is Math, Auth, FixedPoint {\n    mapping(uint => Epoch) public epochs;\n\n    struct Epoch {\n        // denominated in 10^27\n        // percentage ONE == 100%\n        uint redeemFulfillment;\n        // denominated in 10^27\n        // percentage ONE == 100%\n        uint supplyFulfillment;\n        // tokenPrice after end of epoch\n        uint tokenPrice;\n    }\n\n    struct UserOrder {\n        uint orderedInEpoch;\n        uint supplyCurrencyAmount;\n        uint redeemTokenAmount;\n    }\n\n    mapping(address => UserOrder) public users;\n\n    uint public  totalSupply;\n    uint public  totalRedeem;\n\n    ERC20Like_3 public currency;\n    ERC20Like_3 public token;\n    ReserveLike_5 public reserve;\n    CoordinatorLike_4 public coordinator;\n\n    // additional requested currency if the reserve could not fulfill a tranche request\n    uint public requestedCurrency;\n\n    bool public waitingForUpdate = false;\n\n    event Depend(bytes32 indexed contractName, address addr);\n    event Mint(address indexed usr, uint amount);\n    event Burn(address indexed usr, uint amount);\n    event AuthTransfer(address indexed erc20, address usr, uint amount);\n\n    modifier orderAllowed(address usr) {\n        require((users[usr].supplyCurrencyAmount == 0 && users[usr].redeemTokenAmount == 0)\n        || users[usr].orderedInEpoch == coordinator.currentEpoch(), \"disburse required\");\n        _;\n    }\n\n    constructor(address currency_, address token_) {\n        token = ERC20Like_3(token_);\n        currency = ERC20Like_3(currency_);\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function balance() external view returns (uint) {\n        return currency.balanceOf(address(this));\n    }\n\n    function tokenSupply() external view returns (uint) {\n        return token.totalSupply();\n    }\n\n    function depend(bytes32 contractName, address addr) public auth {\n        if (contractName == \"token\") {token = ERC20Like_3(addr);}\n        else if (contractName == \"currency\") {currency = ERC20Like_3(addr);}\n        else if (contractName == \"reserve\") {reserve = ReserveLike_5(addr);}\n        else if (contractName == \"coordinator\") {coordinator = CoordinatorLike_4(addr);}\n        else revert();\n        emit Depend(contractName, addr);\n    }\n\n    // supplyOrder function can be used to place or revoke an supply\n    function supplyOrder(address usr, uint newSupplyAmount) public auth orderAllowed(usr) {\n        users[usr].orderedInEpoch = coordinator.currentEpoch();\n\n        uint currentSupplyAmount = users[usr].supplyCurrencyAmount;\n\n        users[usr].supplyCurrencyAmount = newSupplyAmount;\n\n        totalSupply = safeAdd(safeTotalSub(totalSupply, currentSupplyAmount), newSupplyAmount);\n\n        uint delta;\n        if (newSupplyAmount > currentSupplyAmount) {\n            delta = safeSub(newSupplyAmount, currentSupplyAmount);\n            require(currency.transferFrom(usr, address(this), delta), \"currency-transfer-failed\");\n            return;\n        }\n        delta = safeSub(currentSupplyAmount, newSupplyAmount);\n        if (delta > 0) {\n            _safeTransfer(currency, usr, delta);\n        }\n    }\n\n    // redeemOrder function can be used to place or revoke a redeem\n    function redeemOrder(address usr, uint newRedeemAmount) public auth orderAllowed(usr) {\n        users[usr].orderedInEpoch = coordinator.currentEpoch();\n\n        uint currentRedeemAmount = users[usr].redeemTokenAmount;\n        users[usr].redeemTokenAmount = newRedeemAmount;\n        totalRedeem = safeAdd(safeTotalSub(totalRedeem, currentRedeemAmount), newRedeemAmount);\n\n        uint delta;\n        if (newRedeemAmount > currentRedeemAmount) {\n            delta = safeSub(newRedeemAmount, currentRedeemAmount);\n            require(token.transferFrom(usr, address(this), delta), \"token-transfer-failed\");\n            return;\n        }\n\n        delta = safeSub(currentRedeemAmount, newRedeemAmount);\n        if (delta > 0) {\n            _safeTransfer(token, usr, delta);\n        }\n    }\n\n    function calcDisburse(address usr) public view returns(uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n        return calcDisburse(usr, coordinator.lastEpochExecuted());\n    }\n\n    //  calculates the current disburse of a user starting from the ordered epoch until endEpoch\n    function calcDisburse(address usr, uint endEpoch) public view returns(uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n        uint epochIdx = users[usr].orderedInEpoch;\n        uint lastEpochExecuted = coordinator.lastEpochExecuted();\n\n        // no disburse possible in this epoch\n        if (users[usr].orderedInEpoch == coordinator.currentEpoch()) {\n            return (payoutCurrencyAmount, payoutTokenAmount, users[usr].supplyCurrencyAmount, users[usr].redeemTokenAmount);\n        }\n\n        if (endEpoch > lastEpochExecuted) {\n            // it is only possible to disburse epochs which are already over\n            endEpoch = lastEpochExecuted;\n        }\n\n        remainingSupplyCurrency = users[usr].supplyCurrencyAmount;\n        remainingRedeemToken = users[usr].redeemTokenAmount;\n        uint amount = 0;\n\n        // calculates disburse amounts as long as remaining tokens or currency is left or the end epoch is reached\n        while(epochIdx <= endEpoch && (remainingSupplyCurrency != 0 || remainingRedeemToken != 0 )){\n            if(remainingSupplyCurrency != 0) {\n                amount = rmul(remainingSupplyCurrency, epochs[epochIdx].supplyFulfillment);\n                // supply currency payout in token\n                if (amount != 0) {\n                    payoutTokenAmount = safeAdd(payoutTokenAmount, safeDiv(safeMul(amount, ONE), epochs[epochIdx].tokenPrice));\n                    remainingSupplyCurrency = safeSub(remainingSupplyCurrency, amount);\n                }\n            }\n\n            if(remainingRedeemToken != 0) {\n                amount = rmul(remainingRedeemToken, epochs[epochIdx].redeemFulfillment);\n                // redeem token payout in currency\n                if (amount != 0) {\n                    payoutCurrencyAmount = safeAdd(payoutCurrencyAmount, rmul(amount, epochs[epochIdx].tokenPrice));\n                    remainingRedeemToken = safeSub(remainingRedeemToken, amount);\n                }\n            }\n            epochIdx = safeAdd(epochIdx, 1);\n        }\n\n        return (payoutCurrencyAmount, payoutTokenAmount, remainingSupplyCurrency, remainingRedeemToken);\n    }\n\n    // the disburse function can be used after an epoch is over to receive currency and tokens\n    function disburse(address usr) public auth returns (uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n        return disburse(usr, coordinator.lastEpochExecuted());\n    }\n\n    function _safeTransfer(ERC20Like_3 erc20, address usr, uint amount) internal returns(uint) {\n        uint max = erc20.balanceOf(address(this));\n        if(amount > max) {\n            amount = max;\n        }\n        require(erc20.transfer(usr, amount), \"token-transfer-failed\");\n        return amount;\n    }\n\n    // the disburse function can be used after an epoch is over to receive currency and tokens\n    function disburse(address usr,  uint endEpoch) public auth returns (uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n        require(users[usr].orderedInEpoch <= coordinator.lastEpochExecuted(), \"epoch-not-executed-yet\");\n\n        uint lastEpochExecuted = coordinator.lastEpochExecuted();\n\n        if (endEpoch > lastEpochExecuted) {\n            // it is only possible to disburse epochs which are already over\n            endEpoch = lastEpochExecuted;\n        }\n\n        (payoutCurrencyAmount, payoutTokenAmount,\n        remainingSupplyCurrency, remainingRedeemToken) = calcDisburse(usr, endEpoch);\n        users[usr].supplyCurrencyAmount = remainingSupplyCurrency;\n        users[usr].redeemTokenAmount = remainingRedeemToken;\n        // if lastEpochExecuted is disbursed, orderInEpoch is at the current epoch again\n        // which allows to change the order. This is only possible if all previous epochs are disbursed\n        users[usr].orderedInEpoch = safeAdd(endEpoch, 1);\n\n\n        if (payoutCurrencyAmount > 0) {\n            payoutCurrencyAmount = _safeTransfer(currency, usr, payoutCurrencyAmount);\n        }\n\n        if (payoutTokenAmount > 0) {\n            payoutTokenAmount = _safeTransfer(token, usr, payoutTokenAmount);\n        }\n        return (payoutCurrencyAmount, payoutTokenAmount, remainingSupplyCurrency, remainingRedeemToken);\n    }\n\n\n    // called by epoch coordinator in epoch execute method\n    function epochUpdate(uint epochID, uint supplyFulfillment_, uint redeemFulfillment_, uint tokenPrice_, uint epochSupplyOrderCurrency, uint epochRedeemOrderCurrency) public auth {\n        require(waitingForUpdate == true);\n        waitingForUpdate = false;\n\n        epochs[epochID].supplyFulfillment = supplyFulfillment_;\n        epochs[epochID].redeemFulfillment = redeemFulfillment_;\n        epochs[epochID].tokenPrice = tokenPrice_;\n\n        // currency needs to be converted to tokenAmount with current token price\n        uint redeemInToken = 0;\n        uint supplyInToken = 0;\n        if(tokenPrice_ > 0) {\n            supplyInToken = rdiv(epochSupplyOrderCurrency, tokenPrice_);\n            redeemInToken = safeDiv(safeMul(epochRedeemOrderCurrency, ONE), tokenPrice_);\n        }\n\n        // calculates the delta between supply and redeem for currency and deposit or get them from the reserve\n        adjustCurrencyBalance(epochID, epochSupplyOrderCurrency, epochRedeemOrderCurrency);\n        // calculates the delta between supply and redeem for tokens and burn or mint them\n        adjustTokenBalance(epochID, supplyInToken, redeemInToken);\n\n        // the unfulfilled orders (1-fulfillment) is automatically ordered\n        totalSupply = safeAdd(safeTotalSub(totalSupply, epochSupplyOrderCurrency), rmul(epochSupplyOrderCurrency, safeSub(ONE, epochs[epochID].supplyFulfillment)));\n        totalRedeem = safeAdd(safeTotalSub(totalRedeem, redeemInToken), rmul(redeemInToken, safeSub(ONE, epochs[epochID].redeemFulfillment)));\n    }\n    \n    function closeEpoch() public auth returns (uint totalSupplyCurrency_, uint totalRedeemToken_) {\n        require(waitingForUpdate == false);\n        waitingForUpdate = true;\n        return (totalSupply, totalRedeem);\n    }\n\n    function safeBurn(uint tokenAmount) internal {\n        uint max = token.balanceOf(address(this));\n        if(tokenAmount > max) {\n            tokenAmount = max;\n        }\n        token.burn(address(this), tokenAmount);\n        emit Burn(address(this), tokenAmount);\n    }\n\n    function safePayout(uint currencyAmount) internal returns(uint payoutAmount) {\n        uint max = reserve.totalBalanceAvailable();\n\n        if(currencyAmount > max) {\n            // currently reserve can't fulfill the entire request\n            currencyAmount = max;\n        }\n        reserve.payout(currencyAmount);\n        return currencyAmount;\n    }\n\n    function payoutRequestedCurrency() public {\n        if(requestedCurrency > 0) {\n            uint payoutAmount = safePayout(requestedCurrency);\n            requestedCurrency = safeSub(requestedCurrency, payoutAmount);\n        }\n    }\n    // adjust token balance after epoch execution -> min/burn tokens\n    function adjustTokenBalance(uint epochID, uint epochSupplyToken, uint epochRedeemToken) internal {\n        // mint token amount for supply\n\n        uint mintAmount = 0;\n        if (epochs[epochID].tokenPrice > 0) {\n            mintAmount = rmul(epochSupplyToken, epochs[epochID].supplyFulfillment);\n        }\n\n        // burn token amount for redeem\n        uint burnAmount = rmul(epochRedeemToken, epochs[epochID].redeemFulfillment);\n        // burn tokens that are not needed for disbursement\n        uint diff;\n        if (burnAmount > mintAmount) {\n            diff = safeSub(burnAmount, mintAmount);\n            safeBurn(diff);\n            return;\n        }\n        // mint tokens that are required for disbursement\n        diff = safeSub(mintAmount, burnAmount);\n        if (diff > 0) {\n            token.mint(address(this), diff);\n        }\n    }\n\n    // additional minting of tokens produces a dilution of all token holders\n    // interface is required for adapters\n    function mint(address usr, uint amount) public auth {\n        token.mint(usr, amount);\n        emit Mint(usr, amount);\n    }\n\n    // adjust currency balance after epoch execution -> receive/send currency from/to reserve\n    function adjustCurrencyBalance(uint epochID, uint epochSupply, uint epochRedeem) internal {\n        // currency that was supplied in this epoch\n        uint currencySupplied = rmul(epochSupply, epochs[epochID].supplyFulfillment);\n        // currency required for redemption\n        uint currencyRequired = rmul(epochRedeem, epochs[epochID].redeemFulfillment);\n\n        uint diff;\n        if (currencySupplied > currencyRequired) {\n            // send surplus currency to reserve\n            diff = safeSub(currencySupplied, currencyRequired);\n            currency.approve(address(reserve), diff);\n            reserve.deposit(diff);\n            return;\n        }\n        diff = safeSub(currencyRequired, currencySupplied);\n        if (diff > 0) {\n            // get missing currency from reserve\n            uint payoutAmount = safePayout(diff);\n            if(payoutAmount < diff) {\n                // reserve couldn't fulfill the entire request\n                requestedCurrency = safeAdd(requestedCurrency, safeSub(diff, payoutAmount));\n            }\n        }\n    }\n\n    // recovery transfer can be used by governance to recover funds if tokens are stuck\n    function authTransfer(address erc20, address usr, uint amount) public auth {\n        ERC20Like_3(erc20).transfer(usr, amount);\n        emit AuthTransfer(erc20, usr, amount);\n    }\n\n    // due to rounding in token & currency conversions currency & token balances might be off by 1 wei with the totalSupply/totalRedeem amounts.\n    // in order to prevent an underflow error, 0 is returned when amount to be subtracted is bigger then the total value.\n    function safeTotalSub(uint total, uint amount) internal pure returns (uint) {\n        if (total < amount) {\n            return 0;\n        }\n        return safeSub(total, amount);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AuthTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contractName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Depend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"authTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"calcDisburse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payoutCurrencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingSupplyCurrency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingRedeemToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"}],\"name\":\"calcDisburse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payoutCurrencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingSupplyCurrency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingRedeemToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyCurrency_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRedeemToken_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coordinator\",\"outputs\":[{\"internalType\":\"contract CoordinatorLike_4\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"contract ERC20Like_3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"contractName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"depend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"disburse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payoutCurrencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingSupplyCurrency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingRedeemToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"}],\"name\":\"disburse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payoutCurrencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingSupplyCurrency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingRedeemToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyFulfillment_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemFulfillment_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochSupplyOrderCurrency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochRedeemOrderCurrency\",\"type\":\"uint256\"}],\"name\":\"epochUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemFulfillment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyFulfillment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutRequestedCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rdiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newRedeemAmount\",\"type\":\"uint256\"}],\"name\":\"redeemOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestedCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"contract ReserveLike_5\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rmul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"supplyOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20Like_3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderedInEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCurrencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"waitingForUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Tranche","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000715908cf310a741f085e8487ae981a0c2ff15f93","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}