{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.2;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IBridge {\\n    struct TONEvent {\\n        uint64 eventTransactionLt;\\n        uint32 eventTimestamp;\\n        bytes eventData;\\n        int8 configurationWid;\\n        uint256 configurationAddress;\\n        int8 eventContractWid;\\n        uint256 eventContractAddress;\\n        address proxy;\\n        uint32 round;\\n    }\\n\\n    struct Round {\\n        uint32 end;\\n        uint32 ttl;\\n        uint32 relays;\\n        uint32 requiredSignatures;\\n    }\\n\\n    struct TONAddress {\\n        int8 wid;\\n        uint256 addr;\\n    }\\n\\n    function updateMinimumRequiredSignatures(uint32 _minimumRequiredSignatures) external;\\n    function updateRoundRelaysConfiguration(TONAddress calldata _roundRelaysConfiguration) external;\\n    function updateRoundTTL(uint32 _roundTTL) external;\\n\\n    function isRelay(\\n        uint32 round,\\n        address candidate\\n    ) external view returns(bool);\\n\\n    function isBanned(\\n        address candidate\\n    ) external view returns(bool);\\n\\n    function isRoundRotten(\\n        uint32 round\\n    ) external view returns(bool);\\n\\n    function verifySignedTonEvent(\\n        bytes memory payload,\\n        bytes[] memory signatures\\n    ) external view returns(uint32);\\n\\n    function setRoundRelays(\\n        bytes calldata payload,\\n        bytes[] calldata signatures\\n    ) external;\\n\\n    function forceRoundRelays(\\n        uint160[] calldata _relays,\\n        uint32 roundEnd\\n    ) external;\\n\\n    function banRelays(\\n        address[] calldata _relays\\n    ) external;\\n\\n    function unbanRelays(\\n        address[] calldata _relays\\n    ) external;\\n\\n    function pause() external;\\n    function unpause() external;\\n\\n    function setRoundSubmitter(address _roundSubmitter) external;\\n\\n    event EmergencyShutdown(bool active);\\n\\n    event UpdateMinimumRequiredSignatures(uint32 value);\\n    event UpdateRoundTTL(uint32 value);\\n    event UpdateRoundRelaysConfiguration(TONAddress configuration);\\n    event UpdateRoundSubmitter(address _roundSubmitter);\\n\\n    event NewRound(uint32 indexed round, Round meta);\\n    event RoundRelay(uint32 indexed round, address indexed relay);\\n    event BanRelay(address indexed relay, bool status);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.2;\\n\\n\\ninterface IVault {\\n    struct TONAddress {\\n        int128 wid;\\n        uint256 addr;\\n    }\\n\\n    struct PendingWithdrawalId {\\n        address recipient;\\n        uint256 id;\\n    }\\n\\n    function saveWithdraw(\\n        bytes32 payloadId,\\n        address recipient,\\n        uint256 amount,\\n        uint256 bounty\\n    ) external;\\n\\n    function deposit(\\n        address sender,\\n        TONAddress calldata recipient,\\n        uint256 _amount,\\n        PendingWithdrawalId calldata pendingWithdrawalId,\\n        bool sendTransferToTon\\n    ) external;\\n\\n    function configuration() external view returns(TONAddress memory _configuration);\\n    function bridge() external view returns(address);\\n    function apiVersion() external view returns(string memory api_version);\\n\\n    function initialize(\\n        address _token,\\n        address _governance,\\n        address _bridge,\\n        address _wrapper,\\n        address guardian,\\n        address management\\n    ) external;\\n\\n    function governance() external view returns(address);\\n    function token() external view returns(address);\\n    function wrapper() external view returns(address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.2;\\n\\n\\ninterface IVaultWrapper {\\n    function initialize(address _vault) external;\\n    function apiVersion() external view returns(string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ChainId.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.2;\\n\\n\\ncontract ChainId {\\n    function getChainID() public view returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault/VaultWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.2;\\n\\nimport \\\"./../interfaces/IBridge.sol\\\";\\nimport \\\"./../interfaces/IVault.sol\\\";\\nimport \\\"./../interfaces/IVaultWrapper.sol\\\";\\nimport \\\"./../utils/ChainId.sol\\\";\\n\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\n\\ncontract VaultWrapper is ChainId, Initializable, IVaultWrapper {\\n    address constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;\\n    string constant API_VERSION = \\\"0.1.0\\\";\\n\\n    address public vault;\\n\\n    function initialize(\\n        address _vault\\n    ) external override initializer {\\n        vault = _vault;\\n    }\\n\\n    function apiVersion()\\n        external\\n        override\\n        pure\\n    returns (\\n        string memory api_version\\n    ) {\\n        return API_VERSION;\\n    }\\n\\n    /**\\n        @notice\\n            Most common entry point for Broxus Bridge.this\\n            Simply transfers tokens to the FreeTON side.\\n        @param recipient Recipient TON address\\n        @param amount Amount of tokens to be deposited\\n    */\\n    function deposit(\\n        IVault.TONAddress memory recipient,\\n        uint256 amount\\n    ) external {\\n        IVault.PendingWithdrawalId memory pendingWithdrawalId = IVault.PendingWithdrawalId(ZERO_ADDRESS, 0);\\n\\n        IVault(vault).deposit(\\n            msg.sender,\\n            recipient,\\n            amount,\\n            pendingWithdrawalId,\\n            true\\n        );\\n    }\\n\\n    /**\\n        @notice\\n            Special type of deposit, which allows to fill specified\\n            pending withdrawals. Set of fillings should be created off-chain.\\n            Usually allows depositor to receive additional reward (bounty) on the FreeTON side.\\n        @param recipient Recipient TON address\\n        @param amount Amount of tokens to be deposited, should be gte than sum(fillings)\\n        @param pendingWithdrawalsIdsToFill List of pending withdrawals ids\\n    */\\n    function depositWithFillings(\\n        IVault.TONAddress calldata recipient,\\n        uint256 amount,\\n        IVault.PendingWithdrawalId[] calldata pendingWithdrawalsIdsToFill\\n    ) external {\\n        require(\\n            pendingWithdrawalsIdsToFill.length > 0,\\n            'Wrapper: no pending withdrawals specified'\\n        );\\n\\n        for (uint i = 0; i < pendingWithdrawalsIdsToFill.length; i++) {\\n            IVault(vault).deposit(\\n                msg.sender,\\n                recipient,\\n                amount,\\n                pendingWithdrawalsIdsToFill[i],\\n                true\\n            );\\n        }\\n    }\\n\\n    function decodeWithdrawEventData(\\n        bytes memory payload\\n    ) public pure returns (\\n        int8 sender_wid,\\n        uint256 sender_addr,\\n        uint128 amount,\\n        uint160 _recipient,\\n        uint32 chainId\\n    ) {\\n        (IBridge.TONEvent memory tonEvent) = abi.decode(payload, (IBridge.TONEvent));\\n\\n        return abi.decode(\\n            tonEvent.eventData,\\n            (int8, uint256, uint128, uint160, uint32)\\n        );\\n    }\\n\\n    /**\\n        @notice Entry point for withdrawing tokens from the Broxus Bridge.\\n        Expects payload with withdraw details and list of relay's signatures.\\n        @param payload Bytes encoded `IBridge.TONEvent` structure\\n        @param signatures Set of relay's signatures\\n        @param bounty Pending withdraw bounty, can be set only by withdraw recipient. Ignores otherwise.\\n    */\\n    function saveWithdraw(\\n        bytes calldata payload,\\n        bytes[] calldata signatures,\\n        uint256 bounty\\n    ) external {\\n        address bridge = IVault(vault).bridge();\\n\\n        // Check signatures correct\\n        require(\\n            IBridge(bridge).verifySignedTonEvent(\\n                payload,\\n                signatures\\n            ) == 0,\\n            \\\"Vault wrapper: signatures verification failed\\\"\\n        );\\n\\n        // Decode TON event\\n        (IBridge.TONEvent memory tonEvent) = abi.decode(payload, (IBridge.TONEvent));\\n\\n        // dev: fix stack too deep\\n        {\\n            // Check event configuration matches Vault's configuration\\n            IVault.TONAddress memory configuration = IVault(vault).configuration();\\n\\n            require(\\n                tonEvent.configurationWid == configuration.wid &&\\n                tonEvent.configurationAddress == configuration.addr,\\n                \\\"Vault wrapper: wrong event configuration\\\"\\n            );\\n        }\\n\\n        // Decode event data\\n        (\\n            int8 sender_wid,\\n            uint256 sender_addr,\\n            uint128 amount,\\n            uint160 _recipient,\\n            uint32 chainId\\n        ) = decodeWithdrawEventData(payload);\\n\\n        // Check chain id\\n        require(chainId == getChainID(), \\\"Vault wrapper: wrong chain id\\\");\\n\\n        address recipient = address(_recipient);\\n\\n        IVault(vault).saveWithdraw(\\n            keccak256(payload),\\n            recipient,\\n            amount,\\n            recipient == msg.sender ? bounty : 0\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"apiVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"api_version\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"decodeWithdrawEventData\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"sender_wid\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"sender_addr\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint160\",\"name\":\"_recipient\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int128\",\"name\":\"wid\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"addr\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.TONAddress\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int128\",\"name\":\"wid\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"addr\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.TONAddress\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.PendingWithdrawalId[]\",\"name\":\"pendingWithdrawalsIdsToFill\",\"type\":\"tuple[]\"}],\"name\":\"depositWithFillings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"}],\"name\":\"saveWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VaultWrapper","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}