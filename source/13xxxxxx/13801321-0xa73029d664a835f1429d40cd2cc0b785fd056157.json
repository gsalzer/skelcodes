{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OptionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport \\\"./lib/OptionLib.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./interfaces/IOptionVault.sol\\\";\\nimport \\\"./interfaces/IAMM.sol\\\";\\n\\n/**\\n * @notice OptionVault contract is vaults for basic on-chain option contracts.\\n * It manages option tokens.\\n */\\ncontract OptionVault is IOptionVault, ERC1155, IERC1155Receiver {\\n    using OptionLib for OptionLib.OptionInfo;\\n\\n    /// @dev operator address\\n    address operator;\\n\\n    /// @dev AMM address\\n    address ammAddress;\\n\\n    /// @dev option info\\n    OptionLib.OptionInfo public optionInfo;\\n\\n    /// @dev price oracle contract\\n    PriceOracle priceOracle;\\n\\n    // events\\n    event ExpiryCreated(uint256 indexed expiryId, uint64 expiry);\\n    event SeriesCreated(uint256 indexed expiryId, uint256 seriesId, uint128 strike, bool isPut);\\n\\n    event AccountCreated(uint256 accountId, address indexed account);\\n    event VaultDeposited(uint256 indexed accountId, uint256 expiryId, uint128 amount);\\n    event VaultWithdrawn(uint256 indexed accountId, uint256 expiryId, uint128 amount);\\n    event Written(uint256 indexed accountId, uint256 seriesId, uint128 amount, address recipient);\\n    event Unlocked(uint256 indexed accountId, uint256 seriesId, uint128 amount, address holder);\\n    event Claimed(uint256 indexed seriesId, uint128 amount, uint128 profit);\\n    event Settled(uint256 accountId, uint256 indexed seriesId, uint128 profit);\\n    event Hedged(uint32 tickId, int256 tickDelta, int256 hedgePosition);\\n    event Liquidated(uint256 accountId, uint256 seriesId);\\n    event ConfigUpdated(uint8 key, uint128 value);\\n\\n    // modifiers\\n    modifier onlyVaultOwner(uint256 _accountId) {\\n        // if accountId is id of trader's vaults, check owner\\n        // if AMM vaults, check caller is AMM contract\\n        require(\\n            (msg.sender == optionInfo.getVaultOwner(_accountId) &&\\n                _accountId >= OptionLib.MIN_VAULT_ID &&\\n                _accountId < optionInfo.vaultCount) ||\\n                (msg.sender == ammAddress && _accountId < OptionLib.MIN_VAULT_ID),\\n            \\\"V1\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyAMMVault(uint256 _accountId) {\\n        require(_accountId < OptionLib.MIN_VAULT_ID, \\\"V2\\\");\\n        _;\\n    }\\n\\n    modifier notAMMVault(uint256 _accountId) {\\n        require(_accountId >= OptionLib.MIN_VAULT_ID, \\\"V3\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(msg.sender == operator, \\\"V4\\\");\\n        _;\\n    }\\n\\n    modifier onlyAMM() {\\n        require(msg.sender == ammAddress, \\\"V5\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory _uri,\\n        address _aggregator,\\n        address _collateral,\\n        address _underlying,\\n        address _priceOracle,\\n        address _operator,\\n        address _lendingPool\\n    ) ERC1155(_uri) {\\n        optionInfo.aggregator = _aggregator;\\n        priceOracle = PriceOracle(_priceOracle);\\n\\n        operator = _operator;\\n\\n        optionInfo.init(_collateral, _underlying, _lendingPool);\\n    }\\n\\n    function onERC1155Received(\\n        address _operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    ) external override(IERC1155Receiver) returns (bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) external override(IERC1155Receiver) returns (bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    }\\n\\n    function isApprovedForAll(address account, address _operator) public view virtual override returns (bool) {\\n        return super.isApprovedForAll(account, _operator) || _operator == address(this) || _operator == ammAddress;\\n    }\\n\\n    /**\\n     * @notice set AMM address\\n     * @param _ammAddress amm address\\n     */\\n    function setAMMAddress(address _ammAddress) external {\\n        require(ammAddress == address(0));\\n        ammAddress = _ammAddress;\\n        setApprovalForAll(ammAddress, true);\\n    }\\n\\n    /**\\n     * @notice set IV by AMM contract\\n     * @param _seriesId series id\\n     * @param _iv new implied volatility\\n     */\\n    function setIV(uint256 _seriesId, uint128 _iv) external override(IOptionVault) onlyAMM {\\n        optionInfo.setIV(_seriesId, _iv);\\n    }\\n\\n    /**\\n     * @notice create new vault\\n     */\\n    function createAccount() public override(IOptionVault) returns (uint256) {\\n        uint256 accountId = optionInfo.createAccount(msg.sender);\\n\\n        emit AccountCreated(accountId, msg.sender);\\n\\n        return accountId;\\n    }\\n\\n    /**\\n     * @notice deposit collateral to the vault\\n     * @param _accountId vault id\\n     * @param _collateral amount to deposit scaled by 1e6\\n     */\\n    function deposit(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_collateral > 0, \\\"V9\\\");\\n\\n        optionInfo.deposit(_accountId, _expiryId, _collateral);\\n\\n        IERC20(optionInfo.tokens.collateral).transferFrom(msg.sender, address(this), _collateral);\\n\\n        emit VaultDeposited(_accountId, _expiryId, _collateral);\\n    }\\n\\n    /**\\n     * @notice withdraw collateral from the vault\\n     * @param _accountId vault id\\n     * @param _expiryId expiry id\\n     * @param _collateral amount to withdraw scaled by 1e6\\n     */\\n    function withdraw(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_collateral > 0, \\\"V9\\\");\\n\\n        uint128 spot = getPrice();\\n\\n        optionInfo.withdraw(_accountId, _expiryId, _collateral, spot);\\n\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, _collateral);\\n\\n        emit VaultWithdrawn(_accountId, _expiryId, _collateral);\\n    }\\n\\n    /**\\n     * @notice close short position and withdraw unrequired collateral from the vault\\n     * @param _accountId account id\\n     * @param _seriesId series id to close\\n     * @param _amount the amount to close\\n     * @param _cRatio the final IM ratio(IM / collateral)\\n     */\\n    function closeShortPosition(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _cRatio\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) returns (uint128) {\\n        require(0 < _cRatio && _cRatio <= 1e6, \\\"V6\\\");\\n\\n        if (_amount > 0) {\\n            require(balanceOf(msg.sender, _seriesId) >= _amount, \\\"V7\\\");\\n\\n            // unlock options\\n            optionInfo.unlock(_accountId, _seriesId, _amount);\\n\\n            _burn(msg.sender, _seriesId, _amount);\\n\\n            emit Unlocked(_accountId, _seriesId, _amount, msg.sender);\\n        }\\n\\n        bool isPool = _accountId < OptionLib.MIN_VAULT_ID;\\n\\n        uint256 expiryId = optionInfo.serieses[_seriesId].expiryId;\\n        uint128 unrequiredCollateral = optionInfo.withdrawUnrequiredCollateral(\\n            _accountId,\\n            expiryId,\\n            getPrice(),\\n            _cRatio,\\n            isPool\\n        );\\n\\n        if (unrequiredCollateral > 0) {\\n            IERC20(optionInfo.tokens.collateral).transfer(msg.sender, unrequiredCollateral);\\n\\n            emit VaultWithdrawn(_accountId, expiryId, unrequiredCollateral);\\n        }\\n\\n        return unrequiredCollateral;\\n    }\\n\\n    /**\\n     * @notice lock collateral and mint option tokens\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @param _amount amount to write scaled by 1e8\\n     * @param _recipient recipient of option tokens\\n     */\\n    function write(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        address _recipient\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        uint128 spot = getPrice();\\n\\n        // write options\\n        optionInfo.write(_accountId, _seriesId, _amount, spot);\\n\\n        _mint(_recipient, _seriesId, _amount, \\\"\\\");\\n\\n        emit Written(_accountId, _seriesId, _amount, _recipient);\\n    }\\n\\n    /**\\n     * @notice deposit collateral and write options in one transaction\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @param _cRatio _collateral ratio of Initial Margin\\n     * @param _amount amount to write scaled by 1e8\\n     * @param _recipient recipient of option tokens\\n     */\\n    function depositAndWrite(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _cRatio,\\n        uint128 _amount,\\n        address _recipient\\n    ) public override(IOptionVault) onlyVaultOwner(_accountId) returns (uint128) {\\n        require(_amount > 0, \\\"V9\\\");\\n        require(0 < _cRatio && _cRatio <= 1e6, \\\"V6\\\");\\n\\n        bool isPool = _accountId < OptionLib.MIN_VAULT_ID;\\n\\n        // deposit collateral and write options\\n        (uint256 expiryId, uint128 collateral) = optionInfo.depositAndWrite(\\n            _accountId,\\n            _seriesId,\\n            _amount,\\n            _cRatio,\\n            getPrice(),\\n            isPool\\n        );\\n\\n        IERC20(optionInfo.tokens.collateral).transferFrom(msg.sender, address(this), collateral);\\n\\n        _mint(_recipient, _seriesId, _amount, \\\"\\\");\\n\\n        emit VaultDeposited(_accountId, expiryId, collateral);\\n        emit Written(_accountId, _seriesId, _amount, _recipient);\\n\\n        return collateral;\\n    }\\n\\n    /**\\n     * @notice add long position to calculate net delta\\n     */\\n    function addLong(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        uint128 longSize = optionInfo.addLong(_accountId, _expiryId, _seriesId, _amount);\\n\\n        require(balanceOf(msg.sender, _seriesId) >= longSize, \\\"V10\\\");\\n    }\\n\\n    /**\\n     * @notice remove long position to calculate net delta\\n     */\\n    function removeLong(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external override(IOptionVault) onlyVaultOwner(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        optionInfo.removeLong(_accountId, _expiryId, _seriesId, _amount);\\n    }\\n\\n    /**\\n     * @notice swap collateral asset for underling asset to hedge vault's delta\\n     * @param _accountId the id of target vault\\n     * @param _underlyingAmount amount of underlying asset scaled by 1e8\\n     * @param _collateralAmount amount of collateral asset scaled by 1e6\\n     */\\n    function addUnderlyingLong(\\n        uint32 _accountId,\\n        uint256 _expiryId,\\n        uint256 _underlyingAmount,\\n        uint256 _collateralAmount\\n    ) external onlyAMMVault(_accountId) {\\n        uint128 spot = getPrice();\\n\\n        // calculate vault's net delta\\n        int256 vaultDelta = optionInfo.calculateVaultDelta(_accountId, _expiryId, spot);\\n\\n        // swap collateral asset for underling asset\\n        int256 hedgePosition = optionInfo.addUnderlyingLong(\\n            _accountId,\\n            _expiryId,\\n            spot,\\n            vaultDelta,\\n            _underlyingAmount,\\n            _collateralAmount\\n        );\\n\\n        emit Hedged(_accountId, vaultDelta, hedgePosition);\\n    }\\n\\n    /**\\n     * @notice swap underling asset for collateral asset to hedge vaults' delta\\n     * @param _accountId the id of target vault\\n     * @param _underlyingAmount amount of underlying asset scaled by 1e8\\n     * @param _collateralAmount amount of collateral asset scaled by 1e6\\n     */\\n    function addUnderlyingShort(\\n        uint32 _accountId,\\n        uint256 _expiryId,\\n        uint256 _underlyingAmount,\\n        uint256 _collateralAmount\\n    ) external onlyAMMVault(_accountId) {\\n        uint128 spot = getPrice();\\n\\n        // calculate vault's net delta\\n        int256 vaultDelta = optionInfo.calculateVaultDelta(_accountId, _expiryId, spot);\\n\\n        // swap underling asset for collateral asset\\n        int256 hedgePosition = optionInfo.addUnderlyingShort(\\n            _accountId,\\n            _expiryId,\\n            spot,\\n            vaultDelta,\\n            _underlyingAmount,\\n            _collateralAmount\\n        );\\n\\n        emit Hedged(_accountId, vaultDelta, hedgePosition);\\n    }\\n\\n    /**\\n     * @notice repay all underlying asset and withdraw collateral from AAVE\\n     * @param _repayAmount amount to repay\\n     */\\n    function redeemCollateralFromLendingPool(uint128 _repayAmount) external onlyOperator {\\n        optionInfo.redeemCollateralFromLendingPool(\\n            _repayAmount,\\n            getPrice(),\\n            msg.sender,\\n            address(IAMM(ammAddress).feePool())\\n        );\\n    }\\n\\n    /**\\n     * @notice burn options and get collateral from a vault that requires liquidation\\n     * to save the profit of option holders.\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @param _amount amount to liquidate scaled by 1e8\\n     */\\n    function liquidate(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external notAMMVault(_accountId) {\\n        require(_amount > 0, \\\"V9\\\");\\n\\n        require(balanceOf(msg.sender, _seriesId) >= _amount, \\\"V7\\\");\\n\\n        uint128 price = getPrice();\\n\\n        uint128 reward = optionInfo.liquidate(_accountId, _seriesId, _amount, price);\\n\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, reward);\\n\\n        _burn(msg.sender, _seriesId, _amount);\\n\\n        emit Liquidated(_accountId, _seriesId);\\n    }\\n\\n    /**\\n     * @notice claim profit of some amount of expired option contracts.\\n     * @param _seriesId option series id\\n     * @param _size option size to claim profit scaled by 1e8\\n     */\\n    function claim(uint256 _seriesId, uint128 _size) external override(IOptionVault) returns (uint128) {\\n        IOptionVault.OptionSeries storage series = optionInfo.serieses[_seriesId];\\n\\n        require(balanceOf(msg.sender, _seriesId) >= _size, \\\"V7\\\");\\n\\n        uint256 price = getExpiryPrice(series.expiryId);\\n\\n        uint128 payout = optionInfo.claimProfit(_seriesId, _size, uint128(price));\\n\\n        // burn options\\n        _burn(msg.sender, _seriesId, _size);\\n\\n        // send payout to option holder\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, payout);\\n\\n        emit Claimed(_seriesId, _size, payout);\\n\\n        return payout;\\n    }\\n\\n    /**\\n     * @notice settle a vault\\n     * fix the payout of an expired vault and send collateral in the vault to vault's owner\\n     * @param _accountId vault id\\n     * @param _expiryId option series id\\n     */\\n    function settleVault(uint256 _accountId, uint256 _expiryId) external override(IOptionVault) returns (uint128) {\\n        // anyone can settle trader's vault, but only AMM contract can settle AMM's vault\\n        require(\\n            (_accountId >= OptionLib.MIN_VAULT_ID && _accountId < optionInfo.vaultCount) ||\\n                (msg.sender == ammAddress && _accountId < OptionLib.MIN_VAULT_ID),\\n            \\\"V8\\\"\\n        );\\n\\n        uint256 price = getExpiryPrice(_expiryId);\\n\\n        uint128 settledAmount = optionInfo.settle(_accountId, _expiryId, uint128(price));\\n\\n        if (settledAmount > 0) {\\n            // send all vault's collateral to owner\\n            if (_accountId < OptionLib.MIN_VAULT_ID) {\\n                IERC20(optionInfo.tokens.collateral).transfer(ammAddress, settledAmount);\\n            } else {\\n                IERC20(optionInfo.tokens.collateral).transfer(optionInfo.getVaultOwner(_accountId), settledAmount);\\n            }\\n        }\\n\\n        emit Settled(_accountId, _expiryId, settledAmount);\\n\\n        return settledAmount;\\n    }\\n\\n    ////////////////////////\\n    // Wrapper Functions //\\n    ////////////////////////\\n\\n    function makeShortPosition(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _cRatio,\\n        uint128 _amount,\\n        uint128 _minFee\\n    ) external {\\n        uint256 accountId = _accountId;\\n\\n        if (accountId == 0) {\\n            accountId = createAccount();\\n        }\\n\\n        depositAndWrite(accountId, _seriesId, _cRatio, _amount, address(this));\\n\\n        uint128 premium = IAMM(ammAddress).sell(_seriesId, _amount, _minFee);\\n\\n        IERC20(optionInfo.tokens.collateral).transfer(msg.sender, premium);\\n    }\\n\\n    ////////////////////////\\n    // Operator Functions //\\n    ////////////////////////\\n\\n    /**\\n     * @notice create new expiration\\n     * @param _expiry expiration\\n     * @param _strikes strike prices\\n     * @param _callIVs initial call ivs\\n     * @param _putIVs initial put ivs\\n     */\\n    function createExpiry(\\n        uint64 _expiry,\\n        uint64[] memory _strikes,\\n        uint64[] memory _callIVs,\\n        uint64[] memory _putIVs\\n    ) external onlyOperator {\\n        uint128 expiryId = optionInfo.createExpiry(_expiry);\\n\\n        for (uint256 i = 0; i < _strikes.length; i++) {\\n            createSeries(expiryId, _strikes[i], false, _callIVs[i]);\\n            createSeries(expiryId, _strikes[i], true, _putIVs[i]);\\n        }\\n\\n        emit ExpiryCreated(expiryId, _expiry);\\n    }\\n\\n    /**\\n     * @notice update a config value\\n     */\\n    function setConfig(uint8 _key, uint128 _value) external onlyOperator {\\n        require(_value > 0);\\n        optionInfo.setConfig(_key, _value);\\n\\n        // emit event\\n        emit ConfigUpdated(_key, _value);\\n    }\\n\\n    /**\\n     * @notice set new operator\\n     * @param _operator operator address\\n     */\\n    function setNewOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    //////////////////////\\n    // Getter Functions //\\n    //////////////////////\\n\\n    /**\\n     * @notice get an expiration\\n     */\\n    function getExpiration(uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (IOptionVault.Expiration memory)\\n    {\\n        return optionInfo.expiries[_expiryId];\\n    }\\n\\n    /**\\n     * @notice get an option series\\n     */\\n    function getOptionSeries(uint256 _seriesId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (IOptionVault.OptionSeriesView memory)\\n    {\\n        return optionInfo.getOptionSeriesView(_seriesId);\\n    }\\n\\n    /**\\n     * @notice get list of live option serieses\\n     */\\n    function getLiveOptionSerieses() external view override(IOptionVault) returns (IOptionVault.Expiration[] memory) {\\n        return optionInfo.getLiveOptionSerieses();\\n    }\\n\\n    /**\\n     * @notice get timestamp of the last expiry\\n     */\\n    function getLastExpiry() external view override(IOptionVault) returns (uint64) {\\n        return optionInfo.expiries[optionInfo.expiryCount - 1].expiry;\\n    }\\n\\n    /**\\n     * @notice get total collateral value of a vault\\n     * @param _accountId vault id\\n     */\\n    function getCollateralValueQuote(uint256 _accountId) external view override(IOptionVault) returns (uint128) {\\n        return optionInfo.getCollateralValueQuote(_accountId, getPrice());\\n    }\\n\\n    /**\\n     * @notice get required margin of a vault\\n     * there are 3 margin levels\\n     * 1. Maintenance Margin: vaults can be liquidated if the collateral is lower than MM\\n     * 2. Initial Margin: collateral must be greater than IM to write options\\n     * 3. Safe Margin: enough margin for delta hedging\\n     * @param _accountId vault id\\n     * @param _expiryId expiry id\\n     * @param _marginLevel margin level\\n     */\\n    function getRequiredMargin(\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view override(IOptionVault) returns (uint128) {\\n        uint128 price = getPrice();\\n\\n        return optionInfo.getRequiredMargin(_accountId, _expiryId, price, _marginLevel);\\n    }\\n\\n    /**\\n     * @notice calculate required margin for a series\\n     * @param _seriesId series id\\n     * @param _amount amount of options. plus for short and minus for long\\n     * @param _marginLevel margin level\\n     */\\n    function calRequiredMarginForASeries(\\n        uint256 _seriesId,\\n        int128 _amount,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view override(IOptionVault) returns (uint128) {\\n        IOptionVault.OptionSeries memory series = optionInfo.serieses[_seriesId];\\n\\n        return optionInfo.getRequiredMarginForASeries(series.expiryId, _seriesId, getPrice(), _amount, _marginLevel);\\n    }\\n\\n    /**\\n     * @notice get total payout of a vault\\n     * @param _accountId vault id\\n     * @param _expiryId expiry id\\n     */\\n    function getTotalPayout(uint256 _accountId, uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (uint128)\\n    {\\n        return optionInfo.getTotalPayout(_accountId, _expiryId, getPrice(), false);\\n    }\\n\\n    /**\\n     * @notice get liquidatable amount of a vault\\n     * @param _accountId vault id\\n     * @param _seriesId series id\\n     */\\n    function getLiquidatableAmount(uint256 _accountId, uint256 _seriesId) external view returns (uint128 limit) {\\n        return optionInfo.getLiquidatableAmount(_accountId, _seriesId, getPrice());\\n    }\\n\\n    function getAccount(uint256 _accountId) external view override(IOptionVault) returns (AccountView memory) {\\n        Account storage account = optionInfo.accounts[_accountId];\\n        return AccountView(account.owner, account.settledCount);\\n    }\\n\\n    function getVault(uint256 _accountId, uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (VaultView memory)\\n    {\\n        Vault storage vault = optionInfo.accounts[_accountId].vaults[_expiryId];\\n        return\\n            VaultView(\\n                optionInfo.accounts[_accountId].owner,\\n                vault.isSettled,\\n                vault.collateral,\\n                vault.hedgePosition,\\n                vault.shortLiquidity\\n            );\\n    }\\n\\n    /**\\n     * @notice get position size\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @return (short size, long size)\\n     */\\n    function getPositionSize(uint256 _accountId, uint256 _seriesId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (uint128, uint128)\\n    {\\n        return optionInfo.getPositionSize(_accountId, _seriesId);\\n    }\\n\\n    /**\\n     * @notice get vault's net delta\\n     * @param _accountId vault id\\n     */\\n    function calculateVaultDelta(uint256 _accountId, uint256 _expiryId)\\n        external\\n        view\\n        override(IOptionVault)\\n        returns (int256)\\n    {\\n        return optionInfo.calculateVaultDelta(_accountId, _expiryId, getPrice());\\n    }\\n\\n    /**\\n     * @notice get a config value\\n     */\\n    function getConfig(uint8 _key) external view returns (uint128) {\\n        return optionInfo.configs[_key];\\n    }\\n\\n    ///////////////////////\\n    // Private Functions //\\n    ///////////////////////\\n\\n    function createSeries(\\n        uint128 _expiryId,\\n        uint64 _strike,\\n        bool _isPut,\\n        uint64 _iv\\n    ) internal {\\n        uint256 seriesId = optionInfo.createSeries(_expiryId, _strike, _isPut, _iv);\\n        emit SeriesCreated(_expiryId, seriesId, _strike, _isPut);\\n    }\\n\\n    function getExpiryPrice(uint256 _expiryId) internal view returns (uint256) {\\n        IOptionVault.Expiration storage expiration = optionInfo.expiries[_expiryId];\\n\\n        (uint256 price, bool isFinalized) = priceOracle.getExpiryPrice(optionInfo.aggregator, expiration.expiry);\\n\\n        require(isFinalized, \\\"V11\\\");\\n\\n        return price;\\n    }\\n\\n    function getPrice() internal view returns (uint128) {\\n        (uint256 spot, ) = priceOracle.getPrice(optionInfo.aggregator);\\n        return uint128(spot);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155).interfaceId\\n            || interfaceId == type(IERC1155MetadataURI).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][from] = fromBalance - amount;\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            _balances[id][from] = fromBalance - amount;\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        _balances[id][account] = accountBalance - amount;\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal\\n        virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OptionLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./PriceCalculator.sol\\\";\\nimport \\\"../interfaces/IAave.sol\\\";\\nimport \\\"../interfaces/IHedge.sol\\\";\\nimport \\\"../interfaces/IOptionVault.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IFeePool.sol\\\";\\nimport \\\"./PredyMath.sol\\\";\\n\\n/**\\n * @title OptionLib\\n */\\nlibrary OptionLib {\\n    using PredyMath for uint128;\\n\\n    struct TokenContracts {\\n        // collateral token\\n        address collateral;\\n        // underlying token\\n        address underlying;\\n    }\\n\\n    /// @dev option information\\n    struct OptionInfo {\\n        address aggregator;\\n        TokenContracts tokens;\\n        // counter of serieses\\n        uint128 seriesCount;\\n        uint128 expiryCount;\\n        uint128 expiredCount;\\n        // expiration => seriesId => option series\\n        mapping(uint256 => IOptionVault.Expiration) expiries;\\n        //\\n        mapping(uint256 => IOptionVault.OptionSeries) serieses;\\n        // counter of vaults\\n        uint256 vaultCount;\\n        // accountId => IOptionVault.Account\\n        uint128 totalDepositedToLendingPool;\\n        mapping(uint256 => IOptionVault.Account) accounts;\\n        // config\\n        mapping(uint8 => uint128) configs;\\n        //\\n        LendingPool lendingPool;\\n    }\\n\\n    uint8 public constant MM_RATIO = 1;\\n    uint8 public constant IM_RATIO = 2;\\n    uint8 public constant CALL_SAFE_RATIO = 3;\\n    uint8 public constant PUT_SAFE_RATIO = 4;\\n    uint8 public constant SLIPPAGE_TOLERANCE = 5;\\n    uint8 public constant BASE_LIQ_REWARD = 8;\\n    uint8 public constant REWARD_PER_SIZE_RATIO = 9;\\n\\n    /// @dev minimum vault id.\\n    /// trader's vault id is larger than MIN_VAULT_ID\\n    uint128 public constant MIN_VAULT_ID = 100;\\n\\n    uint256 constant MAX_UINT256 = 2**256 - 1;\\n\\n    modifier existsExpiry(uint256 _expiryId, uint128 _expiryCount) {\\n        require(_expiryId > 0 && _expiryId < _expiryCount, \\\"OptionLib: expiry not found\\\");\\n        _;\\n    }\\n\\n    modifier existsSeries(uint256 _seriesId, uint128 _seriesCount) {\\n        require(_seriesId > 0 && _seriesId < _seriesCount, \\\"OptionLib: series not found\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice initialize OptionInfo\\n     */\\n    function init(\\n        OptionInfo storage _optionInfo,\\n        address _collateral,\\n        address _underlying,\\n        address _lendingPool\\n    ) external {\\n        // initialize states\\n        _optionInfo.expiredCount = 0;\\n        _optionInfo.expiryCount = 1;\\n        _optionInfo.seriesCount = 1;\\n        _optionInfo.vaultCount = OptionLib.MIN_VAULT_ID;\\n\\n        // initialize configs\\n        // 10%\\n        _optionInfo.configs[MM_RATIO] = 100;\\n        // 20%\\n        _optionInfo.configs[IM_RATIO] = 200;\\n        // 120%\\n        _optionInfo.configs[CALL_SAFE_RATIO] = 1200;\\n        // 120%\\n        _optionInfo.configs[PUT_SAFE_RATIO] = 1200;\\n        // 0.5%\\n        _optionInfo.configs[SLIPPAGE_TOLERANCE] = 50;\\n        // $100\\n        _optionInfo.configs[BASE_LIQ_REWARD] = 100 * 1e6;\\n        // 9%\\n        _optionInfo.configs[REWARD_PER_SIZE_RATIO] = 90;\\n\\n        // set contract addresses\\n        _optionInfo.tokens.collateral = _collateral;\\n        _optionInfo.tokens.underlying = _underlying;\\n        _optionInfo.lendingPool = LendingPool(_lendingPool);\\n    }\\n\\n    function setIV(\\n        OptionInfo storage _optionInfo,\\n        uint256 _seriesId,\\n        uint128 _iv\\n    ) external {\\n        _optionInfo.serieses[_seriesId].iv = uint64(_iv);\\n    }\\n\\n    /**\\n     * @notice create new option series\\n     * the option series must have later expiry than existence serieses\\n     */\\n    function createExpiry(OptionInfo storage _optionInfo, uint64 _expiry) external returns (uint128 expiryId) {\\n        // check expiry is greater than or equal to last created\\n        uint64 lastExpiry;\\n        if (_optionInfo.expiryCount > 0) {\\n            lastExpiry = _optionInfo.expiries[_optionInfo.expiryCount - 1].expiry;\\n        }\\n\\n        require(_expiry >= block.timestamp, \\\"OptionLib: expiry must be greater than now\\\");\\n        require(_expiry >= lastExpiry, \\\"OptionLib: expiry must be greater than or equal to last created\\\");\\n        require(_expiry % 1 hours == 0, \\\"OptionLib: expiry must be formatted\\\");\\n\\n        // create series\\n        expiryId = _optionInfo.expiryCount;\\n        _optionInfo.expiries[expiryId].expiryId = expiryId;\\n        _optionInfo.expiries[expiryId].expiry = _expiry;\\n\\n        _optionInfo.expiryCount += 1;\\n    }\\n\\n    function createSeries(\\n        OptionInfo storage _optionInfo,\\n        uint128 _expiryId,\\n        uint64 _strike,\\n        bool _isPut,\\n        uint64 _iv\\n    ) external returns (uint256 seriesId) {\\n        require(_strike > 0 && _strike < 1e16, \\\"OptionLib: strike must be greater than 0 and less than $100M\\\");\\n        require(_iv > 0 && _iv < 1000 * 1e6, \\\"OptionLib: iv must be greater than 0 and less than 1000%\\\");\\n\\n        seriesId = _optionInfo.seriesCount;\\n\\n        // create series\\n        _optionInfo.serieses[seriesId] = IOptionVault.OptionSeries(_strike, _isPut, _iv, _expiryId);\\n        _optionInfo.expiries[_expiryId].seriesIds.push(seriesId);\\n\\n        _optionInfo.seriesCount += 1;\\n    }\\n\\n    function createAccount(OptionInfo storage _optionInfo, address owner) external returns (uint256) {\\n        uint256 id = _optionInfo.vaultCount;\\n\\n        IOptionVault.Account storage account = _optionInfo.accounts[id];\\n        account.owner = owner;\\n        account.settledCount = _optionInfo.expiredCount;\\n\\n        _optionInfo.vaultCount += 1;\\n\\n        return id;\\n    }\\n\\n    function deposit(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _amount\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        require(!vault.isSettled, \\\"Vault already settled\\\");\\n\\n        increaseCollateral(vault, _amount);\\n    }\\n\\n    function withdraw(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _amount,\\n        uint128 _spot\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[_expiryId]);\\n\\n        decreaseCollateral(vault, _amount);\\n\\n        checkCollateral(_optionInfo, _accountId, _expiryId, _spot);\\n    }\\n\\n    function withdrawUnrequiredCollateral(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        uint128 _cRatio,\\n        bool _isPool\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (uint128) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[_expiryId]);\\n\\n        uint128 collateralValue = getCollateralValue(_optionInfo, _accountId, _expiryId, _spot);\\n\\n        uint128 requiredCollateral = (1e6 *\\n            getRequiredMargin(\\n                _optionInfo,\\n                _accountId,\\n                _expiryId,\\n                _spot,\\n                _isPool ? IOptionVault.MarginLevel.Safe : IOptionVault.MarginLevel.Initial\\n            )) / _cRatio;\\n\\n        if (collateralValue > requiredCollateral) {\\n            return decreaseCollateral(vault, collateralValue - requiredCollateral);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function write(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _spot\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.OptionSeries storage series = _optionInfo.serieses[_seriesId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[series.expiryId]);\\n\\n        account.vaults[series.expiryId].shorts[_seriesId] += _amount;\\n\\n        checkCollateral(_optionInfo, _accountId, series.expiryId, _spot);\\n    }\\n\\n    function unlock(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) {\\n        IOptionVault.OptionSeries storage series = _optionInfo.serieses[_seriesId];\\n\\n        _optionInfo.accounts[_accountId].vaults[series.expiryId].shorts[_seriesId] -= _amount;\\n    }\\n\\n    function depositAndWrite(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _cRatio,\\n        uint128 _spot,\\n        bool _isPool\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint256 expiryId, uint128 collateral) {\\n        expiryId = _optionInfo.serieses[_seriesId].expiryId;\\n\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[expiryId];\\n\\n        checkOptionSeriesIsLive(_optionInfo.expiries[expiryId]);\\n\\n        account.vaults[expiryId].shorts[_seriesId] += _amount;\\n\\n        collateral = getCollateralForASeries(_optionInfo, expiryId, _seriesId, _spot, _amount, _cRatio, _isPool);\\n\\n        increaseCollateral(vault, collateral);\\n    }\\n\\n    function addLong(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint128) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n\\n        account.vaults[_expiryId].longs[_seriesId] += _amount;\\n\\n        return account.vaults[_expiryId].longs[_seriesId];\\n    }\\n\\n    function removeLong(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n\\n        account.vaults[_expiryId].longs[_seriesId] -= _amount;\\n    }\\n\\n    /**\\n     * @notice liquidate a vault\\n     * the amount that liquidator can burn is '(BASE_REWRD + MM - C) / (mm - premium - REWARD_RATIO * (St or K))'\\n     * where C = vault.collateral\\n     * , MM current maintenance margin\\n     * and mm is maintenance margin per size\\n     */\\n    function liquidate(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _spot\\n    ) external existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint128) {\\n        IOptionVault.OptionSeries memory option = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[option.expiryId];\\n\\n        uint128 shortAmount = vault.shorts[_seriesId];\\n\\n        require(shortAmount >= _amount, \\\"OptionLib: amount exceeds vault size\\\");\\n\\n        uint128 collateralValue = getCollateralValue(_optionInfo, _accountId, option.expiryId, _spot);\\n\\n        uint128 limit;\\n        {\\n            uint128 maintenanceMargin = getRequiredMargin(\\n                _optionInfo,\\n                _accountId,\\n                option.expiryId,\\n                _spot,\\n                IOptionVault.MarginLevel.Maintenance\\n            );\\n            require(collateralValue < maintenanceMargin, \\\"OptionLib: collateral must be less than MM\\\");\\n\\n            limit = calLiquidatableAmount(\\n                _optionInfo,\\n                maintenanceMargin,\\n                collateralValue,\\n                option.isPut ? option.strike : _spot\\n            );\\n        }\\n\\n        require(limit >= _amount, \\\"OptionLib: amount exceeds liquidatable limit\\\");\\n\\n        vault.shorts[_seriesId] -= _amount;\\n\\n        uint128 reward;\\n        {\\n            uint128 maintenanceMargin = getRequiredMargin(\\n                _optionInfo,\\n                _accountId,\\n                option.expiryId,\\n                _spot,\\n                IOptionVault.MarginLevel.Maintenance\\n            );\\n\\n            require(collateralValue >= maintenanceMargin, \\\"OptionLib: margin must be safe\\\");\\n            reward = collateralValue - maintenanceMargin;\\n        }\\n\\n        return decreaseCollateral(vault, reward);\\n    }\\n\\n    /**\\n     * @notice calculate profit of some amount of option contracts\\n     */\\n    function claimProfit(\\n        OptionInfo storage _optionInfo,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _price\\n    ) external view existsSeries(_seriesId, _optionInfo.seriesCount) returns (uint128) {\\n        uint128 payout = calculatePayout(\\n            _amount,\\n            _price,\\n            _optionInfo.serieses[_seriesId].strike,\\n            _optionInfo.serieses[_seriesId].isPut,\\n            false\\n        );\\n\\n        return payout;\\n    }\\n\\n    /**\\n     * @notice fix payout of a vault and remove the payout from vault's collaterals\\n     * @return settledAmount the amount that the vault owner can redeem\\n     */\\n    function settle(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _price\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (uint128 settledAmount) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n\\n        uint128 payout = getTotalPayout(_optionInfo, _accountId, _expiryId, _price, true);\\n\\n        require(!vault.isSettled, \\\"OptionLib: vault already settled\\\");\\n\\n        require(vault.hedgePosition == 0, \\\"OptionLib: hedge position must be neutral\\\");\\n\\n        // all collaterals in Aave must be redeemed before settlement\\n        require(vault.shortLiquidity == 0, \\\"OptionLib: all collaterals must be withdrawn\\\");\\n\\n        require(account.settledCount < _expiryId, \\\"OptionLib: vault already settled\\\");\\n\\n        for (uint256 i = account.settledCount + 1; i < _expiryId; i++) {\\n            uint128 skippedCollateral = account.vaults[i].collateral;\\n            require(skippedCollateral == 0, \\\"OptionLib: can not skip expiry\\\");\\n        }\\n\\n        vault.isSettled = true;\\n        account.settledCount = _expiryId;\\n\\n        updateExpiredCount(_optionInfo, _expiryId);\\n\\n        decreaseCollateral(vault, payout);\\n\\n        settledAmount = vault.collateral;\\n    }\\n\\n    /*\\n     * addUnderlyingLong and addUnderlyingShort are functions to achieve delta neutral.\\n     * vault's net delta is calculated as vaultDelta, and the protocol wanna make (vaultDelta + vault.hedgePosition) zero.\\n     * hedgePosition exactly represents how many underlying asset the vault has,\\n     * and negative hedgePosition means short position of underlying asset.\\n     */\\n\\n    /**\\n     * @notice receive underlying asset and send collateral asset to sender\\n     * @param _vaultDelta net delta of the vault\\n     * @param _underlyingAmountE8 amount of underlying asset scaled by 1e8\\n     */\\n    function addUnderlyingLong(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        int256 _vaultDelta,\\n        uint256 _underlyingAmountE8,\\n        uint256 _collateralAmount\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (int256) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n        ERC20 underlying = ERC20(_optionInfo.tokens.underlying);\\n\\n        uint256 decimals = underlying.decimals();\\n\\n        require(_vaultDelta + vault.hedgePosition < 0, \\\"OptionLib: net delta must be negative\\\");\\n\\n        require(\\n            -(_vaultDelta + vault.hedgePosition) >= int256(_underlyingAmountE8),\\n            \\\"OptionLib: underlying amount is too large\\\"\\n        );\\n\\n        if (-(_vaultDelta + vault.hedgePosition) < int256(_underlyingAmountE8)) {\\n            _underlyingAmountE8 = uint256(-(_vaultDelta + vault.hedgePosition));\\n        }\\n\\n        require(\\n            (PredyMath.scale(_spot * _underlyingAmountE8, 16, 6) * (10000 + _optionInfo.configs[SLIPPAGE_TOLERANCE])) /\\n                10000 >=\\n                _collateralAmount,\\n            \\\"OptionLib: collateral amount is too large\\\"\\n        );\\n\\n        uint256 uAmount = PredyMath.scale(_underlyingAmountE8, 8, decimals);\\n\\n        int256 hedgePosition = vault.hedgePosition;\\n\\n        vault.hedgePosition += int256(_underlyingAmountE8);\\n\\n        underlying.transferFrom(msg.sender, address(this), uAmount);\\n\\n        if (hedgePosition < -int256(_underlyingAmountE8)) {\\n            repayUnderlyingInternal(_optionInfo, vault, _spot, uAmount, uint256(-hedgePosition) - _underlyingAmountE8);\\n        } else if (hedgePosition < 0) {\\n            repayUnderlyingInternal(\\n                _optionInfo,\\n                vault,\\n                _spot,\\n                PredyMath.scale(uint256(-hedgePosition), 8, decimals),\\n                0\\n            );\\n        }\\n\\n        require(vault.collateral >= uint128(_collateralAmount), \\\"OptionLib: no enough collateral\\\");\\n\\n        decreaseCollateral(vault, uint128(_collateralAmount));\\n\\n        IERC20(_optionInfo.tokens.collateral).transfer(msg.sender, _collateralAmount);\\n\\n        return vault.hedgePosition;\\n    }\\n\\n    /**\\n     * @notice receive collateral asset and send underlying asset to sender\\n     * @param _vaultDelta net delta of the vault\\n     * @param _underlyingAmountE8 amount of underlying asset scaled by 1e8\\n     */\\n    function addUnderlyingShort(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        int256 _vaultDelta,\\n        uint256 _underlyingAmountE8,\\n        uint256 _collateralAmount\\n    ) external existsExpiry(_expiryId, _optionInfo.expiryCount) returns (int256) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n        ERC20 underlying = ERC20(_optionInfo.tokens.underlying);\\n\\n        uint256 decimals = underlying.decimals();\\n\\n        require(_vaultDelta + vault.hedgePosition > 0, \\\"OptionLib: net delta must be positive\\\");\\n\\n        require(\\n            (_vaultDelta + vault.hedgePosition) >= int256(_underlyingAmountE8),\\n            \\\"OptionLib: underlying amount is too large\\\"\\n        );\\n\\n        require(\\n            (PredyMath.scale(_spot * _underlyingAmountE8, 16, 6) * (10000 - _optionInfo.configs[SLIPPAGE_TOLERANCE])) /\\n                10000 <=\\n                _collateralAmount,\\n            \\\"OptionLib: collateral amount is too small\\\"\\n        );\\n\\n        uint256 uAmount = PredyMath.scale(_underlyingAmountE8, 8, decimals);\\n\\n        increaseCollateral(vault, uint128(_collateralAmount));\\n\\n        IERC20(_optionInfo.tokens.collateral).transferFrom(msg.sender, address(this), _collateralAmount);\\n\\n        if (vault.hedgePosition <= 0) {\\n            borrowUnderlyingInternal(_optionInfo, vault, _spot, uAmount);\\n        } else if (vault.hedgePosition < int256(_underlyingAmountE8)) {\\n            borrowUnderlyingInternal(\\n                _optionInfo,\\n                vault,\\n                _spot,\\n                uAmount - PredyMath.scale(uint256(vault.hedgePosition), 8, decimals)\\n            );\\n        }\\n\\n        vault.hedgePosition -= int256(_underlyingAmountE8);\\n\\n        underlying.transfer(msg.sender, uAmount);\\n\\n        return vault.hedgePosition;\\n    }\\n\\n    /**\\n     * @notice redeem collateral from LendingPool\\n     */\\n    function redeemCollateralFromLendingPool(\\n        OptionInfo storage _optionInfo,\\n        uint128 _repayAmount,\\n        uint128 _price,\\n        address _caller,\\n        address _feePool\\n    ) external {\\n        // there are no live option serieses\\n        require(_optionInfo.expiryCount == _optionInfo.expiredCount + 1);\\n        // check total short liquidity is 0\\n        require(_optionInfo.totalDepositedToLendingPool == 0);\\n\\n        IERC20(_optionInfo.tokens.underlying).transferFrom(_caller, address(this), _repayAmount);\\n\\n        IERC20(_optionInfo.tokens.underlying).approve(address(_optionInfo.lendingPool), _repayAmount);\\n        uint128 repaidAmount = repayBorrow(_optionInfo, MAX_UINT256);\\n\\n        // redeem underlying tokens\\n        uint128 withdrawnAmount = uint128(\\n            _optionInfo.lendingPool.withdraw(_optionInfo.tokens.collateral, MAX_UINT256, address(this))\\n        );\\n\\n        uint128 reward = (_price * repaidAmount) / 1e20;\\n        reward = (reward * (10000 + _optionInfo.configs[SLIPPAGE_TOLERANCE])) / 10000;\\n\\n        if (reward < withdrawnAmount) {\\n            uint128 rewardForFeePool = withdrawnAmount - reward;\\n\\n            // send USDC to fee pool\\n            IFeePool feePool = IFeePool(_feePool);\\n\\n            IERC20(_optionInfo.tokens.collateral).approve(address(feePool), rewardForFeePool);\\n            feePool.sendProfitERC20(address(this), rewardForFeePool);\\n        } else {\\n            reward = withdrawnAmount;\\n        }\\n\\n        // send USDC and WETH to caller\\n        IERC20(_optionInfo.tokens.collateral).transfer(_caller, reward);\\n        IERC20(_optionInfo.tokens.underlying).transfer(_caller, _repayAmount - repaidAmount);\\n    }\\n\\n    function setConfig(\\n        OptionInfo storage _optionInfo,\\n        uint8 _key,\\n        uint128 _value\\n    ) external {\\n        _optionInfo.configs[_key] = _value;\\n    }\\n\\n    //////////////////////\\n    // Getter Functions //\\n    //////////////////////\\n\\n    function getLiveOptionSerieses(OptionInfo storage _optionInfo)\\n        external\\n        view\\n        returns (IOptionVault.Expiration[] memory)\\n    {\\n        IOptionVault.Expiration[] memory expirations = new IOptionVault.Expiration[](\\n            _optionInfo.expiryCount - _optionInfo.expiredCount - 1\\n        );\\n\\n        for (uint128 i = _optionInfo.expiredCount + 1; i < _optionInfo.expiryCount; i++) {\\n            expirations[i - _optionInfo.expiredCount - 1] = IOptionVault.Expiration(\\n                i,\\n                _optionInfo.expiries[i].expiry,\\n                _optionInfo.expiries[i].seriesIds\\n            );\\n        }\\n\\n        return expirations;\\n    }\\n\\n    function getOptionSeriesView(OptionInfo storage _optionInfo, uint256 _seriesId)\\n        external\\n        view\\n        returns (IOptionVault.OptionSeriesView memory)\\n    {\\n        IOptionVault.OptionSeries memory optionSeries = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Expiration memory expiration = _optionInfo.expiries[optionSeries.expiryId];\\n\\n        return\\n            IOptionVault.OptionSeriesView(\\n                optionSeries.expiryId,\\n                _seriesId,\\n                expiration.expiry,\\n                OptionLib.getMaturity(expiration.expiry),\\n                optionSeries.strike,\\n                optionSeries.isPut,\\n                optionSeries.iv\\n            );\\n    }\\n\\n    function getCollateralValueQuote(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint128 price\\n    ) external view returns (uint128 total) {\\n        for (uint256 i = _optionInfo.accounts[_accountId].settledCount + 1; i < _optionInfo.seriesCount; i++) {\\n            total += getCollateralValue(_optionInfo, _accountId, i, price);\\n        }\\n    }\\n\\n    /**\\n     * @notice get position size\\n     * @param _accountId vault id\\n     * @param _seriesId option series id\\n     * @return (short size, long size)\\n     */\\n    function getPositionSize(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId\\n    ) external view returns (uint128, uint128) {\\n        IOptionVault.OptionSeries memory series = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[series.expiryId];\\n\\n        return (vault.shorts[_seriesId], vault.longs[_seriesId]);\\n    }\\n\\n    function getVaultOwner(OptionInfo storage _optionInfo, uint256 _accountId) external view returns (address) {\\n        return _optionInfo.accounts[_accountId].owner;\\n    }\\n\\n    /**\\n     * @notice get the amount that can be liquidated\\n     */\\n    function getLiquidatableAmount(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _spot\\n    ) external view returns (uint128) {\\n        IOptionVault.OptionSeries memory option = _optionInfo.serieses[_seriesId];\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[option.expiryId];\\n\\n        uint128 maintenanceMargin = getRequiredMargin(\\n            _optionInfo,\\n            _accountId,\\n            option.expiryId,\\n            _spot,\\n            IOptionVault.MarginLevel.Maintenance\\n        );\\n\\n        uint128 collateralValue = getCollateralValue(_optionInfo, _accountId, option.expiryId, _spot);\\n\\n        if (collateralValue >= maintenanceMargin) {\\n            return 0;\\n        }\\n\\n        uint128 liquidatableAmount = calLiquidatableAmount(\\n            _optionInfo,\\n            maintenanceMargin,\\n            collateralValue,\\n            option.isPut ? option.strike : _spot\\n        );\\n\\n        if (vault.shorts[_seriesId] < liquidatableAmount) {\\n            return vault.shorts[_seriesId];\\n        }\\n\\n        return liquidatableAmount;\\n    }\\n\\n    int256 internal constant SQRT_YEAR_E8 = 5615.69229926 * 10**8;\\n\\n    /**\\n     * @notice calculate vault's net delta\\n     * @param _optionInfo pool info\\n     * @param _accountId vault id to calculate net delta\\n     * @param _spot spot price\\n     * @return tickDelta vault's net delta scaled by 1e8\\n     */\\n    function calculateVaultDelta(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot\\n    ) external view returns (int256 tickDelta) {\\n        IOptionVault.Vault storage vault = _optionInfo.accounts[_accountId].vaults[_expiryId];\\n\\n        // calculate serieses that is not expired\\n        IOptionVault.Expiration memory expiration = _optionInfo.expiries[_expiryId];\\n\\n        // option serieses before maturity are included in the calculation.\\n        if (expiration.expiry <= block.timestamp) {\\n            return 0;\\n        }\\n\\n        // uint64 maturity = getMaturity(expiration.expiry);\\n        int256 sqrtMaturity = PriceCalculator.getSqrtMaturity(getMaturity(expiration.expiry));\\n\\n        for (uint256 j = 0; j < expiration.seriesIds.length; j++) {\\n            uint256 seriesId = expiration.seriesIds[j];\\n\\n            int128 position = vault.longs[seriesId].toInt128() - vault.shorts[seriesId].toInt128();\\n            tickDelta += calculateDelta(sqrtMaturity, _optionInfo.serieses[seriesId], position, _spot);\\n        }\\n        return tickDelta;\\n    }\\n\\n    ///////////////////////\\n    // Private Functions //\\n    ///////////////////////\\n\\n    function increaseCollateral(IOptionVault.Vault storage _vault, uint128 _amount) internal {\\n        _vault.collateral += _amount;\\n    }\\n\\n    function decreaseCollateral(IOptionVault.Vault storage _vault, uint128 _amount) internal returns (uint128) {\\n        if (_vault.collateral >= _amount) {\\n            _vault.collateral -= _amount;\\n            return _amount;\\n        } else {\\n            uint128 a = _vault.collateral;\\n            _vault.collateral = 0;\\n            return a;\\n        }\\n    }\\n\\n    /**\\n     * @notice get USD value of collateral\\n     */\\n    function getCollateralValue(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot\\n    ) internal view returns (uint128) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n\\n        int256 hedgedValue = vault.shortLiquidity.toInt128() + (_spot.toInt128() * vault.hedgePosition) / 1e10;\\n\\n        return uint128(uint256(hedgedValue)) + vault.collateral;\\n    }\\n\\n    /**\\n     * @notice get the required margin of a vault\\n     */\\n    function getRequiredMargin(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) public view returns (uint128 requiredMargin) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n        IOptionVault.Expiration storage expiration = _optionInfo.expiries[_expiryId];\\n\\n        if (vault.isSettled) {\\n            return 0;\\n        }\\n\\n        for (uint256 i = 0; i < expiration.seriesIds.length; i++) {\\n            uint256 seriesId = expiration.seriesIds[i];\\n            uint128 shortAmount = vault.shorts[seriesId];\\n            uint128 longAmount = vault.longs[seriesId];\\n\\n            if (shortAmount == 0 && longAmount == 0) {\\n                continue;\\n            }\\n\\n            IOptionVault.OptionSeriesParams memory seriesParams = getOptionSeriesParams(\\n                _optionInfo.serieses[seriesId],\\n                expiration.expiry\\n            );\\n\\n            if (_marginLevel == IOptionVault.MarginLevel.Safe) {\\n                requiredMargin += calMargin(\\n                    _optionInfo,\\n                    shortAmount.toInt128() - longAmount.toInt128(),\\n                    _spot,\\n                    seriesParams,\\n                    _marginLevel\\n                );\\n            } else {\\n                requiredMargin += calMargin(_optionInfo, shortAmount.toInt128(), _spot, seriesParams, _marginLevel);\\n            }\\n        }\\n    }\\n\\n    function getRequiredMarginForASeries(\\n        OptionInfo storage _optionInfo,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _spot,\\n        int128 _amount,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) public view returns (uint128) {\\n        uint64 expiry = _optionInfo.expiries[_expiryId].expiry;\\n\\n        IOptionVault.OptionSeries memory series = _optionInfo.serieses[_seriesId];\\n\\n        return calMargin(_optionInfo, _amount, _spot, getOptionSeriesParams(series, expiry), _marginLevel);\\n    }\\n\\n    /**\\n     * @notice get the total payout of a vault\\n     */\\n    function getTotalPayout(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot,\\n        bool _roundUp\\n    ) public view returns (uint128 totalPayout) {\\n        IOptionVault.Account storage account = _optionInfo.accounts[_accountId];\\n        IOptionVault.Vault storage vault = account.vaults[_expiryId];\\n\\n        IOptionVault.Expiration memory expiration = _optionInfo.expiries[_expiryId];\\n\\n        for (uint256 i = 0; i < expiration.seriesIds.length; i++) {\\n            uint256 seriesId = expiration.seriesIds[i];\\n\\n            if (vault.shorts[seriesId] == 0) {\\n                continue;\\n            }\\n\\n            totalPayout += calculatePayout(\\n                vault.shorts[seriesId],\\n                _spot,\\n                _optionInfo.serieses[seriesId].strike,\\n                _optionInfo.serieses[seriesId].isPut,\\n                _roundUp\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate liquidatable amount\\n     * Calculate the liquidatable size so that the collateral of the size's premium + BASE_REWARD remains in vault\\n     */\\n    function calLiquidatableAmount(\\n        OptionInfo storage _optionInfo,\\n        uint128 _maintenanceMargin,\\n        uint128 _collateralValue,\\n        uint128 _spotOrStrike\\n    ) internal view returns (uint128 limit) {\\n        // maintenance margin - premium\\n        uint128 rewardDiffPerSize = (_spotOrStrike * _optionInfo.configs[REWARD_PER_SIZE_RATIO]) / (1000);\\n\\n        return\\n            (1e10 * (_optionInfo.configs[BASE_LIQ_REWARD] + _maintenanceMargin - _collateralValue)) / rewardDiffPerSize;\\n    }\\n\\n    /**\\n     * @notice get maturity\\n     */\\n    function getMaturity(uint64 _expiry) internal view returns (uint64 maturity) {\\n        maturity = _expiry > block.timestamp ? _expiry - uint64(block.timestamp) : 0;\\n    }\\n\\n    function getOptionSeriesParams(IOptionVault.OptionSeries memory _series, uint64 _expiry)\\n        internal\\n        view\\n        returns (IOptionVault.OptionSeriesParams memory)\\n    {\\n        uint64 maturity = getMaturity(_expiry);\\n\\n        return IOptionVault.OptionSeriesParams(_series.expiryId, maturity, _series.strike, _series.isPut, _series.iv);\\n    }\\n\\n    function checkOptionSeriesIsLive(IOptionVault.Expiration memory _expiration) internal view {\\n        require(_expiration.expiry > block.timestamp, \\\"OptionLib: option series has been expired\\\");\\n    }\\n\\n    function checkCollateral(\\n        OptionInfo storage _optionInfo,\\n        uint256 _accountId,\\n        uint256 _expiryId,\\n        uint128 _spot\\n    ) internal view {\\n        require(\\n            getCollateralValue(_optionInfo, _accountId, _expiryId, _spot) >=\\n                getRequiredMargin(_optionInfo, _accountId, _expiryId, _spot, IOptionVault.MarginLevel.Initial),\\n            \\\"OptionLib: collateral is not enough\\\"\\n        );\\n    }\\n\\n    function getCollateralForASeries(\\n        OptionInfo storage _optionInfo,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _spot,\\n        uint128 _amount,\\n        uint128 _cRatio,\\n        bool _isPool\\n    ) internal view returns (uint128 collateral) {\\n        uint128 requiredMargin = getRequiredMarginForASeries(\\n            _optionInfo,\\n            _expiryId,\\n            _seriesId,\\n            _spot,\\n            _amount.toInt128(),\\n            _isPool ? IOptionVault.MarginLevel.Safe : IOptionVault.MarginLevel.Initial\\n        );\\n\\n        collateral = (1e6 * requiredMargin) / _cRatio;\\n    }\\n\\n    /**\\n     * @notice calculate required margin\\n     * there are 3 margin levels, Maintenance Margin, Initial Margin and Safe Margin.\\n     * Maintenance Margin: premium + mmRatio * spot\\n     * Initial Margin: premium + imRatio * spot\\n     * Safe Margin:\\n     *   120% of spot for short call\\n     *   200% of min(strike, spot) for short put\\n     *   200% of min(strike, spot) for long call\\n     *   120% of spot for long put\\n     */\\n    function calMargin(\\n        OptionInfo storage _optionInfo,\\n        int128 _u,\\n        uint128 _spot,\\n        IOptionVault.OptionSeriesParams memory _series,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) internal view returns (uint128) {\\n        if (_marginLevel == IOptionVault.MarginLevel.Maintenance || _marginLevel == IOptionVault.MarginLevel.Initial) {\\n            uint128 size = uint128(_u);\\n            // calculate as ATM if option is OTM\\n\\n            uint256 p = PriceCalculator.calculatePrice(\\n                _spot,\\n                _series.strike,\\n                _series.maturity,\\n                _series.iv,\\n                _series.isPut\\n            );\\n\\n            if (_marginLevel == IOptionVault.MarginLevel.Initial) {\\n                // initial margin\\n                if (_series.isPut) {\\n                    p += (_series.strike * _optionInfo.configs[IM_RATIO]) / (1000);\\n                } else {\\n                    p += (_spot * _optionInfo.configs[IM_RATIO]) / (1000);\\n                }\\n            } else {\\n                // maintenance margin\\n                if (_series.isPut) {\\n                    p += (_series.strike * _optionInfo.configs[MM_RATIO]) / (1000);\\n                } else {\\n                    p += (_spot * _optionInfo.configs[MM_RATIO]) / (1000);\\n                }\\n            }\\n\\n            return uint128(size * p) / 1e10;\\n        } else if (_marginLevel == IOptionVault.MarginLevel.Safe) {\\n            bool collateralForShort;\\n            uint128 size;\\n\\n            if (_u > 0) {\\n                size = uint128(_u);\\n                collateralForShort = _series.isPut;\\n            } else {\\n                size = uint128(-_u);\\n                collateralForShort = !_series.isPut;\\n            }\\n\\n            if (collateralForShort) {\\n                return\\n                    (size * PredyMath.min(_series.strike, _spot) * _optionInfo.configs[PUT_SAFE_RATIO]) / (1e10 * 1000);\\n            } else {\\n                return (size * _spot * _optionInfo.configs[CALL_SAFE_RATIO]) / (1e10 * 1000);\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice calculate payout\\n     * put: amount * max(K - S, 0)\\n     * call: amount * max(S - K, 0)\\n     */\\n    function calculatePayout(\\n        uint128 _u,\\n        uint128 _spot,\\n        uint128 _strike,\\n        bool _isPut,\\n        bool _isRoundUp\\n    ) internal pure returns (uint128) {\\n        uint128 r;\\n        if (_isPut && _strike > _spot) {\\n            r = _strike - _spot;\\n        } else if (!_isPut && _strike < _spot) {\\n            r = _spot - _strike;\\n        } else {\\n            return 0;\\n        }\\n        return PredyMath.mulDiv(_u, r, 1e10, _isRoundUp);\\n    }\\n\\n    function updateExpiredCount(OptionInfo storage _optionInfo, uint256 _expiryId) internal {\\n        IOptionVault.Expiration storage expiration = _optionInfo.expiries[_expiryId];\\n\\n        require(expiration.expiry < block.timestamp, \\\"expiry must have been passed\\\");\\n\\n        if (_optionInfo.expiredCount < _expiryId) {\\n            _optionInfo.expiredCount = uint128(_expiryId);\\n        }\\n    }\\n\\n    function calculateDelta(\\n        int256 _maturity,\\n        IOptionVault.OptionSeries memory _option,\\n        int256 _position,\\n        uint128 _spot\\n    ) internal pure returns (int256 delta) {\\n        return\\n            (_position * PriceCalculator.calculateDelta(_spot, _option.strike, _maturity, _option.iv, _option.isPut)) /\\n            int256(1e8);\\n    }\\n\\n    /**\\n     * @notice deposits USDC and borrows underlying asset from compound\\n     */\\n    function borrowUnderlyingInternal(\\n        OptionInfo storage _optionInfo,\\n        IOptionVault.Vault storage vault,\\n        uint128 _spot,\\n        uint256 _underlyingAmount\\n    ) internal {\\n        ERC20 underlying = ERC20(_optionInfo.tokens.underlying);\\n\\n        uint256 decimals = underlying.decimals();\\n\\n        uint128 depositCollateral = uint128(PredyMath.scale(_underlyingAmount * _spot * 2.0, decimals + 8, 6));\\n\\n        // deposit USDC to compound\\n        IERC20(_optionInfo.tokens.collateral).approve(address(_optionInfo.lendingPool), depositCollateral);\\n        _optionInfo.lendingPool.deposit(_optionInfo.tokens.collateral, depositCollateral, address(this), 0);\\n\\n        // borrow underling\\n        borrow(_optionInfo, _underlyingAmount);\\n\\n        require(vault.collateral >= depositCollateral, \\\"OptionLib: no enough collateral\\\");\\n\\n        depositCollateral = decreaseCollateral(vault, depositCollateral);\\n        vault.shortLiquidity += depositCollateral;\\n        _optionInfo.totalDepositedToLendingPool += depositCollateral;\\n    }\\n\\n    /**\\n     * @notice repays underlying asset and withdraws USDC from compound\\n     * @param _optionInfo option vault object\\n     * @param _vault the vault repaying underlying asset\\n     * @param _spot spot price\\n     * @param _underlyingAmount amount to repay\\n     * @param _remainingDebt The remaining debt after the repayment, scaled by 1e8.\\n     */\\n    function repayUnderlyingInternal(\\n        OptionInfo storage _optionInfo,\\n        IOptionVault.Vault storage _vault,\\n        uint128 _spot,\\n        uint256 _underlyingAmount,\\n        uint256 _remainingDebt\\n    ) internal {\\n        IERC20(_optionInfo.tokens.underlying).approve(address(_optionInfo.lendingPool), _underlyingAmount);\\n        repayBorrow(_optionInfo, _underlyingAmount);\\n\\n        // calculate unrequired collateral\\n        // if maturity is large, the protocol have to pay borrowing interest, and it can not redeem all shortLiquidity.\\n        // In this case, repay underling from outside of protocol.\\n        uint128 redeemCollateralAmount = _vault.shortLiquidity - (uint128(_remainingDebt) * _spot * 2) / 1e10;\\n\\n        _optionInfo.lendingPool.withdraw(_optionInfo.tokens.collateral, redeemCollateralAmount, address(this));\\n\\n        increaseCollateral(_vault, redeemCollateralAmount);\\n\\n        _vault.shortLiquidity -= redeemCollateralAmount;\\n        _optionInfo.totalDepositedToLendingPool -= redeemCollateralAmount;\\n    }\\n\\n    /**\\n     * @notice borrow underlying asset with Variable type debt\\n     */\\n    function borrow(OptionInfo storage _optionInfo, uint256 _amount) internal {\\n        _optionInfo.lendingPool.borrow(_optionInfo.tokens.underlying, _amount, 2, 0, address(this));\\n    }\\n\\n    /**\\n     * @notice repay borrowing underlying asset with Variable type debt\\n     */\\n    function repayBorrow(OptionInfo storage _optionInfo, uint256 _amount) internal returns (uint128) {\\n        return uint128(_optionInfo.lendingPool.repay(_optionInfo.tokens.underlying, _amount, 2, address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @notice chainlink price oracle.\\n * This is the contract to fix the price at the nearest time after expiry.\\n */\\ncontract PriceOracle is Ownable {\\n    /// @dev expiry price with timestamp\\n    struct ExpiryPrice {\\n        uint256 price;\\n        uint256 timestamp;\\n    }\\n\\n    /// @dev chainlink aggregator address of the underlying asset price\\n    mapping(address => AggregatorV3Interface) aggregators;\\n\\n    /// @dev aggregator address => timestamp => expiry price\\n    mapping(address => mapping(uint256 => ExpiryPrice)) internal expiryPrices;\\n\\n    event ExpiryPriceUpdated(address aggregator, uint256 expiry, uint256 price);\\n\\n    uint256 public constant DISPUTE_PERIOD = 2 hours;\\n\\n    /**\\n     * @notice set aggregator\\n     * only owner can set new aggregator\\n     */\\n    function setAggregator(address _aggregatorAddress) external onlyOwner {\\n        require(address(aggregators[_aggregatorAddress]) == address(0));\\n        aggregators[_aggregatorAddress] = AggregatorV3Interface(_aggregatorAddress);\\n    }\\n\\n    /**\\n     * @notice set expiry price\\n     * anyone can set price if the price has not been setted.\\n     * Also timestamp must be later than expiration.\\n     */\\n    function setExpiryPrice(address _aggregator, uint256 _expiryTimestamp) external {\\n        (uint256 price, uint256 timestamp) = getPrice(_aggregator);\\n\\n        require(_expiryTimestamp < timestamp, \\\"PriceOracle: price timestamp must be later than expiry\\\");\\n\\n        ExpiryPrice storage expiryPrice = expiryPrices[_aggregator][_expiryTimestamp];\\n\\n        require(expiryPrice.timestamp == 0, \\\"PriceOracle: already setted\\\");\\n\\n        expiryPrice.price = price;\\n        expiryPrice.timestamp = timestamp;\\n\\n        emit ExpiryPriceUpdated(_aggregator, _expiryTimestamp, price);\\n    }\\n\\n    /**\\n     * @notice update expiry price\\n     * anyone can update price if the price has not been setted\\n     * or if new price's timestamp is earlier than previous one.\\n     * Also timestamp must be later than expiration.\\n     */\\n    function updateExpiryPrice(\\n        address _aggregator,\\n        uint256 _expiryTimestamp,\\n        uint80 _roundId\\n    ) external {\\n        (uint256 price, uint256 timestamp) = getHistoricalPrice(_aggregator, _roundId);\\n\\n        require(_expiryTimestamp < timestamp, \\\"PriceOracle: price timestamp must be later than expiry\\\");\\n\\n        ExpiryPrice storage expiryPrice = expiryPrices[_aggregator][_expiryTimestamp];\\n\\n        require(\\n            expiryPrice.timestamp == 0 || expiryPrice.timestamp > timestamp,\\n            \\\"PriceOracle: new price's timestamp must be close to expiry\\\"\\n        );\\n\\n        expiryPrice.price = price;\\n        expiryPrice.timestamp = timestamp;\\n\\n        emit ExpiryPriceUpdated(_aggregator, _expiryTimestamp, price);\\n    }\\n\\n    /**\\n     * @notice get price for an expiration\\n     * @return price price scaled by 1e8\\n     * @return _isFinalized returns true if price has been finalized, if not returns false\\n     */\\n    function getExpiryPrice(address _aggregator, uint256 _expiryTimestamp)\\n        external\\n        view\\n        returns (uint256 price, bool _isFinalized)\\n    {\\n        price = expiryPrices[_aggregator][_expiryTimestamp].price;\\n        _isFinalized = isFinalized(_aggregator, _expiryTimestamp);\\n    }\\n\\n    /**\\n     * @notice return flag if price is finalized or not\\n     * true if dispute period has been passed and price has been setted more than once\\n     */\\n    function isFinalized(address _aggregator, uint256 _expiryTimestamp) internal view returns (bool) {\\n        return\\n            (_expiryTimestamp + DISPUTE_PERIOD < block.timestamp) &&\\n            expiryPrices[_aggregator][_expiryTimestamp].timestamp != 0;\\n    }\\n\\n    /**\\n     * @notice get price scaled by 1e8\\n     */\\n    function getPrice(address _aggregatorAddress) public view returns (uint256, uint256) {\\n        (, int256 answer, , uint256 roundTimestamp, ) = aggregators[_aggregatorAddress].latestRoundData();\\n\\n        require(answer > 0, \\\"PriceOracle: price is lower than 0\\\");\\n\\n        return (uint256(answer), roundTimestamp);\\n    }\\n\\n    function getHistoricalPrice(address _aggregatorAddress, uint80 _roundId) public view returns (uint256, uint256) {\\n        (, int256 answer, , uint256 roundTimestamp, ) = aggregators[_aggregatorAddress].getRoundData(_roundId);\\n\\n        require(answer > 0, \\\"PriceOracle: price is lower than 0\\\");\\n\\n        return (uint256(answer), roundTimestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IOptionVault {\\n    enum MarginLevel {\\n        Maintenance,\\n        Initial,\\n        Safe\\n    }\\n\\n    struct Expiration {\\n        uint128 expiryId;\\n        uint64 expiry;\\n        uint256[] seriesIds;\\n    }\\n\\n    struct OptionSeries {\\n        uint64 strike;\\n        bool isPut;\\n        uint64 iv;\\n        uint128 expiryId;\\n    }\\n\\n    struct Account {\\n        address owner;\\n        uint256 settledCount;\\n        mapping(uint256 => Vault) vaults;\\n    }\\n\\n    struct Vault {\\n        // is settled or not\\n        bool isSettled;\\n        // seriesId => short amount\\n        mapping(uint256 => uint128) shorts;\\n        // seriesId => long amount\\n        mapping(uint256 => uint128) longs;\\n        //\\n        uint128 collateral;\\n        //\\n        int256 hedgePosition;\\n        //\\n        uint128 shortLiquidity;\\n    }\\n\\n    // view struct\\n\\n    struct OptionSeriesParams {\\n        uint256 id;\\n        uint64 maturity;\\n        uint128 strike;\\n        bool isPut;\\n        uint128 iv;\\n    }\\n\\n    struct OptionSeriesView {\\n        uint256 expiryId;\\n        uint256 seriesId;\\n        uint64 expiry;\\n        uint64 maturity;\\n        uint128 strike;\\n        bool isPut;\\n        uint64 iv;\\n    }\\n\\n    struct AccountView {\\n        address owner;\\n        uint256 settledCount;\\n    }\\n\\n    struct VaultView {\\n        address owner;\\n        bool isSettled;\\n        uint128 collateral;\\n        int256 hedgePosition;\\n        uint128 shortLiquidity;\\n    }\\n\\n    function getExpiration(uint256 _expiryId) external view returns (IOptionVault.Expiration memory);\\n\\n    function getOptionSeries(uint256 _seriesId) external view returns (IOptionVault.OptionSeriesView memory);\\n\\n    function getAccount(uint256 _vaultId) external view returns (AccountView memory);\\n\\n    function getVault(uint256 _vaultId, uint256 _expiryId) external view returns (VaultView memory);\\n\\n    function getCollateralValueQuote(uint256 _vaultId) external view returns (uint128);\\n\\n    function getRequiredMargin(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view returns (uint128);\\n\\n    function calRequiredMarginForASeries(\\n        uint256 _seriesId,\\n        int128 _amount,\\n        IOptionVault.MarginLevel _marginLevel\\n    ) external view returns (uint128);\\n\\n    function getTotalPayout(uint256 _vaultId, uint256 _expiryId) external view returns (uint128);\\n\\n    function getPositionSize(uint256 _vaultId, uint256 _seriesId) external view returns (uint128, uint128);\\n\\n    function getLiveOptionSerieses() external view returns (IOptionVault.Expiration[] memory);\\n\\n    function getLastExpiry() external view returns (uint64);\\n\\n    function createAccount() external returns (uint256);\\n\\n    function setIV(uint256 _seriesId, uint128 _iv) external;\\n\\n    function deposit(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external;\\n\\n    function withdraw(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint128 _collateral\\n    ) external;\\n\\n    function closeShortPosition(\\n        uint256 _accountId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _cRatio\\n    ) external returns (uint128);\\n\\n    function write(\\n        uint256 _vaultId,\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        address _recepient\\n    ) external;\\n\\n    function depositAndWrite(\\n        uint256 _vaultId,\\n        uint256 _seriesId,\\n        uint128 _collateral,\\n        uint128 _amount,\\n        address _recepient\\n    ) external returns (uint128);\\n\\n    function settleVault(uint256 _vaultId, uint256 _expiryId) external returns (uint128);\\n\\n    function claim(uint256 _seriesId, uint128 _size) external returns (uint128);\\n\\n    function addLong(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external;\\n\\n    function removeLong(\\n        uint256 _vaultId,\\n        uint256 _expiryId,\\n        uint256 _seriesId,\\n        uint128 _amount\\n    ) external;\\n\\n    function calculateVaultDelta(uint256 _vaultId, uint256 _expiryId) external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IFeePool.sol\\\";\\n\\ninterface IAMM {\\n    function sell(\\n        uint256 _seriesId,\\n        uint128 _amount,\\n        uint128 _minFee\\n    ) external returns (uint128);\\n\\n    function feePool() external returns (IFeePool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/PriceCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AdvancedMath.sol\\\";\\n\\n/**\\n * @notice Option price calculator using Black-Scholes formula\\n */\\nlibrary PriceCalculator {\\n    /// @dev sqrt(365 * 86400)\\n    int256 internal constant SQRT_YEAR_E8 = 5615.69229926 * 10**8;\\n    /// @dev range size of linear function\\n    int256 internal constant RANGE = 20 * 1e6;\\n\\n    struct Parameters {\\n        // spot price\\n        int256 spot;\\n        // strike price\\n        int256 strike;\\n        // log(spot / strike)\\n        int256 logSigE4;\\n        // sqrt(maturity)\\n        int256 sqrtMaturity;\\n    }\\n\\n    /**\\n     * @notice calculate option price at a IV point\\n     * @param _spot spot price scaled 1e8\\n     * @param _strike strike price scaled 1e8\\n     * @param _maturity maturity in seconds\\n     * @param _iv IV\\n     * @param _isPut option type\\n     * @return premium per amount\\n     */\\n    function calculatePrice(\\n        uint256 _spot,\\n        uint256 _strike,\\n        uint256 _maturity,\\n        uint256 _iv,\\n        bool _isPut\\n    ) external pure returns (uint256 premium) {\\n        validateParameters(_spot, _strike);\\n        require(0 < _iv && _iv < 1000 * 1e6, \\\"PriceCalculator: implied volatility must be between 0 and 1000%\\\");\\n\\n        int256 sqrtMaturity = getSqrtMaturity(_maturity);\\n        int256 logSigE4;\\n        {\\n            int256 spotPerStrikeE4 = int256((_spot * 1e4) / _strike);\\n            logSigE4 = AdvancedMath.logTaylor(spotPerStrikeE4);\\n        }\\n\\n        return\\n            uint256(\\n                calOptionPrice(\\n                    Parameters(int256(_spot), int256(_strike), logSigE4, sqrtMaturity),\\n                    int256(_iv),\\n                    _isPut,\\n                    // calculatePrice function never reverts by delta cut-off\\n                    0\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice calculate option price with two IV points\\n     * @param _spot spot price scaled 1e8\\n     * @param _strike strike price scaled 1e8\\n     * @param _maturity maturity in seconds\\n     * @param _x0 start IV\\n     * @param _x1 end IV\\n     * @param _isPut option type\\n     * @param _minDelta minimum delta. if delta is less than minDelta or greater than (100% - minDelta), calculation reverts\\n     * @return premium per amount\\n     */\\n    function calculatePrice2(\\n        uint256 _spot,\\n        uint256 _strike,\\n        uint256 _maturity,\\n        uint256 _x0,\\n        uint256 _x1,\\n        bool _isPut,\\n        uint256 _minDelta\\n    ) external pure returns (uint256 premium) {\\n        validateParameters(_spot, _strike);\\n        require(0 < _x0 && _x0 < 10 * 1e8, \\\"PriceCalculator: 0 < x0 < 1000%\\\");\\n        require(0 < _x1 && _x1 < 10 * 1e8, \\\"PriceCalculator: 0 < x1 < 1000%\\\");\\n        require(_x0 < _x1, \\\"PriceCalculator: _x0 < _x1\\\");\\n\\n        int256 sqrtMaturity = getSqrtMaturity(_maturity);\\n\\n        int256 logSigE4;\\n        {\\n            int256 spotPerStrikeE4 = int256((_spot * 1e4) / _strike);\\n            logSigE4 = AdvancedMath.logTaylor(spotPerStrikeE4);\\n        }\\n\\n        return\\n            uint256(\\n                calculatePriceOfRanges(\\n                    Parameters(int256(_spot), int256(_strike), logSigE4, sqrtMaturity),\\n                    int256(_x0),\\n                    int256(_x1),\\n                    _isPut,\\n                    _minDelta\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice calculate option's delta\\n     * @param _spot spot price scaled 1e8\\n     * @param _strike strike price scaled 1e8\\n     * @param sqrtMaturity maturity in seconds\\n     * @param _iv IV\\n     * @param _isPut option type\\n     * @return delta\\n     */\\n    function calculateDelta(\\n        uint256 _spot,\\n        uint256 _strike,\\n        int256 sqrtMaturity,\\n        uint256 _iv,\\n        bool _isPut\\n    ) external pure returns (int256) {\\n        validateParameters(_spot, _strike);\\n        require(0 < _iv && _iv < 1000 * 1e6, \\\"PriceCalculator: implied volatility must be between 0 and 1000%\\\");\\n\\n        int256 logSigE4;\\n        {\\n            int256 spotPerStrikeE4 = int256((_spot * 1e4) / _strike);\\n            logSigE4 = AdvancedMath.logTaylor(spotPerStrikeE4);\\n        }\\n        (int256 d1E4, ) = _calD1D2(logSigE4, sqrtMaturity, int256(_iv));\\n        if (_isPut) {\\n            return -AdvancedMath.calStandardNormalCDF(-d1E4);\\n        } else {\\n            return AdvancedMath.calStandardNormalCDF(d1E4);\\n        }\\n    }\\n\\n    function getSqrtMaturity(uint256 _maturity) public pure returns (int256) {\\n        require(\\n            _maturity > 0 && _maturity < 31536000,\\n            \\\"PriceCalculator: maturity must not have expired and less than 1 year\\\"\\n        );\\n\\n        return (AdvancedMath.sqrt(int256(_maturity)) * 1e16) / SQRT_YEAR_E8;\\n    }\\n\\n    function calculatePriceOfRanges(\\n        Parameters memory _params,\\n        int256 _x0,\\n        int256 _x1,\\n        bool _isPut,\\n        uint256 _minDelta\\n    ) internal pure returns (int256 premium) {\\n        int256 lower = _x0 / RANGE;\\n        int256 upper = _x1 / RANGE;\\n        int256 cache;\\n        for (int256 i = lower; i <= upper; i++) {\\n            int256 x0 = 0;\\n            int256 x1 = RANGE;\\n            if (i == lower) {\\n                x0 = _x0 - i * RANGE;\\n            }\\n            if (i == upper) {\\n                x1 = _x1 - i * RANGE;\\n            }\\n            int256 p;\\n            (p, cache) = calculatePriceOfRange(_params, i, x0, x1, _isPut, cache, _minDelta);\\n            premium += p;\\n        }\\n        premium /= upper - lower + 1;\\n    }\\n\\n    function calculatePriceOfRange(\\n        Parameters memory _params,\\n        int256 _tick,\\n        int256 _x0,\\n        int256 _x1,\\n        bool _isPut,\\n        int256 _start,\\n        uint256 _minDelta\\n    ) internal pure returns (int256, int256) {\\n        if (_start == 0) {\\n            _start = calOptionPrice(_params, _tick * RANGE, _isPut, _minDelta);\\n        }\\n        int256 end = calOptionPrice(_params, (_tick + 1) * RANGE, _isPut, _minDelta);\\n        // y = (end - start)/RANGE * x + start + instrict\\n        return ((_start + ((end - _start) * (_x1 + _x0)) / (2 * RANGE)), end);\\n    }\\n\\n    function _calD1D2(\\n        int256 _logSigE4,\\n        int256 _sqrtMaturity,\\n        int256 _volatilityE8\\n    ) internal pure returns (int256 d1E4, int256 d2E4) {\\n        int256 sigE8 = (_volatilityE8 * _sqrtMaturity) / (1e8);\\n        d1E4 = ((_logSigE4 * 10**8) / sigE8) + (sigE8 / (2 * 10**4));\\n        d2E4 = d1E4 - (sigE8 / 10**4);\\n    }\\n\\n    function calOptionPrice(\\n        Parameters memory _params,\\n        int256 _volatility,\\n        bool _isPut,\\n        uint256 _minDelta\\n    ) internal pure returns (int256 price) {\\n        int256 nd1E8;\\n\\n        if (_volatility > 0) {\\n            (int256 d1E4, int256 d2E4) = _calD1D2(_params.logSigE4, _params.sqrtMaturity, _volatility);\\n            nd1E8 = AdvancedMath.calStandardNormalCDF(d1E4);\\n            int256 nd2E8 = AdvancedMath.calStandardNormalCDF(d2E4);\\n            price = (_params.spot * nd1E8 - _params.strike * nd2E8) / 1e8;\\n        }\\n        int256 lowestPrice;\\n        if (_isPut) {\\n            price = price - _params.spot + _params.strike;\\n\\n            lowestPrice = (_params.strike > _params.spot) ? _params.strike - _params.spot : int256(0);\\n        } else {\\n            lowestPrice = (_params.spot > _params.strike) ? _params.spot - _params.strike : int256(0);\\n        }\\n\\n        // delta cut-off\\n        // if option type is put, delta is `1 - N(d1)`\\n        // if option type is call, delta is `N(d1)`\\n        require((!_isPut && abs(nd1E8) >= _minDelta) || (_isPut && 1e8 - abs(nd1E8) >= _minDelta), \\\"delta is too low\\\");\\n\\n        if (price < lowestPrice) {\\n            return lowestPrice;\\n        }\\n\\n        return price;\\n    }\\n\\n    function validateParameters(uint256 _spot, uint256 _strike) internal pure {\\n        require(_spot > 0 && _spot < 1e13, \\\"PriceCalculator: spot price must be between 0 and 10^13\\\");\\n        require(_strike > 0 && _strike < 1e13, \\\"PriceCalculator: strike price must be between 0 and 10^13\\\");\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAave.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface LendingPool {\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 rateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHedge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IHedge {\\n    function init(address _ammAddress) external;\\n\\n    function underlying() external returns (address);\\n\\n    function shortAsset() external returns (address);\\n\\n    function buy(uint256 _underlyingAmount, uint256 _amountInMaximum) external returns (uint256 amountIn);\\n\\n    function sell(uint256 _underlyingAmount, uint256 _amountOutMinimum) external returns (uint256 amountOut);\\n\\n    function getShortPrice(uint256 _size) external view returns (uint256);\\n\\n    function buyShort(uint256 _size, uint256 _amountToPay) external returns (uint256 amountIn);\\n\\n    function sellShort(uint256 _size, uint256 amountToReceive) external returns (uint256 amountOut);\\n\\n    function getValueQuote(int256 _position) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IFeePool {\\n    function sendProfitERC20(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/PredyMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nlibrary PredyMath {\\n    function max(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a > b ? a : b;\\n    }\\n\\n    function min(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return a > b ? b : a;\\n    }\\n\\n    function abs(int128 x) internal pure returns (uint128) {\\n        return uint128(x >= 0 ? x : -x);\\n    }\\n\\n    function mulDiv(\\n        uint256 _x,\\n        uint256 _y,\\n        uint256 _d,\\n        bool _roundUp\\n    ) internal pure returns (uint128) {\\n        uint256 tailing;\\n        if (_roundUp) {\\n            uint256 remainer = (_x * _y) % _d;\\n            if (remainer > 0) {\\n                tailing = 1;\\n            }\\n        }\\n\\n        uint256 result = (_x * _y) / _d + tailing;\\n\\n        return SafeCast.toUint128(result);\\n    }\\n\\n    function scale(\\n        uint256 _a,\\n        uint256 _from,\\n        uint256 _to\\n    ) internal pure returns (uint256) {\\n        if (_from > _to) {\\n            return _a / 10**(_from - _to);\\n        } else if (_from < _to) {\\n            return _a * 10**(_to - _from);\\n        } else {\\n            return _a;\\n        }\\n    }\\n\\n    function toInt128(uint256 _a) internal pure returns (int128) {\\n        return SafeCast.toInt128(SafeCast.toInt256(_a));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AdvancedMath.sol\": {\r\n      \"content\": \"/// from https://github.com/LienFinance/bondmaker\\npragma solidity ^0.8.0;\\n\\nlibrary AdvancedMath {\\n    /// @dev sqrt(2*PI) * 10^8\\n    int256 internal constant SQRT_2PI_E8 = 250662827;\\n    /// @dev PI * 10^8\\n    int256 internal constant PI_E8 = 314159265;\\n    /// @dev Napier's constant\\n    int256 internal constant E_E8 = 271828182;\\n    /// @dev Inverse of Napier's constant (1/e)\\n    int256 internal constant INV_E_E8 = 36787944;\\n\\n    // for CDF\\n    int256 internal constant p = 23164190;\\n    int256 internal constant b1 = 31938153;\\n    int256 internal constant b2 = -35656378;\\n    int256 internal constant b3 = 178147793;\\n    int256 internal constant b4 = -182125597;\\n    int256 internal constant b5 = 133027442;\\n\\n    /**\\n     * @dev Calculate an approximate value of the square root of x by Babylonian method.\\n     */\\n    function sqrt(int256 x) internal pure returns (int256 y) {\\n        require(x >= 0, \\\"cannot calculate the square root of a negative number\\\");\\n        int256 z = (x + 1) / 2;\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns log(x) for any positive x.\\n     */\\n    function logTaylor(int256 inputE4) internal pure returns (int256 outputE4) {\\n        require(inputE4 > 1, \\\"input should be positive number\\\");\\n        int256 inputE8 = inputE4 * 1e4;\\n        // input x for _logTaylor1 is adjusted to 1/e < x < 1.\\n        while (inputE8 < INV_E_E8) {\\n            inputE8 = (inputE8 * E_E8) / 1e8;\\n            outputE4 -= 1e4;\\n        }\\n        while (inputE8 > 1e8) {\\n            inputE8 = (inputE8 * INV_E_E8) / 1e8;\\n            outputE4 += 1e4;\\n        }\\n        outputE4 += logTaylor1(inputE8 / 1e4 - 1e4);\\n    }\\n\\n    /**\\n     * @notice Calculate an approximate value of the logarithm of input value by\\n     * Taylor expansion around 1.\\n     * @dev log(x + 1) = x - 1/2 x^2 + 1/3 x^3 - 1/4 x^4 + 1/5 x^5\\n     *                     - 1/6 x^6 + 1/7 x^7 - 1/8 x^8 + ...\\n     */\\n    function logTaylor1(int256 inputE4) internal pure returns (int256 outputE4) {\\n        outputE4 =\\n            inputE4 -\\n            inputE4**2 /\\n            (2 * 1e4) +\\n            inputE4**3 /\\n            (3 * 1e8) -\\n            inputE4**4 /\\n            (4 * 1e12) +\\n            inputE4**5 /\\n            (5 * 1e16) -\\n            inputE4**6 /\\n            (6 * 1e20) +\\n            inputE4**7 /\\n            (7 * 1e24) -\\n            inputE4**8 /\\n            (8 * 1e28);\\n    }\\n\\n    /**\\n     * @notice Calculate the cumulative distribution function of standard normal\\n     * distribution.\\n     * @dev Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\\n     * http://people.math.sfu.ca/~cbm/aands/\\n     * errors are less than 0.7% at -3.2\\n     */\\n    function calStandardNormalCDF(int256 inputE4) internal pure returns (int256 outputE8) {\\n        require(inputE4 < 440 * 1e4 && inputE4 > -440 * 1e4, \\\"input is too large\\\");\\n        int256 _inputE4 = inputE4 > 0 ? inputE4 : inputE4 * (-1);\\n        int256 t = 1e16 / (1e8 + (p * _inputE4) / 1e4);\\n        int256 X2 = (inputE4 * inputE4) / 2;\\n        int256 X3 = (X2 * X2) / 1e8;\\n        int256 X4 = (X3 * X2) / 1e8;\\n        int256 exp2X2 = 1e8 +\\n            X2 +\\n            (X3 / 2) +\\n            (X4 / 6) +\\n            ((X3 * X3) / (24 * 1e8)) +\\n            ((X2 * (X3 * X3)) / (120 * 1e16)) +\\n            ((X4 * X4) / (720 * 1e8)) +\\n            ((X2 * (X4 * X4)) / (5040 * 1e16)) +\\n            ((X3 * (X4 * X4)) / (40320 * 1e16)) +\\n            ((X4 * X4 * X4) / (362880 * 1e16)) +\\n            ((X2 * (X4 * X4 * X4)) / (3628800 * 1e24)) +\\n            ((X3 * (X4 * X4 * X4)) / (39916800 * 1e24));\\n\\n        int256 Z = (1e24 / exp2X2) / SQRT_2PI_E8;\\n        int256 y = (b5 * t) / 1e8;\\n        y = ((y + b4) * t) / 1e8;\\n        y = ((y + b3) * t) / 1e8;\\n        y = ((y + b2) * t) / 1e8;\\n        y = 1e8 - (Z * ((y + b1) * t)) / 1e16;\\n        return inputE4 > 0 ? y : 1e8 - y;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/lib/OptionLib.sol\": {\r\n        \"OptionLib\": \"0xbb87a1011d643362ee92a043efa8196f6413bbb4\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lendingPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"profit\",\"type\":\"uint128\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"key\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"}],\"name\":\"ExpiryCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"tickId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"tickDelta\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"hedgePosition\",\"type\":\"int256\"}],\"name\":\"Hedged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"}],\"name\":\"Liquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strike\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"}],\"name\":\"SeriesCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"profit\",\"type\":\"uint128\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"VaultDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"VaultWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Written\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"addLong\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_underlyingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"addUnderlyingLong\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_underlyingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"addUnderlyingShort\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"_amount\",\"type\":\"int128\"},{\"internalType\":\"enum IOptionVault.MarginLevel\",\"name\":\"_marginLevel\",\"type\":\"uint8\"}],\"name\":\"calRequiredMarginForASeries\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"calculateVaultDelta\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_size\",\"type\":\"uint128\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_cRatio\",\"type\":\"uint128\"}],\"name\":\"closeShortPosition\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64[]\",\"name\":\"_strikes\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_callIVs\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_putIVs\",\"type\":\"uint64[]\"}],\"name\":\"createExpiry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_collateral\",\"type\":\"uint128\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_cRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"depositAndWrite\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"}],\"name\":\"getAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"settledCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionVault.AccountView\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"}],\"name\":\"getCollateralValueQuote\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_key\",\"type\":\"uint8\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"getExpiration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"expiryId\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint256[]\",\"name\":\"seriesIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IOptionVault.Expiration\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastExpiry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"}],\"name\":\"getLiquidatableAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"limit\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiveOptionSerieses\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"expiryId\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint256[]\",\"name\":\"seriesIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IOptionVault.Expiration[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"}],\"name\":\"getOptionSeries\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"expiryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"strike\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"iv\",\"type\":\"uint64\"}],\"internalType\":\"struct IOptionVault.OptionSeriesView\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"}],\"name\":\"getPositionSize\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"internalType\":\"enum IOptionVault.MarginLevel\",\"name\":\"_marginLevel\",\"type\":\"uint8\"}],\"name\":\"getRequiredMargin\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"getTotalPayout\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"getVault\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"collateral\",\"type\":\"uint128\"},{\"internalType\":\"int256\",\"name\":\"hedgePosition\",\"type\":\"int256\"},{\"internalType\":\"uint128\",\"name\":\"shortLiquidity\",\"type\":\"uint128\"}],\"internalType\":\"struct IOptionVault.VaultView\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_cRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_minFee\",\"type\":\"uint128\"}],\"name\":\"makeShortPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"internalType\":\"struct OptionLib.TokenContracts\",\"name\":\"tokens\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"seriesCount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"expiryCount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"expiredCount\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"vaultCount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"totalDepositedToLendingPool\",\"type\":\"uint128\"},{\"internalType\":\"contract LendingPool\",\"name\":\"lendingPool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_repayAmount\",\"type\":\"uint128\"}],\"name\":\"redeemCollateralFromLendingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"removeLong\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ammAddress\",\"type\":\"address\"}],\"name\":\"setAMMAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_key\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_value\",\"type\":\"uint128\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_iv\",\"type\":\"uint128\"}],\"name\":\"setIV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setNewOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"}],\"name\":\"settleVault\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_collateral\",\"type\":\"uint128\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seriesId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"write\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OptionVault","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000008feebd1fd65b6706b2837792c5dfa5b569c4cea70000000000000000000000004f071924d66bbc71a5254217893cc7d49938b1c40000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a9000000000000000000000000000000000000000000000000000000000000002468747470733a2f2f7572692e70726564792e66696e616e63652f76312f6f7074696f6e7300000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}