{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TomiGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/ITomiStaking.sol';\\nimport './interfaces/ITomiConfig.sol';\\nimport './interfaces/ITomiBallotFactory.sol';\\nimport './interfaces/ITomiBallot.sol';\\nimport './interfaces/ITomiBallotRevenue.sol';\\nimport './interfaces/ITgas.sol';\\nimport './interfaces/ITokenRegistry.sol';\\nimport './libraries/ConfigNames.sol';\\nimport './libraries/TransferHelper.sol';\\nimport './modules/TgasStaking.sol';\\nimport './modules/Ownable.sol';\\nimport './libraries/SafeMath.sol';\\n\\ncontract TomiGovernance is TgasStaking, Ownable, AccessControl {\\n    using SafeMath for uint;\\n\\n    uint public version = 1;\\n    address public configAddr;\\n    address public ballotFactoryAddr;\\n    address public rewardAddr;\\n    address public stakingAddr;\\n\\n    uint public T_CONFIG = 1;\\n    uint public T_LIST_TOKEN = 2;\\n    uint public T_TOKEN = 3;\\n    uint public T_SNAPSHOT = 4;\\n    uint public T_REVENUE = 5;\\n\\n    uint public VOTE_DURATION;\\n    uint public FREEZE_DURATION;\\n    uint public REVENUE_VOTE_DURATION;\\n    uint public REVENUE_FREEZE_DURATION;\\n    uint public MINIMUM_TOMI_REQUIRED_IN_BALANCE = 100e18;\\n\\n    bytes32 public constant SUPER_ADMIN_ROLE = keccak256(abi.encodePacked(\\\"SUPER_ADMIN_ROLE\\\"));\\n    bytes32 REVENUE_PROPOSAL = bytes32('REVENUE_PROPOSAL');\\n    bytes32 SNAPSHOT_PROPOSAL = bytes32('SNAPSHOT_PROPOSAL');\\n\\n    mapping(address => uint) public ballotTypes;\\n    mapping(address => bytes32) public configBallots;\\n    mapping(address => address) public tokenBallots;\\n    mapping(address => uint) public rewardOf;\\n    mapping(address => uint) public ballotOf;\\n    mapping(address => mapping(address => uint)) public applyTokenOf;\\n    mapping(address => mapping(address => bool)) public collectUsers;\\n    mapping(address => address) public tokenUsers;\\n\\n    address[] public ballots;\\n    address[] public revenueBallots;\\n\\n    event ConfigAudited(bytes32 name, address indexed ballot, uint proposal);\\n    event ConfigBallotCreated(address indexed proposer, bytes32 name, uint value, address indexed ballotAddr, uint reward);\\n    event TokenBallotCreated(address indexed proposer, address indexed token, uint value, address indexed ballotAddr, uint reward);\\n    event ProposalerRewardRateUpdated(uint oldVaue, uint newValue);\\n    event RewardTransfered(address indexed from, address indexed to, uint value);\\n    event TokenListed(address user, address token, uint amount);\\n    event ListTokenAudited(address user, address token, uint status, uint burn, uint reward, uint refund);\\n    event TokenAudited(address user, address token, uint status, bool result);\\n    event RewardCollected(address indexed user, address indexed ballot, uint value);\\n    event RewardReceived(address indexed user, uint value);\\n\\n    modifier onlyRewarder() {\\n        require(msg.sender == rewardAddr, 'TomiGovernance: ONLY_REWARDER');\\n        _;\\n    }\\n\\n    modifier onlyRole(bytes32 role) {\\n        require(hasRole(role, msg.sender), \\\"TomiGovernance: sender not allowed to do!\\\");\\n        _;\\n    }\\n\\n    constructor (\\n        address _tgas, \\n        uint _VOTE_DURATION,\\n        uint _FREEZE_DURATION,\\n        uint _REVENUE_VOTE_DURATION,\\n        uint _REVENUE_FREEZE_DURATION\\n    ) TgasStaking(_tgas) public {\\n        _setupRole(SUPER_ADMIN_ROLE, msg.sender);\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _setRoleAdmin(DEFAULT_ADMIN_ROLE, SUPER_ADMIN_ROLE);\\n\\n        VOTE_DURATION = _VOTE_DURATION;\\n        FREEZE_DURATION = _FREEZE_DURATION;\\n        REVENUE_VOTE_DURATION = _REVENUE_VOTE_DURATION;\\n        REVENUE_FREEZE_DURATION = _REVENUE_FREEZE_DURATION;\\n    }\\n\\n    // called after deployment\\n    function initialize(address _rewardAddr, address _configContractAddr, address _ballotFactoryAddr, address _stakingAddr) external onlyOwner {\\n        require(_rewardAddr != address(0) && _configContractAddr != address(0) && _ballotFactoryAddr != address(0) && _stakingAddr != address(0), 'TomiGovernance: INPUT_ADDRESS_IS_ZERO');\\n\\n        stakingAddr = _stakingAddr;\\n        rewardAddr = _rewardAddr;\\n        configAddr = _configContractAddr;\\n        ballotFactoryAddr = _ballotFactoryAddr;\\n        lockTime = getConfigValue(ConfigNames.UNSTAKE_DURATION);\\n    }\\n\\n    function newStakingSettle(address _STAKING) external onlyRole(SUPER_ADMIN_ROLE) {\\n        require(stakingAddr != _STAKING, \\\"STAKING ADDRESS IS THE SAME\\\");\\n        require(_STAKING != address(0), \\\"STAKING ADDRESS IS DEFAULT ADDRESS\\\");\\n        stakingAddr = _STAKING;\\n    }\\n\\n    function changeProposalDuration(uint[4] calldata _durations) external onlyRole(SUPER_ADMIN_ROLE) {\\n        VOTE_DURATION = _durations[0];\\n        FREEZE_DURATION = _durations[1];\\n        REVENUE_VOTE_DURATION = _durations[2];\\n        REVENUE_FREEZE_DURATION = _durations[3];\\n    }\\n\\n    function changeTomiMinimumRequired(uint _newMinimum) external onlyRole(SUPER_ADMIN_ROLE) {\\n        require(_newMinimum != MINIMUM_TOMI_REQUIRED_IN_BALANCE, \\\"TomiGovernance::Tomi required is identical!\\\");\\n        MINIMUM_TOMI_REQUIRED_IN_BALANCE = _newMinimum;\\n    }\\n\\n    // function changeProposalVoteDuration(uint _newDuration) external onlyRole(SUPER_ADMIN_ROLE) {\\n    //     require(_newDuration != VOTE_DURATION, \\\"TomiGovernance::Vote duration has not changed\\\");\\n    //     VOTE_DURATION = _newDuration;\\n    // }\\n\\n    // function changeProposalFreezeDuration(uint _newDuration) external onlyRole(SUPER_ADMIN_ROLE) {\\n    //     require(_newDuration != FREEZE_DURATION, \\\"TomiGovernance::Freeze duration has not changed\\\");\\n    //     FREEZE_DURATION = _newDuration;\\n    // }\\n\\n    // function changeRevenueProposalVoteDuration(uint _newDuration) external onlyRole(SUPER_ADMIN_ROLE) {\\n    //     require(_newDuration != REVENUE_VOTE_DURATION, \\\"TomiGovernance::Vote duration has not changed\\\");\\n    //     REVENUE_VOTE_DURATION = _newDuration;\\n    // }\\n\\n    // function changeRevenueProposalFreezeDuration(uint _newDuration) external onlyRole(SUPER_ADMIN_ROLE) {\\n    //     require(_newDuration != REVENUE_FREEZE_DURATION, \\\"TomiGovernance::Freeze duration has not changed\\\");\\n    //     REVENUE_FREEZE_DURATION = _newDuration;\\n    // }\\n\\n    function vote(address _ballot, uint256 _proposal, uint256 _collateral) external {\\n        require(configBallots[_ballot] != REVENUE_PROPOSAL, \\\"TomiGovernance::Fail due to wrong ballot\\\");\\n        uint256 collateralRemain = balanceOf[msg.sender]; \\n\\n        if (_collateral > collateralRemain) {\\n            uint256 collateralMore = _collateral.sub(collateralRemain);\\n            _transferForBallot(collateralMore, true, ITomiBallot(_ballot).executionTime());\\n        }\\n\\n        ITomiBallot(_ballot).voteByGovernor(msg.sender, _proposal);\\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_collateral);\\n\\n        _transferToStaking(_collateral);\\n        // rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_collateral); \\n    }\\n\\n    function participate(address _ballot, uint256 _collateral) external {\\n        require(configBallots[_ballot] == REVENUE_PROPOSAL, \\\"TomiGovernance::Fail due to wrong ballot\\\");\\n        \\n        uint256 collateralRemain = balanceOf[msg.sender];\\n        uint256 collateralMore = _collateral.sub(collateralRemain);\\n\\n        _transferForBallot(collateralMore, true, ITomiBallot(_ballot).executionTime());\\n        ITomiBallotRevenue(_ballot).participateByGovernor(msg.sender);\\n    }\\n\\n    function audit(address _ballot) external returns (bool) {\\n        if(ballotTypes[_ballot] == T_CONFIG) {\\n            return auditConfig(_ballot);\\n        } else if (ballotTypes[_ballot] == T_LIST_TOKEN) {\\n            return auditListToken(_ballot);\\n        } else if (ballotTypes[_ballot] == T_TOKEN) {\\n            return auditToken(_ballot);\\n        } else {\\n            revert('TomiGovernance: UNKNOWN_TYPE');\\n        }\\n    }\\n\\n    function auditConfig(address _ballot) public returns (bool) {\\n        bool result = ITomiBallot(_ballot).end();\\n        require(result, 'TomiGovernance: NO_PASS');\\n        uint value = ITomiBallot(_ballot).value();\\n        bytes32 name = configBallots[_ballot];\\n        result = ITomiConfig(configAddr).changeConfigValue(name, value);\\n        if (name == ConfigNames.UNSTAKE_DURATION) {\\n            lockTime = value;\\n        } else if (name == ConfigNames.PRODUCE_TGAS_RATE) {\\n            _changeAmountPerBlock(value);\\n        }\\n        emit ConfigAudited(name, _ballot, value);\\n        return result;\\n    }\\n\\n    function auditListToken(address _ballot) public returns (bool) {\\n        bool result = ITomiBallot(_ballot).end();\\n        address token = tokenBallots[_ballot];\\n        address user = tokenUsers[token];\\n        require(ITokenRegistry(configAddr).tokenStatus(token) == ITokenRegistry(configAddr).REGISTERED(), 'TomiGovernance: AUDITED');\\n        uint status = result ? ITokenRegistry(configAddr).PENDING() : ITokenRegistry(configAddr).CLOSED();\\n\\t    uint amount = applyTokenOf[user][token];\\n        (uint burnAmount, uint rewardAmount, uint refundAmount) = (0, 0, 0);\\n        if (result) {\\n            burnAmount = amount * getConfigValue(ConfigNames.LIST_TOKEN_SUCCESS_BURN_PRECENT) / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\\n            rewardAmount = amount - burnAmount;\\n            if (burnAmount > 0) {\\n                TransferHelper.safeTransfer(baseToken, address(0), burnAmount);\\n                totalSupply = totalSupply.sub(burnAmount);\\n            }\\n            if (rewardAmount > 0) {\\n                rewardOf[rewardAddr] = rewardOf[rewardAddr].add(rewardAmount);\\n                ballotOf[_ballot] = ballotOf[_ballot].add(rewardAmount);\\n                _rewardTransfer(rewardAddr, _ballot, rewardAmount);\\n            }\\n            ITokenRegistry(configAddr).publishToken(token);\\n        } else {\\n            burnAmount = amount * getConfigValue(ConfigNames.LIST_TOKEN_FAILURE_BURN_PRECENT) / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\\n            refundAmount = amount - burnAmount;\\n            if (burnAmount > 0) TransferHelper.safeTransfer(baseToken, address(0), burnAmount);\\n            if (refundAmount > 0) TransferHelper.safeTransfer(baseToken, user, refundAmount);\\n            totalSupply = totalSupply.sub(amount);\\n            ITokenRegistry(configAddr).updateToken(token, status);\\n        }\\n\\t    emit ListTokenAudited(user, token, status, burnAmount, rewardAmount, refundAmount);\\n        return result;\\n    }\\n\\n    function auditToken(address _ballot) public returns (bool) {\\n        bool result = ITomiBallot(_ballot).end();\\n        uint status = ITomiBallot(_ballot).value();\\n        address token = tokenBallots[_ballot];\\n        address user = tokenUsers[token];\\n        require(ITokenRegistry(configAddr).tokenStatus(token) != status, 'TomiGovernance: TOKEN_STATUS_NO_CHANGE');\\n        if (result) {\\n            ITokenRegistry(configAddr).updateToken(token, status);\\n        } else {\\n            status = ITokenRegistry(configAddr).tokenStatus(token);\\n        }\\n\\t    emit TokenAudited(user, token, status, result);\\n        return result;\\n    }\\n\\n    function getConfigValue(bytes32 _name) public view returns (uint) {\\n        return ITomiConfig(configAddr).getConfigValue(_name);\\n    }\\n\\n    function _createProposalPrecondition(uint _amount, uint _executionTime) private {\\n        address sender = msg.sender;\\n        if (!hasRole(DEFAULT_ADMIN_ROLE, sender)) {\\n            require(IERC20(baseToken).balanceOf(sender).add(balanceOf[sender]) >= MINIMUM_TOMI_REQUIRED_IN_BALANCE, \\\"TomiGovernance::Require minimum TOMI in balance\\\");\\n            require(_amount >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \\\"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_PROPOSAL\\\");\\n            \\n            uint256 collateralRemain = balanceOf[sender];\\n\\n            if (_amount > collateralRemain) {\\n                uint256 collateralMore = _amount.sub(collateralRemain);\\n                _transferForBallot(collateralMore, true, _executionTime);\\n            } \\n\\n            collateralRemain = balanceOf[sender];\\n            \\n            require(collateralRemain >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \\\"TomiGovernance: COLLATERAL_NOT_ENOUGH_AMOUNT_TO_PROPOSAL\\\");\\n            balanceOf[sender] = collateralRemain.sub(_amount);\\n\\n            _transferToStaking(_amount);\\n        }\\n    }\\n\\n    function createRevenueBallot(\\n        string calldata _subject, \\n        string calldata _content\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (address) {\\n        uint endTime = block.timestamp.add(REVENUE_VOTE_DURATION);\\n        uint executionTime = endTime.add(REVENUE_FREEZE_DURATION);\\n\\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).createShareRevenue(msg.sender, endTime, executionTime, _subject, _content);\\n        configBallots[ballotAddr] = REVENUE_PROPOSAL;\\n        uint reward = _createdBallot(ballotAddr, T_REVENUE);\\n        emit ConfigBallotCreated(msg.sender, REVENUE_PROPOSAL, 0, ballotAddr, reward);\\n        return ballotAddr;\\n    }\\n\\n    function createSnapshotBallot(\\n        uint _amount, \\n        string calldata _subject, \\n        string calldata _content\\n    ) external returns (address) {\\n        uint endTime = block.timestamp.add(VOTE_DURATION);\\n        uint executionTime = endTime.add(FREEZE_DURATION);\\n\\n        _createProposalPrecondition(_amount, executionTime);\\n\\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).create(msg.sender, 0, endTime, executionTime, _subject, _content);\\n        \\n        configBallots[ballotAddr] = SNAPSHOT_PROPOSAL;\\n        // rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\\n\\n        uint reward = _createdBallot(ballotAddr, T_SNAPSHOT);\\n        emit ConfigBallotCreated(msg.sender, SNAPSHOT_PROPOSAL, 0, ballotAddr, reward);\\n        return ballotAddr;\\n    }\\n\\n    function createConfigBallot(bytes32 _name, uint _value, uint _amount, string calldata _subject, string calldata _content) external returns (address) {\\n        require(_value >= 0, 'TomiGovernance: INVALID_PARAMTERS');\\n        { // avoids stack too deep errors\\n        (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable) = ITomiConfig(configAddr).getConfig(_name);\\n        require(enable == 1, \\\"TomiGovernance: CONFIG_DISABLE\\\");\\n        require(_value >= minValue && _value <= maxValue, \\\"TomiGovernance: OUTSIDE\\\");\\n        uint span = _value >= value? (_value - value) : (value - _value);\\n        require(maxSpan >= span, \\\"TomiGovernance: OVERSTEP\\\");\\n        }\\n\\n        uint endTime = block.timestamp.add(VOTE_DURATION);\\n        uint executionTime = endTime.add(FREEZE_DURATION);\\n\\n        _createProposalPrecondition(_amount, executionTime);\\n        \\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).create(msg.sender, _value, endTime, executionTime, _subject, _content);\\n        \\n        configBallots[ballotAddr] = _name;\\n        // rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\\n\\n        uint reward = _createdBallot(ballotAddr, T_CONFIG);\\n        emit ConfigBallotCreated(msg.sender, _name, _value, ballotAddr, reward);\\n        return ballotAddr;\\n    }\\n\\n    function createTokenBallot(address _token, uint _value, uint _amount, string calldata _subject, string calldata _content) external returns (address) {\\n        require(!_isDefaultToken(_token), 'TomiGovernance: DEFAULT_LIST_TOKENS_PROPOSAL_DENY');\\n        uint status = ITokenRegistry(configAddr).tokenStatus(_token);\\n        require(status == ITokenRegistry(configAddr).PENDING(), 'TomiGovernance: ONLY_ALLOW_PENDING');\\n        require(_value == ITokenRegistry(configAddr).OPENED() || _value == ITokenRegistry(configAddr).CLOSED(), 'TomiGovernance: INVALID_STATUS');\\n        require(status != _value, 'TomiGovernance: STATUS_NO_CHANGE');\\n\\n        uint endTime = block.timestamp.add(VOTE_DURATION);\\n        uint executionTime = endTime.add(FREEZE_DURATION);\\n\\n        _createProposalPrecondition(_amount, executionTime);\\n\\n        address ballotAddr = _createTokenBallot(T_TOKEN, _token, _value, _subject, _content, endTime, executionTime);\\n        // rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\\n        return ballotAddr;\\n    }\\n\\n\\tfunction listToken(address _token, uint _amount, string calldata _subject, string calldata _content) external returns (address) {\\n        uint status = ITokenRegistry(configAddr).tokenStatus(_token);\\n        require(status == ITokenRegistry(configAddr).NONE() || status == ITokenRegistry(configAddr).CLOSED(), 'TomiGovernance: LISTED');\\n\\t    // require(_amount >= getConfigValue(ConfigNames.LIST_TGAS_AMOUNT), \\\"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_LIST\\\");\\n\\t    tokenUsers[_token] = msg.sender;\\n\\n        uint endTime = block.timestamp.add(VOTE_DURATION);\\n        uint executionTime = endTime.add(FREEZE_DURATION);\\n\\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\\n            require(_amount >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \\\"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_PROPOSAL\\\");\\n            \\n            uint256 collateralRemain = balanceOf[msg.sender]; \\n            uint256 collateralMore = _amount.sub(collateralRemain);\\n            \\n            applyTokenOf[msg.sender][_token] = _transferForBallot(collateralMore, true, executionTime);\\n            collateralRemain = balanceOf[msg.sender];\\n\\n            require(collateralRemain >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \\\"TomiGovernance: COLLATERAL_NOT_ENOUGH_AMOUNT_TO_PROPOSAL\\\");\\n            balanceOf[msg.sender] = collateralRemain.sub(_amount);\\n\\n            _transferToStaking(_amount);\\n        }\\n\\n\\t    ITokenRegistry(configAddr).registryToken(_token);\\n        address ballotAddr = _createTokenBallot(T_LIST_TOKEN, _token, ITokenRegistry(configAddr).PENDING(), _subject, _content, endTime, executionTime);\\n        // rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\\n        emit TokenListed(msg.sender, _token, _amount);\\n        return ballotAddr;\\n\\t}\\n\\n    function _createTokenBallot(uint _type, address _token, uint _value, string memory _subject, string memory _content, uint _endTime, uint _executionTime) private returns (address) {\\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).create(msg.sender, _value, _endTime, _executionTime, _subject, _content);\\n        \\n        uint reward = _createdBallot(ballotAddr, _type);\\n        ballotOf[ballotAddr] = reward;\\n        tokenBallots[ballotAddr] = _token;\\n        emit TokenBallotCreated(msg.sender, _token, _value, ballotAddr, reward);\\n        return ballotAddr;\\n    }\\n\\n    function collectReward(address _ballot) external returns (uint) {\\n        require(block.timestamp >= ITomiBallot(_ballot).endTime(), \\\"TomiGovernance: NOT_YET_ENDED\\\");\\n        require(!collectUsers[_ballot][msg.sender], 'TomiGovernance: REWARD_COLLECTED');\\n        require(configBallots[_ballot] == REVENUE_PROPOSAL, \\\"TomiGovernance::Fail due to wrong ballot\\\");\\n        \\n        uint amount = getRewardForRevenueProposal(_ballot);\\n        _rewardTransfer(_ballot, msg.sender, amount);\\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\\n        stakingSupply = stakingSupply.add(amount);\\n        rewardOf[msg.sender] = rewardOf[msg.sender].sub(amount);\\n        collectUsers[_ballot][msg.sender] = true;\\n       \\n        emit RewardCollected(msg.sender, _ballot, amount);\\n    }\\n\\n    // function getReward(address _ballot) public view returns (uint) {\\n    //     if (block.timestamp < ITomiBallot(_ballot).endTime() || collectUsers[_ballot][msg.sender]) {\\n    //         return 0;\\n    //     }\\n    //     uint amount;\\n    //     uint shares = ballotOf[_ballot];\\n\\n    //     bool result = ITomiBallot(_ballot).result();\\n\\n    //     if (result) {\\n    //         uint extra;\\n    //         uint rewardRate = getConfigValue(ConfigNames.VOTE_REWARD_PERCENT);\\n    //         if ( rewardRate > 0) {\\n    //            extra = shares * rewardRate / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\\n    //            shares -= extra;\\n    //         }\\n    //         if (msg.sender == ITomiBallot(_ballot).proposer()) {\\n    //             amount = extra;\\n    //         }\\n    //     }\\n\\n    //     if (ITomiBallot(_ballot).total() > 0) {  \\n    //         uint reward = shares * ITomiBallot(_ballot).weight(msg.sender) / ITomiBallot(_ballot).total();\\n    //         amount += ITomiBallot(_ballot).proposer() == msg.sender ? 0: reward;\\n    //     }\\n    //     return amount;\\n    // }\\n\\n    function getRewardForRevenueProposal(address _ballot) public view returns (uint) {\\n        if (block.timestamp < ITomiBallotRevenue(_ballot).endTime() || collectUsers[_ballot][msg.sender]) {\\n            return 0;\\n        }\\n        \\n        uint amount = 0;\\n        uint shares = ballotOf[_ballot];\\n\\n        if (ITomiBallotRevenue(_ballot).total() > 0) {  \\n            uint reward = shares * ITomiBallotRevenue(_ballot).weight(msg.sender) / ITomiBallotRevenue(_ballot).total();\\n            amount += ITomiBallotRevenue(_ballot).proposer() == msg.sender ? 0 : reward; \\n        }\\n        return amount;\\n    }\\n\\n    // TOMI TEST ONLY\\n    // function addReward(uint _value) external onlyRewarder returns (bool) {\\n    function addReward(uint _value) external returns (bool) {\\n        require(_value > 0, 'TomiGovernance: ADD_REWARD_VALUE_IS_ZERO');\\n        uint total = IERC20(baseToken).balanceOf(address(this));\\n        uint diff = total.sub(totalSupply);\\n        require(_value <= diff, 'TomiGovernance: ADD_REWARD_EXCEED');\\n        rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_value);\\n        totalSupply = total;\\n        emit RewardReceived(rewardAddr, _value);\\n    }\\n\\n    function _rewardTransfer(address _from, address _to, uint _value) private returns (bool) {\\n        require(_value >= 0 && rewardOf[_from] >= _value, 'TomiGovernance: INSUFFICIENT_BALANCE');\\n        rewardOf[_from] = rewardOf[_from].sub(_value);\\n        rewardOf[_to] = rewardOf[_to].add(_value);\\n        emit RewardTransfered(_from, _to, _value);\\n    }\\n\\n    function _isDefaultToken(address _token) internal returns (bool) {\\n        address[] memory tokens = ITomiConfig(configAddr).getDefaultListTokens();\\n        for(uint i = 0 ; i < tokens.length; i++){\\n            if (tokens[i] == _token) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function _transferForBallot(uint _amount, bool _wallet, uint _endTime) internal returns (uint) {\\n        if (_wallet && _amount > 0) {\\n            _add(msg.sender, _amount, _endTime);\\n            TransferHelper.safeTransferFrom(baseToken, msg.sender, address(this), _amount);\\n            totalSupply += _amount;\\n        } \\n\\n        if (_amount == 0) allowance[msg.sender] = estimateLocktime(msg.sender, _endTime);\\n\\n        return _amount;\\n    }\\n\\n    function _transferToStaking(uint _amount) internal {\\n        if (stakingAddr != address(0)) {\\n            TransferHelper.safeTransfer(baseToken, stakingAddr, _amount);\\n            ITomiStaking(stakingAddr).updateRevenueShare(_amount);\\n        }\\n    }\\n\\n    function _createdBallot(address _ballot, uint _type) internal returns (uint) {\\n        uint reward = 0;\\n        \\n        if (_type == T_REVENUE) {\\n            reward = rewardOf[rewardAddr];\\n            ballotOf[_ballot] = reward;\\n            _rewardTransfer(rewardAddr, _ballot, reward);\\n        }\\n\\n        _type == T_REVENUE ? revenueBallots.push(_ballot): ballots.push(_ballot);\\n        ballotTypes[_ballot] = _type;\\n        return reward;\\n    }\\n\\n    function ballotCount() external view returns (uint) {\\n        return ballots.length;\\n    }\\n\\n    function ballotRevenueCount() external view returns (uint) {\\n        return revenueBallots.length;\\n    }\\n\\n    function _changeAmountPerBlock(uint _value) internal returns (bool) {\\n        return ITgas(baseToken).changeInterestRatePerBlock(_value);\\n    }\\n\\n    function updateTgasGovernor(address _new) external onlyOwner {\\n        ITgas(baseToken).upgradeGovernance(_new);\\n    }\\n\\n    function upgradeApproveReward() external returns (uint) {\\n        require(rewardOf[rewardAddr] > 0, 'TomiGovernance: UPGRADE_NO_REWARD');\\n        require(ITomiConfig(configAddr).governor() != address(this), 'TomiGovernance: UPGRADE_NO_CHANGE');\\n        TransferHelper.safeApprove(baseToken, ITomiConfig(configAddr).governor(), rewardOf[rewardAddr]);\\n        return rewardOf[rewardAddr]; \\n    }\\n\\n    function receiveReward(address _from, uint _value) external returns (bool) {\\n        require(_value > 0, 'TomiGovernance: RECEIVE_REWARD_VALUE_IS_ZERO');\\n        TransferHelper.safeTransferFrom(baseToken, _from, address(this), _value);\\n        rewardOf[rewardAddr] += _value;\\n        totalSupply += _value;\\n        emit RewardReceived(_from, _value);\\n        return true;\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITomiStaking.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITomiStaking {\\n    function updateRevenueShare(uint256 revenueShared) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITomiConfig.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITomiConfig {\\n    function governor() external view returns (address);\\n    function dev() external view returns (address);\\n    function PERCENT_DENOMINATOR() external view returns (uint);\\n    function getConfig(bytes32 _name) external view returns (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable);\\n    function getConfigValue(bytes32 _name) external view returns (uint);\\n    function changeConfigValue(bytes32 _name, uint _value) external returns (bool);\\n    function checkToken(address _token) external view returns(bool);\\n    function checkPair(address tokenA, address tokenB) external view returns (bool);\\n    function listToken(address _token) external returns (bool);\\n    function getDefaultListTokens() external returns (address[] memory);\\n    function platform() external view returns  (address);\\n    function addToken(address _token) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITomiBallotFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITomiBallotFactory {\\n    function create(\\n        address _proposer,\\n        uint _value,\\n        uint _endTime,\\n        uint _executionTime,\\n        string calldata _subject,\\n        string calldata _content\\n    ) external returns (address);\\n\\n     function createShareRevenue(\\n        address _proposer,\\n        uint _endTime,\\n        uint _executionTime,\\n        string calldata _subject,\\n        string calldata _content\\n    ) external returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITomiBallot.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITomiBallot {\\n    function proposer() external view returns(address);\\n    function endTime() external view returns(uint);\\n    function executionTime() external view returns(uint);\\n    function value() external view returns(uint);\\n    function result() external view returns(bool);\\n    function end() external returns (bool);\\n    function total() external view returns(uint);\\n    function weight(address user) external view returns (uint);\\n    function voteByGovernor(address user, uint256 proposal) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITomiBallotRevenue.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITomiBallotRevenue {\\n    function proposer() external view returns(address);\\n    function endTime() external view returns(uint);\\n    function executionTime() external view returns(uint);\\n    function end() external returns (bool);\\n    function total() external view returns(uint);\\n    function weight(address user) external view returns (uint);\\n    function participateByGovernor(address user) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITgas.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITgas {\\n    function amountPerBlock() external view returns (uint);\\n    function changeInterestRatePerBlock(uint value) external returns (bool);\\n    function getProductivity(address user) external view returns (uint, uint);\\n    function increaseProductivity(address user, uint value) external returns (bool);\\n    function decreaseProductivity(address user, uint value) external returns (bool);\\n    function take() external view returns (uint);\\n    function takeWithBlock() external view returns (uint, uint);\\n    function mint() external returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function upgradeImpl(address _newImpl) external;\\n    function upgradeGovernance(address _newGovernor) external;\\n    function transfer(address to, uint value) external returns (bool);\\n    function approve(address spender, uint value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenRegistry.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\ninterface ITokenRegistry {\\n    function tokenStatus(address _token) external view returns(uint);\\n    function pairStatus(address tokenA, address tokenB) external view returns (uint);\\n    function NONE() external view returns(uint);\\n    function REGISTERED() external view returns(uint);\\n    function PENDING() external view returns(uint);\\n    function OPENED() external view returns(uint);\\n    function CLOSED() external view returns(uint);\\n    function registryToken(address _token) external returns (bool);\\n    function publishToken(address _token) external returns (bool);\\n    function updateToken(address _token, uint _status) external returns (bool);\\n    function updatePair(address tokenA, address tokenB, uint _status) external returns (bool);\\n    function tokenCount() external view returns(uint);\\n    function validTokens() external view returns(address[] memory);\\n    function iterateValidTokens(uint32 _start, uint32 _end) external view returns (address[] memory);\\n}\"\r\n    },\r\n    \"contracts/libraries/ConfigNames.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\nlibrary ConfigNames {\\n    bytes32 public constant PRODUCE_TGAS_RATE = bytes32('PRODUCE_TGAS_RATE');\\n    bytes32 public constant SWAP_FEE_PERCENT = bytes32('SWAP_FEE_PERCENT');\\n    bytes32 public constant LIST_TGAS_AMOUNT = bytes32('LIST_TGAS_AMOUNT');\\n    bytes32 public constant UNSTAKE_DURATION = bytes32('UNSTAKE_DURATION');\\n    // bytes32 public constant EXECUTION_DURATION = bytes32('EXECUTION_DURATION');\\n    bytes32 public constant REMOVE_LIQUIDITY_DURATION = bytes32('REMOVE_LIQUIDITY_DURATION');\\n    bytes32 public constant TOKEN_TO_TGAS_PAIR_MIN_PERCENT = bytes32('TOKEN_TO_TGAS_PAIR_MIN_PERCENT');\\n    bytes32 public constant LIST_TOKEN_FAILURE_BURN_PRECENT = bytes32('LIST_TOKEN_FAILURE_BURN_PRECENT');\\n    bytes32 public constant LIST_TOKEN_SUCCESS_BURN_PRECENT = bytes32('LIST_TOKEN_SUCCESS_BURN_PRECENT');\\n    bytes32 public constant PROPOSAL_TGAS_AMOUNT = bytes32('PROPOSAL_TGAS_AMOUNT');\\n    // bytes32 public constant VOTE_DURATION = bytes32('VOTE_DURATION');\\n    bytes32 public constant VOTE_REWARD_PERCENT = bytes32('VOTE_REWARD_PERCENT');\\n    bytes32 public constant TOKEN_PENGDING_SWITCH = bytes32('TOKEN_PENGDING_SWITCH');\\n    bytes32 public constant TOKEN_PENGDING_TIME = bytes32('TOKEN_PENGDING_TIME');\\n    bytes32 public constant LIST_TOKEN_SWITCH = bytes32('LIST_TOKEN_SWITCH');\\n    bytes32 public constant DEV_PRECENT = bytes32('DEV_PRECENT');\\n    bytes32 public constant FEE_GOVERNANCE_REWARD_PERCENT = bytes32('FEE_GOVERNANCE_REWARD_PERCENT');\\n    bytes32 public constant FEE_LP_REWARD_PERCENT = bytes32('FEE_LP_REWARD_PERCENT');\\n    bytes32 public constant FEE_FUNDME_REWARD_PERCENT = bytes32('FEE_FUNDME_REWARD_PERCENT');\\n    bytes32 public constant FEE_LOTTERY_REWARD_PERCENT = bytes32('FEE_LOTTERY_REWARD_PERCENT');\\n    bytes32 public constant FEE_STAKING_REWARD_PERCENT = bytes32('FEE_STAKING_REWARD_PERCENT');\\n}\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/TgasStaking.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\nimport '../libraries/TransferHelper.sol';\\nimport '../libraries/SafeMath.sol';\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/ITomiConfig.sol';\\nimport '../modules/BaseToken.sol';\\n\\n\\ncontract TgasStaking is BaseToken {\\n    using SafeMath for uint;\\n\\n    uint public lockTime;\\n    uint public totalSupply;\\n    uint public stakingSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => uint) public allowance;\\n\\n    constructor (address _baseToken) public {\\n        initBaseToken(_baseToken);\\n    }\\n\\n    function estimateLocktime(address user, uint _endTime) internal view returns(uint) {\\n        uint collateralLocktime = allowance[user];\\n\\n        if (_endTime == 0) {\\n            uint depositLockTime = block.timestamp + lockTime;\\n            return depositLockTime > collateralLocktime ? depositLockTime: collateralLocktime;\\n        }\\n\\n        return _endTime > collateralLocktime ? _endTime: collateralLocktime; \\n    }\\n\\n    function _add(address user, uint value, uint endTime) internal {\\n        require(value > 0, 'ZERO');\\n        balanceOf[user] = balanceOf[user].add(value);\\n        stakingSupply = stakingSupply.add(value);\\n        allowance[user] = estimateLocktime(user, endTime);\\n    }\\n\\n    function _reduce(address user, uint value) internal {\\n        require(balanceOf[user] >= value && value > 0, 'TgasStaking: INSUFFICIENT_BALANCE');\\n        balanceOf[user] = balanceOf[user].sub(value);\\n        stakingSupply = stakingSupply.sub(value);\\n    }\\n\\n    function deposit(uint _amount) external returns (bool) {\\n        TransferHelper.safeTransferFrom(baseToken, msg.sender, address(this), _amount);\\n        _add(msg.sender, _amount, 0);\\n        totalSupply = IERC20(baseToken).balanceOf(address(this));\\n        return true;\\n    }\\n\\n    // function onBehalfDeposit(address _user, uint _amount) external returns (bool) {\\n    //     TransferHelper.safeTransferFrom(baseToken, msg.sender, address(this), _amount);\\n    //     _add(_user, _amount);\\n    //     totalSupply = IERC20(baseToken).balanceOf(address(this));\\n    //     return true;\\n    // }\\n\\n    function withdraw(uint _amount) external returns (bool) {\\n        require(block.timestamp > allowance[msg.sender], 'TgasStaking: NOT_DUE');\\n        TransferHelper.safeTransfer(baseToken, msg.sender, _amount);\\n        _reduce(msg.sender, _amount);\\n        totalSupply = IERC20(baseToken).balanceOf(address(this));\\n        return true;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/modules/Ownable.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'Ownable: FORBIDDEN');\\n        _;\\n    }\\n\\n    function changeOwner(address _newOwner) public onlyOwner {\\n        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\\n        emit OwnerChanged(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.6;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/BaseToken.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.16;\\n\\ncontract BaseToken {\\n    address public baseToken;\\n\\n    // called after deployment\\n    function initBaseToken(address _baseToken) internal {\\n        require(baseToken == address(0), 'INITIALIZED');\\n        require(_baseToken != address(0), 'ADDRESS_IS_ZERO');\\n        baseToken = _baseToken;  // it should be tgas token address\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tgas\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_VOTE_DURATION\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_FREEZE_DURATION\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_REVENUE_VOTE_DURATION\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_REVENUE_FREEZE_DURATION\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ballot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"ConfigAudited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ballotAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ConfigBallotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"ListTokenAudited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVaue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ProposalerRewardRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ballot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RewardCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RewardReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RewardTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"TokenAudited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ballotAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"TokenBallotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenListed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREEZE_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_TOMI_REQUIRED_IN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REVENUE_FREEZE_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REVENUE_VOTE_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPER_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_CONFIG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_LIST_TOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_REVENUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_SNAPSHOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"T_TOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"applyTokenOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"}],\"name\":\"audit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"}],\"name\":\"auditConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"}],\"name\":\"auditListToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"}],\"name\":\"auditToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ballotCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ballotFactoryAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ballotOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ballotRevenueCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ballotTypes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ballots\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"_durations\",\"type\":\"uint256[4]\"}],\"name\":\"changeProposalDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMinimum\",\"type\":\"uint256\"}],\"name\":\"changeTomiMinimumRequired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"}],\"name\":\"collectReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collectUsers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"configBallots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_subject\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_content\",\"type\":\"string\"}],\"name\":\"createConfigBallot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_subject\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_content\",\"type\":\"string\"}],\"name\":\"createRevenueBallot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_subject\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_content\",\"type\":\"string\"}],\"name\":\"createSnapshotBallot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_subject\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_content\",\"type\":\"string\"}],\"name\":\"createTokenBallot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getConfigValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"}],\"name\":\"getRewardForRevenueProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_configContractAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ballotFactoryAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingAddr\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_subject\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_content\",\"type\":\"string\"}],\"name\":\"listToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_STAKING\",\"type\":\"address\"}],\"name\":\"newStakingSettle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateral\",\"type\":\"uint256\"}],\"name\":\"participate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"receiveReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revenueBallots\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBallots\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"updateTgasGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeApproveReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ballot\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_proposal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateral\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TomiGovernance","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000533e90705c0d1a364eb63d620ea16c8478179894000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000012c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}