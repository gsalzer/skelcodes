{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/models/AccountingModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.6;\\n\\nimport \\\"../interfaces/IAccountingModel.sol\\\";\\n\\ncontract AccountingModel is IAccountingModel {\\n    uint256 constant public scaleFactor = 10 ** 18;\\n\\n    function calcJuniorProfits(\\n        uint256 entryPrice,\\n        uint256 currentPrice,\\n        uint256 upsideExposureRate,\\n        uint256 totalSeniors,\\n        uint256 //totalBalance\\n    ) public pure override returns (uint256) {\\n        // price went down => there are no profits for the juniors\\n        if (currentPrice <= entryPrice) {\\n            return 0;\\n        }\\n\\n        uint256 x = currentPrice - entryPrice;\\n        uint256 y = scaleFactor - upsideExposureRate;\\n\\n        // (current price - entry price) * (1 - upside rate) * total seniors / current price\\n        return x * y * totalSeniors / currentPrice / scaleFactor;\\n    }\\n\\n    /// @notice Calculates the junior losses (in other words, senior profits) based on the current pool conditions\\n    /// @dev It always returns 0 if the price went up.\\n    /// @return The amount, in pool tokens, that is considered loss for the juniors\\n    function calcSeniorProfits(\\n        uint256 entryPrice,\\n        uint256 currentPrice,\\n        uint256 downsideProtectionRate,\\n        uint256 totalSeniors,\\n        uint256 //totalBalance\\n    ) public pure override returns (uint256) {\\n        // price went up => there are no losses for the juniors\\n        if (entryPrice <= currentPrice) {\\n            return 0;\\n        }\\n\\n        // entryPrice * (1 - downsideProtectionRate) + 1\\n        // adding +1 to avoid rounding errors that would cause it to return profits that are greater than the junior liquidity\\n        // minPrice would end up equal to 0 if the downsideProtectionRate is 100%\\n        uint256 minPrice = entryPrice * (scaleFactor - downsideProtectionRate) / scaleFactor + 1;\\n\\n        // when there are no juniors in the pool and the downside protection rate is 0,\\n        // the minPrice would be equal to `entryPrice + 1`\\n        if (entryPrice <= minPrice) {\\n            return 0;\\n        }\\n\\n        uint256 calcPrice = currentPrice;\\n        if (calcPrice < minPrice) {\\n            calcPrice = minPrice;\\n        }\\n\\n        return totalSeniors * entryPrice / calcPrice - totalSeniors;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccountingModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.6;\\n\\ninterface IAccountingModel {\\n    function calcJuniorProfits(\\n        uint256 entryPrice,\\n        uint256 currentPrice,\\n        uint256 upsideExposureRate,\\n        uint256 totalSeniors,\\n        uint256 totalBalance\\n    ) external pure returns (uint256);\\n\\n    function calcSeniorProfits(\\n        uint256 entryPrice,\\n        uint256 currentPrice,\\n        uint256 downsideProtectionRate,\\n        uint256 totalSeniors,\\n        uint256 totalBalance\\n    ) external pure returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upsideExposureRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSeniors\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calcJuniorProfits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downsideProtectionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSeniors\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calcSeniorProfits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaleFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AccountingModel","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}