{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/Governance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Governance\\n * @dev The Governance contract allows to execute certain actions via majority of votes.\\n */\\ncontract Governance {\\n    mapping(bytes32 => Proposal) public proposals;\\n    bytes32[] public proposalsHashes;\\n    uint256 public proposalsCount;\\n\\n    mapping(address => bool) public isVoter;\\n    address[] public voters;\\n    uint256 public votersCount;\\n\\n    struct Proposal {\\n        bool finished;\\n        uint256 yesVotes;\\n        uint256 noVotes;\\n        uint256 totalVoters;\\n        mapping(address => bool) votedFor;\\n        mapping(address => bool) votedAgainst;\\n        address targetContract;\\n        bytes data;\\n    }\\n\\n    event ProposalStarted(bytes32 proposalHash);\\n    event ProposalFinished(bytes32 proposalHash);\\n    event ProposalExecuted(bytes32 proposalHash);\\n    event Vote(bytes32 proposalHash, bool vote, uint256 yesVotes, uint256 noVotes, uint256 votersCount);\\n    event VoterAdded(address voter);\\n    event VoterDeleted(address voter);\\n\\n    /**\\n     * @dev The Governance constructor adds sender to voters list.\\n     */\\n    constructor(address[] memory _voters) {\\n        for (uint256 i=0; i<_voters.length; i++){\\n            voters.push(_voters[i]);\\n            isVoter[_voters[i]] = true;\\n        }\\n        proposalsCount = 0;\\n        votersCount = _voters.length;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the voter.\\n     */\\n    modifier onlyVoter() {\\n        require(isVoter[msg.sender], \\\"Should be voter\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the Governance contract.\\n     */\\n    modifier onlyMe() {\\n        require(msg.sender == address(this), \\\"Call only via Governance\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Creates a new voting proposal for the execution `_data` of `_targetContract`.\\n     * Only voter can create a new proposal.\\n     *\\n     * Requirements:\\n     *\\n     * - `_targetContract` cannot be the zero address.\\n     * - `_data` length must not be less than 4 bytes.\\n     *\\n     * @notice Create a new voting proposal for the execution `_data` of `_targetContract`. You must be voter.\\n     * @param _targetContract Target contract address that can execute target `_data`\\n     * @param _data Target calldata to execute\\n     */\\n    function newProposal(address _targetContract, bytes memory _data) public onlyVoter {\\n        require(_targetContract != address(0), \\\"Address must be non-zero\\\");\\n        require(_data.length >= 4, \\\"Tx must be 4+ bytes\\\");\\n        // solhint-disable not-rely-on-time\\n        bytes32 _proposalHash = keccak256(abi.encodePacked(_targetContract, _data, block.timestamp));\\n        require(proposals[_proposalHash].data.length == 0, \\\"The poll has already been initiated\\\");\\n        proposals[_proposalHash].targetContract = _targetContract;\\n        proposals[_proposalHash].data = _data;\\n        proposals[_proposalHash].totalVoters = votersCount;\\n        proposalsHashes.push(_proposalHash);\\n        proposalsCount = proposalsCount + 1;\\n        emit ProposalStarted(_proposalHash);\\n    }\\n\\n    /**\\n     * @dev Adds sender's vote to the proposal and then follows the majority voting algoritm.\\n     *\\n     * Requirements:\\n     *\\n     * - proposal with `_proposalHash` must not be finished.\\n     * - sender must not be already voted.\\n     *\\n     * @notice Vote \\\"for\\\" or \\\"against\\\" in proposal with `_proposalHash` hash.\\n     * @param _proposalHash Unique mapping key of proposal\\n     * @param _yes 1 is vote \\\"for\\\" and 0 is \\\"against\\\"\\n     */\\n    function vote(bytes32 _proposalHash, bool _yes) public onlyVoter {\\n        // solhint-disable code-complexity\\n        require(!proposals[_proposalHash].finished, \\\"Already finished\\\");\\n        require(!proposals[_proposalHash].votedFor[msg.sender], \\\"Already voted\\\");\\n        require(!proposals[_proposalHash].votedAgainst[msg.sender], \\\"Already voted\\\");\\n        if (proposals[_proposalHash].totalVoters != votersCount) proposals[_proposalHash].totalVoters = votersCount;\\n        if (_yes) {\\n            proposals[_proposalHash].yesVotes = proposals[_proposalHash].yesVotes + 1;\\n            proposals[_proposalHash].votedFor[msg.sender] = true;\\n        } else {\\n            proposals[_proposalHash].noVotes = proposals[_proposalHash].noVotes + 1;\\n            proposals[_proposalHash].votedAgainst[msg.sender] = true;\\n        }\\n        emit Vote(\\n            _proposalHash,\\n            _yes,\\n            proposals[_proposalHash].yesVotes,\\n            proposals[_proposalHash].noVotes,\\n            votersCount\\n        );\\n        if (proposals[_proposalHash].yesVotes > votersCount / 2) {\\n            executeProposal(_proposalHash);\\n            finishProposal(_proposalHash);\\n        } else if (proposals[_proposalHash].noVotes >= (votersCount + 1) / 2) {\\n            finishProposal(_proposalHash);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true in first output if `_address` is already voted in\\n     * proposal with `_proposalHash` hash.\\n     * Second output shows, if voter is voted for (true) or against (false).\\n     *\\n     * @param _proposalHash Unique mapping key of proposal\\n     * @param _address Address of the one who is checked\\n     */\\n    function getVoted(bytes32 _proposalHash, address _address) public view returns (bool, bool) {\\n        bool isVoted = proposals[_proposalHash].votedFor[_address] || proposals[_proposalHash].votedAgainst[_address];\\n        bool side = proposals[_proposalHash].votedFor[_address];\\n        return (isVoted, side);\\n    }\\n\\n    /**\\n     * @dev Adds `_address` to the voters list.\\n     * This method can be executed only via proposal of this Governance contract.\\n     *\\n     * Requirements:\\n     *\\n     * - `_address` cannot be the zero address.\\n     * - `_address` cannot be already in voters list.\\n     *\\n     * @param _address Address of voter to add\\n     */\\n    function addVoter(address _address) public onlyMe {\\n        require(_address != address(0), \\\"Need non-zero address\\\");\\n        require(!isVoter[_address], \\\"Already in voters list\\\");\\n        voters.push(_address);\\n        isVoter[_address] = true;\\n        votersCount = votersCount + 1;\\n        emit VoterAdded(_address);\\n    }\\n\\n    /**\\n     * @dev Removes `_address` from the voters list.\\n     * This method can be executed only via proposal of this Governance contract.\\n     *\\n     * Requirements:\\n     *\\n     * - `_address` must be in voters list.\\n     * - Num of voters must be more than one.\\n     *\\n     * @param _address Address of voter to delete\\n     */\\n    function delVoter(address _address) public onlyMe {\\n        require(isVoter[_address], \\\"Not in voters list\\\");\\n        require(votersCount > 1, \\\"Can not delete single voter\\\");\\n        for (uint256 i = 0; i < voters.length; i++) {\\n            if (voters[i] == _address) {\\n                if (voters.length > 1) {\\n                    voters[i] = voters[voters.length - 1];\\n                }\\n                voters.pop(); // Implicitly recovers gas from last element storage\\n                isVoter[_address] = false;\\n                votersCount = votersCount - 1;\\n                emit VoterDeleted(_address);\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes data in proposal with `_proposalHash` hash.\\n     * This method can be executed only from vote() method.\\n     */\\n    function executeProposal(bytes32 _proposalHash) internal {\\n        require(!proposals[_proposalHash].finished, \\\"Already finished\\\");\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returnData) = address(proposals[_proposalHash].targetContract).call(\\n            proposals[_proposalHash].data\\n        );\\n        require(success, string(returnData));\\n        emit ProposalExecuted(_proposalHash);\\n    }\\n\\n    /**\\n     * @dev Finishes proposal with `_proposalHash` hash.\\n     * This method can be executed only from vote() method.\\n     */\\n    function finishProposal(bytes32 _proposalHash) internal {\\n        require(!proposals[_proposalHash].finished, \\\"Already finished\\\");\\n        proposals[_proposalHash].finished = true;\\n        emit ProposalFinished(_proposalHash);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_voters\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vote\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yesVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"noVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votersCount\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoterDeleted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addVoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"delVoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proposalHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isVoter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"newProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"yesVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVoters\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalsHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proposalHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_yes\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000327e2f134f23f47c367559c37ca9cca0763e92a0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}