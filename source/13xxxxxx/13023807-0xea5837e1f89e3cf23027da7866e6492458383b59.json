{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity =0.8.6;\r\n\r\n/**\r\n * Author: Michael Liao\r\n * \r\n * https://michaelliao.github.io/contract-deployer/\r\n * \r\n * A contract-deploy factory which deploys contract as same address on different ETH-compatible chains (e.g. ETH, BSC, Polygon, etc.)\r\n * \r\n * How to generate a specific prefix for contract address (replace bytecode and constructorArgs to yours):\r\n * \r\n * <code>\r\n * const ethUtil = require('ethereumjs-util');\r\n * const prefix = \"Fe666\";\r\n * \r\n * // ContractFactory address:\r\n * const deployContract = 'ea5837e1f89e3cf23027da7866e6492458383b59';\r\n * // contract bytecode:\r\n * const bytecode = '6080604052348015...';\r\n * // constructor args:\r\n * const constructorArgs = '0000000000000000...';\r\n * \r\n * // bytecode hash:\r\n * let bytecodeHash = ethUtil.keccak256(new Buffer(bytecode + constructorArgs, 'hex')).toString('hex');\r\n * \r\n * // find salt:\r\n * for (let i = 0; i< 0xfffffff; i++) {\r\n *     let salt = i.toString(16).padStart(64, '0');\r\n *     // payload data:\r\n *     let payload = 'ff' + deployContract + salt + bytecodeHash;\r\n *     // contract address:\r\n *     let addr = ethUtil.bufferToHex(ethUtil.keccak256(new Buffer(payload, 'hex'))).substr(26);\r\n *     // test prefix:\r\n *     if (addr.startsWith(prefix)) {\r\n *         console.log(salt);\r\n *         console.log(addr);\r\n *         break;\r\n *     }\r\n * }\r\n * console.log('END');\r\n * </code>\r\n */\r\ncontract ContractDeployer {\r\n\r\n    event ContractDeployed(address creatorAddress, address contractAddress);\r\n\r\n    address public owner;\r\n    uint256 public fee;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        fee = 0.01 ether;\r\n    }\r\n\r\n    function setOwner(address _to) public {\r\n        require(owner == msg.sender, \"Not owner\");\r\n        require(_to != address(0), \"Zero address\");\r\n        owner = _to;\r\n    }\r\n\r\n    function setFee(uint256 _fee) public {\r\n        require(owner == msg.sender, \"Not owner\");\r\n        fee = _fee;\r\n    }\r\n\r\n    function withdrawFee(address payable _to) public {\r\n        require(owner == msg.sender, \"Not owner\");\r\n        require(_to != address(0), \"Zero address\");\r\n        _to.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * deploy contract by salt, contract bytecode.\r\n     */\r\n    function deployContract(bytes32 salt, bytes memory contractBytecode) public payable {\r\n        require(msg.value == fee, \"Invalid fee\");\r\n        address addr;\r\n        assembly {\r\n            addr := create2(0, add(contractBytecode, 0x20), mload(contractBytecode), salt)\r\n        }\r\n        require(addr != address(0), \"Create2: Failed on deploy\");\r\n        emit ContractDeployed(msg.sender, addr);\r\n    }\r\n\r\n    /**\r\n     * deploy contract by salt, contract bytecode and constructor args.\r\n     */\r\n    function deployContractWithConstructor(bytes32 salt, bytes memory contractBytecode, bytes memory constructorArgsEncoded) public payable {\r\n        require(msg.value == fee, \"Invalid fee\");\r\n        // deploy contracts with constructor (address):\r\n        bytes memory payload = abi.encodePacked(contractBytecode, constructorArgsEncoded);\r\n        address addr;\r\n        assembly {\r\n            addr := create2(0, add(payload, 0x20), mload(payload), salt)\r\n        }\r\n        require(addr != address(0), \"Create2: Failed on deploy\");\r\n        emit ContractDeployed(msg.sender, addr);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"contractBytecode\",\"type\":\"bytes\"}],\"name\":\"deployContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"contractBytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgsEncoded\",\"type\":\"bytes\"}],\"name\":\"deployContractWithConstructor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ContractDeployer","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7c24708611f1f5b4bd2f7b6c0788e443c3e3ead70200fbd44817753a06409af5"}]}