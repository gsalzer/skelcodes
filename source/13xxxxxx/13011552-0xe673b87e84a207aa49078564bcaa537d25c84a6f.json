{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\ninterface paintglyphsV1Contract {\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n}\r\n\r\ninterface ERC721TokenReceiver\r\n{\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\ncontract Repaintedglyphs {\r\n\r\n    event Generated(uint indexed index, address indexed a, string value);\r\n\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    event ColorChanged(uint id, uint symbolToUpdate, uint newColor);\r\n    \r\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    uint public constant TOKEN_LIMIT = 512;\r\n    uint public constant ARTIST_PRINTS = 0;\r\n\r\n    uint public constant PRICE = 200 finney;\r\n\r\n    address payable public constant BENEFICIARY = 0x8C9eEEcaeb226f1B8C1385abE0960754e08EC285;\r\n\r\n    mapping (uint => address) private idToCreator;\r\n    mapping (uint => uint8) private idToSymbolScheme;\r\n    mapping (uint => uint256) private idToBackgroundColor;\r\n    mapping (uint => uint256[8]) private idToColorScheme;\r\n    mapping (uint => string) private processingCode;\r\n\r\n    // ERC 165\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to the address that owns it.\r\n     */\r\n    mapping (uint256 => address) internal idToOwner;\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to the seed used to make it.\r\n     */\r\n    mapping (uint256 => uint256) internal idToSeed;\r\n    mapping (uint256 => uint256) internal seedToId;\r\n\r\n    /**\r\n     * @dev Mapping from NFT ID to approved address.\r\n     */\r\n    mapping (uint256 => address) internal idToApproval;\r\n\r\n    /**\r\n     * @dev Mapping from owner address to mapping of operator addresses.\r\n     */\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n    /**\r\n     * @dev Mapping from owner to list of owned NFT IDs.\r\n     */\r\n    mapping(address => uint256[]) internal ownerToIds;\r\n\r\n    /**\r\n     * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n     */\r\n    mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n    /**\r\n     * @dev Total number of tokens.\r\n     */\r\n    uint internal numTokens = 102; //start index at 102 (# of paintglyphs v1)\r\n\r\n    /**\r\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n     * @param _tokenId ID of the NFT to validate.\r\n     */\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n     * @param _tokenId ID of the NFT to transfer.\r\n     */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender\r\n            || idToApproval[_tokenId] == msg.sender\r\n            || ownerToOperators[tokenOwner][msg.sender]\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that _tokenId is a valid Token.\r\n     * @param _tokenId ID of the NFT to validate.\r\n     */\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0));\r\n        _;\r\n    }\r\n    \r\n        \r\n    modifier isOwner() {\r\n        require(msg.sender == owner, \"Must be deployer of contract\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     */\r\n    constructor() public {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\r\n        paintglyphsV1 = paintglyphsV1Contract(paintglyphsAddress);\r\n        owner = msg.sender;\r\n        setURI(\"https://paintglyphsV2.azurewebsites.net/api/HttpTrigger?id=\");\r\n    }\r\n\r\n    ///////////////////\r\n    //// GENERATOR ////\r\n    ///////////////////\r\n\r\n    int constant ONE = int(0x100000000);\r\n    uint constant USIZE = 32;\r\n    int constant SIZE = int(USIZE);\r\n    int constant HALF_SIZE = SIZE / int(2);\r\n    address public owner;\r\n    string URI;\r\n\r\n    int constant SCALE = int(0x1b81a81ab1a81a823);\r\n    int constant HALF_SCALE = SCALE / int(2);\r\n\r\n    bytes prefix = \"data:text/plain;charset=utf-8,\";\r\n\r\n    string internal nftName = \"Paintglyphs V2\";\r\n    string internal nftSymbol = \"p☵2\";\r\n    address public paintglyphsAddress = 0x2E8b45D550E4bb8c7986EE98879C1740519E0A1A;\r\n    string public allSymbols = \"0 - ░; 1 - ▒; 2 - ■; 3 - ┼; 4 - ▓; 5 - ▄; 6 - ▀; 7 - ≡\";\r\n    \r\n    paintglyphsV1Contract paintglyphsV1;\r\n\r\n    function abs(int n) internal pure returns (int) {\r\n        if (n >= 0) return n;\r\n        return -n;\r\n    }\r\n    \r\n    function getStartColor(uint a) internal pure returns (uint256) {\r\n        uint256 xxxxff = a % 96;\r\n        uint256 xxffxx = xxxxff*256;\r\n        uint256 ffxxxx = xxffxx*256;\r\n        uint256 randomColor = xxxxff + xxffxx + ffxxxx;\r\n        return randomColor;\r\n    }\r\n\r\n    function getBackgroundColor(uint a) internal pure returns (uint256) {\r\n        uint256 xxxxff = (a % 128) + 128;\r\n        uint256 xxffxx = xxxxff*256;\r\n        uint256 ffxxxx = xxffxx*256;\r\n        uint256 randomColor = xxxxff + xxffxx + ffxxxx;\r\n        return randomColor;\r\n    }\r\n    \r\n    function getScheme(uint a) internal pure returns (uint8) {\r\n        uint index = a % 100;\r\n        uint8 scheme;\r\n        if (index < 22) {\r\n            scheme = 1;\r\n        } else if (index < 41) {\r\n            scheme = 2;\r\n        } else if (index < 58) {\r\n            scheme = 3;\r\n        } else if (index < 72) {\r\n            scheme = 4;\r\n        } else if (index < 84) {\r\n            scheme = 5;\r\n        } else if (index < 93) {\r\n            scheme = 6;\r\n        }else {\r\n            scheme = 7;\r\n        }\r\n        return scheme;\r\n    }\r\n\r\n    /* * ** *** ***** ******** ************* ******** ***** *** ** * */\r\n\r\n    // The following code generates art.\r\n\r\n    function draw(uint id) public view returns (string memory) {\r\n        uint a = uint((keccak256(abi.encodePacked(idToSeed[id]))));\r\n        bytes memory output = new bytes(USIZE * (USIZE + 3) + 30);\r\n        uint c;\r\n        for (c = 0; c < 30; c++) {\r\n            output[c] = prefix[c];\r\n        }\r\n        int x = 0;\r\n        int y = 0;\r\n        uint v = 0;\r\n        uint value = 0;\r\n        uint mod = (a % 11) + 10;\r\n        bytes10 symbols;\r\n        if (idToSymbolScheme[id] == 0) {\r\n            revert();\r\n        } else if (idToSymbolScheme[id] == 1) {\r\n            symbols = 0x3030302E2E2E2E2E2E2E; // ░\r\n        } else if (idToSymbolScheme[id] == 2) { \r\n            symbols = 0x303130312E2E2E2E2E2E; // ░▒\r\n        } else if (idToSymbolScheme[id] == 3) {\r\n            symbols = 0x323332332E2E2E2E2E2E; // ■┼\r\n        } else if (idToSymbolScheme[id] == 4) {\r\n            symbols = 0x303134302E2E2E2E2E2E; // ░▒▓\r\n        } else if (idToSymbolScheme[id] == 5) {\r\n            symbols = 0x3035362E2E2E2E2E2E2E; // ░▄▀\r\n        } else if (idToSymbolScheme[id] == 6) {\r\n            symbols = 0x313731332E2E2E2E2E2E; // ▒┼≡\r\n        } else {\r\n            symbols = 0x30313233342E2E2E2E2E; // ░▒■┼▓\r\n        }\r\n        for (int i = int(0); i < SIZE; i++) {\r\n            y = (2 * (i - HALF_SIZE) + 1);\r\n            if (a % 3 == 1) {\r\n                y = -y;\r\n            } else if (a % 3 == 2) {\r\n                y = abs(y);\r\n            }\r\n            y = y * int(a);\r\n            for (int j = int(0); j < SIZE; j++) {\r\n                x = (2 * (j - HALF_SIZE) + 1);\r\n                if (a % 2 == 1) {\r\n                    x = abs(x);\r\n                }\r\n                x = x * int(a);\r\n                v = uint(x * y / ONE) % mod;\r\n                if (v < 10) {\r\n                    value = uint(uint8(symbols[v]));\r\n                } else {\r\n                    value = 0x2E;\r\n                }\r\n                output[c] = byte(bytes32(value << 248));\r\n                c++;\r\n            }\r\n            output[c] = byte(0x25);\r\n            c++;\r\n            output[c] = byte(0x30);\r\n            c++;\r\n            output[c] = byte(0x41);\r\n            c++;\r\n        }\r\n        string memory result = string(output);\r\n        return result;\r\n    }\r\n\r\n    /* * ** *** ***** ******** ************* ******** ***** *** ** * */\r\n    \r\n    function creator(uint _id) external view returns (address) {\r\n        return idToCreator[_id];\r\n    }\r\n\r\n    function symbolScheme(uint _id) external view returns (uint8) {\r\n        return idToSymbolScheme[_id];\r\n    }\r\n\r\n    function backgroundScheme(uint _id) external view returns (uint256) {\r\n        return idToBackgroundColor[_id];\r\n    }\r\n\r\n    function colorScheme(uint _id) external view returns (uint256 color0, uint256 color1, uint color2, uint color3, uint color4, uint color5, uint color6, uint color7) {\r\n        color0 = idToColorScheme[_id][0];\r\n        color1 = idToColorScheme[_id][1];\r\n        color2 = idToColorScheme[_id][2];\r\n        color3 = idToColorScheme[_id][3];\r\n        color4 = idToColorScheme[_id][4];\r\n        color5 = idToColorScheme[_id][5];\r\n        color6 = idToColorScheme[_id][6];\r\n        color7 = idToColorScheme[_id][7];\r\n    }\r\n    \r\n    function updateProcessingCode(string memory newProcessingCode, uint256 version) public {\r\n        processingCode[version] = newProcessingCode;\r\n    }\r\n    \r\n    function showProcessingCode(uint version) external view returns (string memory) {\r\n        return processingCode[version];\r\n    }\r\n\r\n    //////////////////////////\r\n    //// ERC 721 and 165  ////\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Returns whether the target address is a contract.\r\n     * @param _addr Address to check.\r\n     */\r\n    function isContract(address _addr) internal view returns (bool addressCheck) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(_addr) } // solhint-disable-line\r\n        addressCheck = size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check which interfaces are suported by this contract.\r\n     * @param _interfaceID Id of the interface.\r\n     * @return True if _interfaceID is supported, false otherwise.\r\n     */\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n     * be changed to payable.\r\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n     * `onERC721Received` on `_to` and throws if the return value is not\r\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     * @param _data Additional data with no specified format, sent in call to `_to`.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n     * be changed to payable.\r\n     * @notice This works identically to the other function with an extra data parameter, except this\r\n     * function just sets data to \"\"\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n     * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\r\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n     * they maybe be permanently lost.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n     * the current NFT owner, or an authorized operator of the current owner.\r\n     * @param _approved Address to be approved for the given NFT ID.\r\n     * @param _tokenId ID of the token to be approved.\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external canOperate(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        idToApproval[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n     * @notice This works even if sender doesn't own any tokens at the time.\r\n     * @param _operator Address to add to the set of authorized operators.\r\n     * @param _approved True if the operators is approved, false to revoke approval.\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n     * considered invalid, and this function throws for queries about the zero address.\r\n     * @param _owner Address for whom to query the balance.\r\n     * @return Balance of _owner.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return _getOwnerNFTCount(_owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n     * invalid, and queries about them do throw.\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\r\n        _owner = idToOwner[_tokenId];\r\n        require(_owner != address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the approved address for a single NFT.\r\n     * @notice Throws if `_tokenId` is not a valid NFT.\r\n     * @param _tokenId ID of the NFT to query the approval of.\r\n     * @return Address that _tokenId is approved for.\r\n     */\r\n    function getApproved(uint256 _tokenId) external view validNFToken(_tokenId) returns (address) {\r\n        return idToApproval[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n     * @param _owner The address that owns the NFTs.\r\n     * @param _operator The address that acts on behalf of the owner.\r\n     * @return True if approved for all, false otherwise.\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Actually preforms the transfer.\r\n     * @notice Does NO checks.\r\n     * @param _to Address of a new owner.\r\n     * @param _tokenId The NFT that is being transferred.\r\n     */\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        address from = idToOwner[_tokenId];\r\n        _clearApproval(_tokenId);\r\n\r\n        _removeNFToken(from, _tokenId);\r\n        _addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n}\r\n\r\n\r\n    function createPiece(uint seed) external payable {\r\n        return _mint(msg.sender, seed);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Mints a new NFT.\r\n     * @notice This is an internal function which should be called from user-implemented external\r\n     * mint function. Its purpose is to show and properly initialize data structures when using this\r\n     * implementation.\r\n     * @param _to The address that will own the minted NFT.\r\n     */\r\n    function _mint(address _to, uint seed) internal {\r\n        require(_to != address(0));\r\n        require(numTokens < TOKEN_LIMIT);\r\n        uint amount = 0;\r\n        if (numTokens >= ARTIST_PRINTS) {\r\n            amount = PRICE;\r\n            require(msg.value >= amount);\r\n        }\r\n        require(seedToId[seed] == 0);\r\n        uint id = numTokens + 1;\r\n\r\n        idToCreator[id] = _to;\r\n        idToSeed[id] = seed;\r\n        seedToId[seed] = id;\r\n        uint a = uint((keccak256(abi.encodePacked(seed,id))));\r\n        idToBackgroundColor[id] = getBackgroundColor(a);\r\n        idToSymbolScheme[id] = getScheme(a);\r\n        uint randomColor;\r\n        \r\n        for (uint i = 0; i<8; i = i+1) {\r\n            randomColor = getStartColor(uint(keccak256(abi.encodePacked(a,id,i))));\r\n            idToColorScheme[id][i] = randomColor;\r\n        }\r\n\r\n        numTokens = numTokens + 1;\r\n        _addNFToken(_to, id);\r\n\r\n        if (msg.value > amount) {\r\n            msg.sender.transfer(msg.value - amount);\r\n        }\r\n        if (amount > 0) {\r\n            BENEFICIARY.transfer(address(this).balance);\r\n        }\r\n\r\n        emit Transfer(address(0), _to, id);\r\n        \r\n        feelingLuckyColor(id);\r\n    }\r\n\r\n    function createWithV1(uint seed, uint v1GlyphID) external {\r\n        require(v1GlyphID < 103);\r\n        require(address(uint160(paintglyphsV1.ownerOf(v1GlyphID))) == msg.sender);\r\n        \r\n        paintglyphsV1.transferFrom(msg.sender,address(this),v1GlyphID);\r\n        \r\n        return _mintWithV1(msg.sender, seed, v1GlyphID);\r\n    }\r\n    \r\n    function _mintWithV1(address _to, uint seed, uint v1GlyphID) internal {\r\n        require(_to != address(0));\r\n        require(numTokens <= TOKEN_LIMIT);\r\n        \r\n        require(seedToId[seed] == 0);\r\n\r\n        uint id = v1GlyphID;\r\n        \r\n        idToCreator[id] = _to;\r\n        idToSeed[id] = seed;\r\n        seedToId[seed] = id;\r\n        uint a = uint((keccak256(abi.encodePacked(seed,id))));\r\n        idToBackgroundColor[id] = getBackgroundColor(a);\r\n        idToSymbolScheme[id] = getScheme(a);\r\n        uint randomColor;\r\n        \r\n        for (uint i = 0; i<8; i = i+1) {\r\n            randomColor = getStartColor(uint(keccak256(abi.encodePacked(a,id,i))));\r\n            idToColorScheme[id][i] = randomColor;\r\n        }\r\n\r\n        _addNFToken(_to, id);\r\n\r\n        emit Transfer(address(0), _to, id);\r\n        \r\n        feelingLuckyColor(id);\r\n    }\r\n    \r\n    function updateColor(uint id, uint symbolToUpdate, uint newColor) public {\r\n        require(msg.sender == ownerOf(id));\r\n        require(newColor < 16777216);\r\n        require(checkValidSymbol(id,symbolToUpdate) == true);\r\n        \r\n        idToColorScheme[id][symbolToUpdate] = newColor;\r\n        emit ColorChanged(id, symbolToUpdate, newColor);\r\n    }\r\n    \r\n    function feelingLuckyColor(uint id) public {\r\n        require(msg.sender == ownerOf(id));\r\n        \r\n        uint256 symbolToUpdate;\r\n        uint256 seed = uint(keccak256(abi.encodePacked(id,block.number)));\r\n        \r\n        if (idToSymbolScheme[id] == 1) { //if scheme 1, then update symbol 0\r\n            symbolToUpdate == 0;\r\n            }\r\n        else if (idToSymbolScheme[id] == 2) { //if scheme 2, then update symbol 0 or 1\r\n            symbolToUpdate = seed % 2;\r\n        }\r\n        else if (idToSymbolScheme[id] == 3) { //if scheme 3, then update symbol 2 or 3\r\n            symbolToUpdate = (seed % 2) + 2;\r\n        }\r\n        else if (idToSymbolScheme[id] == 4) { //if scheme 4, then update symbol 0, 1, or 4\r\n            symbolToUpdate = (seed % 3);\r\n            if (symbolToUpdate == 2) {\r\n                symbolToUpdate = 4;\r\n            }\r\n        }\r\n        else if (idToSymbolScheme[id] == 5) { //if scheme 5, then update symbol 0, 5, or 6\r\n            symbolToUpdate = (seed % 3);\r\n            if (symbolToUpdate == 1) {\r\n                symbolToUpdate = 5;\r\n            }\r\n            else if (symbolToUpdate == 2) {\r\n                symbolToUpdate = 6;\r\n            }\r\n        }\r\n        else if (idToSymbolScheme[id] == 6) { //if scheme 6, then update symbol 1, 3, or 7\r\n            symbolToUpdate = (seed % 3);\r\n            if (symbolToUpdate == 0) {\r\n                symbolToUpdate = 3;\r\n            }\r\n            else if (symbolToUpdate == 2) {\r\n                symbolToUpdate = 7;\r\n            }\r\n        }\r\n        else {\r\n            symbolToUpdate = seed % 5; // if scheme 7, then update symbol 0, 1, 2, 3, or 4\r\n        }        \r\n        \r\n        uint256 newColor = seed % 16777216;\r\n        \r\n        idToColorScheme[id][symbolToUpdate] = newColor;\r\n        emit ColorChanged(id, symbolToUpdate, newColor);\r\n    }\r\n    \r\n    function checkValidSymbol(uint id, uint symbolToCheck) public view returns (bool isValid){\r\n        if (idToSymbolScheme[id] == 1) {\r\n            if (symbolToCheck == 0) {\r\n                isValid = true;\r\n            }\r\n        }\r\n        else if (idToSymbolScheme[id] == 2) {\r\n            if (symbolToCheck == 0 || symbolToCheck == 1) {\r\n                isValid = true;\r\n            }\r\n        }\r\n        else if (idToSymbolScheme[id] == 3) {\r\n            if (symbolToCheck == 2 || symbolToCheck == 3) {\r\n                isValid = true;\r\n            }\r\n        }\r\n        else if (idToSymbolScheme[id] == 4) {\r\n            if (symbolToCheck == 0 || symbolToCheck == 1 || symbolToCheck == 4) {\r\n                isValid = true;\r\n            }\r\n        }\r\n        else if (idToSymbolScheme[id] == 5) {\r\n            if (symbolToCheck == 0 || symbolToCheck == 5 || symbolToCheck == 6) {\r\n                isValid = true;\r\n            }\r\n        }\r\n        else if (idToSymbolScheme[id] == 6) {\r\n            if (symbolToCheck == 1 || symbolToCheck == 3 || symbolToCheck == 7) {\r\n                isValid = true;\r\n            }\r\n        } \r\n        else {\r\n            if (symbolToCheck == 0 || symbolToCheck == 1 || symbolToCheck == 2 || symbolToCheck == 3 || symbolToCheck == 4) {\r\n                isValid = true;\r\n            }\r\n        } \r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new NFT to an address.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _to Address to which we want to add the NFT.\r\n     * @param _tokenId Which NFT we want to add.\r\n     */\r\n    function _addNFToken(address _to, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == address(0));\r\n        idToOwner[_tokenId] = _to;\r\n\r\n        uint256 length = ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = length - 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a NFT from an address.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _from Address from wich we want to remove the NFT.\r\n     * @param _tokenId Which NFT we want to remove.\r\n     */\r\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from);\r\n        delete idToOwner[_tokenId];\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex) {\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n\r\n        ownerToIds[_from].length--;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n     * extension to remove double storage (gas optimization) of owner nft count.\r\n     * @param _owner Address for whom to query the count.\r\n     * @return Number of _owner NFTs.\r\n     */\r\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\r\n        return ownerToIds[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Actually perform the safeTransferFrom.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     * @param _data Additional data with no specified format, sent in call to `_to`.\r\n     */\r\n    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Clears the current approval of a given NFT ID.\r\n     * @param _tokenId ID of the NFT to be transferred.\r\n     */\r\n    function _clearApproval(uint256 _tokenId) private {\r\n        if (idToApproval[_tokenId] != address(0)) {\r\n            delete idToApproval[_tokenId];\r\n        }\r\n    }\r\n\r\n    //// Enumerable\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return numTokens;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < numTokens);\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the n-th NFT ID from a list of owner's tokens.\r\n     * @param _owner Token owner's address.\r\n     * @param _index Index number representing n-th token in owner's list of tokens.\r\n     * @return Token id.\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_index < ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n    //// Metadata\r\n\r\n    /**\r\n      * @dev Returns a descriptive name for a collection of NFTokens.\r\n      */\r\n    function name() external view returns (string memory _name) {\r\n        _name = nftName;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an abbreviated name for NFTokens.\r\n     */\r\n    function symbol() external view returns (string memory _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n\r\n    /**\r\n     * @dev A distinct URI (RFC 3986) for a given NFT.\r\n     */\r\n    function tokenURI(uint256 id) external view returns (string memory) {\r\n        return string(abi.encodePacked(URI, integerToString(uint256(id))));\r\n    }\r\n    \r\n    function setURI(string memory newURI) public isOwner {\r\n        URI = newURI;\r\n    }\r\n\r\n    function integerToString(uint _i) internal pure returns (string memory) {\r\n      if (_i == 0) {\r\n         return \"0\";\r\n      }\r\n      uint j = _i;\r\n      uint len;\r\n      \r\n      while (j != 0) {\r\n         len++;\r\n         j /= 10;\r\n      }\r\n      bytes memory bstr = new bytes(len);\r\n      uint k = len - 1;\r\n      \r\n      while (_i != 0) {\r\n         bstr[k--] = byte(uint8(48 + _i % 10));\r\n         _i /= 10;\r\n      }\r\n      return string(bstr);\r\n   }\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"symbolToUpdate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newColor\",\"type\":\"uint256\"}],\"name\":\"ColorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"Generated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ARTIST_PRINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BENEFICIARY\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allSymbols\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"backgroundScheme\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"symbolToCheck\",\"type\":\"uint256\"}],\"name\":\"checkValidSymbol\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"colorScheme\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"color0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"color1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"color2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"color3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"color4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"color5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"color6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"color7\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"createPiece\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v1GlyphID\",\"type\":\"uint256\"}],\"name\":\"createWithV1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"draw\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"feelingLuckyColor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paintglyphsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"showProcessingCode\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"symbolScheme\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"symbolToUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newColor\",\"type\":\"uint256\"}],\"name\":\"updateColor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newProcessingCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"updateProcessingCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Repaintedglyphs","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8847ca3b51547460fd12b0b4e3a5822043337593ba9395624973f7a1bfb6b1ab"}]}