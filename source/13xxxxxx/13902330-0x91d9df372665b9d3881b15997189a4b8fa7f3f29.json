{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.4 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.3.2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.3.2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/Pausable.sol@v4.3.2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Marketplace.sol\r\n\r\npragma solidity ^0.8.11;\r\n\r\n\r\n\r\n\r\ncontract Marketplace is Ownable, Pausable {\r\n    struct Account {\r\n        uint256 reservedBalance;\r\n    }\r\n\r\n    struct Transaction {\r\n        address buyer;\r\n        address seller;\r\n        address nftAddress;\r\n        uint256 tokenId;\r\n        uint256 price;\r\n        uint256 fees;\r\n        uint256 nonce;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping(address => Account) public accounts;\r\n    address public cryptobysWallet;\r\n    address public pauser;\r\n    uint256 public timeoutSeconds;\r\n    bytes32 public constant HASH_TYPE =\r\n        keccak256(\r\n            \"Transaction(address buyer,address seller,address nftAddress,uint256 tokenId,uint256 price,uint256 fees,uint256 nonce,uint256 timestamp)\"\r\n        );\r\n    bytes32 private immutable _HASHED_NAME;\r\n    bytes32 private immutable _HASHED_VERSION;\r\n    bytes32 private immutable _TYPE_HASH;\r\n    bytes32 private immutable _DOMAIN_SEPARATOR;\r\n\r\n    constructor(\r\n        address _cryptobysWallet,\r\n        address _pauser,\r\n        uint256 _timeoutSeconds,\r\n        string memory _version,\r\n        uint256 _chainId\r\n    ) {\r\n        _HASHED_NAME = keccak256(bytes(\"Cryptobys\"));\r\n        _HASHED_VERSION = keccak256(bytes(_version));\r\n        _TYPE_HASH = keccak256(\r\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n        );\r\n        _DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                _TYPE_HASH,\r\n                _HASHED_NAME,\r\n                _HASHED_VERSION,\r\n                _chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        cryptobysWallet = _cryptobysWallet;\r\n        pauser = _pauser;\r\n        timeoutSeconds = _timeoutSeconds;\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n    function pause() external whenNotPaused {\r\n        require(msg.sender == pauser);\r\n        _pause();\r\n    }\r\n\r\n    function unPause() external whenPaused {\r\n        require(msg.sender == pauser);\r\n        _unpause();\r\n    }\r\n\r\n    function withdrawFees(uint256 amount) external payable whenNotPaused {\r\n        require(msg.sender == cryptobysWallet, \"Unauthorized\");\r\n        (bool transferSuccess, ) = cryptobysWallet.call{value: amount}(\"\");\r\n        require(transferSuccess, \"Transfer failed\");\r\n    }\r\n\r\n    function setTimeoutSeconds(uint256 _timeoutSeconds)\r\n        external\r\n        whenNotPaused\r\n        onlyOwner\r\n    {\r\n        timeoutSeconds = _timeoutSeconds;\r\n    }\r\n\r\n    function getReservedBalance(address account)\r\n        external\r\n        view\r\n        whenNotPaused\r\n        returns (uint256)\r\n    {\r\n        return accounts[account].reservedBalance;\r\n    }\r\n\r\n    function depositReservedFunds() external payable whenNotPaused {\r\n        accounts[msg.sender].reservedBalance =\r\n            accounts[msg.sender].reservedBalance +\r\n            msg.value;\r\n    }\r\n\r\n    function withdraw(uint256 amount) external payable {\r\n        uint256 contractStartingBalance = address(this).balance;\r\n        uint256 amountAvailable = accounts[msg.sender].reservedBalance;\r\n        require(amount <= amountAvailable, \"Insufficient available balance\");\r\n        // update account balance\r\n        accounts[msg.sender].reservedBalance -= amount;\r\n        assert((accounts[msg.sender].reservedBalance) >= 0);\r\n        // delete if final balance account is 0\r\n        if (accounts[msg.sender].reservedBalance == 0)\r\n            delete accounts[msg.sender];\r\n        // transfer the eth\r\n        (bool transferSuccess, ) = msg.sender.call{value: amount}(\"\");\r\n        require(transferSuccess, \"Failed to withdraw Eth\");\r\n        assert(address(this).balance == contractStartingBalance - amount);\r\n    }\r\n\r\n    function transactOnBid(\r\n        Transaction memory _transaction,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external payable whenNotPaused {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                _DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        HASH_TYPE,\r\n                        _transaction.buyer,\r\n                        _transaction.seller,\r\n                        _transaction.nftAddress,\r\n                        _transaction.tokenId,\r\n                        _transaction.price,\r\n                        _transaction.fees,\r\n                        _transaction.nonce,\r\n                        _transaction.timestamp\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        address signer = ecrecover(digest, _v, _r, _s);\r\n\r\n        require(signer == this.owner(), \"Unauthorized\");\r\n        require(\r\n            (block.timestamp - _transaction.timestamp) < timeoutSeconds,\r\n            \"Transaction timed out\"\r\n        );\r\n        require(\r\n            msg.sender == _transaction.seller,\r\n            \"Can only be triggered by seller\"\r\n        );\r\n        require(\r\n            accounts[_transaction.buyer].reservedBalance >= _transaction.price,\r\n            \"Insufficient funds\"\r\n        );\r\n        accounts[_transaction.buyer].reservedBalance -= _transaction.price;\r\n\r\n        // transfer the token\r\n        IERC721(_transaction.nftAddress).transferFrom(\r\n            _transaction.seller,\r\n            _transaction.buyer,\r\n            _transaction.tokenId\r\n        );\r\n\r\n        uint256 amount = _transaction.price - _transaction.fees;\r\n\r\n        // transfer the eth\r\n        (bool transferSuccess, ) = _transaction.seller.call{value: amount}(\"\");\r\n        require(transferSuccess, \"Failed to send Ether to seller\");\r\n    }\r\n\r\n    /* function transactSos(\r\n        Transaction memory _transaction,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external payable {\r\n        address signer = hashTyped(_transaction, _v, _r, _s);\r\n        require(signer == this.owner(), \"Unauthorized\");\r\n        require(\r\n            (block.timestamp - _transaction.timestamp) < timeoutSeconds,\r\n            \"Transaction timed out\"\r\n        );\r\n        require(\r\n            msg.sender == _transaction.buyer,\r\n            \"Can only be triggered by buyer\"\r\n        );\r\n        IERC721(_transaction.nftAddress).transferFrom(\r\n            _transaction.seller,\r\n            _transaction.buyer,\r\n            _transaction.tokenId\r\n        );\r\n        /* IERC20().transferFrom(\r\n            _transaction.buyer,\r\n            _transaction.seller,\r\n            _transaction.price\r\n        ); \r\n    } */\r\n\r\n    function transact(\r\n        Transaction memory _transaction,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external payable whenNotPaused {\r\n        require(\r\n            ((block.timestamp - _transaction.timestamp) < timeoutSeconds),\r\n            \"Transaction timed out\"\r\n        );\r\n        require(\r\n            msg.value == _transaction.price,\r\n            \"Money sent mismatch with price\"\r\n        );\r\n        require(msg.sender == _transaction.buyer, \"Must be initiated by buyer\");\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                _DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        HASH_TYPE,\r\n                        _transaction.buyer,\r\n                        _transaction.seller,\r\n                        _transaction.nftAddress,\r\n                        _transaction.tokenId,\r\n                        _transaction.price,\r\n                        _transaction.fees,\r\n                        _transaction.nonce,\r\n                        _transaction.timestamp\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        address signer = ecrecover(digest, _v, _r, _s);\r\n        require(signer == this.owner(), \"Unauthorized\");\r\n\r\n        // transfer the token\r\n        IERC721(_transaction.nftAddress).transferFrom(\r\n            _transaction.seller,\r\n            _transaction.buyer,\r\n            _transaction.tokenId\r\n        );\r\n\r\n        uint256 amount = msg.value - _transaction.fees;\r\n        // transfer the eth\r\n        (bool transferSuccess, ) = _transaction.seller.call{value: amount}(\"\");\r\n        require(transferSuccess, \"Failed to send Ether to seller\");\r\n    }\r\n\r\n    function transactOwner(Transaction memory _transaction)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n        onlyOwner\r\n    {\r\n        IERC721(_transaction.nftAddress).transferFrom(\r\n            _transaction.seller,\r\n            _transaction.buyer,\r\n            _transaction.tokenId\r\n        );\r\n    }\r\n\r\n    /* function hashTyped(\r\n        Transaction memory _transaction,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public view returns (address) {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                _DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        HASH_TYPE,\r\n                        _transaction.buyer,\r\n                        _transaction.seller,\r\n                        _transaction.nftAddress,\r\n                        _transaction.tokenId,\r\n                        _transaction.price,\r\n                        _transaction.fees,\r\n                        _transaction.nonce,\r\n                        _transaction.timestamp\r\n                    )\r\n                )\r\n            )\r\n        );\r\n \r\n        address signer = ecrecover(digest, _v, _r, _s);\r\n        return signer;\r\n    } */\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cryptobysWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timeoutSeconds\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"HASH_TYPE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reservedBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cryptobysWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositReservedFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReservedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeoutSeconds\",\"type\":\"uint256\"}],\"name\":\"setTimeoutSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeoutSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Transaction\",\"name\":\"_transaction\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"transact\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Transaction\",\"name\":\"_transaction\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"transactOnBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Transaction\",\"name\":\"_transaction\",\"type\":\"tuple\"}],\"name\":\"transactOwner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Marketplace","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"0000000000000000000000006fb79b17a6715dddfbcf88e7985af2bf12688a180000000000000000000000006fb79b17a6715dddfbcf88e7985af2bf12688a1800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003312e310000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://23de4e61ce91ebec69fa55275fcf98816a47fb51b1bad4580c6522642091fe0a"}]}