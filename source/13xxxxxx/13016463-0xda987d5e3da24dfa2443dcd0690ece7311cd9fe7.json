{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GammaRedeemerResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport {IGammaRedeemerV1} from \\\"./interfaces/IGammaRedeemerV1.sol\\\";\\nimport {IGammaOperator} from \\\"./interfaces/IGammaOperator.sol\\\";\\nimport {IResolver} from \\\"./interfaces/IResolver.sol\\\";\\nimport {MarginVault} from \\\"./external/OpynVault.sol\\\";\\n\\n/// @author Willy Shen\\n/// @title GammaRedeemer Resolver\\n/// @notice A GammaRedeemer resolver for Gelato PokeMe checks\\ncontract GammaRedeemerResolver is IResolver {\\n    address public redeemer;\\n\\n    constructor(address _redeemer) {\\n        redeemer = _redeemer;\\n    }\\n\\n    /**\\n     * @notice return if a specific order can be processed\\n     * @param _orderId id of order\\n     * @return true if order can be proceseed without a revert\\n     */\\n    function canProcessOrder(uint256 _orderId) public view returns (bool) {\\n        IGammaRedeemerV1.Order memory order = IGammaRedeemerV1(redeemer)\\n            .getOrder(_orderId);\\n\\n        if (order.isSeller) {\\n            if (\\n                !IGammaOperator(redeemer).isValidVaultId(\\n                    order.owner,\\n                    order.vaultId\\n                ) || !IGammaOperator(redeemer).isOperatorOf(order.owner)\\n            ) return false;\\n\\n            (\\n                MarginVault.Vault memory vault,\\n                uint256 typeVault,\\n\\n            ) = IGammaOperator(redeemer).getVaultWithDetails(\\n                order.owner,\\n                order.vaultId\\n            );\\n\\n            try IGammaOperator(redeemer).getVaultOtoken(vault) returns (\\n                address otoken\\n            ) {\\n                if (\\n                    !IGammaOperator(redeemer).hasExpiredAndSettlementAllowed(\\n                        otoken\\n                    )\\n                ) return false;\\n\\n                (uint256 payout, bool isValidVault) = IGammaOperator(redeemer)\\n                    .getExcessCollateral(vault, typeVault);\\n                if (!isValidVault || payout == 0) return false;\\n            } catch {\\n                return false;\\n            }\\n        } else {\\n            if (\\n                !IGammaOperator(redeemer).hasExpiredAndSettlementAllowed(\\n                    order.otoken\\n                )\\n            ) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice return list of processable orderIds\\n     * @return canExec if gelato should execute\\n     * @return execPayload the function and data to be executed by gelato\\n     * @dev order is processable if:\\n     * 1. it is profitable to process (shouldProcessOrder)\\n     * 2. it can be processed without reverting (canProcessOrder)\\n     * 3. it is not included yet (for same type of orders, process it one at a time)\\n     */\\n    function getProcessableOrders()\\n        public\\n        view\\n        override\\n        returns (bool canExec, bytes memory execPayload)\\n    {\\n        IGammaRedeemerV1.Order[] memory orders = IGammaRedeemerV1(redeemer)\\n            .getOrders();\\n\\n        // Only proceess duplicate orders one at a time\\n        bytes32[] memory preCheckHashes = new bytes32[](orders.length);\\n        bytes32[] memory postCheckHashes = new bytes32[](orders.length);\\n\\n        uint256 orderIdsLength;\\n        for (uint256 i = 0; i < orders.length; i++) {\\n            if (\\n                IGammaRedeemerV1(redeemer).shouldProcessOrder(i) &&\\n                canProcessOrder(i) &&\\n                !containDuplicateOrderType(orders[i], preCheckHashes)\\n            ) {\\n                preCheckHashes[i] = getOrderHash(orders[i]);\\n                orderIdsLength++;\\n            }\\n        }\\n\\n        if (orderIdsLength > 0) {\\n            canExec = true;\\n        }\\n\\n        uint256 counter;\\n        uint256[] memory orderIds = new uint256[](orderIdsLength);\\n        for (uint256 i = 0; i < orders.length; i++) {\\n            if (\\n                IGammaRedeemerV1(redeemer).shouldProcessOrder(i) &&\\n                canProcessOrder(i) &&\\n                !containDuplicateOrderType(orders[i], postCheckHashes)\\n            ) {\\n                postCheckHashes[i] = getOrderHash(orders[i]);\\n                orderIds[counter] = i;\\n                counter++;\\n            }\\n        }\\n\\n        execPayload = abi.encodeWithSelector(\\n            IGammaRedeemerV1.processOrders.selector,\\n            orderIds\\n        );\\n    }\\n\\n    /**\\n     * @notice return if order is already included\\n     * @param order struct to check\\n     * @param hashes list of hashed orders\\n     * @return containDuplicate if hashes already contain a same order type.\\n     */\\n    function containDuplicateOrderType(\\n        IGammaRedeemerV1.Order memory order,\\n        bytes32[] memory hashes\\n    ) public pure returns (bool containDuplicate) {\\n        bytes32 orderHash = getOrderHash(order);\\n\\n        for (uint256 j = 0; j < hashes.length; j++) {\\n            if (hashes[j] == orderHash) {\\n                containDuplicate = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice return hash of the order\\n     * @param order struct to hash\\n     * @return orderHash hash depending on the order's type\\n     */\\n    function getOrderHash(IGammaRedeemerV1.Order memory order)\\n        public\\n        pure\\n        returns (bytes32 orderHash)\\n    {\\n        if (order.isSeller) {\\n            orderHash = keccak256(abi.encode(order.owner, order.vaultId));\\n        } else {\\n            orderHash = keccak256(abi.encode(order.owner, order.otoken));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGammaRedeemerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IGammaRedeemerV1 {\\n    struct Order {\\n        // address of user\\n        address owner;\\n        // address of otoken to redeem\\n        address otoken;\\n        // amount of otoken to redeem\\n        uint256 amount;\\n        // vaultId of vault to settle\\n        uint256 vaultId;\\n        // true if settle vault order, else redeem otoken\\n        bool isSeller;\\n        // convert proceed to ETH, currently unused\\n        bool toETH;\\n        // fee in 1/10.000\\n        uint256 fee;\\n        // true if order is already processed\\n        bool finished;\\n    }\\n\\n    event OrderCreated(\\n        uint256 indexed orderId,\\n        address indexed owner,\\n        address indexed otoken\\n    );\\n    event OrderFinished(uint256 indexed orderId, bool indexed cancelled);\\n\\n    function createOrder(\\n        address _otoken,\\n        uint256 _amount,\\n        uint256 _vaultId\\n    ) external;\\n\\n    function cancelOrder(uint256 _orderId) external;\\n\\n    function shouldProcessOrder(uint256 _orderId) external view returns (bool);\\n\\n    function processOrder(uint256 _orderId) external;\\n\\n    function processOrders(uint256[] calldata _orderIds) external;\\n\\n    function getOrdersLength() external view returns (uint256);\\n\\n    function getOrders() external view returns (Order[] memory);\\n\\n    function getOrder(uint256 _orderId) external view returns (Order memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGammaOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport {MarginVault} from \\\"../external/OpynVault.sol\\\";\\n\\ninterface IGammaOperator {\\n    function isValidVaultId(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getExcessCollateral(\\n        MarginVault.Vault memory _vault,\\n        uint256 _typeVault\\n    ) external view returns (uint256, bool);\\n\\n    function getVaultOtoken(MarginVault.Vault memory _vault)\\n        external\\n        pure\\n        returns (address);\\n\\n    function getVaultWithDetails(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (\\n            MarginVault.Vault memory,\\n            uint256,\\n            uint256\\n        );\\n\\n    function isSettlementAllowed(address _otoken) external view returns (bool);\\n\\n    function isOperatorOf(address _owner) external view returns (bool);\\n\\n    function hasExpiredAndSettlementAllowed(address _otoken)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IResolver {\\n    function getProcessableOrders()\\n        external\\n        returns (bool canExec, bytes memory execPayload);\\n}\\n\"\r\n    },\r\n    \"contracts/external/OpynVault.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: UNLICENSED\\n */\\npragma solidity 0.8.0;\\n\\n/**\\n * @title MarginVault\\n * @author Opyn Team\\n * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\\n * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\\n */\\nlibrary MarginVault {\\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\\n    struct Vault {\\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\\n        address[] shortOtokens;\\n        // addresses of oTokens a user has bought and deposited in this vault\\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\\n        address[] longOtokens;\\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\\n        address[] collateralAssets;\\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\\n        uint256[] shortAmounts;\\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\\n        uint256[] longAmounts;\\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\\n        uint256[] collateralAmounts;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_redeemer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"canProcessOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSeller\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"internalType\":\"struct IGammaRedeemerV1.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"}],\"name\":\"containDuplicateOrderType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"containDuplicate\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSeller\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"internalType\":\"struct IGammaRedeemerV1.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProcessableOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GammaRedeemerResolver","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cd92f7bd79e5b0f7d0e20fe7efdf3fafb70e3904","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}