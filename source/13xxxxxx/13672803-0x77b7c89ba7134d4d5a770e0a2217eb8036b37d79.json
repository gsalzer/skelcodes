{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/RewardVesting.sol\": {\r\n      \"content\": \"pragma solidity 0.8.6;\\n\\n// Inheritance\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./IRewardEscrowV2.sol\\\";\\n\\n// Libraries\\nimport \\\"./VestingEntries.sol\\\";\\n\\n// References\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// Based on BaseRewardEscrowV2 by Synthetix\\ncontract RewardVesting is Owned, IRewardEscrowV2 {\\n    IERC20 public immutable PSP;\\n    address public rewardDistribution;\\n\\n    mapping(address => mapping(uint256 => VestingEntries.VestingEntry)) public vestingSchedules;\\n\\n    mapping(address => uint256[]) public accountVestingEntryIDs;\\n\\n    /* Counter for new vesting entry ids. */\\n    uint256 public nextEntryId;\\n\\n    /* An account's total escrowed PSP balance to save recomputing this for fee extraction purposes. */\\n    mapping(address => uint256) public totalEscrowedAccountBalance;\\n\\n    /* An account's total vested reward PSP. */\\n    mapping(address => uint256) public totalVestedAccountBalance;\\n\\n    /* The total remaining escrowed balance, for verifying the actual PSP balance of this contract against. */\\n    uint256 public totalEscrowedBalance;\\n\\n    /* Max escrow duration */\\n    uint public max_duration = 4 * 365 days; // Default max 4 years duration\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(address _owner, IERC20 _psp, address _rewardDistribution) public Owned(_owner) {\\n        PSP = _psp;\\n        rewardDistribution = _rewardDistribution;\\n        nextEntryId = 1;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\\n     */\\n    function balanceOf(address account) public view returns (uint) {\\n        return totalEscrowedAccountBalance[account];\\n    }\\n\\n    /**\\n     * @notice The number of vesting dates in an account's schedule.\\n     */\\n    function numVestingEntries(address account) external view returns (uint) {\\n        return accountVestingEntryIDs[account].length;\\n    }\\n\\n    /**\\n     * @notice Get a particular schedule entry for an account.\\n     * @return endTime The vesting entry object time per second emission.\\n     * @return escrowAmount The vesting entry object escrow amount.\\n     */\\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64 endTime, uint256 escrowAmount) {\\n        endTime = vestingSchedules[account][entryID].endTime;\\n        escrowAmount = vestingSchedules[account][entryID].escrowAmount;\\n    }\\n\\n    function getVestingSchedules(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory) {\\n        uint256 endIndex = index + pageSize;\\n\\n        // If the page extends past the end of the accountVestingEntryIDs, truncate it.\\n        if (endIndex > accountVestingEntryIDs[account].length) {\\n            endIndex = accountVestingEntryIDs[account].length;\\n        }\\n\\n        // If index starts after the endIndex return no results\\n        if (endIndex <= index) {\\n            return new VestingEntries.VestingEntryWithID[](0);\\n        }\\n\\n        uint256 n = endIndex - index;\\n        VestingEntries.VestingEntryWithID[] memory vestingEntries = new VestingEntries.VestingEntryWithID[](n);\\n        for (uint256 i; i < n; i++) {\\n            uint256 entryID = accountVestingEntryIDs[account][i + index];\\n\\n            VestingEntries.VestingEntry memory entry = vestingSchedules[account][entryID];\\n\\n            vestingEntries[i] = VestingEntries.VestingEntryWithID({\\n                endTime: uint64(entry.endTime),\\n                escrowAmount: entry.escrowAmount,\\n                entryID: entryID\\n            });\\n        }\\n        return vestingEntries;\\n    }\\n\\n    function getAccountVestingEntryIDs(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (uint256[] memory) {\\n        uint256 endIndex = index + pageSize;\\n\\n        // If the page extends past the end of the accountVestingEntryIDs, truncate it.\\n        if (endIndex > accountVestingEntryIDs[account].length) {\\n            endIndex = accountVestingEntryIDs[account].length;\\n        }\\n        if (endIndex <= index) {\\n            return new uint256[](0);\\n        }\\n\\n        uint256 n = endIndex - index;\\n        uint256[] memory page = new uint256[](n);\\n        for (uint256 i; i < n; i++) {\\n            page[i] = accountVestingEntryIDs[account][i + index];\\n        }\\n        return page;\\n    }\\n\\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint total) {\\n        for (uint i = 0; i < entryIDs.length; i++) {\\n            VestingEntries.VestingEntry memory entry = vestingSchedules[account][entryIDs[i]];\\n\\n            /* Skip entry if escrowAmount == 0 */\\n            if (entry.escrowAmount != 0) {\\n                uint256 quantity = _claimableAmount(entry);\\n\\n                /* add quantity to total */\\n                total += quantity;\\n            }\\n        }\\n    }\\n\\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint) {\\n        VestingEntries.VestingEntry memory entry = vestingSchedules[account][entryID];\\n        return _claimableAmount(entry);\\n    }\\n\\n    function _claimableAmount(VestingEntries.VestingEntry memory _entry) internal view returns (uint256) {\\n        uint256 quantity;\\n        if (_entry.escrowAmount != 0) {\\n            /* Escrow amounts claimable if block.timestamp equal to or after entry endTime */\\n            quantity = block.timestamp >= _entry.endTime ? _entry.escrowAmount : 0;\\n        }\\n        return quantity;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * Vest escrowed amounts that are claimable\\n     * Allows users to vest their vesting entries based on msg.sender\\n     */\\n\\n    function vest(uint256[] calldata entryIDs) external {\\n        uint256 total;\\n        for (uint i = 0; i < entryIDs.length; i++) {\\n            VestingEntries.VestingEntry storage entry = vestingSchedules[msg.sender][entryIDs[i]];\\n\\n            /* Skip entry if escrowAmount == 0 already vested */\\n            if (entry.escrowAmount != 0) {\\n                uint256 quantity = _claimableAmount(entry);\\n\\n                /* update entry to remove escrowAmount */\\n                if (quantity > 0) {\\n                    entry.escrowAmount = 0;\\n                }\\n\\n                /* add quantity to total */\\n                total += quantity;\\n            }\\n        }\\n\\n        /* Transfer vested tokens. Will revert if total > totalEscrowedAccountBalance */\\n        if (total != 0) {\\n            _transferVestedTokens(msg.sender, total);\\n        }\\n    }\\n\\n    /**\\n     * @notice Create an escrow entry to lock PSP for a given duration in seconds\\n     * @dev This call expects that the despositor (msg.sender) has already approved the Reward vesting contract\\n     * to spend the amount being escrowed.\\n     */\\n    function createEscrowEntry(\\n        address beneficiary,\\n        uint256 deposit,\\n        uint256 duration\\n    ) external {\\n        require(beneficiary != address(0), \\\"Cannot create escrow with address(0)\\\");\\n\\n        /* Transfer PSP from msg.sender */\\n        require(PSP.transferFrom(msg.sender, address(this), deposit), \\\"token transfer failed\\\");\\n\\n        /* Append vesting entry for the beneficiary address */\\n        _appendVestingEntry(beneficiary, deposit, duration);\\n    }\\n\\n    /**\\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\\n     * @dev A call to this should accompany a previous successful call to PSP.transfer(rewardVesting, amount),\\n     * to ensure that when the funds are withdrawn, there is enough balance.\\n     * @param account The account to append a new vesting entry to.\\n     * @param quantity The quantity of PSP that will be escrowed.\\n     * @param duration The duration that PSP will be emitted.\\n     */\\n    function appendVestingEntry(\\n        address account,\\n        uint256 quantity,\\n        uint256 duration\\n    ) external override onlyRewardDistribution {\\n        _appendVestingEntry(account, quantity, duration);\\n    }\\n\\n    /* Transfer vested tokens and update totalEscrowedAccountBalance, totalVestedAccountBalance */\\n    function _transferVestedTokens(address _account, uint256 _amount) internal {\\n        _reduceAccountEscrowBalances(_account, _amount);\\n        totalVestedAccountBalance[_account] += _amount;\\n        PSP.transfer(_account, _amount);\\n        emit Vested(_account, block.timestamp, _amount);\\n    }\\n\\n    function _reduceAccountEscrowBalances(address _account, uint256 _amount) internal {\\n        // Reverts if amount being vested is greater than the account's existing totalEscrowedAccountBalance\\n        totalEscrowedBalance -= _amount;\\n        totalEscrowedAccountBalance[_account] -= _amount;\\n    }\\n\\n    function setRewardDistribution(address _rewardDistribution) external onlyOwner {\\n        rewardDistribution = _rewardDistribution;\\n        emit RewardDistributionUpdated(_rewardDistribution);\\n    }\\n\\n    function setMaxEscrowDuration(uint256 duration) external onlyOwner {\\n        max_duration = duration;\\n        emit MaxEscrowDurationUpdated(duration);\\n    }\\n\\n    /* ========== INTERNALS ========== */\\n\\n    function _appendVestingEntry(\\n        address account,\\n        uint256 quantity,\\n        uint256 duration\\n    ) internal {\\n        /* No empty or already-passed vesting entries allowed. */\\n        require(quantity != 0, \\\"Quantity cannot be zero\\\");\\n        require(duration > 0 && duration <= max_duration, \\\"Cannot escrow with 0 duration OR above max_duration\\\");\\n\\n        /* There must be enough balance in the contract to provide for the vesting entry. */\\n        totalEscrowedBalance += quantity;\\n\\n        require(\\n            totalEscrowedBalance <= PSP.balanceOf(address(this)),\\n            \\\"Must be enough balance in the contract to provide for the vesting entry\\\"\\n        );\\n\\n        /* Escrow the tokens for duration. */\\n        uint endTime = block.timestamp + duration;\\n\\n        /* Add quantity to account's escrowed balance */\\n        totalEscrowedAccountBalance[account] += quantity;\\n\\n        uint entryID = nextEntryId;\\n        vestingSchedules[account][entryID] = VestingEntries.VestingEntry({endTime: uint64(endTime), escrowAmount: quantity});\\n\\n        accountVestingEntryIDs[account].push(entryID);\\n\\n        /* Increment the next entry id. */\\n        nextEntryId += 1;\\n\\n        emit VestingEntryCreated(account, block.timestamp, quantity, duration, entryID);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n    modifier onlyRewardDistribution() {\\n        require(msg.sender == rewardDistribution, \\\"Only the RewardDistribution can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    event Vested(address indexed beneficiary, uint time, uint value);\\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value, uint duration, uint entryID);\\n    event RewardDistributionUpdated(address newRewardDistribution);\\n    event MaxEscrowDurationUpdated(uint newDuration);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/Owned.sol\": {\r\n      \"content\": \"pragma solidity 0.8.6;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/Owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IRewardEscrowV2.sol\": {\r\n      \"content\": \"pragma solidity 0.8.6;\\n\\ninterface IRewardEscrowV2 {\\n    function appendVestingEntry(\\n        address account,\\n        uint256 quantity,\\n        uint256 duration\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/staking/VestingEntries.sol\": {\r\n      \"content\": \"pragma solidity 0.8.6;\\n\\nlibrary VestingEntries {\\n    struct VestingEntry {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n    }\\n    struct VestingEntryWithID {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n        uint256 entryID;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_psp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardDistribution\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"MaxEscrowDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewardDistribution\",\"type\":\"address\"}],\"name\":\"RewardDistributionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"name\":\"VestingEntryCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PSP\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountVestingEntryIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"appendVestingEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"createEscrowEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getAccountVestingEntryIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"name\":\"getVestingEntry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"name\":\"getVestingEntryClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"}],\"name\":\"getVestingQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getVestingSchedules\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"internalType\":\"struct VestingEntries.VestingEntryWithID[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextEntryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"numVestingEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDistribution\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setMaxEscrowDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardDistribution\",\"type\":\"address\"}],\"name\":\"setRewardDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalEscrowedAccountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEscrowedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalVestedAccountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"}],\"name\":\"vest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingSchedules\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RewardVesting","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000005a61d9214adefd7669428a03a4e8734a00e9f4640000000000000000000000007f0af2bdfccbfdb0704dcc155f4a9453d20972890000000000000000000000003cffed0d100d9c5f0135258cfffeaff423bd1185","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}