{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Controlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\nimport \\\"../interfaces/IKernel.sol\\\";\\n\\nabstract contract Controlled is Initializable, ModuleMapConsumer {\\n  // controller address => is a controller\\n  mapping(address => bool) internal _controllers;\\n  address[] public controllers;\\n\\n  function __Controlled_init(address[] memory controllers_, address moduleMap_)\\n    public\\n    initializer\\n  {\\n    for (uint256 i; i < controllers_.length; i++) {\\n      _controllers[controllers_[i]] = true;\\n    }\\n    controllers = controllers_;\\n    __ModuleMapConsumer_init(moduleMap_);\\n  }\\n\\n  function addController(address controller) external onlyOwner {\\n    _controllers[controller] = true;\\n    bool added;\\n    for (uint256 i; i < controllers.length; i++) {\\n      if (controller == controllers[i]) {\\n        added = true;\\n      }\\n    }\\n    if (!added) {\\n      controllers.push(controller);\\n    }\\n  }\\n\\n  modifier onlyOwner() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isOwner(msg.sender),\\n      \\\"Controlled::onlyOwner: Caller is not owner\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isManager(msg.sender),\\n      \\\"Controlled::onlyManager: Caller is not manager\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyController() {\\n    require(\\n      _controllers[msg.sender],\\n      \\\"Controlled::onlyController: Caller is not controller\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ModuleMapConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IModuleMap.sol\\\";\\n\\nabstract contract ModuleMapConsumer is Initializable {\\n  IModuleMap public moduleMap;\\n\\n  function __ModuleMapConsumer_init(address moduleMap_) internal initializer {\\n    moduleMap = IModuleMap(moduleMap_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/StrategyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"../interfaces/IStrategyManager.sol\\\";\\nimport \\\"../interfaces/IStrategyMap.sol\\\";\\nimport \\\"../interfaces/IYieldManager.sol\\\";\\n\\ncontract StrategyManager is\\n  Initializable,\\n  ModuleMapConsumer,\\n  Controlled,\\n  IStrategyManager\\n{\\n  // #### Functions\\n  function initialize(address[] memory controllers_, address moduleMap_)\\n    public\\n    initializer\\n  {\\n    __Controlled_init(controllers_, moduleMap_);\\n  }\\n\\n  /**\\n  @notice Adds a new strategy to the strategy map. \\n  @dev This is a passthrough to StrategyMap.addStrategy\\n   */\\n  function addStrategy(\\n    string calldata name,\\n    IStrategyMap.WeightedIntegration[] memory integrations,\\n    address[] calldata tokens\\n  ) external override onlyManager {\\n    IStrategyMap(moduleMap.getModuleAddress(Modules.StrategyMap)).addStrategy(\\n      name,\\n      integrations,\\n      tokens\\n    );\\n  }\\n\\n  /**\\n@notice Updates the whitelisted tokens a strategy accepts for new deposits\\n@dev This is a passthrough to StrategyMap.updateStrategyTokens\\n */\\n  function updateStrategyTokens(uint256 id, address[] calldata tokens)\\n    external\\n    override\\n    onlyManager\\n  {\\n    IStrategyMap(moduleMap.getModuleAddress(Modules.StrategyMap)).updateTokens(\\n      id,\\n      tokens\\n    );\\n  }\\n\\n  /**\\n    @notice Updates a strategy's name\\n    @dev This is a pass through function to StrategyMap.updateName\\n */\\n  function updateStrategyName(uint256 id, string calldata name)\\n    external\\n    override\\n    onlyManager\\n  {\\n    IStrategyMap(moduleMap.getModuleAddress(Modules.StrategyMap)).updateName(\\n      id,\\n      name\\n    );\\n  }\\n\\n  /**\\n    @notice Updates a strategy's integrations\\n    @dev This is a pass through to StrategyMap.updateIntegrations\\n */\\n  function updateStrategyIntegrations(\\n    uint256 id,\\n    IStrategyMap.WeightedIntegration[] memory integrations\\n  ) external override onlyManager {\\n    IStrategyMap(moduleMap.getModuleAddress(Modules.StrategyMap))\\n      .updateIntegrations(id, integrations);\\n    IYieldManager(moduleMap.getModuleAddress(Modules.YieldManager)).deploy();\\n  }\\n\\n  /**\\n    @notice Deletes a strategy\\n    @dev This is a pass through to StrategyMap.deleteStrategy\\n    */\\n  function deleteStrategy(uint256 id) external override onlyManager {\\n    IStrategyMap(moduleMap.getModuleAddress(Modules.StrategyMap))\\n      .deleteStrategy(id);\\n    IYieldManager(moduleMap.getModuleAddress(Modules.YieldManager)).rebalance();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIntegration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IIntegration {\\n  /// @param tokenAddress The address of the deposited token\\n  /// @param amount The amount of the token being deposited\\n  function deposit(address tokenAddress, uint256 amount) external;\\n\\n  /// @param tokenAddress The address of the withdrawal token\\n  /// @param amount The amount of the token to withdraw\\n  function withdraw(address tokenAddress, uint256 amount) external;\\n\\n  /// @dev Deploys all tokens held in the integration contract to the integrated protocol\\n  function deploy() external;\\n\\n  /// @dev Harvests token yield from the Aave lending pool\\n  function harvestYield() external;\\n\\n  /// @dev This returns the total amount of the underlying token that\\n  /// @dev has been deposited to the integration contract\\n  /// @param tokenAddress The address of the deployed token\\n  /// @return The amount of the underlying token that can be withdrawn\\n  function getBalance(address tokenAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IKernel {\\n  /// @param account The address of the account to check if they are a manager\\n  /// @return Bool indicating whether the account is a manger\\n  function isManager(address account) external view returns (bool);\\n\\n  /// @param account The address of the account to check if they are an owner\\n  /// @return Bool indicating whether the account is an owner\\n  function isOwner(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IModuleMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nenum Modules {\\n  Kernel, // 0\\n  UserPositions, // 1\\n  YieldManager, // 2\\n  IntegrationMap, // 3\\n  BiosRewards, // 4\\n  EtherRewards, // 5\\n  SushiSwapTrader, // 6\\n  UniswapTrader, // 7\\n  StrategyMap, // 8\\n  StrategyManager // 9\\n}\\n\\ninterface IModuleMap {\\n  function getModuleAddress(Modules key) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\nimport \\\"../interfaces/IStrategyMap.sol\\\";\\n\\ninterface IStrategyManager {\\n  // #### Functions\\n\\n  /**\\n  @notice Adds a new strategy to the strategy map. \\n  @dev This is a passthrough to StrategyMap.addStrategy\\n   */\\n  function addStrategy(\\n    string calldata name,\\n    IStrategyMap.WeightedIntegration[] memory integrations,\\n    address[] calldata tokens\\n  ) external;\\n\\n  /**\\n    @notice Updates a strategy's name\\n    @dev This is a pass through function to StrategyMap.updateName\\n */\\n  function updateStrategyName(uint256 id, string calldata name) external;\\n\\n  /**\\n    @notice Updates a strategy's integrations\\n    @dev This is a pass through to StrategyMap.updateIntegrations\\n */\\n  function updateStrategyIntegrations(\\n    uint256 id,\\n    IStrategyMap.WeightedIntegration[] memory integrations\\n  ) external;\\n\\n  /**\\n  @notice Updates the tokens that a strategy accepts\\n  @dev This is a passthrough to StrategyMap.updateStrategyTokens\\n   */\\n  function updateStrategyTokens(uint256 id, address[] calldata tokens) external;\\n\\n  /**\\n    @notice Deletes a strategy\\n    @dev This is a pass through to StrategyMap.deleteStrategy\\n    */\\n  function deleteStrategy(uint256 id) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategyMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\nimport \\\"../interfaces/IIntegration.sol\\\";\\n\\ninterface IStrategyMap {\\n  // #### Structs\\n  struct WeightedIntegration {\\n    address integration;\\n    uint256 weight;\\n  }\\n\\n  struct Strategy {\\n    string name;\\n    uint256 totalStrategyWeight;\\n    mapping(address => bool) enabledTokens;\\n    address[] tokens;\\n    WeightedIntegration[] integrations;\\n  }\\n\\n  struct StrategySummary {\\n    string name;\\n    uint256 totalStrategyWeight;\\n    address[] tokens;\\n    WeightedIntegration[] integrations;\\n  }\\n\\n  struct StrategyTransaction {\\n    uint256 amount;\\n    address token;\\n  }\\n\\n  // #### Events\\n  event NewStrategy(\\n    uint256 indexed id,\\n    string name,\\n    WeightedIntegration[] integrations,\\n    address[] tokens\\n  );\\n  event UpdateName(uint256 indexed id, string name);\\n  event UpdateIntegrations(\\n    uint256 indexed id,\\n    WeightedIntegration[] integrations\\n  );\\n  event UpdateTokens(uint256 indexed id, address[] tokens);\\n  event DeleteStrategy(\\n    uint256 indexed id,\\n    string name,\\n    address[] tokens,\\n    WeightedIntegration[] integrations\\n  );\\n\\n  event EnterStrategy(\\n    uint256 indexed id,\\n    address indexed user,\\n    address[] tokens,\\n    uint256[] amounts\\n  );\\n  event ExitStrategy(\\n    uint256 indexed id,\\n    address indexed user,\\n    address[] tokens,\\n    uint256[] amounts\\n  );\\n\\n  // #### Functions\\n  /**\\n     @notice Adds a new strategy to the list of available strategies\\n     @param name  the name of the new strategy\\n     @param integrations  the integrations and weights that form the strategy\\n     */\\n  function addStrategy(\\n    string calldata name,\\n    WeightedIntegration[] memory integrations,\\n    address[] calldata tokens\\n  ) external;\\n\\n  /**\\n    @notice Updates the strategy name\\n    @param name  the new name\\n     */\\n  function updateName(uint256 id, string calldata name) external;\\n\\n  /**\\n  @notice Updates a strategy's accepted tokens\\n  @param id  The strategy ID\\n  @param tokens  The new tokens to allow\\n  */\\n  function updateTokens(uint256 id, address[] calldata tokens) external;\\n\\n  /**\\n    @notice Updates the strategy integrations \\n    @param integrations  the new integrations\\n     */\\n  function updateIntegrations(\\n    uint256 id,\\n    WeightedIntegration[] memory integrations\\n  ) external;\\n\\n  /**\\n    @notice Deletes a strategy\\n    @dev This can only be called successfully if the strategy being deleted doesn't have any assets invested in it\\n    @param id  the strategy to delete\\n     */\\n  function deleteStrategy(uint256 id) external;\\n\\n  /**\\n    @notice Increases the amount of a set of tokens in a strategy\\n    @param id  the strategy to deposit into\\n    @param tokens  the tokens to deposit\\n    @param amounts  The amounts to be deposited\\n     */\\n  function enterStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n    @notice Decreases the amount of a set of tokens invested in a strategy\\n    @param id  the strategy to withdraw assets from\\n    @param tokens  the tokens to withdraw\\n    @param amounts  The amounts to be withdrawn\\n     */\\n  function exitStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n    @notice Getter function to return the nested arrays as well as the name\\n    @param id  the strategy to return\\n     */\\n  function getStrategy(uint256 id)\\n    external\\n    view\\n    returns (StrategySummary memory);\\n\\n  /**\\n    @notice Returns the expected balance of a given token in a given integration\\n    @param integration  the integration the amount should be invested in\\n    @param token  the token that is being invested\\n    @return balance  the balance of the token that should be currently invested in the integration \\n     */\\n  function getExpectedBalance(address integration, address token)\\n    external\\n    view\\n    returns (uint256 balance);\\n\\n  /**\\n    @notice Returns the amount of a given token currently invested in a strategy\\n    @param id  the strategy id to check\\n    @param token  The token to retrieve the balance for\\n    @return amount  the amount of token that is invested in the strategy\\n     */\\n  function getStrategyTokenBalance(uint256 id, address token)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n    @notice returns the amount of a given token a user has invested in a given strategy\\n    @param id  the strategy id\\n    @param token  the token address\\n    @param user  the user who holds the funds\\n    @return amount  the amount of token that the user has invested in the strategy \\n     */\\n  function getUserStrategyBalanceByToken(\\n    uint256 id,\\n    address token,\\n    address user\\n  ) external view returns (uint256 amount);\\n\\n  /**\\n    @notice Returns the amount of a given token that a user has invested across all strategies\\n    @param token  the token address\\n    @param user  the user holding the funds\\n    @return amount  the amount of tokens the user has invested across all strategies\\n     */\\n  function getUserInvestedAmountByToken(address token, address user)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n    @notice Returns the total amount of a token invested across all strategies\\n    @param token  the token to fetch the balance for\\n    @return amount  the amount of the token currently invested\\n    */\\n  function getTokenTotalBalance(address token)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n  @notice Returns the weight of an individual integration within the system\\n  @param integration  the integration to look up\\n  @return The weight of the integration\\n   */\\n  function getIntegrationWeight(address integration)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n  @notice Returns the sum of all weights in the system.\\n  @return The sum of all integration weights within the system\\n   */\\n  function getIntegrationWeightSum() external view returns (uint256);\\n\\n  /// @notice autogenerated getter definition\\n  function idCounter() external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IYieldManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IYieldManager {\\n  /// @param gasAccountTargetEthBalance_ The target ETH balance of the gas account\\n  function updateGasAccountTargetEthBalance(uint256 gasAccountTargetEthBalance_)\\n    external;\\n\\n  /// @param biosBuyBackEthWeight_ The relative weight of ETH to send to BIOS buy back\\n  /// @param treasuryEthWeight_ The relative weight of ETH to send to the treasury\\n  /// @param protocolFeeEthWeight_ The relative weight of ETH to send to protocol fee accrual\\n  /// @param rewardsEthWeight_ The relative weight of ETH to send to user rewards\\n  function updateEthDistributionWeights(\\n    uint32 biosBuyBackEthWeight_,\\n    uint32 treasuryEthWeight_,\\n    uint32 protocolFeeEthWeight_,\\n    uint32 rewardsEthWeight_\\n  ) external;\\n\\n  /// @param gasAccount_ The address of the account to send ETH to gas for executing bulk system functions\\n  function updateGasAccount(address payable gasAccount_) external;\\n\\n  /// @param treasuryAccount_ The address of the system treasury account\\n  function updateTreasuryAccount(address payable treasuryAccount_) external;\\n\\n  /// @notice Withdraws and then re-deploys tokens to integrations according to configured weights\\n  function rebalance() external;\\n\\n  /// @notice Deploys all tokens to all integrations according to configured weights\\n  function deploy() external;\\n\\n  /// @notice Harvests available yield from all tokens and integrations\\n  function harvestYield() external;\\n\\n  /// @notice Swaps harvested yield for all tokens for ETH\\n  function processYield() external;\\n\\n  /// @notice Distributes ETH to the gas account, BIOS buy back, treasury, protocol fee accrual, and user rewards\\n  function distributeEth() external;\\n\\n  /// @notice Uses WETH to buy back BIOS which is sent to the Kernel\\n  function biosBuyBack() external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return harvestedTokenBalance The amount of the token yield harvested held in the Kernel\\n  function getHarvestedTokenBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The amount of the token held in the Kernel as reserves\\n  function getReserveTokenBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The desired amount of the token to hold in the Kernel as reserves\\n  function getDesiredReserveTokenBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return ethWeightSum The sum of ETH distribution weights\\n  function getEthWeightSum() external view returns (uint32 ethWeightSum);\\n\\n  /// @return processedWethSum The sum of yields processed into WETH\\n  function getProcessedWethSum()\\n    external\\n    view\\n    returns (uint256 processedWethSum);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The amount of WETH received from token yield processing\\n  function getProcessedWethByToken(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return processedWethByTokenSum The sum of processed WETH\\n  function getProcessedWethByTokenSum()\\n    external\\n    view\\n    returns (uint256 processedWethByTokenSum);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return tokenTotalIntegrationBalance The total amount of the token that can be withdrawn from integrations\\n  function getTokenTotalIntegrationBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256 tokenTotalIntegrationBalance);\\n\\n  /// @return The address of the gas account\\n  function getGasAccount() external view returns (address);\\n\\n  /// @return The address of the treasury account\\n  function getTreasuryAccount() external view returns (address);\\n\\n  /// @return The last amount of ETH distributed to rewards\\n  function getLastEthRewardsAmount() external view returns (uint256);\\n\\n  /// @return The target ETH balance of the gas account\\n  function getGasAccountTargetEthBalance() external view returns (uint256);\\n\\n  /// @return The BIOS buyback ETH weight\\n  /// @return The Treasury ETH weight\\n  /// @return The Protocol fee ETH weight\\n  /// @return The rewards ETH weight\\n  function getEthDistributionWeights()\\n    external\\n    view\\n    returns (\\n      uint32,\\n      uint32,\\n      uint32,\\n      uint32\\n    );\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"}],\"name\":\"__Controlled_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"addController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"deleteStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleMap\",\"outputs\":[{\"internalType\":\"contract IModuleMap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"}],\"name\":\"updateStrategyIntegrations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"updateStrategyName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"updateStrategyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StrategyManager","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":""}]}