{"status":"1","message":"OK","result":[{"SourceCode":"// This contract will generate rewards for life and will be used to fund FEG developments. \r\n// Only the rewards from the burnt balance inside can be removed, the burnt balance can never be removed unless contract is broken.\r\n// Broken contract = 180 days since last reward claim.\r\n// This contract will burn the ROX removed for asset backing and not be sold on market.\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// SafeMath library\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    \r\n    function ceil(uint a, uint m) internal pure returns (uint r) {\r\n        return (a + m - 1) / m * m;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event fundTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = msg.sender; \r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"ERC20: sending to the zero address\");\r\n        owner = _newOwner;\r\n        emit fundTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) external returns (bool success);\r\n    function approve(address spender, uint256 tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\r\n    function burnTokens(uint256 _amount) external;\r\n    \r\n    function calculateFeesBeforeSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external view returns (uint256, uint256);\r\n    \r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ninterface roxx {\r\n    function liquifyForMain(uint256 amt) external returns(uint tokenAmountOut);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\ncontract ROXPerpRewardFund is Owned, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    \r\n    roxx _roxx;\r\n    address public ROX  = 0x378c77C5379cA07BBB5B3506c08a1C769dEC91c2; // ROX token\r\n    uint256 public totalBurnt = 0;\r\n    address public fund1 = 0xC35D37147CD4f918A7cc7e58a29E51559e385548; \r\n    address public fund2 = 0x620844ddBe24240e0BB2DbB40a322619B608FbF7; \r\n    address public fund3 = 0x9550aC8B333A0A0F5A9B0F0Cb61f9265d9405028; \r\n    address public fund4 = 0xAd0A7B1Dd61762cb4747C712D8612408bFf3EA82; \r\n    address public fund5 = 0x191dE23a590599Fb3a0A106dda1F62113B4e6a99; \r\n    address public fund6 = 0xCd4b658404fF9cA476A9362242f018b2b7b45722; \r\n    address public fund7 = 0xD7e4310F9Ebc41dB113CcCBc1Dc319eB66e93FBf; \r\n    mapping(address => uint256) private _balances1;\r\n    uint256 public cast = 0;\r\n    event BURNT(address staker, uint256 tokens); \r\n    event CLAIM(address fund, uint256 amt);\r\n    event DISTRIBUTED(uint256 amt, uint256 cast);\r\n\r\n    constructor(){\r\n        _roxx = roxx(ROX);\r\n    }\r\n    \r\n    receive() external payable {\r\n    }\r\n\r\n    function myPendingClaim() external view returns(uint256){\r\n        uint256 pendingClaim = _balances1[msg.sender];\r\n        return pendingClaim;\r\n    }\r\n    \r\n    function supplyROX(uint256 tokens) external nonReentrant { \r\n        require(IERC20(ROX).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from user for locking\");\r\n        totalBurnt = totalBurnt.add(tokens * 99/100); // Set for 1% tx fees\r\n        emit BURNT(msg.sender, tokens);\r\n    }\r\n    \r\n    function updateFund1(address _fund1) external nonReentrant {\r\n        require(msg.sender == fund1, \"You do not have permission\");\r\n        require(_fund1 != address(0), \"Cannot set the 0 address\");\r\n        fund1 = _fund1;\r\n    }\r\n    \r\n    function updateFund2(address _fund2) external nonReentrant {\r\n        require(msg.sender == fund2, \"You do not have permission\");\r\n        require(_fund2 != address(0), \"Cannot set the 0 address\");\r\n        fund2 = _fund2;\r\n    }\r\n    \r\n    function updateFund3(address _fund3) external nonReentrant {\r\n        require(msg.sender == fund3, \"You do not have permission\");\r\n        require(_fund3 != address(0), \"Cannot set the 0 address\");\r\n        fund3 = _fund3;\r\n    }\r\n    \r\n    function updateFund4(address _fund4) external nonReentrant {\r\n        require(msg.sender == fund4, \"You do not have permission\");\r\n        require(_fund4 != address(0), \"Cannot set the 0 address\");\r\n        fund4 = _fund4;\r\n    }\r\n    \r\n    function updateFund5(address _fund5) external nonReentrant {\r\n        require(msg.sender == fund5, \"You do not have permission\");\r\n        require(_fund5 != address(0), \"Cannot set the 0 address\");\r\n        fund5 = _fund5;\r\n    }\r\n    \r\n    function updateFund6(address _fund6) external nonReentrant onlyOwner {\r\n        require(_fund6 != address(0), \"Cannot set the 0 address\");\r\n        fund6 = _fund6;\r\n    }\r\n    \r\n    function updateFund7(address _fund7) external nonReentrant onlyOwner {\r\n        require(_fund7 != address(0), \"Cannot set the 0 address\");\r\n        fund7 = _fund7;\r\n    }\r\n    \r\n    function amtForDist() public view returns(uint256){\r\n        uint256 oo = totalPendingClaims();\r\n        uint256 total = (IERC20(ROX).balanceOf(address(this))).sub(totalBurnt.add(oo));\r\n        return total;\r\n    }\r\n    \r\n    function totalPendingClaims() public view returns(uint256) {\r\n        uint256 amt = (_balances1[fund1] + _balances1[fund2] + _balances1[fund3] + _balances1[fund4] + _balances1[fund5] + _balances1[fund6] + _balances1[fund7]);\r\n        return amt;\r\n    }\r\n    \r\n    function claimFund1() external nonReentrant {\r\n        distributeRewards1();\r\n        require(msg.sender == fund1, \"You do not have permission\");\r\n        uint256 share = _balances1[fund1];\r\n        _balances1[fund1] = 0;\r\n        IERC20(address(ROX)).approve(address(ROX), share);\r\n        _roxx.liquifyForMain(share);\r\n        uint256 mypart = address(this).balance;\r\n        TransferHelper.safeTransferETH(fund1, mypart);\r\n        emit CLAIM(fund1, mypart);\r\n    }\r\n    \r\n    function claimFund2() external nonReentrant{\r\n        distributeRewards1();\r\n        require(msg.sender == fund2, \"You do not have permission\");\r\n        uint256 share = _balances1[fund2];\r\n        _balances1[fund2] = 0;\r\n        IERC20(address(ROX)).approve(address(ROX), share);\r\n        _roxx.liquifyForMain(share);\r\n        uint256 mypart = address(this).balance;\r\n        TransferHelper.safeTransferETH(fund2, mypart);\r\n        emit CLAIM(fund2, mypart);\r\n    }\r\n    \r\n    function claimFund3() external nonReentrant{\r\n        distributeRewards1();\r\n        require(msg.sender == fund3, \"You do not have permission\");\r\n        uint256 share = _balances1[fund3];\r\n        _balances1[fund3] = 0;\r\n        IERC20(address(ROX)).approve(address(ROX), share);\r\n        _roxx.liquifyForMain(share);\r\n        uint256 mypart = address(this).balance;\r\n        TransferHelper.safeTransferETH(fund3, mypart);\r\n        emit CLAIM(fund3, mypart);\r\n    }\r\n    \r\n    function claimFund4() external nonReentrant{\r\n        distributeRewards1();\r\n        require(msg.sender == fund4, \"You do not have permission\");\r\n        uint256 share = _balances1[fund4];\r\n        _balances1[fund4] = 0;\r\n        IERC20(address(ROX)).approve(address(ROX), share);\r\n        _roxx.liquifyForMain(share);\r\n        uint256 mypart = address(this).balance;\r\n        TransferHelper.safeTransferETH(fund4, mypart);\r\n        emit CLAIM(fund4, mypart);\r\n    }\r\n    \r\n    function claimFund5() external nonReentrant{\r\n        distributeRewards1();\r\n        require(msg.sender == fund5, \"You do not have permission\");\r\n        uint256 share = _balances1[fund5];\r\n        _balances1[fund5] = 0;\r\n        IERC20(address(ROX)).approve(address(ROX), share);\r\n        _roxx.liquifyForMain(share);\r\n        uint256 mypart = address(this).balance;\r\n        TransferHelper.safeTransferETH(fund5, mypart);\r\n        emit CLAIM(fund5, mypart);\r\n    }\r\n    \r\n    function claimFund6() external nonReentrant{\r\n        distributeRewards1();\r\n        require(msg.sender == fund6, \"You do not have permission\");\r\n        uint256 share = _balances1[fund6];\r\n        _balances1[fund6] = 0;\r\n        IERC20(address(ROX)).approve(address(ROX), share);\r\n        _roxx.liquifyForMain(share);\r\n        uint256 mypart = address(this).balance;\r\n        TransferHelper.safeTransferETH(fund6, mypart);\r\n        emit CLAIM(fund5, mypart);\r\n    }\r\n    \r\n    function claimFund7() external nonReentrant{\r\n        distributeRewards1();\r\n        require(msg.sender == fund7, \"You do not have permission\");\r\n        uint256 share = _balances1[fund7];\r\n        _balances1[fund7] = 0;\r\n        IERC20(address(ROX)).approve(address(ROX), share);\r\n        _roxx.liquifyForMain(share);\r\n        uint256 mypart = address(this).balance;\r\n        TransferHelper.safeTransferETH(fund7, mypart);\r\n        emit CLAIM(fund7, mypart);\r\n    }\r\n    \r\n    function distributeRewards() external { // Distribute tx fees collected for conversion into rewards for planned purposes, can only be called by fund1-7\r\n        require(msg.sender == fund1 || msg.sender == fund2 || msg.sender == fund3 || msg.sender == fund4 || msg.sender == fund5 || msg.sender == fund6 || msg.sender == fund7);\r\n        uint256 oo = totalPendingClaims();\r\n        uint256 transferMax = (IERC20(ROX).balanceOf(address(this))).sub(totalBurnt.add(oo));\r\n        if(transferMax >= 1e5){\r\n        uint256 amt  = transferMax;\r\n        uint256 amt0 = amt.div(20);\r\n        uint256 amt1 = amt.sub(amt.sub(amt0));\r\n        uint256 amt2 = amt1.mul(5);\r\n        uint256 amt3 = (amt1.mul(10));\r\n        _balances1[fund1] += amt1;\r\n        _balances1[fund2] += amt1;\r\n        _balances1[fund3] += amt1;\r\n        _balances1[fund4] += amt1;\r\n        _balances1[fund5] += amt1;\r\n        _balances1[fund6] += amt2;\r\n        _balances1[fund7] += amt3;\r\n        cast = block.timestamp + 180 days;\r\n        emit DISTRIBUTED(amt, cast);\r\n        }\r\n    }\r\n    \r\n    function distributeRewards1() internal { // Distribute tx fees collected for conversion into rewards for planned purposes\r\n        \r\n        uint256 oo = totalPendingClaims();\r\n        uint256 transferMax = (IERC20(ROX).balanceOf(address(this))).sub(totalBurnt.add(oo));\r\n        if(transferMax >= 1e5){\r\n        uint256 amt  = transferMax;\r\n        uint256 amt0 = amt.div(20);\r\n        uint256 amt1 = amt.sub(amt.sub(amt0));\r\n        uint256 amt2 = amt1.mul(5);\r\n        uint256 amt3 = (amt1.mul(10));\r\n        _balances1[fund1] += amt1;\r\n        _balances1[fund2] += amt1;\r\n        _balances1[fund3] += amt1;\r\n        _balances1[fund4] += amt1;\r\n        _balances1[fund5] += amt1;\r\n        _balances1[fund6] += amt2;\r\n        _balances1[fund7] += amt3;\r\n        cast = block.timestamp + 180 days;\r\n        emit DISTRIBUTED(amt, cast);\r\n        }\r\n    }\r\n    \r\n    function saveLost() external onlyOwner { // Incase contract ever breaks, must be 180 days after last distribution\r\n        require(block.timestamp > cast, \"Must be 180 days since last claim\");\r\n        uint256 amt = IERC20(ROX).balanceOf(address(this));\r\n        IERC20(ROX).transfer(owner, amt);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"BURNT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fund\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"CLAIM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cast\",\"type\":\"uint256\"}],\"name\":\"DISTRIBUTED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"fundTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ROX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amtForDist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFund1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFund2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFund3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFund4\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFund5\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFund6\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFund7\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund4\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund5\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund6\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund7\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myPendingClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saveLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"supplyROX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPendingClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund1\",\"type\":\"address\"}],\"name\":\"updateFund1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund2\",\"type\":\"address\"}],\"name\":\"updateFund2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund3\",\"type\":\"address\"}],\"name\":\"updateFund3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund4\",\"type\":\"address\"}],\"name\":\"updateFund4\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund5\",\"type\":\"address\"}],\"name\":\"updateFund5\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund6\",\"type\":\"address\"}],\"name\":\"updateFund6\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund7\",\"type\":\"address\"}],\"name\":\"updateFund7\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ROXPerpRewardFund","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f64308202a6916c3cef51d6bf3b58403f783140211f3617746ebeb71a20f4229"}]}