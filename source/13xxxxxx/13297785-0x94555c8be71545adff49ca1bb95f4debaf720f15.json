{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n\"\"\"\r\n@title Liquidity Gauge LIX\r\n@author Lixir Finance\r\n@license MIT\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\ninterface Controller:\r\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\r\n    def voting_escrow() -> address: view\r\n    def checkpoint(): nonpayable\r\n    def checkpoint_gauge(addr: address): nonpayable\r\n\r\ninterface Distributor:\r\n    # lifted from Minter\r\n    def lix() -> address: view\r\n    def controller() -> address: view\r\n    def distributed(user: address, gauge: address) -> uint256: view\r\n\r\n    # these two are lifted from CRV20\r\n    def future_epoch_time_write() -> uint256: nonpayable\r\n    def rate() -> uint256: view\r\n\r\ninterface VotingEscrow:\r\n    def user_point_epoch(addr: address) -> uint256: view\r\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\r\n\r\ninterface ERC20Extended:\r\n    def symbol() -> String[26]: view\r\n\r\ninterface LixirRegistry:\r\n    def isGovOrDelegate(account: address) -> bool: view\r\n\r\n\r\n# Interface for checking whether address belongs to a whitelisted\r\n# type of a smart wallet.\r\n# When new types are added - the whole contract is changed\r\n# The check() method is modifying to be able to use caching\r\n# for individual wallet addresses\r\ninterface SmartWalletChecker:\r\n    def check(addr: address) -> bool: nonpayable\r\n\r\n\r\nevent Deposit:\r\n    provider: indexed(address)\r\n    value: uint256\r\n\r\nevent Withdraw:\r\n    provider: indexed(address)\r\n    value: uint256\r\n\r\nevent UpdateLiquidityLimit:\r\n    user: address\r\n    original_balance: uint256\r\n    original_supply: uint256\r\n    working_balance: uint256\r\n    working_supply: uint256\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\n\r\nTOKENLESS_PRODUCTION: constant(uint256) = 40\r\nWEEK: constant(uint256) = 604800\r\n\r\ndistributor: public(address) # minter: public(address)\r\nlix_token: public(address)\r\nlp_token: public(address)\r\ncontroller: public(address)\r\nvoting_escrow: public(address)\r\nfuture_epoch_time: public(uint256)\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\ntotalSupply: public(uint256)\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\n\r\nworking_balances: public(HashMap[address, uint256])\r\nworking_supply: public(uint256)\r\n\r\n# The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\r\n# All values are kept in units of being multiplied by 1e18\r\nperiod: public(int128)\r\nperiod_timestamp: public(uint256[100000000000000000000000000000])\r\n\r\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\r\n\r\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\r\nintegrate_inv_supply_of: public(HashMap[address, uint256])\r\nintegrate_checkpoint_of: public(HashMap[address, uint256])\r\n\r\n# ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\n# Units: rate * t = already number of coins per address to issue\r\nintegrate_fraction: public(HashMap[address, uint256])\r\n\r\ndistribution_rate: public(uint256) # inflation_rate: public(uint256)\r\n\r\n# Checker for whitelisted (smart contract) wallets which are allowed to deposit\r\n# The goal is to prevent tokenizing the escrow\r\nfuture_smart_wallet_checker: public(address)\r\nsmart_wallet_checker: public(address) # veCRV uses this on mainnet: 0xca719728ef172d0961768581fdf35cb116e0b7a4\r\n\r\nregistry: public(address)\r\nis_killed: public(bool)\r\n\r\n@external\r\ndef __init__(_lp_token: address, _distributor: address, _registry: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _lp_token Liquidity Pool contract address\r\n    @param _distributor Distributor contract address\r\n    @param _registry Registry\r\n    \"\"\"\r\n\r\n    symbol: String[26] = ERC20Extended(_lp_token).symbol()\r\n    self.name = concat(\"Lixir Finance \", symbol, \" Gauge Deposit\")\r\n    self.symbol = concat(symbol, \"-gauge\")\r\n\r\n    lix_token: address = Distributor(_distributor).lix()\r\n    controller: address = Distributor(_distributor).controller()\r\n\r\n    self.lp_token = _lp_token\r\n    self.distributor = _distributor\r\n    self.registry = _registry\r\n    self.lix_token = lix_token\r\n    self.controller = controller\r\n    self.voting_escrow = Controller(controller).voting_escrow()\r\n\r\n    self.period_timestamp[0] = block.timestamp\r\n    self.distribution_rate = Distributor(_distributor).rate()\r\n    self.future_epoch_time = Distributor(_distributor).future_epoch_time_write()\r\n\r\n\r\n@view\r\n@external\r\ndef decimals() -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of decimals for this token\r\n    @dev Implemented as a view method to reduce gas costs\r\n    @return uint256 decimal places\r\n    \"\"\"\r\n    return 18\r\n\r\n@view\r\n@external\r\ndef integrate_checkpoint() -> uint256:\r\n    return self.period_timestamp[self.period]\r\n\r\n\r\n@external\r\ndef commit_smart_wallet_checker(addr: address):\r\n    \"\"\"\r\n    @notice Set an external contract to check for approved smart contract wallets\r\n    @param addr Address of Smart contract checker\r\n    \"\"\"\r\n    assert LixirRegistry(self.registry).isGovOrDelegate(msg.sender)\r\n    self.future_smart_wallet_checker = addr\r\n\r\n\r\n@external\r\ndef apply_smart_wallet_checker():\r\n    \"\"\"\r\n    @notice Apply setting external contract to check approved smart contract wallets\r\n    \"\"\"\r\n    assert LixirRegistry(self.registry).isGovOrDelegate(msg.sender)\r\n    self.smart_wallet_checker = self.future_smart_wallet_checker\r\n\r\n\r\n@internal\r\ndef assert_not_contract(addr: address):\r\n    \"\"\"\r\n    @notice Check if the call is from a whitelisted smart contract, revert if not\r\n    @param addr Address to be checked\r\n    \"\"\"\r\n    if addr.is_contract:\r\n        checker: address = self.smart_wallet_checker\r\n        if checker != ZERO_ADDRESS:\r\n            if SmartWalletChecker(checker).check(addr):\r\n                return\r\n        raise \"Smart contract depositors not allowed\"\r\n\r\n\r\n@internal\r\ndef _update_liquidity_limit(addr: address, l: uint256, L: uint256):\r\n    \"\"\"\r\n    @notice Calculate limits which depend on the amount of CRV token per-user.\r\n            Effectively it calculates working balances to apply amplification\r\n            of CRV production by CRV\r\n    @param addr User address\r\n    @param l User's amount of liquidity (LP tokens)\r\n    @param L Total amount of liquidity (LP tokens)\r\n    \"\"\"\r\n    # To be called after totalSupply is updated\r\n    _voting_escrow: address = self.voting_escrow\r\n    voting_balance: uint256 = ERC20(_voting_escrow).balanceOf(addr)\r\n    voting_total: uint256 = ERC20(_voting_escrow).totalSupply()\r\n\r\n    lim: uint256 = l * TOKENLESS_PRODUCTION / 100\r\n    if voting_total > 0:\r\n        lim += L * voting_balance / voting_total * (100 - TOKENLESS_PRODUCTION) / 100\r\n\r\n    lim = min(l, lim)\r\n    old_bal: uint256 = self.working_balances[addr]\r\n    self.working_balances[addr] = lim\r\n    _working_supply: uint256 = self.working_supply + lim - old_bal\r\n    self.working_supply = _working_supply\r\n\r\n    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\r\n\r\n\r\n@internal\r\ndef _checkpoint(addr: address):\r\n    \"\"\"\r\n    @notice Checkpoint for a user\r\n    @param addr User address\r\n    \"\"\"\r\n    _period: int128 = self.period\r\n    _period_time: uint256 = self.period_timestamp[_period]\r\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\r\n    rate: uint256 = self.distribution_rate\r\n    new_rate: uint256 = rate\r\n    prev_future_epoch: uint256 = self.future_epoch_time\r\n    if prev_future_epoch >= _period_time:\r\n        _dist: address = self.distributor\r\n        self.future_epoch_time = Distributor(self.distributor).future_epoch_time_write()\r\n        new_rate = Distributor(self.distributor).rate()\r\n        self.distribution_rate = new_rate\r\n\r\n    if self.is_killed:\r\n        # Stop distributing inflation as soon as killed\r\n        rate = 0\r\n\r\n    # Update integral of 1/supply\r\n    if block.timestamp > _period_time:\r\n        _working_supply: uint256 = self.working_supply\r\n        _controller: address = self.controller\r\n        Controller(_controller).checkpoint_gauge(self)\r\n        prev_week_time: uint256 = _period_time\r\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\r\n\r\n        for i in range(500):\r\n            dt: uint256 = week_time - prev_week_time\r\n            w: uint256 = Controller(_controller).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\r\n\r\n            if _working_supply > 0:\r\n                if prev_future_epoch >= prev_week_time and prev_future_epoch < week_time:\r\n                    # If we went across one or multiple epochs, apply the rate\r\n                    # of the first epoch until it ends, and then the rate of\r\n                    # the last epoch.\r\n                    # If more than one epoch is crossed - the gauge gets less,\r\n                    # but that'd meen it wasn't called for more than 1 year\r\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\r\n                    rate = new_rate\r\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\r\n                else:\r\n                    _integrate_inv_supply += rate * w * dt / _working_supply\r\n                # On precisions of the calculation\r\n                # rate ~= 10e18\r\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\r\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\r\n                # The largest loss is at dt = 1\r\n                # Loss is 1e-9 - acceptable\r\n\r\n            if week_time == block.timestamp:\r\n                break\r\n            prev_week_time = week_time\r\n            week_time = min(week_time + WEEK, block.timestamp)\r\n\r\n    _period += 1\r\n    self.period = _period\r\n    self.period_timestamp[_period] = block.timestamp\r\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\r\n\r\n    # Update user-specific integrals\r\n    _working_balance: uint256 = self.working_balances[addr]\r\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\r\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\r\n    self.integrate_checkpoint_of[addr] = block.timestamp\r\n\r\n\r\n@external\r\ndef user_checkpoint(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for `addr`\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    assert (msg.sender == addr) or (msg.sender == self.distributor) # dev: unauthorized\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n    return True\r\n\r\n\r\n@external\r\ndef claimable_tokens(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable tokens per user\r\n    @dev This function should be manually changed to \"view\" in the ABI\r\n    @return uint256 number of claimable tokens per user\r\n    \"\"\"\r\n    self._checkpoint(addr)\r\n    return self.integrate_fraction[addr] - Distributor(self.distributor).distributed(addr, self)\r\n\r\n\r\n@external\r\ndef kick(addr: address):\r\n    \"\"\"\r\n    @notice Kick `addr` for abusing their boost\r\n    @dev Only if either they had another voting event, or their voting escrow lock expired\r\n    @param addr Address to kick\r\n    \"\"\"\r\n    _voting_escrow: address = self.voting_escrow\r\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\r\n    t_ve: uint256 = VotingEscrow(_voting_escrow).user_point_history__ts(\r\n        addr, VotingEscrow(_voting_escrow).user_point_epoch(addr)\r\n    )\r\n    _balance: uint256 = self.balanceOf[addr]\r\n\r\n    assert ERC20(_voting_escrow).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\r\n    assert self.working_balances[addr] > _balance * TOKENLESS_PRODUCTION / 100  # dev: kick not needed\r\n\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit(_value: uint256, _addr: address = msg.sender, args: Bytes[128] = b\"\"):\r\n    \"\"\"\r\n    @notice Deposit `_value` LP tokens\r\n    @param _value Number of tokens to deposit\r\n    @param _addr Address to deposit for\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    self._checkpoint(_addr)\r\n\r\n    if _value != 0:\r\n        total_supply: uint256 = self.totalSupply\r\n\r\n        total_supply += _value\r\n        new_balance: uint256 = self.balanceOf[_addr] + _value\r\n        self.balanceOf[_addr] = new_balance\r\n        self.totalSupply = total_supply\r\n\r\n        self._update_liquidity_limit(_addr, new_balance, total_supply)\r\n\r\n        if len(args) != 0:\r\n            raw_call(\r\n                self.lp_token,\r\n                concat(\r\n                    method_id(\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\"),\r\n                    convert(_addr, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(_value, bytes32),\r\n                    args\r\n                )\r\n            )\r\n            ERC20(self.lp_token).transferFrom(_addr, self, _value)\r\n        else:\r\n            ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\r\n\r\n\r\n    log Deposit(_addr, _value)\r\n    log Transfer(ZERO_ADDRESS, _addr, _value)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(_value: uint256):\r\n    \"\"\"\r\n    @notice Withdraw `_value` LP tokens\r\n    @param _value Number of tokens to withdraw\r\n    \"\"\"\r\n    self._checkpoint(msg.sender)\r\n\r\n    if _value != 0:\r\n        total_supply: uint256 = self.totalSupply\r\n\r\n        total_supply -= _value\r\n        new_balance: uint256 = self.balanceOf[msg.sender] - _value\r\n        self.balanceOf[msg.sender] = new_balance\r\n        self.totalSupply = total_supply\r\n\r\n        self._update_liquidity_limit(msg.sender, new_balance, total_supply)\r\n        # TODO doesn't this need to check that _value is correct? How do you stop someone from just withdrawing everything when they don't have the balance??\r\n        ERC20(self.lp_token).transfer(msg.sender, _value)\r\n\r\n    log Withdraw(msg.sender, _value)\r\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    self._checkpoint(_from)\r\n    self._checkpoint(_to)\r\n\r\n    if _value != 0:\r\n        total_supply: uint256 = self.totalSupply\r\n\r\n        new_balance: uint256 = self.balanceOf[_from] - _value\r\n        self.balanceOf[_from] = new_balance\r\n        self._update_liquidity_limit(_from, new_balance, total_supply)\r\n\r\n        new_balance = self.balanceOf[_to] + _value\r\n        self.balanceOf[_to] = new_balance\r\n        self._update_liquidity_limit(_to, new_balance, total_supply)\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer token for a specified address\r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    self.assert_not_contract(_to)\r\n    self._transfer(msg.sender, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @notice Transfer tokens from one address to another.\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n    \"\"\"\r\n    self.assert_not_contract(_to)\r\n    _allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if _allowance != MAX_UINT256:\r\n        self.allowance[_from][msg.sender] = _allowance - _value\r\n\r\n    self._transfer(_from, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve the passed address to transfer the specified amount of\r\n            tokens on behalf of msg.sender\r\n    @dev Beware that changing an allowance via this method brings the risk\r\n         that someone may use both the old and new allowance by unfortunate\r\n         transaction ordering. This may be mitigated with the use of\r\n         {incraseAllowance} and {decreaseAllowance}.\r\n         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will transfer the funds\r\n    @param _value The amount of tokens that may be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self.assert_not_contract(_spender)\r\n    self.allowance[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender: address, _added_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _added_value The amount of to increase the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    self.assert_not_contract(_spender)\r\n    allowance: uint256 = self.allowance[msg.sender][_spender] + _added_value\r\n    self.allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender: address, _subtracted_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _subtracted_value The amount of to decrease the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self.allowance[msg.sender][_spender] - _subtracted_value\r\n    self.allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n@external\r\ndef set_killed(_is_killed: bool):\r\n    \"\"\"\r\n    @notice Set the killed status for this contract\r\n    @dev When killed, the gauge always yields a rate of 0 and so cannot mint CRV\r\n    @param _is_killed Killed status to set\r\n    \"\"\"\r\n    assert LixirRegistry(self.registry).isGovOrDelegate(msg.sender)\r\n\r\n    self.is_killed = _is_killed","ABI":"[{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateLiquidityLimit\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":false},{\"name\":\"original_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"original_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"working_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"working_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":288},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4624},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_smart_wallet_checker\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39995},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_smart_wallet_checker\",\"inputs\":[],\"outputs\":[],\"gas\":42022},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3138012},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimable_tokens\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3051019},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kick\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":3152393},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"args\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":3271842},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":12689444},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":12727394},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":46010},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_added_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":48551},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtracted_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":40629},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":40355},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"distributor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2838},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lix_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2868},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2898},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2928},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_escrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2958},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_epoch_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2988},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3233},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3048},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3508},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":13410},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":11163},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3383},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3198},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":3228},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period_timestamp\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3367},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3397},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3533},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3563},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3593},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"distribution_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3528}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000009e815d1c9a4be458e7f9a0add703e7545eda7c280000000000000000000000001af8ef20e0f447329933753baa28353efe21f53400000000000000000000000018bf8a3ee39be5730189a0c88d90f744e3c55b20","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}