{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenRepresentationProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\nimport \\\"./TicketBooth.sol\\\";\\n\\n/** \\n  @notice\\n  ERC20 wrapper for TicketBooth calls that return both staked + unstaked JBX supply.\\n*/\\ncontract TokenRepresentationProxy is ERC20 {\\n    ITicketBooth ticketBooth;\\n    uint256 projectId;\\n\\n    constructor(\\n        ITicketBooth _ticketBooth,\\n        uint256 _projectId,\\n        string memory name,\\n        string memory ticker\\n    ) ERC20(name, ticker) {\\n        ticketBooth = _ticketBooth;\\n        projectId = _projectId;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return ticketBooth.totalSupplyOf(projectId);\\n    }\\n\\n    function balanceOf(address _account) public view virtual override returns (uint256) {\\n        return ticketBooth.balanceOf(_account, projectId);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/TicketBooth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./interfaces/ITicketBooth.sol\\\";\\nimport \\\"./abstract/Operatable.sol\\\";\\nimport \\\"./abstract/TerminalUtility.sol\\\";\\n\\nimport \\\"./libraries/Operations.sol\\\";\\n\\nimport \\\"./Tickets.sol\\\";\\n\\n/** \\n  @notice \\n  Manage Ticket printing, redemption, and account balances.\\n\\n  @dev\\n  Tickets can be either represented internally staked, or as unstaked ERC-20s.\\n  This contract manages these two representations and the conversion between the two.\\n\\n  @dev\\n  The total supply of a project's tickets and the balance of each account are calculated in this contract.\\n*/\\ncontract TicketBooth is TerminalUtility, Operatable, ITicketBooth {\\n    // --- public immutable stored properties --- //\\n\\n    /// @notice The Projects contract which mints ERC-721's that represent project ownership and transfers.\\n    IProjects public immutable override projects;\\n\\n    // --- public stored properties --- //\\n\\n    // Each project's ERC20 Ticket tokens.\\n    mapping(uint256 => ITickets) public override ticketsOf;\\n\\n    // Each holder's balance of staked Tickets for each project.\\n    mapping(address => mapping(uint256 => uint256))\\n        public\\n        override stakedBalanceOf;\\n\\n    // The total supply of 1155 tickets for each project.\\n    mapping(uint256 => uint256) public override stakedTotalSupplyOf;\\n\\n    // The amount of each holders tickets that are locked.\\n    mapping(address => mapping(uint256 => uint256))\\n        public\\n        override lockedBalanceOf;\\n\\n    // The amount of each holders tickets that are locked by each address.\\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\\n        public\\n        override lockedBalanceBy;\\n\\n    // --- external views --- //\\n\\n    /** \\n      @notice \\n      The total supply of tickets for each project, including staked and unstaked tickets.\\n\\n      @param _projectId The ID of the project to get the total supply of.\\n\\n      @return supply The total supply.\\n    */\\n    function totalSupplyOf(uint256 _projectId)\\n        external\\n        view\\n        override\\n        returns (uint256 supply)\\n    {\\n        supply = stakedTotalSupplyOf[_projectId];\\n        ITickets _tickets = ticketsOf[_projectId];\\n        if (_tickets != ITickets(address(0)))\\n            supply = supply + _tickets.totalSupply();\\n    }\\n\\n    /** \\n      @notice \\n      The total balance of tickets a holder has for a specified project, including staked and unstaked tickets.\\n\\n      @param _holder The ticket holder to get a balance for.\\n      @param _projectId The project to get the `_hodler`s balance of.\\n\\n      @return balance The balance.\\n    */\\n    function balanceOf(address _holder, uint256 _projectId)\\n        external\\n        view\\n        override\\n        returns (uint256 balance)\\n    {\\n        balance = stakedBalanceOf[_holder][_projectId];\\n        ITickets _ticket = ticketsOf[_projectId];\\n        if (_ticket != ITickets(address(0)))\\n            balance = balance + _ticket.balanceOf(_holder);\\n    }\\n\\n    // --- external transactions --- //\\n\\n    /** \\n      @param _projects A Projects contract which mints ERC-721's that represent project ownership and transfers.\\n      @param _operatorStore A contract storing operator assignments.\\n      @param _terminalDirectory A directory of a project's current Juicebox terminal to receive payments in.\\n    */\\n    constructor(\\n        IProjects _projects,\\n        IOperatorStore _operatorStore,\\n        ITerminalDirectory _terminalDirectory\\n    ) Operatable(_operatorStore) TerminalUtility(_terminalDirectory) {\\n        projects = _projects;\\n    }\\n\\n    /**\\n        @notice \\n        Issues an owner's ERC-20 Tickets that'll be used when unstaking tickets.\\n\\n        @dev \\n        Deploys an owner's Ticket ERC-20 token contract.\\n\\n        @param _projectId The ID of the project being issued tickets.\\n        @param _name The ERC-20's name. \\\" Juicebox ticket\\\" will be appended.\\n        @param _symbol The ERC-20's symbol. \\\"j\\\" will be prepended.\\n    */\\n    function issue(\\n        uint256 _projectId,\\n        string calldata _name,\\n        string calldata _symbol\\n    )\\n        external\\n        override\\n        requirePermission(\\n            projects.ownerOf(_projectId),\\n            _projectId,\\n            Operations.Issue\\n        )\\n    {\\n        // There must be a name.\\n        require((bytes(_name).length > 0), \\\"TicketBooth::issue: EMPTY_NAME\\\");\\n\\n        // There must be a symbol.\\n        require(\\n            (bytes(_symbol).length > 0),\\n            \\\"TicketBooth::issue: EMPTY_SYMBOL\\\"\\n        );\\n\\n        // Only one ERC20 ticket can be issued.\\n        require(\\n            ticketsOf[_projectId] == ITickets(address(0)),\\n            \\\"TicketBooth::issue: ALREADY_ISSUED\\\"\\n        );\\n\\n        // Create the contract in this TerminalV1 contract in order to have mint and burn privileges.\\n        // Prepend the strings with standards.\\n        ticketsOf[_projectId] = new Tickets(_name, _symbol);\\n\\n        emit Issue(_projectId, _name, _symbol, msg.sender);\\n    }\\n\\n    /** \\n      @notice \\n      Print new tickets.\\n\\n      @dev\\n      Only a project's current terminal can print its tickets.\\n\\n      @param _holder The address receiving the new tickets.\\n      @param _projectId The project to which the tickets belong.\\n      @param _amount The amount to print.\\n      @param _preferUnstakedTickets Whether ERC20's should be converted automatically if they have been issued.\\n    */\\n    function print(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount,\\n        bool _preferUnstakedTickets\\n    ) external override onlyTerminal(_projectId) {\\n        // An amount must be specified.\\n        require(_amount > 0, \\\"TicketBooth::print: NO_OP\\\");\\n\\n        // Get a reference to the project's ERC20 tickets.\\n        ITickets _tickets = ticketsOf[_projectId];\\n\\n        // If there exists ERC-20 tickets and the caller prefers these unstaked tickets.\\n        bool _shouldUnstakeTickets = _preferUnstakedTickets &&\\n            _tickets != ITickets(address(0));\\n\\n        if (_shouldUnstakeTickets) {\\n            // Print the equivalent amount of ERC20s.\\n            _tickets.print(_holder, _amount);\\n        } else {\\n            // Add to the staked balance and total supply.\\n            stakedBalanceOf[_holder][_projectId] =\\n                stakedBalanceOf[_holder][_projectId] +\\n                _amount;\\n            stakedTotalSupplyOf[_projectId] =\\n                stakedTotalSupplyOf[_projectId] +\\n                _amount;\\n        }\\n\\n        emit Print(\\n            _holder,\\n            _projectId,\\n            _amount,\\n            _shouldUnstakeTickets,\\n            _preferUnstakedTickets,\\n            msg.sender\\n        );\\n    }\\n\\n    /** \\n      @notice \\n      Redeems tickets.\\n\\n      @dev\\n      Only a project's current terminal can redeem its tickets.\\n\\n      @param _holder The address that owns the tickets being redeemed.\\n      @param _projectId The ID of the project of the tickets being redeemed.\\n      @param _amount The amount of tickets being redeemed.\\n      @param _preferUnstaked If the preference is to redeem tickets that have been converted to ERC-20s.\\n    */\\n    function redeem(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount,\\n        bool _preferUnstaked\\n    ) external override onlyTerminal(_projectId) {\\n        // Get a reference to the project's ERC20 tickets.\\n        ITickets _tickets = ticketsOf[_projectId];\\n\\n        // Get a reference to the staked amount.\\n        uint256 _unlockedStakedBalance = stakedBalanceOf[_holder][_projectId] -\\n            lockedBalanceOf[_holder][_projectId];\\n\\n        // Get a reference to the number of tickets there are.\\n        uint256 _unstakedBalanceOf = _tickets == ITickets(address(0))\\n            ? 0\\n            : _tickets.balanceOf(_holder);\\n\\n        // There must be enough tickets.\\n        // Prevent potential overflow by not relying on addition.\\n        require(\\n            (_amount < _unstakedBalanceOf &&\\n                _amount < _unlockedStakedBalance) ||\\n                (_amount >= _unstakedBalanceOf &&\\n                    _unlockedStakedBalance >= _amount - _unstakedBalanceOf) ||\\n                (_amount >= _unlockedStakedBalance &&\\n                    _unstakedBalanceOf >= _amount - _unlockedStakedBalance),\\n            \\\"TicketBooth::redeem: INSUFFICIENT_FUNDS\\\"\\n        );\\n\\n        // The amount of tickets to redeem.\\n        uint256 _unstakedTicketsToRedeem;\\n\\n        // If there's no balance, redeem no tickets\\n        if (_unstakedBalanceOf == 0) {\\n            _unstakedTicketsToRedeem = 0;\\n            // If prefer converted, redeem tickets before redeeming staked tickets.\\n        } else if (_preferUnstaked) {\\n            _unstakedTicketsToRedeem = _unstakedBalanceOf >= _amount\\n                ? _amount\\n                : _unstakedBalanceOf;\\n            // Otherwise, redeem staked tickets before unstaked tickets.\\n        } else {\\n            _unstakedTicketsToRedeem = _unlockedStakedBalance >= _amount\\n                ? 0\\n                : _amount - _unlockedStakedBalance;\\n        }\\n\\n        // The amount of staked tickets to redeem.\\n        uint256 _stakedTicketsToRedeem = _amount - _unstakedTicketsToRedeem;\\n\\n        // Redeem the tickets.\\n        if (_unstakedTicketsToRedeem > 0)\\n            _tickets.redeem(_holder, _unstakedTicketsToRedeem);\\n        if (_stakedTicketsToRedeem > 0) {\\n            // Reduce the holders balance and the total supply.\\n            stakedBalanceOf[_holder][_projectId] =\\n                stakedBalanceOf[_holder][_projectId] -\\n                _stakedTicketsToRedeem;\\n            stakedTotalSupplyOf[_projectId] =\\n                stakedTotalSupplyOf[_projectId] -\\n                _stakedTicketsToRedeem;\\n        }\\n\\n        emit Redeem(\\n            _holder,\\n            _projectId,\\n            _amount,\\n            _unlockedStakedBalance,\\n            _preferUnstaked,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n      @notice \\n      Stakes ERC20 tickets by burning their supply and creating an internal staked version.\\n\\n      @dev\\n      Only a ticket holder or an operator can stake its tickets.\\n\\n      @param _holder The owner of the tickets to stake.\\n      @param _projectId The ID of the project whos tickets are being staked.\\n      @param _amount The amount of tickets to stake.\\n     */\\n    function stake(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    )\\n        external\\n        override\\n        requirePermissionAllowingWildcardDomain(\\n            _holder,\\n            _projectId,\\n            Operations.Stake\\n        )\\n    {\\n        // Get a reference to the project's ERC20 tickets.\\n        ITickets _tickets = ticketsOf[_projectId];\\n\\n        // Tickets must have been issued.\\n        require(\\n            _tickets != ITickets(address(0)),\\n            \\\"TicketBooth::stake: NOT_FOUND\\\"\\n        );\\n\\n        // Get a reference to the holder's current balance.\\n        uint256 _unstakedBalanceOf = _tickets.balanceOf(_holder);\\n\\n        // There must be enough balance to stake.\\n        require(\\n            _unstakedBalanceOf >= _amount,\\n            \\\"TicketBooth::stake: INSUFFICIENT_FUNDS\\\"\\n        );\\n\\n        // Redeem the equivalent amount of ERC20s.\\n        _tickets.redeem(_holder, _amount);\\n\\n        // Add the staked amount from the holder's balance.\\n        stakedBalanceOf[_holder][_projectId] =\\n            stakedBalanceOf[_holder][_projectId] +\\n            _amount;\\n\\n        // Add the staked amount from the project's total supply.\\n        stakedTotalSupplyOf[_projectId] =\\n            stakedTotalSupplyOf[_projectId] +\\n            _amount;\\n\\n        emit Stake(_holder, _projectId, _amount, msg.sender);\\n    }\\n\\n    /**\\n      @notice \\n      Unstakes internal tickets by creating and distributing ERC20 tickets.\\n\\n      @dev\\n      Only a ticket holder or an operator can unstake its tickets.\\n\\n      @param _holder The owner of the tickets to unstake.\\n      @param _projectId The ID of the project whos tickets are being unstaked.\\n      @param _amount The amount of tickets to unstake.\\n     */\\n    function unstake(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    )\\n        external\\n        override\\n        requirePermissionAllowingWildcardDomain(\\n            _holder,\\n            _projectId,\\n            Operations.Unstake\\n        )\\n    {\\n        // Get a reference to the project's ERC20 tickets.\\n        ITickets _tickets = ticketsOf[_projectId];\\n\\n        // Tickets must have been issued.\\n        require(\\n            _tickets != ITickets(address(0)),\\n            \\\"TicketBooth::unstake: NOT_FOUND\\\"\\n        );\\n\\n        // Get a reference to the amount of unstaked tickets.\\n        uint256 _unlockedStakedTickets = stakedBalanceOf[_holder][_projectId] -\\n            lockedBalanceOf[_holder][_projectId];\\n\\n        // There must be enough unlocked staked tickets to unstake.\\n        require(\\n            _unlockedStakedTickets >= _amount,\\n            \\\"TicketBooth::unstake: INSUFFICIENT_FUNDS\\\"\\n        );\\n\\n        // Subtract the unstaked amount from the holder's balance.\\n        stakedBalanceOf[_holder][_projectId] =\\n            stakedBalanceOf[_holder][_projectId] -\\n            _amount;\\n\\n        // Subtract the unstaked amount from the project's total supply.\\n        stakedTotalSupplyOf[_projectId] =\\n            stakedTotalSupplyOf[_projectId] -\\n            _amount;\\n\\n        // Print the equivalent amount of ERC20s.\\n        _tickets.print(_holder, _amount);\\n\\n        emit Unstake(_holder, _projectId, _amount, msg.sender);\\n    }\\n\\n    /** \\n      @notice \\n      Lock a project's tickets, preventing them from being redeemed and from converting to ERC20s.\\n\\n      @dev\\n      Only a ticket holder or an operator can lock its tickets.\\n\\n      @param _holder The holder to lock tickets from.\\n      @param _projectId The ID of the project whos tickets are being locked.\\n      @param _amount The amount of tickets to lock.\\n    */\\n    function lock(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    )\\n        external\\n        override\\n        requirePermissionAllowingWildcardDomain(\\n            _holder,\\n            _projectId,\\n            Operations.Lock\\n        )\\n    {\\n        // Amount must be greater than 0.\\n        require(_amount > 0, \\\"TicketBooth::lock: NO_OP\\\");\\n\\n        // The holder must have enough tickets to lock.\\n        require(\\n            stakedBalanceOf[_holder][_projectId] -\\n                lockedBalanceOf[_holder][_projectId] >=\\n                _amount,\\n            \\\"TicketBooth::lock: INSUFFICIENT_FUNDS\\\"\\n        );\\n\\n        // Update the lock.\\n        lockedBalanceOf[_holder][_projectId] =\\n            lockedBalanceOf[_holder][_projectId] +\\n            _amount;\\n        lockedBalanceBy[msg.sender][_holder][_projectId] =\\n            lockedBalanceBy[msg.sender][_holder][_projectId] +\\n            _amount;\\n\\n        emit Lock(_holder, _projectId, _amount, msg.sender);\\n    }\\n\\n    /** \\n      @notice \\n      Unlock a project's tickets.\\n\\n      @dev\\n      The address that locked the tickets must be the address that unlocks the tickets.\\n\\n      @param _holder The holder to unlock tickets from.\\n      @param _projectId The ID of the project whos tickets are being unlocked.\\n      @param _amount The amount of tickets to unlock.\\n    */\\n    function unlock(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    ) external override {\\n        // Amount must be greater than 0.\\n        require(_amount > 0, \\\"TicketBooth::unlock: NO_OP\\\");\\n\\n        // There must be enough locked tickets to unlock.\\n        require(\\n            lockedBalanceBy[msg.sender][_holder][_projectId] >= _amount,\\n            \\\"TicketBooth::unlock: INSUFFICIENT_FUNDS\\\"\\n        );\\n\\n        // Update the lock.\\n        lockedBalanceOf[_holder][_projectId] =\\n            lockedBalanceOf[_holder][_projectId] -\\n            _amount;\\n        lockedBalanceBy[msg.sender][_holder][_projectId] =\\n            lockedBalanceBy[msg.sender][_holder][_projectId] -\\n            _amount;\\n\\n        emit Unlock(_holder, _projectId, _amount, msg.sender);\\n    }\\n\\n    /** \\n      @notice \\n      Allows a ticket holder to transfer its tickets to another account, without unstaking to ERC-20s.\\n\\n      @dev\\n      Only a ticket holder or an operator can transfer its tickets.\\n\\n      @param _holder The holder to transfer tickets from.\\n      @param _projectId The ID of the project whos tickets are being transfered.\\n      @param _amount The amount of tickets to transfer.\\n      @param _recipient The recipient of the tickets.\\n    */\\n    function transfer(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount,\\n        address _recipient\\n    )\\n        external\\n        override\\n        requirePermissionAllowingWildcardDomain(\\n            _holder,\\n            _projectId,\\n            Operations.Transfer\\n        )\\n    {\\n        // Can't transfer to the zero address.\\n        require(\\n            _recipient != address(0),\\n            \\\"TicketBooth::transfer: ZERO_ADDRESS\\\"\\n        );\\n\\n        // An address can't transfer to itself.\\n        require(_holder != _recipient, \\\"TicketBooth::transfer: IDENTITY\\\");\\n\\n        // There must be an amount to transfer.\\n        require(_amount > 0, \\\"TicketBooth::transfer: NO_OP\\\");\\n\\n        // Get a reference to the amount of unlocked staked tickets.\\n        uint256 _unlockedStakedTickets = stakedBalanceOf[_holder][_projectId] -\\n            lockedBalanceOf[_holder][_projectId];\\n\\n        // There must be enough unlocked staked tickets to transfer.\\n        require(\\n            _amount <= _unlockedStakedTickets,\\n            \\\"TicketBooth::transfer: INSUFFICIENT_FUNDS\\\"\\n        );\\n\\n        // Subtract from the holder.\\n        stakedBalanceOf[_holder][_projectId] =\\n            stakedBalanceOf[_holder][_projectId] -\\n            _amount;\\n\\n        // Add the tickets to the recipient.\\n        stakedBalanceOf[_recipient][_projectId] =\\n            stakedBalanceOf[_recipient][_projectId] +\\n            _amount;\\n\\n        emit Transfer(_holder, _projectId, _recipient, _amount, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITicketBooth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./IProjects.sol\\\";\\nimport \\\"./IOperatorStore.sol\\\";\\nimport \\\"./ITickets.sol\\\";\\n\\ninterface ITicketBooth {\\n    event Issue(\\n        uint256 indexed projectId,\\n        string name,\\n        string symbol,\\n        address caller\\n    );\\n    event Print(\\n        address indexed holder,\\n        uint256 indexed projectId,\\n        uint256 amount,\\n        bool convertedTickets,\\n        bool preferUnstakedTickets,\\n        address controller\\n    );\\n\\n    event Redeem(\\n        address indexed holder,\\n        uint256 indexed projectId,\\n        uint256 amount,\\n        uint256 stakedTickets,\\n        bool preferUnstaked,\\n        address controller\\n    );\\n\\n    event Stake(\\n        address indexed holder,\\n        uint256 indexed projectId,\\n        uint256 amount,\\n        address caller\\n    );\\n\\n    event Unstake(\\n        address indexed holder,\\n        uint256 indexed projectId,\\n        uint256 amount,\\n        address caller\\n    );\\n\\n    event Lock(\\n        address indexed holder,\\n        uint256 indexed projectId,\\n        uint256 amount,\\n        address caller\\n    );\\n\\n    event Unlock(\\n        address indexed holder,\\n        uint256 indexed projectId,\\n        uint256 amount,\\n        address caller\\n    );\\n\\n    event Transfer(\\n        address indexed holder,\\n        uint256 indexed projectId,\\n        address indexed recipient,\\n        uint256 amount,\\n        address caller\\n    );\\n\\n    function ticketsOf(uint256 _projectId) external view returns (ITickets);\\n\\n    function projects() external view returns (IProjects);\\n\\n    function lockedBalanceOf(address _holder, uint256 _projectId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function lockedBalanceBy(\\n        address _operator,\\n        address _holder,\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function stakedBalanceOf(address _holder, uint256 _projectId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function stakedTotalSupplyOf(uint256 _projectId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function totalSupplyOf(uint256 _projectId) external view returns (uint256);\\n\\n    function balanceOf(address _holder, uint256 _projectId)\\n        external\\n        view\\n        returns (uint256 _result);\\n\\n    function issue(\\n        uint256 _projectId,\\n        string calldata _name,\\n        string calldata _symbol\\n    ) external;\\n\\n    function print(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount,\\n        bool _preferUnstakedTickets\\n    ) external;\\n\\n    function redeem(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount,\\n        bool _preferUnstaked\\n    ) external;\\n\\n    function stake(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    ) external;\\n\\n    function unstake(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    ) external;\\n\\n    function lock(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    ) external;\\n\\n    function unlock(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount\\n    ) external;\\n\\n    function transfer(\\n        address _holder,\\n        uint256 _projectId,\\n        uint256 _amount,\\n        address _recipient\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Operatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./../interfaces/IOperatable.sol\\\";\\n\\nabstract contract Operatable is IOperatable {\\n    modifier requirePermission(\\n        address _account,\\n        uint256 _domain,\\n        uint256 _index\\n    ) {\\n        require(\\n            msg.sender == _account ||\\n                operatorStore.hasPermission(\\n                    msg.sender,\\n                    _account,\\n                    _domain,\\n                    _index\\n                ),\\n            \\\"Operatable: UNAUTHORIZED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier requirePermissionAllowingWildcardDomain(\\n        address _account,\\n        uint256 _domain,\\n        uint256 _index\\n    ) {\\n        require(\\n            msg.sender == _account ||\\n                operatorStore.hasPermission(\\n                    msg.sender,\\n                    _account,\\n                    _domain,\\n                    _index\\n                ) ||\\n                operatorStore.hasPermission(msg.sender, _account, 0, _index),\\n            \\\"Operatable: UNAUTHORIZED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier requirePermissionAcceptingAlternateAddress(\\n        address _account,\\n        uint256 _domain,\\n        uint256 _index,\\n        address _alternate\\n    ) {\\n        require(\\n            msg.sender == _account ||\\n                operatorStore.hasPermission(\\n                    msg.sender,\\n                    _account,\\n                    _domain,\\n                    _index\\n                ) ||\\n                msg.sender == _alternate,\\n            \\\"Operatable: UNAUTHORIZED\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice A contract storing operator assignments.\\n    IOperatorStore public immutable override operatorStore;\\n\\n    /** \\n      @param _operatorStore A contract storing operator assignments.\\n    */\\n    constructor(IOperatorStore _operatorStore) {\\n        operatorStore = _operatorStore;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/TerminalUtility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./../interfaces/ITerminalUtility.sol\\\";\\n\\nabstract contract TerminalUtility is ITerminalUtility {\\n    modifier onlyTerminal(uint256 _projectId) {\\n        require(\\n            address(terminalDirectory.terminalOf(_projectId)) == msg.sender,\\n            \\\"TerminalUtility: UNAUTHORIZED\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice The direct deposit terminals.\\n    ITerminalDirectory public immutable override terminalDirectory;\\n\\n    /** \\n      @param _terminalDirectory A directory of a project's current Juicebox terminal to receive payments in.\\n    */\\n    constructor(ITerminalDirectory _terminalDirectory) {\\n        terminalDirectory = _terminalDirectory;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Operations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nlibrary Operations {\\n    uint256 public constant Configure = 1;\\n    uint256 public constant PrintPreminedTickets = 2;\\n    uint256 public constant Redeem = 3;\\n    uint256 public constant Migrate = 4;\\n    uint256 public constant SetHandle = 5;\\n    uint256 public constant SetUri = 6;\\n    uint256 public constant ClaimHandle = 7;\\n    uint256 public constant RenewHandle = 8;\\n    uint256 public constant Issue = 9;\\n    uint256 public constant Stake = 10;\\n    uint256 public constant Unstake = 11;\\n    uint256 public constant Transfer = 12;\\n    uint256 public constant Lock = 13;\\n    uint256 public constant SetPayoutMods = 14;\\n    uint256 public constant SetTicketMods = 15;\\n    uint256 public constant SetTerminal = 16;\\n}\\n\"\r\n    },\r\n    \"contracts/Tickets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\nimport \\\"@paulrberg/contracts/token/erc20/Erc20Permit.sol\\\";\\n\\nimport \\\"./interfaces/ITickets.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Tickets is ERC20, ERC20Permit, Ownable, ITickets {\\n    constructor(string memory _name, string memory _symbol)\\n        ERC20(_name, _symbol)\\n        ERC20Permit(_name)\\n    {}\\n\\n    function print(address _account, uint256 _amount)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        return _mint(_account, _amount);\\n    }\\n\\n    function redeem(address _account, uint256 _amount)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        return _burn(_account, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProjects.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./ITerminal.sol\\\";\\nimport \\\"./IOperatorStore.sol\\\";\\n\\ninterface IProjects is IERC721 {\\n    event Create(\\n        uint256 indexed projectId,\\n        address indexed owner,\\n        bytes32 indexed handle,\\n        string uri,\\n        ITerminal terminal,\\n        address caller\\n    );\\n\\n    event SetHandle(\\n        uint256 indexed projectId,\\n        bytes32 indexed handle,\\n        address caller\\n    );\\n\\n    event SetUri(uint256 indexed projectId, string uri, address caller);\\n\\n    event TransferHandle(\\n        uint256 indexed projectId,\\n        address indexed to,\\n        bytes32 indexed handle,\\n        bytes32 newHandle,\\n        address caller\\n    );\\n\\n    event ClaimHandle(\\n        address indexed account,\\n        uint256 indexed projectId,\\n        bytes32 indexed handle,\\n        address caller\\n    );\\n\\n    event ChallengeHandle(\\n        bytes32 indexed handle,\\n        uint256 challengeExpiry,\\n        address caller\\n    );\\n\\n    event RenewHandle(\\n        bytes32 indexed handle,\\n        uint256 indexed projectId,\\n        address caller\\n    );\\n\\n    function count() external view returns (uint256);\\n\\n    function uriOf(uint256 _projectId) external view returns (string memory);\\n\\n    function handleOf(uint256 _projectId) external returns (bytes32 handle);\\n\\n    function projectFor(bytes32 _handle) external returns (uint256 projectId);\\n\\n    function transferAddressFor(bytes32 _handle)\\n        external\\n        returns (address receiver);\\n\\n    function challengeExpiryOf(bytes32 _handle) external returns (uint256);\\n\\n    function exists(uint256 _projectId) external view returns (bool);\\n\\n    function create(\\n        address _owner,\\n        bytes32 _handle,\\n        string calldata _uri,\\n        ITerminal _terminal\\n    ) external returns (uint256 id);\\n\\n    function setHandle(uint256 _projectId, bytes32 _handle) external;\\n\\n    function setUri(uint256 _projectId, string calldata _uri) external;\\n\\n    function transferHandle(\\n        uint256 _projectId,\\n        address _to,\\n        bytes32 _newHandle\\n    ) external returns (bytes32 _handle);\\n\\n    function claimHandle(\\n        bytes32 _handle,\\n        address _for,\\n        uint256 _projectId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOperatorStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\ninterface IOperatorStore {\\n    event SetOperator(\\n        address indexed operator,\\n        address indexed account,\\n        uint256 indexed domain,\\n        uint256[] permissionIndexes,\\n        uint256 packed\\n    );\\n\\n    function permissionsOf(\\n        address _operator,\\n        address _account,\\n        uint256 _domain\\n    ) external view returns (uint256);\\n\\n    function hasPermission(\\n        address _operator,\\n        address _account,\\n        uint256 _domain,\\n        uint256 _permissionIndex\\n    ) external view returns (bool);\\n\\n    function hasPermissions(\\n        address _operator,\\n        address _account,\\n        uint256 _domain,\\n        uint256[] calldata _permissionIndexes\\n    ) external view returns (bool);\\n\\n    function setOperator(\\n        address _operator,\\n        uint256 _domain,\\n        uint256[] calldata _permissionIndexes\\n    ) external;\\n\\n    function setOperators(\\n        address[] calldata _operators,\\n        uint256[] calldata _domains,\\n        uint256[][] calldata _permissionIndexes\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITickets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ITickets is IERC20 {\\n    function print(address _account, uint256 _amount) external;\\n\\n    function redeem(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITerminal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./ITerminalDirectory.sol\\\";\\n\\ninterface ITerminal {\\n    event Pay(\\n        uint256 indexed fundingCycleId,\\n        uint256 indexed projectId,\\n        address indexed beneficiary,\\n        uint256 amount,\\n        string note,\\n        address caller\\n    );\\n\\n    event AddToBalance(\\n        uint256 indexed projectId,\\n        uint256 value,\\n        address caller\\n    );\\n\\n    event AllowMigration(ITerminal allowed);\\n\\n    event Migrate(\\n        uint256 indexed projectId,\\n        ITerminal indexed to,\\n        uint256 _amount,\\n        address caller\\n    );\\n\\n    function terminalDirectory() external view returns (ITerminalDirectory);\\n\\n    function migrationIsAllowed(ITerminal _terminal)\\n        external\\n        view\\n        returns (bool);\\n\\n    function pay(\\n        uint256 _projectId,\\n        address _beneficiary,\\n        string calldata _memo,\\n        bool _preferUnstakedTickets\\n    ) external payable returns (uint256 fundingCycleId);\\n\\n    function addToBalance(uint256 _projectId) external payable;\\n\\n    function allowMigration(ITerminal _contract) external;\\n\\n    function migrate(uint256 _projectId, ITerminal _to) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITerminalDirectory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./IDirectPaymentAddress.sol\\\";\\nimport \\\"./ITerminal.sol\\\";\\nimport \\\"./IProjects.sol\\\";\\nimport \\\"./IProjects.sol\\\";\\n\\ninterface ITerminalDirectory {\\n    event DeployAddress(\\n        uint256 indexed projectId,\\n        string memo,\\n        address indexed caller\\n    );\\n\\n    event SetTerminal(\\n        uint256 indexed projectId,\\n        ITerminal indexed terminal,\\n        address caller\\n    );\\n\\n    event SetPayerPreferences(\\n        address indexed account,\\n        address beneficiary,\\n        bool preferUnstakedTickets\\n    );\\n\\n    function projects() external view returns (IProjects);\\n\\n    function terminalOf(uint256 _projectId) external view returns (ITerminal);\\n\\n    function beneficiaryOf(address _account) external returns (address);\\n\\n    function unstakedTicketsPreferenceOf(address _account)\\n        external\\n        returns (bool);\\n\\n    function addressesOf(uint256 _projectId)\\n        external\\n        view\\n        returns (IDirectPaymentAddress[] memory);\\n\\n    function deployAddress(uint256 _projectId, string calldata _memo) external;\\n\\n    function setTerminal(uint256 _projectId, ITerminal _terminal) external;\\n\\n    function setPayerPreferences(\\n        address _beneficiary,\\n        bool _preferUnstakedTickets\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDirectPaymentAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./ITerminalDirectory.sol\\\";\\nimport \\\"./ITerminal.sol\\\";\\n\\ninterface IDirectPaymentAddress {\\n    event Forward(\\n        address indexed payer,\\n        uint256 indexed projectId,\\n        address beneficiary,\\n        uint256 value,\\n        string memo,\\n        bool preferUnstakedTickets\\n    );\\n\\n    function terminalDirectory() external returns (ITerminalDirectory);\\n\\n    function projectId() external returns (uint256);\\n\\n    function memo() external returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOperatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./IOperatorStore.sol\\\";\\n\\ninterface IOperatable {\\n    function operatorStore() external view returns (IOperatorStore);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITerminalUtility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./ITerminalDirectory.sol\\\";\\n\\ninterface ITerminalUtility {\\n    function terminalDirectory() external view returns (ITerminalDirectory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./draft-IERC20Permit.sol\\\";\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        Counters.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n}\\n\"\r\n    },\r\n    \"@paulrberg/contracts/token/erc20/Erc20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\n// solhint-disable var-name-mixedcase\\npragma solidity >=0.8.4;\\n\\nimport \\\"./Erc20.sol\\\";\\nimport \\\"./IErc20Permit.sol\\\";\\n\\n/// @notice Emitted when the recovered owner does not match the actual owner.\\nerror Erc20Permit__InvalidSignature(uint8 v, bytes32 r, bytes32 s);\\n\\n/// @notice Emitted when the owner is the zero address.\\nerror Erc20Permit__OwnerZeroAddress();\\n\\n/// @notice Emitted when the permit expired.\\nerror Erc20Permit__PermitExpired(uint256 deadline);\\n\\n/// @notice Emitted when the recovered owner is the zero address.\\nerror Erc20Permit__RecoveredOwnerZeroAddress();\\n\\n/// @notice Emitted when the spender is the zero address.\\nerror Erc20Permit__SpenderZeroAddress();\\n\\n/// @title Erc20Permit\\n/// @author Paul Razvan Berg\\ncontract Erc20Permit is\\n    IErc20Permit, // one dependency\\n    Erc20 // one dependency\\n{\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IErc20Permit\\n    bytes32 public immutable override DOMAIN_SEPARATOR;\\n\\n    /// @inheritdoc IErc20Permit\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        0xfc77c2b9d30fe91687fd39abb7d16fcdfe1472d065740051ab8b13e4bf4a617f;\\n\\n    /// @inheritdoc IErc20Permit\\n    mapping(address => uint256) public override nonces;\\n\\n    /// @inheritdoc IErc20Permit\\n    string public constant override version = \\\"1\\\";\\n\\n    /// CONSTRUCTOR ///\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) Erc20(_name, _symbol, _decimals) {\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IErc20Permit\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        if (owner == address(0)) {\\n            revert Erc20Permit__OwnerZeroAddress();\\n        }\\n        if (spender == address(0)) {\\n            revert Erc20Permit__SpenderZeroAddress();\\n        }\\n        if (deadline < block.timestamp) {\\n            revert Erc20Permit__PermitExpired(deadline);\\n        }\\n\\n        // It's safe to use the \\\"+\\\" operator here because the nonce cannot realistically overflow, ever.\\n        bytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\n        address recoveredOwner = ecrecover(digest, v, r, s);\\n\\n        if (recoveredOwner == address(0)) {\\n            revert Erc20Permit__RecoveredOwnerZeroAddress();\\n        }\\n        if (recoveredOwner != owner) {\\n            revert Erc20Permit__InvalidSignature(v, r, s);\\n        }\\n\\n        approveInternal(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return recover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return recover(hash, r, vs);\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(\\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ECDSA: invalid signature 's' value\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@paulrberg/contracts/token/erc20/Erc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IErc20.sol\\\";\\n\\n/// @notice Emitted when the owner is the zero address.\\nerror Erc20__ApproveOwnerZeroAddress();\\n\\n/// @notice Emitted when the spender is the zero address.\\nerror Erc20__ApproveSpenderZeroAddress();\\n\\n/// @notice Emitted when burning more tokens than are in the account.\\nerror Erc20__BurnUnderflow(uint256 accountBalance, uint256 burnAmount);\\n\\n/// @notice Emitted when the holder is the zero address.\\nerror Erc20__BurnZeroAddress();\\n\\n/// @notice Emitted when the sender did not give the caller a sufficient allowance.\\nerror Erc20__InsufficientAllowance(uint256 allowance, uint256 amount);\\n\\n/// @notice Emitted when the beneficiary is the zero address.\\nerror Erc20__MintZeroAddress();\\n\\n/// @notice Emitted when tranferring more tokens than there are in the account.\\nerror Erc20__TransferUnderflow(uint256 senderBalance, uint256 amount);\\n\\n/// @notice Emitted when the sender is the zero address.\\nerror Erc20__TransferSenderZeroAddress();\\n\\n/// @notice Emitted when the recipient is the zero address.\\nerror Erc20__TransferRecipientZeroAddress();\\n\\n/// @title Erc20\\n/// @author Paul Razvan Berg\\ncontract Erc20 is IErc20 {\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IErc20\\n    string public override name;\\n\\n    /// @inheritdoc IErc20\\n    string public override symbol;\\n\\n    /// @inheritdoc IErc20\\n    uint8 public immutable override decimals;\\n\\n    /// @inheritdoc IErc20\\n    uint256 public override totalSupply;\\n\\n    /// @inheritdoc IErc20\\n    mapping(address => uint256) public override balanceOf;\\n\\n    /// @inheritdoc IErc20\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    /// CONSTRUCTOR ///\\n\\n    /// @notice All three of these values are immutable: they can only be set once during construction.\\n    /// @param _name Erc20 name of this token.\\n    /// @param _symbol Erc20 symbol of this token.\\n    /// @param _decimals Erc20 decimal precision of this token.\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IErc20\\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\\n        approveInternal(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IErc20\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual override returns (bool) {\\n        uint256 newAllowance = allowance[msg.sender][spender] - subtractedValue;\\n        approveInternal(msg.sender, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IErc20\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual override returns (bool) {\\n        uint256 newAllowance = allowance[msg.sender][spender] + addedValue;\\n        approveInternal(msg.sender, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IErc20\\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\\n        transferInternal(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IErc20\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external virtual override returns (bool) {\\n        transferInternal(sender, recipient, amount);\\n\\n        uint256 currentAllowance = allowance[sender][msg.sender];\\n        if (currentAllowance < amount) {\\n            revert Erc20__InsufficientAllowance(currentAllowance, amount);\\n        }\\n        approveInternal(sender, msg.sender, currentAllowance);\\n        return true;\\n    }\\n\\n    /// INTERNAL NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n    ///\\n    /// @dev Emits an {Approval} event.\\n    ///\\n    /// This is internal function is equivalent to `approve`, and can be used to e.g. set automatic\\n    /// allowances for certain subsystems, etc.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `owner` cannot be the zero address.\\n    /// - `spender` cannot be the zero address.\\n    function approveInternal(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        if (owner == address(0)) {\\n            revert Erc20__ApproveOwnerZeroAddress();\\n        }\\n        if (spender == address(0)) {\\n            revert Erc20__ApproveSpenderZeroAddress();\\n        }\\n\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /// @notice Destroys `burnAmount` tokens from `holder`, reducing the token supply.\\n    ///\\n    /// @dev Emits a {Transfer} event.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `holder` must have at least `amount` tokens.\\n    function burnInternal(address holder, uint256 burnAmount) internal {\\n        if (holder == address(0)) {\\n            revert Erc20__BurnZeroAddress();\\n        }\\n\\n        uint256 accountBalance = balanceOf[holder];\\n        if (accountBalance < burnAmount) {\\n            revert Erc20__BurnUnderflow(accountBalance, burnAmount);\\n        }\\n\\n        // Burn the tokens.\\n        unchecked {\\n            balanceOf[holder] = accountBalance - burnAmount;\\n        }\\n\\n        // Reduce the total supply.\\n        totalSupply -= burnAmount;\\n\\n        emit Transfer(holder, address(0), burnAmount);\\n    }\\n\\n    /// @notice Prints new tokens into existence and assigns them to `beneficiary`, increasing the\\n    /// total supply.\\n    ///\\n    /// @dev Emits a {Transfer} event.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - The beneficiary's balance and the total supply cannot overflow.\\n    function mintInternal(address beneficiary, uint256 mintAmount) internal {\\n        if (beneficiary == address(0)) {\\n            revert Erc20__MintZeroAddress();\\n        }\\n\\n        /// Mint the new tokens.\\n        balanceOf[beneficiary] += mintAmount;\\n\\n        /// Increase the total supply.\\n        totalSupply += mintAmount;\\n\\n        emit Transfer(address(0), beneficiary, mintAmount);\\n    }\\n\\n    /// @notice Moves `amount` tokens from `sender` to `recipient`.\\n    ///\\n    /// @dev This is internal function is equivalent to {transfer}, and can be used to e.g. implement\\n    /// automatic token fees, slashing mechanisms, etc.\\n    ///\\n    /// Emits a {Transfer} event.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `sender` cannot be the zero address.\\n    /// - `recipient` cannot be the zero address.\\n    /// - `sender` must have a balance of at least `amount`.\\n    function transferInternal(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        if (sender == address(0)) {\\n            revert Erc20__TransferSenderZeroAddress();\\n        }\\n        if (recipient == address(0)) {\\n            revert Erc20__TransferRecipientZeroAddress();\\n        }\\n\\n        uint256 senderBalance = balanceOf[sender];\\n        if (senderBalance < amount) {\\n            revert Erc20__TransferUnderflow(senderBalance, amount);\\n        }\\n        unchecked {\\n            balanceOf[sender] = senderBalance - amount;\\n        }\\n\\n        balanceOf[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@paulrberg/contracts/token/erc20/IErc20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\n// solhint-disable func-name-mixedcase\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IErc20.sol\\\";\\n\\n/// @title IErc20Permit\\n/// @author Paul Razvan Berg\\n/// @notice Extension of Erc20 that allows token holders to use their tokens without sending any\\n/// transactions by setting the allowance with a signature using the `permit` method, and then spend\\n/// them via `transferFrom`.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2612.\\ninterface IErc20Permit is IErc20 {\\n    /// NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over `owner`'s tokens, assuming the latter's\\n    /// signed approval.\\n    ///\\n    /// @dev Emits an {Approval} event.\\n    ///\\n    /// IMPORTANT: The same issues Erc20 `approve` has related to transaction\\n    /// ordering also apply here.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `owner` cannot be the zero address.\\n    /// - `spender` cannot be the zero address.\\n    /// - `deadline` must be a timestamp in the future.\\n    /// - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the Eip712-formatted\\n    /// function arguments.\\n    /// - The signature must use `owner`'s current nonce.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// CONSTANT FUNCTIONS ///\\n\\n    /// @notice The Eip712 domain's keccak256 hash.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice Provides replay protection.\\n    function nonces(address account) external view returns (uint256);\\n\\n    /// @notice keccak256(\\\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\\\");\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    /// @notice Eip712 version of this implementation.\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@paulrberg/contracts/token/erc20/IErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\n/// @title IErc20\\n/// @author Paul Razvan Berg\\n/// @notice Implementation for the Erc20 standard.\\n///\\n/// We have followed general OpenZeppelin guidelines: functions revert instead of returning\\n/// `false` on failure. This behavior is nonetheless conventional and does not conflict with\\n/// the with the expectations of Erc20 applications.\\n///\\n/// Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows\\n/// applications to reconstruct the allowance for all accounts just by listening to said\\n/// events. Other implementations of the Erc may not emit these events, as it isn't\\n/// required by the specification.\\n///\\n/// Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been\\n/// added to mitigate the well-known issues around setting allowances.\\n///\\n/// @dev Forked from OpenZeppelin\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/ERC20.sol\\ninterface IErc20 {\\n    /// EVENTS ///\\n\\n    /// @notice Emitted when an approval happens.\\n    /// @param owner The address of the owner of the tokens.\\n    /// @param spender The address of the spender.\\n    /// @param amount The maximum amount that can be spent.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @notice Emitted when a transfer happens.\\n    /// @param from The account sending the tokens.\\n    /// @param to The account receiving the tokens.\\n    /// @param amount The amount of tokens transferred.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// CONSTANT FUNCTIONS ///\\n\\n    /// @notice Returns the remaining number of tokens that `spender` will be allowed to spend\\n    /// on behalf of `owner` through {transferFrom}. This is zero by default.\\n    ///\\n    /// @dev This value changes when {approve} or {transferFrom} are called.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Returns the amount of tokens owned by `account`.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token, usually a shorter version of the name.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the amount of tokens in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// @dev Emits an {Approval} event.\\n    ///\\n    /// IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may\\n    /// use both the old and the new allowance by unfortunate transaction ordering. One possible solution\\n    /// to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired\\n    /// value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `spender` cannot be the zero address.\\n    ///\\n    /// @return a boolean value indicating whether the operation succeeded.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Atomically decreases the allowance granted to `spender` by the caller.\\n    ///\\n    /// @dev Emits an {Approval} event indicating the updated allowance.\\n    ///\\n    /// This is an alternative to {approve} that can be used as a mitigation for problems described\\n    /// in {Erc20Interface-approve}.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `spender` cannot be the zero address.\\n    /// - `spender` must have allowance for the caller of at least `subtractedValue`.\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /// @notice Atomically increases the allowance granted to `spender` by the caller.\\n    ///\\n    /// @dev Emits an {Approval} event indicating the updated allowance.\\n    ///\\n    /// This is an alternative to {approve} that can be used as a mitigation for the problems described above.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `spender` cannot be the zero address.\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `recipient`.\\n    ///\\n    /// @dev Emits a {Transfer} event.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `recipient` cannot be the zero address.\\n    /// - The caller must have a balance of at least `amount`.\\n    ///\\n    /// @return a boolean value indicating whether the operation succeeded.\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount`\\n    /// `is then deducted from the caller's allowance.\\n    ///\\n    /// @dev Emits a {Transfer} event and an {Approval} event indicating the updated allowance. This is\\n    /// not required by the Erc. See the note at the beginning of {Erc20}.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - `sender` and `recipient` cannot be the zero address.\\n    /// - `sender` must have a balance of at least `amount`.\\n    /// - The caller must have approed `sender` to spent at least `amount` tokens.\\n    ///\\n    /// @return a boolean value indicating whether the operation succeeded.\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ITicketBooth\",\"name\":\"_ticketBooth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenRepresentationProxy","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000ee2ebccb7cdb34a8a822b589f9e8427c24351bfc0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000094a42582050726f7879000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084a425850524f5859000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}