{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Airdrop/OngoingAirdrop.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"openzeppelin-solidity-2.3.0/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/Owned.sol\\\";\\nimport \\\"openzeppelin-solidity-2.3.0/contracts/cryptography/MerkleProof.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/Pausable.sol\\\";\\nimport \\\"../interfaces/IEscrowThales.sol\\\";\\n\\n/**\\n * Contract which implements a merkle airdrop for a given token\\n * Based on an account balance snapshot stored in a merkle tree\\n */\\ncontract OngoingAirdrop is Owned, Pausable {\\n    IERC20 public token;\\n\\n    IEscrowThales public iEscrowThales;\\n\\n    bytes32 public root; // merkle tree root\\n\\n    uint256 public startTime;\\n\\n    address public admin;\\n\\n    uint256 public period;\\n\\n    mapping(uint256 => mapping(uint256 => uint256)) public _claimed;\\n\\n    constructor(\\n        address _owner,\\n        IERC20 _token,\\n        bytes32 _root\\n    ) public Owned(_owner) Pausable() {\\n        token = _token;\\n        root = _root;\\n        startTime = block.timestamp;\\n        period = 1;\\n    }\\n\\n    // Set root of merkle tree\\n    function setRoot(bytes32 _root) public onlyOwner {\\n        require(address(iEscrowThales) != address(0), \\\"Set Escrow Thales address\\\");\\n        root = _root;\\n        startTime = block.timestamp; //reset time every period\\n        emit NewRoot(_root, block.timestamp, period);\\n        period = period + 1;\\n    }\\n\\n    // Set EscrowThales contract address\\n    function setEscrow(address _escrowThalesContract) public onlyOwner {\\n        if (address(iEscrowThales) != address(0)) {\\n            token.approve(address(iEscrowThales), 0);\\n        }\\n        iEscrowThales = IEscrowThales(_escrowThalesContract);\\n        token.approve(_escrowThalesContract, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n    }\\n\\n    // Check if a given reward has already been claimed\\n    function claimed(uint256 index) public view returns (uint256 claimedBlock, uint256 claimedMask) {\\n        claimedBlock = _claimed[period][index / 256];\\n        claimedMask = (uint256(1) << uint256(index % 256));\\n        require((claimedBlock & claimedMask) == 0, \\\"Tokens have already been claimed\\\");\\n    }\\n\\n    // helper for the dapp\\n    function canClaim(uint256 index) external view returns (bool) {\\n        uint256 claimedBlock = _claimed[period][index / 256];\\n        uint256 claimedMask = (uint256(1) << uint256(index % 256));\\n        return ((claimedBlock & claimedMask) == 0);\\n    }\\n\\n    // Get airdrop tokens assigned to address\\n    // Requires sending merkle proof to the function\\n    function claim(\\n        uint256 index,\\n        uint256 amount,\\n        bytes32[] memory merkleProof\\n    ) public notPaused {\\n        // Make sure the tokens have not already been redeemed\\n        (uint256 claimedBlock, uint256 claimedMask) = claimed(index);\\n        _claimed[period][index / 256] = claimedBlock | claimedMask;\\n\\n        // Compute the merkle leaf from index, recipient and amount\\n        bytes32 leaf = keccak256(abi.encodePacked(index, msg.sender, amount));\\n        // verify the proof is valid\\n        require(MerkleProof.verify(merkleProof, root, leaf), \\\"Proof is not valid\\\");\\n\\n        // Send to EscrowThales contract\\n        iEscrowThales.addToEscrow(msg.sender, amount);\\n\\n        emit Claim(msg.sender, amount, block.timestamp);\\n    }\\n\\n    function _selfDestruct(address payable beneficiary) external onlyOwner {\\n        token.transfer(beneficiary, token.balanceOf(address(this)));\\n        selfdestruct(beneficiary);\\n    }\\n\\n    event Claim(address claimer, uint256 amount, uint timestamp);\\n    event NewRoot(bytes32 root, uint timestamp, uint256 period);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity-2.3.0/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/Owned.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity-2.3.0/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash < proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/Pausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Inheritance\\nimport \\\"./Owned.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/contracts/pausable\\ncontract Pausable is Owned {\\n    uint public lastPauseTime;\\n    bool public paused;\\n\\n    constructor() internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\\n    }\\n\\n    /**\\n     * @notice Change the paused state of the contract\\n     * @dev Only the contract owner may call this.\\n     */\\n    function setPaused(bool _paused) external onlyOwner {\\n        // Ensure we're actually changing the state before we do anything\\n        if (_paused == paused) {\\n            return;\\n        }\\n\\n        // Set our paused state.\\n        paused = _paused;\\n\\n        // If applicable, set the last pause time.\\n        if (paused) {\\n            lastPauseTime = now;\\n        }\\n\\n        // Let everyone know that our pause state has changed.\\n        emit PauseChanged(paused);\\n    }\\n\\n    event PauseChanged(bool isPaused);\\n\\n    modifier notPaused {\\n        require(!paused, \\\"This action cannot be performed while the contract is paused\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEscrowThales.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\ninterface IEscrowThales {\\n    /* ========== VIEWS / VARIABLES ========== */\\n    function getStakerPeriod(address account, uint index) external view returns (uint);\\n\\n    function getStakerAmounts(address account, uint index) external view returns (uint);\\n\\n    function totalAccountEscrowedAmount(address account) external view returns (uint);\\n\\n    function getStakedEscrowedBalanceForRewards(address account) external view returns (uint);\\n\\n    function totalEscrowedRewards() external view returns (uint);\\n\\n    function totalEscrowBalanceNotIncludedInStaking() external view returns (uint);\\n\\n    function currentVestingPeriod() external view returns (uint);\\n\\n    function updateCurrentPeriod() external returns (bool);\\n\\n    function claimable(address account) external view returns (uint);\\n\\n    function addToEscrow(address account, uint amount) external;\\n\\n    function vest(uint amount) external returns (bool);\\n\\n    function addTotalEscrowBalanceNotIncludedInStaking(uint amount) external;\\n\\n    function subtractTotalEscrowBalanceNotIncludedInStaking(uint amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"NewRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"_selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedMask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"iEscrowThales\",\"outputs\":[{\"internalType\":\"contract IEscrowThales\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_escrowThalesContract\",\"type\":\"address\"}],\"name\":\"setEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OngoingAirdrop","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004d03ef005e5f559fc9294a8e1cebba09284b1f8200000000000000000000000003e173ad8d1581a4802d3b532ace27a62c5b81dcabfc88f60dcac2cc17d518ff428a7033306dcd4633cff8fd688edc4eab042902","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}