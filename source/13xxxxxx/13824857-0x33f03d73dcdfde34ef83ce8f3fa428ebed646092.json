{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BlockClock/BlockClockRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// S U N M O N T U E W E D T H U F R I S A T\\n// J A N F E B M A R A P R M A Y J U N J U L\\n// A U G S E P O C T N O V D E C 0 0 1 0 0 2\\n// 0 0 3 0 0 4 0 0 5 0 0 6 0 0 7 0 0 8 0 0 9\\n// 0 1 0 0 1 1 0 1 2 0 1 3 0 1 4 0 1 5 0 1 6\\n// 0 1 7 0 1 8 0 1 9 0 2 0 0 2 1 0 2 2 0 2 3\\n// 0 2 | --------- | 0 2 7 0 2 8 0 2 9 0 3 0\\n// 0 3 | B L O C K | 0 0 2 0 0 3 0 0 4 0 0 5\\n// 0 0 | ----------------- | 1 0 0 1 1 0 0 0\\n// 0 0 1 0 0 2 | C L O C K | 0 5 0 0 6 0 0 7\\n// 0 0 8 0 0 9 ----------- | 1 2 0 1 3 0 1 4\\n// 0 1 5 0 1 6 0 1 7 0 1 8 0 1 9 0 2 0 0 2 1\\n// | --- | 2 3 0 2 4 0 2 5 0 2 6 0 2 7 0 2 8\\n// | B Y   --------------------- | 3 4 0 3 5\\n// | --- | @ S A M M Y B A U C H | 4 1 0 4 2\\n// 0 4 3 ----------------------- | 4 8 0 4 9\\n// 0 5 0 0 5 1 0 5 2 0 5 3 0 5 4 0 5 5 0 5 6\\n// 0 5 7 0 5 8 0 5 9 0 0 0 0 0 1 0 0 2 0 0 3\\n// 0 0 4 0 0 5 0 0 6 0 0 7 0 0 8 0 0 9 0 1 0\\n// 0 1 1 0 1 2 0 1 3 0 1 4 0 1 5 0 1 6 0 1 7\\n// 0 1 8 0 1 9 0 2 0 0 2 1 0 2 2 0 2 3 0 2 4\\n// 0 2 5 0 2 6 0 2 7 0 2 8 0 2 9 0 3 0 0 3 1\\n// 0 3 2 0 3 3 0 3 4 0 3 5 0 3 6 0 3 7 0 3 8\\n// 0 3 9 0 4 0 0 4 1 0 4 2 0 4 3 0 4 4 0 4 5\\n// 0 4 6 0 4 7 0 4 8 0 4 9 0 5 0 0 5 1 0 5 2\\n// 0 5 3 0 5 4 0 5 5 0 5 6 0 5 7 0 5 8 0 5 9\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../Libraries/Base64.sol\\\";\\nimport \\\"../Libraries/DateTime.sol\\\";\\nimport \\\"../Libraries/DynamicBuffer.sol\\\";\\nimport \\\"../Libraries/EssentialStrings.sol\\\";\\n\\ninterface ICorruptionsFont {\\n    function font() external view returns (string memory);\\n}\\n\\ncontract BlockClockRenderer is Ownable {\\n    using DynamicBuffer for bytes;\\n    using EssentialStrings for uint256;\\n    using EssentialStrings for uint24;\\n    using EssentialStrings for uint8;\\n\\n    ICorruptionsFont private font;\\n\\n    constructor() {}\\n\\n    function setFont(address fontAddress) external onlyOwner {\\n        font = ICorruptionsFont(fontAddress);\\n    }\\n\\n    /* solhint-disable quotes */\\n\\n    function svgBase64Data(\\n        int8 hourOffset,\\n        uint24 hexCode,\\n        uint256 timestamp\\n    ) public view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\\"data:image/svg+xml;base64,\\\", Base64.encode(svgRaw(hourOffset, hexCode, timestamp)))\\n            );\\n    }\\n\\n    function svgRaw(\\n        int8 hourOffset,\\n        uint24 hexCode,\\n        uint256 timestamp\\n    ) public view returns (bytes memory) {\\n        uint256 _timestamp = timestamp == 0\\n            ? uint256(int256(block.timestamp) + int256(hourOffset) * 1 hours)\\n            : timestamp;\\n\\n        bytes memory svg = DynamicBuffer.allocate(2**16); // 64KB - reduce?\\n\\n        (, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) = BokkyPooBahsDateTimeLibrary\\n            .timestampToDateTime(_timestamp);\\n\\n        bytes memory elementClasses = abi.encodePacked(\\n            dotwClass(_timestamp),\\n            monthClass(month),\\n            dayClass(day),\\n            hourClass(hour),\\n            minuteClass(minute),\\n            secondClass(second)\\n        );\\n\\n        svg.appendSafe(\\n            abi.encodePacked(\\n                \\\"<svg viewBox='0 0 1024 1024' width='1024' height='1024' xmlns='http://www.w3.org/2000/svg'>\\\",\\n                '<style> @font-face { font-family: CorruptionsFont; src: url(\\\"',\\n                font.font(),\\n                '\\\") format(\\\"opentype\\\"); } ',\\n                \\\".wk { letter-spacing: 24px; } .base{fill:#504f54;font-family:CorruptionsFont;font-size: 36px;} \\\",\\n                elementClasses,\\n                \\\"{fill: \\\",\\n                hexCode.toHtmlHexString(),\\n                \\\";} </style> \\\",\\n                '<rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#181A18\\\" /> '\\n            )\\n        );\\n\\n        for (uint256 i = 1; i < 27; i++) {\\n            svg.appendSafe(renderRow(i));\\n        }\\n\\n        svg.appendSafe(\\\" </svg>\\\");\\n\\n        return svg;\\n    }\\n\\n    function renderRow(uint256 rowNum) internal view returns (bytes memory) {\\n        bytes memory row = DynamicBuffer.allocate(2**16); // 64KB\\n        row.appendSafe(abi.encodePacked('<text x=\\\"0\\\" y=\\\"', ((rowNum + 1) * 36).toString(), '\\\" class=\\\"base\\\"> '));\\n        string[7] memory rowLabels = rowElements(rowNum - 1);\\n\\n        for (uint256 i = 0; i < 7; i++) {\\n            row.appendSafe(\\n                abi.encodePacked(\\n                    '<tspan class=\\\"',\\n                    abi.encodePacked(\\\"wk el\\\", rowNum.toString(), i.toString()),\\n                    '\\\"  x=\\\"',\\n                    (46 + (138 * i)).toString(),\\n                    '\\\">',\\n                    rowLabels[i],\\n                    \\\"</tspan> \\\"\\n                )\\n            );\\n        }\\n\\n        row.appendSafe(\\\"</text> \\\");\\n\\n        return row;\\n    }\\n\\n    function rowElements(uint256 rowIndex) internal view returns (string[7] memory row) {\\n        if (rowIndex > 2) {\\n            return paddedNumberRow(rowIndex);\\n        }\\n\\n        if (rowIndex == 0) return [\\\"SUN\\\", \\\"MON\\\", \\\"TUE\\\", \\\"WED\\\", \\\"THU\\\", \\\"FRI\\\", \\\"SAT\\\"];\\n        if (rowIndex == 1) return [\\\"JAN\\\", \\\"FEB\\\", \\\"MAR\\\", \\\"APR\\\", \\\"MAY\\\", \\\"JUN\\\", \\\"JUL\\\"];\\n        if (rowIndex == 2) return [\\\"AUG\\\", \\\"SEP\\\", \\\"OCT\\\", \\\"NOV\\\", \\\"DEC\\\", \\\"001\\\", \\\"002\\\"];\\n    }\\n\\n    function paddedNumberRow(uint256 rowIndex) internal view returns (string[7] memory row) {\\n        int256 maxUnit = 59;\\n\\n        for (int256 index = 0; index < 7; index++) {\\n            int256 start = int256(rowIndex < 9 ? (rowIndex * 7) - 18 : (rowIndex - 8) * 7 - 6);\\n\\n            if (rowIndex == 7) {\\n                maxUnit = 31;\\n\\n                if (index == 1) {\\n                    row[uint256(index)] = \\\"012\\\";\\n                    continue;\\n                }\\n\\n                if (index > 1) {\\n                    start = -1;\\n                }\\n            }\\n\\n            if (rowIndex == 8) {\\n                maxUnit = 11;\\n                start = 6;\\n            }\\n\\n            int256 unit = start + index;\\n\\n            if (unit > maxUnit) {\\n                unit = unit - maxUnit - 1;\\n            }\\n\\n            row[uint256(index)] = uint256(unit).toPaddedNumberString();\\n        }\\n    }\\n\\n    function dotwClass(uint256 timestamp) internal view returns (bytes memory) {\\n        uint256 dow = BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp);\\n        if (dow == 7) return bytes(\\\".el10,\\\");\\n\\n        return abi.encodePacked(\\\".el1\\\", dow.toString(), \\\",\\\");\\n    }\\n\\n    function monthClass(uint256 month) internal view returns (bytes memory) {\\n        if (month > 7) {\\n            return abi.encodePacked(\\\".el3\\\", (month - 8).toString());\\n        }\\n\\n        return abi.encodePacked(\\\".el2\\\", (month - 1).toString());\\n    }\\n\\n    function dayClass(uint256 day) internal view returns (bytes memory) {\\n        if (day < 3) {\\n            return abi.encodePacked(\\\",.el3\\\", (day + 4).toString());\\n        }\\n\\n        uint256 dayIdx = (day - 3) % 7;\\n        uint256 dayRow = (day - 3) / 7 + 4;\\n\\n        return abi.encodePacked(\\\",.el\\\", dayRow.toString(), dayIdx.toString());\\n    }\\n\\n    function hourClass(uint256 hour) internal view returns (bytes memory) {\\n        if (hour < 6) {\\n            return abi.encodePacked(\\\",.el8\\\", (hour + 1).toString());\\n        }\\n\\n        uint256 meridianHour = hour % 12;\\n\\n        if (meridianHour < 6) {\\n            return abi.encodePacked(\\\",.el8\\\", (meridianHour + 1).toString());\\n        }\\n\\n        return abi.encodePacked(\\\",.el9\\\", (meridianHour - 6).toString());\\n    }\\n\\n    function minuteClass(uint256 minute) internal view returns (bytes memory) {\\n        if (minute == 0) {\\n            return bytes(\\\",.el96\\\");\\n        }\\n\\n        uint256 minuteIdx = (minute - 1) % 7;\\n        uint256 minuteRow = (minute - 1) / 7 + 10;\\n\\n        return abi.encodePacked(\\\",.el\\\", minuteRow.toString(), minuteIdx.toString());\\n    }\\n\\n    function secondClass(uint256 second) internal view returns (bytes memory) {\\n        if (second < 4) {\\n            return abi.encodePacked(\\\",.el18\\\", (second + 3).toString());\\n        }\\n\\n        uint256 secondIdx = (second - 4) % 7;\\n        uint256 secondRow = (second - 4) / 7 + 19;\\n\\n        return abi.encodePacked(\\\",.el\\\", secondRow.toString(), secondIdx.toString());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Libraries/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.6 <0.9.0;\\n\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Libraries/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.01\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary BokkyPooBahsDateTimeLibrary {\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    uint256 constant DOW_MON = 1;\\n    uint256 constant DOW_TUE = 2;\\n    uint256 constant DOW_WED = 3;\\n    uint256 constant DOW_THU = 4;\\n    uint256 constant DOW_FRI = 5;\\n    uint256 constant DOW_SAT = 6;\\n    uint256 constant DOW_SUN = 7;\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 _days) {\\n        require(year >= 1970);\\n        int256 _year = int256(year);\\n        int256 _month = int256(month);\\n        int256 _day = int256(day);\\n\\n        int256 __days = _day -\\n            32075 +\\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n            4 +\\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n            12 -\\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n            4 -\\n            OFFSET19700101;\\n\\n        _days = uint256(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    function timestampFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n    }\\n\\n    function timestampFromDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            hour *\\n            SECONDS_PER_HOUR +\\n            minute *\\n            SECONDS_PER_MINUTE +\\n            second;\\n    }\\n\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day,\\n            uint256 hour,\\n            uint256 minute,\\n            uint256 second\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function isValidDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (bool valid) {\\n        if (year >= 1970 && month > 0 && month <= 12) {\\n            uint256 daysInMonth = _getDaysInMonth(year, month);\\n            if (day > 0 && day <= daysInMonth) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isValidDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (bool valid) {\\n        if (isValidDate(year, month, day)) {\\n            if (hour < 24 && minute < 60 && second < 60) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        leapYear = _isLeapYear(year);\\n    }\\n\\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n    }\\n\\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n    }\\n\\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n    }\\n\\n    function getDaysInMonth(uint256 timestamp) internal pure returns (uint256 daysInMonth) {\\n        (uint256 year, uint256 month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        daysInMonth = _getDaysInMonth(year, month);\\n    }\\n\\n    function _getDaysInMonth(uint256 year, uint256 month) internal pure returns (uint256 daysInMonth) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }\\n\\n    // 1 = Monday, 7 = Sunday\\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\\n        uint256 _days = timestamp / SECONDS_PER_DAY;\\n        dayOfWeek = ((_days + 3) % 7) + 1;\\n    }\\n\\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n    }\\n\\n    function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n    }\\n\\n    function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\\n        second = timestamp % SECONDS_PER_MINUTE;\\n    }\\n\\n    function addYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year += _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = ((month - 1) % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function subYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year -= _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\\n        year = yearMonth / 12;\\n        month = (yearMonth % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _years) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _years = toYear - fromYear;\\n    }\\n\\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _months) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint256 toYear, uint256 toMonth, ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n    }\\n\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _days) {\\n        require(fromTimestamp <= toTimestamp);\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n    }\\n\\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _hours) {\\n        require(fromTimestamp <= toTimestamp);\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n    }\\n\\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _minutes) {\\n        require(fromTimestamp <= toTimestamp);\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n    }\\n\\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _seconds) {\\n        require(fromTimestamp <= toTimestamp);\\n        _seconds = toTimestamp - fromTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Libraries/DynamicBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\\n\\npragma solidity >=0.8.0;\\n\\n/// @title DynamicBuffer\\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also\\n///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer\\n/// @notice This library is used to allocate a big amount of container memory\\n//          which will be subsequently filled without needing to reallocate\\n///         memory.\\n/// @dev First, allocate memory.\\n///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if\\n///      bounds checking is required.\\nlibrary DynamicBuffer {\\n    /// @notice Allocates container space for the DynamicBuffer\\n    /// @param capacity The intended max amount of bytes in the buffer\\n    /// @return buffer The memory location of the buffer\\n    /// @dev Allocates `capacity + 0x60` bytes of space\\n    ///      The buffer array starts at the first container data position,\\n    ///      (i.e. `buffer = container + 0x20`)\\n    function allocate(uint256 capacity) internal pure returns (bytes memory buffer) {\\n        assembly {\\n            // Get next-free memory address\\n            let container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                // Add 32 bytes safety space for 32B chunked copy\\n                let size := add(capacity, 0x60)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n\\n        return buffer;\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Does not perform out-of-bound checks (container capacity)\\n    ///      for efficiency.\\n    function appendUnchecked(bytes memory buffer, bytes memory data) internal pure {\\n        assembly {\\n            let length := mload(data)\\n            for {\\n                data := add(data, 0x20)\\n                let dataEnd := add(data, length)\\n                let copyTo := add(buffer, add(mload(buffer), 0x20))\\n            } lt(data, dataEnd) {\\n                data := add(data, 0x20)\\n                copyTo := add(copyTo, 0x20)\\n            } {\\n                // Copy 32B chunks from data to buffer.\\n                // This may read over data array boundaries and copy invalid\\n                // bytes, which doesn't matter in the end since we will\\n                // later set the correct buffer length, and have allocated an\\n                // additional word to avoid buffer overflow.\\n                mstore(copyTo, mload(data))\\n            }\\n\\n            // Update buffer length\\n            mstore(buffer, add(mload(buffer), length))\\n        }\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.\\n    function appendSafe(bytes memory buffer, bytes memory data) internal pure {\\n        uint256 capacity;\\n        uint256 length;\\n        assembly {\\n            capacity := sub(mload(sub(buffer, 0x20)), 0x40)\\n            length := mload(buffer)\\n        }\\n\\n        require(length + data.length <= capacity, \\\"DynamicBuffer: Appending out of bounds.\\\");\\n        appendUnchecked(buffer, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Libraries/EssentialStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary EssentialStrings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    function toHtmlHexString(uint256 value) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(7);\\n        buffer[0] = \\\"#\\\";\\n        for (uint256 i = 6; i > 0; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    function toPaddedNumberString(uint256 value) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(3);\\n\\n        if (value < 10) {\\n            buffer[0] = \\\"0\\\";\\n            buffer[1] = \\\"0\\\";\\n            buffer[2] = _HEX_SYMBOLS[value & 0xf];\\n            return string(buffer);\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits = 1;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        buffer[0] = \\\"0\\\";\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fontAddress\",\"type\":\"address\"}],\"name\":\"setFont\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"hourOffset\",\"type\":\"int8\"},{\"internalType\":\"uint24\",\"name\":\"hexCode\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"svgBase64Data\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"hourOffset\",\"type\":\"int8\"},{\"internalType\":\"uint24\",\"name\":\"hexCode\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"svgRaw\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BlockClockRenderer","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}