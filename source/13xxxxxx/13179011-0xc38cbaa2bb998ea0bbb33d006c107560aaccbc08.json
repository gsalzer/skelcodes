{"status":"1","message":"OK","result":[{"SourceCode":"{\"interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// Reflection\\ninterface IReflect {\\n    function tokenFromReflection(uint256 rAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getRate() external view returns (uint256);\\n}\\n\\n/// ChainLink ETH/USD oracle\\ninterface IChainLink {\\n    // chainlink ETH/USD oracle\\n    // answer|int256 :  216182781556 - 8 decimals\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\n/// USDT is not ERC-20 compliant, not returning true on transfers\\ninterface IUsdt {\\n    function transfer(address, uint256) external;\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\\n// Check ETH send to first presale\\n// Yes, there is a typo\\ninterface IPresale1 {\\n    function blanceOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check tokens bought in second presale\\n// There is bug in ETH deposits, we need handle it\\n// Also \\\"tokensBoughtOf\\\" calculation is broken, so we do all math\\ninterface IPresale2 {\\n    function ethDepositOf(address user) external view returns (uint256 amt);\\n\\n    function usdDepositOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check final sale tokens bought\\ninterface ISale {\\n    function tokensBoughtOf(address user) external view returns (uint256 amt);\\n}\\n\\ninterface IClaimSale {\\n    function addLock(\\n        address user,\\n        uint256 reflection,\\n        uint256 locktime\\n    ) external;\\n}\\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipChanged(address from, address to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipChanged(address(0), msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    // owner can give super-rights to someone\\n    function giveOwnership(address user) external onlyOwner {\\n        require(user != address(0), \\\"User renounceOwnership\\\");\\n        newOwner = user;\\n    }\\n\\n    // new owner need to accept\\n    function acceptOwnership() external {\\n        require(msg.sender == newOwner, \\\"Only NewOwner\\\");\\n        emit OwnershipChanged(owner, newOwner);\\n        owner = msg.sender;\\n        delete newOwner;\\n    }\\n}\\n\"},\"public-claim.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n// Rzucam 70mln worków w tłum w tłum .. kto łapie ten jara ... XD\\n\\n/**\\nApes Together Strong!\\n\\nAbout BigShortBets DeFi project:\\n\\nWe are creating a social\\u0026trading p2p platform that guarantees encrypted interaction between investors.\\nLogging in is possible via a cryptocurrency wallet (e.g. Metamask).\\nThe security level is one comparable to the Tor network.\\n\\nhttps://bigsb.io/ - Our Tool\\nhttps://bigshortbets.com - Project\\u0026Team info\\n\\nVideo explainer:\\nhttps://youtu.be/wbhUo5IvKdk\\n\\nZaorski, You Son of a bitch I’m in …\\n*/\\n\\npragma solidity 0.8.7;\\nimport \\\"./owned.sol\\\";\\nimport \\\"./reentryGuard.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract BigSBsaleClaim is Owned, Guarded {\\n    /**\\n        Claiming contract for BigSB public sale\\n        @param sale address of sale contract\\n        @param token address of BigSB token tontract\\n     */\\n    constructor(address sale, address token) {\\n        saleContract = sale;\\n        tokenContract = token;\\n        emergencyUnlock = block.timestamp + 720 days;\\n    }\\n\\n    /// timestamp moving 2 years of last lock made\\n    uint256 public emergencyUnlock;\\n\\n    address public immutable tokenContract;\\n    address public immutable saleContract;\\n\\n    struct Lock {\\n        uint256 reflection;\\n        uint256 locktime;\\n    }\\n\\n    /// Storage of user locks by address\\n    mapping(address =\\u003e Lock[]) public userLocks;\\n\\n    /**\\n        Add lock for user, can be called only by sale contract.\\n        Using contract reflection rate it can earn from transfer fees.\\n        @param user address of user\\n        @param reflection amount of reflection tokens\\n        @param locktime timestamp after which tokens can be released\\n     */\\n    function addLock(\\n        address user,\\n        uint256 reflection,\\n        uint256 locktime\\n    ) external {\\n        require(msg.sender == saleContract, \\\"Only sale contract\\\");\\n        userLocks[user].push(Lock(reflection, locktime));\\n        emergencyUnlock = block.timestamp + 720 days;\\n    }\\n\\n    /// claim all tokens than can be claimed\\n    function claim() external guarded {\\n        uint256 len = userLocks[msg.sender].length;\\n        require(len \\u003e 0, \\\"Nothing locked\\\");\\n        uint256 i;\\n        uint256 timeNow = block.timestamp;\\n        uint256 amt;\\n        for (i; i \\u003c len; i++) {\\n            Lock memory l = userLocks[msg.sender][i];\\n            if (timeNow \\u003e l.locktime \\u0026\\u0026 l.reflection \\u003e 0) {\\n                amt += IReflect(tokenContract).tokenFromReflection(\\n                    l.reflection\\n                );\\n                // tokens taken\\n                userLocks[msg.sender][i].reflection = 0;\\n            }\\n        }\\n        require(amt \\u003e 0, \\\"Nothing to claim\\\");\\n        IERC20(tokenContract).transfer(msg.sender, amt);\\n    }\\n\\n    /// return all user locks\\n    function getUserLocks(address user) external view returns (Lock[] memory) {\\n        return userLocks[user];\\n    }\\n\\n    /// return balance of user from all locks\\n    function balanceOf(address user) external view returns (uint256 amt) {\\n        uint256 len = userLocks[user].length;\\n        if (len == 0) return amt;\\n        uint256 i;\\n        for (i; i \\u003c len; i++) {\\n            amt += IReflect(tokenContract).tokenFromReflection(\\n                userLocks[user][i].reflection\\n            );\\n        }\\n        return amt;\\n    }\\n\\n    /// How many tokens user can claim now?\\n    function claimable(address user) external view returns (uint256 amt) {\\n        uint256 len = userLocks[user].length;\\n        if (len == 0) return amt;\\n        uint256 i;\\n        uint256 timeNow = block.timestamp;\\n        for (i; i \\u003c len; i++) {\\n            Lock memory l = userLocks[user][i];\\n            if (timeNow \\u003e l.locktime) {\\n                amt += IReflect(tokenContract).tokenFromReflection(\\n                    l.reflection\\n                );\\n            }\\n        }\\n        return amt;\\n    }\\n\\n    //\\n    // Emergency functions\\n    //\\n    /**\\n        Take ETH from contract\\n    */\\n    function withdrawEth() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    /**\\n        Take any ERC20 from contract\\n        BigSB is possible after 2 years form last lock event\\n    */\\n    function withdrawErc20(address token) external onlyOwner {\\n        if (token == tokenContract) {\\n            require(block.timestamp \\u003e emergencyUnlock, \\\"Too soon\\\");\\n        }\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(balance \\u003e 0, \\\"Nothing to withdraw\\\");\\n        // use broken IERC20\\n        IUsdt(token).transfer(owner, balance);\\n    }\\n}\\n//This is fine!\\n\"},\"reentryGuard.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Guarded {\\n    uint256 constant NOT_ENTERED = 1;\\n    uint256 constant ENTERED = 2;\\n    uint256 entryState = NOT_ENTERED;\\n\\n    modifier guarded() {\\n        require(entryState == NOT_ENTERED, \\\"Reentry\\\");\\n        entryState = ENTERED;\\n        _;\\n        entryState = NOT_ENTERED;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sale\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reflection\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"}],\"name\":\"addLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLocks\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reflection\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"}],\"internalType\":\"struct BigSBsaleClaim.Lock[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"giveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userLocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reflection\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BigSBsaleClaim","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000286b2eb4f4dbf2dffc1fcb00bab547f103be5fd4000000000000000000000000131157c6760f78f7ddf877c0019eba175ba4b6f6","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://28d7fc522c64294bd2acacc00b353332b3e294bd44d3ae7007ac03e6d7cc76e4"}]}