{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/INamelessTemplateLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INamelessTemplateLibrary {\\n  function getTemplate(uint256 templateIndex) external view returns (bytes32[] memory dataSection, bytes32[] memory codeSection);\\n  function getContentApis() external view returns (string memory arweaveContentApi, string memory ipfsContentApi);\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/INamelessToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\ninterface INamelessToken {\\n  function initialize(string memory name, string memory symbol, address tokenDataContract, address initialAdmin) external;\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/INamelessTokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\ninterface INamelessTokenData {\\n  function initialize ( address templateLibrary, address clonableTokenAddress, address initialAdmin, uint256 maxGenerationSize ) external;\\n  function getTokenURI(uint256 tokenId, address owner) external view returns (string memory);\\n  function beforeTokenTransfer(address from, address, uint256 tokenId) external returns (bool);\\n  function redeem(uint256 tokenId) external;\\n  function getFeeRecipients(uint256) external view returns (address payable[] memory);\\n  function getFeeBps(uint256) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessDataV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../utils/BinaryDecoder.sol';\\nimport '../utils/PackedVarArray.sol';\\n\\n\\nlibrary NamelessDataV1 {\\n  /*\\n   * up to 2^32 generations each separated in space by\\n   * 2^223 empty slots for safety\\n   * leaving 223 bits of space for collision resistance\\n   */\\n  function getGenerationalSlot(uint256 columnName, uint32 generation) internal pure returns (uint256) {\\n    uint256 finalSlot =\\n      (columnName & 0x000000007FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n      (uint(generation) << 224);\\n\\n    return finalSlot;\\n  }\\n\\n  /*\\n   * Special Column Types\\n   */\\n\\n  uint256 private constant MAX_COLUMN_WORDS = 65535;\\n  uint256 private constant MAX_CONTENT_LIBRARIES_PER_COLUMN = 256;\\n  uint256 private constant CONTENT_LIBRARY_SECTION_SIZE = 32 * MAX_CONTENT_LIBRARIES_PER_COLUMN;\\n\\n  uint256 public constant COLUMN_TYPE_STRING = 1;\\n  uint256 public constant COLUMN_TYPE_UINT256 = 2;\\n  uint256 public constant COLUMN_TYPE_UINT128 = 3;\\n  uint256 public constant COLUMN_TYPE_UINT64 = 4;\\n  uint256 public constant COLUMN_TYPE_UINT32 = 5;\\n  uint256 public constant COLUMN_TYPE_UINT16 = 6;\\n  uint256 public constant COLUMN_TYPE_UINT8  = 7;\\n  uint256 public constant COLUMN_TYPE_NATIVE_STRING = 8;\\n\\n  /**\\n    * @dev Returns an `uint256[MAX_COLUMN_WORDS]` located at `slot`.\\n    */\\n  function getColumn(bytes32 slot) internal pure returns (bytes32[MAX_COLUMN_WORDS] storage r) {\\n      // solhint-disable-next-line no-inline-assembly\\n      assembly {\\n          r.slot := slot\\n      }\\n  }\\n\\n  function getBufferIndexAndOffset(uint index, uint stride) internal pure returns (uint, uint) {\\n    uint offset = index * stride;\\n    return (offset / 32, offset % 32);\\n  }\\n\\n  function getBufferIndexAndOffset(uint index, uint stride, uint baseOffset) internal pure returns (uint, uint) {\\n    uint offset = (index * stride) + baseOffset;\\n    return (offset / 32, offset % 32);\\n  }\\n\\n  /*\\n   * Content Library Column\\n   *\\n   * @dev a content library column references content from a secondary data source like arweave of IPFS\\n   *      this content has been batched into libraries to save space.  Each library is a JSON-encoded\\n   *      array stored on the secondary data source that provides an indirection to the \\\"real\\\" content.\\n   *      each content library can hold up to 256 content references and each column can reference 256\\n   *      libraries. This results in a total of 65536 addressable content hashes while only consuming\\n   *      2 bytes per distinct token.\\n   */\\n  function readContentLibraryColumn(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint contentLibraryHash,\\n    uint contentIndex\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    (uint bufferIndex, uint offset) = getBufferIndexAndOffset(ordinal, 2, CONTENT_LIBRARY_SECTION_SIZE);\\n    uint row = 0;\\n    (row, , ) = BinaryDecoder.decodeUint16Aligned(column, bufferIndex, offset);\\n\\n    uint contentLibraryIndex = row >> 8;\\n    contentIndex = row & 0xFF;\\n    contentLibraryHash = uint256(column[contentLibraryIndex]);\\n  }\\n\\n  function readDictionaryString(bytes32 dictionarySlot, uint ordinal) public view returns ( string memory ) {\\n    return PackedVarArray.getString(getColumn(dictionarySlot), ordinal);\\n  }\\n\\n  function getDictionaryStringInfo(bytes32 dictionarySlot, uint ordinal) internal view returns ( bytes32 firstSlot, uint offset, uint length ) {\\n    return PackedVarArray.getStringInfo(getColumn(dictionarySlot), ordinal);\\n  }\\n\\n  function readDictionaryStringLength(bytes32 dictionarySlot, uint ordinal) public view returns ( uint ) {\\n    return PackedVarArray.getStringLength(getColumn(dictionarySlot), ordinal);\\n  }\\n\\n  /*\\n   * Uint256 Column\\n   *\\n   */\\n  function readUint256Column(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    return uint256(column[ordinal]);\\n  }\\n\\n  /*\\n   * Uint128 Column\\n   *\\n   */\\n  function readUint128Column(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    uint bufferIndex = ordinal / 2;\\n    uint shift = (1 - (ordinal % 2)) * 128;\\n    return (uint256(column[bufferIndex]) >> shift) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  }\\n\\n  /*\\n   * Uint64 Column\\n   *\\n   */\\n  function readUint64Column(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    uint bufferIndex = ordinal / 4;\\n    uint shift = (3 - (ordinal % 4)) * 64;\\n    return (uint256(column[bufferIndex]) >> shift) & 0xFFFFFFFFFFFFFFFF;\\n  }\\n\\n  /*\\n   * Uint32 Column\\n   *\\n   */\\n  function readUint32Column(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    uint bufferIndex = ordinal / 8;\\n    uint shift = (7 - (ordinal % 8)) * 32;\\n    return (uint256(column[bufferIndex]) >> shift) & 0xFFFFFFFF;\\n  }\\n\\n  /*\\n   * Uint16 Column\\n   *\\n   */\\n  function readUint16Column(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    uint bufferIndex = ordinal / 16;\\n    uint shift = (15 - (ordinal % 16)) * 16;\\n    return (uint256(column[bufferIndex]) >> shift) & 0xFFFF;\\n  }\\n\\n  /*\\n   * Uint8 Column\\n   *\\n   */\\n  function readUint8Column(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    uint bufferIndex = ordinal / 32;\\n    uint shift = (31 - (ordinal % 32)) * 8;\\n    return (uint256(column[bufferIndex]) >> shift) & 0xFF;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessMetadataURIV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/StorageSlot.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\nimport './NamelessDataV1.sol';\\nimport '../utils/Base64.sol';\\n\\nlibrary NamelessMetadataURIV1 {\\n  bytes constant private BASE_64_URL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\\n\\n  function base64EncodeBuffer(bytes memory buffer, bytes memory output, uint outOffset) internal pure returns (uint) {\\n    uint outLen = (buffer.length + 2) / 3 * 4 - ((3 - ( buffer.length % 3 )) % 3);\\n\\n    uint256 i = 0;\\n    uint256 j = outOffset;\\n\\n    for (; i + 3 <= buffer.length; i += 3) {\\n        (output[j], output[j+1], output[j+2], output[j+3]) = base64Encode3(\\n            uint8(buffer[i]),\\n            uint8(buffer[i+1]),\\n            uint8(buffer[i+2])\\n        );\\n\\n        j += 4;\\n    }\\n\\n    if ((i + 2) == buffer.length) {\\n      (output[j], output[j+1], output[j+2], ) = base64Encode3(\\n          uint8(buffer[i]),\\n          uint8(buffer[i+1]),\\n          0\\n      );\\n    } else if ((i + 1) == buffer.length) {\\n      (output[j], output[j+1], , ) = base64Encode3(\\n          uint8(buffer[i]),\\n          0,\\n          0\\n      );\\n    }\\n\\n    return outOffset + outLen;\\n  }\\n\\n  function base64Encode(uint256 bigint, bytes memory output, uint outOffset) internal pure returns (uint) {\\n      bytes32 buffer = bytes32(bigint);\\n\\n      uint256 i = 0;\\n      uint256 j = outOffset;\\n\\n      for (; i + 3 <= 32; i += 3) {\\n          (output[j], output[j+1], output[j+2], output[j+3]) = base64Encode3(\\n              uint8(buffer[i]),\\n              uint8(buffer[i+1]),\\n              uint8(buffer[i+2])\\n          );\\n\\n          j += 4;\\n      }\\n      (output[j], output[j+1], output[j+2], ) = base64Encode3(uint8(buffer[30]), uint8(buffer[31]), 0);\\n      return outOffset + 43;\\n  }\\n\\n  function base64Encode3(uint256 a0, uint256 a1, uint256 a2)\\n      internal\\n      pure\\n      returns (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3)\\n  {\\n\\n      uint256 n = (a0 << 16) | (a1 << 8) | a2;\\n\\n      uint256 c0 = (n >> 18) & 63;\\n      uint256 c1 = (n >> 12) & 63;\\n      uint256 c2 = (n >>  6) & 63;\\n      uint256 c3 = (n      ) & 63;\\n\\n      b0 = BASE_64_URL_CHARS[c0];\\n      b1 = BASE_64_URL_CHARS[c1];\\n      b2 = BASE_64_URL_CHARS[c2];\\n      b3 = BASE_64_URL_CHARS[c3];\\n  }\\n\\n  bytes constant private BASE_58_CHARS = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\\n\\n  function ipfsCidEncode(bytes32 value, bytes memory output, uint outOffset) internal pure returns (uint) {\\n    uint encodedLen = 0;\\n    for (uint idx = 0; idx < 34; idx++)\\n    {\\n      uint carry = 0;\\n      if (idx >= 2) {\\n        carry = uint8(value[idx - 2]);\\n      } else if (idx == 1) {\\n        carry = 0x20;\\n      } else if (idx == 0) {\\n        carry = 0x12;\\n      }\\n\\n      for (uint jdx = 0; jdx < encodedLen; jdx++)\\n      {\\n        carry = carry + (uint(uint8(output[outOffset + 45 - jdx])) << 8);\\n        output[outOffset + 45 - jdx] = bytes1(uint8(carry % 58));\\n        carry /= 58;\\n      }\\n      while (carry > 0) {\\n        output[outOffset + 45 - encodedLen++] = bytes1(uint8(carry % 58));\\n        carry /= 58;\\n      }\\n    }\\n\\n    for (uint idx = 0; idx < 46; idx++) {\\n      output[outOffset + idx] = BASE_58_CHARS[uint8(output[outOffset + idx])];\\n    }\\n\\n    return outOffset + 46;\\n  }\\n\\n  function base10Encode(uint256 bigint, bytes memory output, uint outOffset) internal pure returns (uint) {\\n    bytes memory alphabet = '0123456789';\\n    if (bigint == 0) {\\n      output[outOffset] = alphabet[0];\\n      return outOffset + 1;\\n    }\\n\\n    uint digits = 0;\\n    uint value = bigint;\\n    while (value > 0) {\\n      digits++;\\n      value = value / 10;\\n    }\\n\\n    value = bigint;\\n    uint currentOffset = outOffset + digits - 1;\\n    while (value > 0) {\\n      output[currentOffset] = alphabet[value % 10];\\n      currentOffset--;\\n      value = value / 10;\\n    }\\n\\n    return outOffset + digits;\\n  }\\n\\n\\n\\n  function writeAddressToString(address addr, bytes memory output, uint outOffset) internal pure returns(uint) {\\n    bytes32 value = bytes32(uint256(uint160(addr)));\\n    bytes memory alphabet = '0123456789abcdef';\\n\\n    output[outOffset++] = '0';\\n    output[outOffset++] = 'x';\\n    for (uint256 i = 0; i < 20; i++) {\\n      output[outOffset + (i*2) ]    = alphabet[uint8(value[i + 12] >> 4)];\\n      output[outOffset + (i*2) + 1] = alphabet[uint8(value[i + 12] & 0x0f)];\\n    }\\n    outOffset += 40;\\n    return outOffset;\\n  }\\n\\n  function copyDictionaryString(Context memory context, bytes32 columnSlot, uint256 ordinal) internal view returns (uint) {\\n    bytes32 curSlot;\\n    uint offset;\\n    uint length;\\n    (curSlot, offset, length) = NamelessDataV1.getDictionaryStringInfo(columnSlot, ordinal);\\n\\n    bytes32 curBuffer;\\n    uint remaining = length;\\n    uint bufferCap = 32 - offset;\\n    uint outIdx = 0;\\n\\n    while (outIdx < length) {\\n      uint copyCount = remaining > bufferCap ? bufferCap : remaining;\\n      uint lastOffset = offset + copyCount;\\n      curBuffer = StorageSlot.getBytes32Slot(curSlot).value;\\n\\n      while( offset < lastOffset) {\\n        context.output[context.outOffset + outIdx++] = curBuffer[offset++];\\n      }\\n      remaining -= copyCount;\\n      bufferCap = 32;\\n      offset = 0;\\n      curSlot = bytes32(uint(curSlot) + 1);\\n    }\\n\\n    return context.outOffset + outIdx;\\n  }\\n\\n  function copyString(Context memory context, string memory value) internal pure returns (uint) {\\n    for (uint idx = 0; idx < bytes(value).length; idx++) {\\n      context.output[context.outOffset + idx] = bytes(value)[idx];\\n    }\\n\\n    return context.outOffset + bytes(value).length;\\n  }\\n\\n  function copyNativeString(Context memory context, bytes32 columnSlot, uint256 ordinal) internal view returns (uint) {\\n    string[] storage nativeStrings;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      nativeStrings.slot := columnSlot\\n    }\\n\\n    bytes storage buffer = bytes(nativeStrings[ordinal]);\\n    uint length = buffer.length;\\n\\n    for (uint idx = 0; idx < length; idx++) {\\n      context.output[context.outOffset + idx] = buffer[idx];\\n    }\\n\\n    return context.outOffset + length;\\n  }\\n\\n\\n  struct Context {\\n    uint codeBufferIndex;\\n    uint codeBufferOffset;\\n    uint256 tokenId;\\n    uint32 generation;\\n    uint   index;\\n    address owner;\\n    string arweaveContentApi;\\n    string ipfsContentApi;\\n\\n    uint opsRetired;\\n\\n    uint outOffset;\\n    bytes output;\\n    bool done;\\n    uint8  stackLength;\\n    bytes32[0xFF] stack;\\n  }\\n\\n  // 4byte opcode to write the bytes32 at the top of the stack to the output raw and consume it\\n  // byte 1 is the write codepoint,\\n  // byte 2 is the write format (0 = raw, 1 = hex, 2 = base64),\\n  // byte 3 is the offset big-endian to start at and\\n  // byte 4 is the big-endian byte to stop at (non-inclusive)\\n  function execWrite(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal pure {\\n    require(context.stackLength > 0, 'stack underflow');\\n    uint format = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint start = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint end = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    if (format == 0) {\\n      bytes32 stackTop = bytes32(context.stack[context.stackLength - 1]);\\n      for (uint idx = start; idx < end; idx++) {\\n        context.output[ context.outOffset ++ ] = stackTop[idx];\\n      }\\n    } else if (format == 1) {\\n      uint256 stackTop = uint256(context.stack[context.stackLength - 1]);\\n      bytes memory alphabet = '0123456789abcdef';\\n      uint startNibble = start * 2;\\n      uint endNibble = end * 2;\\n\\n      stackTop >>= (64 - endNibble) * 4;\\n\\n      context.output[context.outOffset++] = '0';\\n      context.output[context.outOffset++] = 'x';\\n      for (uint256 i = endNibble-1; i >= startNibble; i--) {\\n        uint nibble = stackTop & 0xf;\\n        stackTop >>= 4;\\n        context.output[context.outOffset + i - startNibble ] = alphabet[nibble];\\n      }\\n      context.outOffset += endNibble - startNibble;\\n    } else if (format == 2) {\\n      uint256 stackTop = uint256(context.stack[context.stackLength - 1]);\\n      if (start == 0 && end == 32) {\\n        context.outOffset = base64Encode(stackTop, context.output, context.outOffset);\\n      } else {\\n        uint length = end - start;\\n        bytes memory temp = new bytes(length);\\n        for (uint idx = 0; idx < length; idx++) {\\n          temp[idx] = bytes32(stackTop)[start + idx];\\n        }\\n        context.outOffset = base64EncodeBuffer(temp, context.output, context.outOffset);\\n      }\\n    } else if (format == 3) {\\n      require(start == 0 && end == 32, 'invalid cid length');\\n      context.outOffset = ipfsCidEncode(context.stack[context.stackLength - 1], context.output, context.outOffset);\\n    } else if (format == 4) {\\n      uint mask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >> (start * 8);\\n      uint shift = (32 - end) * 8;\\n      uint value = (uint256(context.stack[context.stackLength - 1]) & mask) >> shift;\\n      context.outOffset = base10Encode(value, context.output, context.outOffset);\\n    }\\n\\n\\n    context.stackLength--;\\n  }\\n  // 2byte opcode to write the column-specific data indicated by the column name on the top of the stack\\n  // this column has \\\"typed\\\" data like strings etc\\n  function execWriteContext(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal view {\\n    require(context.stack.length > 0, 'stack underflow');\\n    uint contextId = uint(context.stack[context.stackLength - 1]);\\n    context.stackLength--;\\n\\n    uint format = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    if (contextId == CONTEXT_TOKEN_ID || contextId == CONTEXT_TOKEN_OWNER || contextId == CONTEXT_BLOCK_TIMESTAMP || contextId == CONTEXT_GENERATION || contextId == CONTEXT_INDEX ) {\\n      require(format != 0, 'invalid format for uint256');\\n      uint value = 0;\\n      if (contextId == CONTEXT_TOKEN_ID) {\\n        value = context.tokenId;\\n      } else if (contextId == CONTEXT_TOKEN_OWNER ) {\\n        value = uint256(uint160(context.owner));\\n      } else if (contextId == CONTEXT_BLOCK_TIMESTAMP ) {\\n        // solhint-disable-next-line not-rely-on-time\\n        value = uint256(block.timestamp);\\n      } else if (contextId == CONTEXT_GENERATION ) {\\n        value = context.generation;\\n      } else if (contextId == CONTEXT_INDEX ) {\\n        value = context.index;\\n      }\\n\\n      if (format == 1) {\\n        bytes memory alphabet = '0123456789abcdef';\\n        context.output[context.outOffset++] = '0';\\n        context.output[context.outOffset++] = 'x';\\n        for (uint256 i = 63; i >= 0; i--) {\\n          uint nibble = value & 0xf;\\n          value >>= 4;\\n          context.output[context.outOffset + i] = alphabet[nibble];\\n        }\\n        context.outOffset += 64;\\n      } else if (format == 2) {\\n        context.outOffset = base64Encode(value, context.output, context.outOffset);\\n      } else if (format == 4) {\\n        context.outOffset = base10Encode(value, context.output, context.outOffset);\\n      }\\n\\n    } else if (contextId == CONTEXT_ARWEAVE_CONTENT_API || contextId == CONTEXT_IPFS_CONTENT_API ) {\\n      require(format == 0, 'invalid format for string');\\n      string memory value;\\n      if (contextId == CONTEXT_ARWEAVE_CONTENT_API) {\\n        value = context.arweaveContentApi;\\n      } else if ( contextId == CONTEXT_IPFS_CONTENT_API) {\\n        value = context.ipfsContentApi;\\n      }\\n\\n      context.outOffset = copyString(context, value);\\n    } else {\\n      revert(string(abi.encodePacked('Unknown/unsupported context ID', Strings.toString(contextId))));\\n    }\\n  }\\n\\n  // 2byte opcode to write the column-specific data indicated by the column name on the top of the stack\\n  // this column has \\\"typed\\\" data like strings etc\\n  function execWriteColumnar(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal view {\\n    require(context.stack.length > 1, 'stack underflow');\\n    bytes32 rawColumnSlot = context.stack[context.stackLength - 2];\\n    bytes32 columnSlot = bytes32(NamelessDataV1.getGenerationalSlot(uint(rawColumnSlot), context.generation));\\n    uint columnIndex = uint(context.stack[context.stackLength - 1]);\\n    context.stackLength -= 2;\\n\\n    uint format = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint256 columnMetadata = StorageSlot.getUint256Slot(columnSlot).value;\\n    uint columnType = (columnMetadata >> 248) & 0xFF;\\n\\n    if (columnType == NamelessDataV1.COLUMN_TYPE_NATIVE_STRING) {\\n      require(format == 0, 'invalid format for string');\\n      context.outOffset = copyNativeString(context, bytes32(uint256(columnSlot) + 1), columnIndex);\\n    } else if (columnType == NamelessDataV1.COLUMN_TYPE_STRING) {\\n      require(format == 0, 'invalid format for string');\\n      context.outOffset = copyDictionaryString(context, bytes32(uint256(columnSlot) + 1), columnIndex);\\n    } else if (columnType >= NamelessDataV1.COLUMN_TYPE_UINT256 && columnType <= NamelessDataV1.COLUMN_TYPE_UINT8) {\\n      require(format != 0, 'invalid format for uint');\\n      uint value = 0;\\n\\n      if (columnType == NamelessDataV1.COLUMN_TYPE_UINT256) {\\n        value = NamelessDataV1.readUint256Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT128) {\\n        value = NamelessDataV1.readUint128Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT64) {\\n        value = NamelessDataV1.readUint64Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT32) {\\n        value = NamelessDataV1.readUint32Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT16) {\\n        value = NamelessDataV1.readUint16Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT8) {\\n        value = NamelessDataV1.readUint8Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      }\\n\\n      if (format == 1) {\\n        bytes memory alphabet = '0123456789abcdef';\\n        context.output[context.outOffset++] = '0';\\n        context.output[context.outOffset++] = 'x';\\n        for (uint256 i = 63; i >= 0; i--) {\\n          uint nibble = value & 0xf;\\n          value >>= 4;\\n          context.output[context.outOffset + i] = alphabet[nibble];\\n        }\\n        context.outOffset += 64;\\n      } else if (format == 2) {\\n        context.outOffset = base64Encode(value, context.output, context.outOffset);\\n      } else if (format == 3) {\\n        context.outOffset = ipfsCidEncode(bytes32(value), context.output, context.outOffset);\\n      } else if (format == 4) {\\n        context.outOffset = base10Encode(value, context.output, context.outOffset);\\n      }\\n    } else {\\n      revert('unknown column type');\\n    }\\n  }\\n\\n  // 1byte opcode to push the bytes32 at a given index in the data section onto the stack\\n  // byte 1 is the push codepoint,\\n  function execPushData(Context memory context, bytes32[] memory dataSegment, bytes32[] memory) internal pure {\\n    context.stack[context.stackLength-1] = dataSegment[uint256(context.stack[context.stackLength-1])];\\n  }\\n\\n  // Nbyte opcode to push the immediate bytes in the codeSegment onto the stack\\n  // byte 1 is the pushImmediate codepoint,\\n  // byte 2 big-endian offset to write the first loaded byte from\\n  // byte 3 number of immediate bytes\\n  // bytes 4-N big-endian immediate bytes\\n  function execPushImmediate(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal pure {\\n    uint startShiftByte = 31 - uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint length = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint256 value = 0;\\n    for (uint idx = 0; idx < length; idx++) {\\n      uint byteVal = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n      incrementCodeOffset(context);\\n      value |= byteVal << ((startShiftByte - idx) * 8);\\n    }\\n\\n    context.stack[context.stackLength++] = bytes32(value);\\n  }\\n\\n  uint private constant CONTEXT_TOKEN_ID = 0;\\n  uint private constant CONTEXT_TOKEN_OWNER = 1;\\n  uint private constant CONTEXT_BLOCK_TIMESTAMP = 2;\\n  uint private constant CONTEXT_ARWEAVE_CONTENT_API = 3;\\n  uint private constant CONTEXT_IPFS_CONTENT_API = 4;\\n  uint private constant CONTEXT_GENERATION = 5;\\n  uint private constant CONTEXT_INDEX = 6;\\n\\n\\n  // 2byte opcode to push well-known context data to the stack\\n  // byte 1 is the push codepoint,\\n  // byte 2 well-known context id\\n  function execPushContext(Context memory context, bytes32[] memory, bytes32[] memory) internal view {\\n    uint contextId = uint256(context.stack[context.stackLength-1]);\\n\\n    if (contextId == CONTEXT_TOKEN_ID) {\\n      context.stack[context.stackLength-1] = bytes32(context.tokenId);\\n    } else if (contextId == CONTEXT_TOKEN_OWNER ) {\\n      context.stack[context.stackLength-1] = bytes32(uint256(uint160(context.owner)));\\n    } else if (contextId == CONTEXT_BLOCK_TIMESTAMP ) {\\n      // solhint-disable-next-line not-rely-on-time\\n      context.stack[context.stackLength-1] = bytes32(uint256(block.timestamp));\\n    } else if (contextId == CONTEXT_GENERATION) {\\n      context.stack[context.stackLength-1] = bytes32(uint(context.generation));\\n    } else if (contextId == CONTEXT_INDEX) {\\n      context.stack[context.stackLength-1] = bytes32(context.index);\\n    } else {\\n      revert('Unknown/unsupported context ID in push');\\n    }\\n  }\\n\\n  // 1byte opcode to push the 32 bytes at the slot indicated by the top of the stack\\n  function execPushStorage(Context memory context, bytes32[] memory, bytes32[] memory) internal view {\\n    bytes32 stackTop = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 1] = StorageSlot.getBytes32Slot(stackTop).value;\\n  }\\n\\n  // 1byte opcode to push the 32 bytes at the slot indicated by the top of the stack\\n  function execPushColumnar(Context memory context, bytes32[] memory, bytes32[] memory) internal view {\\n    require(context.stack.length > 1, 'stack underflow');\\n    bytes32 rawColumnSlot = context.stack[context.stackLength - 2];\\n    bytes32 columnSlot = bytes32(NamelessDataV1.getGenerationalSlot(uint(rawColumnSlot), context.generation));\\n    uint columnIndex = uint(context.stack[context.stackLength - 1]);\\n    context.stackLength -= 1;\\n\\n    uint256 columnMetadata = StorageSlot.getUint256Slot(columnSlot).value;\\n    uint columnType = (columnMetadata >> 248) & 0xFF;\\n\\n    if (columnType == NamelessDataV1.COLUMN_TYPE_UINT256) {\\n      uint value = NamelessDataV1.readUint256Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      context.stack[context.stackLength - 1] = bytes32(value);\\n    } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT128) {\\n      uint value = NamelessDataV1.readUint128Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      context.stack[context.stackLength - 1] = bytes32(value);\\n    } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT64) {\\n      uint value = NamelessDataV1.readUint64Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      context.stack[context.stackLength - 1] = bytes32(value);\\n    } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT32) {\\n      uint value = NamelessDataV1.readUint32Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      context.stack[context.stackLength - 1] = bytes32(value);\\n    } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT16) {\\n      uint value = NamelessDataV1.readUint16Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      context.stack[context.stackLength - 1] = bytes32(value);\\n    } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT8) {\\n      uint value = NamelessDataV1.readUint8Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      context.stack[context.stackLength - 1] = bytes32(value);\\n    } else {\\n      revert('unknown or bad column type');\\n    }\\n  }\\n\\n  function execPop(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    context.stackLength--;\\n  }\\n\\n  function execDup(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    context.stack[context.stackLength] = context.stack[context.stackLength - 1];\\n    context.stackLength++;\\n  }\\n\\n  function execSwap(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    (context.stack[context.stackLength - 1], context.stack[context.stackLength - 2]) = (context.stack[context.stackLength - 2], context.stack[context.stackLength - 1]);\\n  }\\n\\n  function execAdd(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a + b);\\n    context.stackLength--;\\n  }\\n\\n  function execSub(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a - b);\\n    context.stackLength--;\\n  }\\n\\n  function execMul(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a * b);\\n    context.stackLength--;\\n  }\\n\\n  function execDiv(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a / b);\\n    context.stackLength--;\\n  }\\n\\n  function execMod(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a % b);\\n    context.stackLength--;\\n  }\\n\\n  function execJumpPos(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength--;\\n\\n    addCodeOffset(context, offset);\\n  }\\n\\n  function execJumpNeg(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength--;\\n\\n    subCodeOffset(context, offset);\\n  }\\n\\n  function execBrEZPos(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 value = uint256(context.stack[context.stackLength - 2]);\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength-=2;\\n\\n    if (value == 0) {\\n      addCodeOffset(context, offset);\\n    }\\n  }\\n\\n  function execBrEZNeg(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 value = uint256(context.stack[context.stackLength - 2]);\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength-=2;\\n\\n    if (value == 0) {\\n      subCodeOffset(context, offset);\\n    }\\n  }\\n\\n  function execSha3(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 1] = keccak256(abi.encodePacked(a));\\n  }\\n\\n  function execXor(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = a ^ b;\\n    context.stackLength--;\\n  }\\n\\n  function execOr(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = a | b;\\n    context.stackLength--;\\n  }\\n\\n  function execAnd(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = a & b;\\n    context.stackLength--;\\n  }\\n\\n  function execGt(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a > b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execGte(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a >= b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execLt(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a < b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execLte(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a <= b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execEq(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a == b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execNeq(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a != b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  uint private constant OP_NOOP                = 0x00;\\n  uint private constant OP_WRITE               = 0x01;\\n  uint private constant OP_WRITE_CONTEXT       = 0x02;\\n  uint private constant OP_WRITE_COLUMNAR      = 0x04;\\n  uint private constant OP_PUSH_DATA           = 0x05;\\n  uint private constant OP_PUSH_STORAGE        = 0x06;\\n  uint private constant OP_PUSH_IMMEDIATE      = 0x07;\\n  uint private constant OP_PUSH_CONTEXT        = 0x08;\\n  uint private constant OP_PUSH_COLUMNAR       = 0x09;\\n  uint private constant OP_POP                 = 0x0a;\\n  uint private constant OP_DUP                 = 0x0b;\\n  uint private constant OP_SWAP                = 0x0c;\\n  uint private constant OP_ADD                 = 0x0d;\\n  uint private constant OP_SUB                 = 0x0e;\\n  uint private constant OP_MUL                 = 0x0f;\\n  uint private constant OP_DIV                 = 0x10;\\n  uint private constant OP_MOD                 = 0x11;\\n  uint private constant OP_JUMP_POS            = 0x12;\\n  uint private constant OP_JUMP_NEG            = 0x13;\\n  uint private constant OP_BRANCH_POS_EQ_ZERO  = 0x14;\\n  uint private constant OP_BRANCH_NEG_EQ_ZERO  = 0x15;\\n  uint private constant OP_SHA3                = 0x16;\\n  uint private constant OP_XOR                 = 0x17;\\n  uint private constant OP_OR                  = 0x18;\\n  uint private constant OP_AND                 = 0x19;\\n  uint private constant OP_GT                  = 0x1a;\\n  uint private constant OP_GTE                 = 0x1b;\\n  uint private constant OP_LT                  = 0x1c;\\n  uint private constant OP_LTE                 = 0x1d;\\n  uint private constant OP_EQ                  = 0x1e;\\n  uint private constant OP_NEQ                 = 0x1f;\\n\\n  function incrementCodeOffset(Context memory context) internal pure {\\n    context.codeBufferOffset++;\\n    if (context.codeBufferOffset == 32) {\\n      context.codeBufferOffset = 0;\\n      context.codeBufferIndex++;\\n    }\\n  }\\n\\n  function addCodeOffset(Context memory context, uint offset) internal pure {\\n    uint pc = (context.codeBufferIndex * 32) + context.codeBufferOffset;\\n    pc += offset;\\n    context.codeBufferOffset = pc % 32;\\n    context.codeBufferIndex = pc / 32;\\n  }\\n\\n  function subCodeOffset(Context memory context, uint offset) internal pure {\\n    uint pc = (context.codeBufferIndex * 32) + context.codeBufferOffset;\\n    pc -= offset;\\n    context.codeBufferOffset = pc % 32;\\n    context.codeBufferIndex = pc / 32;\\n  }\\n\\n  function execOne(Context memory context, bytes32[] memory dataSegment, bytes32[] memory codeSegment) internal view {\\n    uint nextOp = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n\\n    incrementCodeOffset(context);\\n\\n    if (nextOp == OP_NOOP) {\\n      //solhint-disable-previous-line no-empty-blocks\\n    } else if (nextOp == OP_WRITE) {\\n      execWrite(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_WRITE_CONTEXT) {\\n      execWriteContext(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_WRITE_COLUMNAR) {\\n      execWriteColumnar(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_DATA) {\\n      execPushData(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_STORAGE) {\\n      execPushStorage(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_IMMEDIATE) {\\n      execPushImmediate(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_CONTEXT) {\\n      execPushContext(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_COLUMNAR) {\\n      execPushColumnar(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_POP) {\\n      execPop(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_DUP) {\\n      execDup(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_SWAP) {\\n      execSwap(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_ADD) {\\n      execAdd(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_SUB) {\\n      execSub(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_MUL) {\\n      execMul(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_DIV) {\\n      execDiv(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_MOD) {\\n      execMod(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_JUMP_POS) {\\n      execJumpPos(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_JUMP_NEG) {\\n      execJumpNeg(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_BRANCH_POS_EQ_ZERO) {\\n      execBrEZPos(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_BRANCH_NEG_EQ_ZERO) {\\n      execBrEZNeg(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_SHA3) {\\n      execSha3(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_XOR) {\\n      execXor(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_OR) {\\n      execOr(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_AND) {\\n      execAnd(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_GT) {\\n      execGt(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_GTE) {\\n      execGte(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_LT) {\\n      execLt(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_LTE) {\\n      execLte(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_EQ) {\\n      execEq(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_NEQ) {\\n      execNeq(context, dataSegment, codeSegment);\\n    } else {\\n      revert(string(abi.encodePacked('bad op code: ', Strings.toString(nextOp), ' next_pc: ', Strings.toString(context.codeBufferIndex), ',',  Strings.toString(context.codeBufferOffset))));\\n    }\\n\\n    context.opsRetired++;\\n\\n    if (/*context.opsRetired > 7 || */context.codeBufferIndex >= codeSegment.length) {\\n      context.done = true;\\n    }\\n  }\\n\\n  function interpolateTemplate(uint256 tokenId, uint32 generation, uint index, address owner, string memory arweaveContentApi, string memory ipfsContentApi, bytes32[] memory dataSegment, bytes32[] memory codeSegment) internal view returns (bytes memory) {\\n    Context memory context;\\n    context.output = new bytes(0xFFFF);\\n    context.tokenId = tokenId;\\n    context.generation = generation;\\n    context.index = index;\\n    context.owner = owner;\\n    context.arweaveContentApi = arweaveContentApi;\\n    context.ipfsContentApi = ipfsContentApi;\\n    context.outOffset = 0;\\n\\n    while (!context.done) {\\n      execOne(context, dataSegment, codeSegment);\\n    }\\n\\n    bytes memory result = context.output;\\n    uint resultLen = context.outOffset;\\n\\n    //solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      mstore(result, resultLen)\\n    }\\n\\n    return result;\\n  }\\n\\n  function makeJson( uint256 tokenId, uint32 generation, uint index, address owner, string memory arweaveContentApi, string memory ipfsContentApi, bytes32[] memory dataSegment, bytes32[] memory codeSegment ) public view returns (string memory) {\\n    bytes memory metadata = interpolateTemplate(tokenId, generation, index, owner, arweaveContentApi, ipfsContentApi, dataSegment, codeSegment);\\n    return string(metadata);\\n  }\\n\\n  function makeDataURI( string memory uriBase, uint256 tokenId, uint32 generation, uint index, address owner, string memory arweaveContentApi, string memory ipfsContentApi, bytes32[] memory dataSegment, bytes32[] memory codeSegment ) public view returns (string memory) {\\n    bytes memory metadata = interpolateTemplate(tokenId, generation, index, owner, arweaveContentApi, ipfsContentApi, dataSegment, codeSegment);\\n    return string(abi.encodePacked(uriBase,Base64.encode(metadata)));\\n  }\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessTokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\\nimport '@openzeppelin/contracts/proxy/Clones.sol';\\n\\nimport './NamelessMetadataURIV1.sol';\\nimport './NamelessDataV1.sol';\\nimport './INamelessTemplateLibrary.sol';\\nimport './INamelessToken.sol';\\nimport './INamelessTokenData.sol';\\n\\ncontract NamelessTokenData is INamelessTokenData, AccessControl, Initializable {\\n  bytes32 public constant INFRA_ROLE = keccak256('INFRA_ROLE');\\n  bytes32 public constant MINTER_ROLE = keccak256('MINTER_ROLE');\\n\\n  address private _templateLibrary;\\n  string private _uriBase;\\n  address public clonableTokenAddress;\\n  address public frontendAddress;\\n  address payable public royaltyAddress;\\n  uint256 public royaltyBps;\\n  uint256 public maxGenerationSize;\\n\\n  function initialize (\\n    address templateLibrary_,\\n    address clonableTokenAddress_,\\n    address initialAdmin,\\n    uint256 maxGenerationSize_\\n  ) public override initializer {\\n    _templateLibrary = templateLibrary_;\\n    _uriBase = 'data:application/json;base64,';\\n    clonableTokenAddress = clonableTokenAddress_;\\n    maxGenerationSize = maxGenerationSize_;\\n    _setupRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n  }\\n\\n  constructor(\\n    address templateLibrary_,\\n    address clonableTokenAddress_,\\n    uint256 maxGenerationSize_\\n  ) {\\n    initialize(templateLibrary_, clonableTokenAddress_, msg.sender, maxGenerationSize_);\\n  }\\n\\n  mapping (uint32 => bool) public generationSealed;\\n\\n  modifier onlyUnsealed(uint32 generation) {\\n    require(!generationSealed[generation], 'genration is sealed');\\n    _;\\n  }\\n\\n  modifier onlyFrontend() {\\n    require(msg.sender == frontendAddress, 'caller not frontend');\\n    _;\\n  }\\n\\n  function sealGeneration(uint32 generation) public onlyRole(DEFAULT_ADMIN_ROLE) onlyUnsealed(generation){\\n    generationSealed[generation] = true;\\n  }\\n\\n  function _setColumnData(uint256 columnHash, bytes32[] memory data, uint offset ) internal  {\\n    bytes32[0xFFFF] storage storageData;\\n    uint256 columnDataHash = columnHash + 1;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageData.slot := columnDataHash\\n    }\\n\\n    for( uint idx = 0; idx < data.length; idx++) {\\n      storageData[idx + offset] = data[idx];\\n    }\\n  }\\n\\n  function _setColumnMetadata(uint256 columnHash, uint columnType ) internal {\\n    uint256[1] storage columnMetadata;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      columnMetadata.slot := columnHash\\n    }\\n\\n    columnMetadata[0] = columnMetadata[0] | ((columnType & 0xFF) << 248);\\n  }\\n\\n  struct ColumnConfiguration {\\n    uint256 columnHash;\\n    uint256 columnType;\\n    uint256 dataOffset;\\n    bytes32[] data;\\n  }\\n\\n  function configureData( uint32 generation, ColumnConfiguration[] calldata configs) public onlyRole(DEFAULT_ADMIN_ROLE) onlyUnsealed(generation) {\\n    for(uint idx = 0; idx < configs.length; idx++) {\\n      uint256 generationSlot = NamelessDataV1.getGenerationalSlot(configs[idx].columnHash, generation);\\n      _setColumnMetadata(generationSlot, configs[idx].columnType);\\n      _setColumnData(generationSlot, configs[idx].data, configs[idx].dataOffset);\\n    }\\n  }\\n\\n  function idToGenerationIndex(uint256 tokenId) internal view returns (uint32 generation, uint index) {\\n    generation = uint32(tokenId / maxGenerationSize);\\n    index = tokenId % maxGenerationSize;\\n  }\\n\\n  uint256 public constant TOKEN_TRANSFER_COUNT_EXTENSION = 0x1;\\n  uint256 public constant TOKEN_TRANSFER_TIME_EXTENSION  = 0x2;\\n  uint256 public constant TOKEN_REDEEMABLE_EXTENSION     = 0x4;\\n\\n  mapping (uint => uint256) public extensions;\\n  function enableExtensions(uint32 generation, uint256 newExtensions) public onlyRole(DEFAULT_ADMIN_ROLE) onlyUnsealed(generation) {\\n    extensions[generation] = extensions[generation] | newExtensions;\\n\\n    if (newExtensions & TOKEN_TRANSFER_COUNT_EXTENSION != 0) {\\n      initializeTokenTransferCountExtension(generation);\\n    }\\n\\n    if (newExtensions & TOKEN_TRANSFER_TIME_EXTENSION != 0) {\\n      initializeTokenTransferTimeExtension(generation);\\n    }\\n\\n    if (newExtensions & TOKEN_REDEEMABLE_EXTENSION != 0) {\\n      initializeTokenRedeemableExtension(generation);\\n    }\\n  }\\n\\n  uint256 public constant TOKEN_TRANSFER_COUNT_EXTENSION_SLOT = uint256(keccak256('TOKEN_TRANSFER_COUNT_EXTENSION_SLOT'));\\n  function initializeTokenTransferCountExtension(uint32 generation) internal {\\n    uint256[1] storage storageMetadata;\\n    uint generationalSlot = NamelessDataV1.getGenerationalSlot(TOKEN_TRANSFER_COUNT_EXTENSION_SLOT, generation);\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageMetadata.slot := generationalSlot\\n    }\\n\\n    storageMetadata[0] = 0x2 << 248;\\n  }\\n\\n  function processTokenTransferCountExtension(uint32 generation, uint index) internal {\\n    uint256[0xFFFF] storage storageData;\\n    uint generationalSlot = NamelessDataV1.getGenerationalSlot(TOKEN_TRANSFER_COUNT_EXTENSION_SLOT, generation);\\n    uint256 dataSlot = generationalSlot + 1;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageData.slot := dataSlot\\n    }\\n\\n    storageData[index] = storageData[index] + 1;\\n  }\\n\\n  uint256 public constant TOKEN_TRANSFER_TIME_EXTENSION_SLOT = uint256(keccak256('TOKEN_TRANSFER_TIME_EXTENSION_SLOT'));\\n  function initializeTokenTransferTimeExtension(uint32 generation) internal {\\n    uint256[1] storage storageMetadata;\\n    uint generationalSlot = NamelessDataV1.getGenerationalSlot(TOKEN_TRANSFER_TIME_EXTENSION_SLOT, generation);\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageMetadata.slot := generationalSlot\\n    }\\n\\n    storageMetadata[0] = 0x2 << 248;\\n  }\\n\\n  function processTokenTransferTimeExtension(uint32 generation, uint index) internal {\\n    uint256[0xFFFF] storage storageData;\\n    uint generationalSlot = NamelessDataV1.getGenerationalSlot(TOKEN_TRANSFER_COUNT_EXTENSION_SLOT, generation);\\n    uint256 dataSlot = generationalSlot + 1;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageData.slot := dataSlot\\n    }\\n\\n    // solhint-disable-next-line not-rely-on-time\\n    storageData[index] = block.timestamp;\\n  }\\n\\n  uint256 public constant TOKEN_REDEMPTION_EXTENSION_COUNT_SLOT = uint256(keccak256('TOKEN_REDEMPTION_EXTENSION_COUNT_SLOT'));\\n\\n  function initializeTokenRedeemableExtension(uint32 generation) internal {\\n    uint256[1] storage storageMetadata;\\n    uint generationalSlot = NamelessDataV1.getGenerationalSlot(TOKEN_REDEMPTION_EXTENSION_COUNT_SLOT, generation);\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageMetadata.slot := generationalSlot\\n    }\\n\\n    storageMetadata[0] = 0x2 << 248;  // uint256\\n  }\\n\\n\\n  function beforeTokenTransfer(address from, address, uint256 tokenId) public onlyFrontend override returns (bool) {\\n    (uint32 generation, uint index) = idToGenerationIndex(tokenId);\\n    if (extensions[generation] & TOKEN_TRANSFER_COUNT_EXTENSION != 0) {\\n      // don't count minting as a transfer\\n      if (from != address(0)) {\\n        processTokenTransferCountExtension(generation, index);\\n      }\\n    }\\n\\n    if (extensions[generation] & TOKEN_TRANSFER_TIME_EXTENSION != 0) {\\n      processTokenTransferTimeExtension(generation, index);\\n    }\\n\\n    return extensions[generation] & (TOKEN_TRANSFER_COUNT_EXTENSION | TOKEN_TRANSFER_TIME_EXTENSION) != 0;\\n  }\\n\\n  function redeem(uint256 tokenId) public onlyFrontend override {\\n    (uint32 generation, uint index) = idToGenerationIndex(tokenId);\\n    require(extensions[generation] & TOKEN_REDEEMABLE_EXTENSION != 0, 'Token is not redeemable' );\\n\\n    uint256[65535] storage redemptionCount;\\n    uint generationalSlot = NamelessDataV1.getGenerationalSlot(TOKEN_REDEMPTION_EXTENSION_COUNT_SLOT, generation);\\n    uint256 redemptionCountSlot = generationalSlot + 1;\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      redemptionCount.slot := redemptionCountSlot\\n    }\\n\\n    redemptionCount[index] = redemptionCount[index] + 1;\\n  }\\n\\n  function setRoyalties( address payable newRoyaltyAddress, uint256 newRoyaltyBps ) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    royaltyAddress = newRoyaltyAddress;\\n    royaltyBps = newRoyaltyBps;\\n  }\\n\\n  function getFeeRecipients(uint256) public view override returns (address payable[] memory) {\\n    address payable[] memory result = new address payable[](1);\\n    result[0] = royaltyAddress;\\n    return result;\\n  }\\n\\n  function getFeeBps(uint256) public view override returns (uint256[] memory) {\\n    uint256[] memory result = new uint256[](1);\\n    result[0] = royaltyBps;\\n    return result;\\n  }\\n\\n  function setURIBase(string calldata uriBase_) public onlyRole(INFRA_ROLE) {\\n    _uriBase = uriBase_;\\n  }\\n\\n  mapping (uint32 => uint256) public templateIndex;\\n  mapping (uint32 => bytes32[]) public templateData;\\n  mapping (uint32 => bytes32[]) public templateCode;\\n\\n  function setLibraryTemplate(uint32 generation, uint256 which) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    templateIndex[generation] = which;\\n    delete(templateData[generation]);\\n    delete(templateCode[generation]);\\n  }\\n\\n  function setCustomTemplate(uint32 generation, bytes32[] calldata _data, bytes32[] calldata _code) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    delete(templateIndex[generation]);\\n    templateData[generation] = _data;\\n    templateCode[generation] = _code;\\n  }\\n\\n  function getTokenURI(uint256 tokenId, address owner) public view override returns (string memory) {\\n    string memory arweaveContentApi;\\n    string memory ipfsContentApi;\\n    (arweaveContentApi, ipfsContentApi) = INamelessTemplateLibrary(_templateLibrary).getContentApis();\\n    (uint32 generation, uint index) = idToGenerationIndex(tokenId);\\n\\n    if (templateCode[generation].length > 0) {\\n      return NamelessMetadataURIV1.makeDataURI(_uriBase, tokenId, generation, index, owner, arweaveContentApi, ipfsContentApi, templateData[generation], templateCode[generation]);\\n    } else {\\n      bytes32[] memory libraryTemplateData;\\n      bytes32[] memory libraryTemplateCode;\\n      (libraryTemplateData, libraryTemplateCode) = INamelessTemplateLibrary(_templateLibrary).getTemplate(templateIndex[generation]);\\n      return NamelessMetadataURIV1.makeDataURI(_uriBase, tokenId, generation, index, owner, arweaveContentApi, ipfsContentApi, libraryTemplateData, libraryTemplateCode);\\n    }\\n  }\\n\\n  function getTokenMetadata(uint256 tokenId, address owner) public view returns (string memory) {\\n    string memory arweaveContentApi;\\n    string memory ipfsContentApi;\\n    (arweaveContentApi, ipfsContentApi) = INamelessTemplateLibrary(_templateLibrary).getContentApis();\\n    (uint32 generation, uint index) = idToGenerationIndex(tokenId);\\n\\n    if (templateCode[generation].length > 0) {\\n      return NamelessMetadataURIV1.makeJson(tokenId, generation, index, owner, arweaveContentApi, ipfsContentApi, templateData[generation], templateCode[generation]);\\n    } else {\\n      bytes32[] memory libraryTemplateData;\\n      bytes32[] memory libraryTemplateCode;\\n      (libraryTemplateData, libraryTemplateCode) = INamelessTemplateLibrary(_templateLibrary).getTemplate(templateIndex[generation]);\\n      return NamelessMetadataURIV1.makeJson(tokenId, generation, index, owner, arweaveContentApi, ipfsContentApi, libraryTemplateData, libraryTemplateCode);\\n    }\\n  }\\n\\n  function createFrontend(string calldata name, string calldata symbol) public onlyRole(MINTER_ROLE) returns (address) {\\n    require(frontendAddress == address(0), 'frontend already created');\\n    frontendAddress = Clones.clone(clonableTokenAddress);\\n\\n    INamelessToken frontend = INamelessToken(frontendAddress);\\n    frontend.initialize(name, symbol, address(this), msg.sender);\\n\\n    return frontendAddress;\\n  }\\n\\n  /**\\n    * @dev See {IERC165-supportsInterface}.\\n    */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override( AccessControl) returns (bool) {\\n    return AccessControl.supportsInterface(interfaceId);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/utils/Base64.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n// Adapted from OpenZeppelin public expiriment\\n// @dev see https://github.com/OpenZeppelin/solidity-jwt/blob/2a787f1c12c50da649eed1670b3a6d9c0221dd8e/contracts/Base64.sol for original\\npragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n\\n    bytes constant private BASE_64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory buffer, bytes memory output, uint outOffset) public pure returns (uint) {\\n      uint outLen = (buffer.length + 2) / 3 * 4;\\n\\n      uint256 i = 0;\\n      uint256 j = outOffset;\\n\\n      for (; i + 3 <= buffer.length; i += 3) {\\n          (output[j], output[j+1], output[j+2], output[j+3]) = encode3(\\n              uint8(buffer[i]),\\n              uint8(buffer[i+1]),\\n              uint8(buffer[i+2])\\n          );\\n\\n          j += 4;\\n      }\\n\\n      if (i + 2 == buffer.length) {\\n        (output[j], output[j+1], output[j+2], ) = encode3(\\n            uint8(buffer[i]),\\n            uint8(buffer[i+1]),\\n            0\\n        );\\n        output[j+3] = '=';\\n      } else if (i + 1 == buffer.length) {\\n        (output[j], output[j+1], , ) = encode3(\\n            uint8(buffer[i]),\\n            0,\\n            0\\n        );\\n        output[j+2] = '=';\\n        output[j+3] = '=';\\n      }\\n\\n      return outOffset + outLen;\\n    }\\n\\n    function encode(bytes memory buffer) public pure returns (bytes memory) {\\n      uint outLen = (buffer.length + 2) / 3 * 4;\\n      bytes memory result = new bytes(outLen);\\n\\n      uint256 i = 0;\\n      uint256 j = 0;\\n\\n      for (; i + 3 <= buffer.length; i += 3) {\\n          (result[j], result[j+1], result[j+2], result[j+3]) = encode3(\\n              uint8(buffer[i]),\\n              uint8(buffer[i+1]),\\n              uint8(buffer[i+2])\\n          );\\n\\n          j += 4;\\n      }\\n\\n      if (i + 2 == buffer.length) {\\n        (result[j], result[j+1], result[j+2], ) = encode3(\\n            uint8(buffer[i]),\\n            uint8(buffer[i+1]),\\n            0\\n        );\\n        result[j+3] = '=';\\n      } else if (i + 1 == buffer.length) {\\n        (result[j], result[j+1], , ) = encode3(\\n            uint8(buffer[i]),\\n            0,\\n            0\\n        );\\n        result[j+2] = '=';\\n        result[j+3] = '=';\\n      }\\n\\n      return result;\\n    }\\n\\n    function encode(uint256 bigint, bytes memory output, uint outOffset) external pure returns (uint) {\\n        bytes32 buffer = bytes32(bigint);\\n\\n        uint256 i = 0;\\n        uint256 j = outOffset;\\n\\n        for (; i + 3 <= 32; i += 3) {\\n            (output[j], output[j+1], output[j+2], output[j+3]) = encode3(\\n                uint8(buffer[i]),\\n                uint8(buffer[i+1]),\\n                uint8(buffer[i+2])\\n            );\\n\\n            j += 4;\\n        }\\n        (output[j], output[j+1], output[j+2], ) = encode3(uint8(buffer[30]), uint8(buffer[31]), 0);\\n        return outOffset + 43;\\n    }\\n\\n    function encode(uint256 bigint) external pure returns (string memory) {\\n        bytes32 buffer = bytes32(bigint);\\n        bytes memory res = new bytes(43);\\n\\n        uint256 i = 0;\\n        uint256 j = 0;\\n\\n        for (; i + 3 <= 32; i += 3) {\\n            (res[j], res[j+1], res[j+2], res[j+3]) = encode3(\\n                uint8(buffer[i]),\\n                uint8(buffer[i+1]),\\n                uint8(buffer[i+2])\\n            );\\n\\n            j += 4;\\n        }\\n        (res[j], res[j+1], res[j+2], ) = encode3(uint8(buffer[30]), uint8(buffer[31]), 0);\\n        return string(res);\\n    }\\n\\n    function encode3(uint256 a0, uint256 a1, uint256 a2)\\n        private\\n        pure\\n        returns (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3)\\n    {\\n\\n        uint256 n = (a0 << 16) | (a1 << 8) | a2;\\n\\n        uint256 c0 = (n >> 18) & 63;\\n        uint256 c1 = (n >> 12) & 63;\\n        uint256 c2 = (n >>  6) & 63;\\n        uint256 c3 = (n      ) & 63;\\n\\n        b0 = BASE_64_CHARS[c0];\\n        b1 = BASE_64_CHARS[c1];\\n        b2 = BASE_64_CHARS[c2];\\n        b3 = BASE_64_CHARS[c3];\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/utils/BinaryDecoder.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary BinaryDecoder {\\n    function increment(uint bufferIdx, uint offset, uint amount) internal pure returns (uint, uint) {\\n      offset+=amount;\\n      return (bufferIdx + (offset / 32), offset % 32);\\n    }\\n\\n    function decodeUint8(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint8, uint, uint) {\\n      uint8 result = 0;\\n      result |= uint8(buffers[bufferIdx][offset]);\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (result, bufferIdx, offset);\\n    }\\n\\n    function decodeUint16(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint16, uint, uint) {\\n      uint result = 0;\\n      if (offset % 32 < 31) {\\n        return decodeUint16Aligned(buffers, bufferIdx, offset);\\n      }\\n\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (uint16(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint16Aligned(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint16, uint, uint) {\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 1]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 2);\\n      return (uint16(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint32(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint32, uint, uint) {\\n      if (offset % 32 < 29) {\\n        return decodeUint32Aligned(buffers, bufferIdx, offset);\\n      }\\n\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 24;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 16;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (uint32(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint32Aligned(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint32, uint, uint) {\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 24;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 1])) << 16;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 2])) << 8;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 3]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 4);\\n      return (uint32(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint64(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint64, uint, uint) {\\n      if (offset % 32 < 25) {\\n        return decodeUint64Aligned(buffers, bufferIdx, offset);\\n      }\\n\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 56;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 48;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 40;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 32;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 24;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 16;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (uint64(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint64Aligned(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint64, uint, uint) {\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 56;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 1])) << 48;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 2])) << 40;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 3])) << 32;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 4])) << 24;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 5])) << 16;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 6])) << 8;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 7]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 8);\\n      return (uint64(result), bufferIdx, offset);\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/utils/PackedVarArray.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './BinaryDecoder.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\nlibrary PackedVarArray {\\n  function getString(bytes32[0xFFFF] storage buffers, uint offset, uint len) internal view returns (string memory) {\\n    bytes memory result = new bytes(len);\\n\\n    uint bufferIdx = offset / 32;\\n    uint bufferOffset = offset % 32;\\n    uint outIdx = 0;\\n    uint remaining = len;\\n    uint bufferCap = 32 - bufferOffset;\\n\\n\\n    while (outIdx < len) {\\n      uint copyCount = remaining > bufferCap ? bufferCap : remaining;\\n      uint lastOffset = bufferOffset + copyCount;\\n      bytes32 buffer = bytes32(buffers[bufferIdx]);\\n      while( bufferOffset < lastOffset) {\\n        result[outIdx++] = buffer[bufferOffset++];\\n      }\\n      remaining -= copyCount;\\n      bufferCap = 32;\\n      bufferOffset = 0;\\n      bufferIdx++;\\n    }\\n\\n    return string(result);\\n  }\\n\\n  function getString(bytes32[0xFFFF] storage buffers, uint index) internal view returns (string memory) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint stringOffsetLen;\\n    (stringOffsetLen,,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint stringOffset = stringOffsetLen & 0xFFFF;\\n    uint stringLen = stringOffsetLen >> 16;\\n\\n    return getString(buffers, stringOffset, stringLen);\\n  }\\n\\n  function getStringInfo(bytes32[0xFFFF] storage buffers, uint index) internal view returns ( bytes32 firstSlot, uint offset, uint length ) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint stringOffsetLen;\\n    (stringOffsetLen,,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint stringOffset = stringOffsetLen & 0xFFFF;\\n    uint stringLen = stringOffsetLen >> 16;\\n    uint bufferIdx = stringOffset / 32;\\n    uint bufferOffset = stringOffset % 32;\\n    bytes32 bufferSlot;\\n\\n    //solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      bufferSlot := buffers.slot\\n    }\\n\\n    bufferSlot = bytes32(uint(bufferSlot) +  bufferIdx);\\n\\n\\n    return (bufferSlot, bufferOffset, stringLen);\\n  }\\n\\n  function getStringLength(bytes32[0xFFFF] storage buffers, uint index) internal view returns (uint) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint stringOffsetLen;\\n    (stringOffsetLen,,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    return stringOffsetLen >> 24;\\n  }\\n\\n  function getUint16Array(bytes32[0xFFFF] storage buffers, uint offset, uint len) internal view returns (uint16[] memory) {\\n    uint16[] memory result = new uint16[](len);\\n\\n    uint bufferIdx = offset / 32;\\n    uint bufferOffset = offset % 32;\\n    uint outIdx = 0;\\n    uint remaining = len * 2;\\n    uint bufferCap = 32 - bufferOffset;\\n\\n\\n    while (outIdx < len) {\\n      uint copyCount = remaining > bufferCap ? bufferCap : remaining;\\n      uint lastOffset = bufferOffset + copyCount;\\n      bytes32 buffer = bytes32(buffers[bufferIdx]);\\n      while (bufferOffset < lastOffset) {\\n        result[outIdx]  = uint16(uint8(buffer[bufferOffset++])) << 8;\\n        result[outIdx] |= uint16(uint8(buffer[bufferOffset++]));\\n        outIdx++;\\n      }\\n      remaining -= copyCount;\\n      bufferCap = 32;\\n      bufferOffset = 0;\\n      bufferIdx++;\\n    }\\n\\n    return result;\\n  }\\n\\n  function getUint16Array(bytes32[0xFFFF] storage buffers, uint index) internal view returns (uint16[] memory) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint arrOffsetLen;\\n    (arrOffsetLen, ,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint arrOffset = arrOffsetLen & 0xFFFFFF;\\n    uint arrLen = arrOffsetLen >> 24;\\n\\n    return getUint16Array(buffers, arrOffset, arrLen);\\n  }\\n\\n  function getUint16ArrayInfo(bytes32[0xFFFF] storage buffers, uint index) internal view returns ( uint, uint, uint ) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint arrOffsetLen;\\n    (arrOffsetLen, ,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint arrOffset = arrOffsetLen & 0xFFFFFF;\\n    uint arrLen = arrOffsetLen >> 24;\\n    uint bufferIdx = arrOffset / 32;\\n    uint bufferOffset = arrOffset % 32;\\n\\n    return (bufferIdx, bufferOffset, arrLen);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if(!hasRole(role, account)) {\\n            revert(string(abi.encodePacked(\\n                \\\"AccessControl: account \\\",\\n                Strings.toHexString(uint160(account), 20),\\n                \\\" is missing role \\\",\\n                Strings.toHexString(uint256(role), 32)\\n            )));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessMetadataURIV1.sol\": {\r\n        \"NamelessMetadataURIV1\": \"0xe1EB3d8E3cFdBdef8d56480f257a037c19f0B6BC\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"templateLibrary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"clonableTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxGenerationSize_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INFRA_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_REDEEMABLE_EXTENSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_REDEMPTION_EXTENSION_COUNT_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_COUNT_EXTENSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_COUNT_EXTENSION_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_TIME_EXTENSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_TIME_EXTENSION_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"beforeTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clonableTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"generation\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"columnHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"columnType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataOffset\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"data\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct NamelessTokenData.ColumnConfiguration[]\",\"name\":\"configs\",\"type\":\"tuple[]\"}],\"name\":\"configureData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"createFrontend\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"generation\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"newExtensions\",\"type\":\"uint256\"}],\"name\":\"enableExtensions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extensions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frontendAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"generationSealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getFeeBps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getFeeRecipients\",\"outputs\":[{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getTokenMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"templateLibrary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"clonableTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxGenerationSize_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGenerationSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"generation\",\"type\":\"uint32\"}],\"name\":\"sealGeneration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"generation\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_data\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_code\",\"type\":\"bytes32[]\"}],\"name\":\"setCustomTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"generation\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"which\",\"type\":\"uint256\"}],\"name\":\"setLibraryTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newRoyaltyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newRoyaltyBps\",\"type\":\"uint256\"}],\"name\":\"setRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uriBase_\",\"type\":\"string\"}],\"name\":\"setURIBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templateCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templateData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"templateIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NamelessTokenData","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}