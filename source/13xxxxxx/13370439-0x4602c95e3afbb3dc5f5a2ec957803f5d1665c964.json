{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/Counters.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /*\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner);\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: solidity-rlp/contracts/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem item;   // Item that's being iterated over.\r\n        uint nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\r\n    * @param self The iterator.\r\n    * @return The next element in the iteration.\r\n    */\r\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\r\n        require(hasNext(self));\r\n\r\n        uint ptr = self.nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        self.nextPtr = ptr + itemLength;\r\n\r\n        return RLPItem(itemLength, ptr);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the iteration has more elements.\r\n    * @param self The iterator.\r\n    * @return true if the iteration has more elements.\r\n    */\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self.item;\r\n        return self.nextPtr < item.memPtr + item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @dev Create an iterator. Reverts if item is not a list.\r\n    * @param self The RLP item.\r\n    * @return An 'Iterator' over the item.\r\n    */\r\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\r\n        require(isList(self));\r\n\r\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\r\n        return Iterator(self, ptr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len - _payloadOffset(item.memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    // any non-zero byte is considered true\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    * Private Helpers\r\n    */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) private pure returns (uint) {\r\n        uint itemLen;\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            itemLen = 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            itemLen = byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            itemLen = byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/Merkle.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\nlibrary Merkle {\r\n    function checkMembership(\r\n        bytes32 leaf,\r\n        uint256 index,\r\n        bytes32 rootHash,\r\n        bytes memory proof\r\n    ) internal pure returns (bool) {\r\n        require(proof.length % 32 == 0, \"Invalid proof length\");\r\n        uint256 proofHeight = proof.length / 32;\r\n        // Proof of size n means, height of the tree is n+1.\r\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\r\n        require(index < 2 ** proofHeight, \"Leaf index is too big\");\r\n\r\n        bytes32 proofElement;\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 32; i <= proof.length; i += 32) {\r\n            assembly {\r\n                proofElement := mload(add(proof, i))\r\n            }\r\n\r\n            if (index % 2 == 0) {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(computedHash, proofElement)\r\n                );\r\n            } else {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(proofElement, computedHash)\r\n                );\r\n            }\r\n\r\n            index = index / 2;\r\n        }\r\n        return computedHash == rootHash;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/MerklePatriciaProof.sol\r\n\r\n/*\r\n * @title MerklePatriciaVerifier\r\n * @author Sam Mayo (sammayo888@gmail.com)\r\n *\r\n * @dev Library for verifing merkle patricia proofs.\r\n */\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary MerklePatriciaProof {\r\n    /*\r\n   * @dev Verifies a merkle patricia proof.\r\n   * @param value The terminating value in the trie.\r\n   * @param encodedPath The path in the trie leading to value.\r\n   * @param rlpParentNodes The rlp encoded stack of nodes.\r\n   * @param root The root hash of the trie.\r\n   * @return The boolean validity of the proof.\r\n   */\r\n    function verify(\r\n        bytes memory value,\r\n        bytes memory encodedPath,\r\n        bytes memory rlpParentNodes,\r\n        bytes32 root\r\n    ) internal pure returns (bool) {\r\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\r\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLPReader.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint256 pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray(encodedPath);\r\n        if (path.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint256 i = 0; i < parentNodes.length; i++) {\r\n            if (pathPtr > path.length) {\r\n                return false;\r\n            }\r\n\r\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\r\n            if (nodeKey != keccak256(currentNode)) {\r\n                return false;\r\n            }\r\n            currentNodeList = RLPReader.toList(parentNodes[i]);\r\n\r\n            if (currentNodeList.length == 17) {\r\n                if (pathPtr == path.length) {\r\n                    if (\r\n                        keccak256(RLPReader.toBytes(currentNodeList[16])) ==\r\n                        keccak256(value)\r\n                    ) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if (nextPathNibble > 16) {\r\n                    return false;\r\n                }\r\n                nodeKey = bytes32(\r\n                    RLPReader.toUintStrict(currentNodeList[nextPathNibble])\r\n                );\r\n                pathPtr += 1;\r\n            } else if (currentNodeList.length == 2) {\r\n                uint256 traversed = _nibblesToTraverse(\r\n                    RLPReader.toBytes(currentNodeList[0]),\r\n                    path,\r\n                    pathPtr\r\n                );\r\n                if (pathPtr + traversed == path.length) {\r\n                    //leaf node\r\n                    if (\r\n                        keccak256(RLPReader.toBytes(currentNodeList[1])) ==\r\n                        keccak256(value)\r\n                    ) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                //extension node\r\n                if (traversed == 0) {\r\n                    return false;\r\n                }\r\n\r\n                pathPtr += traversed;\r\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _nibblesToTraverse(\r\n        bytes memory encodedPartialPath,\r\n        bytes memory path,\r\n        uint256 pathPtr\r\n    ) private pure returns (uint256) {\r\n        uint256 len;\r\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\r\n        // and slicedPath have elements that are each one hex character (1 nibble)\r\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\r\n        bytes memory slicedPath = new bytes(partialPath.length);\r\n\r\n        // pathPtr counts nibbles in path\r\n        // partialPath.length is a number of nibbles\r\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\r\n            bytes1 pathNibble = path[i];\r\n            slicedPath[i - pathPtr] = pathNibble;\r\n        }\r\n\r\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\r\n            len = partialPath.length;\r\n        } else {\r\n            len = 0;\r\n        }\r\n        return len;\r\n    }\r\n\r\n    // bytes b must be hp encoded\r\n    function _getNibbleArray(bytes memory b)\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory nibbles;\r\n        if (b.length > 0) {\r\n            uint8 offset;\r\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\r\n            if (hpNibble == 1 || hpNibble == 3) {\r\n                nibbles = new bytes(b.length * 2 - 1);\r\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\r\n                nibbles[0] = oddNibble;\r\n                offset = 1;\r\n            } else {\r\n                nibbles = new bytes(b.length * 2 - 2);\r\n                offset = 0;\r\n            }\r\n\r\n            for (uint256 i = offset; i < nibbles.length; i++) {\r\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\r\n            }\r\n        }\r\n        return nibbles;\r\n    }\r\n\r\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str)\r\n        private\r\n        pure\r\n        returns (bytes1)\r\n    {\r\n        return\r\n            bytes1(\r\n                n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10\r\n            );\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/PriorityQueue.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title PriorityQueue\r\n * @dev A priority queue implementation.\r\n */\r\ncontract PriorityQueue is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256[] heapList;\r\n    uint256 public currentSize;\r\n\r\n    constructor() public {\r\n        heapList = [0];\r\n    }\r\n\r\n    /**\r\n  * @dev Inserts an element into the priority queue.\r\n  * @param _priority Priority to insert.\r\n  * @param _value Some additional value.\r\n  */\r\n    function insert(uint256 _priority, uint256 _value) public onlyOwner {\r\n        uint256 element = (_priority << 128) | _value;\r\n        heapList.push(element);\r\n        currentSize = currentSize.add(1);\r\n        _percUp(currentSize);\r\n    }\r\n\r\n    /**\r\n  * @dev Returns the top element of the heap.\r\n  * @return The smallest element in the priority queue.\r\n  */\r\n    function getMin() public view returns (uint256, uint256) {\r\n        return _splitElement(heapList[1]);\r\n    }\r\n\r\n    /**\r\n  * @dev Deletes the top element of the heap and shifts everything up.\r\n  * @return The smallest element in the priorty queue.\r\n  */\r\n    function delMin() public onlyOwner returns (uint256, uint256) {\r\n        uint256 retVal = heapList[1];\r\n        heapList[1] = heapList[currentSize];\r\n        delete heapList[currentSize];\r\n        currentSize = currentSize.sub(1);\r\n        _percDown(1);\r\n        heapList.length = heapList.length.sub(1);\r\n        return _splitElement(retVal);\r\n    }\r\n\r\n    /**\r\n  * @dev Determines the minimum child of a given node in the tree.\r\n  * @param _index Index of the node in the tree.\r\n  * @return The smallest child node.\r\n  */\r\n    function _minChild(uint256 _index) private view returns (uint256) {\r\n        if (_index.mul(2).add(1) > currentSize) {\r\n            return _index.mul(2);\r\n        } else {\r\n            if (heapList[_index.mul(2)] < heapList[_index.mul(2).add(1)]) {\r\n                return _index.mul(2);\r\n            } else {\r\n                return _index.mul(2).add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Bubbles the element at some index up.\r\n   */\r\n    function _percUp(uint256 _index) private {\r\n        uint256 index = _index;\r\n        uint256 j = index;\r\n        uint256 newVal = heapList[index];\r\n\r\n        while (newVal < heapList[index.div(2)]) {\r\n            heapList[index] = heapList[index.div(2)];\r\n            index = index.div(2);\r\n        }\r\n\r\n        if (index != j) {\r\n            heapList[index] = newVal;\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Bubbles the element at some index down.\r\n   */\r\n    function _percDown(uint256 _index) private {\r\n        uint256 index = _index;\r\n        uint256 j = index;\r\n        uint256 newVal = heapList[index];\r\n        uint256 mc = _minChild(index);\r\n        while (mc <= currentSize && newVal > heapList[mc]) {\r\n            heapList[index] = heapList[mc];\r\n            index = mc;\r\n            mc = _minChild(index);\r\n        }\r\n\r\n        if (index != j) {\r\n            heapList[index] = newVal;\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Split an element into its priority and value.\r\n   * @param _element Element to decode.\r\n   * @return A tuple containing the priority and value.\r\n   */\r\n    function _splitElement(uint256 _element)\r\n        private\r\n        pure\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 priority = _element >> 128;\r\n        uint256 value = uint256(uint128(_element));\r\n        return (priority, value);\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/BytesLib.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(\r\n                        add(tempBytes, lengthmod),\r\n                        mul(0x20, iszero(lengthmod))\r\n                    )\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(\r\n                            add(\r\n                                add(_bytes, lengthmod),\r\n                                mul(0x20, iszero(lengthmod))\r\n                            ),\r\n                            _start\r\n                        )\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    // Pad a bytes array to 32 bytes\r\n    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        // may underflow if bytes.length < 32. Hence using SafeMath.sub\r\n        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\r\n        return concat(newBytes, _bytes);\r\n    }\r\n\r\n    function toBytes32(bytes memory b) internal pure returns (bytes32) {\r\n        require(b.length >= 32, \"Bytes array should atleast be 32 bytes\");\r\n        bytes32 out;\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            out |= bytes32(b[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\r\n        assembly {\r\n            result := mload(add(b, 32))\r\n        }\r\n    }\r\n\r\n    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\r\n        bytes memory b = new bytes(32);\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\r\n        }\r\n        return b;\r\n    }\r\n\r\n    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\r\n        _ret = new bytes(32);\r\n        assembly {\r\n            mstore(add(_ret, 32), _num)\r\n        }\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n        assembly {\r\n            tempAddress := div(\r\n                mload(add(add(_bytes, 0x20), _start)),\r\n                0x1000000000000000000000000\r\n            )\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/ExitPayloadReader.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\nlibrary ExitPayloadReader {\r\n  using RLPReader for bytes;\r\n  using RLPReader for RLPReader.RLPItem;\r\n\r\n  uint8 constant WORD_SIZE = 32;\r\n\r\n  struct ExitPayload {\r\n    RLPReader.RLPItem[] data;\r\n  }\r\n\r\n  struct Receipt {\r\n    RLPReader.RLPItem[] data;\r\n    bytes raw;\r\n    uint256 logIndex;\r\n  }\r\n\r\n  struct Log {\r\n    RLPReader.RLPItem data;\r\n    RLPReader.RLPItem[] list;\r\n  }\r\n\r\n  struct LogTopics {\r\n    RLPReader.RLPItem[] data;\r\n  }\r\n\r\n  function toExitPayload(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (ExitPayload memory)\r\n    {\r\n        RLPReader.RLPItem[] memory payloadData = data\r\n            .toRlpItem()\r\n            .toList();\r\n\r\n        return ExitPayload(payloadData);\r\n    }\r\n\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[0].toUint();\r\n    }\r\n\r\n    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[1].toBytes();\r\n    }\r\n\r\n    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[2].toUint();\r\n    }\r\n\r\n    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[3].toUint();\r\n    }\r\n\r\n    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {\r\n      return bytes32(payload.data[4].toUint());\r\n    }\r\n\r\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {\r\n      return bytes32(payload.data[5].toUint());\r\n    }\r\n\r\n    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {\r\n      receipt.raw = payload.data[6].toBytes();\r\n      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\r\n\r\n      if (receiptItem.isList()) {\r\n          // legacy tx\r\n          receipt.data = receiptItem.toList();\r\n      } else {\r\n          // pop first byte before parsting receipt\r\n          bytes memory typedBytes = receipt.raw;\r\n          bytes memory result = new bytes(typedBytes.length - 1);\r\n          uint256 srcPtr;\r\n          uint256 destPtr;\r\n          assembly {\r\n              srcPtr := add(33, typedBytes)\r\n              destPtr := add(0x20, result)\r\n          }\r\n\r\n          copy(srcPtr, destPtr, result.length);\r\n          receipt.data = result.toRlpItem().toList();\r\n      }\r\n\r\n      receipt.logIndex = getReceiptLogIndex(payload);\r\n      return receipt;\r\n    }\r\n\r\n    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[7].toBytes();\r\n    }\r\n\r\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[8].toBytes();\r\n    }\r\n\r\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[8].toUint();\r\n    }\r\n\r\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[9].toUint();\r\n    }\r\n\r\n    function getTx(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[10].toBytes();\r\n    }\r\n\r\n    function getTxProof(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[11].toBytes();\r\n    }\r\n    \r\n    // Receipt methods\r\n    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {\r\n        return receipt.raw;\r\n    }\r\n\r\n    function getLog(Receipt memory receipt) internal pure returns(Log memory) {\r\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\r\n        return Log(logData, logData.toList());\r\n    }\r\n\r\n    // Log methods\r\n    function getEmitter(Log memory log) internal pure returns(address) {\r\n      return RLPReader.toAddress(log.list[0]);\r\n    }\r\n\r\n    function getTopics(Log memory log) internal pure returns(LogTopics memory) {\r\n        return LogTopics(log.list[1].toList());\r\n    }\r\n\r\n    function getData(Log memory log) internal pure returns(bytes memory) {\r\n        return log.list[2].toBytes();\r\n    }\r\n\r\n    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {\r\n      return log.data.toRlpBytes();\r\n    }\r\n\r\n    // LogTopics methods\r\n    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {\r\n      return topics.data[index];\r\n    }\r\n}\r\n\r\n// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        _assertGovernance();\r\n        _;\r\n    }\r\n\r\n    function _assertGovernance() private view {\r\n        require(\r\n            msg.sender == address(governance),\r\n            \"Only governance contract is authorized\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/ExitNFT.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ExitNFT is ERC721 {\r\n    Registry internal registry;\r\n\r\n    modifier onlyWithdrawManager() {\r\n        require(\r\n            msg.sender == registry.getWithdrawManagerAddress(),\r\n            \"UNAUTHORIZED_WITHDRAW_MANAGER_ONLY\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n    }\r\n\r\n    function mint(address _owner, uint256 _tokenId)\r\n        external\r\n        onlyWithdrawManager\r\n    {\r\n        _mint(_owner, _tokenId);\r\n    }\r\n\r\n    function burn(uint256 _tokenId) external onlyWithdrawManager {\r\n        _burn(_tokenId);\r\n    }\r\n\r\n    function exists(uint256 tokenId) public view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must equal true).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\r\n        require(address(token).isContract());\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success);\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            require(abi.decode(returndata, (bool)));\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/tokens/WETH.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract WETH is ERC20 {\r\n    event Deposit(address indexed dst, uint256 wad);\r\n    event Withdrawal(address indexed src, uint256 wad);\r\n\r\n    function deposit() public payable;\r\n\r\n    function withdraw(uint256 wad) public;\r\n\r\n    function withdraw(uint256 wad, address user) public;\r\n}\r\n\r\n// File: contracts/root/depositManager/IDepositManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IDepositManager {\r\n    function depositEther() external payable;\r\n    function transferAssets(\r\n        address _token,\r\n        address _user,\r\n        uint256 _amountOrNFTId\r\n    ) external;\r\n    function depositERC20(address _token, uint256 _amount) external;\r\n    function depositERC721(address _token, uint256 _tokenId) external;\r\n}\r\n\r\n// File: contracts/common/misc/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ProxyStorage is Ownable {\r\n    address internal proxyTo;\r\n}\r\n\r\n// File: contracts/common/mixin/ChainIdMixin.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract ChainIdMixin {\r\n  bytes constant public networkId = hex\"3A99\";\r\n  uint256 constant public CHAINID = 15001;\r\n}\r\n\r\n// File: contracts/root/RootChainStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\ncontract RootChainHeader {\r\n    event NewHeaderBlock(\r\n        address indexed proposer,\r\n        uint256 indexed headerBlockId,\r\n        uint256 indexed reward,\r\n        uint256 start,\r\n        uint256 end,\r\n        bytes32 root\r\n    );\r\n    // housekeeping event\r\n    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);\r\n    struct HeaderBlock {\r\n        bytes32 root;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 createdAt;\r\n        address proposer;\r\n    }\r\n}\r\n\r\n\r\ncontract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {\r\n    bytes32 public heimdallId;\r\n    uint8 public constant VOTE_TYPE = 2;\r\n\r\n    uint16 internal constant MAX_DEPOSITS = 10000;\r\n    uint256 public _nextHeaderBlock = MAX_DEPOSITS;\r\n    uint256 internal _blockDepositId = 1;\r\n    mapping(uint256 => HeaderBlock) public headerBlocks;\r\n    Registry internal registry;\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        uint[3][] calldata sigs\r\n    ) external returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes calldata slashingInfoList) external returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function getRegistry() public view returns (address);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n\r\n    function delegatedAmount(uint256 validatorId) public view returns(uint256);\r\n\r\n    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;\r\n\r\n    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);\r\n\r\n    function delegatorsReward(uint256 validatorId) public view returns(uint256);\r\n\r\n    function dethroneAndStake(\r\n        address auctionUser,\r\n        uint256 heimdallFee,\r\n        uint256 validatorId,\r\n        uint256 auctionAmount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n}\r\n\r\n// File: contracts/root/IRootChain.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IRootChain {\r\n    function slash() external;\r\n\r\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)\r\n        external;\r\n    \r\n    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)\r\n        external;\r\n\r\n    function getLastChildBlock() external view returns (uint256);\r\n\r\n    function currentHeaderBlock() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/root/RootChain.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract RootChain is RootChainStorage, IRootChain {\r\n    using SafeMath for uint256;\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    modifier onlyDepositManager() {\r\n        require(msg.sender == registry.getDepositManagerAddress(), \"UNAUTHORIZED_DEPOSIT_MANAGER_ONLY\");\r\n        _;\r\n    }\r\n\r\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {\r\n        revert();\r\n    }\r\n\r\n    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {\r\n        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi\r\n            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));\r\n        require(CHAINID == _borChainID, \"Invalid bor chain id\");\r\n\r\n        require(_buildHeaderBlock(proposer, start, end, rootHash), \"INCORRECT_HEADER_DATA\");\r\n\r\n        // check if it is better to keep it in local storage instead\r\n        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());\r\n        uint256 _reward = stakeManager.checkSignatures(\r\n            end.sub(start).add(1),\r\n            /**  \r\n                prefix 01 to data \r\n                01 represents positive vote on data and 00 is negative vote\r\n                malicious validator can try to send 2/3 on negative vote so 01 is appended\r\n             */\r\n            keccak256(abi.encodePacked(bytes(hex\"01\"), data)),\r\n            accountHash,\r\n            proposer,\r\n            sigs\r\n        );\r\n\r\n        require(_reward != 0, \"Invalid checkpoint\");\r\n        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);\r\n        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);\r\n        _blockDepositId = 1;\r\n    }\r\n\r\n    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {\r\n        depositId = currentHeaderBlock().add(_blockDepositId);\r\n        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)\r\n        _blockDepositId = _blockDepositId.add(numDeposits);\r\n        require(\r\n            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed\r\n            _blockDepositId <= MAX_DEPOSITS,\r\n            \"TOO_MANY_DEPOSITS\"\r\n        );\r\n    }\r\n\r\n    function getLastChildBlock() external view returns (uint256) {\r\n        return headerBlocks[currentHeaderBlock()].end;\r\n    }\r\n\r\n    function slash() external {\r\n        //TODO: future implementation\r\n    }\r\n\r\n    function currentHeaderBlock() public view returns (uint256) {\r\n        return _nextHeaderBlock.sub(MAX_DEPOSITS);\r\n    }\r\n\r\n    function _buildHeaderBlock(\r\n        address proposer,\r\n        uint256 start,\r\n        uint256 end,\r\n        bytes32 rootHash\r\n    ) private returns (bool) {\r\n        uint256 nextChildBlock;\r\n        /*\r\n    The ID of the 1st header block is MAX_DEPOSITS.\r\n    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0\r\n    */\r\n        if (_nextHeaderBlock > MAX_DEPOSITS) {\r\n            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;\r\n        }\r\n        if (nextChildBlock != start) {\r\n            return false;\r\n        }\r\n\r\n        HeaderBlock memory headerBlock = HeaderBlock({\r\n            root: rootHash,\r\n            start: nextChildBlock,\r\n            end: end,\r\n            createdAt: now,\r\n            proposer: proposer\r\n        });\r\n\r\n        headerBlocks[_nextHeaderBlock] = headerBlock;\r\n        return true;\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function setNextHeaderBlock(uint256 _value) public onlyOwner {\r\n        require(_value % MAX_DEPOSITS == 0, \"Invalid value\");\r\n        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {\r\n            delete headerBlocks[i];\r\n        }\r\n        _nextHeaderBlock = _value;\r\n        _blockDepositId = 1;\r\n        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function setHeimdallId(string memory _heimdallId) public onlyOwner {\r\n        heimdallId = keccak256(abi.encodePacked(_heimdallId));\r\n    }\r\n}\r\n\r\n// File: contracts/root/stateSyncer/StateSender.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract StateSender is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public counter;\r\n    mapping(address => address) public registrations;\r\n\r\n    event NewRegistration(\r\n        address indexed user,\r\n        address indexed sender,\r\n        address indexed receiver\r\n    );\r\n    event RegistrationUpdated(\r\n        address indexed user,\r\n        address indexed sender,\r\n        address indexed receiver\r\n    );\r\n    event StateSynced(\r\n        uint256 indexed id,\r\n        address indexed contractAddress,\r\n        bytes data\r\n    );\r\n\r\n    modifier onlyRegistered(address receiver) {\r\n        require(registrations[receiver] == msg.sender, \"Invalid sender\");\r\n        _;\r\n    }\r\n\r\n    function syncState(address receiver, bytes calldata data)\r\n        external\r\n        onlyRegistered(receiver)\r\n    {\r\n        counter = counter.add(1);\r\n        emit StateSynced(counter, receiver, data);\r\n    }\r\n\r\n    // register new contract for state sync\r\n    function register(address sender, address receiver) public {\r\n        require(\r\n            isOwner() || registrations[receiver] == msg.sender,\r\n            \"StateSender.register: Not authorized to register\"\r\n        );\r\n        registrations[receiver] = sender;\r\n        if (registrations[receiver] == address(0)) {\r\n            emit NewRegistration(msg.sender, sender, receiver);\r\n        } else {\r\n            emit RegistrationUpdated(msg.sender, sender, receiver);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Lockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Lockable {\r\n    bool public locked;\r\n\r\n    modifier onlyWhenUnlocked() {\r\n        _assertUnlocked();\r\n        _;\r\n    }\r\n\r\n    function _assertUnlocked() private view {\r\n        require(!locked, \"locked\");\r\n    }\r\n\r\n    function lock() public {\r\n        locked = true;\r\n    }\r\n\r\n    function unlock() public {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/GovernanceLockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract GovernanceLockable is Lockable, Governable {\r\n    constructor(address governance) public Governable(governance) {}\r\n\r\n    function lock() public onlyGovernance {\r\n        super.lock();\r\n    }\r\n\r\n    function unlock() public onlyGovernance {\r\n        super.unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/root/depositManager/DepositManagerStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DepositManagerHeader {\r\n    event NewDepositBlock(address indexed owner, address indexed token, uint256 amountOrNFTId, uint256 depositBlockId);\r\n    event MaxErc20DepositUpdate(uint256 indexed oldLimit, uint256 indexed newLimit);\r\n\r\n    struct DepositBlock {\r\n        bytes32 depositHash;\r\n        uint256 createdAt;\r\n    }\r\n}\r\n\r\n\r\ncontract DepositManagerStorage is ProxyStorage, GovernanceLockable, DepositManagerHeader {\r\n    Registry public registry;\r\n    RootChain public rootChain;\r\n    StateSender public stateSender;\r\n\r\n    mapping(uint256 => DepositBlock) public deposits;\r\n\r\n    address public childChain;\r\n    uint256 public maxErc20Deposit = 100 * (10**18);\r\n}\r\n\r\n// File: contracts/root/depositManager/DepositManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DepositManager is DepositManagerStorage, IDepositManager, ERC721Holder {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    modifier isTokenMapped(address _token) {\r\n        require(registry.isTokenMapped(_token), \"TOKEN_NOT_SUPPORTED\");\r\n        _;\r\n    }\r\n\r\n    modifier isPredicateAuthorized() {\r\n        require(uint8(registry.predicates(msg.sender)) != 0, \"Not a valid predicate\");\r\n        _;\r\n    }\r\n\r\n    constructor() public GovernanceLockable(address(0x0)) {}\r\n\r\n    // deposit ETH by sending to this contract\r\n    function() external payable {\r\n        depositEther();\r\n    }\r\n\r\n    function updateMaxErc20Deposit(uint256 maxDepositAmount) public onlyGovernance {\r\n        require(maxDepositAmount != 0);\r\n        emit MaxErc20DepositUpdate(maxErc20Deposit, maxDepositAmount);\r\n        maxErc20Deposit = maxDepositAmount;\r\n    }\r\n\r\n    function transferAssets(\r\n        address _token,\r\n        address _user,\r\n        uint256 _amountOrNFTId\r\n    ) external isPredicateAuthorized {\r\n        address wethToken = registry.getWethTokenAddress();\r\n        if (registry.isERC721(_token)) {\r\n            IERC721(_token).transferFrom(address(this), _user, _amountOrNFTId);\r\n        } else if (_token == wethToken) {\r\n            WETH t = WETH(_token);\r\n            t.withdraw(_amountOrNFTId, _user);\r\n        } else {\r\n            require(IERC20(_token).transfer(_user, _amountOrNFTId), \"TRANSFER_FAILED\");\r\n        }\r\n    }\r\n\r\n    function depositERC20(address _token, uint256 _amount) external {\r\n        depositERC20ForUser(_token, msg.sender, _amount);\r\n    }\r\n\r\n    function depositERC721(address _token, uint256 _tokenId) external {\r\n        depositERC721ForUser(_token, msg.sender, _tokenId);\r\n    }\r\n\r\n    function depositBulk(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amountOrTokens,\r\n        address _user\r\n    )\r\n        external\r\n        onlyWhenUnlocked // unlike other deposit functions, depositBulk doesn't invoke _safeCreateDepositBlock\r\n    {\r\n        require(_tokens.length == _amountOrTokens.length, \"Invalid Input\");\r\n        uint256 depositId = rootChain.updateDepositId(_tokens.length);\r\n        Registry _registry = registry;\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            // will revert if token is not mapped\r\n            if (_registry.isTokenMappedAndIsErc721(_tokens[i])) {\r\n                _safeTransferERC721(msg.sender, _tokens[i], _amountOrTokens[i]);\r\n            } else {\r\n                IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amountOrTokens[i]);\r\n            }\r\n\r\n            _createDepositBlock(_user, _tokens[i], _amountOrTokens[i], depositId);\r\n            depositId = depositId.add(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Caches childChain and stateSender (frequently used variables) from registry\r\n     */\r\n    function updateChildChainAndStateSender() public {\r\n        (address _childChain, address _stateSender) = registry.getChildChainAndStateSender();\r\n        require(\r\n            _stateSender != address(stateSender) || _childChain != childChain,\r\n            \"Atleast one of stateSender or childChain address should change\"\r\n        );\r\n        childChain = _childChain;\r\n        stateSender = StateSender(_stateSender);\r\n    }\r\n\r\n    function depositERC20ForUser(\r\n        address _token,\r\n        address _user,\r\n        uint256 _amount\r\n    ) public {\r\n        require(_amount <= maxErc20Deposit, \"exceed maximum deposit amount\");\r\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\r\n        _safeCreateDepositBlock(_user, _token, _amount);\r\n    }\r\n\r\n    function depositERC721ForUser(\r\n        address _token,\r\n        address _user,\r\n        uint256 _tokenId\r\n    ) public {\r\n        require(registry.isTokenMappedAndIsErc721(_token), \"not erc721\");\r\n\r\n        _safeTransferERC721(msg.sender, _token, _tokenId);\r\n        _safeCreateDepositBlock(_user, _token, _tokenId);\r\n    }\r\n\r\n    // @todo: write depositEtherForUser\r\n    function depositEther() public payable {\r\n        address wethToken = registry.getWethTokenAddress();\r\n        WETH t = WETH(wethToken);\r\n        t.deposit.value(msg.value)();\r\n        _safeCreateDepositBlock(msg.sender, wethToken, msg.value);\r\n    }\r\n\r\n    function _safeCreateDepositBlock(\r\n        address _user,\r\n        address _token,\r\n        uint256 _amountOrToken\r\n    ) internal onlyWhenUnlocked isTokenMapped(_token) {\r\n        _createDepositBlock(\r\n            _user,\r\n            _token,\r\n            _amountOrToken,\r\n            rootChain.updateDepositId(1) /* returns _depositId */\r\n        );\r\n    }\r\n\r\n    function _createDepositBlock(\r\n        address _user,\r\n        address _token,\r\n        uint256 _amountOrToken,\r\n        uint256 _depositId\r\n    ) internal {\r\n        deposits[_depositId] = DepositBlock(keccak256(abi.encodePacked(_user, _token, _amountOrToken)), now);\r\n        stateSender.syncState(childChain, abi.encode(_user, _token, _amountOrToken, _depositId));\r\n        emit NewDepositBlock(_user, _token, _amountOrToken, _depositId);\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function updateRootChain(address _rootChain) public onlyOwner {\r\n        rootChain = RootChain(_rootChain);\r\n    }\r\n\r\n    function _safeTransferERC721(address _user, address _token, uint256 _tokenId) private {\r\n        IERC721(_token).safeTransferFrom(_user, address(this), _tokenId);\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/Common.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary Common {\r\n    function getV(bytes memory v, uint16 chainId) public pure returns (uint8) {\r\n        if (chainId > 0) {\r\n            return\r\n                uint8(\r\n                    BytesLib.toUint(BytesLib.leftPad(v), 0) - (chainId * 2) - 8\r\n                );\r\n        } else {\r\n            return uint8(BytesLib.toUint(BytesLib.leftPad(v), 0));\r\n        }\r\n    }\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint256 length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n\r\n    // convert bytes to uint8\r\n    function toUint8(bytes memory _arg) public pure returns (uint8) {\r\n        return uint8(_arg[0]);\r\n    }\r\n\r\n    function toUint16(bytes memory _arg) public pure returns (uint16) {\r\n        return (uint16(uint8(_arg[0])) << 8) | uint16(uint8(_arg[1]));\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/RLPEncode.sol\r\n\r\n// Library for RLP encoding a list of bytes arrays.\r\n// Modeled after ethereumjs/rlp (https://github.com/ethereumjs/rlp)\r\n// [Very] modified version of Sam Mayo's library.\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary RLPEncode {\r\n    // Encode an item (bytes memory)\r\n    function encodeItem(bytes memory self)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory encoded;\r\n        if (self.length == 1 && uint8(self[0] & 0xFF) < 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = BytesLib.concat(encodeLength(self.length, 128), self);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    // Encode a list of items\r\n    function encodeList(bytes[] memory self)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory encoded;\r\n        for (uint256 i = 0; i < self.length; i++) {\r\n            encoded = BytesLib.concat(encoded, encodeItem(self[i]));\r\n        }\r\n        return BytesLib.concat(encodeLength(encoded.length, 192), encoded);\r\n    }\r\n\r\n    // Hack to encode nested lists. If you have a list as an item passed here, included\r\n    // pass = true in that index. E.g.\r\n    // [item, list, item] --> pass = [false, true, false]\r\n    // function encodeListWithPasses(bytes[] memory self, bool[] pass) internal pure returns (bytes memory) {\r\n    //   bytes memory encoded;\r\n    //   for (uint i=0; i < self.length; i++) {\r\n    // \t\tif (pass[i] == true) {\r\n    // \t\t\tencoded = BytesLib.concat(encoded, self[i]);\r\n    // \t\t} else {\r\n    // \t\t\tencoded = BytesLib.concat(encoded, encodeItem(self[i]));\r\n    // \t\t}\r\n    //   }\r\n    //   return BytesLib.concat(encodeLength(encoded.length, 192), encoded);\r\n    // }\r\n\r\n    // Generate the prefix for an item or the entire list based on RLP spec\r\n    function encodeLength(uint256 L, uint256 offset)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (L < 56) {\r\n            bytes memory prefix = new bytes(1);\r\n            prefix[0] = bytes1(uint8(L + offset));\r\n            return prefix;\r\n        } else {\r\n            // lenLen is the length of the hex representation of the data length\r\n            uint256 lenLen;\r\n            uint256 i = 0x1;\r\n\r\n            while (L / i != 0) {\r\n                lenLen++;\r\n                i *= 0x100;\r\n            }\r\n\r\n            bytes memory prefix0 = getLengthBytes(offset + 55 + lenLen);\r\n            bytes memory prefix1 = getLengthBytes(L);\r\n            return BytesLib.concat(prefix0, prefix1);\r\n        }\r\n    }\r\n\r\n    function getLengthBytes(uint256 x) internal pure returns (bytes memory b) {\r\n        // Figure out if we need 1 or two bytes to express the length.\r\n        // 1 byte gets us to max 255\r\n        // 2 bytes gets us to max 65535 (no payloads will be larger than this)\r\n        uint256 nBytes = 1;\r\n        if (x > 255) {\r\n            nBytes = 2;\r\n        }\r\n\r\n        b = new bytes(nBytes);\r\n        // Encode the length and return it\r\n        for (uint256 i = 0; i < nBytes; i++) {\r\n            b[i] = bytes1(uint8(x / (2**(8 * (nBytes - 1 - i)))));\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/WithdrawManagerStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ExitsDataStructure {\r\n    struct Input {\r\n        address utxoOwner;\r\n        address predicate;\r\n        address token;\r\n    }\r\n\r\n    struct PlasmaExit {\r\n        uint256 receiptAmountOrNFTId;\r\n        bytes32 txHash;\r\n        address owner;\r\n        address token;\r\n        bool isRegularExit;\r\n        address predicate;\r\n        // Mapping from age of input to Input\r\n        mapping(uint256 => Input) inputs;\r\n    }\r\n}\r\n\r\n\r\ncontract WithdrawManagerHeader is ExitsDataStructure {\r\n    event Withdraw(uint256 indexed exitId, address indexed user, address indexed token, uint256 amount);\r\n\r\n    event ExitStarted(\r\n        address indexed exitor,\r\n        uint256 indexed exitId,\r\n        address indexed token,\r\n        uint256 amount,\r\n        bool isRegularExit\r\n    );\r\n\r\n    event ExitUpdated(uint256 indexed exitId, uint256 indexed age, address signer);\r\n    event ExitPeriodUpdate(uint256 indexed oldExitPeriod, uint256 indexed newExitPeriod);\r\n\r\n    event ExitCancelled(uint256 indexed exitId);\r\n}\r\n\r\n\r\ncontract WithdrawManagerStorage is ProxyStorage, WithdrawManagerHeader {\r\n    // 0.5 week = 7 * 86400 / 2 = 302400\r\n    uint256 public HALF_EXIT_PERIOD = 302400;\r\n\r\n    // Bonded exits collaterized at 0.1 ETH\r\n    uint256 internal constant BOND_AMOUNT = 10**17;\r\n\r\n    Registry internal registry;\r\n    RootChain internal rootChain;\r\n\r\n    mapping(uint128 => bool) isKnownExit;\r\n    mapping(uint256 => PlasmaExit) public exits;\r\n    // mapping with token => (owner => exitId) keccak(token+owner) keccak(token+owner+tokenId)\r\n    mapping(bytes32 => uint256) public ownerExits;\r\n    mapping(address => address) public exitsQueues;\r\n    ExitNFT public exitNft;\r\n\r\n    // ERC721, ERC20 and Weth transfers require 155000, 100000, 52000 gas respectively\r\n    // Processing each exit in a while loop iteration requires ~52000 gas (@todo check if this changed)\r\n    // uint32 constant internal ITERATION_GAS = 52000;\r\n\r\n    // So putting an upper limit of 155000 + 52000 + leeway\r\n    uint32 public ON_FINALIZE_GAS_LIMIT = 300000;\r\n\r\n    uint256 public exitWindow;\r\n}\r\n\r\n// File: contracts/root/predicates/IPredicate.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IPredicate {\r\n    /**\r\n   * @notice Verify the deprecation of a state update\r\n   * @param exit ABI encoded PlasmaExit data\r\n   * @param inputUtxo ABI encoded Input UTXO data\r\n   * @param challengeData RLP encoded data of the challenge reference tx that encodes the following fields\r\n   * headerNumber Header block number of which the reference tx was a part of\r\n   * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root\r\n   * blockNumber Block number of which the reference tx is a part of\r\n   * blockTime Reference tx block time\r\n   * blocktxRoot Transactions root of block\r\n   * blockReceiptsRoot Receipts root of block\r\n   * receipt Receipt of the reference transaction\r\n   * receiptProof Merkle proof of the reference receipt\r\n   * branchMask Merkle proof branchMask for the receipt\r\n   * logIndex Log Index to read from the receipt\r\n   * tx Challenge transaction\r\n   * txProof Merkle proof of the challenge tx\r\n   * @return Whether or not the state is deprecated\r\n   */\r\n    function verifyDeprecation(\r\n        bytes calldata exit,\r\n        bytes calldata inputUtxo,\r\n        bytes calldata challengeData\r\n    ) external returns (bool);\r\n\r\n    function interpretStateUpdate(bytes calldata state)\r\n        external\r\n        view\r\n        returns (bytes memory);\r\n    function onFinalizeExit(bytes calldata data) external;\r\n}\r\n\r\ncontract PredicateUtils is ExitsDataStructure, ChainIdMixin {\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    // Bonded exits collaterized at 0.1 ETH\r\n    uint256 private constant BOND_AMOUNT = 10**17;\r\n\r\n    IWithdrawManager internal withdrawManager;\r\n    IDepositManager internal depositManager;\r\n\r\n    modifier onlyWithdrawManager() {\r\n        require(\r\n            msg.sender == address(withdrawManager),\r\n            \"ONLY_WITHDRAW_MANAGER\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isBondProvided() {\r\n        require(msg.value == BOND_AMOUNT, \"Invalid Bond amount\");\r\n        _;\r\n    }\r\n\r\n    function onFinalizeExit(bytes calldata data) external onlyWithdrawManager {\r\n        (, address token, address exitor, uint256 tokenId) = decodeExitForProcessExit(\r\n            data\r\n        );\r\n        depositManager.transferAssets(token, exitor, tokenId);\r\n    }\r\n\r\n    function sendBond() internal {\r\n        address(uint160(address(withdrawManager))).transfer(BOND_AMOUNT);\r\n    }\r\n\r\n    function getAddressFromTx(RLPReader.RLPItem[] memory txList)\r\n        internal\r\n        pure\r\n        returns (address signer, bytes32 txHash)\r\n    {\r\n        bytes[] memory rawTx = new bytes[](9);\r\n        for (uint8 i = 0; i <= 5; i++) {\r\n            rawTx[i] = txList[i].toBytes();\r\n        }\r\n        rawTx[6] = networkId;\r\n        rawTx[7] = hex\"\"; // [7] and [8] have something to do with v, r, s values\r\n        rawTx[8] = hex\"\";\r\n\r\n        txHash = keccak256(RLPEncode.encodeList(rawTx));\r\n        signer = ecrecover(\r\n            txHash,\r\n            Common.getV(txList[6].toBytes(), Common.toUint16(networkId)),\r\n            bytes32(txList[7].toUint()),\r\n            bytes32(txList[8].toUint())\r\n        );\r\n    }\r\n\r\n    function decodeExit(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (PlasmaExit memory)\r\n    {\r\n        (address owner, address token, uint256 amountOrTokenId, bytes32 txHash, bool isRegularExit) = abi\r\n            .decode(data, (address, address, uint256, bytes32, bool));\r\n        return\r\n            PlasmaExit(\r\n                amountOrTokenId,\r\n                txHash,\r\n                owner,\r\n                token,\r\n                isRegularExit,\r\n                address(0) /* predicate value is not required */\r\n            );\r\n    }\r\n\r\n    function decodeExitForProcessExit(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (uint256 exitId, address token, address exitor, uint256 tokenId)\r\n    {\r\n        (exitId, token, exitor, tokenId) = abi.decode(\r\n            data,\r\n            (uint256, address, address, uint256)\r\n        );\r\n    }\r\n\r\n    function decodeInputUtxo(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (uint256 age, address signer, address predicate, address token)\r\n    {\r\n        (age, signer, predicate, token) = abi.decode(\r\n            data,\r\n            (uint256, address, address, address)\r\n        );\r\n    }\r\n\r\n}\r\n\r\ncontract IErcPredicate is IPredicate, PredicateUtils {\r\n    enum ExitType {Invalid, OutgoingTransfer, IncomingTransfer, Burnt}\r\n\r\n    struct ExitTxData {\r\n        uint256 amountOrToken;\r\n        bytes32 txHash;\r\n        address childToken;\r\n        address signer;\r\n        ExitType exitType;\r\n    }\r\n\r\n    struct ReferenceTxData {\r\n        uint256 closingBalance;\r\n        uint256 age;\r\n        address childToken;\r\n        address rootToken;\r\n    }\r\n\r\n    uint256 internal constant MAX_LOGS = 10;\r\n\r\n    constructor(address _withdrawManager, address _depositManager) public {\r\n        withdrawManager = IWithdrawManager(_withdrawManager);\r\n        depositManager = IDepositManager(_depositManager);\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/WithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract WithdrawManager is WithdrawManagerStorage, IWithdrawManager {\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using Merkle for bytes32;\r\n\r\n    using ExitPayloadReader for bytes;\r\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\r\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\r\n    using ExitPayloadReader for ExitPayloadReader.Log;\r\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\r\n\r\n    modifier isBondProvided() {\r\n        require(msg.value == BOND_AMOUNT, \"Invalid Bond amount\");\r\n        _;\r\n    }\r\n\r\n    modifier isPredicateAuthorized() {\r\n        require(registry.predicates(msg.sender) != Registry.Type.Invalid, \"PREDICATE_NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier checkPredicateAndTokenMapping(address rootToken) {\r\n        Registry.Type _type = registry.predicates(msg.sender);\r\n        require(registry.rootToChildToken(rootToken) != address(0x0), \"rootToken not supported\");\r\n        if (_type == Registry.Type.ERC20) {\r\n            require(registry.isERC721(rootToken) == false, \"Predicate supports only ERC20 tokens\");\r\n        } else if (_type == Registry.Type.ERC721) {\r\n            require(registry.isERC721(rootToken) == true, \"Predicate supports only ERC721 tokens\");\r\n        } else if (_type == Registry.Type.Custom) {} else {\r\n            revert(\"PREDICATE_NOT_AUTHORIZED\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Receive bond for bonded exits\r\n     */\r\n    function() external payable {}\r\n\r\n    function createExitQueue(address token) external {\r\n        require(msg.sender == address(registry), \"UNAUTHORIZED_REGISTRY_ONLY\");\r\n        exitsQueues[token] = address(new PriorityQueue());\r\n    }\r\n\r\n    /**\r\n     During coverage tests verifyInclusion fails co compile with \"stack too deep\" error.\r\n     */\r\n    struct VerifyInclusionVars {\r\n        uint256 headerNumber;\r\n        uint256 blockNumber;\r\n        uint256 createdAt;\r\n        uint256 branchMask;\r\n        bytes32 txRoot;\r\n        bytes32 receiptRoot;\r\n        bytes branchMaskBytes;\r\n    }\r\n\r\n    /**\r\n     * @dev Verify the inclusion of the receipt in the checkpoint\r\n     * @param data RLP encoded data of the reference tx(s) that encodes the following fields for each tx\r\n     * headerNumber Header block number of which the reference tx was a part of\r\n     * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root\r\n     * blockNumber Block number of which the reference tx is a part of\r\n     * blockTime Reference tx block time\r\n     * blocktxRoot Transactions root of block\r\n     * blockReceiptsRoot Receipts root of block\r\n     * receipt Receipt of the reference transaction\r\n     * receiptProof Merkle proof of the reference receipt\r\n     * branchMask Merkle proof branchMask for the receipt\r\n     * logIndex Log Index to read from the receipt\r\n     * @param offset offset in the data array\r\n     * @param verifyTxInclusion Whether to also verify the inclusion of the raw tx in the txRoot\r\n     * @return ageOfInput Measure of the position of the receipt and the log in the child chain\r\n     */\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 /* ageOfInput */\r\n        )\r\n    {\r\n        ExitPayloadReader.ExitPayload memory payload = data.toExitPayload();\r\n        VerifyInclusionVars memory vars;\r\n\r\n        vars.headerNumber = payload.getHeaderNumber();\r\n        vars.branchMaskBytes = payload.getBranchMaskAsBytes();\r\n        require(vars.branchMaskBytes[0] == 0, \"incorrect mask\");\r\n        vars.txRoot = payload.getTxRoot();\r\n        vars.receiptRoot = payload.getReceiptRoot();\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                payload.getReceipt().toBytes(),\r\n                vars.branchMaskBytes,\r\n                payload.getReceiptProof(),\r\n                vars.receiptRoot\r\n            ),\r\n            \"INVALID_RECEIPT_MERKLE_PROOF\"\r\n        );\r\n\r\n        if (verifyTxInclusion) {\r\n            require(\r\n                MerklePatriciaProof.verify(\r\n                    payload.getTx(),\r\n                    vars.branchMaskBytes,\r\n                    payload.getTxProof(), \r\n                    vars.txRoot\r\n                ),\r\n                \"INVALID_TX_MERKLE_PROOF\"\r\n            );\r\n        }\r\n\r\n        vars.blockNumber = payload.getBlockNumber();\r\n        vars.createdAt = checkBlockMembershipInCheckpoint(\r\n            vars.blockNumber,\r\n            payload.getBlockTime(),\r\n            vars.txRoot,\r\n            vars.receiptRoot,\r\n            vars.headerNumber,\r\n            payload.getBlockProof()\r\n        );\r\n\r\n        vars.branchMask = payload.getBranchMaskAsUint();\r\n        require(\r\n            vars.branchMask & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000 == 0,\r\n            \"Branch mask should be 32 bits\"\r\n        );\r\n        // ageOfInput is denoted as\r\n        // 1 reserve bit (see last 2 lines in comment)\r\n        // 128 bits for exitableAt timestamp\r\n        // 95 bits for child block number\r\n        // 32 bits for receiptPos + logIndex * MAX_LOGS + oIndex\r\n        // In predicates, the exitId will be evaluated by shifting the ageOfInput left by 1 bit\r\n        // (Only in erc20Predicate) Last bit is to differentiate whether the sender or receiver of the in-flight tx is starting an exit\r\n        return (getExitableAt(vars.createdAt) << 127) | (vars.blockNumber << 32) | vars.branchMask;\r\n    }\r\n\r\n    function startExitWithDepositedTokens(\r\n        uint256 depositId,\r\n        address token,\r\n        uint256 amountOrToken\r\n    ) external payable isBondProvided {\r\n        // (bytes32 depositHash, uint256 createdAt) = getDepositManager().deposits(depositId);\r\n        // require(keccak256(abi.encodePacked(msg.sender, token, amountOrToken)) == depositHash, \"UNAUTHORIZED_EXIT\");\r\n        // uint256 ageOfInput = getExitableAt(createdAt) << 127 | (depositId % 10000 /* MAX_DEPOSITS */);\r\n        // uint256 exitId = ageOfInput << 1;\r\n        // address predicate = registry.isTokenMappedAndGetPredicate(token);\r\n        // _addExitToQueue(\r\n        //     msg.sender,\r\n        //     token,\r\n        //     amountOrToken,\r\n        //     bytes32(0), /* txHash */\r\n        //     false, /* isRegularExit */\r\n        //     exitId,\r\n        //     predicate\r\n        // );\r\n        // _addInput(\r\n        //     exitId,\r\n        //     ageOfInput,\r\n        //     msg.sender, /* utxoOwner */\r\n        //     predicate,\r\n        //     token\r\n        // );\r\n    }\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external checkPredicateAndTokenMapping(rootToken) {\r\n        require(registry.rootToChildToken(rootToken) == childToken, \"INVALID_ROOT_TO_CHILD_TOKEN_MAPPING\");\r\n        _addExitToQueue(exitor, rootToken, exitAmountOrTokenId, txHash, isRegularExit, priority, msg.sender);\r\n    }\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external {\r\n        PlasmaExit storage exit = exits[exitId];\r\n        Input storage input = exit.inputs[inputId];\r\n        require(exit.owner != address(0x0) && input.utxoOwner != address(0x0), \"Invalid exit or input id\");\r\n        require(registry.predicates(adjudicatorPredicate) != Registry.Type.Invalid, \"INVALID_PREDICATE\");\r\n        require(\r\n            IPredicate(adjudicatorPredicate).verifyDeprecation(\r\n                encodeExit(exit),\r\n                encodeInputUtxo(inputId, input),\r\n                challengeData\r\n            ),\r\n            \"Challenge failed\"\r\n        );\r\n        // In the call to burn(exitId), there is an implicit check that prevents challenging the same exit twice\r\n        ExitNFT(exitNft).burn(exitId);\r\n\r\n        // Send bond amount to challenger\r\n        msg.sender.send(BOND_AMOUNT);\r\n\r\n        // delete exits[exitId];\r\n        emit ExitCancelled(exitId);\r\n    }\r\n\r\n    function processExits(address _token) public {\r\n        uint256 exitableAt;\r\n        uint256 exitId;\r\n\r\n        PriorityQueue exitQueue = PriorityQueue(exitsQueues[_token]);\r\n\r\n        while (exitQueue.currentSize() > 0 && gasleft() > ON_FINALIZE_GAS_LIMIT) {\r\n            (exitableAt, exitId) = exitQueue.getMin();\r\n            exitId = (exitableAt << 128) | exitId;\r\n            PlasmaExit memory currentExit = exits[exitId];\r\n\r\n            // Stop processing exits if the exit that is next is queue is still in its challenge period\r\n            if (exitableAt > block.timestamp) return;\r\n\r\n            exitQueue.delMin();\r\n            // If the exitNft was deleted as a result of a challenge, skip processing this exit\r\n            if (!exitNft.exists(exitId)) continue;\r\n            address exitor = exitNft.ownerOf(exitId);\r\n            exits[exitId].owner = exitor;\r\n            exitNft.burn(exitId);\r\n            // If finalizing a particular exit is reverting, it will block any following exits from being processed.\r\n            // Hence, call predicate.onFinalizeExit in a revertless manner.\r\n            // (bool success, bytes memory result) =\r\n            currentExit.predicate.call(\r\n                abi.encodeWithSignature(\"onFinalizeExit(bytes)\", encodeExitForProcessExit(exitId))\r\n            );\r\n\r\n            emit Withdraw(exitId, exitor, _token, currentExit.receiptAmountOrNFTId);\r\n\r\n            if (!currentExit.isRegularExit) {\r\n                // return the bond amount if this was a MoreVp style exit\r\n                address(uint160(exitor)).send(BOND_AMOUNT);\r\n            }\r\n        }\r\n    }\r\n\r\n    function processExitsBatch(address[] calldata _tokens) external {\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            processExits(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add a state update (UTXO style input) to an exit\r\n     * @param exitId Exit ID\r\n     * @param age age of the UTXO style input\r\n     * @param utxoOwner User for whom the input acts as a proof-of-funds\r\n     * (alternate expression) User who could have potentially spent this UTXO\r\n     * @param token Token (Think of it like Utxo color)\r\n     */\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external isPredicateAuthorized {\r\n        PlasmaExit storage exitObject = exits[exitId];\r\n        require(exitObject.owner != address(0x0), \"INVALID_EXIT_ID\");\r\n        _addInput(\r\n            exitId,\r\n            age,\r\n            utxoOwner,\r\n            /* predicate */\r\n            msg.sender,\r\n            token\r\n        );\r\n    }\r\n\r\n    function _addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address predicate,\r\n        address token\r\n    ) internal {\r\n        exits[exitId].inputs[age] = Input(utxoOwner, predicate, token);\r\n        emit ExitUpdated(exitId, age, utxoOwner);\r\n    }\r\n\r\n    function encodeExit(PlasmaExit storage exit) internal view returns (bytes memory) {\r\n        return\r\n            abi.encode(\r\n                exit.owner,\r\n                registry.rootToChildToken(exit.token),\r\n                exit.receiptAmountOrNFTId,\r\n                exit.txHash,\r\n                exit.isRegularExit\r\n            );\r\n    }\r\n\r\n    function encodeExitForProcessExit(uint256 exitId) internal view returns (bytes memory) {\r\n        PlasmaExit storage exit = exits[exitId];\r\n        return abi.encode(exitId, exit.token, exit.owner, exit.receiptAmountOrNFTId);\r\n    }\r\n\r\n    function encodeInputUtxo(uint256 age, Input storage input) internal view returns (bytes memory) {\r\n        return abi.encode(age, input.utxoOwner, input.predicate, registry.rootToChildToken(input.token));\r\n    }\r\n\r\n    function _addExitToQueue(\r\n        address exitor,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 exitId,\r\n        address predicate\r\n    ) internal {\r\n        require(exits[exitId].token == address(0x0), \"EXIT_ALREADY_EXISTS\");\r\n        exits[exitId] = PlasmaExit(\r\n            exitAmountOrTokenId,\r\n            txHash,\r\n            exitor,\r\n            rootToken,\r\n            isRegularExit,\r\n            predicate\r\n        );\r\n        PlasmaExit storage _exitObject = exits[exitId];\r\n\r\n        bytes32 key = getKey(_exitObject.token, _exitObject.owner, _exitObject.receiptAmountOrNFTId);\r\n\r\n        if (isRegularExit) {\r\n            require(!isKnownExit[uint128(exitId)], \"KNOWN_EXIT\");\r\n            isKnownExit[uint128(exitId)] = true;\r\n        } else {\r\n            // a user cannot start 2 MoreVP exits for the same erc20 token or nft\r\n            require(ownerExits[key] == 0, \"EXIT_ALREADY_IN_PROGRESS\");\r\n            ownerExits[key] = exitId;\r\n        }\r\n\r\n        PriorityQueue queue = PriorityQueue(exitsQueues[_exitObject.token]);\r\n\r\n        // Way priority queue is implemented is such that it expects 2 uint256 params with most significant 128 bits masked out\r\n        // This is a workaround to split exitId, which otherwise is conclusive in itself\r\n        // exitId >> 128 gives 128 most significant bits\r\n        // uint256(uint128(exitId)) gives 128 least significant bits\r\n        // @todo Fix this mess\r\n        queue.insert(exitId >> 128, uint256(uint128(exitId)));\r\n\r\n        // create exit nft\r\n        exitNft.mint(_exitObject.owner, exitId);\r\n        emit ExitStarted(exitor, exitId, rootToken, exitAmountOrTokenId, isRegularExit);\r\n    }\r\n\r\n    function checkBlockMembershipInCheckpoint(\r\n        uint256 blockNumber,\r\n        uint256 blockTime,\r\n        bytes32 txRoot,\r\n        bytes32 receiptRoot,\r\n        uint256 headerNumber,\r\n        bytes memory blockProof\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 /* createdAt */\r\n        )\r\n    {\r\n        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = rootChain.headerBlocks(headerNumber);\r\n        require(\r\n            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\r\n                blockNumber - startBlock,\r\n                headerRoot,\r\n                blockProof\r\n            ),\r\n            \"WITHDRAW_BLOCK_NOT_A_PART_OF_SUBMITTED_HEADER\"\r\n        );\r\n        return createdAt;\r\n    }\r\n\r\n    function getKey(\r\n        address token,\r\n        address exitor,\r\n        uint256 amountOrToken\r\n    ) internal view returns (bytes32 key) {\r\n        if (registry.isERC721(token)) {\r\n            key = keccak256(abi.encodePacked(token, exitor, amountOrToken));\r\n        } else {\r\n            // validate amount\r\n            require(amountOrToken > 0, \"CANNOT_EXIT_ZERO_AMOUNTS\");\r\n            key = keccak256(abi.encodePacked(token, exitor));\r\n        }\r\n    }\r\n\r\n    function getDepositManager() internal view returns (DepositManager) {\r\n        return DepositManager(address(uint160(registry.getDepositManagerAddress())));\r\n    }\r\n\r\n    function getExitableAt(uint256 createdAt) internal view returns (uint256) {\r\n        return Math.max(createdAt + 2 * HALF_EXIT_PERIOD, now + HALF_EXIT_PERIOD);\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function updateExitPeriod(uint256 halfExitPeriod) public onlyOwner {\r\n        emit ExitPeriodUpdate(HALF_EXIT_PERIOD, halfExitPeriod);\r\n        HALF_EXIT_PERIOD = halfExitPeriod;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exitId\",\"type\":\"uint256\"}],\"name\":\"ExitCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldExitPeriod\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newExitPeriod\",\"type\":\"uint256\"}],\"name\":\"ExitPeriodUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exitor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exitId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRegularExit\",\"type\":\"bool\"}],\"name\":\"ExitStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exitId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"age\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"ExitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exitId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"HALF_EXIT_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ON_FINALIZE_GAS_LIMIT\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exitor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"childToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rootToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exitAmountOrTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isRegularExit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priority\",\"type\":\"uint256\"}],\"name\":\"addExitToQueue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"age\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"utxoOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addInput\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"challengeData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"adjudicatorPredicate\",\"type\":\"address\"}],\"name\":\"challengeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createExitQueue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitNft\",\"outputs\":[{\"internalType\":\"contract ExitNFT\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiptAmountOrNFTId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isRegularExit\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"predicate\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exitsQueues\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ownerExits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"processExits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"processExitsBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrToken\",\"type\":\"uint256\"}],\"name\":\"startExitWithDepositedTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"halfExitPeriod\",\"type\":\"uint256\"}],\"name\":\"updateExitPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"offset\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"verifyTxInclusion\",\"type\":\"bool\"}],\"name\":\"verifyInclusion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WithdrawManager","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://df78cae32a553680764c1b40ed24c964070f0d40ecd8f767fa1ef6dcf60f694d"}]}