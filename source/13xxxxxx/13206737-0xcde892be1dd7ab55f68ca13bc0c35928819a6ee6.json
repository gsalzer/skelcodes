{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// Global Enums and Structs\r\n\r\n\r\n\r\nstruct StrategyParams {\r\n    uint256 performanceFee;\r\n    uint256 activation;\r\n    uint256 debtRatio;\r\n    uint256 minDebtPerHarvest;\r\n    uint256 maxDebtPerHarvest;\r\n    uint256 lastReport;\r\n    uint256 totalDebt;\r\n    uint256 totalGain;\r\n    uint256 totalLoss;\r\n}\r\n\r\n// Part: Account\r\n\r\nlibrary Account {\r\n    enum Status {Normal, Liquid, Vapor}\r\n    struct Info {\r\n        address owner; // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n    struct Storage {\r\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n}\r\n\r\n// Part: Actions\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, // supply tokens\r\n        Withdraw, // borrow tokens\r\n        Transfer, // transfer balance between accounts\r\n        Buy, // buy an amount of some token (publicly)\r\n        Sell, // sell an amount of some token (publicly)\r\n        Trade, // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize, // use excess tokens to zero-out a completely negative account\r\n        Call // send arbitrary data to an address\r\n    }\r\n\r\n    enum AccountLayout {OnePrimary, TwoPrimary, PrimaryAndSecondary}\r\n\r\n    enum MarketLayout {ZeroMarkets, OneMarket, TwoMarkets}\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct DepositArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address from;\r\n    }\r\n\r\n    struct WithdrawArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address to;\r\n    }\r\n\r\n    struct TransferArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info accountOne;\r\n        Account.Info accountTwo;\r\n        uint256 market;\r\n    }\r\n\r\n    struct BuyArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 makerMarket;\r\n        uint256 takerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    struct SellArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 takerMarket;\r\n        uint256 makerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    struct TradeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info takerAccount;\r\n        Account.Info makerAccount;\r\n        uint256 inputMarket;\r\n        uint256 outputMarket;\r\n        address autoTrader;\r\n        bytes tradeData;\r\n    }\r\n\r\n    struct LiquidateArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info liquidAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    struct VaporizeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info vaporAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    struct CallArgs {\r\n        Account.Info account;\r\n        address callee;\r\n        bytes data;\r\n    }\r\n}\r\n\r\n// Part: IAaveIncentivesController\r\n\r\ninterface IAaveIncentivesController {\r\n    /**\r\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n     * @param user The address of the user\r\n     * @return The rewards\r\n     **/\r\n    function getRewardsBalance(address[] calldata assets, address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n     * @param amount Amount of rewards to claim\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewards(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n     * @param amount Amount of rewards to claim\r\n     * @param user Address to check and claim rewards\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewardsOnBehalf(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address user,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev returns the unclaimed rewards of the user\r\n     * @param user the address of the user\r\n     * @return the unclaimed user rewards\r\n     */\r\n    function getUserUnclaimedRewards(address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev for backward compatibility with previous implementation of the Incentives controller\r\n     */\r\n    function REWARD_TOKEN() external view returns (address);\r\n\r\n    function getDistributionEnd() external view returns (uint256);\r\n\r\n    function getAssetData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n\r\n// Part: ICallee\r\n\r\n/**\r\n * @title ICallee\r\n * @author dYdX\r\n *\r\n * Interface that Callees for Solo must implement in order to ingest data.\r\n */\r\ninterface ICallee {\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Allows users to send this contract arbitrary data.\r\n     *\r\n     * @param  sender       The msg.sender to Solo\r\n     * @param  accountInfo  The account from which the data is being sent\r\n     * @param  data         Arbitrary data given by the sender\r\n     */\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info memory accountInfo,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n\r\n// Part: ILendingPoolAddressesProvider\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n    event MarketIdSet(string newMarketId);\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event ConfigurationAdminUpdated(address indexed newAddress);\r\n    event EmergencyAdminUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n    function getMarketId() external view returns (string memory);\r\n\r\n    function setMarketId(string calldata marketId) external;\r\n\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    function getLendingPool() external view returns (address);\r\n\r\n    function setLendingPoolImpl(address pool) external;\r\n\r\n    function getLendingPoolConfigurator() external view returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n    function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n    function setLendingPoolCollateralManager(address manager) external;\r\n\r\n    function getPoolAdmin() external view returns (address);\r\n\r\n    function setPoolAdmin(address admin) external;\r\n\r\n    function getEmergencyAdmin() external view returns (address);\r\n\r\n    function setEmergencyAdmin(address admin) external;\r\n\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    function setPriceOracle(address priceOracle) external;\r\n\r\n    function getLendingRateOracle() external view returns (address);\r\n\r\n    function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n\r\n// Part: IOptionalERC20\r\n\r\ninterface IOptionalERC20 {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// Part: IPriceOracle\r\n\r\ninterface IPriceOracle {\r\n    function getAssetPrice(address _asset) external view returns (uint256);\r\n\r\n    function getAssetsPrices(address[] calldata _assets)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getSourceOfAsset(address _asset) external view returns (address);\r\n\r\n    function getFallbackOracle() external view returns (address);\r\n}\r\n\r\n// Part: IScaledBalanceToken\r\n\r\ninterface IScaledBalanceToken {\r\n    /**\r\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n     * @param user The user whose balance is calculated\r\n     * @return The scaled balance of the user\r\n     **/\r\n    function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the scaled balance of the user and the scaled total supply.\r\n     * @param user The address of the user\r\n     * @return The scaled balance of the user\r\n     * @return The scaled balance and the scaled total supply\r\n     **/\r\n    function getScaledUserBalanceAndSupply(address user)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    /**\r\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n     * @return The scaled total supply\r\n     **/\r\n    function scaledTotalSupply() external view returns (uint256);\r\n}\r\n\r\n// Part: ISoloMargin\r\n\r\nlibrary Decimal {\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Interest {\r\n    struct Rate {\r\n        uint256 value;\r\n    }\r\n\r\n    struct Index {\r\n        uint96 borrow;\r\n        uint96 supply;\r\n        uint32 lastUpdate;\r\n    }\r\n}\r\n\r\nlibrary Monetary {\r\n    struct Price {\r\n        uint256 value;\r\n    }\r\n    struct Value {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Storage {\r\n    // All information necessary for tracking a market\r\n    struct Market {\r\n        // Contract address of the associated ERC20 token\r\n        address token;\r\n        // Total aggregated supply and borrow amount of the entire market\r\n        Types.TotalPar totalPar;\r\n        // Interest index of the market\r\n        Interest.Index index;\r\n        // Contract address of the price oracle for this market\r\n        address priceOracle;\r\n        // Contract address of the interest setter for this market\r\n        address interestSetter;\r\n        // Multiplier on the marginRatio for this market\r\n        Decimal.D256 marginPremium;\r\n        // Multiplier on the liquidationSpread for this market\r\n        Decimal.D256 spreadPremium;\r\n        // Whether additional borrows are allowed for this market\r\n        bool isClosing;\r\n    }\r\n\r\n    // The global risk parameters that govern the health and security of the system\r\n    struct RiskParams {\r\n        // Required ratio of over-collateralization\r\n        Decimal.D256 marginRatio;\r\n        // Percentage penalty incurred by liquidated accounts\r\n        Decimal.D256 liquidationSpread;\r\n        // Percentage of the borrower's interest fee that gets passed to the suppliers\r\n        Decimal.D256 earningsRate;\r\n        // The minimum absolute borrow value of an account\r\n        // There must be sufficient incentivize to liquidate undercollateralized accounts\r\n        Monetary.Value minBorrowedValue;\r\n    }\r\n\r\n    // The maximum RiskParam values that can be set\r\n    struct RiskLimits {\r\n        uint64 marginRatioMax;\r\n        uint64 liquidationSpreadMax;\r\n        uint64 earningsRateMax;\r\n        uint64 marginPremiumMax;\r\n        uint64 spreadPremiumMax;\r\n        uint128 minBorrowedValueMax;\r\n    }\r\n\r\n    // The entire storage state of Solo\r\n    struct State {\r\n        // number of markets\r\n        uint256 numMarkets;\r\n        // marketId => Market\r\n        mapping(uint256 => Market) markets;\r\n        // owner => account number => Account\r\n        mapping(address => mapping(uint256 => Account.Storage)) accounts;\r\n        // Addresses that can control other users accounts\r\n        mapping(address => mapping(address => bool)) operators;\r\n        // Addresses that can control all users accounts\r\n        mapping(address => bool) globalOperators;\r\n        // mutable risk parameters of the system\r\n        RiskParams riskParams;\r\n        // immutable risk limits of the system\r\n        RiskLimits riskLimits;\r\n    }\r\n}\r\n \r\ninterface ISoloMargin {\r\n    struct OperatorArg {\r\n        address operator1;\r\n        bool trusted;\r\n    }\r\n\r\n    function ownerSetSpreadPremium(\r\n        uint256 marketId,\r\n        Decimal.D256 memory spreadPremium\r\n    ) external;\r\n\r\n    function getIsGlobalOperator(address operator1)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getMarketTokenAddress(uint256 marketId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function ownerSetInterestSetter(uint256 marketId, address interestSetter)\r\n        external;\r\n\r\n    function getAccountValues(Account.Info memory account)\r\n        external\r\n        view\r\n        returns (Monetary.Value memory, Monetary.Value memory);\r\n\r\n    function getMarketPriceOracle(uint256 marketId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getMarketInterestSetter(uint256 marketId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getMarketSpreadPremium(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Decimal.D256 memory);\r\n\r\n    function getNumMarkets() external view returns (uint256);\r\n\r\n    function ownerWithdrawUnsupportedTokens(address token, address recipient)\r\n        external\r\n        returns (uint256);\r\n\r\n    function ownerSetMinBorrowedValue(Monetary.Value memory minBorrowedValue)\r\n        external;\r\n\r\n    function ownerSetLiquidationSpread(Decimal.D256 memory spread) external;\r\n\r\n    function ownerSetEarningsRate(Decimal.D256 memory earningsRate) external;\r\n\r\n    function getIsLocalOperator(address owner, address operator1)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getAccountPar(Account.Info memory account, uint256 marketId)\r\n        external\r\n        view\r\n        returns (Types.Par memory);\r\n\r\n    function ownerSetMarginPremium(\r\n        uint256 marketId,\r\n        Decimal.D256 memory marginPremium\r\n    ) external;\r\n\r\n    function getMarginRatio() external view returns (Decimal.D256 memory);\r\n\r\n    function getMarketCurrentIndex(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Interest.Index memory);\r\n\r\n    function getMarketIsClosing(uint256 marketId) external view returns (bool);\r\n\r\n    function getRiskParams() external view returns (Storage.RiskParams memory);\r\n\r\n    function getAccountBalances(Account.Info memory account)\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            Types.Par[] memory,\r\n            Types.Wei[] memory\r\n        );\r\n\r\n    function renounceOwnership() external;\r\n\r\n    function getMinBorrowedValue()\r\n        external\r\n        view\r\n        returns (Monetary.Value memory);\r\n\r\n    function setOperators(OperatorArg[] memory args) external;\r\n\r\n    function getMarketPrice(uint256 marketId) external view returns (address);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function ownerWithdrawExcessTokens(uint256 marketId, address recipient)\r\n        external\r\n        returns (uint256);\r\n\r\n    function ownerAddMarket(\r\n        address token,\r\n        address priceOracle,\r\n        address interestSetter,\r\n        Decimal.D256 memory marginPremium,\r\n        Decimal.D256 memory spreadPremium\r\n    ) external;\r\n\r\n    function operate(\r\n        Account.Info[] memory accounts,\r\n        Actions.ActionArgs[] memory actions\r\n    ) external;\r\n\r\n    function getMarketWithInfo(uint256 marketId)\r\n        external\r\n        view\r\n        returns (\r\n            Storage.Market memory,\r\n            Interest.Index memory,\r\n            Monetary.Price memory,\r\n            Interest.Rate memory\r\n        );\r\n\r\n    function ownerSetMarginRatio(Decimal.D256 memory ratio) external;\r\n\r\n    function getLiquidationSpread() external view returns (Decimal.D256 memory);\r\n\r\n    function getAccountWei(Account.Info memory account, uint256 marketId)\r\n        external\r\n        view\r\n        returns (Types.Wei memory);\r\n\r\n    function getMarketTotalPar(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Types.TotalPar memory);\r\n\r\n    function getLiquidationSpreadForPair(\r\n        uint256 heldMarketId,\r\n        uint256 owedMarketId\r\n    ) external view returns (Decimal.D256 memory);\r\n\r\n    function getNumExcessTokens(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Types.Wei memory);\r\n\r\n    function getMarketCachedIndex(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Interest.Index memory);\r\n\r\n    function getAccountStatus(Account.Info memory account)\r\n        external\r\n        view\r\n        returns (uint8);\r\n\r\n    function getEarningsRate() external view returns (Decimal.D256 memory);\r\n\r\n    function ownerSetPriceOracle(uint256 marketId, address priceOracle)\r\n        external;\r\n\r\n    function getRiskLimits() external view returns (Storage.RiskLimits memory);\r\n\r\n    function getMarket(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Storage.Market memory);\r\n\r\n    function ownerSetIsClosing(uint256 marketId, bool isClosing) external;\r\n\r\n    function ownerSetGlobalOperator(address operator1, bool approved) external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    function getAdjustedAccountValues(Account.Info memory account)\r\n        external\r\n        view\r\n        returns (Monetary.Value memory, Monetary.Value memory);\r\n\r\n    function getMarketMarginPremium(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Decimal.D256 memory);\r\n\r\n    function getMarketInterestRate(uint256 marketId)\r\n        external\r\n        view\r\n        returns (Interest.Rate memory);\r\n}\r\n\r\n// Part: IStakedAave\r\n\r\ninterface IStakedAave {\r\n    function stake(address to, uint256 amount) external;\r\n\r\n    function redeem(address to, uint256 amount) external;\r\n\r\n    function cooldown() external;\r\n\r\n    function claimRewards(address to, uint256 amount) external;\r\n\r\n    function getTotalRewardsBalance(address) external view returns (uint256);\r\n\r\n    function COOLDOWN_SECONDS() external view returns (uint256);\r\n\r\n    function stakersCooldowns(address) external view returns (uint256);\r\n\r\n    function UNSTAKE_WINDOW() external view returns (uint256);\r\n}\r\n\r\n// Part: IUni\r\n\r\ninterface IUni{\r\n    function getAmountsOut(\r\n        uint256 amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\n// Part: IUniswapV3SwapCallback\r\n\r\n/// @title Callback for IUniswapV3PoolActions#swap\r\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\r\ninterface IUniswapV3SwapCallback {\r\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\r\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\r\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/Address\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/IERC20\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/Math\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeMath\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Part: Types\r\n\r\nlibrary Types {\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n}\r\n\r\n// Part: yearn/yearn-vaults@0.4.3/HealthCheck\r\n\r\ninterface HealthCheck {\r\n    function check(\r\n        uint256 profit,\r\n        uint256 loss,\r\n        uint256 debtPayment,\r\n        uint256 debtOutstanding,\r\n        uint256 totalDebt\r\n    ) external view returns (bool);\r\n}\r\n\r\n// Part: ILendingPool\r\n\r\nlibrary DataTypes {\r\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        uint40 lastUpdateTimestamp;\r\n        //tokens addresses\r\n        address aTokenAddress;\r\n        address stableDebtTokenAddress;\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint8 id;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        //bit 0-15: LTV\r\n        //bit 16-31: Liq. threshold\r\n        //bit 32-47: Liq. bonus\r\n        //bit 48-55: Decimals\r\n        //bit 56: Reserve is active\r\n        //bit 57: reserve is frozen\r\n        //bit 58: borrowing is enabled\r\n        //bit 59: stable rate borrowing enabled\r\n        //bit 60-63: reserved\r\n        //bit 64-79: reserve factor\r\n        uint256 data;\r\n    }\r\n\r\n    struct UserConfigurationMap {\r\n        uint256 data;\r\n    }\r\n\r\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n\r\ninterface ILendingPool {\r\n    /**\r\n     * @dev Emitted on deposit()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the deposit\r\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n     * @param amount The amount deposited\r\n     * @param referral The referral code used\r\n     **/\r\n    event Deposit(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on withdraw()\r\n     * @param reserve The address of the underlyng asset being withdrawn\r\n     * @param user The address initiating the withdrawal, owner of aTokens\r\n     * @param to Address that will receive the underlying\r\n     * @param amount The amount to be withdrawn\r\n     **/\r\n    event Withdraw(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n     * @param reserve The address of the underlying asset being borrowed\r\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n     * initiator of the transaction on flashLoan()\r\n     * @param onBehalfOf The address that will be getting the debt\r\n     * @param amount The amount borrowed out\r\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n     * @param borrowRate The numeric rate at which the user has borrowed\r\n     * @param referral The referral code used\r\n     **/\r\n    event Borrow(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint256 borrowRateMode,\r\n        uint256 borrowRate,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on repay()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The beneficiary of the repayment, getting his debt reduced\r\n     * @param repayer The address of the user initiating the repay(), providing the funds\r\n     * @param amount The amount repaid\r\n     **/\r\n    event Repay(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed repayer,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on swapBorrowRateMode()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user swapping his rate mode\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralEnabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralDisabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on rebalanceStableBorrowRate()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user for which the rebalance has been executed\r\n     **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on flashLoan()\r\n     * @param target The address of the flash loan receiver contract\r\n     * @param initiator The address initiating the flash loan\r\n     * @param asset The address of the asset being flash borrowed\r\n     * @param amount The amount flash borrowed\r\n     * @param premium The fee flash borrowed\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event FlashLoan(\r\n        address indexed target,\r\n        address indexed initiator,\r\n        address indexed asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        uint16 referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered.\r\n     */\r\n    event Paused();\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted.\r\n     */\r\n    event Unpaused();\r\n\r\n    /**\r\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n     * LendingPoolCollateral manager using a DELEGATECALL\r\n     * This allows to have the events in the generated ABI for LendingPool.\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n     * @param liquidator The address of the liquidator\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    event LiquidationCall(\r\n        address indexed collateralAsset,\r\n        address indexed debtAsset,\r\n        address indexed user,\r\n        uint256 debtToCover,\r\n        uint256 liquidatedCollateralAmount,\r\n        address liquidator,\r\n        bool receiveAToken\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n     * gets added to the LendingPool ABI\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param liquidityRate The new liquidity rate\r\n     * @param stableBorrowRate The new stable borrow rate\r\n     * @param variableBorrowRate The new variable borrow rate\r\n     * @param liquidityIndex The new liquidity index\r\n     * @param variableBorrowIndex The new variable borrow index\r\n     **/\r\n    event ReserveDataUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @return The final amount repaid\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 rateMode,\r\n        address onBehalfOf\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n    /**\r\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n     *        borrowed at a stable rate and depositors are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n     * @param asset The address of the underlying asset deposited\r\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n     * For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts amounts being flash-borrowed\r\n     * @param modes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata modes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralETH the total collateral in ETH of the user\r\n     * @return totalDebtETH the total debt in ETH of the user\r\n     * @return availableBorrowsETH the borrowing power left of the user\r\n     * @return currentLiquidationThreshold the liquidation threshold of the user\r\n     * @return ltv the loan to value of the user\r\n     * @return healthFactor the current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function initReserve(\r\n        address reserve,\r\n        address aTokenAddress,\r\n        address stableDebtAddress,\r\n        address variableDebtAddress,\r\n        address interestRateStrategyAddress\r\n    ) external;\r\n\r\n    function setReserveInterestRateStrategyAddress(\r\n        address reserve,\r\n        address rateStrategyAddress\r\n    ) external;\r\n\r\n    function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n    /**\r\n     * @dev Returns the configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The configuration of the reserve\r\n     **/\r\n    function getConfiguration(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the configuration of the user across all the reserves\r\n     * @param user The user address\r\n     * @return The configuration of the user\r\n     **/\r\n    function getUserConfiguration(address user)\r\n        external\r\n        view\r\n        returns (DataTypes.UserConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the normalized income normalized income of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve's normalized income\r\n     */\r\n    function getReserveNormalizedIncome(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the normalized variable debt per unit of asset\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve normalized variable debt\r\n     */\r\n    function getReserveNormalizedVariableDebt(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the state and configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The state of the reserve\r\n     **/\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveData memory);\r\n\r\n    function finalizeTransfer(\r\n        address asset,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 balanceFromAfter,\r\n        uint256 balanceToBefore\r\n    ) external;\r\n\r\n    function getReservesList() external view returns (address[] memory);\r\n\r\n    function getAddressesProvider()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function setPause(bool val) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n\r\n// Part: IProtocolDataProvider\r\n\r\ninterface IProtocolDataProvider {\r\n    struct TokenData {\r\n        string symbol;\r\n        address tokenAddress;\r\n    }\r\n\r\n    function ADDRESSES_PROVIDER()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function getAllReservesTokens() external view returns (TokenData[] memory);\r\n\r\n    function getAllATokens() external view returns (TokenData[] memory);\r\n\r\n    function getReserveConfigurationData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 decimals,\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            uint256 reserveFactor,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive,\r\n            bool isFrozen\r\n        );\r\n\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 availableLiquidity,\r\n            uint256 totalStableDebt,\r\n            uint256 totalVariableDebt,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 averageStableBorrowRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            uint40 lastUpdateTimestamp\r\n        );\r\n\r\n    function getUserReserveData(address asset, address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentStableDebt,\r\n            uint256 currentVariableDebt,\r\n            uint256 principalStableDebt,\r\n            uint256 scaledVariableDebt,\r\n            uint256 stableBorrowRate,\r\n            uint256 liquidityRate,\r\n            uint40 stableRateLastUpdated,\r\n            bool usageAsCollateralEnabled\r\n        );\r\n\r\n    function getReserveTokensAddresses(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            address aTokenAddress,\r\n            address stableDebtTokenAddress,\r\n            address variableDebtTokenAddress\r\n        );\r\n}\r\n\r\n// Part: ISwapRouter\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountIn);\r\n}\r\n\r\n// Part: IVariableDebtToken\r\n\r\n/**\r\n * @title IVariableDebtToken\r\n * @author Aave\r\n * @notice Defines the basic interface for a variable debt token.\r\n **/\r\ninterface IVariableDebtToken is IERC20, IScaledBalanceToken {\r\n    /**\r\n     * @dev Emitted after the mint action\r\n     * @param from The address performing the mint\r\n     * @param onBehalfOf The address of the user on which behalf minting has been performed\r\n     * @param value The amount to be minted\r\n     * @param index The last index of the reserve\r\n     **/\r\n    event Mint(\r\n        address indexed from,\r\n        address indexed onBehalfOf,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Mints debt token to the `onBehalfOf` address\r\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n     * of credit delegate, or same as `onBehalfOf` otherwise\r\n     * @param onBehalfOf The address receiving the debt tokens\r\n     * @param amount The amount of debt being minted\r\n     * @param index The variable debt index of the reserve\r\n     * @return `true` if the the previous balance of the user is 0\r\n     **/\r\n    function mint(\r\n        address user,\r\n        address onBehalfOf,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when variable debt is burnt\r\n     * @param user The user which debt has been burned\r\n     * @param amount The amount of debt being burned\r\n     * @param index The index of the user\r\n     **/\r\n    event Burn(address indexed user, uint256 amount, uint256 index);\r\n\r\n    /**\r\n     * @dev Burns user variable debt\r\n     * @param user The user which debt is burnt\r\n     * @param index The variable debt index of the reserve\r\n     **/\r\n    function burn(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the address of the incentives controller contract\r\n     **/\r\n    function getIncentivesController()\r\n        external\r\n        view\r\n        returns (IAaveIncentivesController);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeERC20\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// Part: yearn/yearn-vaults@0.4.3/VaultAPI\r\n\r\ninterface VaultAPI is IERC20 {\r\n    function name() external view returns (string calldata);\r\n\r\n    function symbol() external view returns (string calldata);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function apiVersion() external pure returns (string memory);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 expiry,\r\n        bytes calldata signature\r\n    ) external returns (bool);\r\n\r\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\r\n    function deposit() external returns (uint256);\r\n\r\n    function deposit(uint256 amount) external returns (uint256);\r\n\r\n    function deposit(uint256 amount, address recipient) external returns (uint256);\r\n\r\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\r\n    function withdraw() external returns (uint256);\r\n\r\n    function withdraw(uint256 maxShares) external returns (uint256);\r\n\r\n    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function strategies(address _strategy) external view returns (StrategyParams memory);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function totalAssets() external view returns (uint256);\r\n\r\n    function depositLimit() external view returns (uint256);\r\n\r\n    function maxAvailableShares() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault would increase this Strategy's borrow limit,\r\n     * based on its present performance (since its last report). Can be used to\r\n     * determine expectedReturn in your Strategy.\r\n     */\r\n    function creditAvailable() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault would like to pull back from the Strategy,\r\n     * based on its present performance (since its last report). Can be used to\r\n     * determine expectedReturn in your Strategy.\r\n     */\r\n    function debtOutstanding() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault expect this Strategy to return at the current\r\n     * block, based on its present performance (since its last report). Can be\r\n     * used to determine expectedReturn in your Strategy.\r\n     */\r\n    function expectedReturn() external view returns (uint256);\r\n\r\n    /**\r\n     * This is the main contact point where the Strategy interacts with the\r\n     * Vault. It is critical that this call is handled as intended by the\r\n     * Strategy. Therefore, this function will be called by BaseStrategy to\r\n     * make sure the integration is correct.\r\n     */\r\n    function report(\r\n        uint256 _gain,\r\n        uint256 _loss,\r\n        uint256 _debtPayment\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * This function should only be used in the scenario where the Strategy is\r\n     * being retired but no migration of the positions are possible, or in the\r\n     * extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\r\n     * mode in order for it to exit as quickly as possible. The latter scenario\r\n     * could be for any reason that is considered \"critical\" that the Strategy\r\n     * exits its position as fast as possible, such as a sudden change in\r\n     * market conditions leading to losses, or an imminent failure in an\r\n     * external dependency.\r\n     */\r\n    function revokeStrategy() external;\r\n\r\n    /**\r\n     * View the governance address of the Vault to assert privileged functions\r\n     * can only be called by governance. The Strategy serves the Vault, so it\r\n     * is subject to governance defined by the Vault.\r\n     */\r\n    function governance() external view returns (address);\r\n\r\n    /**\r\n     * View the management address of the Vault to assert privileged functions\r\n     * can only be called by management. The Strategy serves the Vault, so it\r\n     * is subject to management defined by the Vault.\r\n     */\r\n    function management() external view returns (address);\r\n\r\n    /**\r\n     * View the guardian address of the Vault to assert privileged functions\r\n     * can only be called by guardian. The Strategy serves the Vault, so it\r\n     * is subject to guardian defined by the Vault.\r\n     */\r\n    function guardian() external view returns (address);\r\n}\r\n\r\n// Part: IInitializableAToken\r\n\r\n/**\r\n * @title IInitializableAToken\r\n * @notice Interface for the initialize function on AToken\r\n * @author Aave\r\n **/\r\ninterface IInitializableAToken {\r\n    /**\r\n     * @dev Emitted when an aToken is initialized\r\n     * @param underlyingAsset The address of the underlying asset\r\n     * @param pool The address of the associated lending pool\r\n     * @param treasury The address of the treasury\r\n     * @param incentivesController The address of the incentives controller for this aToken\r\n     * @param aTokenDecimals the decimals of the underlying\r\n     * @param aTokenName the name of the aToken\r\n     * @param aTokenSymbol the symbol of the aToken\r\n     * @param params A set of encoded parameters for additional initialization\r\n     **/\r\n    event Initialized(\r\n        address indexed underlyingAsset,\r\n        address indexed pool,\r\n        address treasury,\r\n        address incentivesController,\r\n        uint8 aTokenDecimals,\r\n        string aTokenName,\r\n        string aTokenSymbol,\r\n        bytes params\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the aToken\r\n     * @param pool The address of the lending pool where this aToken will be used\r\n     * @param treasury The address of the Aave treasury, receiving the fees on this aToken\r\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n     * @param incentivesController The smart contract managing potential incentives distribution\r\n     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n     * @param aTokenName The name of the aToken\r\n     * @param aTokenSymbol The symbol of the aToken\r\n     */\r\n    function initialize(\r\n        ILendingPool pool,\r\n        address treasury,\r\n        address underlyingAsset,\r\n        IAaveIncentivesController incentivesController,\r\n        uint8 aTokenDecimals,\r\n        string calldata aTokenName,\r\n        string calldata aTokenSymbol,\r\n        bytes calldata params\r\n    ) external;\r\n}\r\n\r\n// Part: yearn/yearn-vaults@0.4.3/BaseStrategy\r\n\r\n/**\r\n * @title Yearn Base Strategy\r\n * @author yearn.finance\r\n * @notice\r\n *  BaseStrategy implements all of the required functionality to interoperate\r\n *  closely with the Vault contract. This contract should be inherited and the\r\n *  abstract methods implemented to adapt the Strategy to the particular needs\r\n *  it has to create a return.\r\n *\r\n *  Of special interest is the relationship between `harvest()` and\r\n *  `vault.report()'. `harvest()` may be called simply because enough time has\r\n *  elapsed since the last report, and not because any funds need to be moved\r\n *  or positions adjusted. This is critical so that the Vault may maintain an\r\n *  accurate picture of the Strategy's performance. See  `vault.report()`,\r\n *  `harvest()`, and `harvestTrigger()` for further details.\r\n */\r\n\r\nabstract contract BaseStrategy {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    string public metadataURI;\r\n\r\n    // health checks\r\n    bool public doHealthCheck;\r\n    address public healthCheck;\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to track which version of `StrategyAPI` this Strategy\r\n     *  implements.\r\n     * @dev The Strategy's version must match the Vault's `API_VERSION`.\r\n     * @return A string which holds the current API version of this contract.\r\n     */\r\n    function apiVersion() public pure returns (string memory) {\r\n        return \"0.4.3\";\r\n    }\r\n\r\n    /**\r\n     * @notice This Strategy's name.\r\n     * @dev\r\n     *  You can use this field to manage the \"version\" of this Strategy, e.g.\r\n     *  `StrategySomethingOrOtherV1`. However, \"API Version\" is managed by\r\n     *  `apiVersion()` function above.\r\n     * @return This Strategy's name.\r\n     */\r\n    function name() external view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice\r\n     *  The amount (priced in want) of the total assets managed by this strategy should not count\r\n     *  towards Yearn's TVL calculations.\r\n     * @dev\r\n     *  You can override this field to set it to a non-zero value if some of the assets of this\r\n     *  Strategy is somehow delegated inside another part of of Yearn's ecosystem e.g. another Vault.\r\n     *  Note that this value must be strictly less than or equal to the amount provided by\r\n     *  `estimatedTotalAssets()` below, as the TVL calc will be total assets minus delegated assets.\r\n     *  Also note that this value is used to determine the total assets under management by this\r\n     *  strategy, for the purposes of computing the management fee in `Vault`\r\n     * @return\r\n     *  The amount of assets this strategy manages that should not be included in Yearn's Total Value\r\n     *  Locked (TVL) calculation across it's ecosystem.\r\n     */\r\n    function delegatedAssets() external view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    VaultAPI public vault;\r\n    address public strategist;\r\n    address public rewards;\r\n    address public keeper;\r\n\r\n    IERC20 public want;\r\n\r\n    // So indexers can keep track of this\r\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\r\n\r\n    event UpdatedStrategist(address newStrategist);\r\n\r\n    event UpdatedKeeper(address newKeeper);\r\n\r\n    event UpdatedRewards(address rewards);\r\n\r\n    event UpdatedMinReportDelay(uint256 delay);\r\n\r\n    event UpdatedMaxReportDelay(uint256 delay);\r\n\r\n    event UpdatedProfitFactor(uint256 profitFactor);\r\n\r\n    event UpdatedDebtThreshold(uint256 debtThreshold);\r\n\r\n    event EmergencyExitEnabled();\r\n\r\n    event UpdatedMetadataURI(string metadataURI);\r\n\r\n    // The minimum number of seconds between harvest calls. See\r\n    // `setMinReportDelay()` for more details.\r\n    uint256 public minReportDelay;\r\n\r\n    // The maximum number of seconds between harvest calls. See\r\n    // `setMaxReportDelay()` for more details.\r\n    uint256 public maxReportDelay;\r\n\r\n    // The minimum multiple that `callCost` must be above the credit/profit to\r\n    // be \"justifiable\". See `setProfitFactor()` for more details.\r\n    uint256 public profitFactor;\r\n\r\n    // Use this to adjust the threshold at which running a debt causes a\r\n    // harvest trigger. See `setDebtThreshold()` for more details.\r\n    uint256 public debtThreshold;\r\n\r\n    // See note on `setEmergencyExit()`.\r\n    bool public emergencyExit;\r\n\r\n    // modifiers\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyEmergencyAuthorized() {\r\n        require(\r\n            msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(),\r\n            \"!authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyStrategist() {\r\n        require(msg.sender == strategist, \"!strategist\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyKeepers() {\r\n        require(\r\n            msg.sender == keeper ||\r\n                msg.sender == strategist ||\r\n                msg.sender == governance() ||\r\n                msg.sender == vault.guardian() ||\r\n                msg.sender == vault.management(),\r\n            \"!authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyVaultManagers() {\r\n        require(msg.sender == vault.management() || msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _vault) public {\r\n        _initialize(_vault, msg.sender, msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Initializes the Strategy, this is called only once, when the\r\n     *  contract is deployed.\r\n     * @dev `_vault` should implement `VaultAPI`.\r\n     * @param _vault The address of the Vault responsible for this Strategy.\r\n     * @param _strategist The address to assign as `strategist`.\r\n     * The strategist is able to change the reward address\r\n     * @param _rewards  The address to use for pulling rewards.\r\n     * @param _keeper The adddress of the _keeper. _keeper\r\n     * can harvest and tend a strategy.\r\n     */\r\n    function _initialize(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) internal {\r\n        require(address(want) == address(0), \"Strategy already initialized\");\r\n\r\n        vault = VaultAPI(_vault);\r\n        want = IERC20(vault.token());\r\n        want.safeApprove(_vault, uint256(-1)); // Give Vault unlimited access (might save gas)\r\n        strategist = _strategist;\r\n        rewards = _rewards;\r\n        keeper = _keeper;\r\n\r\n        // initialize variables\r\n        minReportDelay = 0;\r\n        maxReportDelay = 86400;\r\n        profitFactor = 100;\r\n        debtThreshold = 0;\r\n\r\n        vault.approve(rewards, uint256(-1)); // Allow rewards to be pulled\r\n    }\r\n\r\n    function setHealthCheck(address _healthCheck) external onlyVaultManagers {\r\n        healthCheck = _healthCheck;\r\n    }\r\n\r\n    function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {\r\n        doHealthCheck = _doHealthCheck;\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `strategist`.\r\n     *\r\n     *  This may only be called by governance or the existing strategist.\r\n     * @param _strategist The new address to assign as `strategist`.\r\n     */\r\n    function setStrategist(address _strategist) external onlyAuthorized {\r\n        require(_strategist != address(0));\r\n        strategist = _strategist;\r\n        emit UpdatedStrategist(_strategist);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `keeper`.\r\n     *\r\n     *  `keeper` is the only address that may call `tend()` or `harvest()`,\r\n     *  other than `governance()` or `strategist`. However, unlike\r\n     *  `governance()` or `strategist`, `keeper` may *only* call `tend()`\r\n     *  and `harvest()`, and no other authorized functions, following the\r\n     *  principle of least privilege.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _keeper The new address to assign as `keeper`.\r\n     */\r\n    function setKeeper(address _keeper) external onlyAuthorized {\r\n        require(_keeper != address(0));\r\n        keeper = _keeper;\r\n        emit UpdatedKeeper(_keeper);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `rewards`. EOA or smart contract which has the permission\r\n     *  to pull rewards from the vault.\r\n     *\r\n     *  This may only be called by the strategist.\r\n     * @param _rewards The address to use for pulling rewards.\r\n     */\r\n    function setRewards(address _rewards) external onlyStrategist {\r\n        require(_rewards != address(0));\r\n        vault.approve(rewards, 0);\r\n        rewards = _rewards;\r\n        vault.approve(rewards, uint256(-1));\r\n        emit UpdatedRewards(_rewards);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `minReportDelay`. `minReportDelay` is the minimum number\r\n     *  of blocks that should pass for `harvest()` to be called.\r\n     *\r\n     *  For external keepers (such as the Keep3r network), this is the minimum\r\n     *  time between jobs to wait. (see `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _delay The minimum number of seconds to wait between harvests.\r\n     */\r\n    function setMinReportDelay(uint256 _delay) external onlyAuthorized {\r\n        minReportDelay = _delay;\r\n        emit UpdatedMinReportDelay(_delay);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `maxReportDelay`. `maxReportDelay` is the maximum number\r\n     *  of blocks that should pass for `harvest()` to be called.\r\n     *\r\n     *  For external keepers (such as the Keep3r network), this is the maximum\r\n     *  time between jobs to wait. (see `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _delay The maximum number of seconds to wait between harvests.\r\n     */\r\n    function setMaxReportDelay(uint256 _delay) external onlyAuthorized {\r\n        maxReportDelay = _delay;\r\n        emit UpdatedMaxReportDelay(_delay);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `profitFactor`. `profitFactor` is used to determine\r\n     *  if it's worthwhile to harvest, given gas costs. (See `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _profitFactor A ratio to multiply anticipated\r\n     * `harvest()` gas cost against.\r\n     */\r\n    function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {\r\n        profitFactor = _profitFactor;\r\n        emit UpdatedProfitFactor(_profitFactor);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Sets how far the Strategy can go into loss without a harvest and report\r\n     *  being required.\r\n     *\r\n     *  By default this is 0, meaning any losses would cause a harvest which\r\n     *  will subsequently report the loss to the Vault for tracking. (See\r\n     *  `harvestTrigger()` for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _debtThreshold How big of a loss this Strategy may carry without\r\n     * being required to report to the Vault.\r\n     */\r\n    function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {\r\n        debtThreshold = _debtThreshold;\r\n        emit UpdatedDebtThreshold(_debtThreshold);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `metadataURI`. `metadataURI` is used to store the URI\r\n     * of the file describing the strategy.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _metadataURI The URI that describe the strategy.\r\n     */\r\n    function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {\r\n        metadataURI = _metadataURI;\r\n        emit UpdatedMetadataURI(_metadataURI);\r\n    }\r\n\r\n    /**\r\n     * Resolve governance address from Vault contract, used to make assertions\r\n     * on protected functions in the Strategy.\r\n     */\r\n    function governance() internal view returns (address) {\r\n        return vault.governance();\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)\r\n     *  to `want` (using the native decimal characteristics of `want`).\r\n     * @dev\r\n     *  Care must be taken when working with decimals to assure that the conversion\r\n     *  is compatible. As an example:\r\n     *\r\n     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),\r\n     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)\r\n     *\r\n     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`\r\n     * @return The amount in `want` of `_amtInEth` converted to `want`\r\n     **/\r\n    function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide an accurate estimate for the total amount of assets\r\n     *  (principle + return) that this Strategy is currently managing,\r\n     *  denominated in terms of `want` tokens.\r\n     *\r\n     *  This total should be \"realizable\" e.g. the total value that could\r\n     *  *actually* be obtained from this Strategy if it were to divest its\r\n     *  entire position based on current on-chain conditions.\r\n     * @dev\r\n     *  Care must be taken in using this function, since it relies on external\r\n     *  systems, which could be manipulated by the attacker to give an inflated\r\n     *  (or reduced) value produced by this function, based on current on-chain\r\n     *  conditions (e.g. this function is possible to influence through\r\n     *  flashloan attacks, oracle manipulations, or other DeFi attack\r\n     *  mechanisms).\r\n     *\r\n     *  It is up to governance to use this function to correctly order this\r\n     *  Strategy relative to its peers in the withdrawal queue to minimize\r\n     *  losses for the Vault based on sudden withdrawals. This value should be\r\n     *  higher than the total debt of the Strategy and higher than its expected\r\n     *  value to be \"safe\".\r\n     * @return The estimated total assets in this Strategy.\r\n     */\r\n    function estimatedTotalAssets() public view virtual returns (uint256);\r\n\r\n    /*\r\n     * @notice\r\n     *  Provide an indication of whether this strategy is currently \"active\"\r\n     *  in that it is managing an active position, or will manage a position in\r\n     *  the future. This should correlate to `harvest()` activity, so that Harvest\r\n     *  events can be tracked externally by indexing agents.\r\n     * @return True if the strategy is actively managing a position.\r\n     */\r\n    function isActive() public view returns (bool) {\r\n        return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;\r\n    }\r\n\r\n    /**\r\n     * Perform any Strategy unwinding or other calls necessary to capture the\r\n     * \"free return\" this Strategy has generated since the last time its core\r\n     * position(s) were adjusted. Examples include unwrapping extra rewards.\r\n     * This call is only used during \"normal operation\" of a Strategy, and\r\n     * should be optimized to minimize losses as much as possible.\r\n     *\r\n     * This method returns any realized profits and/or realized losses\r\n     * incurred, and should return the total amounts of profits/losses/debt\r\n     * payments (in `want` tokens) for the Vault's accounting (e.g.\r\n     * `want.balanceOf(this) >= _debtPayment + _profit`).\r\n     *\r\n     * `_debtOutstanding` will be 0 if the Strategy is not past the configured\r\n     * debt limit, otherwise its value will be how far past the debt limit\r\n     * the Strategy is. The Strategy's debt limit is configured in the Vault.\r\n     *\r\n     * NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\r\n     *       It is okay for it to be less than `_debtOutstanding`, as that\r\n     *       should only used as a guide for how much is left to pay back.\r\n     *       Payments should be made to minimize loss from slippage, debt,\r\n     *       withdrawal fees, etc.\r\n     *\r\n     * See `vault.debtOutstanding()`.\r\n     */\r\n    function prepareReturn(uint256 _debtOutstanding)\r\n        internal\r\n        virtual\r\n        returns (\r\n            uint256 _profit,\r\n            uint256 _loss,\r\n            uint256 _debtPayment\r\n        );\r\n\r\n    /**\r\n     * Perform any adjustments to the core position(s) of this Strategy given\r\n     * what change the Vault made in the \"investable capital\" available to the\r\n     * Strategy. Note that all \"free capital\" in the Strategy after the report\r\n     * was made is available for reinvestment. Also note that this number\r\n     * could be 0, and you should handle that scenario accordingly.\r\n     *\r\n     * See comments regarding `_debtOutstanding` on `prepareReturn()`.\r\n     */\r\n    function adjustPosition(uint256 _debtOutstanding) internal virtual;\r\n\r\n    /**\r\n     * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,\r\n     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\r\n     * This function should return the amount of `want` tokens made available by the\r\n     * liquidation. If there is a difference between them, `_loss` indicates whether the\r\n     * difference is due to a realized loss, or if there is some other sitution at play\r\n     * (e.g. locked funds) where the amount made available is less than what is needed.\r\n     *\r\n     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\r\n     */\r\n    function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);\r\n\r\n    /**\r\n     * Liquidate everything and returns the amount that got freed.\r\n     * This function is used during emergency exit instead of `prepareReturn()` to\r\n     * liquidate all of the Strategy's positions back to the Vault.\r\n     */\r\n\r\n    function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide a signal to the keeper that `tend()` should be called. The\r\n     *  keeper will provide the estimated gas cost that they would pay to call\r\n     *  `tend()`, and this function should use that estimate to make a\r\n     *  determination if calling it is \"worth it\" for the keeper. This is not\r\n     *  the only consideration into issuing this trigger, for example if the\r\n     *  position would be negatively affected if `tend()` is not called\r\n     *  shortly, then this can return `true` even if the keeper might be\r\n     *  \"at a loss\" (keepers are always reimbursed by Yearn).\r\n     * @dev\r\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\r\n     *\r\n     *  This call and `harvestTrigger()` should never return `true` at the same\r\n     *  time.\r\n     * @param callCostInWei The keeper's estimated gas cost to call `tend()` (in wei).\r\n     * @return `true` if `tend()` should be called, `false` otherwise.\r\n     */\r\n    function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {\r\n        // We usually don't need tend, but if there are positions that need\r\n        // active maintainence, overriding this function is how you would\r\n        // signal for that.\r\n        // If your implementation uses the cost of the call in want, you can\r\n        // use uint256 callCost = ethToWant(callCostInWei);\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Adjust the Strategy's position. The purpose of tending isn't to\r\n     *  realize gains, but to maximize yield by reinvesting any returns.\r\n     *\r\n     *  See comments on `adjustPosition()`.\r\n     *\r\n     *  This may only be called by governance, the strategist, or the keeper.\r\n     */\r\n    function tend() external onlyKeepers {\r\n        // Don't take profits with this call, but adjust for better gains\r\n        adjustPosition(vault.debtOutstanding());\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide a signal to the keeper that `harvest()` should be called. The\r\n     *  keeper will provide the estimated gas cost that they would pay to call\r\n     *  `harvest()`, and this function should use that estimate to make a\r\n     *  determination if calling it is \"worth it\" for the keeper. This is not\r\n     *  the only consideration into issuing this trigger, for example if the\r\n     *  position would be negatively affected if `harvest()` is not called\r\n     *  shortly, then this can return `true` even if the keeper might be \"at a\r\n     *  loss\" (keepers are always reimbursed by Yearn).\r\n     * @dev\r\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\r\n     *\r\n     *  This call and `tendTrigger` should never return `true` at the\r\n     *  same time.\r\n     *\r\n     *  See `min/maxReportDelay`, `profitFactor`, `debtThreshold` to adjust the\r\n     *  strategist-controlled parameters that will influence whether this call\r\n     *  returns `true` or not. These parameters will be used in conjunction\r\n     *  with the parameters reported to the Vault (see `params`) to determine\r\n     *  if calling `harvest()` is merited.\r\n     *\r\n     *  It is expected that an external system will check `harvestTrigger()`.\r\n     *  This could be a script run off a desktop or cloud bot (e.g.\r\n     *  https://github.com/iearn-finance/yearn-vaults/blob/main/scripts/keep.py),\r\n     *  or via an integration with the Keep3r network (e.g.\r\n     *  https://github.com/Macarse/GenericKeep3rV2/blob/master/contracts/keep3r/GenericKeep3rV2.sol).\r\n     * @param callCostInWei The keeper's estimated gas cost to call `harvest()` (in wei).\r\n     * @return `true` if `harvest()` should be called, `false` otherwise.\r\n     */\r\n    function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {\r\n        uint256 callCost = ethToWant(callCostInWei);\r\n        StrategyParams memory params = vault.strategies(address(this));\r\n\r\n        // Should not trigger if Strategy is not activated\r\n        if (params.activation == 0) return false;\r\n\r\n        // Should not trigger if we haven't waited long enough since previous harvest\r\n        if (block.timestamp.sub(params.lastReport) < minReportDelay) return false;\r\n\r\n        // Should trigger if hasn't been called in a while\r\n        if (block.timestamp.sub(params.lastReport) >= maxReportDelay) return true;\r\n\r\n        // If some amount is owed, pay it back\r\n        // NOTE: Since debt is based on deposits, it makes sense to guard against large\r\n        //       changes to the value from triggering a harvest directly through user\r\n        //       behavior. This should ensure reasonable resistance to manipulation\r\n        //       from user-initiated withdrawals as the outstanding debt fluctuates.\r\n        uint256 outstanding = vault.debtOutstanding();\r\n        if (outstanding > debtThreshold) return true;\r\n\r\n        // Check for profits and losses\r\n        uint256 total = estimatedTotalAssets();\r\n        // Trigger if we have a loss to report\r\n        if (total.add(debtThreshold) < params.totalDebt) return true;\r\n\r\n        uint256 profit = 0;\r\n        if (total > params.totalDebt) profit = total.sub(params.totalDebt); // We've earned a profit!\r\n\r\n        // Otherwise, only trigger if it \"makes sense\" economically (gas cost\r\n        // is <N% of value moved)\r\n        uint256 credit = vault.creditAvailable();\r\n        return (profitFactor.mul(callCost) < credit.add(profit));\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Harvests the Strategy, recognizing any profits or losses and adjusting\r\n     *  the Strategy's position.\r\n     *\r\n     *  In the rare case the Strategy is in emergency shutdown, this will exit\r\n     *  the Strategy's position.\r\n     *\r\n     *  This may only be called by governance, the strategist, or the keeper.\r\n     * @dev\r\n     *  When `harvest()` is called, the Strategy reports to the Vault (via\r\n     *  `vault.report()`), so in some cases `harvest()` must be called in order\r\n     *  to take in profits, to borrow newly available funds from the Vault, or\r\n     *  otherwise adjust its position. In other cases `harvest()` must be\r\n     *  called to report to the Vault on the Strategy's position, especially if\r\n     *  any losses have occurred.\r\n     */\r\n    function harvest() external onlyKeepers {\r\n        uint256 profit = 0;\r\n        uint256 loss = 0;\r\n        uint256 debtOutstanding = vault.debtOutstanding();\r\n        uint256 debtPayment = 0;\r\n        if (emergencyExit) {\r\n            // Free up as much capital as possible\r\n            uint256 amountFreed = liquidateAllPositions();\r\n            if (amountFreed < debtOutstanding) {\r\n                loss = debtOutstanding.sub(amountFreed);\r\n            } else if (amountFreed > debtOutstanding) {\r\n                profit = amountFreed.sub(debtOutstanding);\r\n            }\r\n            debtPayment = debtOutstanding.sub(loss);\r\n        } else {\r\n            // Free up returns for Vault to pull\r\n            (profit, loss, debtPayment) = prepareReturn(debtOutstanding);\r\n        }\r\n\r\n        // Allow Vault to take up to the \"harvested\" balance of this contract,\r\n        // which is the amount it has earned since the last time it reported to\r\n        // the Vault.\r\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\r\n        debtOutstanding = vault.report(profit, loss, debtPayment);\r\n\r\n        // Check if free returns are left, and re-invest them\r\n        adjustPosition(debtOutstanding);\r\n\r\n        // call healthCheck contract\r\n        if (doHealthCheck && healthCheck != address(0)) {\r\n            require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), \"!healthcheck\");\r\n        } else {\r\n            doHealthCheck = true;\r\n        }\r\n\r\n        emit Harvested(profit, loss, debtPayment, debtOutstanding);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Withdraws `_amountNeeded` to `vault`.\r\n     *\r\n     *  This may only be called by the Vault.\r\n     * @param _amountNeeded How much `want` to withdraw.\r\n     * @return _loss Any realized losses\r\n     */\r\n    function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {\r\n        require(msg.sender == address(vault), \"!vault\");\r\n        // Liquidate as much as possible to `want`, up to `_amountNeeded`\r\n        uint256 amountFreed;\r\n        (amountFreed, _loss) = liquidatePosition(_amountNeeded);\r\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\r\n        want.safeTransfer(msg.sender, amountFreed);\r\n        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\r\n    }\r\n\r\n    /**\r\n     * Do anything necessary to prepare this Strategy for migration, such as\r\n     * transferring any reserve or LP tokens, CDPs, or other tokens or stores of\r\n     * value.\r\n     */\r\n    function prepareMigration(address _newStrategy) internal virtual;\r\n\r\n    /**\r\n     * @notice\r\n     *  Transfers all `want` from this Strategy to `_newStrategy`.\r\n     *\r\n     *  This may only be called by the Vault.\r\n     * @dev\r\n     * The new Strategy's Vault must be the same as this Strategy's Vault.\r\n     *  The migration process should be carefully performed to make sure all\r\n     * the assets are migrated to the new address, which should have never\r\n     * interacted with the vault before.\r\n     * @param _newStrategy The Strategy to migrate to.\r\n     */\r\n    function migrate(address _newStrategy) external {\r\n        require(msg.sender == address(vault));\r\n        require(BaseStrategy(_newStrategy).vault() == vault);\r\n        prepareMigration(_newStrategy);\r\n        want.safeTransfer(_newStrategy, want.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Activates emergency exit. Once activated, the Strategy will exit its\r\n     *  position upon the next harvest, depositing all funds into the Vault as\r\n     *  quickly as is reasonable given on-chain conditions.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @dev\r\n     *  See `vault.setEmergencyShutdown()` and `harvest()` for further details.\r\n     */\r\n    function setEmergencyExit() external onlyEmergencyAuthorized {\r\n        emergencyExit = true;\r\n        vault.revokeStrategy();\r\n\r\n        emit EmergencyExitEnabled();\r\n    }\r\n\r\n    /**\r\n     * Override this to add all tokens/tokenized positions this contract\r\n     * manages on a *persistent* basis (e.g. not just for swapping back to\r\n     * want ephemerally).\r\n     *\r\n     * NOTE: Do *not* include `want`, already included in `sweep` below.\r\n     *\r\n     * Example:\r\n     * ```\r\n     *    function protectedTokens() internal override view returns (address[] memory) {\r\n     *      address[] memory protected = new address[](3);\r\n     *      protected[0] = tokenA;\r\n     *      protected[1] = tokenB;\r\n     *      protected[2] = tokenC;\r\n     *      return protected;\r\n     *    }\r\n     * ```\r\n     */\r\n    function protectedTokens() internal view virtual returns (address[] memory);\r\n\r\n    /**\r\n     * @notice\r\n     *  Removes tokens from this Strategy that are not the type of tokens\r\n     *  managed by this Strategy. This may be used in case of accidentally\r\n     *  sending the wrong kind of token to this Strategy.\r\n     *\r\n     *  Tokens will be sent to `governance()`.\r\n     *\r\n     *  This will fail if an attempt is made to sweep `want`, or any tokens\r\n     *  that are protected by this Strategy.\r\n     *\r\n     *  This may only be called by governance.\r\n     * @dev\r\n     *  Implement `protectedTokens()` to specify any additional tokens that\r\n     *  should be protected from sweeping in addition to `want`.\r\n     * @param _token The token to transfer out of this vault.\r\n     */\r\n    function sweep(address _token) external onlyGovernance {\r\n        require(_token != address(want), \"!want\");\r\n        require(_token != address(vault), \"!shares\");\r\n\r\n        address[] memory _protectedTokens = protectedTokens();\r\n        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], \"!protected\");\r\n\r\n        IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\n// Part: IAToken\r\n\r\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\r\n    /**\r\n     * @dev Emitted after the mint action\r\n     * @param from The address performing the mint\r\n     * @param value The amount being\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event Mint(address indexed from, uint256 value, uint256 index);\r\n\r\n    /**\r\n     * @dev Mints `amount` aTokens to `user`\r\n     * @param user The address receiving the minted tokens\r\n     * @param amount The amount of tokens getting minted\r\n     * @param index The new liquidity index of the reserve\r\n     * @return `true` if the the previous balance of the user was 0\r\n     */\r\n    function mint(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted after aTokens are burned\r\n     * @param from The owner of the aTokens, getting them burned\r\n     * @param target The address that will receive the underlying\r\n     * @param value The amount being burned\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event Burn(\r\n        address indexed from,\r\n        address indexed target,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted during the transfer action\r\n     * @param from The user whose tokens are being transferred\r\n     * @param to The recipient\r\n     * @param value The amount being transferred\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event BalanceTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n     * @param user The owner of the aTokens, getting them burned\r\n     * @param receiverOfUnderlying The address that will receive the underlying\r\n     * @param amount The amount being burned\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    function burn(\r\n        address user,\r\n        address receiverOfUnderlying,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Mints aTokens to the reserve treasury\r\n     * @param amount The amount of tokens getting minted\r\n     * @param index The new liquidity index of the reserve\r\n     */\r\n    function mintToTreasury(uint256 amount, uint256 index) external;\r\n\r\n    /**\r\n     * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n     * @param from The address getting liquidated, current owner of the aTokens\r\n     * @param to The recipient\r\n     * @param value The amount of tokens getting transferred\r\n     **/\r\n    function transferOnLiquidation(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n     * assets in borrow(), withdraw() and flashLoan()\r\n     * @param user The recipient of the underlying\r\n     * @param amount The amount getting transferred\r\n     * @return The amount transferred\r\n     **/\r\n    function transferUnderlyingTo(address user, uint256 amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Invoked to execute actions on the aToken side after a repayment.\r\n     * @param user The user executing the repayment\r\n     * @param amount The amount getting repaid\r\n     **/\r\n    function handleRepayment(address user, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the address of the incentives controller contract\r\n     **/\r\n    function getIncentivesController()\r\n        external\r\n        view\r\n        returns (IAaveIncentivesController);\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n     **/\r\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n}\r\n\r\n// Part: yearn/yearn-vaults@0.4.3/BaseStrategyInitializable\r\n\r\nabstract contract BaseStrategyInitializable is BaseStrategy {\r\n    bool public isOriginal = true;\r\n    event Cloned(address indexed clone);\r\n\r\n    constructor(address _vault) public BaseStrategy(_vault) {}\r\n\r\n    function initialize(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) external virtual {\r\n        _initialize(_vault, _strategist, _rewards, _keeper);\r\n    }\r\n\r\n    function clone(address _vault) external returns (address) {\r\n        require(isOriginal, \"!clone\");\r\n        return this.clone(_vault, msg.sender, msg.sender, msg.sender);\r\n    }\r\n\r\n    function clone(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) external returns (address newStrategy) {\r\n        // Copied from https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\r\n        bytes20 addressBytes = bytes20(address(this));\r\n\r\n        assembly {\r\n            // EIP-1167 bytecode\r\n            let clone_code := mload(0x40)\r\n            mstore(clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone_code, 0x14), addressBytes)\r\n            mstore(add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            newStrategy := create(0, clone_code, 0x37)\r\n        }\r\n\r\n        BaseStrategyInitializable(newStrategy).initialize(_vault, _strategist, _rewards, _keeper);\r\n\r\n        emit Cloned(newStrategy);\r\n    }\r\n}\r\n\r\n// Part: FlashLoanLib\r\n\r\nlibrary FlashLoanLib {\r\n    using SafeMath for uint256;\r\n    event Leverage(\r\n        uint256 amountRequested,\r\n        uint256 amountGiven,\r\n        bool deficit,\r\n        address flashLoan\r\n    );\r\n\r\n    address public constant SOLO = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n    uint256 private constant collatRatioETH = 0.79 ether;\r\n    uint256 private constant COLLAT_RATIO_PRECISION = 1 ether;\r\n    address private constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IAToken public constant aWeth =\r\n        IAToken(0x030bA81f1c18d280636F32af80b9AAd02Cf0854e);\r\n    IProtocolDataProvider private constant protocolDataProvider =\r\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\r\n    ILendingPool private constant lendingPool =\r\n        ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\r\n\r\n    // Aave's referral code\r\n    uint16 private constant referral = 0;\r\n\r\n    function doDyDxFlashLoan(\r\n        bool deficit,\r\n        uint256 amountDesired,\r\n        address token\r\n    ) public returns (uint256 amount) {\r\n        if (amountDesired == 0) {\r\n            return 0;\r\n        }\r\n        amount = amountDesired;\r\n        ISoloMargin solo = ISoloMargin(SOLO);\r\n\r\n        // calculate amount of ETH we need\r\n        uint256 requiredETH;\r\n        {\r\n            requiredETH = _toETH(amount, token).mul(COLLAT_RATIO_PRECISION).div(\r\n                collatRatioETH\r\n            );\r\n\r\n            uint256 dxdyLiquidity = IERC20(weth).balanceOf(address(solo));\r\n            if (requiredETH > dxdyLiquidity) {\r\n                requiredETH = dxdyLiquidity;\r\n                // NOTE: if we cap amountETH, we reduce amountToken we are taking too\r\n                amount = _fromETH(requiredETH, token).mul(collatRatioETH).div(\r\n                    1 ether\r\n                );\r\n            }\r\n        }\r\n\r\n        // Array of actions to be done during FlashLoan\r\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\r\n\r\n        // 1. Take FlashLoan\r\n        operations[0] = _getWithdrawAction(0, requiredETH); // hardcoded market ID to 0 (ETH)\r\n\r\n        // 2. Encode arguments of functions and create action for calling it\r\n        bytes memory data = abi.encode(deficit, amount);\r\n        // This call will:\r\n        // supply ETH to Aave\r\n        // borrow desired Token from Aave\r\n        // do stuff with Token\r\n        // repay desired Token to Aave\r\n        // withdraw ETH from Aave\r\n        operations[1] = _getCallAction(data);\r\n\r\n        // 3. Repay FlashLoan\r\n        operations[2] = _getDepositAction(0, requiredETH.add(2));\r\n\r\n        // Create Account Info\r\n        Account.Info[] memory accountInfos = new Account.Info[](1);\r\n        accountInfos[0] = _getAccountInfo();\r\n\r\n        solo.operate(accountInfos, operations);\r\n\r\n        emit Leverage(amountDesired, requiredETH, deficit, address(solo));\r\n\r\n        return amount; // we need to return the amount of Token we have changed our position in\r\n    }\r\n\r\n    function loanLogic(\r\n        bool deficit,\r\n        uint256 amount,\r\n        address want\r\n    ) public {\r\n        uint256 wethBal = IERC20(weth).balanceOf(address(this));\r\n        // NOTE: weth balance should always be > amount/0.75\r\n        // require(wethBal >= amount, \"!bal\"); // to stop malicious calls\r\n\r\n        ILendingPool lp = lendingPool;\r\n\r\n        // 1. Deposit WETH in Aave as collateral\r\n        lp.deposit(weth, wethBal, address(this), referral);\r\n\r\n        if (deficit) {\r\n            // 2a. if in deficit withdraw amount and repay it\r\n            lp.withdraw(want, amount, address(this));\r\n            lp.repay(want, amount, 2, address(this));\r\n        } else {\r\n            // 2b. if levering up borrow and deposit\r\n            lp.borrow(want, amount, 2, 0, address(this));\r\n            lp.deposit(\r\n                want,\r\n                IERC20(want).balanceOf(address(this)),\r\n                address(this),\r\n                referral\r\n            );\r\n        }\r\n        // 3. Withdraw WETH\r\n        lp.withdraw(weth, wethBal, address(this));\r\n    }\r\n\r\n    function _getAccountInfo() internal view returns (Account.Info memory) {\r\n        return Account.Info({owner: address(this), number: 1});\r\n    }\r\n\r\n    function _getWithdrawAction(uint256 marketId, uint256 amount)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Withdraw,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n\r\n    function _getCallAction(bytes memory data)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Call,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: 0\r\n                }),\r\n                primaryMarketId: 0,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: data\r\n            });\r\n    }\r\n\r\n    function _getDepositAction(uint256 marketId, uint256 amount)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Deposit,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: true,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n\r\n    function _priceOracle() internal view returns (IPriceOracle) {\r\n        return\r\n            IPriceOracle(\r\n                protocolDataProvider.ADDRESSES_PROVIDER().getPriceOracle()\r\n            );\r\n    }\r\n\r\n    function _toETH(uint256 _amount, address asset)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (\r\n            _amount == 0 ||\r\n            _amount == type(uint256).max ||\r\n            address(asset) == address(weth) // 1:1 change\r\n        ) {\r\n            return _amount;\r\n        }\r\n\r\n        return\r\n            _amount.mul(_priceOracle().getAssetPrice(asset)).div(\r\n                uint256(10)**uint256(IOptionalERC20(asset).decimals())\r\n            );\r\n    }\r\n\r\n    function _fromETH(uint256 _amount, address asset)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (\r\n            _amount == 0 ||\r\n            _amount == type(uint256).max ||\r\n            address(asset) == address(weth) // 1:1 change\r\n        ) {\r\n            return _amount;\r\n        }\r\n\r\n        return\r\n            _amount\r\n                .mul(uint256(10)**uint256(IOptionalERC20(asset).decimals()))\r\n                .div(_priceOracle().getAssetPrice(asset));\r\n    }\r\n}\r\n\r\n// File: Strategy.sol\r\n\r\ncontract Strategy is BaseStrategyInitializable, ICallee {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    // AAVE protocol address\r\n    IProtocolDataProvider private constant protocolDataProvider =\r\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\r\n    IAaveIncentivesController private constant incentivesController =\r\n        IAaveIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\r\n    ILendingPool private constant lendingPool =\r\n        ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\r\n\r\n    // Token addresses\r\n    address private constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\r\n    IStakedAave private constant stkAave =\r\n        IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\r\n    address private constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    // Supply and borrow tokens\r\n    IAToken public aToken;\r\n    IVariableDebtToken public debtToken;\r\n\r\n    // SWAP routers\r\n    IUni private constant V2ROUTER =\r\n        IUni(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    ISwapRouter private constant V3ROUTER =\r\n        ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\r\n\r\n    // OPS State Variables\r\n    uint256 private constant DEFAULT_COLLAT_TARGET_MARGIN = 0.02 ether;\r\n    uint256 private constant DEFAULT_COLLAT_MAX_MARGIN = 0.005 ether;\r\n    uint256 private constant LIQUIDATION_WARNING_THRESHOLD = 0.01 ether;\r\n    uint256 public maxBorrowCollatRatio; // The maximum the aave protocol will let us borrow\r\n    uint256 public targetCollatRatio; // The LTV we are levering up to\r\n    uint256 public maxCollatRatio; // Closest to liquidation we'll risk\r\n\r\n    uint8 public maxIterations = 6;\r\n    bool public isDyDxActive = true;\r\n\r\n    uint256 public minWant = 100;\r\n    uint256 public minRatio = 0.005 ether;\r\n    uint256 public minRewardToSell = 1e15;\r\n\r\n    bool public sellStkAave = true;\r\n    bool public cooldownStkAave = false;\r\n    bool public useUniV3 = false; // only applied to aave => want, stkAave => aave always uses v3\r\n    uint256 public maxStkAavePriceImpactBps = 1000;\r\n\r\n    uint24 public stkAaveToAaveSwapFee = 10000;\r\n    uint24 public aaveToWethSwapFee = 3000;\r\n    uint24 public wethToWantSwapFee = 3000;\r\n\r\n    uint16 private constant referral = 0; // Aave's referral code\r\n    bool private alreadyAdjusted = false; // Signal whether a position adjust was done in prepareReturn\r\n\r\n    uint256 private constant MAX_BPS = 1e4;\r\n    uint256 private constant BPS_WAD_RATIO = 1e14;\r\n    uint256 private constant COLLATERAL_RATIO_PRECISION = 1 ether;\r\n    uint256 private constant PESSIMISM_FACTOR = 1000;\r\n    uint256 private DECIMALS;\r\n\r\n    constructor(address _vault) public BaseStrategyInitializable(_vault) {\r\n        _initializeThis();\r\n    }\r\n\r\n    function initialize(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) external override {\r\n        _initialize(_vault, _strategist, _rewards, _keeper);\r\n        _initializeThis();\r\n    }\r\n\r\n    function _initializeThis() internal {\r\n        require(address(aToken) == address(0));\r\n\r\n        // initialize operational state\r\n        maxIterations = 6;\r\n        isDyDxActive = true;\r\n\r\n        // mins\r\n        minWant = 100;\r\n        minRatio = 0.005 ether;\r\n        minRewardToSell = 1e15;\r\n\r\n        // reward params\r\n        sellStkAave = true;\r\n        cooldownStkAave = false;\r\n        useUniV3 = false;\r\n        maxStkAavePriceImpactBps = 1000;\r\n\r\n        stkAaveToAaveSwapFee = 10000;\r\n        aaveToWethSwapFee = 3000;\r\n        wethToWantSwapFee = 3000;\r\n\r\n        // Set aave tokens\r\n        (address _aToken, , address _debtToken) =\r\n            protocolDataProvider.getReserveTokensAddresses(address(want));\r\n        aToken = IAToken(_aToken);\r\n        debtToken = IVariableDebtToken(_debtToken);\r\n\r\n        // Let collateral targets\r\n        (, uint256 ltv, uint256 liquidationThreshold, , , , , , , ) =\r\n            protocolDataProvider.getReserveConfigurationData(address(want));\r\n        liquidationThreshold = liquidationThreshold.mul(BPS_WAD_RATIO); // convert bps to wad\r\n        targetCollatRatio = liquidationThreshold.sub(\r\n            DEFAULT_COLLAT_TARGET_MARGIN\r\n        );\r\n        maxCollatRatio = liquidationThreshold.sub(DEFAULT_COLLAT_MAX_MARGIN);\r\n        maxBorrowCollatRatio = ltv.mul(BPS_WAD_RATIO).sub(\r\n            DEFAULT_COLLAT_MAX_MARGIN\r\n        );\r\n\r\n        DECIMALS = 10**vault.decimals();\r\n\r\n        // approve spend aave spend\r\n        approveMaxSpend(address(want), address(lendingPool));\r\n        approveMaxSpend(address(aToken), address(lendingPool));\r\n\r\n        // approve flashloan spend\r\n        approveMaxSpend(weth, address(lendingPool));\r\n        approveMaxSpend(weth, FlashLoanLib.SOLO);\r\n\r\n        // approve swap router spend\r\n        approveMaxSpend(address(stkAave), address(V3ROUTER));\r\n        approveMaxSpend(aave, address(V2ROUTER));\r\n        approveMaxSpend(aave, address(V3ROUTER));\r\n    }\r\n\r\n    // SETTERS\r\n    function setCollateralTargets(\r\n        uint256 _targetCollatRatio,\r\n        uint256 _maxCollatRatio,\r\n        uint256 _maxBorrowCollatRatio\r\n    ) external onlyVaultManagers {\r\n        (, uint256 ltv, uint256 liquidationThreshold, , , , , , , ) =\r\n            protocolDataProvider.getReserveConfigurationData(address(want));\r\n        targetCollatRatio = _maxCollatRatio;\r\n        maxCollatRatio = _maxCollatRatio;\r\n        maxBorrowCollatRatio = _maxBorrowCollatRatio;\r\n\r\n        require(targetCollatRatio < liquidationThreshold);\r\n        require(maxCollatRatio < liquidationThreshold);\r\n        require(targetCollatRatio < maxCollatRatio);\r\n        require(maxBorrowCollatRatio < ltv);\r\n    }\r\n\r\n    function setIsDyDxActive(bool _isDyDxActive) external onlyVaultManagers {\r\n        isDyDxActive = _isDyDxActive;\r\n    }\r\n\r\n    function setMinsAndMaxs(\r\n        uint256 _minWant,\r\n        uint256 _minRatio,\r\n        uint8 _maxIterations\r\n    ) external onlyVaultManagers {\r\n        minWant = _minWant;\r\n        minRatio = _minRatio;\r\n        maxIterations = _maxIterations;\r\n    }\r\n\r\n    function setRewardBehavior(\r\n        bool _sellStkAave,\r\n        bool _cooldownStkAave,\r\n        bool _useUniV3,\r\n        uint256 _minRewardToSell,\r\n        uint256 _maxStkAavePriceImpactBps,\r\n        uint24 _stkAaveToAaveSwapFee,\r\n        uint24 _aaveToWethSwapFee,\r\n        uint24 _wethToWantSwapFee\r\n    ) external onlyVaultManagers {\r\n        sellStkAave = _sellStkAave;\r\n        cooldownStkAave = _cooldownStkAave;\r\n        useUniV3 = _useUniV3;\r\n        minRewardToSell = _minRewardToSell;\r\n        maxStkAavePriceImpactBps = _maxStkAavePriceImpactBps;\r\n        stkAaveToAaveSwapFee = _stkAaveToAaveSwapFee;\r\n        aaveToWethSwapFee = _aaveToWethSwapFee;\r\n        wethToWantSwapFee = _wethToWantSwapFee;\r\n    }\r\n\r\n    function name() external view override returns (string memory) {\r\n        return \"StrategyGenLevAAVE\";\r\n    }\r\n\r\n    function estimatedTotalAssets() public view override returns (uint256) {\r\n        uint256 rewards =\r\n            estimatedRewardsInWant().mul(MAX_BPS - PESSIMISM_FACTOR).div(\r\n                MAX_BPS\r\n            );\r\n\r\n        return balanceOfWant().add(getCurrentSupply()).add(rewards);\r\n    }\r\n\r\n    function estimatedRewardsInWant() public view returns (uint256) {\r\n        uint256 aaveBalance = balanceOfAave();\r\n        uint256 stkAaveBalance = balanceOfStkAave();\r\n\r\n        uint256 combinedBalance =\r\n            aaveBalance.add(\r\n                stkAaveBalance.mul(MAX_BPS - maxStkAavePriceImpactBps).div(\r\n                    MAX_BPS\r\n                )\r\n            );\r\n\r\n        uint256 lastReport = vault.strategies(address(this)).lastReport;\r\n        if (lastReport >= block.timestamp) {\r\n            return 0;\r\n        }\r\n        uint256 secondsSinceLastReport = block.timestamp.sub(lastReport);\r\n\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n\r\n        if (deposits == 0) {\r\n            return tokenToWant(aave, combinedBalance);\r\n        }\r\n\r\n        uint256 supplyRewards =\r\n            _tokenRewards(address(aToken), deposits, secondsSinceLastReport);\r\n\r\n        // Shortcut if no borrows\r\n        if (borrows == 0) {\r\n            return tokenToWant(aave, supplyRewards.add(combinedBalance));\r\n        }\r\n\r\n        uint256 borrowRewards =\r\n            _tokenRewards(address(debtToken), borrows, secondsSinceLastReport);\r\n\r\n        return\r\n            tokenToWant(\r\n                aave,\r\n                supplyRewards.add(borrowRewards).add(combinedBalance)\r\n            );\r\n    }\r\n\r\n    function prepareReturn(uint256 _debtOutstanding)\r\n        internal\r\n        override\r\n        returns (\r\n            uint256 _profit,\r\n            uint256 _loss,\r\n            uint256 _debtPayment\r\n        )\r\n    {\r\n        // claim & sell rewards\r\n        _claimAndSellRewards();\r\n\r\n        // account for profit / losses\r\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\r\n\r\n        // Assets immediately convertable to want only\r\n        uint256 supply = getCurrentSupply();\r\n        uint256 totalAssets = balanceOfWant().add(supply);\r\n\r\n        if (totalDebt > totalAssets) {\r\n            // we have losses\r\n            _loss = totalDebt.sub(totalAssets);\r\n        } else {\r\n            // we have profit\r\n            _profit = totalAssets.sub(totalDebt);\r\n        }\r\n\r\n        // free funds to repay debt + profit to the strategy\r\n        uint256 amountAvailable = balanceOfWant();\r\n        uint256 amountRequired = _debtOutstanding.add(_profit);\r\n\r\n        if (amountRequired > amountAvailable) {\r\n            // we need to free funds\r\n            // we dismiss losses here, they cannot be generated from withdrawal\r\n            // but it is possible for the strategy to unwind full position\r\n            (amountAvailable, ) = liquidatePosition(amountRequired);\r\n\r\n            alreadyAdjusted = true;\r\n            if (amountAvailable >= amountRequired) {\r\n                _debtPayment = _debtOutstanding;\r\n                // profit remains unchanged unless there is not enough to pay it\r\n                if (amountRequired.sub(_debtPayment) < _profit) {\r\n                    _profit = amountRequired.sub(_debtPayment);\r\n                }\r\n            } else {\r\n                // we were not able to free enough funds\r\n                if (amountAvailable < _debtOutstanding) {\r\n                    // available funds are lower than the repayment that we need to do\r\n                    _profit = 0;\r\n                    _debtPayment = amountAvailable;\r\n                    // we dont report losses here as the strategy might not be able to return in this harvest\r\n                    // but it will still be there for the next harvest\r\n                } else {\r\n                    // NOTE: amountRequired is always equal or greater than _debtOutstanding\r\n                    // important to use amountRequired just in case amountAvailable is > amountAvailable\r\n                    _debtPayment = _debtOutstanding;\r\n                    _profit = amountAvailable.sub(_debtPayment);\r\n                }\r\n            }\r\n        } else {\r\n            _debtPayment = _debtOutstanding;\r\n            // profit remains unchanged unless there is not enough to pay it\r\n            if (amountRequired.sub(_debtPayment) < _profit) {\r\n                _profit = amountRequired.sub(_debtPayment);\r\n            }\r\n        }\r\n    }\r\n\r\n    function adjustPosition(uint256 _debtOutstanding) internal override {\r\n        if (alreadyAdjusted) {\r\n            alreadyAdjusted = false; // reset for next time\r\n            return;\r\n        }\r\n\r\n        uint256 wantBalance = balanceOfWant();\r\n        // deposit available want as collateral\r\n        if (\r\n            wantBalance > _debtOutstanding &&\r\n            wantBalance.sub(_debtOutstanding) > minWant\r\n        ) {\r\n            _depositCollateral(wantBalance.sub(_debtOutstanding));\r\n            // we update the value\r\n            wantBalance = balanceOfWant();\r\n        }\r\n        // check current position\r\n        uint256 currentCollatRatio = getCurrentCollatRatio();\r\n\r\n        // Either we need to free some funds OR we want to be max levered\r\n        if (_debtOutstanding > wantBalance) {\r\n            // we should free funds\r\n            uint256 amountRequired = _debtOutstanding.sub(wantBalance);\r\n\r\n            // NOTE: vault will take free funds during the next harvest\r\n            _freeFunds(amountRequired);\r\n        } else if (currentCollatRatio < targetCollatRatio) {\r\n            // we should lever up\r\n            if (targetCollatRatio.sub(currentCollatRatio) > minRatio) {\r\n                // we only act on relevant differences\r\n                _leverMax();\r\n            }\r\n        } else if (currentCollatRatio > targetCollatRatio) {\r\n            if (currentCollatRatio.sub(targetCollatRatio) > minRatio) {\r\n                (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n                uint256 newBorrow =\r\n                    getBorrowFromSupply(\r\n                        deposits.sub(borrows),\r\n                        targetCollatRatio\r\n                    );\r\n                _leverDownTo(newBorrow, borrows);\r\n            }\r\n        }\r\n    }\r\n\r\n    function liquidatePosition(uint256 _amountNeeded)\r\n        internal\r\n        override\r\n        returns (uint256 _liquidatedAmount, uint256 _loss)\r\n    {\r\n        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`\r\n        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`\r\n        uint256 wantBalance = balanceOfWant();\r\n        if (wantBalance > _amountNeeded) {\r\n            // if there is enough free want, let's use it\r\n            return (_amountNeeded, 0);\r\n        }\r\n\r\n        // we need to free funds\r\n        uint256 amountRequired = _amountNeeded.sub(wantBalance);\r\n        _freeFunds(amountRequired);\r\n\r\n        uint256 freeAssets = balanceOfWant();\r\n        if (_amountNeeded > freeAssets) {\r\n            _liquidatedAmount = freeAssets;\r\n            _loss = _amountNeeded.sub(freeAssets);\r\n        } else {\r\n            _liquidatedAmount = _amountNeeded;\r\n        }\r\n    }\r\n\r\n    function tendTrigger(uint256 gasCost) public view override returns (bool) {\r\n        if (harvestTrigger(gasCost)) {\r\n            //harvest takes priority\r\n            return false;\r\n        }\r\n        // pull the liquidation liquidationThreshold from aave to be extra safu\r\n        (, , uint256 liquidationThreshold, , , , , , , ) =\r\n            protocolDataProvider.getReserveConfigurationData(address(want));\r\n\r\n        // convert bps to wad\r\n        liquidationThreshold = liquidationThreshold.mul(BPS_WAD_RATIO);\r\n\r\n        uint256 currentCollatRatio = getCurrentCollatRatio();\r\n\r\n        if (currentCollatRatio >= liquidationThreshold) {\r\n            return true;\r\n        }\r\n\r\n        return (liquidationThreshold.sub(currentCollatRatio) <=\r\n            LIQUIDATION_WARNING_THRESHOLD);\r\n    }\r\n\r\n    function liquidateAllPositions()\r\n        internal\r\n        override\r\n        returns (uint256 _amountFreed)\r\n    {\r\n        (_amountFreed, ) = liquidatePosition(type(uint256).max);\r\n    }\r\n\r\n    function prepareMigration(address _newStrategy) internal override {\r\n        require(getCurrentSupply() < minWant);\r\n    }\r\n\r\n    function protectedTokens()\r\n        internal\r\n        view\r\n        override\r\n        returns (address[] memory)\r\n    {}\r\n\r\n    //emergency function that we can use to deleverage manually if something is broken\r\n    function manualDeleverage(uint256 amount) external onlyVaultManagers {\r\n        _withdrawCollateral(amount);\r\n        _repayWant(amount);\r\n    }\r\n\r\n    //emergency function that we can use to deleverage manually if something is broken\r\n    function manualReleaseWant(uint256 amount) external onlyVaultManagers {\r\n        _withdrawCollateral(amount);\r\n    }\r\n\r\n    // INTERNAL ACTIONS\r\n\r\n    function _claimAndSellRewards() internal returns (uint256) {\r\n        uint256 stkAaveBalance = balanceOfStkAave();\r\n        uint8 cooldownStatus = stkAaveBalance == 0 ? 0 : _checkCooldown(); // don't check status if we have no stkAave\r\n\r\n        // If it's the claim period claim\r\n        if (stkAaveBalance > 0 && cooldownStatus == 1) {\r\n            // redeem AAVE from stkAave\r\n            stkAave.claimRewards(address(this), type(uint256).max);\r\n            stkAave.redeem(address(this), stkAaveBalance);\r\n        }\r\n\r\n        // claim stkAave from lending and borrowing, this will reset the cooldown\r\n        address[] memory assets;\r\n        assets = new address[](2);\r\n        assets[0] = address(aToken);\r\n        assets[1] = address(debtToken);\r\n        incentivesController.claimRewards(\r\n            assets,\r\n            type(uint256).max,\r\n            address(this)\r\n        );\r\n\r\n        stkAaveBalance = balanceOfStkAave();\r\n\r\n        // request start of cooldown period, if there's no cooldown in progress\r\n        if (cooldownStkAave && stkAaveBalance > 0 && cooldownStatus == 0) {\r\n            stkAave.cooldown();\r\n        }\r\n\r\n        // Always keep 1 wei to get around cooldown clear\r\n        if (sellStkAave && stkAaveBalance >= minRewardToSell.add(1)) {\r\n            uint256 minAAVEOut =\r\n                stkAaveBalance.mul(MAX_BPS.sub(maxStkAavePriceImpactBps)).div(\r\n                    MAX_BPS\r\n                );\r\n            _sellSTKAAVEToAAVE(stkAaveBalance.sub(1), minAAVEOut);\r\n        }\r\n\r\n        // sell AAVE for want\r\n        uint256 aaveBalance = balanceOfAave();\r\n        if (aaveBalance >= minRewardToSell) {\r\n            _sellAAVEForWant(aaveBalance, 0);\r\n        }\r\n    }\r\n\r\n    function _freeFunds(uint256 amountToFree) internal returns (uint256) {\r\n        if (amountToFree == 0) return 0;\r\n\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n\r\n        uint256 realAssets = deposits.sub(borrows);\r\n        uint256 amountRequired = Math.min(amountToFree, realAssets);\r\n        uint256 newSupply = realAssets.sub(amountRequired);\r\n        uint256 newBorrow = getBorrowFromSupply(newSupply, targetCollatRatio);\r\n\r\n        // repay required amount\r\n        _leverDownTo(newBorrow, borrows);\r\n\r\n        return balanceOfWant();\r\n    }\r\n\r\n    function _leverMax() internal {\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n\r\n        // NOTE: decimals should cancel out\r\n        uint256 realSupply = deposits.sub(borrows);\r\n        uint256 newBorrow = getBorrowFromSupply(realSupply, targetCollatRatio);\r\n        uint256 totalAmountToBorrow = newBorrow.sub(borrows);\r\n\r\n        if (isDyDxActive) {\r\n            // The best approach is to lever up using regular method, then finish with flash loan\r\n            totalAmountToBorrow = totalAmountToBorrow.sub(\r\n                _leverUpStep(totalAmountToBorrow)\r\n            );\r\n\r\n            if (totalAmountToBorrow > minWant) {\r\n                totalAmountToBorrow = totalAmountToBorrow.sub(\r\n                    _leverUpFlashLoan(totalAmountToBorrow)\r\n                );\r\n            }\r\n        } else {\r\n            for (\r\n                uint8 i = 0;\r\n                i < maxIterations && totalAmountToBorrow > minWant;\r\n                i++\r\n            ) {\r\n                totalAmountToBorrow = totalAmountToBorrow.sub(\r\n                    _leverUpStep(totalAmountToBorrow)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _leverUpFlashLoan(uint256 amount) internal returns (uint256) {\r\n        return FlashLoanLib.doDyDxFlashLoan(false, amount, address(want));\r\n    }\r\n\r\n    function _leverUpStep(uint256 amount) internal returns (uint256) {\r\n        if (amount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 wantBalance = balanceOfWant();\r\n\r\n        // calculate how much borrow can I take\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n        uint256 canBorrow =\r\n            getBorrowFromDeposit(\r\n                deposits.add(wantBalance),\r\n                maxBorrowCollatRatio\r\n            );\r\n\r\n        if (canBorrow <= borrows) {\r\n            return 0;\r\n        }\r\n        canBorrow = canBorrow.sub(borrows);\r\n\r\n        if (canBorrow < amount) {\r\n            amount = canBorrow;\r\n        }\r\n\r\n        // deposit available want as collateral\r\n        _depositCollateral(wantBalance);\r\n\r\n        // borrow available amount\r\n        _borrowWant(amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    function _leverDownTo(uint256 newAmountBorrowed, uint256 currentBorrowed)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (newAmountBorrowed >= currentBorrowed) {\r\n            // we don't need to repay\r\n            return 0;\r\n        }\r\n\r\n        uint256 totalRepayAmount = currentBorrowed.sub(newAmountBorrowed);\r\n\r\n        if (isDyDxActive) {\r\n            totalRepayAmount = totalRepayAmount.sub(\r\n                _leverDownFlashLoan(totalRepayAmount)\r\n            );\r\n            _withdrawExcessCollateral();\r\n        }\r\n\r\n        for (\r\n            uint8 i = 0;\r\n            i < maxIterations && totalRepayAmount > minWant;\r\n            i++\r\n        ) {\r\n            uint256 toRepay = totalRepayAmount;\r\n            uint256 wantBalance = balanceOfWant();\r\n            if (toRepay > wantBalance) {\r\n                toRepay = wantBalance;\r\n            }\r\n            uint256 repaid = _repayWant(toRepay);\r\n            totalRepayAmount = totalRepayAmount.sub(repaid);\r\n            // withdraw collateral\r\n            _withdrawExcessCollateral();\r\n        }\r\n\r\n        // deposit back to get targetCollatRatio (we always need to leave this in this ratio)\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n        uint256 targetDeposit =\r\n            getDepositFromBorrow(borrows, targetCollatRatio);\r\n        if (targetDeposit > deposits) {\r\n            uint256 toDeposit = targetDeposit.sub(deposits);\r\n            if (toDeposit > minWant) {\r\n                _depositCollateral(Math.min(toDeposit, balanceOfWant()));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _leverDownFlashLoan(uint256 amount) internal returns (uint256) {\r\n        if (amount <= minWant) return 0;\r\n        (, uint256 borrows) = getCurrentPosition();\r\n        if (amount > borrows) {\r\n            amount = borrows;\r\n        }\r\n        return FlashLoanLib.doDyDxFlashLoan(true, amount, address(want));\r\n    }\r\n\r\n    function _withdrawExcessCollateral() internal returns (uint256 amount) {\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n        uint256 theoDeposits = getDepositFromBorrow(borrows, maxCollatRatio);\r\n        if (deposits > theoDeposits) {\r\n            uint256 toWithdraw = deposits.sub(theoDeposits);\r\n            return _withdrawCollateral(toWithdraw);\r\n        }\r\n    }\r\n\r\n    function _depositCollateral(uint256 amount) internal returns (uint256) {\r\n        if (amount == 0) return 0;\r\n        lendingPool.deposit(address(want), amount, address(this), referral);\r\n        return amount;\r\n    }\r\n\r\n    function _withdrawCollateral(uint256 amount) internal returns (uint256) {\r\n        if (amount == 0) return 0;\r\n        lendingPool.withdraw(address(want), amount, address(this));\r\n        return amount;\r\n    }\r\n\r\n    function _repayWant(uint256 amount) internal returns (uint256) {\r\n        if (amount == 0) return 0;\r\n        return lendingPool.repay(address(want), amount, 2, address(this));\r\n    }\r\n\r\n    function _borrowWant(uint256 amount) internal returns (uint256) {\r\n        if (amount == 0) return 0;\r\n        lendingPool.borrow(address(want), amount, 2, referral, address(this));\r\n        return amount;\r\n    }\r\n\r\n    // INTERNAL VIEWS\r\n    function balanceOfWant() internal view returns (uint256) {\r\n        return want.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfAToken() internal view returns (uint256) {\r\n        return aToken.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfDebtToken() internal view returns (uint256) {\r\n        return debtToken.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfAave() internal view returns (uint256) {\r\n        return IERC20(aave).balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfStkAave() internal view returns (uint256) {\r\n        return IERC20(address(stkAave)).balanceOf(address(this));\r\n    }\r\n\r\n    function _tokenRewards(\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _seconds\r\n    ) private view returns (uint256) {\r\n        (, uint256 aavePerSecond, ) = incentivesController.getAssetData(_token);\r\n        uint256 share = _amount.mul(DECIMALS).div(IERC20(_token).totalSupply());\r\n        return share.mul(aavePerSecond).mul(_seconds).div(DECIMALS);\r\n    }\r\n\r\n    // Flashloan callback function\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info memory account,\r\n        bytes memory data\r\n    ) public override {\r\n        (bool deficit, uint256 amount) = abi.decode(data, (bool, uint256));\r\n        require(msg.sender == FlashLoanLib.SOLO);\r\n        require(sender == address(this));\r\n\r\n        FlashLoanLib.loanLogic(deficit, amount, address(want));\r\n    }\r\n\r\n    function getCurrentPosition()\r\n        public\r\n        view\r\n        returns (uint256 deposits, uint256 borrows)\r\n    {\r\n        deposits = balanceOfAToken();\r\n        borrows = balanceOfDebtToken();\r\n    }\r\n\r\n    function getCurrentCollatRatio()\r\n        public\r\n        view\r\n        returns (uint256 currentCollatRatio)\r\n    {\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n\r\n        if (deposits > 0) {\r\n            currentCollatRatio = borrows.mul(COLLATERAL_RATIO_PRECISION).div(\r\n                deposits\r\n            );\r\n        }\r\n    }\r\n\r\n    function getCurrentSupply() public view returns (uint256) {\r\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\r\n        return deposits.sub(borrows);\r\n    }\r\n\r\n    // conversions\r\n    function tokenToWant(address token, uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (amount == 0 || address(want) == token) {\r\n            return amount;\r\n        }\r\n\r\n        uint256[] memory amounts =\r\n            IUni(V2ROUTER).getAmountsOut(\r\n                amount,\r\n                getTokenOutPathV2(token, address(want))\r\n            );\r\n\r\n        return amounts[amounts.length - 1];\r\n    }\r\n\r\n    function ethToWant(uint256 _amtInWei)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return tokenToWant(weth, _amtInWei);\r\n    }\r\n\r\n    // returns cooldown status\r\n    // 0 = no cooldown or past withdraw period\r\n    // 1 = claim period\r\n    // 2 = cooldown initiated, future claim period\r\n    function _checkCooldown() internal view returns (uint8) {\r\n        uint256 cooldownStartTimestamp =\r\n            IStakedAave(stkAave).stakersCooldowns(address(this));\r\n        uint256 COOLDOWN_SECONDS = IStakedAave(stkAave).COOLDOWN_SECONDS();\r\n        uint256 UNSTAKE_WINDOW = IStakedAave(stkAave).UNSTAKE_WINDOW();\r\n        uint256 nextClaimStartTimestamp =\r\n            cooldownStartTimestamp.add(COOLDOWN_SECONDS);\r\n\r\n        if (cooldownStartTimestamp == 0) {\r\n            return 0;\r\n        }\r\n        if (\r\n            block.timestamp > nextClaimStartTimestamp &&\r\n            block.timestamp <= nextClaimStartTimestamp.add(UNSTAKE_WINDOW)\r\n        ) {\r\n            return 1;\r\n        }\r\n        if (block.timestamp < nextClaimStartTimestamp) {\r\n            return 2;\r\n        }\r\n    }\r\n\r\n    function getTokenOutPathV2(address _token_in, address _token_out)\r\n        internal\r\n        pure\r\n        returns (address[] memory _path)\r\n    {\r\n        bool is_weth =\r\n            _token_in == address(weth) || _token_out == address(weth);\r\n        _path = new address[](is_weth ? 2 : 3);\r\n        _path[0] = _token_in;\r\n\r\n        if (is_weth) {\r\n            _path[1] = _token_out;\r\n        } else {\r\n            _path[1] = address(weth);\r\n            _path[2] = _token_out;\r\n        }\r\n    }\r\n\r\n    function getTokenOutPathV3(address _token_in, address _token_out)\r\n        internal\r\n        view\r\n        returns (bytes memory _path)\r\n    {\r\n        if (address(want) == weth) {\r\n            _path = abi.encodePacked(\r\n                address(aave),\r\n                aaveToWethSwapFee,\r\n                address(weth)\r\n            );\r\n        } else {\r\n            _path = abi.encodePacked(\r\n                address(aave),\r\n                aaveToWethSwapFee,\r\n                address(weth),\r\n                wethToWantSwapFee,\r\n                address(want)\r\n            );\r\n        }\r\n    }\r\n\r\n    function _sellAAVEForWant(uint256 amountIn, uint256 minOut) internal {\r\n        if (amountIn == 0) {\r\n            return;\r\n        }\r\n        if (!useUniV3) {\r\n            V2ROUTER.swapExactTokensForTokens(\r\n                amountIn,\r\n                minOut,\r\n                getTokenOutPathV2(address(aave), address(want)),\r\n                address(this),\r\n                now\r\n            );\r\n        } else {\r\n            V3ROUTER.exactInput(\r\n                ISwapRouter.ExactInputParams(\r\n                    getTokenOutPathV3(address(aave), address(want)),\r\n                    address(this),\r\n                    now,\r\n                    amountIn,\r\n                    minOut\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function _sellSTKAAVEToAAVE(uint256 amountIn, uint256 minOut) internal {\r\n        // Swap Rewards in UNIV3\r\n        // NOTE: Unoptimized, can be frontrun and most importantly this pool is low liquidity\r\n        V3ROUTER.exactInputSingle(\r\n            ISwapRouter.ExactInputSingleParams(\r\n                address(stkAave),\r\n                address(aave),\r\n                stkAaveToAaveSwapFee,\r\n                address(this),\r\n                now,\r\n                amountIn, // wei\r\n                minOut,\r\n                0\r\n            )\r\n        );\r\n    }\r\n\r\n    function getBorrowFromDeposit(uint256 deposit, uint256 collatRatio)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return deposit.mul(collatRatio).div(COLLATERAL_RATIO_PRECISION);\r\n    }\r\n\r\n    function getDepositFromBorrow(uint256 borrow, uint256 collatRatio)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return borrow.mul(COLLATERAL_RATIO_PRECISION).div(collatRatio);\r\n    }\r\n\r\n    function getBorrowFromSupply(uint256 supply, uint256 collatRatio)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            supply.mul(collatRatio).div(\r\n                COLLATERAL_RATIO_PRECISION.sub(collatRatio)\r\n            );\r\n    }\r\n\r\n    function approveMaxSpend(address token, address spender) internal {\r\n        IERC20(token).safeApprove(spender, type(uint256).max);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"Cloned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EmergencyExitEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loss\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtOutstanding\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtThreshold\",\"type\":\"uint256\"}],\"name\":\"UpdatedDebtThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newKeeper\",\"type\":\"address\"}],\"name\":\"UpdatedKeeper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxReportDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"name\":\"UpdatedMetadataURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"UpdatedMinReportDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitFactor\",\"type\":\"uint256\"}],\"name\":\"UpdatedProfitFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"}],\"name\":\"UpdatedRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStrategist\",\"type\":\"address\"}],\"name\":\"UpdatedStrategist\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aToken\",\"outputs\":[{\"internalType\":\"contract IAToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aaveToWethSwapFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apiVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Account.Info\",\"name\":\"account\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownStkAave\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtToken\",\"outputs\":[{\"internalType\":\"contract IVariableDebtToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegatedAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doHealthCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedRewardsInWant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedTotalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amtInWei\",\"type\":\"uint256\"}],\"name\":\"ethToWant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentCollatRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentCollatRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"callCostInWei\",\"type\":\"uint256\"}],\"name\":\"harvestTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"healthCheck\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDyDxActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOriginal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualDeleverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualReleaseWant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBorrowCollatRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCollatRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxIterations\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxReportDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStkAavePriceImpactBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newStrategy\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minReportDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRewardToSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellStkAave\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetCollatRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxCollatRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBorrowCollatRatio\",\"type\":\"uint256\"}],\"name\":\"setCollateralTargets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debtThreshold\",\"type\":\"uint256\"}],\"name\":\"setDebtThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_doHealthCheck\",\"type\":\"bool\"}],\"name\":\"setDoHealthCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setEmergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_healthCheck\",\"type\":\"address\"}],\"name\":\"setHealthCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isDyDxActive\",\"type\":\"bool\"}],\"name\":\"setIsDyDxActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"setKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setMaxReportDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_metadataURI\",\"type\":\"string\"}],\"name\":\"setMetadataURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setMinReportDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minWant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_maxIterations\",\"type\":\"uint8\"}],\"name\":\"setMinsAndMaxs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_profitFactor\",\"type\":\"uint256\"}],\"name\":\"setProfitFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_sellStkAave\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_cooldownStkAave\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_useUniV3\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minRewardToSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxStkAavePriceImpactBps\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"_stkAaveToAaveSwapFee\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"_aaveToWethSwapFee\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"_wethToWantSwapFee\",\"type\":\"uint24\"}],\"name\":\"setRewardBehavior\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"}],\"name\":\"setRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategist\",\"type\":\"address\"}],\"name\":\"setStrategist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stkAaveToAaveSwapFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetCollatRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"tendTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useUniV3\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract VaultAPI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"want\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethToWantSwapFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountNeeded\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_loss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Strategy","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000db25ca703181e7484a155dd612b06f57e12be5f0","EVMVersion":"Default","Library":"FlashLoanLib:0a6d9bc45077ad92272959c38a88d451836d38b5","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://493bf8a13d58be1303551b12f3faed9ad17cf27c2143e6c240d3de2d51c4eb99"}]}