{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nabstract contract ERC165 {\\n    // Includes supportsInterface method:\\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\\n\\n    /**\\n    * @dev Query if a contract implements a certain interface\\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\\n    */\\n    function supportsInterface(bytes4 _interfaceId) virtual public view returns (bool) {\\n        return _interfaceId == ERC165_INTERFACE_ID;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-core/contracts/GovernRegistry.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\n\\nimport \\\"erc3k/contracts/IERC3000.sol\\\";\\nimport \\\"erc3k/contracts/IERC3000Executor.sol\\\";\\nimport \\\"erc3k/contracts/IERC3000Registry.sol\\\";\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\\\";\\n\\ncontract GovernRegistry is IERC3000Registry {\\n    mapping(string => bool) public nameUsed;\\n\\n    function register(\\n        IERC3000Executor _executor,\\n        IERC3000 _queue,\\n        IERC20 _token,\\n        address minter,\\n        string calldata _name,\\n        bytes calldata _initialMetadata\\n    ) override external\\n    {\\n        require(!nameUsed[_name], \\\"registry: name used\\\");\\n\\n        nameUsed[_name] = true;\\n\\n        emit Registered(_executor, _queue, _token, minter, msg.sender, _name);\\n        _setMetadata(_executor, _initialMetadata);\\n    }\\n\\n    function setMetadata(bytes memory _metadata) override public {\\n        _setMetadata(IERC3000Executor(msg.sender), _metadata);\\n    }\\n\\n    function _setMetadata(IERC3000Executor _executor, bytes memory _metadata) internal {\\n        emit SetMetadata(_executor, _metadata);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-token/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/ERC3000Data.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IERC3000Executor.sol\\\";\\n\\nlibrary ERC3000Data {\\n    // TODO: come up with a non-shitty name\\n    struct Container {\\n        Payload payload;\\n        Config config;\\n    }\\n\\n    // WARN: Always remember to change the 'hash' function if modifying the struct\\n    struct Payload {\\n        uint256 nonce;\\n        uint256 executionTime;\\n        address submitter;\\n        IERC3000Executor executor;\\n        Action[] actions;\\n        bytes32 allowFailuresMap;\\n        bytes proof;\\n    }\\n\\n    struct Action {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    struct Config {\\n        uint256 executionDelay; // how many seconds to wait before being able to call `execute`.\\n        Collateral scheduleDeposit; // fees for scheduling\\n        Collateral challengeDeposit; // fees for challenging\\n        address resolver;  // resolver that will rule the disputes\\n        bytes rules; // rules of how DAO should be managed\\n        uint256 maxCalldataSize; // max calldatasize for the schedule\\n    }\\n\\n    struct Collateral {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function containerHash(bytes32 payloadHash, bytes32 configHash) internal view returns (bytes32) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        return keccak256(abi.encodePacked(\\\"erc3k-v1\\\", address(this), chainId, payloadHash, configHash));\\n    }\\n\\n    function hash(Container memory container) internal view returns (bytes32) {\\n        return containerHash(hash(container.payload), hash(container.config));\\n    }\\n\\n    function hash(Payload memory payload) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                payload.nonce,\\n                payload.executionTime,\\n                payload.submitter,\\n                payload.executor,\\n                keccak256(abi.encode(payload.actions)),\\n                payload.allowFailuresMap,\\n                keccak256(payload.proof)\\n            )\\n        );\\n    }\\n\\n    function hash(Config memory config) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(config));\\n    }\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/IERC3000.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC3000Data.sol\\\";\\n\\nabstract contract IERC3000 {\\n    /**\\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window\\n     * @param container A Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @return containerHash\\n     */\\n    function schedule(ERC3000Data.Container memory container) virtual public returns (bytes32 containerHash);\\n    event Scheduled(bytes32 indexed containerHash, ERC3000Data.Payload payload);\\n\\n    /**\\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * MUST be an ERC3000Executor call: payload.executor.exec(payload.actions)\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function execute(ERC3000Data.Container memory container) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Executed(bytes32 indexed containerHash, address indexed actor);\\n\\n    /**\\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @param reason Hint for case reviewers as to why the scheduled container is illegal\\n     * @return resolverId\\n     */\\n    function challenge(ERC3000Data.Container memory container, bytes memory reason) virtual public returns (uint256 resolverId);\\n    event Challenged(bytes32 indexed containerHash, address indexed actor, bytes reason, uint256 resolverId, ERC3000Data.Collateral collateral);\\n\\n    /**\\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @param resolverId disputeId in the arbitrator in which the dispute over the container was created\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function resolve(ERC3000Data.Container memory container, uint256 resolverId) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Resolved(bytes32 indexed containerHash, address indexed actor, bool approved);\\n\\n    /**\\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @param reason Justification for the veto\\n     */\\n    function veto(ERC3000Data.Container memory container, bytes memory reason) virtual public;\\n    event Vetoed(bytes32 indexed containerHash, address indexed actor, bytes reason);\\n\\n    /**\\n     * @notice Apply a new configuration for all *new* containers to be scheduled\\n     * @param config A ERC3000Data.Config struct holding all the new params that will control the system\\n     * @return configHash\\n     */\\n    function configure(ERC3000Data.Config memory config) virtual public returns (bytes32 configHash);\\n    event Configured(bytes32 indexed configHash, address indexed actor, ERC3000Data.Config config);\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/IERC3000Executor.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC3000Data.sol\\\";\\n\\nabstract contract IERC3000Executor {\\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\\n\\n    /**\\n     * @notice Executes all given actions\\n     * @param actions A array of ERC3000Data.Action for later executing those\\n     * @param allowFailuresMap A map with the allowed failures\\n     * @param memo The hash of the ERC3000Data.Container\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes32 memo, bytes32 failureMap, bytes[] execResults);\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/IERC3000Registry.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity 0.6.8;\\n\\nimport \\\"./IERC3000.sol\\\";\\nimport \\\"./IERC3000Executor.sol\\\";\\n\\nimport \\\"@aragon/govern-token/contracts/interfaces/IERC20.sol\\\";\\n\\nabstract contract IERC3000Registry {\\n    /**\\n     * @notice Registers a IERC3000Executor and IERC3000 contract by a name and with his metadata\\n     * @param executor IERC3000Executor contract\\n     * @param queue IERC3000 contract\\n     * @param name The name of this DAO\\n     * @param token Governance token of the DAO\\n     * @param initialMetadata Additional data to store for this DAO\\n     */\\n    function register(IERC3000Executor executor, IERC3000 queue, IERC20 token, address minter, string calldata name, bytes calldata initialMetadata) virtual external;\\n    event Registered(IERC3000Executor indexed executor, IERC3000 queue, IERC20 indexed token, address minter, address indexed registrant, string name);\\n\\n    /**\\n     * @notice Sets or updates the metadata of a DAO\\n     * @param metadata Additional data to store for this DAO\\n     */\\n    function setMetadata(bytes memory metadata) virtual public;\\n    event SetMetadata(IERC3000Executor indexed executor, bytes metadata);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC3000Executor\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC3000\",\"name\":\"queue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC3000Executor\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"SetMetadata\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nameUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3000Executor\",\"name\":\"_executor\",\"type\":\"address\"},{\"internalType\":\"contract IERC3000\",\"name\":\"_queue\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_initialMetadata\",\"type\":\"bytes\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_metadata\",\"type\":\"bytes\"}],\"name\":\"setMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GovernRegistry","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}