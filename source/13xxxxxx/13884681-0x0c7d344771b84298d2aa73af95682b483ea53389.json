{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/STokensDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity 0.8.4;\\n\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {AddressLib} from \\\"@devprotocol/util-contracts/contracts/utils/AddressLib.sol\\\";\\nimport {Base64} from \\\"@devprotocol/util-contracts/contracts/utils/Base64.sol\\\";\\nimport {ISTokenManagerDescriptor} from \\\"./interface/ISTokenManagerDescriptor.sol\\\";\\n\\ncontract STokensDescriptor is ISTokenManagerDescriptor {\\n\\tusing Base64 for bytes;\\n\\tusing AddressLib for address;\\n\\tusing Strings for uint256;\\n\\n\\tfunction getTokenURI(\\n\\t\\taddress _property,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _cumulativeReward,\\n\\t\\tstring memory _tokeUriImage\\n\\t) external pure override returns (string memory) {\\n\\t\\tstring memory name = string(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\\"Dev Protocol sTokens - \\\",\\n\\t\\t\\t\\t_property.toChecksumString(),\\n\\t\\t\\t\\t\\\" - \\\",\\n\\t\\t\\t\\t_amount.toString(),\\n\\t\\t\\t\\t\\\" DEV\\\",\\n\\t\\t\\t\\t\\\" - \\\",\\n\\t\\t\\t\\t_cumulativeReward.toString()\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\tstring memory description = string(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\\"This NFT represents a staking position in a Dev Protocol Property tokens. The owner of this NFT can modify or redeem the position.\\\\\\\\nProperty Address: \\\",\\n\\t\\t\\t\\t_property.toChecksumString(),\\n\\t\\t\\t\\t\\\"\\\\\\\\n\\\\\\\\n\\\\xE2\\\\x9A\\\\xA0 DISCLAIMER: Due diligence is imperative when assessing this NFT. Make sure token addresses match the expected tokens, as token symbols may be imitated.\\\"\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\tif (bytes(_tokeUriImage).length == 0) {\\n\\t\\t\\tbytes memory image = bytes(\\n\\t\\t\\t\\tabi\\n\\t\\t\\t\\t\\t.encodePacked(\\n\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t'<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"290\\\" height=\\\"500\\\" viewBox=\\\"0 0 290 500\\\" fill=\\\"none\\\"><rect width=\\\"290\\\" height=\\\"500\\\" fill=\\\"url(#paint0_linear)\\\"/><path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M192 203H168.5V226.5V250H145H121.5V226.5V203H98H74.5V226.5V250V273.5H51V297H74.5H98V273.5H121.5H145H168.5H192V250V226.5H215.5H239V203H215.5H192Z\\\" fill=\\\"white\\\"/><text fill=\\\"white\\\" xml:space=\\\"preserve\\\" style=\\\"white-space: pre\\\" font-family=\\\"monospace\\\" font-size=\\\"11\\\" letter-spacing=\\\"0em\\\"><tspan x=\\\"27.4072\\\" y=\\\"333.418\\\">',\\n\\t\\t\\t\\t\\t\\t_property.toChecksumString(),\\n\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t'</tspan></text><defs><linearGradient id=\\\"paint0_linear\\\" x1=\\\"0\\\" y1=\\\"0\\\" x2=\\\"290\\\" y2=\\\"500\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop stop-color=\\\"#00D0FD\\\"/><stop offset=\\\"0.151042\\\" stop-color=\\\"#4889F5\\\"/><stop offset=\\\"0.552083\\\" stop-color=\\\"#D500E6\\\"/><stop offset=\\\"1\\\" stop-color=\\\"#FF3815\\\"/></linearGradient></defs></svg>'\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t.encode()\\n\\t\\t\\t);\\n\\t\\t\\treturn\\n\\t\\t\\t\\tstring(\\n\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t\\\"data:application/json;base64,\\\",\\n\\t\\t\\t\\t\\t\\tbytes(\\n\\t\\t\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t\\t'{\\\"name\\\":\\\"',\\n\\t\\t\\t\\t\\t\\t\\t\\tname,\\n\\t\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t\\t'\\\", \\\"description\\\":\\\"',\\n\\t\\t\\t\\t\\t\\t\\t\\tdescription,\\n\\t\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t\\t'\\\", \\\"image\\\": \\\"',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\\"data:image/svg+xml;base64,\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\timage,\\n\\t\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t\\t'\\\"}'\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t).encode()\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn\\n\\t\\t\\tstring(\\n\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\\"data:application/json;base64,\\\",\\n\\t\\t\\t\\t\\tbytes(\\n\\t\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t'{\\\"name\\\":\\\"',\\n\\t\\t\\t\\t\\t\\t\\tname,\\n\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t'\\\", \\\"description\\\":\\\"',\\n\\t\\t\\t\\t\\t\\t\\tdescription,\\n\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t'\\\", \\\"image\\\": \\\"',\\n\\t\\t\\t\\t\\t\\t\\t_tokeUriImage,\\n\\t\\t\\t\\t\\t\\t\\t// solhint-disable-next-line quotes\\n\\t\\t\\t\\t\\t\\t\\t'\\\"}'\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t).encode()\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@devprotocol/util-contracts/contracts/utils/AddressLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.0;\\n\\n// see https://ethereum.stackexchange.com/questions/63908/address-checksum-solidity-implementation\\nlibrary AddressLib {\\n\\tfunction toChecksumString(address account)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory asciiString)\\n\\t{\\n\\t\\t// convert the account argument from address to bytes.\\n\\t\\tbytes20 data = bytes20(account);\\n\\n\\t\\t// create an in-memory fixed-size bytes array.\\n\\t\\tbytes memory asciiBytes = new bytes(40);\\n\\n\\t\\t// declare variable types.\\n\\t\\tuint8 b;\\n\\t\\tuint8 leftNibble;\\n\\t\\tuint8 rightNibble;\\n\\t\\tbool leftCaps;\\n\\t\\tbool rightCaps;\\n\\t\\tuint8 asciiOffset;\\n\\n\\t\\t// get the capitalized characters in the actual checksum.\\n\\t\\tbool[40] memory caps = _toChecksumCapsFlags(account);\\n\\n\\t\\t// iterate over bytes, processing left and right nibble in each iteration.\\n\\t\\tfor (uint256 i = 0; i < data.length; i++) {\\n\\t\\t\\t// locate the byte and extract each nibble.\\n\\t\\t\\tb = uint8(uint160(data) / (2**(8 * (19 - i))));\\n\\t\\t\\tleftNibble = b / 16;\\n\\t\\t\\trightNibble = b - 16 * leftNibble;\\n\\n\\t\\t\\t// locate and extract each capitalization status.\\n\\t\\t\\tleftCaps = caps[2 * i];\\n\\t\\t\\trightCaps = caps[2 * i + 1];\\n\\n\\t\\t\\t// get the offset from nibble value to ascii character for left nibble.\\n\\t\\t\\tasciiOffset = _getAsciiOffset(leftNibble, leftCaps);\\n\\n\\t\\t\\t// add the converted character to the byte array.\\n\\t\\t\\tasciiBytes[2 * i] = bytes1(leftNibble + asciiOffset)[0];\\n\\n\\t\\t\\t// get the offset from nibble value to ascii character for right nibble.\\n\\t\\t\\tasciiOffset = _getAsciiOffset(rightNibble, rightCaps);\\n\\n\\t\\t\\t// add the converted character to the byte array.\\n\\t\\t\\tasciiBytes[2 * i + 1] = bytes1(rightNibble + asciiOffset)[0];\\n\\t\\t}\\n\\n\\t\\treturn string(abi.encodePacked(\\\"0x\\\", string(asciiBytes)));\\n\\t}\\n\\n\\tfunction _toChecksumCapsFlags(address account)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (bool[40] memory characterCapitalized)\\n\\t{\\n\\t\\t// convert the address to bytes.\\n\\t\\tbytes20 a = bytes20(account);\\n\\n\\t\\t// hash the address (used to calculate checksum).\\n\\t\\tbytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));\\n\\n\\t\\t// declare variable types.\\n\\t\\tuint8 leftNibbleAddress;\\n\\t\\tuint8 rightNibbleAddress;\\n\\t\\tuint8 leftNibbleHash;\\n\\t\\tuint8 rightNibbleHash;\\n\\n\\t\\t// iterate over bytes, processing left and right nibble in each iteration.\\n\\t\\tfor (uint256 i; i < a.length; i++) {\\n\\t\\t\\t// locate the byte and extract each nibble for the address and the hash.\\n\\t\\t\\trightNibbleAddress = uint8(a[i]) % 16;\\n\\t\\t\\tleftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;\\n\\t\\t\\trightNibbleHash = uint8(b[i]) % 16;\\n\\t\\t\\tleftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;\\n\\n\\t\\t\\tcharacterCapitalized[2 * i] = (leftNibbleAddress > 9 &&\\n\\t\\t\\t\\tleftNibbleHash > 7);\\n\\t\\t\\tcharacterCapitalized[2 * i + 1] = (rightNibbleAddress > 9 &&\\n\\t\\t\\t\\trightNibbleHash > 7);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getAsciiOffset(uint8 nibble, bool caps)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (uint8 offset)\\n\\t{\\n\\t\\t// to convert to ascii characters, add 48 to 0-9, 55 to A-F, & 87 to a-f.\\n\\t\\tif (nibble < 10) {\\n\\t\\t\\toffset = 48;\\n\\t\\t} else if (caps) {\\n\\t\\t\\toffset = 55;\\n\\t\\t} else {\\n\\t\\t\\toffset = 87;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _toAsciiString(bytes20 data)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (string memory asciiString)\\n\\t{\\n\\t\\t// create an in-memory fixed-size bytes array.\\n\\t\\tbytes memory asciiBytes = new bytes(40);\\n\\n\\t\\t// declare variable types.\\n\\t\\tuint8 b;\\n\\t\\tuint8 leftNibble;\\n\\t\\tuint8 rightNibble;\\n\\n\\t\\t// iterate over bytes, processing left and right nibble in each iteration.\\n\\t\\tfor (uint256 i = 0; i < data.length; i++) {\\n\\t\\t\\t// locate the byte and extract each nibble.\\n\\t\\t\\tb = uint8(uint160(data) / (2**(8 * (19 - i))));\\n\\t\\t\\tleftNibble = b / 16;\\n\\t\\t\\trightNibble = b - 16 * leftNibble;\\n\\n\\t\\t\\t// to convert to ascii characters, add 48 to 0-9 and 87 to a-f.\\n\\t\\t\\tasciiBytes[2 * i] = bytes1(\\n\\t\\t\\t\\tleftNibble + (leftNibble < 10 ? 48 : 87)\\n\\t\\t\\t)[0];\\n\\t\\t\\tasciiBytes[2 * i + 1] = bytes1(\\n\\t\\t\\t\\trightNibble + (rightNibble < 10 ? 48 : 87)\\n\\t\\t\\t)[0];\\n\\t\\t}\\n\\n\\t\\treturn string(asciiBytes);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@devprotocol/util-contracts/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.0;\\n\\n// see https://github.com/Brechtpd/base64/blob/main/base64.sol\\nlibrary Base64 {\\n\\tstring internal constant TABLE =\\n\\t\\t\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n\\tfunction encode(bytes memory data) internal pure returns (string memory) {\\n\\t\\tif (data.length == 0) return \\\"\\\";\\n\\n\\t\\t// load the table into memory\\n\\t\\tstring memory table = TABLE;\\n\\n\\t\\t// multiply by 4/3 rounded up\\n\\t\\tuint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n\\t\\t// add some extra buffer at the end required for the writing\\n\\t\\tstring memory result = new string(encodedLen + 32);\\n\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// set the actual output length\\n\\t\\t\\tmstore(result, encodedLen)\\n\\n\\t\\t\\t// prepare the lookup table\\n\\t\\t\\tlet tablePtr := add(table, 1)\\n\\n\\t\\t\\t// input ptr\\n\\t\\t\\tlet dataPtr := data\\n\\t\\t\\tlet endPtr := add(dataPtr, mload(data))\\n\\n\\t\\t\\t// result ptr, jump over length\\n\\t\\t\\tlet resultPtr := add(result, 32)\\n\\n\\t\\t\\t// run over the input, 3 bytes at a time\\n\\t\\t\\tfor {\\n\\n\\t\\t\\t} lt(dataPtr, endPtr) {\\n\\n\\t\\t\\t} {\\n\\t\\t\\t\\tdataPtr := add(dataPtr, 3)\\n\\n\\t\\t\\t\\t// read 3 bytes\\n\\t\\t\\t\\tlet input := mload(dataPtr)\\n\\n\\t\\t\\t\\t// write 4 characters\\n\\t\\t\\t\\tmstore(\\n\\t\\t\\t\\t\\tresultPtr,\\n\\t\\t\\t\\t\\tshl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t\\tmstore(\\n\\t\\t\\t\\t\\tresultPtr,\\n\\t\\t\\t\\t\\tshl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t\\tmstore(\\n\\t\\t\\t\\t\\tresultPtr,\\n\\t\\t\\t\\t\\tshl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t\\tmstore(\\n\\t\\t\\t\\t\\tresultPtr,\\n\\t\\t\\t\\t\\tshl(248, mload(add(tablePtr, and(input, 0x3F))))\\n\\t\\t\\t\\t)\\n\\t\\t\\t\\tresultPtr := add(resultPtr, 1)\\n\\t\\t\\t}\\n\\n\\t\\t\\t// padding with '='\\n\\t\\t\\tswitch mod(mload(data), 3)\\n\\t\\t\\tcase 1 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n\\t\\t\\t}\\n\\t\\t\\tcase 2 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 1), shl(248, 0x3d))\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ISTokenManagerDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity 0.8.4;\\n\\nimport {ISTokenManagerStruct} from \\\"./ISTokenManagerStruct.sol\\\";\\n\\ninterface ISTokenManagerDescriptor {\\n\\t/*\\n\\t * @dev get toke uri from position information.\\n\\t * @param _property The struct of positon information\\n\\t * @param _amount The struct of positon information\\n\\t * @param _cumulativeReward Cumulative Rewards\\n\\t * @param _tokeUriImage The struct of positon information\\n\\t */\\n\\tfunction getTokenURI(\\n\\t\\taddress _property,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _cumulativeReward,\\n\\t\\tstring memory _tokeUriImage\\n\\t) external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ISTokenManagerStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity 0.8.4;\\n\\ninterface ISTokenManagerStruct {\\n\\t/*\\n\\t * @dev Struct to declares a staking position.\\n\\t * @param owner The address of the owner of the new staking position\\n\\t * @param property The address of the Property as the staking destination\\n\\t * @param amount The amount of the new staking position\\n\\t * @param price The latest unit price of the cumulative staking reward\\n\\t * @param cumulativeReward The cumulative withdrawn reward amount\\n\\t * @param pendingReward The pending withdrawal reward amount amount\\n\\t */\\n\\tstruct StakingPositionV1 {\\n\\t\\taddress property;\\n\\t\\tuint256 amount;\\n\\t\\tuint256 price;\\n\\t\\tuint256 cumulativeReward;\\n\\t\\tuint256 pendingReward;\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_property\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cumulativeReward\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokeUriImage\",\"type\":\"string\"}],\"name\":\"getTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"STokensDescriptor","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}