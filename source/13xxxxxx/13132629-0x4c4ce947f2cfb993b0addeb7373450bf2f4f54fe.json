{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.5;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ncontract TokenInfos {\r\n    \r\n    /* Fallback function, don't accept any ETH */\r\n    receive() external payable {\r\n        // revert();\r\n        revert(\"BalanceChecker does not accept payments\");\r\n    }\r\n    \r\n    function isContract(address token) public view returns(bool){\r\n        // check if token is actually a contract\r\n        uint256 tokenCode;\r\n        assembly { tokenCode := extcodesize(token) } // contract code size\r\n        return tokenCode > 0;\r\n    }\r\n    \r\n    /**\r\n     * get token symbols for multiple tokens\r\n     */\r\n    function getTokenSymbols(address[] memory tokens) external view returns(string[] memory){\r\n        string[] memory symbols = new string[](tokens.length);\r\n        for(uint32 i = 0; i < tokens.length; i ++){\r\n            if(isContract(tokens[i])){\r\n                IERC20 t = IERC20(tokens[i]);\r\n                symbols[i] = (t.symbol());\r\n            }else{\r\n                symbols[i] = \"\";\r\n            }\r\n        }\r\n        return symbols;\r\n    } \r\n    \r\n    /**\r\n     * get token decimals for multiple tokens\r\n     */\r\n    function getTokenDecimals(address[] memory tokens) external view returns(uint8[] memory){\r\n        uint8[] memory decimals = new uint8[](tokens.length);\r\n        for(uint32 i = 0; i < tokens.length; i ++){\r\n            if(isContract(tokens[i])){\r\n                IERC20 t = IERC20(tokens[i]);\r\n                decimals[i] = (t.decimals());\r\n            }else{\r\n                decimals[i] = 0;\r\n            }\r\n        }\r\n        return decimals;\r\n    } \r\n    \r\n    /**\r\n     * check token allowances for multiple tokens to spenders\r\n     */\r\n    function getTokenAllowance(address[] memory tokens, address[] memory contracts, address account) external view returns(uint256[] memory){\r\n        uint256[] memory allowances = new uint256[](tokens.length);\r\n        for(uint32 i = 0; i < tokens.length; i ++){\r\n            if(isContract(tokens[i])){\r\n                IERC20 t = IERC20(tokens[i]);\r\n                uint256 amount = t.allowance(account, contracts[i]);\r\n                allowances[i] = amount;\r\n            }else{\r\n                allowances[i] = 0;\r\n            }\r\n        }\r\n        return allowances;\r\n    }\r\n   \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTokenAllowance\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getTokenDecimals\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getTokenSymbols\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"TokenInfos","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://831514f011c0ee5bf1d2f3e9d732ab1633ca8d4c25db16e21cfa1ee0db107f75"}]}