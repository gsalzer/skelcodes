{"status":"1","message":"OK","result":[{"SourceCode":"{\"push2ENS.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\n//  ____  _  _  ____  _  _    ____    ____  __ _  ____\\n// (  _ \\\\/ )( \\\\/ ___)/ )( \\\\  (___ \\\\  (  __)(  ( \\\\/ ___)\\n//  ) __/) \\\\/ (\\\\___ \\\\) __ (   / __/   ) _) /    /\\\\___ \\\\\\n// (__)  \\\\____/(____/\\\\_)(_/  (____)  (____)\\\\_)__)(____/\\n//\\n// By Alex Van de Sande\\n//\\n// A little contract that adds push \\u0026 pull money transfer to ENS ensAddresses.\\n// Will work with any ENS, existing or future, including DNS names!\\n// Ether, tokens and NFTs remain locked by contract until ENS is set up properly.\\n// Once ENS points to a non-zero address, anyone can pull it there.\\n//\\n// Want to donate USDC to wikipedia.org but they don\\u0027t have an eth address yet?\\n// Want to send an NFT to xkcd.org but you\\u0027re not sure how to trust the address?\\n// Want to make an Ether bounty for the Ethiopian government to be aware of ENS?\\n// Now you can do all that and more!\\n// But wait, there\\u0027s more! You can also use it to push to a normal address.\\n// Just because.\\n//\\n// ATTENTION: use at your own risk! I\\u0027ve barely tested it. And by barely I mean I tried a couple different things\\n// on rinkeby and once they worked I deployed to mainnet. NFTs don\\u0027t use _safeTransfer\\n// because I was too lazy to build my own onerc721Received. Be careful out there.\\n\\npragma solidity ^0.8.0;\\n/// @title Push to ENS\\n/// @author Alex Van de Sande\\n/// @notice Allows tokens and ether to be deposited to ENS names\\n/// @dev Supports ether, erc20 tokens and erc721 NFTs.\\n\\nimport \\\"./supportsENS.sol\\\";\\n\\n// works for both Tokens and NFTs\\nabstract contract Transferable {\\n    function transferFrom(address from, address to, uint tokens) virtual public;\\n}\\n\\ncontract PushToENS is SupportsENS {\\n\\n  /// @notice Internal balance function\\n  /// @dev Balances are a hash based on token and account information\\n  mapping(bytes32 =\\u003e Balance) public balances;\\n\\n  struct Balance {\\n      uint256 withdrawable;\\n      uint256 lastBlockPulled;\\n      mapping(address =\\u003e uint256) pusher;\\n      mapping(address =\\u003e uint256) lastPushed;\\n  }\\n\\n  event Pushed(bytes32 nameHash, address assetAddress, uint8 sendType, uint256 amount);\\n  event Pulled(bytes32 nameHash, address assetAddress, uint8 sendType, uint256 amount);\\n  event Cancel(bytes32 nameHash, address assetAddress, uint8 sendType, uint256 amount);\\n\\n  // PUSH FUNCTIONS\\n\\n   /**\\n    * @dev Generic internal push functions\\n    */\\n  function _push (bytes32 hash, uint256 amount, address assetAddress, uint8 sendType) internal {\\n    Balance storage balance = balances[hash];\\n\\n    // If there was a pull since you last pushed, then you can\\u0027t withdraw that amount anymore\\n    if (balance.lastPushed[msg.sender] \\u003c balance.lastBlockPulled) balance.pusher[msg.sender]=0;\\n\\n    // Weird things can happen in the same block\\n    require(balance.lastPushed[msg.sender] != balance.lastBlockPulled || balance.lastBlockPulled == 0, \\\"You can\\u0027t push the same block on a pull\\\");\\n\\n    // Prevent Overflows\\n    require(balance.pusher[msg.sender] + amount \\u003e balance.pusher[msg.sender] , \\\"Overflow detected!\\\");\\n    require(balance.withdrawable + amount \\u003e balance.withdrawable , \\\"Overflow detected!\\\");\\n\\n    // Increase the balances\\n    balance.withdrawable  += amount;\\n    balance.pusher[msg.sender]+= amount;\\n    balance.lastPushed[msg.sender] = block.number;\\n\\n    // tell everyone about it\\n    emit Pushed(hash, assetAddress, sendType, amount);\\n  }\\n\\n   /**\\n    * @notice Pushes ether sent in transaction for an ENS name represented by `nameHash`\\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\\n    */\\n  function pushEther2ENS (bytes32 nameHash) public payable {\\n    _push(nameHash, msg.value, 0x0000000000000000000000000000000000000000, 0);\\n  }\\n\\n   /**\\n    * @notice Pushes ether sent in transaction for `ethAddress`\\n    * @param ethAddress a standard ethereum compatible address\\n    */\\n  function pushEther2Ethadd (address ethAddress) public payable {\\n    _push(keccak256(abi.encode(ethAddress)), msg.value, 0x0000000000000000000000000000000000000000, 1);\\n  }\\n\\n   /**\\n    * @notice Pushes `amount` standard units of the `assetAddress` token for an ENS address represented by `nameHash`.\\n    * @notice If `nftId` is set, then it assumes it\\u0027s a ERC721 NFT and sends the one with `nftId`.\\n    * @dev If it\\u0027s a token, leave nftId as 0. Can\\u0027t send any NFT with id 0.\\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\\n    * @param assetAddress The address of either the token or NFT\\n    * @param amount Token amount. If it\\u0027s an NFT, leave 0.\\n    * @param nftId the id of the NFT being sent. If it\\u0027s a token, leave 0.\\n    */\\n  function pushAsset2ENS (bytes32 nameHash, address assetAddress, uint256 amount, uint256 nftId) public {\\n     // instantiate token\\n     Transferable asset = Transferable(assetAddress);\\n     uint256 wat;\\n\\n     if (nftId==0) {\\n        // If fungible, then add all balances\\n        wat = amount;\\n        _push(keccak256(abi.encode(nameHash,assetAddress)), amount, assetAddress, 2);\\n     } else {\\n       // If not, then use amount as the nft ID\\n       wat = nftId;\\n        _push(keccak256(abi.encode(nameHash,assetAddress,nftId)), nftId, assetAddress, 3);\\n    }\\n\\n    // transfer assets. Doesn\\u0027t add a require, assumes token will revert if fails\\n    asset.transferFrom(msg.sender, address(this), wat);\\n  }\\n\\n  // PULL FUNCTIONS\\n\\n   /**\\n    * @dev Generic internal pull function\\n    */\\n  function _pull (bytes32 hash, address assetAddress, uint8 sendType) internal returns (uint256 amount){\\n    Balance storage balance = balances[hash];\\n\\n    amount = balance.withdrawable;\\n\\n    //Pull full amount always\\n    balance.withdrawable=0;\\n    balance.lastBlockPulled = block.number;\\n\\n    // Interaction\\n    emit Pulled(hash, assetAddress, sendType, amount );\\n\\n    return amount;\\n  }\\n\\n   /**\\n    * @notice Pulls ether for any valid ENS name.\\n    * @dev Function can be called by anyone. Will revert if ENS name is not set, or set to 0x.\\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\\n    */\\n  function pullEther2ENS (bytes32 nameHash) public {\\n      // Zeroes out full balance\\n      uint256 amount = _pull(nameHash, 0x0000000000000000000000000000000000000000, 0);\\n\\n      //Interaction\\n      // getSafeENSAddress prevents returning empty address\\n      sendValue(payable(getSafeENSAddress(nameHash)), amount);\\n  }\\n\\n   /**\\n    * @notice Pulls all ether pushed for your address.\\n    * @dev Can only be called by the address receiving the token.\\n    */\\n  function pullEther2Ethadd () public {\\n      // Zeroes out full balance\\n      uint256 amount = _pull(keccak256(abi.encode(msg.sender)), 0x0000000000000000000000000000000000000000, 1);\\n\\n      //Interaction\\n      sendValue(payable(msg.sender), amount);\\n  }\\n\\n   /**\\n    * @notice Pulls all of the balance from token `assetAddress` for the ENS address represented by `nameHash`.\\n    * @notice If `nftId` is set, then it assumes it\\u0027s a NFT and pulls the one with `nftId`.\\n    * @dev Can be called by anyone. If it\\u0027s a token, leave nftId as 0. Can only pull full amounts.\\n    * @dev Function will revert if ENS is not set or set to 0x0.\\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\\n    * @param assetAddress The address of either the token or NFT\\n    * @param nftId the id of the NFT being sent. If it\\u0027s a token, leave 0.\\n     */\\n  function pullAsset2ENS (bytes32 nameHash, address assetAddress, uint nftId) public {\\n       // instantiate token\\n     Transferable asset = Transferable(assetAddress);\\n    uint256 wat;\\n    // If it\\u0027s a token then use nftId as 0\\n    if (nftId==0){\\n      //if ID is 0 then it\\u0027s a token\\n      wat = _pull(keccak256(abi.encode(nameHash,assetAddress)), assetAddress, 2);\\n    } else {\\n      //if ID is set then it\\u0027s an NFT\\n      wat = nftId;\\n      _pull(keccak256(abi.encode(nameHash, assetAddress, nftId)), assetAddress, 3);\\n    }\\n\\n    // getSafeENSAddress prevents returning empty address\\n      asset.transferFrom(address(this), getSafeENSAddress(nameHash), wat);\\n  }\\n\\n    // CANCEL FUNCTIONS\\n\\n   /**\\n    * @dev Generic internal cancel function\\n    */\\n  function _cancel (bytes32 hash, uint256 amount, address assetAddress, uint8 sendType) internal {\\n     Balance storage balance = balances[hash];\\n\\n    // Can only cancel if there wasn\\u0027t a push yet\\n    require(balance.lastPushed[msg.sender] \\u003e balance.lastBlockPulled || balance.lastBlockPulled == 0, \\\"Recipient already withdrew\\\");\\n\\n    // Check if enough balance\\n    require(amount \\u003c= balance.pusher[msg.sender] , \\\"Not enough balance\\\");\\n    require(amount \\u003c= balance.withdrawable , \\\"Not enough balance\\\");\\n\\n    // Decrease both balances\\n    balance.pusher[msg.sender]-= amount;\\n    balance.withdrawable -= amount;\\n\\n    // Interaction\\n    emit Cancel(hash, assetAddress, sendType, amount );\\n  }\\n\\n  /**\\n    * @dev Get back `amount/1000000000000000000` ether you had pushed to an ENS name but it hasn\\u0027t pulled yet.\\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\\n    * @param amount Ether amount you want to get back.\\n    */\\n  function cancelEther2ENS (bytes32 nameHash, uint256 amount) public {\\n      // Generic cancel function\\n      _cancel(nameHash, amount, 0x0000000000000000000000000000000000000000, 0);\\n\\n      //Interaction\\n      // getSafeENSAddress prevents returning empty address\\n      sendValue(payable(msg.sender), amount);\\n  }\\n\\n\\n   /**\\n    * @dev Get back `amount/1000000000000000000` ether you had pushed to an Eth address name but it hasn\\u0027t pulled yet.\\n    * @param ethAddress The address which you had pushed to.\\n    * @param amount Ether amount you want to get back.\\n    */\\n  function cancelEther2Ethadd (address ethAddress, uint256 amount) public {\\n      // Generic cancel function\\n       _cancel(keccak256(abi.encode(ethAddress)), amount, 0x0000000000000000000000000000000000000000, 1);\\n\\n      //Interaction\\n      sendValue(payable(msg.sender), amount);\\n  }\\n\\n   /**\\n    * @notice Get back tokens or NFT you had pushed to an ENS name but hasn\\u0027t been claimed yet.\\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\\n    * @param assetAddress The address of either the token or NFT\\n    * @param amount Amount you want to pull back\\n    * @param nftId the id of the NFT being sent. If it\\u0027s a token, leave 0.\\n    */\\n  function cancelAsset2ENS (bytes32 nameHash,  address assetAddress, uint256 amount, uint256 nftId) public {\\n       // instantiate token\\n     Transferable asset = Transferable(assetAddress);\\n     uint256 wat;\\n     //generic cancel\\n     // getSafeENSAddress prevents returning empty address\\n     if (nftId==0) {\\n       // If it\\u0027s a token then pull all of them\\n       wat= amount;\\n       _cancel(keccak256(abi.encode(nameHash,assetAddress)), amount, assetAddress, 2);\\n     } else {\\n       // if it\\u0027s an NFT use amount as tokenId\\n       wat=nftId;\\n       _cancel(keccak256(abi.encode(nameHash, assetAddress, amount)), amount, assetAddress, 3);\\n     }\\n\\n    // transfer tokens\\n    asset.transferFrom(address(this), msg.sender, wat);\\n\\n  }\\n\\n\\n     /**\\n     * Open Zeppellin\\u0027s Send Value\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"},\"supportsENS.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// This is a quick and small library for allowing any contract to\\n// use ENS names like they would use a standard address.\\n// So a DAO can have bob.eth as the member, instead of 0x123,\\n// and therefore Bob can change that address to whatever they prefer\\n// or give out a tip that can be only received by the rightful owner of example.com\\n// even if example.com owner never heard about ethereum!\\n//\\n// To use it, just use a store the NameHash as a string and then call\\n// updateAddress(NameHash) to save the latest ethereum address it points to\\n// Once that has been saved, use ensAddresses(NameHash) to obtain a valid eth address.\\n// Optionally, you can check lastUpdatedENSAt(NameHash) to check the last time\\n// it was updated. If it was never updated then both functions should return 0:\\n// IMPORTANT: check if address is not address(0) before sending ether.\\n\\n// Learn more about NameHash: https://docs.ens.domains/contract-api-reference/name-processing\\n// Learn more about full DNS support in ENS: https://medium.com/the-ethereum-name-service/full-dns-namespace-integration-to-ens-now-on-mainnet-9d37270807d3\\n// Learn more about ENS: ens.domains\\n\\n// Author: Alex Van de Sande\\n// License: Public Domain\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract  ENS {\\n    function resolver(bytes32 node) public virtual view  returns (Resolver);\\n}\\n\\nabstract contract Resolver {\\n    function addr(bytes32 node) public virtual view returns (address);\\n}\\n\\ncontract SupportsENS {\\n    // Same address for Mainet, Ropsten, Rinkerby, Gorli and other networks;\\n    ENS ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\\n\\n    // Optional modifier to only allow calls from a specific ENS owner\\n    modifier onlyENSOwner(bytes32 nameHash) {\\n        require(\\n            msg.sender == getENSAddress(nameHash),\\n            \\\"Only ENS owner can call this contract\\\"\\n            );\\n            _;\\n    }\\n\\n    // Main function to get an address\\n    // ATTENTION: if an ENS is not set or claimed, it will return 0x0.\\n    // Make sure to check this before sending ether.\\n    function getENSAddress(bytes32 nameHash) public view returns (address){\\n        Resolver resolver = ens.resolver(nameHash);\\n        return resolver.addr(nameHash);\\n    }\\n\\n    // Similar to the function above but will\\n    // revert if the address returns 0x00..\\n    function getSafeENSAddress(bytes32 nameHash) public view returns (address){\\n        Resolver resolver = ens.resolver(nameHash);\\n        address res = resolver.addr(nameHash);\\n        require(res != address(0), \\\"address not set or set to burn\\\");\\n        return res;\\n    }\\n\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sendType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sendType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Pulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sendType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Pushed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlockPulled\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"cancelAsset2ENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancelEther2ENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancelEther2Ethadd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"}],\"name\":\"getENSAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"}],\"name\":\"getSafeENSAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"pullAsset2ENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"}],\"name\":\"pullEther2ENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullEther2Ethadd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"pushAsset2ENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"}],\"name\":\"pushEther2ENS\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethAddress\",\"type\":\"address\"}],\"name\":\"pushEther2Ethadd\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"PushToENS","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6ef332eee6dfb340340afc6d314a07df57a4beecbf1100ea85d09ac64448bb50"}]}