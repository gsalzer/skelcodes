{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/merkle-drop/ERC721MerkleDrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {IERC721MerkleDrop} from \\\"./interface/IERC721MerkleDrop.sol\\\";\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\nimport {Pausable} from \\\"../lib/Pausable.sol\\\";\\nimport {Reentrancy} from \\\"../lib/Reentrancy.sol\\\";\\nimport {IERC721, IERC721Events} from \\\"../lib/ERC721/interface/IERC721.sol\\\";\\nimport {IMirrorFeeConfig} from \\\"../fee-config/MirrorFeeConfig.sol\\\";\\nimport {ITreasuryConfig} from \\\"../treasury/interface/ITreasuryConfig.sol\\\";\\nimport {IMirrorTreasury} from \\\"../treasury/interface/IMirrorTreasury.sol\\\";\\n\\n/**\\n * @title ERC721MerkleDrop\\n * @author MirrorXYZ\\n */\\ncontract ERC721MerkleDrop is\\n    IERC721MerkleDrop,\\n    Ownable,\\n    Pausable,\\n    Reentrancy,\\n    IERC721Events\\n{\\n    /// @notice Address for factory that deploys clones\\n    address public immutable factory;\\n\\n    /// @notice Address for Mirror's fee configuration\\n    address public immutable feeConfig;\\n\\n    /// @notice Address for Mirror's treasury configuration\\n    address public immutable treasuryConfig;\\n\\n    /// @notice Merkle root\\n    bytes32 public merkleRoot;\\n\\n    /// @notice Claim deadline block\\n    uint256 public claimDeadline;\\n\\n    /// @notice Funds recipient\\n    address public recipient;\\n\\n    /// @notice ERC721 token address\\n    address public token;\\n\\n    /// @notice ERC721 tokens holder\\n    address public tokenOwner;\\n\\n    /// @notice Start token-id\\n    uint256 public startTokenId;\\n\\n    /// @notice End token-id\\n    uint256 public endTokenId;\\n\\n    /// @notice Current token-id\\n    uint256 public currentTokenId;\\n\\n    /// @notice Map of claimed token hashes\\n    mapping(bytes32 => bool) public claimed;\\n\\n    constructor(\\n        address factory_,\\n        address feeConfig_,\\n        address treasuryConfig_\\n    ) Ownable(address(0)) Pausable(true) {\\n        factory = factory_;\\n        feeConfig = feeConfig_;\\n        treasuryConfig = treasuryConfig_;\\n    }\\n\\n    function initialize(\\n        address owner_,\\n        bool paused_,\\n        bytes32 merkleRoot_,\\n        uint256 claimDeadline_,\\n        address recipient_,\\n        address token_,\\n        address tokenOwner_,\\n        uint256 startTokenId_,\\n        uint256 endTokenId_\\n    ) external override {\\n        // ensure that this function is only callable by the factory\\n        require(msg.sender == factory, \\\"unauthorized caller\\\");\\n\\n        // set owner\\n        _setOwner(address(0), owner_);\\n\\n        // set pause status\\n        if (paused_) {\\n            _pause();\\n        }\\n\\n        // set merkle-root\\n        merkleRoot = merkleRoot_;\\n\\n        // set claim deadline\\n        claimDeadline = claimDeadline_;\\n\\n        // set recipient\\n        recipient = recipient_;\\n\\n        // set erc721 token address\\n        token = token_;\\n\\n        // set address that owns the tokens\\n        tokenOwner = tokenOwner_;\\n\\n        // set start and end token-ids\\n        startTokenId = startTokenId_;\\n        endTokenId = endTokenId_;\\n\\n        // set currentTokenId\\n        currentTokenId = startTokenId_;\\n    }\\n\\n    /// @notice Update claim deadline\\n    function setClaimDeadline(uint256 newClaimDeadline)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        emit UpdateClaimDeadline(claimDeadline, newClaimDeadline);\\n\\n        // set claim deadline\\n        claimDeadline = newClaimDeadline;\\n    }\\n\\n    /// @notice Pause claiming\\n    function pause() external override onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpause claiming\\n    function unpause() external override onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Cancel drop.\\n    /// @dev Pauses claiming, removes owner and withdraws\\n    function cancel(uint16 feePercentage_) external override onlyOwner {\\n        if (!paused) {\\n            _pause();\\n        }\\n\\n        _renounceOwnership();\\n\\n        _withdraw(feePercentage_);\\n    }\\n\\n    /// @notice Number of claimed tokens\\n    function claimedTokens() external view override returns (uint256) {\\n        return currentTokenId - startTokenId;\\n    }\\n\\n    /// @notice Claim tokens\\n    function claim(\\n        address account,\\n        uint256 allocation,\\n        uint256 price,\\n        uint256 index,\\n        bytes32[] calldata merkleProof\\n    ) external payable whenNotPaused {\\n        // assert claim deadline has not passed\\n        require(block.number <= claimDeadline, \\\"claim deadline has passed\\\");\\n\\n        // assert enough funds are sent to cover the cost\\n        require(price * allocation <= msg.value, \\\"insufficient funds\\\");\\n\\n        // assert there are enough tokens left to claim allocation amount\\n        require(\\n            currentTokenId + allocation <= endTokenId + 1,\\n            \\\"insufficient tokens\\\"\\n        );\\n\\n        // assert account has not claimed already\\n        require(!isClaimed(index, account), \\\"already claimed\\\");\\n\\n        // store account claim\\n        _setClaimed(index, account);\\n\\n        // assert proof is valid\\n        require(\\n            _verifyProof(\\n                merkleProof,\\n                merkleRoot,\\n                _getNode(index, price, account, allocation)\\n            ),\\n            \\\"invalid proof\\\"\\n        );\\n\\n        // transfer tokens\\n        for (uint256 i = 0; i < allocation; i++) {\\n            IERC721(token).transferFrom(tokenOwner, account, currentTokenId++);\\n        }\\n    }\\n\\n    function isClaimed(uint256 index, address account)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return claimed[_getClaimHash(index, account)];\\n    }\\n\\n    /// @notice Withdraw funds\\n    function withdraw(uint16 feePercentage_) external override nonReentrant {\\n        _withdraw(feePercentage_);\\n    }\\n\\n    // ============ Internal Functions ============\\n    function _withdraw(uint16 feePercentage_) internal {\\n        uint256 balance = address(this).balance;\\n\\n        if (balance > 0) {\\n            // assert that the fee is valid\\n            require(\\n                IMirrorFeeConfig(feeConfig).isFeeValid(feePercentage_),\\n                \\\"invalid fee\\\"\\n            );\\n\\n            // calculate the fee on the current balance, using the fee percentage\\n            uint256 fee = _feeAmount(balance, feePercentage_);\\n\\n            // if the fee is not zero, attempt to send it to the treasury\\n            if (fee != 0) {\\n                IMirrorTreasury(ITreasuryConfig(treasuryConfig).treasury())\\n                    .contribute{value: fee}(fee);\\n            }\\n            // broadcast the withdrawal event â€“ with balance and fee\\n            emit Withdrawal(recipient, address(this).balance, fee);\\n\\n            // transfer the remaining balance to the recipient\\n            _sendEther(payable(recipient), address(this).balance);\\n        }\\n    }\\n\\n    function _feeAmount(uint256 amount, uint256 fee)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (amount * fee) / 10000;\\n    }\\n\\n    function _sendEther(address payable recipient_, uint256 amount) internal {\\n        // Ensure sufficient balance.\\n        require(address(this).balance >= amount, \\\"insufficient balance\\\");\\n        // Send the value.\\n        (bool success, ) = recipient_.call{value: amount}(\\\"\\\");\\n        require(success, \\\"recipient reverted\\\");\\n    }\\n\\n    function _setClaimed(uint256 index, address account) internal {\\n        claimed[_getClaimHash(index, account)] = true;\\n    }\\n\\n    function _getClaimHash(uint256 index, address account)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(index, account));\\n    }\\n\\n    function _getNode(\\n        uint256 index,\\n        uint256 price,\\n        address account,\\n        uint256 allocation\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(account, allocation, price, index));\\n    }\\n\\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\\n    function _verifyProof(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-drop/interface/IERC721MerkleDrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC721MerkleDrop {\\n    event UpdateClaimDeadline(\\n        uint256 oldClaimDeadline,\\n        uint256 newClaimDeadline\\n    );\\n\\n    event Withdrawal(address recipient, uint256 amount, uint256 fee);\\n\\n    function initialize(\\n        address owner_,\\n        bool paused_,\\n        bytes32 merkleRoot_,\\n        uint256 claimDeadline_,\\n        address recipient_,\\n        address token_,\\n        address tokenOwner_,\\n        uint256 startTokenId_,\\n        uint256 endTokenId_\\n    ) external;\\n\\n    function claim(\\n        address account,\\n        uint256 allocation,\\n        uint256 price,\\n        uint256 index,\\n        bytes32[] calldata merkleProof\\n    ) external payable;\\n\\n    function setClaimDeadline(uint256 claimDeadline_) external;\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function cancel(uint16 feePercentage_) external;\\n\\n    function claimedTokens() external view returns (uint256);\\n\\n    function withdraw(uint16 feePercentage_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ncontract Ownable is IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        emit OwnershipTransferred(owner, address(0));\\n\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IPausableEvents {\\n    /// @notice Emitted when the pause is triggered by `account`.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted by `account`.\\n    event Unpaused(address account);\\n}\\n\\ninterface IPausable {\\n    function paused() external returns (bool);\\n}\\n\\ncontract Pausable is IPausable, IPausableEvents {\\n    bool public override paused;\\n\\n    // Modifiers\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Initializes the contract in unpaused state.\\n    constructor(bool paused_) {\\n        paused = paused_;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Reentrancy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ncontract Reentrancy {\\n    // ============ Constants ============\\n\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    // ============ Mutable Storage ============\\n\\n    uint256 internal reentrancyStatus;\\n\\n    // ============ Modifiers ============\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancyStatus != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancyStatus = REENTRANCY_ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip2200)\\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC721/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC721 {\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Events {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Burnable is IERC721 {\\n    function burn(uint256 tokenId) external;\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC721Royalties {\\n    function getFeeRecipients(uint256 id)\\n        external\\n        view\\n        returns (address payable[] memory);\\n\\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/fee-config/MirrorFeeConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\n\\ninterface IMirrorFeeConfig {\\n    function maxFee() external returns (uint16);\\n\\n    function minFee() external returns (uint16);\\n\\n    function isFeeValid(uint16) external view returns (bool);\\n\\n    function updateMaxFee(uint16 newFee) external;\\n\\n    function updateMinFee(uint16 newFee) external;\\n}\\n\\n/**\\n * @title MirrorFeeConfig\\n * @author MirrorXYZ\\n */\\ncontract MirrorFeeConfig is IMirrorFeeConfig, Ownable {\\n    uint16 public override maxFee = 500;\\n    uint16 public override minFee = 250;\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    function updateMaxFee(uint16 newFee) external override onlyOwner {\\n        maxFee = newFee;\\n    }\\n\\n    function updateMinFee(uint16 newFee) external override onlyOwner {\\n        minFee = newFee;\\n    }\\n\\n    function isFeeValid(uint16 fee)\\n        external\\n        view\\n        returns (bool isBeweenMinAndMax)\\n    {\\n        isBeweenMinAndMax = (minFee <= fee) && (fee <= maxFee);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/interface/IMirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IMirrorTreasury {\\n    function transferFunds(address payable to, uint256 value) external;\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function contributeWithTributary(address tributary) external payable;\\n\\n    function contribute(uint256 amount) external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeConfig_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldClaimDeadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newClaimDeadline\",\"type\":\"uint256\"}],\"name\":\"UpdateClaimDeadline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"feePercentage_\",\"type\":\"uint16\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"claimDeadline_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newClaimDeadline\",\"type\":\"uint256\"}],\"name\":\"setClaimDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"feePercentage_\",\"type\":\"uint16\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC721MerkleDrop","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000b6b102ef4538ab86317573c8751bc9f446ee6e690000000000000000000000002b27d7a2b62d532e8d34fb8b35a41c75eb90a85400000000000000000000000021a93be569666527dae0fdbfbe7715299dec1202","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}