{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n    \r\n    function percentageOf(uint a, uint b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        return a * b / 100;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\nabstract contract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\ncontract RoyaltyDistributor is Context, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    \r\n    uint[4] private sharePercentage = [35,59,3,3];\r\n    address[4] private owners;\r\n    address private wETH;\r\n\r\n    mapping(address => uint) private royalties;\r\n    \r\n    event Received(address _from, uint _amount);\r\n    event Royalty(address _recipient, uint _amount);\r\n    \r\n    // Owner 1, Nadmid Sergelen, Artist (35%)\r\n    // 0x5eCeb1bcc86181dbDD0e340568cc9139574563fa\r\n    // Owner 2, NovaTerra LLC, General Contractor (59%), ERC721 Owner\r\n    // 0xf9ee21aF7d4664BD57ba9a69203108A914793CC4\r\n    // Owner 3: Cultural Heritage Fund:\r\n    // 0xa3089Ed64FbFaaF75fD50E2F6CfE588624a4c7B0\r\n    // Owner 4: Mongol NFT\r\n    // 0x25526B4db1c52Ec849d143Fee6616ACDc26368BC\r\n    \r\n    constructor () {\r\n\r\n        wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n        owners[0] = 0x5eCeb1bcc86181dbDD0e340568cc9139574563fa;\r\n        owners[1] = 0xf9ee21aF7d4664BD57ba9a69203108A914793CC4;\r\n        owners[2] = 0xa3089Ed64FbFaaF75fD50E2F6CfE588624a4c7B0;\r\n        owners[3] = 0x25526B4db1c52Ec849d143Fee6616ACDc26368BC;\r\n    }\r\n    \r\n    modifier checkBalance() {\r\n        require(hasWethBalance() || hasEthBalance(), \"Not enough balance\");\r\n        _;\r\n    }\r\n    \r\n    function hasWethBalance() private view returns(bool) {\r\n        uint balance = wEthBalance();\r\n        uint amount1 = balance.percentageOf(sharePercentage[0]);\r\n        uint amount2 = balance.percentageOf(sharePercentage[1]);\r\n        uint amount3 = balance.percentageOf(sharePercentage[2]);\r\n        uint amount4 = balance.percentageOf(sharePercentage[3]);\r\n        return amount1 > 0 && amount2 > 0 && amount3 > 0 && amount4 > 0;\r\n    }\r\n    \r\n    function hasEthBalance() private view returns(bool) {\r\n        uint balance = ethBalance();\r\n        uint amount1 = balance.percentageOf(sharePercentage[0]);\r\n        uint amount2 = balance.percentageOf(sharePercentage[1]);\r\n        uint amount3 = balance.percentageOf(sharePercentage[2]);\r\n        uint amount4 = balance.percentageOf(sharePercentage[3]);\r\n        return amount1 > 0 && amount2 > 0 && amount3 > 0 && amount4 > 0;\r\n    }\r\n    \r\n    function distirbute() public nonReentrant checkBalance {\r\n        distirbuteWEth();\r\n        distirbuteEth();\r\n    }\r\n    \r\n    function distirbuteWEth() private {\r\n        uint balance = wEthBalance();\r\n        uint amount1 = balance.percentageOf(sharePercentage[0]);\r\n        uint amount2 = balance.percentageOf(sharePercentage[1]);\r\n        uint amount3 = balance.percentageOf(sharePercentage[2]);\r\n        uint amount4 = balance.percentageOf(sharePercentage[3]);\r\n        \r\n        if(amount1 > 0 && amount2 > 0 && amount3 > 0 && amount4 > 0) {\r\n            uint totalAmount = amount1 + amount2 + amount3 + amount4;\r\n            if(totalAmount <= balance) {\r\n                withdrawWEth(owners[0], amount1);\r\n                withdrawWEth(owners[1], amount2);\r\n                withdrawWEth(owners[2], amount3);\r\n                withdrawWEth(owners[3], amount4);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function distirbuteEth() private {\r\n        uint balance = ethBalance();\r\n        uint amount1 = balance.percentageOf(sharePercentage[0]);\r\n        uint amount2 = balance.percentageOf(sharePercentage[1]);\r\n        uint amount3 = balance.percentageOf(sharePercentage[2]);\r\n        uint amount4 = balance.percentageOf(sharePercentage[3]);\r\n        \r\n        if(amount1 > 0 && amount2 > 0 && amount3 > 0 && amount4 > 0) {\r\n            uint totalAmount = amount1 + amount2 + amount3 + amount4;\r\n            if(totalAmount <= balance) {\r\n                withdrawEth(owners[0], amount1);\r\n                withdrawEth(owners[1], amount2);\r\n                withdrawEth(owners[2], amount3);\r\n                withdrawEth(owners[3], amount4);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function withdrawWEth(address _recipient, uint _amount) private {\r\n        royalties[_recipient] = royalties[_recipient].add(_amount);\r\n        IERC20(wETH).transfer(_recipient, _amount);\r\n        emit Royalty(_recipient, _amount);\r\n    }\r\n    \r\n    function withdrawEth(address _recipient, uint _amount) private {\r\n        royalties[_recipient] = royalties[_recipient].add(_amount);\r\n        (bool success, ) = payable(_recipient).call{value: _amount}(\"\");\r\n        require(success);\r\n        emit Royalty(_recipient, _amount);\r\n    }\r\n    \r\n    function allOwners() public view returns (address[4] memory) {\r\n        return owners;\r\n    }\r\n    \r\n    function ownerByIndex(uint _index) public view returns(address) {\r\n        return owners[_index];\r\n    }\r\n    \r\n    function ethBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    function wEthBalance() public view returns(uint) {\r\n        return IERC20(wETH).balanceOf(address(this));\r\n    }\r\n    \r\n    function totalPendingRoyalties() public view returns(uint) {\r\n        return ethBalance().add(wEthBalance());\r\n    }\r\n    \r\n    function pendingRoyaltyByIndex(uint _index) private view returns (uint) {\r\n        require(_index >= 0 && _index < owners.length);\r\n        if(!hasWethBalance() && !hasEthBalance()) return 0;\r\n        \r\n        uint ethRoyalty = ethBalance().percentageOf(sharePercentage[_index]);\r\n        uint wEthRoyalty = wEthBalance().percentageOf(sharePercentage[_index]);\r\n        return ethRoyalty.add(wEthRoyalty);\r\n    }\r\n    \r\n    function pendingRoyaltyByAddress(address _owner) private view returns (uint) {\r\n        for (uint i; i < owners.length; i++) {\r\n            if(_owner == owners[i]) return i;\r\n        }\r\n        return ~uint256(0);\r\n    }\r\n    \r\n    function pendingRoyalties() public view returns (uint[4] memory) {\r\n        uint[4] memory data;\r\n        for (uint i; i < owners.length; i++) {\r\n            data[i] = pendingRoyaltyByIndex(i);\r\n        }\r\n        return data;\r\n    }\r\n    \r\n    function sharedRoyaltyByAddress(address _owner) private view returns(uint) {\r\n        return royalties[_owner];\r\n    }\r\n    \r\n    function sharedRoyaltyByIndex(uint _index) private view returns(uint) {\r\n        require(_index >= 0 && _index < owners.length);\r\n        return sharedRoyaltyByAddress(ownerByIndex(_index));\r\n    }\r\n    \r\n    function sharedRoyalties() public view returns (uint[4] memory) {\r\n        uint[4] memory data;\r\n        for (uint i; i < owners.length; i++) {\r\n            data[i] = sharedRoyaltyByIndex(i);\r\n        }\r\n        return data;\r\n    }\r\n    \r\n    function totalSharedRoyalties() public view returns(uint) {\r\n        uint totalAmount;\r\n        for (uint i; i < owners.length; i++) {\r\n            totalAmount = totalAmount.add(sharedRoyaltyByIndex(i));\r\n        }\r\n        return totalAmount;\r\n    }\r\n    \r\n    receive() external payable {\r\n        emit Received(_msgSender(), msg.value);\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Royalty\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allOwners\",\"outputs\":[{\"internalType\":\"address[4]\",\"name\":\"\",\"type\":\"address[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distirbute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"ownerByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRoyalties\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sharedRoyalties\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPendingRoyalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSharedRoyalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wEthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"RoyaltyDistributor","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0da5072ce2e391fb1393978b7ac06cbfb6c13935086ae9cb419dab9ca62658cc"}]}