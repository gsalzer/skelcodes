{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/market-wrapper/KoansMarketWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n// ============ External Imports ============\\nimport {IKoansAuctionHouse} from \\\"../external/interfaces/IKoansAuctionHouse.sol\\\";\\n\\n// ============ Internal Imports ============\\nimport {IMarketWrapper} from \\\"./IMarketWrapper.sol\\\";\\n\\n/**\\n * @title KoansMarketWrapper\\n * @author Koans Founders + Anna Carroll + Nounders\\n * @notice MarketWrapper contract implementing IMarketWrapper interface\\n * according to the logic of Koans' Auction House, a fork of Nouns' Auction\\n * House\\n */\\ncontract KoansMarketWrapper is IMarketWrapper {\\n    // ============ Public Immutables ============\\n\\n    IKoansAuctionHouse public immutable market;\\n\\n    // ======== Constructor =========\\n\\n    constructor(address _koansAuctionHouse) {\\n        market = IKoansAuctionHouse(_koansAuctionHouse);\\n    }\\n\\n    // ======== External Functions =========\\n\\n    /**\\n     * @notice Determine whether there is an existing, active auction\\n     * for this token. In the Koans auction house, the current auction\\n     * id is the token id, which increments sequentially, forever. The\\n     * auction is considered active while the current block timestamp\\n     * is less than the auction's end time.\\n     * @return TRUE if the auction exists\\n     */\\n    function auctionExists(uint256 auctionId)\\n      public\\n      view\\n      returns (bool)\\n    {\\n        (uint256 currentAuctionId, , , uint256 endTime, , , ) = market.auction();\\n        return auctionId == currentAuctionId && block.timestamp < endTime;\\n    }\\n\\n    /**\\n     * @notice Determine whether the given auctionId and tokenId is active.\\n     * We ignore nftContract since it is static for all koans auctions.\\n     * @return TRUE if the auctionId and tokenId matches the active auction\\n     */\\n    function auctionIdMatchesToken(\\n        uint256 auctionId,\\n        address /* nftContract */,\\n        uint256 tokenId\\n    ) public view override returns (bool) {\\n        return auctionId == tokenId && auctionExists(auctionId);\\n    }\\n\\n    /**\\n     * @notice Calculate the minimum next bid for the active auction\\n     * @return minimum bid amount\\n     */\\n    function getMinimumBid(uint256 auctionId)\\n      external\\n      view\\n      override\\n      returns (uint256)\\n    {\\n        require(\\n            auctionExists(auctionId),\\n            \\\"KoansMarketWrapper::getMinimumBid: Auction not active\\\"\\n        );\\n\\n        (, uint256 amount, , , address payable bidder, , ) = market.auction();\\n        if (bidder == address(0)) {\\n            // if there are NO bids, the minimum bid is the reserve price\\n            return market.reservePrice();\\n        }\\n        // if there ARE bids, the minimum bid is the current bid plus the increment buffer\\n        uint8 minBidIncrementPercentage = market.minBidIncrementPercentage();\\n        return amount + ((amount * minBidIncrementPercentage) / 100);\\n    }\\n\\n    /**\\n     * @notice Query the current highest bidder for this auction\\n     * @return highest bidder\\n     */\\n    function getCurrentHighestBidder(uint256 auctionId)\\n      external\\n      view\\n      override\\n      returns (address)\\n    {\\n        require(\\n            auctionExists(auctionId),\\n            \\\"KoansMarketWrapper::getCurrentHighestBidder: Auction not active\\\"\\n        );\\n\\n        (, , , , address payable bidder, , ) = market.auction();\\n        return bidder;\\n    }\\n\\n    /**\\n     * @notice Submit bid to Market contract\\n     */\\n    function bid(uint256 auctionId, uint256 bidAmount) external override {\\n        // line 104 of Koans Auction House, createBid() function\\n        (bool success, bytes memory returnData) =\\n        address(market).call{value: bidAmount}(\\n            abi.encodeWithSignature(\\n                \\\"createBid(uint256)\\\",\\n                auctionId\\n            )\\n        );\\n        require(success, string(returnData));\\n    }\\n\\n    /**\\n     * @notice Determine whether the auction has been finalized\\n     * @return TRUE if the auction has been finalized\\n     */\\n    function isFinalized(uint256 auctionId)\\n      external\\n      view\\n      override\\n      returns (bool)\\n    {\\n        (uint256 currentAuctionId, , , , , bool settled, ) = market.auction();\\n        bool settledNormally = auctionId != currentAuctionId;\\n        bool settledWhenPaused = auctionId == currentAuctionId && settled;\\n        return settledNormally || settledWhenPaused;\\n    }\\n\\n    /**\\n     * @notice Finalize the results of the auction\\n     */\\n    function finalize(uint256 /* auctionId */) external override {\\n        if (market.paused()) {\\n            market.settleAuction();\\n        } else {\\n            market.settleCurrentAndCreateNewAuction();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IKoansAuctionHouse.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\ninterface IKoansAuctionHouse {\\n    struct Auction {\\n        // ID for the Koan (ERC721 token ID)\\n        uint256 koanId;\\n        // The current highest bid amount\\n        uint256 amount;\\n        // The time that the auction started\\n        uint256 startTime;\\n        // The time that the auction is scheduled to end\\n        uint256 endTime;\\n        // The address of the current highest bid\\n        address payable bidder;\\n        // Whether or not the auction has been settled\\n        bool settled;\\n        // The address to payout a portion of the auction's proceeds to.\\n        address payable payoutAddress;\\n    }\\n\\n    event AuctionCreated(uint256 indexed koanId, uint256 startTime, uint256 endTime);\\n\\n    event AuctionBid(uint256 indexed koanId, address sender, uint256 value, bool extended);\\n\\n    event AuctionExtended(uint256 indexed koanId, uint256 endTime);\\n\\n    event AuctionSettled(uint256 indexed koanId, address winner, uint256 amount);\\n\\n    event AuctionTimeBufferUpdated(uint256 timeBuffer);\\n\\n    event AuctionReservePriceUpdated(uint256 reservePrice);\\n\\n    event AuctionMinBidIncrementPercentageUpdated(uint256 minBidIncrementPercentage);\\n\\n    event PayoutRewardBPUpdated(uint256 artistRewardBP);\\n\\n    event AuctionDurationUpdated(uint256 duration);\\n\\n    function reservePrice() external view returns (uint256);\\n\\n    function minBidIncrementPercentage() external view returns (uint8);\\n\\n    function auction() external view returns (uint256, uint256, uint256, uint256, address payable, bool, address payable);\\n\\n    function settleCurrentAndCreateNewAuction() external;\\n\\n    function settleAuction() external;\\n\\n    function createBid(uint256 koanId) external payable;\\n\\n    function addOffer(string memory _uri, address _payoutAddress) external;\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function paused() external view returns (bool);\\n\\n    function setTimeBuffer(uint256 _timeBuffer) external;\\n\\n    function setReservePrice(uint256 _reservePrice) external;\\n\\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external;\\n\\n    function setPayoutRewardBP(uint256 _payoutRewardBP) external;\\n\\n    function setDuration(uint256 _duration) external;\\n\\n    function setOfferAddress(address _koanOfferAddress) external;\\n}\"\r\n    },\r\n    \"contracts/market-wrapper/IMarketWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n/**\\n * @title IMarketWrapper\\n * @author Anna Carroll\\n * @notice IMarketWrapper provides a common interface for\\n * interacting with NFT auction markets.\\n * Contracts can abstract their interactions with\\n * different NFT markets using IMarketWrapper.\\n * NFT markets can become compatible with any contract\\n * using IMarketWrapper by deploying a MarketWrapper contract\\n * that implements this interface using the logic of their Market.\\n *\\n * WARNING: MarketWrapper contracts should NEVER write to storage!\\n * When implementing a MarketWrapper, exercise caution; a poorly implemented\\n * MarketWrapper contract could permanently lose access to the NFT or user funds.\\n */\\ninterface IMarketWrapper {\\n    /**\\n     * @notice Given the auctionId, nftContract, and tokenId, check that:\\n     * 1. the auction ID matches the token\\n     * referred to by tokenId + nftContract\\n     * 2. the auctionId refers to an *ACTIVE* auction\\n     * (e.g. an auction that will accept bids)\\n     * within this market contract\\n     * 3. any additional validation to ensure that\\n     * a PartyBid can bid on this auction\\n     * (ex: if the market allows arbitrary bidding currencies,\\n     * check that the auction currency is ETH)\\n     * Note: This function probably should have been named \\\"isValidAuction\\\"\\n     * @dev Called in PartyBid.sol in `initialize` at line 174\\n     * @return TRUE if the auction is valid\\n     */\\n    function auctionIdMatchesToken(\\n        uint256 auctionId,\\n        address nftContract,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Calculate the minimum next bid for this auction.\\n     * PartyBid contracts always submit the minimum possible\\n     * bid that will be accepted by the Market contract.\\n     * usually, this is either the reserve price (if there are no bids)\\n     * or a certain percentage increase above the current highest bid\\n     * @dev Called in PartyBid.sol in `bid` at line 251\\n     * @return minimum bid amount\\n     */\\n    function getMinimumBid(uint256 auctionId) external view returns (uint256);\\n\\n    /**\\n     * @notice Query the current highest bidder for this auction\\n     * It is assumed that there is always 1 winning highest bidder for an auction\\n     * This is used to ensure that PartyBid cannot outbid itself if it is already winning\\n     * @dev Called in PartyBid.sol in `bid` at line 241\\n     * @return highest bidder\\n     */\\n    function getCurrentHighestBidder(uint256 auctionId)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @notice Submit bid to Market contract\\n     * @dev Called in PartyBid.sol in `bid` at line 259\\n     */\\n    function bid(uint256 auctionId, uint256 bidAmount) external;\\n\\n    /**\\n     * @notice Determine whether the auction has been finalized\\n     * Used to check if it is still possible to bid\\n     * And to determine whether the PartyBid should finalize the auction\\n     * @dev Called in PartyBid.sol in `bid` at line 247\\n     * @dev and in `finalize` at line 288\\n     * @return TRUE if the auction has been finalized\\n     */\\n    function isFinalized(uint256 auctionId) external view returns (bool);\\n\\n    /**\\n     * @notice Finalize the results of the auction\\n     * on the Market contract\\n     * It is assumed  that this operation is performed once for each auction,\\n     * that after it is done the auction is over and the NFT has been\\n     * transferred to the auction winner.\\n     * @dev Called in PartyBid.sol in `finalize` at line 289\\n     */\\n    function finalize(uint256 auctionId) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_koansAuctionHouse\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"auctionExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"auctionIdMatchesToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getCurrentHighestBidder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getMinimumBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"internalType\":\"contract IKoansAuctionHouse\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"KoansMarketWrapper","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000004a60203b6fffb98324c09208ac704f40355f5bd6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}