{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Farm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\\nimport 'hardhat-deploy/solc_0.8/proxy/Proxied.sol';\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport './libraries/FarmLookupLibrary.sol';\\nimport './libraries/VRFLibrary.sol';\\n\\nimport './interfaces/IChickenNoodle.sol';\\nimport './interfaces/IEgg.sol';\\nimport './interfaces/IFarm.sol';\\nimport './interfaces/IRandomnessConsumer.sol';\\nimport './interfaces/IRandomnessProvider.sol';\\n\\ncontract Farm is IRandomnessConsumer, Proxied, PausableUpgradeable {\\n    using VRFLibrary for VRFLibrary.VRFData;\\n\\n    // maximum tier score for a Noodle\\n    uint8 public constant MAX_TIER_SCORE = 8;\\n\\n    struct ClaimRequest {\\n        address owner;\\n        uint256 owed;\\n        bytes32 hash;\\n    }\\n\\n    event ClaimProcessed(address owner, uint256 owed, bool stolen);\\n    event TokenStaked(address owner, uint256 tokenId, uint256 value);\\n    event ChickenClaimed(\\n        uint256 tokenId,\\n        uint256 earned,\\n        uint256 stolen,\\n        bool unstaked\\n    );\\n    event NoodleClaimed(uint256 tokenId, uint256 earned, bool unstaked);\\n\\n    // reference to the ChickenNoodle NFT contract\\n    IChickenNoodle public chickenNoodle;\\n    // reference to the $EGG contract for minting $EGG earnings\\n    IEgg egg;\\n\\n    // maps tokenId to stake\\n    mapping(uint16 => IFarm.Stake) public henHouse;\\n    // maps tier score to all Noodle stakes with their tier\\n    mapping(uint8 => IFarm.Stake[]) public den;\\n    // tracks location of each Noodle in Den\\n    mapping(uint16 => uint16) public denIndices;\\n    // total tier score scores staked\\n    uint256 public totalTierScoreStaked;\\n    // any rewards distributed when no noodles are staked\\n    uint256 public unaccountedRewards;\\n    // amount of $EGG due for each tier score point staked\\n    uint256 public eggPerTierScore;\\n\\n    // Gen 0 Chickens earn 10000 $EGG per day\\n    uint256 public constant DAILY_GEN0_EGG_RATE = 10000 ether;\\n    // Gen 1 Chickens earn 6000 $EGG per day\\n    uint256 public constant DAILY_GEN1_EGG_RATE = 6000 ether;\\n    // Chicken must have 2 days worth of $EGG to unstake or else it's too cold\\n    uint256 public constant MINIMUM_TO_EXIT = 2 days;\\n    // noodles take a 20% tax on all $EGG claimed\\n    uint256 public constant EGG_CLAIM_TAX_PERCENTAGE = 20;\\n    // there will only ever be (roughly) 2.4 billion $EGG earned through staking\\n    uint256 public constant MAXIMUM_GLOBAL_EGG = 2400000000 ether;\\n\\n    // amount of $EGG earned so far\\n    uint256 public totalEggEarned;\\n    // the last time $EGG was claimed\\n    uint256 public lastClaimTimestamp;\\n    // number of Chicken staked in the HenHouse\\n    uint16 public totalChickenStaked;\\n    // number of Gen 0 Chicken staked in the HenHouse\\n    uint16 public gen0ChickensStaked;\\n\\n    // emergency rescue to allow unstaking without any checks but without $EGG\\n    bool public rescueEnabled;\\n\\n    // number of claims have been processed so far\\n    uint16 public claimsProcessed;\\n    // number of claims have been requested so far\\n    uint16 public claimsRequested;\\n\\n    VRFLibrary.VRFData private vrf;\\n\\n    mapping(uint256 => ClaimRequest) internal claims;\\n\\n    uint256 randomnessInterval;\\n    uint256 randomnessClaimsNeeded;\\n    uint256 randomnessClaimsMinimum;\\n\\n    // /**\\n    //  * @param _chickenNoodle reference to the ChickenNoodleSoup NFT contract\\n    //  * @param _egg reference to the $EGG token\\n    //  */\\n    // constructor(address _egg, address _chickenNoodle) {\\n    //     initialize(_egg, _chickenNoodle);\\n    // }\\n\\n    /**\\n     * @param _chickenNoodle reference to the ChickenNoodleSoup NFT contract\\n     * @param _egg reference to the $EGG token\\n     */\\n    function initialize(address _egg, address _chickenNoodle) public proxied {\\n        __Pausable_init();\\n\\n        egg = IEgg(_egg);\\n        chickenNoodle = IChickenNoodle(_chickenNoodle);\\n\\n        randomnessInterval = 12 hours;\\n        randomnessClaimsNeeded = 50;\\n        randomnessClaimsMinimum = 0;\\n    }\\n\\n    function processingStats()\\n        public\\n        view\\n        returns (\\n            bool requestPending,\\n            uint256 maxIdAvailableToProcess,\\n            uint256 readyForProcessing,\\n            uint256 waitingToBeProcessed,\\n            uint256 timeTellNextRandomnessRequest\\n        )\\n    {\\n        return vrf.processingStats(claimsRequested, claimsProcessed, randomnessInterval);\\n    }\\n\\n    function getTotalStaked()\\n        public\\n        view\\n        returns (\\n            uint16 chickens,\\n            uint16 noodles,\\n            uint16 tier5Noodles,\\n            uint16 tier4Noodles,\\n            uint16 tier3Noodles,\\n            uint16 tier2Noodles,\\n            uint16 tier1Noodles\\n        )\\n    {\\n        return FarmLookupLibrary.getTotalStaked(address(this), den);\\n    }\\n\\n    function getStakedBalanceOf(address tokenOwner)\\n        public\\n        view\\n        returns (\\n            uint16 chickens,\\n            uint16 noodles,\\n            uint16 tier5Noodles,\\n            uint16 tier4Noodles,\\n            uint16 tier3Noodles,\\n            uint16 tier2Noodles,\\n            uint16 tier1Noodles\\n        )\\n    {\\n        return\\n            FarmLookupLibrary.getStakedBalanceOf(\\n                address(this),\\n                tokenOwner,\\n                henHouse,\\n                den,\\n                denIndices\\n            );\\n    }\\n\\n    function getStakedChickensForOwner(\\n        address tokenOwner,\\n        uint16 limit,\\n        uint16 page\\n    )\\n        public\\n        view\\n        returns (\\n            uint16[] memory tokens,\\n            uint256[] memory timeTellUnlock,\\n            uint256[] memory earnedEgg\\n        )\\n    {\\n        return\\n            FarmLookupLibrary.getStakedChickensForOwner(\\n                address(this),\\n                IFarm.PagingData(tokenOwner, limit, page),\\n                henHouse,\\n                den,\\n                denIndices\\n            );\\n    }\\n\\n    function getStakedNoodlesForOwner(\\n        address tokenOwner,\\n        uint16 limit,\\n        uint16 page\\n    )\\n        public\\n        view\\n        returns (\\n            uint16[] memory tokens,\\n            uint8[] memory tier,\\n            uint256[] memory taxedEgg\\n        )\\n    {\\n        return\\n            FarmLookupLibrary.getStakedNoodlesForOwner(\\n                address(this),\\n                IFarm.PagingData(tokenOwner, limit, page),\\n                henHouse,\\n                den,\\n                denIndices\\n            );\\n    }\\n\\n    /** STAKING */\\n\\n    /**\\n     * adds Chicken and Noodles to the HenHouse and Den\\n     * @param tokenIds the IDs of the Chicken and Noodles to stake\\n     */\\n    function addManyToHenHouseAndDen(uint16[] calldata tokenIds) external {\\n        require(tx.origin == _msgSender(), 'Only EOA');\\n\\n        for (uint16 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                chickenNoodle.ownerOf(tokenIds[i]) == _msgSender(),\\n                'Can only stake your own tokens'\\n            );\\n\\n            chickenNoodle.transferFrom(\\n                _msgSender(),\\n                address(this),\\n                tokenIds[i]\\n            );\\n\\n            if (isChicken(tokenIds[i])) {\\n                _addChickenToHenHouse(tokenIds[i]);\\n            } else {\\n                _addNoodleToDen(tokenIds[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * adds a single Chicken to the HenHouse\\n     * @param tokenId the ID of the Chicken to add to the HenHouse\\n     */\\n    function _addChickenToHenHouse(uint16 tokenId)\\n        internal\\n        whenNotPaused\\n        _updateEarnings\\n    {\\n        henHouse[tokenId] = IFarm.Stake({\\n            owner: _msgSender(),\\n            tokenId: tokenId,\\n            value: uint80(block.timestamp)\\n        });\\n        if (tokenId <= chickenNoodle.PAID_TOKENS()) {\\n            gen0ChickensStaked++;\\n        }\\n        totalChickenStaked++;\\n        emit TokenStaked(_msgSender(), tokenId, block.timestamp);\\n    }\\n\\n    /**\\n     * adds a single Noodle to the Den\\n     * @param tokenId the ID of the Noodle to add to the Den\\n     */\\n    function _addNoodleToDen(uint16 tokenId) internal {\\n        uint8 tierScore = tierScoreForNoodle(tokenId);\\n        totalTierScoreStaked += tierScore; // Portion of earnings ranges from 8 to 4\\n        denIndices[tokenId] = uint16(den[tierScore].length); // Store the location of the noodle in the Den\\n        den[tierScore].push(\\n            IFarm.Stake({\\n                owner: _msgSender(),\\n                tokenId: tokenId,\\n                value: uint80(eggPerTierScore)\\n            })\\n        ); // Add the noodle to the Den\\n        emit TokenStaked(_msgSender(), tokenId, eggPerTierScore);\\n    }\\n\\n    /** CLAIMING / UNSTAKING */\\n\\n    /**\\n     * realize $EGG earnings and optionally unstake tokens from the HenHouse / Den\\n     * to unstake a Chicken it will require it has 2 days worth of $EGG unclaimed\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\n     * @param unstake whether or not to unstake ALL of the tokens listed in tokenIds\\n     */\\n    function claimManyFromHenHouseAndDen(\\n        uint16[] calldata tokenIds,\\n        bool unstake\\n    ) external whenNotPaused _updateEarnings {\\n        require(tx.origin == _msgSender(), 'Only EOA');\\n\\n        uint256 owed = 0;\\n        for (uint16 i = 0; i < tokenIds.length; i++) {\\n            require(\\n                chickenNoodle.ownerOf(tokenIds[i]) == address(this),\\n                'Can only claim tokens that are staked'\\n            );\\n\\n            if (isChicken(tokenIds[i])) {\\n                owed += _claimChickenFromHenHouse(tokenIds[i], unstake);\\n            } else {\\n                owed += _claimNoodleFromDen(tokenIds[i], unstake);\\n            }\\n        }\\n        if (owed == 0) return;\\n        egg.mint(_msgSender(), owed);\\n    }\\n\\n    /**\\n     * realize $EGG earnings for a single Chicken and optionally unstake it\\n     * if not unstaking, pay a 20% tax to the staked Noodles\\n     * if unstaking, there is a 50% chance all $EGG is stolen\\n     * @param tokenId the ID of the Chicken to claim earnings from\\n     * @param unstake whether or not to unstake the Chicken\\n     * @return owed - the amount of $EGG earned\\n     */\\n    function _claimChickenFromHenHouse(uint16 tokenId, bool unstake)\\n        internal\\n        returns (uint256 owed)\\n    {\\n        IFarm.Stake memory stake = henHouse[tokenId];\\n        require(\\n            stake.owner == _msgSender(),\\n            'Can only claim tokens you staked'\\n        );\\n        require(\\n            !(unstake && block.timestamp - stake.value < MINIMUM_TO_EXIT),\\n            'Can only unstake if you have waited the minimum exit time'\\n        );\\n        if (totalEggEarned < MAXIMUM_GLOBAL_EGG) {\\n            owed =\\n                ((block.timestamp - stake.value) *\\n                    (\\n                        tokenId <= chickenNoodle.PAID_TOKENS()\\n                            ? DAILY_GEN0_EGG_RATE\\n                            : DAILY_GEN1_EGG_RATE\\n                    )) /\\n                1 days;\\n        } else if (stake.value > lastClaimTimestamp) {\\n            owed = 0; // $EGG production stopped already\\n        } else {\\n            owed =\\n                ((lastClaimTimestamp - stake.value) *\\n                    (\\n                        tokenId <= chickenNoodle.PAID_TOKENS()\\n                            ? DAILY_GEN0_EGG_RATE\\n                            : DAILY_GEN1_EGG_RATE\\n                    )) /\\n                1 days; // stop earning additional $EGG if it's all been earned\\n        }\\n\\n        uint256 stolen;\\n\\n        if (unstake) {\\n            claimsRequested++;\\n            claims[claimsRequested] = ClaimRequest({\\n                owner: _msgSender(),\\n                owed: owed,\\n                hash: blockhash(block.number - 1)\\n            });\\n\\n            owed = 0;\\n            delete henHouse[tokenId];\\n            if (tokenId <= chickenNoodle.PAID_TOKENS()) {\\n                gen0ChickensStaked--;\\n            }\\n            totalChickenStaked--;\\n\\n            chickenNoodle.transferFrom(address(this), _msgSender(), tokenId); // send back Chicken\\n        } else {\\n            stolen = (owed * EGG_CLAIM_TAX_PERCENTAGE) / 100;\\n            _payNoodleTax(stolen); // percentage tax to staked noodles\\n            owed = owed - stolen; // remainder goes to Chicken owner\\n            henHouse[tokenId] = IFarm.Stake({\\n                owner: _msgSender(),\\n                tokenId: tokenId,\\n                value: uint80(block.timestamp)\\n            }); // reset stake\\n        }\\n        emit ChickenClaimed(tokenId, owed, stolen, unstake);\\n\\n        checkRandomness(false);\\n    }\\n\\n    function checkRandomness(bool force) public {\\n        force = force && _msgSender() == _proxyAdmin();\\n\\n        if (force) {\\n            vrf.newRequest();\\n        } else {\\n            vrf.checkRandomness(\\n                claimsRequested, \\n                claimsProcessed,\\n                randomnessInterval,\\n                randomnessClaimsNeeded,\\n                randomnessClaimsMinimum);\\n        }\\n\\n        _processNext();\\n    }\\n\\n    function process(uint256 amount) external override {\\n        for (uint256 i = 0; i < amount; i++) {\\n            if (!_processNext()) break;\\n        }\\n    }\\n\\n    function setRandomnessResult(bytes32 requestId, uint256 randomness)\\n        external\\n        override\\n    {\\n        vrf.setRequestResults(requestId, randomness, claimsRequested);\\n    }\\n\\n    function processNext() external override returns (bool) {\\n        return _processNext();\\n    }\\n\\n    function _processNext() internal returns (bool) {\\n        uint256 claimId = claimsProcessed + 1;\\n\\n        (bool available, uint256 randomness) = vrf.randomnessForId(claimId);\\n\\n        if (available) {\\n            uint256 seed = random(claimId, randomness);\\n\\n            if (seed & 1 == 1) {\\n                // 50% chance of all $EGG stolen\\n                _payNoodleTax(claims[claimId].owed);\\n                emit ClaimProcessed(\\n                    claims[claimId].owner,\\n                    claims[claimId].owed,\\n                    true\\n                );\\n            } else {\\n                egg.mint(claims[claimId].owner, claims[claimId].owed);\\n                emit ClaimProcessed(\\n                    claims[claimId].owner,\\n                    claims[claimId].owed,\\n                    false\\n                );\\n            }\\n\\n            delete claims[claimId];\\n            claimsProcessed++;\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * realize $EGG earnings for a single Noodle and optionally unstake it\\n     * Noodles earn $EGG proportional to their Tier score\\n     * @param tokenId the ID of the Noodle to claim earnings from\\n     * @param unstake whether or not to unstake the Noodle\\n     * @return owed - the amount of $EGG earned\\n     */\\n    function _claimNoodleFromDen(uint16 tokenId, bool unstake)\\n        internal\\n        returns (uint256 owed)\\n    {\\n        uint8 tierScore = tierScoreForNoodle(tokenId);\\n        IFarm.Stake memory stake = den[tierScore][denIndices[tokenId]];\\n\\n        require(\\n            stake.owner == _msgSender(),\\n            'Can only claim tokens you staked'\\n        );\\n\\n        owed = (tierScore) * (eggPerTierScore - stake.value); // Calculate portion of tokens based on Tier score\\n        if (unstake) {\\n            totalTierScoreStaked -= tierScore; // Remove Tier score from total staked\\n            IFarm.Stake memory lastStake = den[tierScore][\\n                den[tierScore].length - 1\\n            ];\\n            den[tierScore][denIndices[tokenId]] = lastStake; // Shuffle last Noodle to current position\\n            denIndices[lastStake.tokenId] = denIndices[tokenId];\\n            den[tierScore].pop(); // Remove duplicate\\n            delete denIndices[tokenId]; // Delete old mapping\\n\\n            chickenNoodle.transferFrom(address(this), _msgSender(), tokenId); // Send back Noodle\\n        } else {\\n            den[tierScore][denIndices[tokenId]] = IFarm.Stake({\\n                owner: _msgSender(),\\n                tokenId: tokenId,\\n                value: uint80(eggPerTierScore)\\n            }); // reset stake\\n        }\\n        emit NoodleClaimed(tokenId, owed, unstake);\\n    }\\n\\n    /**\\n     * emergency unstake tokens\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\n     */\\n    function rescue(uint16[] calldata tokenIds) external {\\n        require(rescueEnabled, 'Rescue is currently disabled');\\n\\n        uint16 tokenId;\\n        IFarm.Stake memory stake;\\n        IFarm.Stake memory lastStake;\\n        uint8 tierScore;\\n\\n        for (uint16 i = 0; i < tokenIds.length; i++) {\\n            tokenId = tokenIds[i];\\n            if (isChicken(tokenId)) {\\n                stake = henHouse[tokenId];\\n\\n                require(\\n                    stake.owner == _msgSender(),\\n                    'Can only claim tokens you staked'\\n                );\\n\\n                delete henHouse[tokenId];\\n                if (tokenId <= chickenNoodle.PAID_TOKENS()) {\\n                    gen0ChickensStaked--;\\n                }\\n                totalChickenStaked--;\\n\\n                chickenNoodle.transferFrom(\\n                    address(this),\\n                    _msgSender(),\\n                    tokenId\\n                ); // send back Chicken\\n\\n                emit ChickenClaimed(tokenId, 0, 0, true);\\n            } else {\\n                tierScore = tierScoreForNoodle(tokenId);\\n                stake = den[tierScore][denIndices[tokenId]];\\n\\n                require(\\n                    stake.owner == _msgSender(),\\n                    'Can only claim tokens you staked'\\n                );\\n\\n                totalTierScoreStaked -= tierScore; // Remove Tier score from total staked\\n                lastStake = den[tierScore][den[tierScore].length - 1];\\n                den[tierScore][denIndices[tokenId]] = lastStake; // Shuffle last Noodle to current position\\n                denIndices[lastStake.tokenId] = denIndices[tokenId];\\n                den[tierScore].pop(); // Remove duplicate\\n                delete denIndices[tokenId]; // Delete old mapping\\n\\n                chickenNoodle.transferFrom(\\n                    address(this),\\n                    _msgSender(),\\n                    tokenId\\n                ); // Send back Noodle\\n\\n                emit NoodleClaimed(tokenId, 0, true);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * allows owner to rescue tokens\\n     */\\n    function rescueTokens(IERC20 token, uint256 amount)\\n        external\\n        onlyProxyAdmin\\n    {\\n        token.transfer(_proxyAdmin(), amount);\\n    }\\n\\n    /** ACCOUNTING */\\n\\n    /**\\n     * add $EGG to claimable pot for the den\\n     * @param amount $EGG to add to the pot\\n     */\\n    function _payNoodleTax(uint256 amount) internal {\\n        if (totalTierScoreStaked == 0) {\\n            // if there's no staked noodles\\n            unaccountedRewards += amount; // keep track of $EGG due to noodles\\n            return;\\n        }\\n        // makes sure to include any unaccounted $EGG\\n        eggPerTierScore += (amount + unaccountedRewards) / totalTierScoreStaked;\\n        unaccountedRewards = 0;\\n    }\\n\\n    /**\\n     * tracks $EGG earnings to ensure it stops once 2.4 billion is eclipsed\\n     */\\n    modifier _updateEarnings() {\\n        if (totalEggEarned < MAXIMUM_GLOBAL_EGG) {\\n            totalEggEarned +=\\n                ((block.timestamp - lastClaimTimestamp) *\\n                    gen0ChickensStaked *\\n                    DAILY_GEN0_EGG_RATE) /\\n                1 days;\\n            totalEggEarned +=\\n                ((block.timestamp - lastClaimTimestamp) *\\n                    (gen0ChickensStaked - gen0ChickensStaked) *\\n                    DAILY_GEN1_EGG_RATE) /\\n                1 days;\\n            lastClaimTimestamp = block.timestamp;\\n        }\\n        _;\\n    }\\n\\n    /** ADMIN */\\n\\n    /**\\n     * called after deployment so that the contract can get random values\\n     * @param _randomnessProvider the address of the new RandomnessProvider\\n     */\\n    function setRandomnessProvider(address _randomnessProvider)\\n        external\\n        override\\n        onlyProxyAdmin\\n    {\\n        vrf.setRandomnessProvider(_randomnessProvider);\\n    }\\n\\n    /**\\n     * called to upoate fee to get randomness\\n     * @param _fee the fee required for getting randomness\\n     */\\n    function updateRandomnessFee(uint256 _fee)\\n        external\\n        override\\n        onlyProxyAdmin\\n    {\\n        vrf.updateFee(_fee);\\n    }\\n\\n    /**\\n     * allows owner to rescue LINK tokens\\n     */\\n    function rescueLINK(uint256 amount) external override onlyProxyAdmin {\\n        vrf.rescueLINK(_proxyAdmin(), amount);\\n    }\\n\\n    /**\\n     * allows owner to enable \\\"rescue mode\\\"\\n     * simplifies accounting, prioritizes tokens out in emergency\\n     */\\n    function setRescueEnabled(bool _enabled) external onlyProxyAdmin {\\n        rescueEnabled = _enabled;\\n    }\\n\\n    /**\\n     * enables owner to pause / unpause minting\\n     */\\n    function setPaused(bool _paused) external onlyProxyAdmin {\\n        if (_paused) _pause();\\n        else _unpause();\\n    }\\n\\n    /** READ ONLY */\\n\\n    /**\\n     * checks if a token is a Chicken\\n     * @param tokenId the ID of the token to check\\n     * @return chicken - whether or not a token is a Chicken\\n     */\\n    function isChicken(uint16 tokenId) public view returns (bool) {\\n        return chickenNoodle.tokenTraits(tokenId).isChicken;\\n    }\\n\\n    /**\\n     * gets the tier score for a Noodle\\n     * @param tokenId the ID of the Noodle to get the tier score for\\n     * @return the tier score of the Noodle (5-8)\\n     */\\n    function tierScoreForNoodle(uint16 tokenId) public view returns (uint8) {\\n        return chickenNoodle.tokenTraits(tokenId).tier + 3; // tier is 5-1\\n    }\\n\\n    /**\\n     * chooses a random Noodle thief when a newly minted token is stolen\\n     * @param seed a random value to choose a Noodle from\\n     * @return the owner of the randomly selected Noodle thief\\n     */\\n    function randomNoodleOwner(uint256 seed) external view returns (address) {\\n        if (totalTierScoreStaked == 0) return address(0x0);\\n        uint256 bucket = (seed & 0xFFFFFFFF) % totalTierScoreStaked; // choose a value from 0 to total tier score staked\\n        uint256 cumulative;\\n        seed >>= 32;\\n        // loop through each bucket of Noodles with the same tier score\\n        for (uint8 i = MAX_TIER_SCORE - 4; i <= MAX_TIER_SCORE; i++) {\\n            cumulative += den[i].length * i;\\n            // if the value is not inside of that bucket, keep going\\n            if (bucket >= cumulative) continue;\\n            // get the address of a random Noodle with that tier score\\n            return den[i][seed % den[i].length].owner;\\n        }\\n        return address(0x0);\\n    }\\n\\n    /**\\n     * generates a pseudorandom number\\n     * @param claimId a value ensure different outcomes for different sources in the same block\\n     * @param seed a value ensure different outcomes for different sources in the same block\\n     * @return a pseudorandom value\\n     */\\n    function random(uint256 claimId, uint256 seed)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            uint256(\\n                keccak256(abi.encodePacked(claimId, claims[claimId].hash, seed))\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FarmLookupLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IFarm.sol';\\n\\nlibrary FarmLookupLibrary {\\n    struct Counters {\\n        uint256 skipCounter;\\n        uint256 counter;\\n    }\\n\\n    function getTotalStaked(\\n        address farmAddress,\\n        mapping(uint8 => IFarm.Stake[]) storage den\\n    )\\n        public\\n        view\\n        returns (\\n            uint16 chickens,\\n            uint16 noodles,\\n            uint16 tier5Noodles,\\n            uint16 tier4Noodles,\\n            uint16 tier3Noodles,\\n            uint16 tier2Noodles,\\n            uint16 tier1Noodles\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        chickens = farm.totalChickenStaked();\\n\\n        tier5Noodles = uint16(den[farm.MAX_TIER_SCORE()].length);\\n        tier4Noodles = uint16(den[farm.MAX_TIER_SCORE() - 1].length);\\n        tier3Noodles = uint16(den[farm.MAX_TIER_SCORE() - 2].length);\\n        tier2Noodles = uint16(den[farm.MAX_TIER_SCORE() - 3].length);\\n        tier1Noodles = uint16(den[farm.MAX_TIER_SCORE() - 4].length);\\n\\n        noodles =\\n            tier5Noodles +\\n            tier4Noodles +\\n            tier3Noodles +\\n            tier2Noodles +\\n            tier1Noodles;\\n    }\\n\\n    function getStakedBalanceOf(\\n        address farmAddress,\\n        address tokenOwner,\\n        mapping(uint16 => IFarm.Stake) storage henHouse,\\n        mapping(uint8 => IFarm.Stake[]) storage den,\\n        mapping(uint16 => uint16) storage denIndices\\n    )\\n        public\\n        view\\n        returns (\\n            uint16 chickens,\\n            uint16 noodles,\\n            uint16 tier5Noodles,\\n            uint16 tier4Noodles,\\n            uint16 tier3Noodles,\\n            uint16 tier2Noodles,\\n            uint16 tier1Noodles\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\\n\\n        for (uint16 tokenId = 1; tokenId <= supply; tokenId++) {\\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\\n                continue;\\n            }\\n\\n            if (farm.isChicken(tokenId)) {\\n                if (henHouse[tokenId].owner == tokenOwner) {\\n                    chickens++;\\n                }\\n            } else {\\n                uint8 tierScore = farm.tierScoreForNoodle(tokenId);\\n\\n                if (den[tierScore][denIndices[tokenId]].owner == tokenOwner) {\\n                    if (tierScore == 8) {\\n                        tier5Noodles++;\\n                    } else if (tierScore == 7) {\\n                        tier4Noodles++;\\n                    } else if (tierScore == 6) {\\n                        tier3Noodles++;\\n                    } else if (tierScore == 5) {\\n                        tier2Noodles++;\\n                    } else if (tierScore == 4) {\\n                        tier1Noodles++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        noodles =\\n            tier5Noodles +\\n            tier4Noodles +\\n            tier3Noodles +\\n            tier2Noodles +\\n            tier1Noodles;\\n    }\\n\\n    function getStakedChickensForOwner(\\n        address farmAddress,\\n        IFarm.PagingData memory data,\\n        mapping(uint16 => IFarm.Stake) storage henHouse,\\n        mapping(uint8 => IFarm.Stake[]) storage den,\\n        mapping(uint16 => uint16) storage denIndices\\n    )\\n        public\\n        view\\n        returns (\\n            uint16[] memory tokens,\\n            uint256[] memory timeTellUnlock,\\n            uint256[] memory earnedEgg\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        (uint16 tokensOwned, , , , , , ) = getStakedBalanceOf(\\n            farmAddress,\\n            data.tokenOwner,\\n            henHouse,\\n            den,\\n            denIndices\\n        );\\n\\n        (uint256 tokensSize, uint256 pageStart) = _paging(\\n            tokensOwned,\\n            data.limit,\\n            data.page\\n        );\\n\\n        tokens = new uint16[](tokensSize);\\n        timeTellUnlock = new uint256[](tokensSize);\\n        earnedEgg = new uint256[](tokensSize);\\n\\n        Counters memory counters;\\n\\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counters.counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\\n                continue;\\n            }\\n\\n            if (\\n                farm.isChicken(tokenId) &&\\n                henHouse[tokenId].owner == data.tokenOwner\\n            ) {\\n                IFarm.Stake memory stake = henHouse[tokenId];\\n\\n                if (counters.skipCounter < pageStart) {\\n                    counters.skipCounter++;\\n                    continue;\\n                }\\n\\n                tokens[counters.counter] = tokenId;\\n                timeTellUnlock[counters.counter] = block.timestamp -\\n                    stake.value <\\n                    farm.MINIMUM_TO_EXIT()\\n                    ? farm.MINIMUM_TO_EXIT() - (block.timestamp - stake.value)\\n                    : 0;\\n\\n                if (farm.totalEggEarned() < farm.MAXIMUM_GLOBAL_EGG()) {\\n                    earnedEgg[counters.counter] =\\n                        ((block.timestamp - stake.value) *\\n                            (\\n                                tokenId <= farm.chickenNoodle().PAID_TOKENS()\\n                                    ? farm.DAILY_GEN0_EGG_RATE()\\n                                    : farm.DAILY_GEN1_EGG_RATE()\\n                            )) /\\n                        1 days;\\n                } else if (stake.value > farm.lastClaimTimestamp()) {\\n                    earnedEgg[counters.counter] = 0; // $EGG production stopped already\\n                } else {\\n                    earnedEgg[counters.counter] =\\n                        ((farm.lastClaimTimestamp() - stake.value) *\\n                            (\\n                                tokenId <= farm.chickenNoodle().PAID_TOKENS()\\n                                    ? farm.DAILY_GEN0_EGG_RATE()\\n                                    : farm.DAILY_GEN1_EGG_RATE()\\n                            )) /\\n                        1 days; // stop earning additional $EGG if it's all been earned\\n                }\\n\\n                counters.counter++;\\n            }\\n        }\\n    }\\n\\n    function getStakedNoodlesForOwner(\\n        address farmAddress,\\n        IFarm.PagingData memory data,\\n        mapping(uint16 => IFarm.Stake) storage henHouse,\\n        mapping(uint8 => IFarm.Stake[]) storage den,\\n        mapping(uint16 => uint16) storage denIndices\\n    )\\n        public\\n        view\\n        returns (\\n            uint16[] memory tokens,\\n            uint8[] memory tier,\\n            uint256[] memory taxedEgg\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        (, uint16 tokensOwned, , , , , ) = getStakedBalanceOf(\\n            farmAddress,\\n            data.tokenOwner,\\n            henHouse,\\n            den,\\n            denIndices\\n        );\\n\\n        (uint256 tokensSize, uint256 pageStart) = _paging(\\n            tokensOwned,\\n            data.limit,\\n            data.page\\n        );\\n\\n        tokens = new uint16[](tokensSize);\\n        tier = new uint8[](tokensSize);\\n        taxedEgg = new uint256[](tokensSize);\\n\\n        Counters memory counters;\\n\\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counters.counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\\n                continue;\\n            }\\n\\n            if (!farm.isChicken(tokenId)) {\\n                uint8 tierScore = farm.tierScoreForNoodle(tokenId);\\n\\n                IFarm.Stake memory stake = den[tierScore][denIndices[tokenId]];\\n\\n                if (stake.owner == data.tokenOwner) {\\n                    if (counters.skipCounter < pageStart) {\\n                        counters.skipCounter++;\\n                        continue;\\n                    }\\n\\n                    tokens[counters.counter] = tokenId;\\n                    tier[counters.counter] = tierScore - 3;\\n                    taxedEgg[counters.counter] =\\n                        (tierScore) *\\n                        (farm.eggPerTierScore() - stake.value);\\n                    counters.counter++;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _paging(\\n        uint16 tokensOwned,\\n        uint16 limit,\\n        uint16 page\\n    ) private pure returns (uint256 tokensSize, uint256 pageStart) {\\n        pageStart = limit * page;\\n        uint256 pageEnd = limit * (page + 1);\\n        tokensSize = tokensOwned >= pageEnd\\n            ? limit\\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/VRFLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IRandomnessProvider.sol';\\n\\nlibrary VRFLibrary {\\n    struct VRFData {\\n        IRandomnessProvider randomnessProvider;\\n        bytes32 lastRequestId;\\n        mapping(uint256 => uint256) highestIdForRandomness;\\n        mapping(uint256 => uint256) randomResults;\\n        uint256 lastRequest;\\n        uint256 minResultIndex;\\n        uint256 resultsReceived;\\n    }\\n\\n    modifier onlyRandomnessProvider(VRFData storage self) {\\n        require(\\n            msg.sender == address(self.randomnessProvider),\\n            'Required to be randomnessProvider'\\n        );\\n        _;\\n    }\\n\\n    function processingStats(\\n        VRFData storage self,\\n        uint256 maxId,\\n        uint256 processedId,\\n        uint256 interval\\n    )\\n        public\\n        view\\n        returns (\\n            bool requestPending,\\n            uint256 maxIdAvailableToProcess,\\n            uint256 readyForProcessing,\\n            uint256 waitingToBeProcessed,\\n            uint256 timeTellNextRandomnessRequest\\n        )\\n    {\\n        timeTellNextRandomnessRequest = self.lastRequest + interval < block.timestamp\\n                ? 0\\n                : (self.lastRequest + interval) - block.timestamp;\\n\\n        return (\\n            self.lastRequestId != '' && timeTellNextRandomnessRequest > interval / 2,\\n            self.highestIdForRandomness[self.resultsReceived],\\n            self.highestIdForRandomness[self.resultsReceived] - processedId,\\n            maxId - self.highestIdForRandomness[self.resultsReceived],\\n            timeTellNextRandomnessRequest\\n        );\\n    }\\n\\n    function checkRandomness(\\n        VRFData storage self,\\n        uint256 maxId,\\n        uint256 processedId,\\n        uint256 interval,\\n        uint256 needed,\\n        uint256 minimum\\n    ) external {\\n        (\\n            bool requested,\\n            ,\\n            ,\\n            uint256 processingNeeded,\\n            uint256 timeTellNext\\n        ) = processingStats(self, maxId, processedId, interval);\\n\\n        if (\\n            !requested &&\\n            (processingNeeded >= needed ||\\n                (timeTellNext == 0 && processingNeeded > minimum))\\n        ) {\\n            newRequest(self);\\n        }\\n    }\\n\\n    function newRequest(VRFData storage self) public {\\n        bytes32 requestId = self.randomnessProvider.newRandomnessRequest();\\n\\n        if (requestId != '') {\\n            self.lastRequest = block.timestamp;\\n            self.lastRequestId = requestId;\\n        }\\n    }\\n\\n    function setRequestResults(\\n        VRFData storage self,\\n        bytes32 requestId,\\n        uint256 randomness,\\n        uint256 maxId\\n    ) public onlyRandomnessProvider(self) {\\n        if (self.lastRequestId == requestId) {\\n            self.resultsReceived++;\\n            self.randomResults[self.resultsReceived] = randomness;\\n            self.highestIdForRandomness[self.resultsReceived] = maxId;\\n            self.lastRequestId = '';\\n        }\\n    }\\n\\n    function randomnessForId(VRFData storage self, uint256 id)\\n        public\\n        returns (bool available, uint256 randomness)\\n    {\\n        while (\\n            self.highestIdForRandomness[self.minResultIndex] < id &&\\n            self.minResultIndex < self.resultsReceived\\n        ) {\\n            delete self.randomResults[self.minResultIndex];\\n            delete self.highestIdForRandomness[self.minResultIndex];\\n            self.minResultIndex++;\\n        }\\n\\n        if (self.highestIdForRandomness[self.minResultIndex] >= id) {\\n            return (true, self.randomResults[self.minResultIndex]);\\n        }\\n\\n        return (false, 0);\\n    }\\n\\n    function setRandomnessProvider(\\n        VRFData storage self,\\n        address randomnessProvider\\n    ) public {\\n        self.randomnessProvider = IRandomnessProvider(randomnessProvider);\\n    }\\n\\n    function updateFee(VRFData storage self, uint256 fee) public {\\n        self.randomnessProvider.updateFee(fee);\\n    }\\n\\n    function rescueLINK(\\n        VRFData storage self,\\n        address to,\\n        uint256 amount\\n    ) public {\\n        self.randomnessProvider.rescueLINK(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChickenNoodle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IChickenNoodle {\\n    // struct to store each token's traits\\n    struct ChickenNoodleTraits {\\n        bool minted;\\n        bool isChicken;\\n        uint8 backgrounds;\\n        uint8 snakeBodies;\\n        uint8 mouthAccessories;\\n        uint8 pupils;\\n        uint8 bodyAccessories;\\n        uint8 hats;\\n        uint8 tier;\\n    }\\n\\n    function MAX_TOKENS() external view returns (uint256);\\n\\n    function PAID_TOKENS() external view returns (uint256);\\n\\n    function tokenTraits(uint256 tokenId)\\n        external\\n        view\\n        returns (ChickenNoodleTraits memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function mint(address to, uint16 tokenId) external;\\n\\n    function finalize(\\n        uint16 tokenId,\\n        ChickenNoodleTraits memory traits,\\n        address thief\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEgg.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IEgg {\\n    /**\\n     * mints $EGG to a recipient\\n     * @param to the recipient of the $EGG\\n     * @param amount the amount of $EGG to mint\\n     */\\n    function mint(address to, uint256 amount) external;\\n\\n    /**\\n     * burns $EGG from a holder\\n     * @param from the holder of the $EGG\\n     * @param amount the amount of $EGG to burn\\n     */\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './IChickenNoodle.sol';\\n\\ninterface IFarm {\\n    struct Stake {\\n        uint16 tokenId;\\n        uint80 value;\\n        address owner;\\n    }\\n\\n    struct PagingData {\\n        address tokenOwner;\\n        uint16 limit;\\n        uint16 page;\\n    }\\n\\n    function totalChickenStaked() external view returns (uint16);\\n\\n    function MINIMUM_TO_EXIT() external view returns (uint256);\\n\\n    function MAX_TIER_SCORE() external view returns (uint8);\\n\\n    function MAXIMUM_GLOBAL_EGG() external view returns (uint256);\\n\\n    function DAILY_GEN0_EGG_RATE() external view returns (uint256);\\n\\n    function DAILY_GEN1_EGG_RATE() external view returns (uint256);\\n\\n    function eggPerTierScore() external view returns (uint256);\\n\\n    function totalEggEarned() external view returns (uint256);\\n\\n    function lastClaimTimestamp() external view returns (uint256);\\n\\n    function denIndices(uint16 tokenId) external view returns (uint16);\\n\\n    function chickenNoodle() external view returns (IChickenNoodle);\\n\\n    function isChicken(uint16 tokenId) external view returns (bool);\\n\\n    function tierScoreForNoodle(uint16 tokenId) external view returns (uint8);\\n\\n    function randomNoodleOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomnessConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRandomnessConsumer {\\n    function setRandomnessResult(bytes32 requestId, uint256 randomness)\\n        external;\\n\\n    function process(uint256 amount) external;\\n\\n    function processNext() external returns (bool);\\n\\n    function setRandomnessProvider(address _randomnessProvider) external;\\n\\n    function updateRandomnessFee(uint256 _fee) external;\\n\\n    function rescueLINK(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomnessProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRandomnessProvider {\\n    function newRandomnessRequest() external returns (bytes32);\\n\\n    function updateFee(uint256) external;\\n\\n    function rescueLINK(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/FarmLookupLibrary.sol\": {\r\n        \"FarmLookupLibrary\": \"0x200489739228f5b79059428e61caeeaa3127f374\"\r\n      },\r\n      \"contracts/libraries/VRFLibrary.sol\": {\r\n        \"VRFLibrary\": \"0xe4915cafa1e7e53786719e51fc42c9c12f722f76\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stolen\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"name\":\"ChickenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"stolen\",\"type\":\"bool\"}],\"name\":\"ClaimProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"name\":\"NoodleClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAILY_GEN0_EGG_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAILY_GEN1_EGG_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EGG_CLAIM_TAX_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_GLOBAL_EGG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TIER_SCORE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_TO_EXIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"addManyToHenHouseAndDen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"checkRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chickenNoodle\",\"outputs\":[{\"internalType\":\"contract IChickenNoodle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"claimManyFromHenHouseAndDen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimsProcessed\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimsRequested\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"den\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"value\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"denIndices\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eggPerTierScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gen0ChickensStaked\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"getStakedBalanceOf\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"chickens\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier5Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier4Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier3Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier2Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier1Noodles\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"limit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"page\",\"type\":\"uint16\"}],\"name\":\"getStakedChickensForOwner\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokens\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"timeTellUnlock\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"earnedEgg\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"limit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"page\",\"type\":\"uint16\"}],\"name\":\"getStakedNoodlesForOwner\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokens\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"tier\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"taxedEgg\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaked\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"chickens\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier5Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier4Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier3Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier2Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier1Noodles\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"henHouse\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"value\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_egg\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chickenNoodle\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"isChicken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastClaimTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processNext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingStats\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"requestPending\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxIdAvailableToProcess\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"readyForProcessing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"waitingToBeProcessed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeTellNextRandomnessRequest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"randomNoodleOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLINK\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_randomnessProvider\",\"type\":\"address\"}],\"name\":\"setRandomnessProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"setRandomnessResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setRescueEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"tierScoreForNoodle\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalChickenStaked\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEggEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTierScoreStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unaccountedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"updateRandomnessFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Farm","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}