{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL 3.0\r\n\r\npragma solidity >= 0.8.4;\r\n\r\ninterface IErc20 {\r\n    function approve(address, uint256) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\ninterface ICErc20 {\r\n    function mint(uint256) external returns (uint256);\r\n    function redeemUnderlying(uint) external returns (uint);\r\n    function balanceOfUnderlying(address account) external returns (uint);\r\n}\r\n\r\ninterface IComptroller {\r\n    function claimComp(address holder) external;\r\n}\r\n\r\ninterface ILendingPoolAddressesProvider {\r\n  function getLendingPool() external view returns (address);\r\n}\r\n\r\ninterface ILendingPool {\r\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode ) external;\r\n  function withdraw(address asset, uint256 amount, address to) external;\r\n}\r\n\r\ninterface ICurvePool {\r\n    function exchange(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external;\r\n    function get_dy(int128 from, int128 to, uint256 _from_amount) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswap {\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n    \r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n}\r\n\r\ninterface IUniQuote {\r\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\r\n}\r\n\r\ninterface IAaveRewards {\r\n    function claimRewards(address[] calldata assets, uint256 amount, address to) external returns (uint256); // deleted override\r\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256); // deleted override\r\n}\r\n\r\ninterface IAaveStaked {\r\n    function redeem(address to, uint256 amount) external;\r\n    function cooldown() external;\r\n}\r\n\r\nstruct TransferTx {\r\n    uint txID;\r\n    uint32 accountNumber;\r\n    address destination;\r\n    uint256 value;\r\n}\r\n\r\nstruct OwnerTx {\r\n    uint txID;\r\n    uint16 action;\r\n    address owner;\r\n    bytes32 ownerUsername;\r\n    uint16 newThreshold;\r\n    bool exceptionEligible;\r\n}\r\n\r\n/// @title BlxmPool\r\ncontract BlxmPool {\r\n\r\n    modifier onlyManager() {\r\n        require(isManager[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner(uint32 accountNumber) {\r\n        require(owners[msg.sender] == accountNumber);\r\n        _;\r\n    }\r\n\r\n    modifier ownerOrManager(uint32 accountNumber) {\r\n        require(owners[msg.sender] == accountNumber || isManager[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address addrs) {\r\n        require(addrs != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier accountExists(uint32 accountNumber) { \r\n        require(accountThreshold[accountNumber] != 0); // a valid account threshold can't be 0\r\n        _;\r\n    }\r\n\r\n    modifier managerExists(address manager) {\r\n        require(isManager[manager]);\r\n        _;\r\n    }\r\n\r\n    modifier managerDoesNotExist(address manager) {\r\n        require(!isManager[manager]);\r\n        _;\r\n    }\r\n\r\n    modifier pendingTransferExists(uint32 accountNumber) {\r\n        require(accountPendingTransfer[accountNumber].length == 1);\r\n        _;\r\n    }\r\n\r\n    // events\r\n    event EtherDeposit(address indexed sender, uint value);\r\n    event Deposit(uint32 indexed accountNumber, address indexed sender, uint value);\r\n    event Revocation(uint32 indexed accountNumber, uint indexed transactionId, address sender);\r\n    event Transfer(uint32 indexed accountNumber, uint indexed transactionId, address destination, uint value);\r\n    event OwnerAddition(uint32 indexed accountNumber, uint indexed transactionId, address owner);\r\n    event OwnerRemoval(uint32 indexed accountNumber, uint indexed transactionId, address owner);\r\n    event RequiredSignaturesChange(uint32 indexed accountNumber, uint indexed transactionId, uint16 oldRequired, uint16 newRequired);\r\n\r\n    // contracts we use\r\n    address constant aDai = 0x028171bCA77440897B824Ca71D1c56caC55b68A3;\r\n    address constant aUsdc = 0xBcca60bB61934080951369a648Fb03DF4F96263C;\r\n    address constant cDai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n    address constant cUsdc = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\r\n    address constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n    address constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\r\n    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    address constant compoundComptroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n\r\n    address constant aaveAddressesProvider = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\r\n    address constant aaveRewardsContract = 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5;\r\n    address constant aaveStakedContract = 0x4da27a545c0c5B758a6BA100e3a049001de870f5;\r\n\r\n    address constant uniswapRouterV3 = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\r\n    address constant uniswapQuoter = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\r\n\r\n    address constant curve3Pool=0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\r\n    \r\n    // uniswap paths\r\n    uint24 constant uniswapFee = 3000;\r\n    bytes constant compPath = abi.encodePacked(comp,uniswapFee,weth,uniswapFee,usdc);\r\n    bytes constant aavePath = abi.encodePacked(aave,uniswapFee,weth,uniswapFee,usdc);\r\n    \r\n    // set in constructor\r\n    address aaveLendingPool; \r\n    mapping (address => int128) curveIndices;\r\n    mapping (address => uint) toDecimals;\r\n\r\n    // accounts & owners\r\n    uint32 private accountNumberSeed = 1000000;\r\n    mapping (address => uint32) public owners;\r\n    mapping (uint32 => address[]) accountHolders;\r\n    mapping (uint32 => bytes32[]) accountUserNames;\r\n    mapping (uint32 => uint16) public accountThreshold;\r\n    mapping (uint32 => address) public accountRedemptionAddress;\r\n    mapping (uint32 => uint) accountTransactionCount;\r\n    mapping (uint32 => TransferTx[]) accountPendingTransfer; // array so we can check for existence easily\r\n    mapping (uint32 => OwnerTx[]) accountPendingOwnerTx;\r\n    mapping (uint32 => uint) public accountBalance; // accountNumber => blxm coin\r\n    mapping (uint32 => mapping(uint => address[])) confirmedBy; // accountNumber => txID => address[]\r\n\r\n    // managers\r\n    mapping (address => bool) public isManager;\r\n    uint32 managementAccount;\r\n    uint public managementFee=4756468798;\r\n    uint public managementFeePeriod=15;\r\n    bool public exclude01=true;\r\n    uint public feeTimestamp=0;\r\n\r\n    // holdings\r\n    uint32[] public pendingTransfers; // account numbers with confirmed pending transfers\r\n    uint public totalCoins;\r\n\r\n    // retiring\r\n    bool public deactivated=false;\r\n\r\n    // fallback() function allows to deposit ether. fallback() is called when calldata is NOT empty and no other method is matched\r\n    fallback() external payable {\r\n        if (msg.value > 0)\r\n            // handle case where msg.sender is not a known owner\r\n            emit EtherDeposit(msg.sender, msg.value);\r\n    }\r\n\r\n    // receive() function allows to deposit ether. receive() is called when calldata is empty\r\n    receive() external payable {\r\n        if (msg.value > 0)\r\n            emit EtherDeposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function refund(address dest) external onlyManager {\r\n        (bool ret,) = dest.call{ value: address(this).balance }(\"\");\r\n        require(ret);\r\n    }\r\n\r\n    constructor(address[] memory mngr, bytes32[] memory mngrUserNames, address mngExternalAccount) {        \r\n        require(mngr.length!=0);\r\n        \r\n        for (uint i=0; i<mngr.length; i++) {\r\n            require(!isManager[mngr[i]] && mngr[i] != address(0));\r\n            isManager[mngr[i]] = true;\r\n        }\r\n\r\n        totalCoins = 0;\r\n\r\n        aaveLendingPool = ILendingPoolAddressesProvider(aaveAddressesProvider).getLendingPool();\r\n        curveIndices[dai] = 0;\r\n        curveIndices[usdc] = 1;\r\n        toDecimals[usdc] = 1e6;\r\n        toDecimals[dai] = 1e18;\r\n\r\n        managementAccount = createAccount(mngr, mngrUserNames, 1, mngExternalAccount);\r\n    }\r\n\r\n    function createAccount(address[] memory ownerAddresses, bytes32[] memory ownerUserNames, uint16 requiredSignatures, address redemptionDestination) public onlyManager returns (uint32) {\r\n        require(requiredSignatures != 0 && ownerAddresses.length==ownerUserNames.length && redemptionDestination!=address(0));\r\n\r\n        accountNumberSeed++;\r\n        uint32 accountNumber = accountNumberSeed;\r\n\r\n        for (uint i=0; i<ownerAddresses.length; i++) {\r\n            // check for duplicated names and 0 addresses\r\n            require(ownerAddresses[i] != address(0) && owners[ownerAddresses[i]]==0);\r\n            // note this means no more than 1 account per owner (==address)\r\n            owners[ownerAddresses[i]] = accountNumber;\r\n        }\r\n\r\n        accountHolders[accountNumber] = ownerAddresses;\r\n        accountUserNames[accountNumber] = ownerUserNames;\r\n        accountThreshold[accountNumber] = requiredSignatures;\r\n        accountRedemptionAddress[accountNumber] = redemptionDestination;\r\n        accountTransactionCount[accountNumber] = 0;\r\n\r\n        accountBalance[accountNumber] = 0;\r\n\r\n        return accountNumber;\r\n    }\r\n\r\n    function deleteAccount(uint32 accountNumber) external onlyManager returns (bool) {\r\n        require(accountBalance[accountNumber] == 0);\r\n\r\n        accountUserNames[accountNumber] = new bytes32[](0);\r\n        accountThreshold[accountNumber] = 0;\r\n        accountRedemptionAddress[accountNumber] = address(0);\r\n        accountTransactionCount[accountNumber] = 0;\r\n\r\n        address[] memory holders = accountHolders[accountNumber];\r\n        for (uint i=0; i<holders.length; i++) {\r\n            owners[holders[i]] = 0;\r\n        }\r\n        accountHolders[accountNumber] = new address[](0);\r\n\r\n        return true;\r\n    }\r\n\r\n    function accrueFee() external onlyManager returns (bool) {\r\n        (uint mngmtCoins, uint timestamp) = calculateFeeInternal();\r\n\r\n        accountBalance[managementAccount] += mngmtCoins;\r\n        totalCoins += mngmtCoins;\r\n        feeTimestamp = timestamp;\r\n\r\n        return true;\r\n    }\r\n\r\n    function calculateFeeInternal() internal view returns (uint, uint) {\r\n        if (feeTimestamp == 0) {\r\n            // start the \"clock\" for fees\r\n            return (0, block.timestamp);\r\n        }\r\n\r\n        uint blocks = (block.timestamp - feeTimestamp) / managementFeePeriod;\r\n        if (blocks >= 1) {\r\n            uint total = totalCoins;\r\n            if (exclude01) total -= accountBalance[managementAccount];\r\n            // n/b / (t+n/b) = f\r\n            uint newCoins = total * blocks * managementFee / (1e18 - managementFee);\r\n            uint timestamp = feeTimestamp + blocks * managementFeePeriod;\r\n\r\n            return (newCoins, timestamp);\r\n        }\r\n\r\n        return (0, feeTimestamp);\r\n    }\r\n\r\n    function setFee(uint fee) external onlyManager {\r\n        // constrain the fee to a range 0-3%\r\n        require(fee <= 14269406392);\r\n        managementFee = fee;\r\n    }\r\n\r\n    function setFeePeriod(uint feePeriod) external onlyManager {\r\n        require(feePeriod >= 10);\r\n        managementFeePeriod = feePeriod;\r\n    }\r\n\r\n    function setExcludeManagementAccount(bool exclude) external onlyManager {\r\n        exclude01 = exclude;\r\n    }\r\n\r\n    function setDeactivated() external onlyManager {\r\n        deactivated = true;\r\n    }\r\n\r\n    function unsetDeactivated() external onlyManager {\r\n        deactivated = false;\r\n    }\r\n\r\n    // sender is most likely msg.sender . keeping some flexibility for now\r\n    function deposit(uint32 accountNumber, uint amount, address sender) external accountExists(accountNumber) returns(uint) {\r\n        require(amount != 0 && !deactivated && pendingTransfers.length == 0);\r\n\r\n        (uint mngmtCoins, uint timestamp) = calculateFeeInternal();\r\n\r\n        // can only deposit usdc. amount is in USDC scaled to 6 decimals. usdc has 6 decimals. sender is the address holding the usdc balance that set the allowance and approved the transfer for us\r\n        bool ret = IErc20(usdc).transferFrom(sender, address(this), amount);\r\n        require(ret);\r\n\r\n        // total pool holdings + accrued rewards on aave and compound valued in usd based on prices on uniswap and curve\r\n        uint[] memory bals = updatePoolHoldings();\r\n        uint rewardsFromTokens = uniQuoteRewards();\r\n        // currentPoolBalance includes the newly deposited amount (after call to transferFrom()). we give blxm token 6 decimals\r\n        uint currentPoolBalance = getPoolBalanceUSD(bals) * 1e6 + rewardsFromTokens;  \r\n        uint newCoins = currentPoolBalance != amount ? amount * (totalCoins+mngmtCoins) / (currentPoolBalance-amount) : amount;\r\n        // update state\r\n        accountBalance[accountNumber] += newCoins;\r\n        totalCoins += newCoins+mngmtCoins;\r\n        accountBalance[managementAccount] += mngmtCoins;\r\n        feeTimestamp = timestamp;\r\n\r\n        emit Deposit(accountNumber, msg.sender, amount / 1e6);\r\n\r\n        return newCoins;\r\n    }\r\n\r\n    function getPoolBalanceUSD(uint[] memory bals) public view returns (uint) {\r\n        // all these are already scaled by 1e18\r\n        uint totalDai = bals[4] + bals[2] + bals[0];\r\n\r\n        // usdc is our numeraire and usdc = usd. evaluate the others. daiUsd has 6 decimals (usdc output)\r\n        ICurvePool curvePool = ICurvePool(curve3Pool);\r\n        uint daiUsd = totalDai!=0 ? curvePool.get_dy(curveIndices[dai], curveIndices[usdc], totalDai) : 0;\r\n\r\n        uint balance = bals[1] + bals[3] + bals[5] + daiUsd;\r\n\r\n        // return in USD\r\n        return balance / 1e6;\r\n    }\r\n\r\n    // this is state changing because it forces compound to update accrued interest\r\n    function updatePoolHoldings() internal returns (uint[] memory) {\r\n        uint cdaiB = ICErc20(cDai).balanceOfUnderlying(address(this));\r\n        uint cusdcB = ICErc20(cUsdc).balanceOfUnderlying(address(this));\r\n\r\n        uint adaiB = IErc20(aDai).balanceOf(address(this)); \r\n        uint ausdcB = IErc20(aUsdc).balanceOf(address(this));\r\n\r\n        // get usdc and dai uninvested holdings\r\n        uint usdcB = IErc20(usdc).balanceOf(address(this));\r\n        uint daiB = IErc20(dai).balanceOf(address(this));\r\n\r\n        // returned balances are scaled by 1e^decimals, each its own decimals. these CANNOT be changed without breaking client code\r\n        uint[] memory ret = new uint[](6);\r\n        ret[0] = cdaiB;\r\n        ret[1] = cusdcB;\r\n        ret[2] = adaiB;\r\n        ret[3] = ausdcB;\r\n        ret[4] = daiB;\r\n        ret[5] = usdcB;\r\n\r\n        return ret;\r\n    }\r\n\r\n    /// manager only so we can test validity of owner address\r\n    function submitOwnerTransaction(uint32 accountNumber, uint16 action, address owner, bytes32 ownerUsername, uint16 newThreshold) external onlyManager returns (bool) {\r\n        if (action != 3) {\r\n            require(owner != address(0));\r\n        }\r\n        \r\n        // look for owner\r\n        bool found = false;\r\n        for (uint i=0; i<accountHolders[accountNumber].length; i++) {\r\n            if (accountHolders[accountNumber][i] == owner) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (action == 1) {\r\n            // owner is being added. we verify owner does not exist\r\n            require(!found);\r\n        } else if (action == 2) {\r\n            // owner is being removed. we verify owner exists and that this is not the last owner\r\n            require(found && accountHolders[accountNumber].length > 1);\r\n        } else if (action == 3) {\r\n            // account threshold is being changed\r\n            uint numOwners = accountHolders[accountNumber].length;\r\n            require(newThreshold >= 1 && newThreshold <= numOwners);\r\n            bool one = true;\r\n            for (uint i=0; i<accountPendingOwnerTx[accountNumber].length; i++){\r\n                if (accountPendingOwnerTx[accountNumber][i].action == 3) {\r\n                    one = false;\r\n                    break;\r\n                }\r\n            }\r\n            // don't allow more than one pending threshold change tx\r\n            require(one);\r\n        }\r\n\r\n        accountTransactionCount[accountNumber]++;\r\n        OwnerTx memory ownerTx = OwnerTx({\r\n            txID: accountTransactionCount[accountNumber],\r\n            action: action,\r\n            owner: owner,\r\n            ownerUsername: ownerUsername,\r\n            newThreshold: newThreshold,\r\n            exceptionEligible: false\r\n        });\r\n\r\n        accountPendingOwnerTx[accountNumber].push(ownerTx);\r\n\r\n        return true;\r\n    }\r\n\r\n    function submitTransfer(uint32 accountNumber, uint amount, address destination) external onlyOwner(accountNumber) returns(bool) {\r\n        require(accountPendingTransfer[accountNumber].length == 0);\r\n\r\n        uint[] memory bals = updatePoolHoldings();\r\n        uint rewardsFromTokens = uniQuoteRewards();\r\n        uint pool = getPoolBalanceUSD(bals) + rewardsFromTokens / 1e6;\r\n        uint bal = accountBalance[accountNumber]; // these are the blxm tokens held in account\r\n        require(bal != 0);\r\n\r\n        uint balUSD = bal * pool / totalCoins;\r\n        // if amount is greater than balance, return entire balance\r\n        if (amount > balUSD) {\r\n            amount = balUSD;\r\n        }\r\n\r\n        if (destination == address(0)) {\r\n            destination = accountRedemptionAddress[accountNumber];\r\n        }\r\n\r\n        accountTransactionCount[accountNumber]++;\r\n        TransferTx memory transferTx = TransferTx({\r\n            txID: accountTransactionCount[accountNumber],\r\n            accountNumber: accountNumber,\r\n            destination: destination,\r\n            value: amount\r\n        });\r\n\r\n        accountPendingTransfer[accountNumber].push(transferTx);\r\n        // owner who submitted transfer automatically confirms\r\n        return confirmTransferInternal(accountNumber, transferTx.txID, msg.sender);\r\n    }\r\n\r\n    function confirmOwnerTx(uint32 accountNumber, uint txID) external onlyOwner(accountNumber) accountExists(accountNumber) returns(bool) {\r\n        bool found = false;\r\n        for (uint i=0; i<accountPendingOwnerTx[accountNumber].length; i++) {\r\n            if (accountPendingOwnerTx[accountNumber][i].txID == txID) { // matching txID ensures the right owner change is being confirmed and that txID was indeed submitted\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            if (!checkConfirmation(confirmedBy[accountNumber][txID], msg.sender)){\r\n                confirmedBy[accountNumber][txID].push(msg.sender);\r\n            }\r\n\r\n            if (confirmedBy[accountNumber][txID].length == accountThreshold[accountNumber]) {\r\n                require(executeOwnerTx(accountNumber, txID));\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false; // txID not found\r\n    }\r\n\r\n    function confirmTransfer(uint32 accountNumber, uint txID) external onlyOwner(accountNumber) accountExists(accountNumber) returns(bool) {\r\n        require(accountPendingTransfer[accountNumber].length == 1);\r\n\r\n        return confirmTransferInternal(accountNumber, txID, msg.sender);\r\n    }\r\n\r\n    function confirmTransferInternal(uint32 accountNumber, uint txID, address sender) internal returns(bool) {\r\n        if (accountPendingTransfer[accountNumber][0].txID == txID)  { // sanity check. added protection against double transfer if we have a stale enrty in confirmedBY\r\n            if (!checkConfirmation(confirmedBy[accountNumber][txID], sender)) {\r\n                confirmedBy[accountNumber][txID].push(sender); // sender already confirmed. we return normally\r\n            }\r\n\r\n            if (confirmedBy[accountNumber][txID].length == accountThreshold[accountNumber]) {\r\n                bool alreadyIn = false;\r\n                for (uint i=0; i<pendingTransfers.length; i++) {\r\n                    if (pendingTransfers[i] == accountNumber) {\r\n                        alreadyIn = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!alreadyIn) pendingTransfers.push(accountNumber); // ready to execute\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false; // txID is wrong\r\n    }\r\n\r\n    function checkConfirmation(address[] memory alreadyConfirmed, address newSender) internal pure returns(bool) {\r\n        for (uint i=0; i<alreadyConfirmed.length; i++) {\r\n            if (newSender == alreadyConfirmed[i]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function revokeTransaction(uint32 accountNumber, uint txID) external onlyOwner(accountNumber) {\r\n        // transaction could be either: an owner tx or a transfer\r\n        bool found = false;\r\n\r\n        if (accountPendingTransfer[accountNumber].length == 1 && accountPendingTransfer[accountNumber][0].txID==txID) {\r\n            accountPendingTransfer[accountNumber].pop();\r\n            for (uint i=0; i<pendingTransfers.length; i++) {\r\n                if (pendingTransfers[i]==accountNumber) {\r\n                    pendingTransfers[i] = pendingTransfers[pendingTransfers.length-1];\r\n                    pendingTransfers.pop();\r\n                }\r\n            }\r\n            found = true;\r\n        } else {\r\n            for (uint i=0; i<accountPendingOwnerTx[accountNumber].length; i++) {\r\n                if (accountPendingOwnerTx[accountNumber][i].txID == txID) {\r\n                    accountPendingOwnerTx[accountNumber][i] = accountPendingOwnerTx[accountNumber][accountPendingOwnerTx[accountNumber].length-1]; // can only pop last element in array. so shift last element first\r\n                    accountPendingOwnerTx[accountNumber].pop();\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            emit Revocation(accountNumber, txID, msg.sender);\r\n        }\r\n    }\r\n\r\n    /// manager needs to make funds available prior to calling this\r\n    function executeTransfer(uint32 accountNumber) external onlyManager returns (bool) {\r\n        require(accountPendingTransfer[accountNumber].length==1);\r\n\r\n        (uint mngmtCoins, uint timestamp) = calculateFeeInternal();\r\n        uint total = totalCoins + mngmtCoins;\r\n\r\n        uint txID = accountPendingTransfer[accountNumber][0].txID;\r\n\r\n        require(confirmedBy[accountNumber][txID].length >= accountThreshold[accountNumber]);\r\n        \r\n        // get fresh pool balance and calculate coins equivalent to amount being transferred\r\n        uint pool = getPoolBalanceUSD(updatePoolHoldings()) + uniQuoteRewards() / 1e6;\r\n        uint valToTransfer = accountPendingTransfer[accountNumber][0].value;\r\n        uint coins = valToTransfer * total / pool;\r\n        // condition satisfied only if after transfer was submitted tx fees were paid for swaps. investor pays share of fees\r\n        if (coins > accountBalance[accountNumber]) {\r\n            coins = accountBalance[accountNumber];\r\n            valToTransfer = coins * pool / total;\r\n        }\r\n\r\n        // transfer\r\n        bool ret = IErc20(usdc).transfer(accountPendingTransfer[accountNumber][0].destination, valToTransfer * 1e6);\r\n        emit Transfer(accountNumber, txID, accountPendingTransfer[accountNumber][0].destination, valToTransfer);\r\n        require(ret);\r\n\r\n        // update state\r\n        accountBalance[accountNumber] -= coins;\r\n        accountBalance[managementAccount] += mngmtCoins;\r\n        feeTimestamp = timestamp;\r\n        totalCoins = total - coins;\r\n\r\n        // remove from pending\r\n        accountPendingTransfer[accountNumber].pop();\r\n        for (uint i=0; i<pendingTransfers.length; i++) {\r\n            if (pendingTransfers[i]==accountNumber) {\r\n                pendingTransfers[i] = pendingTransfers[pendingTransfers.length-1];\r\n                pendingTransfers.pop();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n     /// not external so address(this) can call it\r\n    function executeOwnerTx(uint32 accountNumber, uint txID) public ownerOrManager(accountNumber) returns (bool) {\r\n        for (uint i=0; i<accountPendingOwnerTx[accountNumber].length; i++) {\r\n            OwnerTx memory ownerTx = accountPendingOwnerTx[accountNumber][i];\r\n            if (txID == ownerTx.txID) {\r\n                // remember that if exceptionEligible == true then at least 1 owner has already confirmed\r\n                require(confirmedBy[accountNumber][txID].length >= accountThreshold[accountNumber] || (isManager[msg.sender] && ownerTx.exceptionEligible));\r\n\r\n                if (ownerTx.action == 1) { // add owner\r\n                    addOwner(accountNumber, ownerTx.owner, ownerTx.ownerUsername);\r\n\r\n                    emit OwnerAddition(accountNumber, txID, ownerTx.owner);\r\n                } else if (ownerTx.action == 2) {\r\n                    bool changedThreshold = removeOwner(accountNumber, ownerTx.owner);\r\n\r\n                    emit OwnerRemoval(accountNumber, txID, ownerTx.owner);\r\n                    if (changedThreshold) emit RequiredSignaturesChange(accountNumber, txID, accountThreshold[accountNumber]+1, accountThreshold[accountNumber]);\r\n                } else if (ownerTx.action == 3) { // new required number of sigs for account\r\n                    uint16 oldThreshold = accountThreshold[accountNumber];\r\n                    accountThreshold[accountNumber] = ownerTx.newThreshold;\r\n\r\n                    emit RequiredSignaturesChange(accountNumber, txID, oldThreshold, ownerTx.newThreshold);\r\n                }\r\n\r\n                accountPendingOwnerTx[accountNumber][i] = accountPendingOwnerTx[accountNumber][accountPendingOwnerTx[accountNumber].length - 1];\r\n                accountPendingOwnerTx[accountNumber].pop();\r\n\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n\r\n    function addOwner(uint32 accountNumber, address owner, bytes32 ownerUsername) internal {\r\n        owners[owner] = accountNumber;\r\n        accountHolders[accountNumber].push(owner);\r\n        accountUserNames[accountNumber].push(ownerUsername);\r\n    }\r\n\r\n    function removeOwner(uint32 accountNumber, address owner) internal returns (bool) {\r\n        owners[owner] = 0; // there's no removing keys in solidity. mapping to default value does the trick\r\n        uint l = accountHolders[accountNumber].length; // kept in sync with accountUsernames\r\n        for (uint j=0; j<l; j++){\r\n            if (accountHolders[accountNumber][j] == owner) {\r\n                accountHolders[accountNumber][j] = accountHolders[accountNumber][l-1];\r\n                accountHolders[accountNumber].pop();\r\n                accountUserNames[accountNumber][j] = accountUserNames[accountNumber][l-1];\r\n                accountUserNames[accountNumber].pop();\r\n\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (accountThreshold[accountNumber] > accountHolders[accountNumber].length) {\r\n            accountThreshold[accountNumber] -= 1;\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n\r\n    function setExceptionEligible(uint32 accountNumber, uint txID) external onlyOwner(accountNumber) returns (bool) {\r\n        require(checkConfirmation(confirmedBy[accountNumber][txID], msg.sender));\r\n        \r\n        // transaction can only be an owner tx\r\n        for (uint i=0; i<accountPendingOwnerTx[accountNumber].length; i++) {\r\n            if (accountPendingOwnerTx[accountNumber][i].txID == txID) {\r\n                accountPendingOwnerTx[accountNumber][i].exceptionEligible = true;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false; // txID was not found\r\n    }\r\n\r\n    function getOwners(uint32 accountNumber) public view accountExists(accountNumber) returns (address[] memory, bytes32[] memory) {\r\n        return (accountHolders[accountNumber], accountUserNames[accountNumber]);\r\n    }\r\n\r\n    function getPendingTransfer(uint32 accountNumber) public view accountExists(accountNumber) returns (uint, address, uint) {\r\n        if (accountPendingTransfer[accountNumber].length !=1) {\r\n            return (0,address(0),0);\r\n        }\r\n        \r\n        TransferTx memory pendingTransfer = accountPendingTransfer[accountNumber][0];\r\n        return (pendingTransfer.txID, pendingTransfer.destination, pendingTransfer.value);\r\n    }\r\n\r\n    function getNumberOfPendingTransfers() public view returns (uint) {\r\n        return pendingTransfers.length;\r\n    }\r\n\r\n    function getNumberOfPendingOwnerTx(uint32 accountNumber) public view accountExists(accountNumber) returns (uint) {\r\n        return accountPendingOwnerTx[accountNumber].length;\r\n    }\r\n\r\n    function getPendingOwnerTx(uint32 accountNumber, uint ind) public view accountExists(accountNumber) returns (uint, uint16, address, bytes32, uint16) {\r\n        // ind is the index in accountPendingOwnerTx[accountNumber] of the desired transaction\r\n        OwnerTx memory ownerTx = accountPendingOwnerTx[accountNumber][ind];\r\n        return (ownerTx.txID, ownerTx.action, ownerTx.owner, ownerTx.ownerUsername, ownerTx.newThreshold);\r\n    }\r\n\r\n    function getTxConfirmations(uint32 accountNumber, uint txID) public view accountExists(accountNumber) returns (address[] memory) {\r\n        return confirmedBy[accountNumber][txID];\r\n    }\r\n\r\n    // amounts MUST be already properly scaled to reflect appropriate decimals\r\n    function portfolioActions(uint16[] calldata actions,  uint16[] calldata tokens,  uint256[] calldata amounts) external onlyManager returns (bool) {\r\n        for (uint16 a=0; a < actions.length; a++) {\r\n            if (actions[a] == 3) { // compound deposit\r\n                IErc20 underlying = tokens[a]==1 ? IErc20(usdc) : IErc20(dai);\r\n                address cAddr = tokens[a]==1 ? cUsdc : cDai;\r\n                ICErc20 cTokenContr = ICErc20(cAddr);\r\n                underlying.approve(cAddr, amounts[a]);\r\n                cTokenContr.mint(amounts[a]); // ignoring returned value\r\n            } else if (actions[a] == 1) { // compound withdraw\r\n                ICErc20 cTokenContr = tokens[a]==1 ? ICErc20(cUsdc) : ICErc20(cDai);\r\n                cTokenContr.redeemUnderlying(amounts[a]); // ignoring returned value\r\n            } else if (actions[a] == 4) { // aave deposit\r\n                address underlying = tokens[a]==1 ? usdc : dai;\r\n                IErc20(underlying).approve(aaveLendingPool, amounts[a]);\r\n                ILendingPool(aaveLendingPool).deposit(underlying, amounts[a], address(this), uint16(0));\r\n            } else if (actions[a] == 2) { // aave withdraw\r\n                address underlying = tokens[a]==1 ? usdc : dai;\r\n                ILendingPool(aaveLendingPool).withdraw(underlying, amounts[a], address(this));\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function kill() external onlyManager returns (bool) {\r\n        // liquidate everything on compound, this will automatically give us all accumulated comp\r\n        uint cdaiB = ICErc20(cDai).balanceOfUnderlying(address(this));\r\n        uint cusdcB = ICErc20(cUsdc).balanceOfUnderlying(address(this));\r\n        if (cdaiB !=0) ICErc20(cDai).redeemUnderlying(cdaiB);\r\n        if (cusdcB !=0) ICErc20(cUsdc).redeemUnderlying(cusdcB);\r\n\r\n        // aave\r\n        uint adaiB = IErc20(aDai).balanceOf(address(this)); \r\n        uint ausdcB = IErc20(aUsdc).balanceOf(address(this)); \r\n        if (adaiB !=0) ILendingPool(aaveLendingPool).withdraw(dai, type(uint256).max, address(this));\r\n        if (ausdcB !=0) ILendingPool(aaveLendingPool).withdraw(usdc, type(uint256).max, address(this));\r\n\r\n        // swap dai for usdc\r\n        uint totalDai = IErc20(dai).balanceOf(address(this));\r\n        if (totalDai!=0) curveSwap(dai, usdc, totalDai);\r\n\r\n        // swap comp\r\n        uniswap();\r\n\r\n        // stkAave not handled since only withdrawn on a schedule;\r\n\r\n        return true;\r\n    }\r\n\r\n    function claimRewards(uint16 platform) external onlyManager returns (bool) {\r\n        if (platform !=2) {\r\n            IComptroller(compoundComptroller).claimComp(address(this));\r\n        }\r\n        \r\n        if (platform !=1) {\r\n            address[] memory aTokens = new address[](2);\r\n            aTokens[0] = aUsdc;\r\n            aTokens[1] = aDai;\r\n            IAaveRewards(aaveRewardsContract).claimRewards(aTokens, type(uint256).max, address(this));\r\n            // we can only redeem after a cool down period of 10 days, and then only within 2 datys\r\n            IAaveStaked(aaveStakedContract).cooldown();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function redeemAave() external onlyManager returns (bool) {\r\n        IAaveStaked(aaveStakedContract).redeem(address(this), type(uint256).max);\r\n        return true;\r\n    }\r\n\r\n    function uniQuoteRewards() internal returns (uint) {\r\n        uint stkAaveB = 0; \r\n        IAaveRewards aaveRewards = IAaveRewards(aaveRewardsContract);\r\n        // get accrued reward tokens on aave and compound. Note: this requires Comp to have been claimed\r\n        address[] memory assets = new address[](2);\r\n        assets[0] = dai;\r\n        assets[1] = usdc;\r\n        try aaveRewards.getRewardsBalance(assets, address(this)) returns (uint v) {\r\n            stkAaveB = v;\r\n        } catch (bytes memory) {}\r\n        uint compB = IErc20(comp).balanceOf(address(this));\r\n        uint aaveB = IErc20(aave).balanceOf(address(this));\r\n        IUniQuote quoter = IUniQuote(uniswapQuoter);\r\n        uint comp2Usdc = 0;\r\n        uint aave2Usdc = 0;\r\n        if (compB != 0) {\r\n            comp2Usdc = quoter.quoteExactInput(compPath, compB);\r\n        }\r\n        if (aaveB !=0) {\r\n            aave2Usdc = quoter.quoteExactInput(aavePath, aaveB+stkAaveB);\r\n        }\r\n        \r\n        return comp2Usdc+aave2Usdc;\r\n    }\r\n\r\n    function uniswap() public onlyManager returns (uint, uint) {\r\n        uint usdcFromComp = 0;\r\n        // swap comp\r\n        uint256 compB = IErc20(comp).balanceOf(address(this));\r\n        if (compB != 0) {\r\n            IErc20(comp).approve(uniswapRouterV3, compB);\r\n\r\n            IUniswap.ExactInputParams memory params = IUniswap.ExactInputParams({\r\n                path: compPath,\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountIn: compB,\r\n                amountOutMinimum: 0\r\n            });\r\n            usdcFromComp = IUniswap(uniswapRouterV3).exactInput(params);\r\n        }\r\n        \r\n        uint usdcFromAave = 0;\r\n        // swap aave\r\n        uint256 aaveB = IErc20(aave).balanceOf(address(this));\r\n        if (aaveB != 0) {\r\n            IErc20(aave).approve(uniswapRouterV3, aaveB);\r\n\r\n            IUniswap.ExactInputParams memory params = IUniswap.ExactInputParams({\r\n                path: aavePath,\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountIn: aaveB,\r\n                amountOutMinimum: 0\r\n            });\r\n            usdcFromAave = IUniswap(uniswapRouterV3).exactInput(params);\r\n        }\r\n\r\n        return (usdcFromComp, usdcFromAave);    \r\n    }\r\n    \r\n    function curveSwap(address inErc, address outErc, uint256 amount) public onlyManager returns (bool) {\r\n        ICurvePool curvePool = ICurvePool(curve3Pool);\r\n        uint256 e = curvePool.get_dy(curveIndices[inErc], curveIndices[outErc], amount);\r\n        // sanity check\r\n        if (e * toDecimals[inErc] * 100 < amount * 90 * toDecimals[outErc]) {\r\n            return false;\r\n        }\r\n\r\n        IErc20(inErc).approve(curve3Pool, amount);\r\n        curvePool.exchange(curveIndices[inErc], curveIndices[outErc], amount, e * 9995 / 1e4);\r\n\r\n        return true;\r\n    }\r\n\r\n    function addManager(address manager, bytes32 mngrAlias) external onlyManager managerDoesNotExist(manager) returns (bool) {\r\n        isManager[manager] = true;\r\n        addOwner(managementAccount, manager, mngrAlias);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function removeManager(address manager) external onlyManager managerExists(manager) returns (bool) {\r\n        // manager can't remove self guarantees we always have at least one manager\r\n        require(msg.sender != manager);\r\n\r\n        isManager[manager] = false;\r\n        removeOwner(managementAccount, manager);\r\n        \r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"mngr\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"mngrUserNames\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"mngExternalAccount\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EtherDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"oldRequired\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newRequired\",\"type\":\"uint16\"}],\"name\":\"RequiredSignaturesChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"accountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"accountRedemptionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"accountThreshold\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"mngrAlias\",\"type\":\"bytes32\"}],\"name\":\"addManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"platform\",\"type\":\"uint16\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"confirmOwnerTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"confirmTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ownerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ownerUserNames\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint16\",\"name\":\"requiredSignatures\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"redemptionDestination\",\"type\":\"address\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inErc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outErc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"curveSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"}],\"name\":\"deleteAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exclude01\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"executeOwnerTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"}],\"name\":\"executeTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"}],\"name\":\"getNumberOfPendingOwnerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfPendingTransfers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"}],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"ind\",\"type\":\"uint256\"}],\"name\":\"getPendingOwnerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"}],\"name\":\"getPendingTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bals\",\"type\":\"uint256[]\"}],\"name\":\"getPoolBalanceUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"getTxConfirmations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementFeePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTransfers\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"actions\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"tokens\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"portfolioActions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemAave\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"revokeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setDeactivated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"txID\",\"type\":\"uint256\"}],\"name\":\"setExceptionEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"setExcludeManagementAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feePeriod\",\"type\":\"uint256\"}],\"name\":\"setFeePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"action\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ownerUsername\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"newThreshold\",\"type\":\"uint16\"}],\"name\":\"submitOwnerTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"accountNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"submitTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCoins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unsetDeactivated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BlxmPool","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000b20feee0434cdcb4204668c99883166c48de9cf70000000000000000000000000000000000000000000000000000000000000001000000000000000000000000b20feee0434cdcb4204668c99883166c48de9cf700000000000000000000000000000000000000000000000000000000000000016d616a6564000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4a1857d0c985476119c52e2ebc3519141923158e0da1adad1886a60be54869f1"}]}