{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Governance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Manages address permissions to act on Macabris contracts\\n */\\ncontract Governance {\\n\\n    enum Actions { Vote, Configure, SetOwnerAddress, TriggerOwnerWithdraw, ManageDeaths, StopPayouts, Bootstrap }\\n\\n    // Stores permissions of an address\\n    struct Permissions {\\n        bool canVote;\\n        bool canConfigure;\\n        bool canSetOwnerAddress;\\n        bool canTriggerOwnerWithdraw;\\n        bool canManageDeaths;\\n        bool canStopPayouts;\\n\\n        // Special permission that can't be voted in and only the deploying address receives\\n        bool canBootstrap;\\n    }\\n\\n    // A call for vote to change address permissions\\n    struct CallForVote {\\n\\n        // Address that will be assigned the permissions if the vote passes\\n        address subject;\\n\\n        // Permissions to be assigned if the vote passes\\n        Permissions permissions;\\n\\n        // Total number of votes for and against the permission change\\n        uint128 yeas;\\n        uint128 nays;\\n    }\\n\\n    // A vote in a call for vote\\n    struct Vote {\\n        uint64 callForVoteIndex;\\n        bool yeaOrNay;\\n    }\\n\\n    // Permissions of addresses\\n    mapping(address => Permissions) private permissions;\\n\\n    // List of calls for a vote: callForVoteIndex => CallForVote, callForVoteIndex starts from 1\\n    mapping(uint => CallForVote) private callsForVote;\\n\\n    // Last registered call for vote of every address: address => callForVoteIndex\\n    mapping(address => uint64) private lastRegisteredCallForVote;\\n\\n    // Votes of every address: address => Vote\\n    mapping(address => Vote) private votes;\\n\\n    uint64 public resolvedCallsForVote;\\n    uint64 public totalCallsForVote;\\n    uint64 public totalVoters;\\n\\n    /**\\n     * @dev Emitted when a new call for vote is registered\\n     * @param callForVoteIndex Index of the call for vote (1-based)\\n     * @param subject Subject address to change permissions to if vote passes\\n     * @param canVote Allow subject address to vote\\n     * @param canConfigure Allow subject address to configure prices, fees and base URI\\n     * @param canSetOwnerAddress Allows subject to change owner withdraw address\\n     * @param canTriggerOwnerWithdraw Allow subject address to trigger withdraw from owner's balance\\n     * @param canManageDeaths Allow subject to set tokens as dead or alive\\n     * @param canStopPayouts Allow subject to stop the bank payout schedule early\\n     */\\n    event CallForVoteRegistered(\\n        uint64 indexed callForVoteIndex,\\n        address indexed caller,\\n        address indexed subject,\\n        bool canVote,\\n        bool canConfigure,\\n        bool canSetOwnerAddress,\\n        bool canTriggerOwnerWithdraw,\\n        bool canManageDeaths,\\n        bool canStopPayouts\\n    );\\n\\n    /**\\n     * @dev Emitted when a call for vote is resolved\\n     * @param callForVoteIndex Index of the call for vote (1-based)\\n     * @param yeas Total yeas for the call after the vote\\n     * @param nays Total nays for the call after the vote\\n     */\\n    event CallForVoteResolved(\\n        uint64 indexed callForVoteIndex,\\n        uint128 yeas,\\n        uint128 nays\\n    );\\n\\n    /**\\n     * @dev Emitted when a vote is casted\\n     * @param callForVoteIndex Index of the call for vote (1-based)\\n     * @param voter Voter address\\n     * @param yeaOrNay Vote, true if yea, false if nay\\n     * @param totalVoters Total addresses with vote permission at the time of event\\n     * @param yeas Total yeas for the call after the vote\\n     * @param nays Total nays for the call after the vote\\n     */\\n    event VoteCasted(\\n        uint64 indexed callForVoteIndex,\\n        address indexed voter,\\n        bool yeaOrNay,\\n        uint64 totalVoters,\\n        uint128 yeas,\\n        uint128 nays\\n    );\\n\\n    /**\\n     * @dev Inits the contract and gives the deployer address all permissions\\n     */\\n    constructor() {\\n        _setPermissions(msg.sender, Permissions({\\n            canVote: true,\\n            canConfigure: true,\\n            canSetOwnerAddress: true,\\n            canTriggerOwnerWithdraw: true,\\n            canManageDeaths: true,\\n            canStopPayouts: true,\\n            canBootstrap: true\\n        }));\\n    }\\n\\n    /**\\n     * @dev Checks if the given address has permission to perform given action\\n     * @param subject Address to check\\n     * @param action Action to check permissions against\\n     * @return True if given address has permission to perform given action\\n     */\\n    function hasPermission(address subject, Actions action) public view returns (bool) {\\n        if (action == Actions.ManageDeaths) {\\n            return permissions[subject].canManageDeaths;\\n        }\\n\\n        if (action == Actions.Vote) {\\n            return permissions[subject].canVote;\\n        }\\n\\n        if (action == Actions.SetOwnerAddress) {\\n            return permissions[subject].canSetOwnerAddress;\\n        }\\n\\n        if (action == Actions.TriggerOwnerWithdraw) {\\n            return permissions[subject].canTriggerOwnerWithdraw;\\n        }\\n\\n        if (action == Actions.Configure) {\\n            return permissions[subject].canConfigure;\\n        }\\n\\n        if (action == Actions.StopPayouts) {\\n            return permissions[subject].canStopPayouts;\\n        }\\n\\n        if (action == Actions.Bootstrap) {\\n            return permissions[subject].canBootstrap;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * Sets permissions for a given address\\n     * @param subject Subject address to set permissions to\\n     * @param _permissions Permissions\\n     */\\n    function _setPermissions(address subject, Permissions memory _permissions) private {\\n\\n        // Tracks count of total voting addresses to be able to calculate majority\\n        if (permissions[subject].canVote != _permissions.canVote) {\\n            if (_permissions.canVote) {\\n                totalVoters += 1;\\n            } else {\\n                totalVoters -= 1;\\n\\n                // Cleaning up voting-related state for the address\\n                delete votes[subject];\\n                delete lastRegisteredCallForVote[subject];\\n            }\\n        }\\n\\n        permissions[subject] = _permissions;\\n    }\\n\\n    /**\\n     * @dev Registers a new call for vote to change address permissions\\n     * @param subject Subject address to change permissions to if vote passes\\n     * @param canVote Allow subject address to vote\\n     * @param canConfigure Allow subject address to configure prices, fees and base URI\\n     * @param canSetOwnerAddress Allows subject to change owner withdraw address\\n     * @param canTriggerOwnerWithdraw Allow subject address to trigger withdraw from owner's balance\\n     * @param canManageDeaths Allow subject to set tokens as dead or alive\\n     * @param canStopPayouts Allow subject to stop the bank payout schedule early\\n     *\\n     * Requirements:\\n     * - the caller must have the vote permission\\n     * - the caller shouldn't have any unresolved calls for vote\\n     */\\n    function callForVote(\\n        address subject,\\n        bool canVote,\\n        bool canConfigure,\\n        bool canSetOwnerAddress,\\n        bool canTriggerOwnerWithdraw,\\n        bool canManageDeaths,\\n        bool canStopPayouts\\n    ) external {\\n        require(\\n            hasPermission(msg.sender, Actions.Vote),\\n            \\\"Only addresses with vote permission can register a call for vote\\\"\\n        );\\n\\n        // If the sender has previously created a call for vote that hasn't been resolved yet,\\n        // a second call for vote can't be registered. Prevents a denial of service attack, where\\n        // a minority of voters could flood the call for vote queue.\\n        require(\\n            lastRegisteredCallForVote[msg.sender] <= resolvedCallsForVote,\\n            \\\"Only one active call for vote per address is allowed\\\"\\n        );\\n\\n        totalCallsForVote++;\\n\\n        lastRegisteredCallForVote[msg.sender] = totalCallsForVote;\\n\\n        callsForVote[totalCallsForVote] = CallForVote({\\n            subject: subject,\\n            permissions: Permissions({\\n                canVote: canVote,\\n                canConfigure: canConfigure,\\n                canSetOwnerAddress: canSetOwnerAddress,\\n                canTriggerOwnerWithdraw: canTriggerOwnerWithdraw,\\n                canManageDeaths: canManageDeaths,\\n                canStopPayouts: canStopPayouts,\\n                canBootstrap: false\\n            }),\\n            yeas: 0,\\n            nays: 0\\n        });\\n\\n        emit CallForVoteRegistered(\\n            totalCallsForVote,\\n            msg.sender,\\n            subject,\\n            canVote,\\n            canConfigure,\\n            canSetOwnerAddress,\\n            canTriggerOwnerWithdraw,\\n            canManageDeaths,\\n            canStopPayouts\\n        );\\n    }\\n\\n    /**\\n     * @dev Registers a vote\\n     * @param callForVoteIndex Call for vote index\\n     * @param yeaOrNay True to vote yea, false to vote nay\\n     *\\n     * Requirements:\\n     * - unresolved call for vote must exist\\n     * - call for vote index must match the current active call for vote\\n     * - the caller must have the vote permission\\n     */\\n    function vote(uint64 callForVoteIndex, bool yeaOrNay) external {\\n        require(hasUnresolvedCallForVote(), \\\"No unresolved call for vote exists\\\");\\n        require(\\n            callForVoteIndex == _getCurrenCallForVoteIndex(),\\n            \\\"Call for vote does not exist or is not active\\\"\\n        );\\n        require(\\n            hasPermission(msg.sender, Actions.Vote),\\n            \\\"Sender address does not have vote permission\\\"\\n        );\\n\\n        uint128 yeas = callsForVote[callForVoteIndex].yeas;\\n        uint128 nays = callsForVote[callForVoteIndex].nays;\\n\\n        // If the voter has already voted in this call for vote, undo the last vote\\n        if (votes[msg.sender].callForVoteIndex == callForVoteIndex) {\\n            if (votes[msg.sender].yeaOrNay) {\\n                yeas -= 1;\\n            } else {\\n                nays -= 1;\\n            }\\n        }\\n\\n        if (yeaOrNay) {\\n            yeas += 1;\\n        } else {\\n            nays += 1;\\n        }\\n\\n        emit VoteCasted(callForVoteIndex, msg.sender, yeaOrNay, totalVoters, yeas, nays);\\n\\n        if (yeas == (totalVoters / 2 + 1) || nays == (totalVoters - totalVoters / 2)) {\\n\\n            if (yeas > nays) {\\n                _setPermissions(\\n                    callsForVote[callForVoteIndex].subject,\\n                    callsForVote[callForVoteIndex].permissions\\n                );\\n            }\\n\\n            resolvedCallsForVote += 1;\\n\\n            // Cleaning up what we can\\n            delete callsForVote[callForVoteIndex];\\n            delete votes[msg.sender];\\n\\n            emit CallForVoteResolved(callForVoteIndex, yeas, nays);\\n\\n            return;\\n        }\\n\\n        votes[msg.sender] = Vote({\\n            callForVoteIndex: callForVoteIndex,\\n            yeaOrNay: yeaOrNay\\n        });\\n\\n        callsForVote[callForVoteIndex].yeas = yeas;\\n        callsForVote[callForVoteIndex].nays = nays;\\n    }\\n\\n    /**\\n     * @dev Returns information about the current unresolved call for vote\\n     * @return callForVoteIndex Call for vote index (1-based)\\n     * @return yeas Total yea votes\\n     * @return nays Total nay votes\\n     *\\n     * Requirements:\\n     * - Unresolved call for vote must exist\\n     */\\n    function getCurrentCallForVote() public view returns (\\n        uint64 callForVoteIndex,\\n        uint128 yeas,\\n        uint128 nays\\n    ) {\\n        require(hasUnresolvedCallForVote(), \\\"No unresolved call for vote exists\\\");\\n        uint64 index = _getCurrenCallForVoteIndex();\\n        return (index, callsForVote[index].yeas, callsForVote[index].nays);\\n    }\\n\\n    /**\\n     * @dev Checks if there is an unresolved call for vote\\n     * @return True if an unresolved call for vote exists\\n     */\\n    function hasUnresolvedCallForVote() public view returns (bool) {\\n        return totalCallsForVote > resolvedCallsForVote;\\n    }\\n\\n    /**\\n     * @dev Returns current call for vote index\\n     * @return Call for vote index (1-based)\\n     *\\n     * Doesn't check if an unresolved call for vote exists, hasUnresolvedCallForVote should be used\\n     * before using the index that this method returns.\\n     */\\n    function _getCurrenCallForVoteIndex() private view returns (uint64) {\\n        return resolvedCallsForVote + 1;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"callForVoteIndex\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canVote\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canConfigure\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canSetOwnerAddress\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canTriggerOwnerWithdraw\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canManageDeaths\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canStopPayouts\",\"type\":\"bool\"}],\"name\":\"CallForVoteRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"callForVoteIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"yeas\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nays\",\"type\":\"uint128\"}],\"name\":\"CallForVoteResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"callForVoteIndex\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"yeaOrNay\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"totalVoters\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"yeas\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nays\",\"type\":\"uint128\"}],\"name\":\"VoteCasted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"canVote\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canConfigure\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canSetOwnerAddress\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canTriggerOwnerWithdraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canManageDeaths\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canStopPayouts\",\"type\":\"bool\"}],\"name\":\"callForVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentCallForVote\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"callForVoteIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"yeas\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"nays\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"enum Governance.Actions\",\"name\":\"action\",\"type\":\"uint8\"}],\"name\":\"hasPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasUnresolvedCallForVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolvedCallsForVote\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCallsForVote\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVoters\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"callForVoteIndex\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"yeaOrNay\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}