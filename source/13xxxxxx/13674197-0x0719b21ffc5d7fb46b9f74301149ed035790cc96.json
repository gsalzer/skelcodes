{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// GUniOracle.sol \r\n\r\n// based heavily on GUniLPOracle.sol from MakerDAO\r\n// found here: https://github.com/makerdao/univ3-lp-oracle/blob/master/src/GUniLPOracle.sol\r\n// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n///////////////////////////////////////////////////////\r\n//                                                   //\r\n//    Methodology for Calculating LP Token Price     //\r\n//                                                   //\r\n///////////////////////////////////////////////////////\r\n\r\n// We derive the sqrtPriceX96 via Chainlink Oracles to prevent price manipulation in the pool:\r\n// \r\n// p0 = price of token0 in USD (18 decimal precision)\r\n// p1 = price of token1 in USD (18 decimal precision)\r\n// UNITS_0 = decimals of token0\r\n// UNITS_1 = decimals of token1\r\n// \r\n// token1/token0 = (p0 / 10^UNITS_0) / (p1 / 10^UNITS_1)               [price ratio, Uniswap format]\r\n//               = (p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)\r\n// \r\n// sqrtPriceX96 = sqrt(token1/token0) * 2^96                           [From Uniswap's definition]\r\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^96\r\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^48 * 2^48\r\n//              = sqrt((p0 * 10^UNITS_1 * 2^96) / (p1 * 10^UNITS_0)) * 2^48\r\n// \r\n// Once we have the sqrtPriceX96 we can use that to compute the fair reserves for each token. \r\n// This part may be slightly subjective depending on the implementation, \r\n// but we expect token to provide something like getUnderlyingBalancesAtPrice(uint160 sqrtPriceX96)\r\n// which will forward our oracle derived `sqrtPriceX96` \r\n// to Uniswap's LiquidityAmounts.getAmountsForLiquidity(...)\r\n// This function will return the fair reserves for each token.\r\n// Vendor-specific logic is then used to tack any uninvested fees on top of those amounts.\r\n// \r\n// Once we have the fair reserves and the prices we can compute the token price by:\r\n// \r\n// Token Price = TVL / Token Supply\r\n//             = (r0 * p0 + r1 * p1) / totalSupply\r\n\r\n\r\npragma solidity =0.6.12;\r\n\r\ninterface IExtendedAggregator {\r\n    enum TokenType {Invalid, Simple, Complex}\r\n\r\n    enum PlatformId {Invalid, Simple, Uniswap, Balancer, GUni}\r\n\r\n    /**\r\n     * @dev Returns the LP shares token\r\n     * @return address of the LP shares token\r\n     */\r\n    function getToken() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens that composes the LP shares\r\n     * @return address[] memory of token addresses\r\n     */\r\n    function getSubTokens() external view returns (address[] memory);\r\n    \r\n    /**\r\n     * @dev Returns the latest price\r\n     * @return int256 price\r\n     */\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    /**\r\n     * @dev Returns the decimals of latestAnswer()\r\n     * @return uint8\r\n     */\r\n    function decimals() external pure returns (uint8);\r\n    \r\n    /**\r\n     * @dev Returns the platform id to categorize the price aggregator\r\n     * @return uint256 1 = Uniswap, 2 = Balancer, 3 = G-UNI\r\n     */\r\n    function getPlatformId() external pure returns (PlatformId);\r\n\r\n    /**\r\n     * @dev Returns token type for categorization\r\n     * @return uint256 1 = Simple (Native or plain ERC20s), 2 = Complex (LP Tokens, Staked tokens)\r\n     */\r\n    function getTokenType() external pure returns (TokenType);\r\n}\r\n\r\ninterface IGUniPool {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getUnderlyingBalancesAtPrice(uint160) external view returns (uint256, uint256);\r\n    function getUnderlyingBalances() external view returns (uint256, uint256);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ncontract GUniOracle is IExtendedAggregator {\r\n    // solhint-disable private-vars-leading-underscore, var-name-mixedcase\r\n    uint256 private immutable UNIT_0;\r\n    uint256 private immutable UNIT_1;\r\n    uint256 private immutable TO_WAD_0;\r\n    uint256 private immutable TO_WAD_1;\r\n    uint256 private immutable TO_WAD_ORACLE_0;\r\n    uint256 private immutable TO_WAD_ORACLE_1;\r\n\r\n    address public immutable pool;\r\n    address public immutable priceFeed0;\r\n    address public immutable priceFeed1;\r\n\r\n    constructor(address _pool, address _feed0, address _feed1) public {\r\n        uint256 dec0 = uint256(IExtendedAggregator(IGUniPool(_pool).token0()).decimals());\r\n        require(dec0 <= 18, \"token0-dec-gt-18\");\r\n        UNIT_0 = 10 ** dec0;\r\n        TO_WAD_0 = 10 ** (18 - dec0);\r\n        uint256 dec1 = uint256(IExtendedAggregator(IGUniPool(_pool).token1()).decimals());\r\n        require(dec1 <= 18, \"token1-dec-gt-18\");\r\n        UNIT_1 = 10 ** dec1;\r\n        TO_WAD_1 = 10 ** (18 - dec1);\r\n        uint256 decOracle0 = uint256(IExtendedAggregator(_feed0).decimals());\r\n        require(decOracle0 <= 18, \"oracle0-dec-gt-18\");\r\n        TO_WAD_ORACLE_0 = 10 ** (18 - decOracle0);\r\n        uint256 decOracle1 = uint256(IExtendedAggregator(_feed1).decimals());\r\n        require(decOracle1 <= 18, \"oracle1-dec-gt-18\");\r\n        TO_WAD_ORACLE_1 = 10 ** (18 - decOracle1);\r\n        pool = _pool;\r\n        priceFeed0 = _feed0;\r\n        priceFeed1 = _feed1;\r\n    }\r\n\r\n    function latestAnswer() external view override returns (int256) {\r\n        // All Oracle prices are priced with 18 decimals against USD\r\n        uint256 p0 = _getWADPrice(true);  // Query token0 price from oracle (WAD)\r\n        uint256 p1 = _getWADPrice(false);  // Query token1 price from oracle (WAD)\r\n        uint160 sqrtPriceX96 =\r\n            _toUint160(_sqrt(_mul(_mul(p0, UNIT_1), (1 << 96)) / (_mul(p1, UNIT_0))) << 48);\r\n\r\n        // Get balances of the tokens in the pool\r\n        (uint256 r0, uint256 r1) = IGUniPool(pool).getUnderlyingBalancesAtPrice(sqrtPriceX96);\r\n        require(r0 > 0 || r1 > 0, \"invalid-balances\");\r\n        uint256 totalSupply = IGUniPool(pool).totalSupply();\r\n        // Protect against precision errors with dust-levels of collateral\r\n        require(totalSupply >= 1e9, \"total-supply-too-small\");\r\n\r\n        // Add the total value of each token together and divide by totalSupply to get unit price\r\n        uint256 preq = _add(\r\n            _mul(p0, _mul(r0, TO_WAD_0)),\r\n            _mul(p1, _mul(r1, TO_WAD_1))\r\n        ) / totalSupply;\r\n        \r\n        return int256(preq);\r\n    }\r\n\r\n    function getToken() external view override returns (address) {\r\n        return pool;\r\n    }\r\n\r\n    function getSubTokens() external view override returns (address[] memory) {\r\n        address[] memory arr = new address[](2);\r\n        arr[0] = IGUniPool(pool).token0();\r\n        arr[1] = IGUniPool(pool).token1();\r\n        return arr;\r\n    }\r\n\r\n    function getPlatformId() external pure override returns (IExtendedAggregator.PlatformId) {\r\n        return IExtendedAggregator.PlatformId.GUni;\r\n    }\r\n\r\n    function getTokenType() external pure override returns (IExtendedAggregator.TokenType) {\r\n        return IExtendedAggregator.TokenType.Complex;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function _getWADPrice(bool isToken0)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        int256 price = IExtendedAggregator(isToken0 ? priceFeed0 : priceFeed1).latestAnswer();\r\n        require(price > 0, \"negative-price\");\r\n        return _mul(uint256(price), isToken0 ? TO_WAD_ORACLE_0 : TO_WAD_ORACLE_1);\r\n    }\r\n\r\n    function _add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require((z = _x + _y) >= _x, \"add-overflow\");\r\n    }\r\n    function _sub(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require((z = _x - _y) <= _x, \"sub-underflow\");\r\n    }\r\n    function _mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require(_y == 0 || (z = _x * _y) / _y == _x, \"mul-overflow\");\r\n    }\r\n    function _toUint160(uint256 x) internal pure returns (uint160 z) {\r\n        require((z = uint160(x)) == x, \"uint160-overflow\");\r\n    }\r\n\r\n    // solhint-disable-next-line max-line-length\r\n    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\r\n    // solhint-disable-next-line code-complexity\r\n    function _sqrt(uint256 _x) private pure returns (uint128) {\r\n        if (_x == 0) return 0;\r\n        else {\r\n            uint256 xx = _x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n            if (xx >= 0x8) { r <<= 1; }\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = _x / r;\r\n            return uint128 (r < r1 ? r : r1);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feed0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feed1\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformId\",\"outputs\":[{\"internalType\":\"enum IExtendedAggregator.PlatformId\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenType\",\"outputs\":[{\"internalType\":\"enum IExtendedAggregator.TokenType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GUniOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000050379f632ca68d36e50cfbc8f78fe16bd1499d1e000000000000000000000000aed0c38402a5d19df6e4c03f4e2dced6e29c1ee90000000000000000000000008fffffd4afb6115b954bd326cbe7b4ba576818f6","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7bc79256cf247d63ce1f8776b821905908ee9f2ad2ab1bd53bf9a10bc37d84a0"}]}