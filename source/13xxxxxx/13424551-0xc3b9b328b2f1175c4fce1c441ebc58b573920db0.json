{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PRBProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IPRBProxy.sol\\\";\\nimport \\\"./IPRBProxyFactory.sol\\\";\\nimport \\\"./PRBProxy.sol\\\";\\n\\n/// @title PRBProxyFactory\\n/// @author Paul Razvan Berg\\ncontract PRBProxyFactory is IPRBProxyFactory {\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    uint256 public constant version = 1;\\n\\n    /// INTERNAL STORAGE ///\\n\\n    /// @dev Internal mapping to track all deployed proxies.\\n    mapping(address => bool) internal proxies;\\n\\n    /// @dev Internal mapping to track the next seed to be used by an EOA.\\n    mapping(address => bytes32) internal nextSeeds;\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function getNextSeed(address eoa) external view returns (bytes32 nextSeed) {\\n        nextSeed = nextSeeds[eoa];\\n    }\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function isProxy(address proxy) external view returns (bool result) {\\n        result = proxies[proxy];\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function deploy() external returns (address payable proxy) {\\n        proxy = deployFor(msg.sender);\\n    }\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function deployFor(address owner) public returns (address payable proxy) {\\n        bytes32 seed = nextSeeds[tx.origin];\\n\\n        // Prevent front-running the salt by hashing the concatenation of \\\"tx.origin\\\" and the user-provided seed.\\n        bytes32 salt = keccak256(abi.encode(tx.origin, seed));\\n\\n        // Load the proxy bytecode.\\n        bytes memory bytecode = type(PRBProxy).creationCode;\\n\\n        // Deploy the proxy with CREATE2.\\n        assembly {\\n            let endowment := 0\\n            let bytecodeStart := add(bytecode, 0x20)\\n            let bytecodeLength := mload(bytecode)\\n            proxy := create2(endowment, bytecodeStart, bytecodeLength, salt)\\n        }\\n\\n        // Transfer the ownership from this factory contract to the specified owner.\\n        IPRBProxy(proxy).transferOwnership(owner);\\n\\n        // Mark the proxy as deployed.\\n        proxies[proxy] = true;\\n\\n        // Increment the seed.\\n        unchecked {\\n            nextSeeds[tx.origin] = bytes32(uint256(seed) + 1);\\n        }\\n\\n        // Log the proxy via en event.\\n        emit DeployProxy(tx.origin, msg.sender, owner, seed, salt, address(proxy));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IPRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @title IPRBProxy\\n/// @author Paul Razvan Berg\\n/// @notice Proxy contract to compose transactions on owner's behalf.\\ninterface IPRBProxy {\\n    /// EVENTS ///\\n\\n    event Execute(address indexed target, bytes data, bytes response);\\n\\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @notice Returns a boolean flag that indicates whether the envoy has permission to call the given target\\n    /// contract and function selector.\\n    function getPermission(\\n        address envoy,\\n        address target,\\n        bytes4 selector\\n    ) external view returns (bool);\\n\\n    /// @notice The address of the owner account or contract.\\n    function owner() external view returns (address);\\n\\n    /// @notice How much gas to reserve for running the remainder of the \\\"execute\\\" function after the DELEGATECALL.\\n    /// @dev This prevents the proxy from becoming unusable if EVM opcode gas costs change in the future.\\n    function minGasReserve() external view returns (uint256);\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Delegate calls to the target contract by forwarding the call data. Returns the data it gets back,\\n    /// including when the contract call reverts with a reason or custom error.\\n    ///\\n    /// @dev Requirements:\\n    /// - The caller must be either an owner or an envoy.\\n    /// - `target` must be a deployed contract.\\n    /// - The owner cannot be changed during the DELEGATECALL.\\n    ///\\n    /// @param target The address of the target contract.\\n    /// @param data Function selector plus ABI encoded data.\\n    /// @return response The response received from the target contract.\\n    function execute(address target, bytes calldata data) external payable returns (bytes memory response);\\n\\n    /// @notice Sets a new value for the minimum gas reserve.\\n    /// @dev Requirements:\\n    /// - The caller must be the owner.\\n    /// @param newMinGasReserve The new minimum gas reserve.\\n    function setMinGasReserve(uint256 newMinGasReserve) external;\\n\\n    /// @notice Gives or takes a permission from an envoy to call the given target contract and function selector\\n    /// on behalf of the owner.\\n    /// @dev It is not an error to reset a permission on the same (envoy,target,selector) tuple multiple types.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be the owner.\\n    ///\\n    /// @param envoy The address of the envoy account.\\n    /// @param target The address of the target contract.\\n    /// @param selector The 4 byte function selector on the target contract.\\n    /// @param permission The boolean permission to set.\\n    function setPermission(\\n        address envoy,\\n        address target,\\n        bytes4 selector,\\n        bool permission\\n    ) external;\\n\\n    /// @notice Transfers the owner of the contract to a new account.\\n    /// @dev Requirements:\\n    /// - The caller must be the owner.\\n    /// @param newOwner The address of the new owner account.\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IPRBProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @title IPRBProxyFactory\\n/// @author Paul Razvan Berg\\n/// @notice Deploys new proxies with CREATE2.\\ninterface IPRBProxyFactory {\\n    /// EVENTS ///\\n\\n    event DeployProxy(\\n        address indexed origin,\\n        address indexed deployer,\\n        address indexed owner,\\n        bytes32 seed,\\n        bytes32 salt,\\n        address proxy\\n    );\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @notice Gets the next seed that will be used to deploy the proxy.\\n    /// @param eoa The externally owned account that will own the proxy.\\n    function getNextSeed(address eoa) external view returns (bytes32 result);\\n\\n    /// @notice Mapping to track all deployed proxies.\\n    /// @param proxy The address of the proxy to make the check for.\\n    function isProxy(address proxy) external view returns (bool result);\\n\\n    /// @notice The release version of PRBProxy.\\n    /// @dev This is stored in the factory rather than the proxy to save gas for end users.\\n    function version() external view returns (uint256);\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Deploys a new proxy via CREATE2.\\n    /// @dev Sets \\\"msg.sender\\\" as the owner of the proxy.\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deploy() external returns (address payable proxy);\\n\\n    /// @notice Deploys a new proxy via CREATE2, for the given owner.\\n    /// @param owner The owner of the proxy.\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deployFor(address owner) external returns (address payable proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/PRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IPRBProxy.sol\\\";\\n\\n/// @notice Emitted when the caller is not the owner.\\nerror PRBProxy__ExecutionNotAuthorized(address owner, address caller, address target, bytes4 selector);\\n\\n/// @notice Emitted when execution reverted with no reason.\\nerror PRBProxy__ExecutionReverted();\\n\\n/// @notice Emitted when the caller is not the owner.\\nerror PRBProxy__NotOwner(address owner, address caller);\\n\\n/// @notice Emitted when the owner is changed during the DELEGATECALL.\\nerror PRBProxy__OwnerChanged(address originalOwner, address newOwner);\\n\\n/// @notice Emitted when passing an EOA or an undeployed contract as the target.\\nerror PRBProxy__TargetInvalid(address target);\\n\\n/// @title PRBProxy\\n/// @author Paul Razvan Berg\\ncontract PRBProxy is IPRBProxy {\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IPRBProxy\\n    address public owner;\\n\\n    /// @inheritdoc IPRBProxy\\n    uint256 public minGasReserve;\\n\\n    /// INTERNAL STORAGE ///\\n\\n    /// @notice Maps envoys to target contracts to function selectors to boolean flags.\\n    mapping(address => mapping(address => mapping(bytes4 => bool))) internal permissions;\\n\\n    /// CONSTRUCTOR ///\\n\\n    constructor() {\\n        minGasReserve = 5_000;\\n        owner = msg.sender;\\n        emit TransferOwnership(address(0), msg.sender);\\n    }\\n\\n    /// FALLBACK FUNCTION ///\\n\\n    /// @dev Called when Ether is sent and the call data is empty.\\n    receive() external payable {}\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxy\\n    function getPermission(\\n        address envoy,\\n        address target,\\n        bytes4 selector\\n    ) external view returns (bool) {\\n        return permissions[envoy][target][selector];\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxy\\n    function execute(address target, bytes calldata data) external payable returns (bytes memory response) {\\n        // Check that the caller is either the owner or an envoy.\\n        if (owner != msg.sender) {\\n            bytes4 selector;\\n            assembly {\\n                selector := calldataload(data.offset)\\n            }\\n            if (!permissions[msg.sender][target][selector]) {\\n                revert PRBProxy__ExecutionNotAuthorized(owner, msg.sender, target, selector);\\n            }\\n        }\\n\\n        // Check that the target is a valid contract.\\n        uint256 codeSize;\\n        assembly {\\n            codeSize := extcodesize(target)\\n        }\\n        if (codeSize == 0) {\\n            revert PRBProxy__TargetInvalid(target);\\n        }\\n\\n        // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\\n        address owner_ = owner;\\n\\n        // Reserve some gas to ensure that the function has enough to finish the execution.\\n        uint256 stipend = gasleft() - minGasReserve;\\n\\n        // Delegate call to the target contract.\\n        bool success;\\n        (success, response) = target.delegatecall{ gas: stipend }(data);\\n\\n        // Check that the owner has not been changed.\\n        if (owner_ != owner) {\\n            revert PRBProxy__OwnerChanged(owner_, owner);\\n        }\\n\\n        // Log the execution.\\n        emit Execute(target, data, response);\\n\\n        // Check if the call was successful or not.\\n        if (!success) {\\n            // If there is return data, the call reverted with a reason or a custom error.\\n            if (response.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(response)\\n                    revert(add(32, response), returndata_size)\\n                }\\n            } else {\\n                revert PRBProxy__ExecutionReverted();\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IPRBProxy\\n    function setMinGasReserve(uint256 newMinGasReserve) external {\\n        if (owner != msg.sender) {\\n            revert PRBProxy__NotOwner(owner, msg.sender);\\n        }\\n        minGasReserve = newMinGasReserve;\\n    }\\n\\n    /// @inheritdoc IPRBProxy\\n    function setPermission(\\n        address envoy,\\n        address target,\\n        bytes4 selector,\\n        bool permission\\n    ) external {\\n        if (owner != msg.sender) {\\n            revert PRBProxy__NotOwner(owner, msg.sender);\\n        }\\n        permissions[envoy][target][selector] = permission;\\n    }\\n\\n    /// @inheritdoc IPRBProxy\\n    function transferOwnership(address newOwner) external {\\n        if (owner != msg.sender) {\\n            revert PRBProxy__NotOwner(owner, msg.sender);\\n        }\\n        owner = newOwner;\\n        emit TransferOwnership(owner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"DeployProxy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"deployFor\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eoa\",\"type\":\"address\"}],\"name\":\"getNextSeed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"nextSeed\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"isProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PRBProxyFactory","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}