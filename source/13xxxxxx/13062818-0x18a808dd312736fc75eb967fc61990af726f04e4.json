{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides a function for encoding some bytes in base64\\nlibrary Base64 {\\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n        \\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n            \\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n            \\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n            \\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n            \\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               dataPtr := add(dataPtr, 3)\\n               \\n               // read 3 bytes\\n               let input := mload(dataPtr)\\n               \\n               // write 4 characters\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n            }\\n            \\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BurnNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n   (                          (\\n ( )\\\\   (  (         (      ( )\\\\      (\\n )((_) ))\\\\ )(   (    )\\\\ )   )((_)  (  )\\\\ ) (\\n((_)_ /((_|()\\\\  )\\\\ )(()/(  ((_)_   )\\\\(()/( )\\\\\\n | _ |_))( ((_)_(_/( )(_))  | _ ) ((_))(_)|(_)\\n | _ \\\\ || | '_| ' \\\\)) || |  | _ \\\\/ _ \\\\ || (_-<\\n |___/\\\\_,_|_| |_||_| \\\\_, |  |___/\\\\___/\\\\_, /__/\\n                     |__/             |__/\\n*/\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"./MetaDataGenerator.sol\\\";\\n\\ncontract BurnNFT is ERC721 {\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private _tokenIds;\\n\\n    event NewToken(address _minter, uint256 _tokenId, uint256 _baseFee);\\n\\n    uint public limit;\\n    uint256 public price;\\n    address public beneficiary;\\n    uint256 public minBaseFee = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 public maxBaseFee = 1;\\n\\n    mapping(uint256 => uint256) public tokenBaseFee;\\n\\n    constructor(uint _limit, uint256 _price, address _beneficiary) ERC721(\\\"BurnyBoy\\\", \\\"BURN\\\") {\\n      limit = _limit;\\n      price = _price;\\n      beneficiary = _beneficiary;\\n    }\\n\\n    function mint() public payable returns (uint256) {\\n\\n        require(msg.value >= price, \\\"price too low\\\");\\n\\n        _tokenIds.increment();\\n        uint256 newItemId = _tokenIds.current();\\n        require(newItemId <= limit, \\\"at limit\\\");\\n\\n        _safeMint(msg.sender, newItemId);\\n\\n        uint256 baseFee = block.basefee;\\n        tokenBaseFee[newItemId] = baseFee;\\n\\n        if(baseFee > maxBaseFee) {\\n          maxBaseFee = baseFee;\\n        }\\n        if(baseFee < minBaseFee) {\\n          minBaseFee = baseFee;\\n        }\\n\\n        emit NewToken(msg.sender, newItemId, baseFee);\\n\\n        return newItemId;\\n    }\\n\\n    function withdrawFunds() public {\\n      require(msg.sender == beneficiary, 'only beneficiary');\\n      uint amount = address(this).balance;\\n\\n      (bool success,) = beneficiary.call{value: amount}(\\\"\\\");\\n      require(success, \\\"Failed\\\");\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n      return _tokenIds.current();\\n    }\\n\\n    function tokenURI(uint256 id) public view override returns (string memory) {\\n\\n        require(_exists(id), \\\"not exist\\\");\\n\\n        return MetaDataGenerator.tokenURI(\\n          MetaDataGenerator.MetaDataParams({\\n            tokenId: id,\\n            tokenBaseFee:\\n            tokenBaseFee[id],\\n            owner: ownerOf(id),\\n            minBaseFee: minBaseFee,\\n            maxBaseFee: maxBaseFee,\\n            fireHeight: 0,\\n            readableBaseFee: '',\\n            ownerOrBurniest: ''\\n            }));\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/HexStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nlibrary HexStrings {\\n    bytes16 internal constant ALPHABET = '0123456789abcdef';\\n\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = ALPHABET[value & 0xf];\\n            value >>= 4;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MetaDataGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport 'base64-sol/base64.sol';\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport './HexStrings.sol';\\n/// @title NFTSVG\\n/// @notice Provides a function for generating an SVG associated with a Uniswap NFT\\nlibrary MetaDataGenerator {\\n\\n  using Strings for uint256;\\n  using HexStrings for uint160;\\n\\n  struct MetaDataParams {\\n    uint256 tokenId;\\n    uint256 tokenBaseFee;\\n    address owner;\\n    uint256 minBaseFee;\\n    uint256 maxBaseFee;\\n    uint fireHeight;\\n    string readableBaseFee;\\n    string ownerOrBurniest;\\n  }\\n\\n  string internal constant svgStart = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" viewBox=\\\"0 0 300 300\\\"><defs><linearGradient id=\\\"linear-gradient\\\" x1=\\\"150\\\" x2=\\\"150\\\" y2=\\\"300\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop offset=\\\"0\\\" stop-color=\\\"#00bdd0\\\"/><stop offset=\\\"1\\\" stop-color=\\\"#008ad0\\\"/></linearGradient><linearGradient id=\\\"linear-gradient-2\\\" x1=\\\"30.7\\\" y1=\\\"-8.2\\\" x2=\\\"30.7\\\" y2=\\\"141.5\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop offset=\\\"0\\\" stop-color=\\\"#f16d76\\\"/><stop offset=\\\"1\\\" stop-color=\\\"#ffa358\\\"/></linearGradient><linearGradient id=\\\"linear-gradient-3\\\" x1=\\\"34.5\\\" y1=\\\"29.9\\\" x2=\\\"34.5\\\" y2=\\\"144.9\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop offset=\\\"0\\\" stop-color=\\\"#ffbd58\\\"/><stop offset=\\\"1\\\" stop-color=\\\"#f6ec47\\\"/></linearGradient><linearGradient id=\\\"linear-gradient-4\\\" x1=\\\"31.9\\\" y1=\\\"2.5\\\" x2=\\\"31.9\\\" y2=\\\"146.3\\\" xlink:href=\\\"#linear-gradient-2\\\"/><linearGradient id=\\\"linear-gradient-5\\\" x1=\\\"67.8\\\" y1=\\\"27.9\\\" x2=\\\"67.8\\\" y2=\\\"74.5\\\" xlink:href=\\\"#linear-gradient-2\\\"/><linearGradient id=\\\"linear-gradient-6\\\" x1=\\\"36.5\\\" y1=\\\"-15.1\\\" x2=\\\"36.5\\\" y2=\\\"52.8\\\" xlink:href=\\\"#linear-gradient-2\\\"/><linearGradient id=\\\"linear-gradient-7\\\" x1=\\\"33.6\\\" y1=\\\"22.5\\\" x2=\\\"33.6\\\" y2=\\\"148.5\\\" xlink:href=\\\"#linear-gradient-3\\\"/><linearGradient id=\\\"linear-gradient-8\\\" x1=\\\"23.1\\\" y1=\\\"-8.3\\\" x2=\\\"23.1\\\" y2=\\\"155.9\\\" xlink:href=\\\"#linear-gradient-2\\\"/><linearGradient id=\\\"linear-gradient-9\\\" x1=\\\"64.9\\\" y1=\\\"6.7\\\" x2=\\\"64.9\\\" y2=\\\"100\\\" xlink:href=\\\"#linear-gradient-2\\\"/><linearGradient id=\\\"linear-gradient-10\\\" x1=\\\"48.4\\\" y1=\\\"-45.8\\\" x2=\\\"48.4\\\" y2=\\\"80.7\\\" xlink:href=\\\"#linear-gradient-2\\\"/><linearGradient id=\\\"linear-gradient-11\\\" x1=\\\"25.6\\\" y1=\\\"8.2\\\" x2=\\\"25.6\\\" y2=\\\"149.8\\\" xlink:href=\\\"#linear-gradient-3\\\"/><linearGradient id=\\\"linear-gradient-12\\\" x1=\\\"150\\\" y1=\\\"300\\\" x2=\\\"150\\\" y2=\\\"139.8\\\" xlink:href=\\\"#linear-gradient-3\\\"/><linearGradient id=\\\"linear-gradient-13\\\" x1=\\\"96\\\" y1=\\\"202.4\\\" x2=\\\"150\\\" y2=\\\"202.4\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop offset=\\\"0\\\" stop-color=\\\"#574581\\\"/><stop offset=\\\"1\\\" stop-color=\\\"#4c235b\\\"/></linearGradient><linearGradient id=\\\"linear-gradient-14\\\" x1=\\\"150\\\" y1=\\\"202.4\\\" x2=\\\"204\\\" y2=\\\"202.4\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop offset=\\\"0\\\" stop-color=\\\"#ea496a\\\"/><stop offset=\\\"1\\\" stop-color=\\\"#ea6b60\\\"/></linearGradient><linearGradient id=\\\"linear-gradient-15\\\" x1=\\\"150\\\" y1=\\\"153.7\\\" x2=\\\"204\\\" y2=\\\"153.7\\\" xlink:href=\\\"#linear-gradient-14\\\"/><linearGradient id=\\\"linear-gradient-16\\\" x1=\\\"204\\\" y1=\\\"105\\\" x2=\\\"150\\\" y2=\\\"105\\\" xlink:href=\\\"#linear-gradient\\\"/><linearGradient id=\\\"linear-gradient-17\\\" x1=\\\"96\\\" y1=\\\"105\\\" x2=\\\"150\\\" y2=\\\"105\\\" xlink:href=\\\"#linear-gradient-14\\\"/><linearGradient id=\\\"linear-gradient-18\\\" x1=\\\"96\\\" y1=\\\"153.7\\\" x2=\\\"150\\\" y2=\\\"153.7\\\" xlink:href=\\\"#linear-gradient-13\\\"/><linearGradient id=\\\"linear-gradient-19\\\" x1=\\\"149.1\\\" y1=\\\"24\\\" x2=\\\"149.1\\\" y2=\\\"276\\\" xlink:href=\\\"#linear-gradient-13\\\"/><clipPath id=\\\"clip-path\\\"><path class=\\\"cls-1\\\" d=\\\"M0-42.3h300v188.6H0z\\\"/></clipPath><clipPath id=\\\"clip-path-2\\\"><path class=\\\"cls-1\\\" d=\\\"M.4 0h300v300H.4z\\\"/></clipPath><style>.cls-1{fill:none}.cls-2{fill:url(#linear-gradient)}.cls-4{fill:url(#linear-gradient-2)}.cls-5{fill:url(#linear-gradient-3)}.cls-14{fill:url(#linear-gradient-12)}.cls-15{opacity:.2}.cls-16{clip-path:url(#clip-path-2)}.cls-17{fill:#e75a00}.cls-18{fill:url(#linear-gradient-13)}.cls-19{fill:#fff}.cls-20{fill:url(#linear-gradient-14)}.cls-21{fill:url(#linear-gradient-15)}.cls-22{fill:url(#linear-gradient-16)}.cls-23{fill:url(#linear-gradient-17)}.cls-24{fill:url(#linear-gradient-18)}.cls-25{stroke:#fff;stroke-miterlimit:10;fill:url(#linear-gradient-19)}</style></defs><path class=\\\"cls-2\\\" d=\\\"M0 0h300v300H0z\\\" id=\\\"background\\\"/><g id=\\\"fire-layer\\\"><g id=\\\"Fire_to_move\\\" data-name=\\\"Fire to move\\\"><g id=\\\"Fire1\\\"><g id=\\\"fire-001\\\"><path class=\\\"cls-4\\\" d=\\\"M-4.4 139.2c-.4-12.2-17.5-31.5-9.6-49s21-13 24-30c0 0 10.3 9.6 1.1 21.6 0 0 13.3-3.8 12.8-14.6s1.5-15.7-7.4-18-22.2-18.4-9.3-35.5c0 0 2.4 14.4 13.8 8.1s20.7-26 1-26.5c0 0 12.3-8.1 19.7.4s-9.4 27-3.5 31.5S52 33.1 51.5 43 35.8 61.8 41.2 66.3s19.3 1.5 19.7-3.3c.3-4.8-7.9-10.6-1-20a18.7 18.7 0 009 11.8c9.9 5.5 12.2 17.8 2.3 26.8-6.7 6.2-15-3.4-15.9 5.9-.6 5.4 21 13 19 29.1-3.7 29.7 9.3 24.5-33.1 24.5-47.6 0-45.6-1.9-45.6-1.9z\\\"/><path class=\\\"cls-5\\\" d=\\\"M35 145c-62.2 0-33.8-7.3-27-16.2C19.8 113.2-2.7 113.6-2.2 100s8.9-20.3 8.9-20.3-5.2 16 2.2 16.5S24 91 27.9 76c6.6-26.2.5-40.3-8.4-46.2A37.5 37.5 0 0138 39.6c6 6-4.6 17.3-4.3 26.7.7 24.6 34.8 5 31.7-5.8 0 0 9.5 14.8-2.9 17-22.4 4.2-21.4 20.6-13 26s6 16.3 13.6 24.6c10 11 26 16.8-28.3 16.8z\\\"/></g><use href=\\\"#fire-001\\\" x=\\\"77\\\"/><use href=\\\"#fire-001\\\" x=\\\"154\\\"/><use href=\\\"#fire-001\\\" x=\\\"231\\\"/></g><path class=\\\"cls-14\\\" d=\\\"M0 139.8h300V300H0z\\\"/></g></g><g class=\\\"cls-15\\\" id=\\\"ray\\\"><g class=\\\"cls-16\\\"><path id=\\\"ray1\\\" class=\\\"cls-17\\\" d=\\\"M153.4 383q8.5-.1 16.9-.8L153.4 211z\\\"/></g>';\\n\\n  string internal constant svgMiddle = '</g><g id=\\\"Ether\\\"><path class=\\\"cls-18\\\" d=\\\"M150 197.4v44.5l-54-79 54 34.5z\\\"/><path class=\\\"cls-19\\\" d=\\\"M150 242.3a.4.4 0 01-.3-.2l-54-78.9a.4.4 0 01.5-.5l54 34.3a.4.4 0 01.2.4v44.5a.4.4 0 01-.3.4.4.4 0 01-.1 0zm-52.6-78l52.2 76.3v-43z\\\"/><path class=\\\"cls-20\\\" d=\\\"M204 163l-54 78.9v-44.5l54-34.4z\\\"/><path class=\\\"cls-19\\\" d=\\\"M150 242.3a.4.4 0 01-.1 0 .4.4 0 01-.3-.4v-44.5a.4.4 0 01.2-.4l54-34.3a.4.4 0 01.5.5l-54 78.9a.4.4 0 01-.3.2zm.4-44.7v43l52.2-76.2z\\\"/><path class=\\\"cls-21\\\" d=\\\"M204 151.9l-54-30.7v65l54-34.3z\\\"/><path class=\\\"cls-19\\\" d=\\\"M150 186.7a.4.4 0 01-.4-.4v-65.1a.4.4 0 01.6-.4l54 30.7a.4.4 0 010 .7l-54 34.4a.4.4 0 01-.2 0zm.4-64.8v63.6l52.8-33.6z\\\"/><g><path class=\\\"cls-22\\\" d=\\\"M204 151.9L150 58v63l54 30.8z\\\"/><path class=\\\"cls-19\\\" d=\\\"M204 152.3a.4.4 0 01-.2 0l-54-30.8a.4.4 0 01-.2-.3v-63a.4.4 0 01.7-.3l54 93.8a.4.4 0 01-.3.6zM150.4 121l52.5 29.8-52.5-91.2z\\\"/></g><g><path class=\\\"cls-23\\\" d=\\\"M150 58.1v63L96 152 150 58z\\\"/><path class=\\\"cls-19\\\" d=\\\"M96 152.3a.4.4 0 01-.3-.6l54-93.8a.4.4 0 01.7.2v63a.4.4 0 01-.2.4l-54 30.7a.4.4 0 01-.2 0zm53.6-92.7l-52.5 91.2 52.5-29.8z\\\"/></g><g><path class=\\\"cls-24\\\" d=\\\"M150 121.2v65L96 152l54-30.7z\\\"/><path class=\\\"cls-19\\\" d=\\\"M150 186.7a.4.4 0 01-.2 0l-54-34.5a.4.4 0 010-.7l54-30.7a.4.4 0 01.6.4v65a.4.4 0 01-.4.5zm-53.2-34.8l52.8 33.6V122z\\\"/></g><g><path class=\\\"cls-19\\\" d=\\\"M203.8 162.7L150 196.9l-53.8-34.2a.4.4 0 00-.5.5l54 78.9a.4.4 0 00.2.1.4.4 0 00.2 0 .4.4 0 00.2 0v-.1l54-78.9a.4.4 0 00-.5-.5zm-54.2 34.9v43l-52.2-76.2zm.8 43v-43l52.2-33.2z\\\"/><path class=\\\"cls-19\\\" d=\\\"M95.6 151.9a.4.4 0 00.1.2v.1l54 34.4h.1a.4.4 0 00.4 0l54-34.4h.1a.4.4 0 000-.2.4.4 0 000-.1h.1a.4.4 0 000-.2l-54-93.8a.4.4 0 00-.1 0 .3.3 0 00-.1-.1.2.2 0 00-.1 0 .4.4 0 00-.1 0h-.1a.3.3 0 00-.1 0 .3.3 0 00-.1.1l-54 93.8a.4.4 0 000 .2c-.1 0 0 0 0 0zm54-30v63.6L96.8 152zm.8 63.6V122l52.8 30zm0-64.5V59.6l52.5 91.2zm-.8-61.4V121l-52.5 29.8z\\\"/></g></g><g id=\\\"Ring\\\"><g id=\\\"rotatethis\\\"><path class=\\\"cls-25\\\" d=\\\"M149 24a126 126 0 10126 126A126 126 0 00149 24zm0 225.3a99.3 99.3 0 1199.4-99.3 99.3 99.3 0 01-99.3 99.3z\\\"/><path id=\\\"textcircle\\\" class=\\\"cls-1\\\" d=\\\"M32 150a118 118 0 10236 0 118 118 0 10-236 0\\\"><animateTransform attributeName=\\\"transform\\\" begin=\\\"0s\\\" dur=\\\"50s\\\" type=\\\"rotate\\\" from=\\\"0 150 150\\\" to=\\\"360 150 150\\\" repeatCount=\\\"indefinite\\\"/></path></g></g><defs><style>@keyframes ff{0%,49.9%,to{transform:translate(0,0) scale(1,1)}50%,99.9%{transform:translate(300px,0) scale(-1,1)}}#Fire1{animation:ff 300ms linear infinite normal forwards}text{font-size:16px;font-family:Helvetica,sans-serif;font-weight:900;fill:#fff;letter-spacing:1px}#Ether,#Ring,#background{filter:hue-rotate(';\\n\\n  function generateConfigString(MetaDataParams memory params) internal pure returns (string memory) {\\n\\n    if(params.tokenBaseFee < 10000000) {\\n      params.readableBaseFee = '&lt;0.01 Gwei';\\n    }\\n\\n    return string(abi.encodePacked(Strings.toString((params.tokenBaseFee + (params.tokenId * 30)) % 360),\\n    'deg)}#Fire_to_move{transform:translate(0px,',\\n    params.fireHeight.toString(),\\n    'px)}</style></defs><text dy=\\\"0\\\"><textPath xlink:href=\\\"#textcircle\\\"> / EIP-1559 / #',\\n    params.tokenId.toString(),\\n    ' / Basefee: ',\\n    params.readableBaseFee,\\n    ' / ',\\n    params.ownerOrBurniest,\\n    unicode'🔥🔥🔥🔥🔥🔥🔥🔥',\\n    '</textPath></text></svg>'));\\n  }\\n\\n  function generateRayString() internal pure returns (string memory) {\\n    uint16[59] memory rotations = [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354];\\n    string memory rays = '';\\n    for (uint i=0; i<rotations.length; i++) {\\n      rays = string(abi.encodePacked(rays,\\n        '<use href=\\\"#ray1\\\" transform=\\\"rotate(',\\n        Strings.toString(rotations[i]),\\n        ' 150 150)\\\" />'));\\n    }\\n\\n    return rays;\\n  }\\n\\n  function appendEmoji(string memory start, string memory emoji, uint emojiCount) internal pure returns (string memory) {\\n    for (uint i=0; i<emojiCount; i++) {\\n      start = string(abi.encodePacked(start, emoji));\\n    }\\n    return start;\\n  }\\n\\n  function generateSVGofTokenById(MetaDataParams memory params) internal pure returns (string memory) {\\n\\n      uint height = 270;\\n\\n      if(params.minBaseFee == params.maxBaseFee) {\\n        params.fireHeight = 0;\\n      } else {\\n        params.fireHeight = height*(uint(100)-(uint(100)*(params.tokenBaseFee-params.minBaseFee)/(params.maxBaseFee-params.minBaseFee))) / uint(100);\\n      }\\n\\n      if(params.maxBaseFee == params.tokenBaseFee) {\\n        params.ownerOrBurniest = appendEmoji(unicode'Burniest Boy ',unicode'🔥',30);\\n      } else if(params.minBaseFee == params.tokenBaseFee) {\\n        params.ownerOrBurniest = appendEmoji(unicode'Ice cold ',unicode'🧊',30);\\n      } else if((params.tokenBaseFee / uint(1_000_000_000)) == 69) {\\n        params.ownerOrBurniest = appendEmoji(unicode'Nice. ',unicode'♋',30);\\n      } else if((params.tokenBaseFee / uint(1_000_000_000)) == 420) {\\n        params.ownerOrBurniest = appendEmoji(unicode'Nice. ',unicode'🌲',30);\\n      } else {\\n        params.ownerOrBurniest = (uint160(params.owner)).toHexString(20);\\n      }\\n\\n      string memory svg = string(abi.encodePacked(\\n        svgStart,\\n        generateRayString(),\\n        svgMiddle,\\n        generateConfigString(params)\\n        ));\\n\\n      return svg;\\n  }\\n\\n  function tokenURI(MetaDataParams memory params) internal pure returns (string memory) {\\n\\n      string memory name = string(abi.encodePacked('Burny Boy #',params.tokenId.toString()));\\n\\n      if(params.tokenBaseFee < uint(10_000_000)) {\\n        params.readableBaseFee = string(abi.encodePacked(params.tokenBaseFee.toString(), ' wei'));\\n        } else if(params.tokenBaseFee < uint(100_000_000)) {\\n          params.readableBaseFee = string(abi.encodePacked('0.0',Strings.toString(params.tokenBaseFee/uint(10_000_000)), ' Gwei'));\\n        } else if(params.tokenBaseFee < uint(10_000_000_000)) {\\n          params.readableBaseFee = string(abi.encodePacked(Strings.toString(params.tokenBaseFee/uint(1_000_000_000)),'.',Strings.toString((params.tokenBaseFee/uint(10_000_000)) % uint(100)), ' Gwei'));\\n        } else {\\n          params.readableBaseFee = string(abi.encodePacked(Strings.toString(params.tokenBaseFee/uint(1_000_000_000)), ' Gwei'));\\n        }\\n\\n      string memory description = string(abi.encodePacked('When this burny boy was minted, the basefee was ',params.readableBaseFee));\\n      string memory image = Base64.encode(bytes(generateSVGofTokenById(params)));\\n\\n      return\\n          string(\\n              abi.encodePacked(\\n                'data:application/json;base64,',\\n                Base64.encode(\\n                    bytes(\\n                          abi.encodePacked(\\n                              '{\\\"name\\\":\\\"',\\n                              name,\\n                              '\\\", \\\"description\\\":\\\"',\\n                              description,\\n                              '\\\", \\\"external_url\\\":\\\"https://burnyboys.com/token/',\\n                              params.tokenId.toString(),\\n                              '\\\", \\\"attributes\\\": [{\\\"trait_type\\\": \\\"Base fee per gas (wei)\\\", \\\"value\\\": ',\\n                              Strings.toString(params.tokenBaseFee),\\n                              '}], \\\"owner\\\":\\\"',\\n                              (uint160(params.owner)).toHexString(20),\\n                              '\\\", \\\"image\\\": \\\"',\\n                              'data:image/svg+xml;base64,',\\n                              image,\\n                              '\\\"}'\\n                          )\\n                        )\\n                    )\\n              )\\n          );\\n  }\\n\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseFee\",\"type\":\"uint256\"}],\"name\":\"NewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBaseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBaseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenBaseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BurnNFT","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000061700000000000000000000000000000000000000000000000000376305bc0c600000000000000000000000000097843608a00e2bbc75ab0c1911387e002565dede","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}