{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/nft/token/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC1155 Receiver contract\\n * @dev Contract implementing the IERC1155Receiver interface\\n * \\n * This contract is meant to be used as a base contract for \\n * other contracts, to enable them to receive ERC1155 transfers.\\n * Attempting transfer of ERC1155 tokens to contracts that don't\\n * implement this interface will lead to transaction revertion.\\n */\\ncontract ERC1155Receiver is IERC1155Receiver, ERC165  {\\n    \\n    event ERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event ERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] ids,\\n        uint256[] values,\\n        bytes data\\n    );\\n\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external override returns (bytes4){\\n        emit ERC1155Received(operator, from, id, value, data);\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external override returns (bytes4){\\n        emit ERC1155BatchReceived(operator, from, ids, values, data);\\n        return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/nft/token/NFT_Auction_Market_v4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.5 <0.9.0;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n* Interface for royalties following EIP-2981 (https://eips.ethereum.org/EIPS/eip-2981).\\n*/\\ninterface IERC2981 is IERC165 {\\n    function royaltyInfo(\\n        uint256 _tokenId,\\n        uint256 _salePrice\\n    ) external view returns (\\n        address receiver,\\n        uint256 royaltyAmount\\n    );\\n}\\n\\n/**\\n * @title NFT Auction Market + royalties\\n * Sellers can choose a minimum, starting bid, an expiry time when the auction ends\\n * Before creating an auction the seller has to approve this contract for the respective token,\\n * which will be held in contract until the auction ends.\\n * bid price = price + fee \\n * which he will be refunded in case he gets outbid.\\n * After the specified expiry date of an auction anyone can trigger the settlement \\n * Not only will we transfer tokens to new owners, but we will also transfer sales money to sellers.\\n * All comissions will be credited to the owner / deployer of the marketplace contract.\\n */\\ncontract NAMarketV4 is Ownable, ReentrancyGuard, ERC1155Receiver {\\n  // bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n  bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\n  // Protect against overflow\\n  using SafeMath for uint256;\\n  // Add math utilities missing in solidity\\n  using Math for uint256;\\n  using Counters for Counters.Counter;\\n  // Number of auctions ever listed\\n  Counters.Counter public totalAuctionCount;\\n  // Number of auctions already sold\\n  Counters.Counter private closedAuctionCount;\\n\\n  enum TokenType { NONE, ERC721, ERC1155 }\\n  enum AuctionStatus { NONE, OPEN, CLOSE, SETTLED, CANCELED }\\n  enum Sort { ASC, DESC, NEW, END, HOT }\\n  enum BidType { BID, CANCELED }\\n  \\n  /* Constructor parameters */\\n  struct Auction {\\n      address contractAddress;\\n      uint256 tokenId;\\n      uint256 currentPrice;\\n      uint256 buyNowPrice;\\n      address seller;\\n      address highestBidder;\\n      address ERC20Token;\\n      string auctionTitle;\\n      uint256 expiryDate;\\n      uint256 auctionId;\\n      AuctionType auctionTypes;\\n  }\\n\\n  struct AuctionType {\\n      uint256 category;\\n      AuctionStatus status;\\n      TokenType tokenType;\\n      uint256 quantity;\\n  }\\n  //fee+price\\n  struct previousInfo {\\n    uint256 previousPrice;\\n  }\\n  //bid\\n  struct Bid {\\n        uint256 bidId;\\n        address bidder;\\n        uint256 price;\\n        BidType Type;\\n        uint256 timestamp;\\n  }\\n  struct SellerSale {\\n    address seller;\\n    uint256 price;\\n    uint256 timestamp;\\n  }\\n\\n  // minBidSize,minAuctionLiveness, feePercentage\\n  address public adminAddress; \\n\\n  // Minimum amount by which a new bid has to exceed previousBid 0.0001 = 1\\n  // uint256 public minBidSize = 1;\\n  /* Minimum duration in seconds for which the auction has to be live\\n   * timestamp 1h = 3600s\\n   * default  10m\\n  */\\n  uint256 public minAuctionLiveness = 10 * 60;\\n    \\n  // //transfer gas\\n  uint256 public gasSize = 100000;\\n  address public feeAddress;\\n  uint256 public feePercentage = 250; // default fee percentage : 2.5%\\n  uint256 public createAuctionFee = 1000000000000000;// default 0.001\\n\\n  uint256 public totalMarketVolume;\\n  uint256 public totalSales;\\n  //create auction on/off default = true\\n  bool public marketStatus = true;\\n\\n  // Save Users credit balances (to be used when they are outbid)\\n  mapping(address => uint256) public userPriceList;\\n  mapping(address => mapping(address => uint256)) public userERC20PriceList;\\n  mapping (address => SellerSale[]) private sellerSales;\\n  mapping(uint256 => previousInfo) private previousPriceList;\\n  mapping(uint256 => Auction) public auctions;\\n  mapping (uint256 => Bid[]) private bidList;\\n  address[] private uniqSellerList;// Unique seller address\\n  mapping(address => bool) public blackList;\\n  uint256[] private recommendAuctionIds;\\n  \\n  // EVENTS\\n  event AuctionCreated(\\n      uint256 auctionId,\\n      address contractAddress,\\n      uint256 tokenId,\\n      uint256 startingPrice,\\n      address seller,\\n      uint256 expiryDate\\n  );\\n  event NFTApproved(address nftContract);\\n  event AuctionCanceled(uint256 auctionId);\\n  event AuctionSettled(uint256 auctionId, bool sold);\\n  event BidPlaced(uint256 auctionId, uint256 bidPrice);\\n  event BidFailed(uint256 auctionId, uint256 bidPrice);\\n  event UserCredited(address creditAddress, uint256 amount);\\n  event priceBid(uint256 auctionId, uint256 bidPrice);\\n  event AdminAuctionCancel(uint256 auctionId, bool feeApproved);\\n  event CancelBid(uint256 auctionId);\\n  event RoyaltiesPaid(uint256 tokenId, uint value);\\n\\n\\n  // MODIFIERS\\n  modifier onlyAdmin() {\\n        require(msg.sender == adminAddress, \\\"admin: wut?\\\");\\n        _;\\n  }\\n  \\n  modifier checkBlackList() {\\n    if (blackList[msg.sender] == true) {\\n      require(false, \\\"Blacklist wallet address.\\\");\\n    }\\n    _;\\n  }\\n\\n  modifier openAuction(uint256 auctionId) {\\n      require(auctions[auctionId].auctionTypes.status == AuctionStatus.OPEN, \\\"Transaction only open Auctions\\\");\\n        _;\\n  }\\n\\n  modifier settleStatusCheck(uint256 auctionId) {\\n    AuctionStatus auctionStatus = auctions[auctionId].auctionTypes.status;\\n      require( auctionStatus != AuctionStatus.SETTLED || \\n        auctionStatus != AuctionStatus.CANCELED, \\\"Transaction only open or close Auctions\\\");\\n\\n      if (auctionStatus == AuctionStatus.OPEN) {\\n        require(auctions[auctionId].expiryDate < block.timestamp, \\\"Transaction only valid for expired Auctions\\\");\\n      }\\n    _;\\n  }\\n\\n  modifier nonExpiredAuction(uint256 auctionId) {\\n      require(auctions[auctionId].expiryDate >= block.timestamp, \\\"Transaction not valid for expired Auctions\\\");\\n        _;\\n  }\\n\\n  modifier onlyExpiredAuction(uint256 auctionId) {\\n      require(auctions[auctionId].expiryDate < block.timestamp, \\\"Transaction only valid for expired Auctions\\\");\\n        _;\\n  }\\n\\n  modifier noBids(uint256 auctionId) {\\n      require(auctions[auctionId].highestBidder == address(0), \\\"Auction has bids already\\\");\\n        _;\\n  }\\n\\n  modifier sellerOnly(uint256 auctionId) {\\n      require(msg.sender == auctions[auctionId].seller, \\\"Caller is not Seller\\\");\\n        _;\\n  }\\n\\n  modifier marketStatusCheck() {\\n      require(marketStatus, \\\"Market is closed\\\");\\n        _;\\n  }\\n\\n  /**     functions             */\\n  // Update market status\\n  function setMarkStatus(bool _marketStatus) public onlyOwner {\\n        marketStatus = _marketStatus;\\n  }\\n  \\n  // Update only owner \\n  function setFeeAddress(address _feeAddress) public onlyOwner {\\n        require(_feeAddress != address(0), \\\"Invalid Address\\\");\\n        feeAddress = _feeAddress;\\n  }\\n  // Update admin address \\n  function setAdmin(address _adminAddress) public onlyOwner {\\n        adminAddress = _adminAddress;\\n  }\\n  // gas update default min 21000\\n  function setGasSize(uint256 _gasSize) public onlyAdmin {\\n        gasSize = _gasSize;\\n  }\\n\\n  // update blackList \\n  //approved true add address \\n  function setBlackList(address blackAddress, bool approved) public onlyAdmin {\\n    blackList[blackAddress] = approved;\\n  }\\n  //Recommendation. Auction\\n  function setRecommendAuctionId(uint256 auctionId, bool approved) public onlyAdmin {\\n    if (approved) {\\n      recommendAuctionIds.push(auctionId);\\n    } else {\\n      for (uint256 i = 0; i < recommendAuctionIds.length ; i++) {\\n        if (recommendAuctionIds[i] == auctionId) {\\n          for (uint j = i; j < recommendAuctionIds.length - 1; j++) {\\n            recommendAuctionIds[j] = recommendAuctionIds[j + 1];\\n          }\\n          recommendAuctionIds.pop();\\n        }\\n      }\\n    }\\n  }\\n  // Update minBidSize \\n  // function setMinBidSize(uint256 _minBidSize) public onlyAdmin {\\n  //       minBidSize = _minBidSize;\\n  // }\\n  // Update minAuctionLiveness \\n  function setMinAuctionLiveness(uint256 _minAuctionLiveness) public onlyAdmin {\\n        minAuctionLiveness = _minAuctionLiveness;\\n  }\\n  // Update Fee percentages \\n  function setFeePercentage(uint256 _feePercentage) public onlyAdmin {\\n        require(_feePercentage <= 10000, \\\"Fee percentages exceed max\\\");\\n        feePercentage = _feePercentage;\\n  }\\n  // Update Fee percentages \\n  function setCreateAuctionFee(uint256 _createAuctionFee) public onlyAdmin {\\n        createAuctionFee = (_createAuctionFee.mul(10**18)).div(1000);\\n  }\\n\\n  // Calculate fee due for an auction based on its feePrice\\n  function calculateFee(uint256 _cuPrice) private view returns(uint256 fee){\\n      fee  = _cuPrice.mul(feePercentage).div(10000);\\n  }\\n\\n\\n  /*\\n  * AUCTION MANAGEMENT\\n  * Creates a new auction and transfers the token to the contract to be held in escrow until the end of the auction.\\n  * Requires this contract to be approved for the token to be auctioned.\\n  */\\n\\n  function createAuction(address _contractAddress, uint256 _tokenId, uint256 _startingPrice, string memory auctionTitle,\\n    uint256 _buyNowPrice, uint256 expiryDate, uint256 _category, TokenType _tokenType, address ERC20Token,\\n    uint256 _quantity\\n    ) public payable marketStatusCheck() checkBlackList() nonReentrant \\n    returns(uint256 auctionId){\\n      require(msg.value == createAuctionFee, \\\"The fee amount is different.\\\");\\n      require(expiryDate.sub(minAuctionLiveness) > block.timestamp, \\\"Expiry date is not far enough in the future\\\");\\n      require(_tokenType != TokenType.NONE, \\\"Invalid token type provided\\\");\\n      require(_buyNowPrice > _startingPrice, \\\"Invalid _buyNowPrice\\\");\\n\\n      uint256 quantity = 1;\\n      if(_tokenType == TokenType.ERC1155){\\n        quantity = _quantity;\\n      }\\n      // ERC20Token 0x0000000000000000000000000000000000000000\\n      // Generate Auction Id\\n      totalAuctionCount.increment();\\n      auctionId = totalAuctionCount.current();\\n      // Register new Auction\\n      auctions[auctionId] = Auction(_contractAddress, _tokenId, _startingPrice, _buyNowPrice, msg.sender,\\n       address(0), ERC20Token, auctionTitle, expiryDate, auctionId, \\n       AuctionType(_category,AuctionStatus.OPEN,  _tokenType, quantity));\\n      // Transfer Token\\n      transferToken(auctionId, msg.sender, address(this));\\n      emit AuctionCreated(auctionId, _contractAddress, _tokenId, _startingPrice, msg.sender, expiryDate);\\n  }\\n\\n    //  update auction\\n  function updateAuction(uint256 auctionId, string memory auctionTitle, uint256 expiryDate,\\n    uint256 category, TokenType tokenType, AuctionStatus status,\\n    uint256 quantity) public onlyAdmin  nonReentrant{\\n    Auction storage auction = auctions[auctionId];\\n    auction.auctionTitle = auctionTitle;\\n    auction.expiryDate = expiryDate;\\n    auction.auctionTypes.category = category;\\n    auction.auctionTypes.tokenType = tokenType;\\n    auction.auctionTypes.status = status;\\n    auction.auctionTypes.quantity = quantity;\\n  }\\n\\n  /**\\n   * Cancels an auction and returns the token to the original owner.\\n   * Requires the caller to be the seller who created the auction, the auction to be open and no bids having been placed on it.\\n   */\\n  function cancelAuction(uint256 auctionId) public openAuction(auctionId) noBids(auctionId) sellerOnly(auctionId) nonReentrant{\\n      auctions[auctionId].auctionTypes.status = AuctionStatus.CANCELED;\\n      closedAuctionCount.increment();\\n      transferToken(auctionId, address(this), msg.sender);\\n      emit AuctionCanceled(auctionId);\\n  }\\n\\n  /**\\n   * Settles an auction.\\n   * If at least one bid has been placed the token will be transfered to its new owner, the seller will be credited the sale price\\n   * and the contract owner will be credited the fee.\\n   * If no bid has been placed on the token it will just be transfered back to its original owner.\\n   */\\n  function settleAuction(uint256 auctionId) public settleStatusCheck(auctionId) nonReentrant{\\n      Auction storage auction = auctions[auctionId];\\n      auction.auctionTypes.status = AuctionStatus.SETTLED;\\n      closedAuctionCount.increment();\\n      \\n      bool sold = auction.highestBidder != address(0);\\n      if(sold){\\n        // If token was sold transfer it to its new owner and credit seller / contractOwner with price / fee\\n        transferToken(auctionId, address(this), auction.highestBidder);\\n        uint256 cuPrice = 0;\\n        // NFT royalties\\n\\t\\t    if (_checkRoyalties(auction.contractAddress)) {\\n            (address royaltiesReceiver, uint256 royaltiesAmount) = IERC2981(auction.contractAddress).royaltyInfo(auction.tokenId, auction.currentPrice);\\n            if (auction.seller != royaltiesReceiver) {\\n\\t\\t\\t        cuPrice = auction.currentPrice - royaltiesAmount;\\n            } else {\\n              cuPrice = auction.currentPrice;\\n            }\\n            if (royaltiesAmount > 0) {\\n                if (_isERC20Auction(auction.ERC20Token)) {\\n                    creditUserToken(royaltiesReceiver, auction.ERC20Token, royaltiesAmount);\\n                } else {\\n                    creditUser(royaltiesReceiver, royaltiesAmount);\\n                }\\n            } \\n            emit RoyaltiesPaid(auction.tokenId, royaltiesAmount);\\n        }\\n        if (_isERC20Auction(auction.ERC20Token)) {\\n          creditUserToken(auction.seller, auction.ERC20Token, cuPrice);\\n          creditUserToken(feeAddress, auction.ERC20Token, calculateFee(auction.currentPrice));\\n        } else {\\n          creditUser(auction.seller, cuPrice); \\n          creditUser(feeAddress, calculateFee(auction.currentPrice));\\n        }\\n\\n        saveSales(auction.seller, auction.currentPrice);\\n        totalSales = totalSales.add(auction.currentPrice);\\n      } else {\\n        // If token was not sold, return ownership to the seller\\n        transferToken(auctionId, address(this), auction.seller);\\n      }\\n      emit AuctionSettled(auctionId, sold);\\n  }\\n  //Save sales information\\n  function saveSales(address sellerAddress, uint256 price) private {\\n    if (uniqSellerList.length == 0) {\\n      uniqSellerList.push(sellerAddress);\\n    } else {\\n      bool chkSeller = false;\\n      for (uint256 i = 0; i < uniqSellerList.length; i++) {\\n        if (uniqSellerList[i] == sellerAddress) {\\n          chkSeller = true;\\n        }\\n      }\\n      if (!chkSeller) {\\n        uniqSellerList.push(sellerAddress);\\n      }\\n    }\\n    SellerSale memory sellerInfo = SellerSale(sellerAddress, price, block.timestamp);\\n    sellerSales[sellerAddress].push(sellerInfo);\\n  }\\n\\n    /**\\n\\t * Checks if a contract supports EIP-2981 for royalties.\\n\\t * View EIP-165 (https://eips.ethereum.org/EIPS/eip-165).\\n\\t */\\n\\tfunction _checkRoyalties(address _contract) internal view returns (bool) {\\n        (bool success) = IERC165(_contract).supportsInterface(_INTERFACE_ID_ERC2981);\\n\\t\\treturn success;\\n    }\\n\\n  /**\\n   * Credit user with given amount in ETH\\n   * Credits a user with a given amount that he can later withdraw from the contract.\\n   * Used to refund outbidden buyers and credit sellers / contract owner upon sucessfull sale.\\n   */\\n  function creditUser(address creditAddress, uint256 amount) private {\\n      userPriceList[creditAddress] = userPriceList[creditAddress].add(amount);\\n      emit UserCredited(creditAddress, amount);\\n  }\\n  function creditUserToken(address creditAddress, address tokenAddress, uint256 amount) private {\\n      userERC20PriceList[creditAddress][tokenAddress] = userERC20PriceList[creditAddress][tokenAddress].add(amount);\\n      emit UserCredited(creditAddress, amount);\\n  }\\n\\n  /**\\n   *  Withdraws all credit of the caller\\n   * Transfers all of his credit to the caller and sets the balance to 0\\n   * Fails if caller has no credit.\\n   */\\n  function withdrawCredit() public nonReentrant{\\n      uint256 creditBalance = userPriceList[msg.sender];\\n      require(creditBalance > 0, \\\"User has no credits to withdraw\\\");\\n      userPriceList[msg.sender] = 0;\\n\\n      (bool success, ) = msg.sender.call{value: creditBalance}(\\\"\\\");\\n      require(success);\\n  }\\n\\n  function withdrawToken(address tokenAddress) public nonReentrant{\\n    uint256 creditBalance = userERC20PriceList[msg.sender][tokenAddress];\\n    require(creditBalance > 0, \\\"User has no credits to withdraw\\\");\\n    userERC20PriceList[msg.sender][tokenAddress] = 0;\\n\\n    IERC20(tokenAddress).transfer(msg.sender, creditBalance);\\n  }\\n\\n  /**\\n   * Places a bid on the selected auction at the selected price\\n   * Requires the provided bid price to exceed the current highest bid by at least the minBidSize.\\n   * Also requires the caller to transfer the exact amount of the chosen bidPrice plus fee, to be held in escrow by the contract\\n   * until the auction is settled or a higher bid is placed.\\n   */\\n  function placeBid(uint256 auctionId, uint256 bidPrice) public payable openAuction(auctionId) nonExpiredAuction(auctionId) nonReentrant{\\n      Auction storage auction = auctions[auctionId];\\n      // require(bidPrice >= auction.currentPrice.add((minBidSize.mul(10**18)/10000)), \\\"Bid has to exceed current price by the minBidSize or more\\\");\\n      require(bidPrice > auction.currentPrice, \\\"It should be higher than the current bid amount\\\");\\n\\n      if (_isERC20Auction(auction.ERC20Token)) {\\n        require(msg.value == 0, \\\"msg.value must be zero.\\\");\\n        _payout(auction.ERC20Token, msg.sender, bidPrice);\\n      } else {\\n        require(msg.value == bidPrice.add(calculateFee(bidPrice)), \\\"The payment amount and the bid amount are different\\\");\\n      }\\n\\n      emit priceBid(auctionId, bidPrice);\\n\\n      uint256 creditAmount;\\n      // If this is not the first bid, credit the previous highest bidder\\n      address previousBidder = auction.highestBidder;\\n    \\n      if (auction.buyNowPrice <= bidPrice) {\\n        if (auction.auctionTypes.tokenType == TokenType.ERC721) {\\n          auction.auctionTypes.status = AuctionStatus.CLOSE;\\n        } else if (auction.auctionTypes.tokenType == TokenType.ERC1155){\\n          if (auction.auctionTypes.quantity == 0) {\\n            auction.auctionTypes.status = AuctionStatus.CLOSE;\\n          } else {\\n            auction.auctionTypes.quantity--;\\n          }\\n        }\\n      }\\n\\n      //bid list \\n      uint256 newBidId = bidList[auctionId].length + 1;\\n      Bid memory newBid = Bid(newBidId, msg.sender, bidPrice, BidType.BID, block.timestamp);\\n      bidList[auctionId].push(newBid);\\n\\n      //bid refund\\n      if(previousBidder != address(0)){\\n        creditAmount = previousPriceList[auctionId].previousPrice;\\n        if (_isERC20Auction(auction.ERC20Token)) {\\n          creditUserToken(previousBidder, auction.ERC20Token, creditAmount);\\n        } else {\\n          creditUser(previousBidder, creditAmount);\\n        }\\n      }\\n    \\n      previousPriceList[auctionId].previousPrice = bidPrice.add(calculateFee(bidPrice));\\n\\n      auction.highestBidder = msg.sender;\\n      auction.currentPrice = bidPrice;\\n\\n  }\\n\\n  function _payout(\\n        address ERC20Token,\\n        address bidder,\\n        uint256 bidPrice\\n    ) internal {\\n        uint256 newBidPrice = bidPrice.add(calculateFee(bidPrice));\\n            bool sent = IERC20(ERC20Token).transferFrom(bidder, address(this), newBidPrice);\\n            require(sent, \\\"transfer fail\\\");\\n  }\\n\\n    function _isERC20Auction(address _auctionERC20Token)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return _auctionERC20Token != address(0);\\n    }\\n\\n  /**\\n   * Transfer the token(s) belonging to a given auction.\\n   * Supports both ERC721 and ERC1155 tokens\\n   */\\n  function transferToken(uint256 auctionId, address from, address to) private {\\n      require(to != address(0), \\\"Cannot transfer token to zero address\\\");\\n\\n      Auction storage auction = auctions[auctionId];\\n      require(auction.auctionTypes.status != AuctionStatus.NONE, \\\"Cannot transfer token of non existent auction\\\");\\n\\n      TokenType tokenType = auction.auctionTypes.tokenType;\\n      uint256 tokenId = auction.tokenId;\\n      address contractAddress = auction.contractAddress;\\n\\n      if(tokenType == TokenType.ERC721){\\n        IERC721(contractAddress).transferFrom(from, to, tokenId);\\n      }\\n      else if(tokenType == TokenType.ERC1155){\\n        uint256 quantity = auction.auctionTypes.quantity;\\n        require(quantity > 0, \\\"Cannot transfer 0 quantity of ERC1155 tokens\\\");\\n        IERC1155(contractAddress).safeTransferFrom(from, to, tokenId, quantity, \\\"\\\");\\n      }\\n      else{\\n        revert(\\\"Invalid token type for transfer\\\");\\n      }\\n  }\\n  //cancel auction\\n  function adminCancelAuction(uint256 auctionId, bool feeApproved) public openAuction(auctionId) onlyAdmin  nonReentrant{\\n    Auction storage auction = auctions[auctionId];\\n    address previousBidder = auction.highestBidder;\\n    uint256 creditAmount = 0;\\n    //bid refund\\n    if(previousBidder != address(0)){\\n      if (feeApproved) {\\n        creditAmount = auction.currentPrice; //only price, Cancellation fee.\\n      } else {\\n        creditAmount = previousPriceList[auctionId].previousPrice; //fee+ price\\n      }\\n      if (_isERC20Auction(auction.ERC20Token)) {\\n          creditUserToken(previousBidder, auction.ERC20Token, creditAmount);\\n      } else {\\n        creditUser(previousBidder, creditAmount);\\n      }\\n    }\\n    auction.auctionTypes.status = AuctionStatus.CANCELED;\\n  \\n    emit AdminAuctionCancel(auctionId, feeApproved);\\n  }\\n  //cancel bid\\n  function cancelBid(uint256 auctionId) public openAuction(auctionId) nonExpiredAuction(auctionId) nonReentrant {\\n    Auction storage auction = auctions[auctionId];\\n    require(msg.sender == auction.highestBidder, \\\"Invalid Request\\\");\\n    address previousBidder = auction.highestBidder;\\n    uint256 creditAmount = 0;\\n    //bid refund\\n    if(previousBidder != address(0)){\\n      creditAmount = auction.currentPrice; //only price, Cancellation fee.\\n      if (_isERC20Auction(auction.ERC20Token)) {\\n          creditUserToken(previousBidder, auction.ERC20Token, creditAmount);\\n      } else {\\n        creditUser(previousBidder, creditAmount);\\n      }\\n    }\\n    uint256 newBidId = bidList[auctionId].length + 1;\\n    Bid memory newBid = Bid(newBidId, msg.sender, auction.currentPrice, BidType.BID, block.timestamp);\\n    bidList[auctionId].push(newBid);\\n    \\n    auction.highestBidder = address(0);\\n    previousPriceList[auctionId].previousPrice = 0;\\n  \\n    emit CancelBid(auctionId);\\n  }\\n\\n\\n  //data func auction list \\n  function getOpenAuctions(uint256 category, Sort sort, string memory keyword, \\n  uint256 offset, uint256 limit) public view returns \\n  (Auction[] memory, uint256, uint256) {\\n        uint256 totalLen = totalAuctionCount.current();\\n        Auction[] memory values = new Auction[] (totalLen);\\n        uint256 resultLen = 0;\\n        bytes memory checkString = bytes(keyword);\\n\\n        //auctionId is no zero.\\n        //auction open, type count\\n        for (uint256 i = 1; i <= totalLen; i++) {\\n          if(auctions[i].auctionTypes.status == AuctionStatus.OPEN){\\n            values[resultLen] = auctions[i];\\n            resultLen++;\\n          }  \\n        }\\n        resultLen = 0;\\n        if (checkString.length > 0) {\\n          values = sfilter(values, category, keyword);\\n        } else if (category != 0) {\\n          values = cfilter(values, category);\\n        }\\n\\n        for (uint256 i = 0; i < values.length; i++) {\\n          if(values[i].seller != address(0)){\\n            resultLen++;\\n          }  \\n        }\\n\\n        Auction[] memory result = new Auction[](resultLen);\\n        uint256 rId = 0;\\n        for (uint256 i = 0; i < values.length; i++) {\\n          if(values[i].seller != address(0)){\\n            result[rId] = values[i];\\n            rId++;\\n          }  \\n        }\\n        //sort\\n        result = sortMap(result, resultLen, sort);\\n\\n\\n        if(limit == 0) {\\n            limit = 1;\\n        }\\n        \\n        if (limit > resultLen - offset) {\\n            limit = 0 > resultLen - offset ? 0 : resultLen - offset;\\n        }\\n       \\n        Auction[] memory newAuctions = new Auction[] (result.length > limit ? limit: result.length);\\n\\n        if (result.length > limit) {\\n          for (uint256 i = 0; i < limit; i++) {\\n            newAuctions[i] = result[offset+i];\\n          }\\n          return (newAuctions, offset + limit, resultLen);\\n        } else {\\n          return (result, offset + limit, resultLen);\\n        }\\n        \\n  }\\n\\n  //seller open auction list\\n  function getSellerAuctions(address sellerAddress, Sort sort, uint256 offset, uint256 limit) public view returns \\n  (Auction[] memory, uint256, uint256) {\\n        uint256 totalLen = totalAuctionCount.current();\\n        Auction[] memory values = new Auction[] (totalLen);\\n        uint256 resultLen = 0;\\n\\n        //auctionId is no zero.\\n        //auction open, type count\\n        for (uint256 i = 1; i <= totalLen; i++) {\\n          if(auctions[i].auctionTypes.status == AuctionStatus.OPEN\\n            && auctions[i].seller == sellerAddress){\\n            values[resultLen] = auctions[i];\\n            resultLen++;\\n          }  \\n        }\\n\\n        //sort\\n        values = sortMap(values, resultLen, sort);\\n\\n        if(limit == 0) {\\n            limit = 1;\\n        }\\n        \\n        if (limit > resultLen - offset) {\\n            limit = 0 > resultLen - offset ? 0 : resultLen - offset;\\n        }\\n       \\n        Auction[] memory newAuctions = new Auction[] (resultLen > limit ? limit: resultLen);\\n\\n        if (resultLen > limit) {\\n          for (uint256 i = 0; i < limit; i++) {\\n            newAuctions[i] = values[offset+i];\\n          }\\n          return (newAuctions, offset + limit, resultLen);\\n        } else {\\n          return (values, offset + limit, resultLen);\\n        }\\n        \\n  }\\n \\n  //Recommendation Auction\\n  function getRecommendationAuctions() public view returns (Auction[] memory, uint256) {\\n    uint256 totalLen = recommendAuctionIds.length;\\n    Auction[] memory values = new Auction[] (totalLen);\\n    uint256 resultLen = 0;\\n\\n    //auctionId is no zero.\\n    //auction open, type count\\n    for (uint256 i = 0; i < totalLen; i++) {\\n      if(auctions[recommendAuctionIds[i]].auctionTypes.status == AuctionStatus.OPEN) {\\n        values[resultLen] = auctions[i];\\n        resultLen++;\\n      }  \\n    }\\n    return (values, resultLen);\\n  }\\n  //bids\\n  function getBids(uint256 auctionId) public view returns(Bid[] memory){\\n      return bidList[auctionId];\\n  }\\n\\n  function getUserAuctions(address seller) public view returns(Auction[] memory) {\\n    uint256 resultCount = 0;\\n\\n    for(uint256 i = 1; i <= totalAuctionCount.current(); i++) {\\n      if (auctions[i].seller == seller) {\\n        resultCount++;\\n      }\\n    }\\n    Auction[] memory values = new Auction[] (resultCount);\\n    uint256 rInt = 0;\\n    for(uint256 i = 1; i <= totalAuctionCount.current(); i++) {\\n      if (auctions[i].seller == seller) {\\n        values[rInt] = auctions[i];\\n        rInt++;\\n      }\\n    }\\n    return values;\\n  }\\n  function getUserBidAuctions(address seller) public view returns(Auction[] memory) {\\n    uint256 resultCount = 0;\\n\\n    for(uint256 i = 1; i <= totalAuctionCount.current(); i++) {\\n      if (auctions[i].highestBidder == seller) {\\n        resultCount++;\\n      }\\n    }\\n    Auction[] memory values = new Auction[] (resultCount);\\n    uint256 rInt = 0;\\n    for(uint256 i = 1; i <= totalAuctionCount.current(); i++) {\\n      if (auctions[i].highestBidder == seller) {\\n        values[rInt] = auctions[i];\\n        rInt++;\\n      }\\n    }\\n    return values;\\n  }\\n  //Filter based on the timestamp.\\n  function getSellerSalesList(uint256 timestamp) public view returns(SellerSale[] memory) {\\n    SellerSale[] memory topSellerList = new SellerSale[](uniqSellerList.length);\\n    SellerSale memory cuSellerSales;\\n    for(uint256 i = 0; i < uniqSellerList.length; i++) {\\n      cuSellerSales.seller = uniqSellerList[i];\\n      cuSellerSales.price = 0;\\n      cuSellerSales.timestamp = timestamp;\\n      for(uint256 j = 0; j < sellerSales[uniqSellerList[i]].length; j++) {\\n        if (timestamp <= sellerSales[uniqSellerList[i]][j].timestamp) {\\n          cuSellerSales.price = cuSellerSales.price.add(sellerSales[uniqSellerList[i]][j].price);\\n        }\\n      }\\n      topSellerList[i] = cuSellerSales;\\n    }\\n    return topSellerList;\\n  }\\n  //string substring\\n  function substring(string memory str, uint256 startIndex, uint256 endIndex) private pure returns (string memory) {\\n        bytes memory strBytes = bytes(str);\\n        bytes memory result = new bytes(endIndex-startIndex);\\n        for(uint256 i = startIndex; i < endIndex; i++) {\\n            result[i-startIndex] = strBytes[i];\\n        }\\n        return string(result);\\n  }\\n\\n  /* filter */\\n  function sfilter(Auction[] memory values, uint256 category, string memory keyword) \\n    private pure returns (Auction[] memory) {\\n    Auction[] memory sValues = new Auction[](values.length);\\n\\n    bytes memory kBytes = bytes(keyword);\\n    for (uint256 i = 0; i < values.length; i ++) {\\n      bytes memory tBytes = bytes(values[i].auctionTitle);\\n      for (uint256 j = 0; j < tBytes.length; j ++) {\\n\\n          if(keccak256(abi.encodePacked(substring(values[i].auctionTitle, j, \\n          tBytes.length < j+kBytes.length ? tBytes.length : j+kBytes.length))) \\n            == keccak256(abi.encodePacked(keyword))) {\\n              sValues[i] = values[i];\\n              break;\\n          }\\n      }\\n    }\\n    sValues = cfilter(sValues, category);\\n    return sValues;\\n\\n  }\\n\\n  function cfilter(Auction[] memory values, uint256 category) private pure returns (Auction[] memory) {\\n    Auction[] memory cValues = new Auction[](values.length);\\n    if (category != 0) {\\n      for (uint256 i = 0; i < values.length; i++) {\\n        if(values[i].auctionTypes.category == category){\\n          cValues[i] = values[i];\\n        } \\n      }\\n      return cValues;\\n    } else {\\n      return values;\\n    }\\n  }\\n\\n  /*  sort  */\\n  function sortMap(Auction[] memory arr, uint256 limit, Sort sort) private view returns (Auction[] memory) {\\n    //sort\\n    Auction memory temp;\\n    for(uint256 i = 0; i < limit; i++) {\\n        for(uint256 j = i+1; j < limit ;j++) {\\n          if (sort == Sort.NEW) {\\n            if(arr[i].expiryDate > arr[j].expiryDate) {\\n                temp = arr[i];\\n                arr[i] = arr[j];\\n                arr[j] = temp;\\n            }\\n          } else if (sort == Sort.END) {\\n            if(arr[i].expiryDate < arr[j].expiryDate) {\\n                temp = arr[i];\\n                arr[i] = arr[j];\\n                arr[j] = temp;\\n            }\\n          } else if (sort == Sort.ASC) {\\n            if(arr[i].currentPrice > arr[j].currentPrice) {\\n                temp = arr[i];\\n                arr[i] = arr[j];\\n                arr[j] = temp;\\n            }\\n          } else if (sort == Sort.HOT) {\\n            if( bidList[arr[i].auctionId].length < bidList[arr[j].auctionId].length) {\\n                temp = arr[i];\\n                arr[i] = arr[j];\\n                arr[j] = temp;\\n            }\\n          } else {\\n            if(arr[i].currentPrice < arr[j].currentPrice) {\\n                temp = arr[i];\\n                arr[i] = arr[j];\\n                arr[j] = temp;\\n            }\\n          } \\n        }\\n    }\\n    return arr;\\n  }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"feeApproved\",\"type\":\"bool\"}],\"name\":\"AdminAuctionCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"AuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"}],\"name\":\"AuctionSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"}],\"name\":\"BidFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"}],\"name\":\"BidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"CancelBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC1155BatchReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC1155Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"NFTApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RoyaltiesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creditAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserCredited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"}],\"name\":\"priceBid\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"feeApproved\",\"type\":\"bool\"}],\"name\":\"adminCancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.AuctionType\",\"name\":\"auctionTypes\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"_tokenType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createAuctionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getBids\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bidId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.BidType\",\"name\":\"Type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.Bid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.Sort\",\"name\":\"sort\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"keyword\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getOpenAuctions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.AuctionType\",\"name\":\"auctionTypes\",\"type\":\"tuple\"}],\"internalType\":\"struct NAMarketV4.Auction[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRecommendationAuctions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.AuctionType\",\"name\":\"auctionTypes\",\"type\":\"tuple\"}],\"internalType\":\"struct NAMarketV4.Auction[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellerAddress\",\"type\":\"address\"},{\"internalType\":\"enum NAMarketV4.Sort\",\"name\":\"sort\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getSellerAuctions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.AuctionType\",\"name\":\"auctionTypes\",\"type\":\"tuple\"}],\"internalType\":\"struct NAMarketV4.Auction[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSellerSalesList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.SellerSale[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"getUserAuctions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.AuctionType\",\"name\":\"auctionTypes\",\"type\":\"tuple\"}],\"internalType\":\"struct NAMarketV4.Auction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"getUserBidAuctions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct NAMarketV4.AuctionType\",\"name\":\"auctionTypes\",\"type\":\"tuple\"}],\"internalType\":\"struct NAMarketV4.Auction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAuctionLiveness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blackAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_createAuctionFee\",\"type\":\"uint256\"}],\"name\":\"setCreateAuctionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasSize\",\"type\":\"uint256\"}],\"name\":\"setGasSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_marketStatus\",\"type\":\"bool\"}],\"name\":\"setMarkStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAuctionLiveness\",\"type\":\"uint256\"}],\"name\":\"setMinAuctionLiveness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setRecommendAuctionId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAuctionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMarketVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"auctionTitle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"enum NAMarketV4.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum NAMarketV4.AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"updateAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userERC20PriceList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPriceList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NAMarketV4","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}