{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/price-feeds/derivatives/IAggregatedDerivativePriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IDerivativePriceFeed.sol\\\";\\n\\n/// @title IDerivativePriceFeed Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IAggregatedDerivativePriceFeed is IDerivativePriceFeed {\\n    function getPriceFeedForDerivative(address) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/price-feeds/derivatives/IDerivativePriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IDerivativePriceFeed Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Simple interface for derivative price source oracle implementations\\ninterface IDerivativePriceFeed {\\n    function calcUnderlyingValues(address, uint256)\\n        external\\n        returns (address[] memory, uint256[] memory);\\n\\n    function isSupportedAsset(address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/price-feeds/primitives/IPrimitivePriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IPrimitivePriceFeed Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for primitive price feeds\\ninterface IPrimitivePriceFeed {\\n    function calcCanonicalValue(\\n        address,\\n        uint256,\\n        address\\n    ) external view returns (uint256, bool);\\n\\n    function calcLiveValue(\\n        address,\\n        uint256,\\n        address\\n    ) external view returns (uint256, bool);\\n\\n    function isSupportedAsset(address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/value-interpreter/IValueInterpreter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IValueInterpreter interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for ValueInterpreter\\ninterface IValueInterpreter {\\n    function calcCanonicalAssetValue(\\n        address,\\n        uint256,\\n        address\\n    ) external returns (uint256, bool);\\n\\n    function calcCanonicalAssetsTotalValue(\\n        address[] calldata,\\n        uint256[] calldata,\\n        address\\n    ) external returns (uint256, bool);\\n\\n    function calcLiveAssetValue(\\n        address,\\n        uint256,\\n        address\\n    ) external returns (uint256, bool);\\n\\n    function calcLiveAssetsTotalValue(\\n        address[] calldata,\\n        uint256[] calldata,\\n        address\\n    ) external returns (uint256, bool);\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/value-interpreter/ValueInterpreter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../price-feeds/derivatives/IAggregatedDerivativePriceFeed.sol\\\";\\nimport \\\"../price-feeds/derivatives/IDerivativePriceFeed.sol\\\";\\nimport \\\"../price-feeds/primitives/IPrimitivePriceFeed.sol\\\";\\nimport \\\"./IValueInterpreter.sol\\\";\\n\\n/// @title ValueInterpreter Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interprets price feeds to provide covert value between asset pairs\\n/// @dev This contract contains several \\\"live\\\" value calculations, which for this release are simply\\n/// aliases to their \\\"canonical\\\" value counterparts since the only primitive price feed (Chainlink)\\n/// is immutable in this contract and only has one type of value. Including the \\\"live\\\" versions of\\n/// functions only serves as a placeholder for infrastructural components and plugins (e.g., policies)\\n/// to explicitly define the types of values that they should (and will) be using in a future release.\\ncontract ValueInterpreter is IValueInterpreter {\\n    using SafeMath for uint256;\\n\\n    address private immutable AGGREGATED_DERIVATIVE_PRICE_FEED;\\n    address private immutable PRIMITIVE_PRICE_FEED;\\n\\n    constructor(address _primitivePriceFeed, address _aggregatedDerivativePriceFeed) public {\\n        AGGREGATED_DERIVATIVE_PRICE_FEED = _aggregatedDerivativePriceFeed;\\n        PRIMITIVE_PRICE_FEED = _primitivePriceFeed;\\n    }\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice An alias of calcCanonicalAssetsTotalValue\\n    function calcLiveAssetsTotalValue(\\n        address[] calldata _baseAssets,\\n        uint256[] calldata _amounts,\\n        address _quoteAsset\\n    ) external override returns (uint256 value_, bool isValid_) {\\n        return calcCanonicalAssetsTotalValue(_baseAssets, _amounts, _quoteAsset);\\n    }\\n\\n    /// @notice An alias of calcCanonicalAssetValue\\n    function calcLiveAssetValue(\\n        address _baseAsset,\\n        uint256 _amount,\\n        address _quoteAsset\\n    ) external override returns (uint256 value_, bool isValid_) {\\n        return calcCanonicalAssetValue(_baseAsset, _amount, _quoteAsset);\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Calculates the total value of given amounts of assets in a single quote asset\\n    /// @param _baseAssets The assets to convert\\n    /// @param _amounts The amounts of the _baseAssets to convert\\n    /// @param _quoteAsset The asset to which to convert\\n    /// @return value_ The sum value of _baseAssets, denominated in the _quoteAsset\\n    /// @return isValid_ True if the price feed rates used to derive value are all valid\\n    /// @dev Does not alter protocol state,\\n    /// but not a view because calls to price feeds can potentially update third party state\\n    function calcCanonicalAssetsTotalValue(\\n        address[] memory _baseAssets,\\n        uint256[] memory _amounts,\\n        address _quoteAsset\\n    ) public override returns (uint256 value_, bool isValid_) {\\n        require(\\n            _baseAssets.length == _amounts.length,\\n            \\\"calcCanonicalAssetsTotalValue: Arrays unequal lengths\\\"\\n        );\\n        require(\\n            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_quoteAsset),\\n            \\\"calcCanonicalAssetsTotalValue: Unsupported _quoteAsset\\\"\\n        );\\n\\n        isValid_ = true;\\n        for (uint256 i; i < _baseAssets.length; i++) {\\n            (uint256 assetValue, bool assetValueIsValid) = __calcAssetValue(\\n                _baseAssets[i],\\n                _amounts[i],\\n                _quoteAsset\\n            );\\n            value_ = value_.add(assetValue);\\n            if (!assetValueIsValid) {\\n                isValid_ = false;\\n            }\\n        }\\n\\n        return (value_, isValid_);\\n    }\\n\\n    /// @notice Calculates the value of a given amount of one asset in terms of another asset\\n    /// @param _baseAsset The asset from which to convert\\n    /// @param _amount The amount of the _baseAsset to convert\\n    /// @param _quoteAsset The asset to which to convert\\n    /// @return value_ The equivalent quantity in the _quoteAsset\\n    /// @return isValid_ True if the price feed rates used to derive value are all valid\\n    /// @dev Does not alter protocol state,\\n    /// but not a view because calls to price feeds can potentially update third party state\\n    function calcCanonicalAssetValue(\\n        address _baseAsset,\\n        uint256 _amount,\\n        address _quoteAsset\\n    ) public override returns (uint256 value_, bool isValid_) {\\n        if (_baseAsset == _quoteAsset || _amount == 0) {\\n            return (_amount, true);\\n        }\\n\\n        require(\\n            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_quoteAsset),\\n            \\\"calcCanonicalAssetValue: Unsupported _quoteAsset\\\"\\n        );\\n\\n        return __calcAssetValue(_baseAsset, _amount, _quoteAsset);\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n\\n    /// @dev Helper to differentially calculate an asset value\\n    /// based on if it is a primitive or derivative asset.\\n    function __calcAssetValue(\\n        address _baseAsset,\\n        uint256 _amount,\\n        address _quoteAsset\\n    ) private returns (uint256 value_, bool isValid_) {\\n        if (_baseAsset == _quoteAsset || _amount == 0) {\\n            return (_amount, true);\\n        }\\n\\n        // Handle case that asset is a primitive\\n        if (IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_baseAsset)) {\\n            return\\n                IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).calcCanonicalValue(\\n                    _baseAsset,\\n                    _amount,\\n                    _quoteAsset\\n                );\\n        }\\n\\n        // Handle case that asset is a derivative\\n        address derivativePriceFeed = IAggregatedDerivativePriceFeed(\\n            AGGREGATED_DERIVATIVE_PRICE_FEED\\n        )\\n            .getPriceFeedForDerivative(_baseAsset);\\n        if (derivativePriceFeed != address(0)) {\\n            return __calcDerivativeValue(derivativePriceFeed, _baseAsset, _amount, _quoteAsset);\\n        }\\n\\n        revert(\\\"__calcAssetValue: Unsupported _baseAsset\\\");\\n    }\\n\\n    /// @dev Helper to calculate the value of a derivative in an arbitrary asset.\\n    /// Handles multiple underlying assets (e.g., Uniswap and Balancer pool tokens).\\n    /// Handles underlying assets that are also derivatives (e.g., a cDAI-ETH LP)\\n    function __calcDerivativeValue(\\n        address _derivativePriceFeed,\\n        address _derivative,\\n        uint256 _amount,\\n        address _quoteAsset\\n    ) private returns (uint256 value_, bool isValid_) {\\n        (address[] memory underlyings, uint256[] memory underlyingAmounts) = IDerivativePriceFeed(\\n            _derivativePriceFeed\\n        )\\n            .calcUnderlyingValues(_derivative, _amount);\\n\\n        require(underlyings.length > 0, \\\"__calcDerivativeValue: No underlyings\\\");\\n        require(\\n            underlyings.length == underlyingAmounts.length,\\n            \\\"__calcDerivativeValue: Arrays unequal lengths\\\"\\n        );\\n\\n        // Let validity be negated if any of the underlying value calculations are invalid\\n        isValid_ = true;\\n        for (uint256 i = 0; i < underlyings.length; i++) {\\n            (uint256 underlyingValue, bool underlyingValueIsValid) = __calcAssetValue(\\n                underlyings[i],\\n                underlyingAmounts[i],\\n                _quoteAsset\\n            );\\n\\n            if (!underlyingValueIsValid) {\\n                isValid_ = false;\\n            }\\n            value_ = value_.add(underlyingValue);\\n        }\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `AGGREGATED_DERIVATIVE_PRICE_FEED` variable\\n    /// @return aggregatedDerivativePriceFeed_ The `AGGREGATED_DERIVATIVE_PRICE_FEED` variable value\\n    function getAggregatedDerivativePriceFeed()\\n        external\\n        view\\n        returns (address aggregatedDerivativePriceFeed_)\\n    {\\n        return AGGREGATED_DERIVATIVE_PRICE_FEED;\\n    }\\n\\n    /// @notice Gets the `PRIMITIVE_PRICE_FEED` variable\\n    /// @return primitivePriceFeed_ The `PRIMITIVE_PRICE_FEED` variable value\\n    function getPrimitivePriceFeed() external view returns (address primitivePriceFeed_) {\\n        return PRIMITIVE_PRICE_FEED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/off-chain/AssetValueCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../infrastructure/value-interpreter/ValueInterpreter.sol\\\";\\n\\n/// @title AssetValueCalculator Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A peripheral contract for calculating asset values\\n/// @dev These are convenience functions intended for off-chain consumption,\\n/// some of which involve potentially expensive state transitions\\ncontract AssetValueCalculator {\\n    address private immutable VALUE_INTERPRETER;\\n\\n    constructor(address _valueInterpreter) public {\\n        VALUE_INTERPRETER = _valueInterpreter;\\n    }\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Calculates the value of a given amount of one asset in terms of another asset\\n    /// @param _baseAsset The asset from which to convert\\n    /// @param _amount The amount of the _baseAsset to convert\\n    /// @param _quoteAsset The asset to which to convert\\n    /// @return timestamp_ The current block timestamp\\n    /// @return value_ The equivalent quantity in the _quoteAsset\\n    function calcCanonicalAssetValue(\\n        address _baseAsset,\\n        uint256 _amount,\\n        address _quoteAsset\\n    )\\n        external\\n        returns (\\n            uint256 timestamp_,\\n            uint256 value_,\\n            bool valueIsValid_\\n        )\\n    {\\n        timestamp_ = block.timestamp;\\n\\n        try\\n            ValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\\n                _baseAsset,\\n                _amount,\\n                _quoteAsset\\n            )\\n        returns (uint256 value, bool isValid) {\\n            if (isValid) {\\n                value_ = value;\\n                valueIsValid_ = true;\\n            }\\n        } catch {}\\n\\n        return (timestamp_, value_, valueIsValid_);\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `VALUE_INTERPRETER` variable\\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\\n    function getValueInterpreter() public view returns (address valueInterpreter_) {\\n        return VALUE_INTERPRETER;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_valueInterpreter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_quoteAsset\",\"type\":\"address\"}],\"name\":\"calcCanonicalAssetValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"valueIsValid_\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValueInterpreter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"valueInterpreter_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AssetValueCalculator","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000010a5624840ac07287f756777df1dec34d2c2d654","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}