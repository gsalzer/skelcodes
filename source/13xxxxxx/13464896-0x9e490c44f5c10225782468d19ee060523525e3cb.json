{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NFTMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"./math/SafeMath.sol\\\";\\r\\nimport \\\"./token/IERC20.sol\\\";\\r\\nimport \\\"./access/Ownable.sol\\\";\\r\\nimport \\\"./token/IERC1155.sol\\\";\\r\\nimport \\\"./NFTBase.sol\\\";\\r\\nimport \\\"./ERC20TokenList.sol\\\";\\r\\n\\r\\n/**\\r\\n *\\r\\n * @dev Implementation of Market [지정가판매(fixed_price), 경매(auction)]\\r\\n *\\r\\n */\\r\\n\\r\\n// interface for ERC1155\\r\\ninterface NFTBaseLike {\\r\\n    function getCreator(uint256 id) external view returns (address);\\r\\n    function getRoyaltyRatio(uint256 id) external view returns (uint256);\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n}\\r\\n\\r\\n// interface for payment ERC20 Token List\\r\\ninterface ERC20TokenListLike {\\r\\n    function contains(address addr) external view returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\ncontract NFTMarket is Ownable\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    struct SaleData {\\r\\n        address seller;            \\r\\n        bool isAuction;      // auction true, fixed_price false         \\r\\n        uint256 nftId;       // ERC1155 Token Id               \\r\\n        uint256 volume;      // number of nft,  volume >= 2 -> isAuction=false, remnant value : number decrease after buying\\r\\n        address erc20;       // payment erc20 token \\r\\n        uint256 price;       // auction : starting price, fixed_price : sellig unit price \\r\\n        uint256 bid;         // bidding price     \\r\\n        address buyer;       // fixed_price : 구매자 auction : bidder, 최종구매자 \\r\\n        uint256 start;       // auction start time [unix epoch time]    unit : sec\\r\\n        uint256 end;         // auction expiry time  [unix epoch time]  unit : sec     \\r\\n        bool isCanceled;     // no buyer or no bidder 만 가능 \\r\\n        bool isSettled;      // 정산되었는지 여부\\r\\n    }\\r\\n    \\r\\n    mapping (uint256 => SaleData) private _sales;        //mapping from uint256 to sales data \\r\\n    uint256 private _currentSalesId = 0;                //현재 salesId \\r\\n     \\r\\n    uint256 private  _feeRatio = 10;                    // 수수료율 100% = 100\\r\\n    address private  _feeTo;                            // 거래수수료 수취주소 \\r\\n    \\r\\n    uint256 private _interval = 15 minutes;             // additionl bidding time  [seconds]\\r\\n    //uint256 private _duration = 1 days;                 // 1 days total auction length  [seconds]\\r\\n    \\r\\n    NFTBaseLike _nftBase;                               // ERC1155\\r\\n    ERC20TokenListLike _erc20s;                         // payment ERC20 Token List\\r\\n    \\r\\n\\r\\n    //event\\r\\n    event Open(uint256 id,address indexed seller,bool isAuction,uint256 nftId,uint256 volume,address indexed erc20,uint256 price,uint256 start, uint256 end);\\r\\n    event Buy(uint256 id,address indexed buyer,uint256 amt);\\r\\n    event Clear(uint256 id);\\r\\n    event Cancel(uint256 id);\\r\\n\\r\\n    event Bid(uint256 id,address indexed guy, uint256 amount,uint256 end);\\r\\n    //event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n    //event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /* Keccak256 \\r\\n        Open(uint256,address,bool,uint256,uint256,address,uint256)  : 0x0e884c2228e2e8cc975ba6a7d1c29574c38bda6a723957411fd523ad0c03d04e\\r\\n        Buy(uint256,address,uint256)                                : 0x3b599f6217e39be59216b60e543ce0d4c7d534fe64dd9d962334924e7819894e\\r\\n        Clear(uint256)                                              : 0x6e4c858d91fb3af82ec04ba219c6b12542326a62accb6ffac4cf87ba00ba95a3\\r\\n        Cancel(uint256)                                             : 0x8bf30e7ff26833413be5f69e1d373744864d600b664204b4a2f9844a8eedb9ed\\r\\n        Bid(uint256,address,uint256,uint256)                        : 0x3138d8d517460c959fb333d4e8d87ea984f1cf15d6742c02e2955dd27a622b70\\r\\n        TransferSingle(address,address,address,uint256,uint256)     : 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62\\r\\n        Transfer(address,address,uint256)                           : 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\\r\\n    */\\r\\n\\r\\n    /**\\r\\n     * @dev feeTo address, ERC1155 Contract, ERC20 Payment Token List 설정 \\r\\n     */\\r\\n    constructor(NFTBaseLike nftBase_,ERC20TokenListLike erc20s_) {\\r\\n        _feeTo = address(this);\\r\\n        _nftBase = NFTBaseLike(nftBase_);\\r\\n        _erc20s = ERC20TokenListLike(erc20s_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev feeRatio 설정 \\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - 100% 이하\\r\\n     */\\r\\n    function setFeeRatio(uint256 feeRatio_) external onlyOwner {\\r\\n        require(feeRatio_ <= 100,\\\"NFTMarket/FeeRation_>_100\\\");\\r\\n       _feeRatio = feeRatio_;\\r\\n    }\\r\\n\\r\\n    function getFeeRatio() external view returns(uint256) {\\r\\n        return _feeRatio;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev feeTo Address 설정 \\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - not zero address\\r\\n     */\\r\\n\\r\\n    function setFeeTo(address feeTo_) external onlyOwner {\\r\\n        require(feeTo_ != address(0),\\\"NFTMarket/FeeTo_address_is_0\\\");\\r\\n       _feeTo = feeTo_;\\r\\n    }\\r\\n\\r\\n    function getFeeTo() external view returns(address) {\\r\\n        return _feeTo;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev auction 연장 시간 설정 [minites]\\r\\n     *\\r\\n     * Requirements:\\r\\n     * \\r\\n     */    \\r\\n    function setInterval(uint256 interval_) external onlyOwner {\\r\\n        _interval = interval_;\\r\\n    }\\r\\n\\r\\n    function getInterval() external view returns(uint256) {\\r\\n        return _interval;\\r\\n    }\\r\\n    /**\\r\\n     * @dev auction 시간 설정 [minites]\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - not zero \\r\\n     */    \\r\\n    /*     \\r\\n    function setDuration(uint256 duration_) external onlyOwner   {\\r\\n        require(duration_ > 0,\\\"NFTMarket/duration_is_0\\\");\\r\\n        _duration = duration_;\\r\\n    }    \\r\\n    \\r\\n    function getDuration() external view returns(uint256) {\\r\\n        return _duration;\\r\\n    }\\r\\n    */\\r\\n\\r\\n    /**\\r\\n     * @dev open : 판매시작, NFT escrow , SaleData 등록\\r\\n     *   args  \\r\\n     *     isAuction : true - auction, false - fixed_price \\r\\n     *     nftId : ERC1155 mint token Id \\r\\n     *     volume : 수량 \\r\\n     *     erc20 : payment ERC20 Token\\r\\n     *     price : auction : starting price, fixed_price : sellig unit price \\r\\n     *   \\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     *   수량(volume) > 1 인 경우 fixed_price 만 가능 \\r\\n     *   수량 > 0, 가격 > 0\\r\\n     *   결제 ERC20 contract : ERC20TokenList 중의 하나 \\r\\n     *\\r\\n     * Event : Open, TransferSingle(NFTBase)\\r\\n     * \\r\\n     * Return  salesId\\r\\n     */ \\t \\r\\n    function open(bool isAuction,uint256 nftId,uint256 volume,address erc20, uint256 price,uint256 start, uint256 end) public returns (uint256 id) {\\r\\n        if(volume > 1 && isAuction) {\\r\\n            revert(\\\"NFTMarket/if_volume_>_1,isAuction_should_be_false\\\");\\r\\n        }\\r\\n        require(volume > 0,\\\"NFTMarket/open_0_volume\\\");\\r\\n        require(price > 0, \\\"NFTMarket/open_0_price\\\");\\r\\n        require(_erc20s.contains(erc20),\\\"NFTMarket/open_erc20_not_registered\\\");\\r\\n        if(isAuction) {\\r\\n            require(end > start,\\\"NFTMarket/open_should_end_>_start\\\");\\r\\n        }\\r\\n                \\r\\n        _nftBase.safeTransferFrom(_msgSender(),address(this),nftId,volume,\\\"\\\");    \\r\\n\\r\\n        id = ++_currentSalesId;\\r\\n        _sales[id].seller = _msgSender();\\r\\n        _sales[id].isAuction = isAuction;\\r\\n        _sales[id].nftId = nftId;\\r\\n        _sales[id].volume = volume;\\r\\n        _sales[id].erc20 = erc20;\\r\\n        _sales[id].price = price;\\r\\n        _sales[id].isCanceled = false;\\r\\n        _sales[id].isSettled = false;\\r\\n        \\r\\n        if(isAuction) {\\r\\n            _sales[id].bid = price;\\r\\n            _sales[id].start = start;\\r\\n            _sales[id].end = end;\\r\\n        }\\r\\n        emit Open(id,_msgSender(),isAuction,nftId,volume,erc20,price,start,end);            \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev buy : 바로구매, 정산 \\r\\n     *   args  \\r\\n     *     id     : saleId\\r\\n     *     amt    : 구매수량 \\r\\n\\r\\n     * Requirements:\\r\\n     *\\r\\n     *   auction이 아니고 (fixed_price 이어야)\\r\\n     *   buyer가 확정되지 않아야 하고 (settle 되어지 않아야)\\r\\n     *   취소상태가 아니어야 함 \\r\\n     * \\r\\n     * Event : Buy,TransferSingle(NFTBase),Transfer(ERC20)      \\r\\n     * \\r\\n     */ \\t \\r\\n\\r\\n    function buy(uint256 id,uint256 amt) public {\\r\\n        require(id <= _currentSalesId,\\\"NFTMarket/sale_is_not_open\\\");\\r\\n        require(!_sales[id].isAuction, \\\"NFTMarket/sale_is_auction\\\");\\r\\n        require(!_sales[id].isCanceled,\\\"NFTMarket/sale_already_cancelled\\\");    \\r\\n        require(!_sales[id].isSettled,\\\"NFTMarket/sale_already_settled\\\");   \\r\\n        require(amt > 0,\\\"NFTMarket/buy_must_>_0\\\");\\r\\n        require(amt <= _sales[id].volume,\\\"NFTMarket/buy_should_<=_sale_volume\\\");\\r\\n        \\r\\n        _sales[id].buyer = _msgSender();\\r\\n\\r\\n        settle(id,amt);\\r\\n        emit Buy(id,_msgSender(),amt);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev bid : 경매 참여, ERC20 Token escrow, 경매시간 연장  \\r\\n     *   args : \\r\\n     *      id : salesId\\r\\n     *      amount : bidding 금액  \\r\\n     *      bidder = msg.sender \\r\\n     * \\r\\n     * Requirements:\\r\\n     * \\r\\n     *   auction이고\\r\\n     *   취소상태가 아니고\\r\\n     *   경매 종료시간이 지나지 않아야 함\\r\\n     *   bidding 금액이 기존 금액(첫 bidding인경우 seller가 제시한 금액)보다 커야함     \\r\\n     * \\r\\n     * Event : Bid,Transfer(ERC20)       \\r\\n     */ \\r\\n\\r\\n    function bid(uint256 id,uint256 amount) public {\\r\\n        require(id <= _currentSalesId,\\\"NFTMarket/sale_is_not_open\\\");\\r\\n        require(_sales[id].isAuction, \\\"NFTMarket/sale_should_be_auction\\\");\\r\\n        require(!_sales[id].isCanceled,\\\"NFTMarket/sale_already_cancelled\\\");    \\r\\n        require(!_sales[id].isSettled,\\\"NFTMarket/sale_already_settled\\\");         \\r\\n        require(block.timestamp >= _sales[id].start, \\\"NFTMarket/auction_doesn't_start\\\");     \\r\\n        require(_sales[id].end >= block.timestamp, \\\"NFTMarket/auction_finished\\\");\\r\\n        require(amount > _sales[id].bid, \\\"NFTMarket/bid_should_be_higher\\\");\\r\\n\\r\\n        IERC20 erc20Token = IERC20(_sales[id].erc20);\\r\\n        erc20Token.transferFrom(_msgSender(),address(this),amount);\\r\\n\\r\\n        // not first bidding\\r\\n        if(_sales[id].buyer != address(0)) {\\r\\n            erc20Token.transfer(_sales[id].buyer,_sales[id].bid);     \\r\\n        }\\r\\n        \\r\\n        _sales[id].buyer = _msgSender();\\r\\n        _sales[id].bid = amount;        \\r\\n        \\r\\n        // auction end time increase\\r\\n        if(block.timestamp < _sales[id].end && _sales[id].end < block.timestamp + _interval) \\r\\n            _sales[id].end = _sales[id].end.add(_interval);\\r\\n        \\r\\n        emit Bid(id,_msgSender(),amount,_sales[id].end);        \\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev clear : 경매 정리, 정산  \\r\\n     *   args : \\r\\n     *      id : salesId\\r\\n     *      amount : bidding 금액  \\r\\n     *      bidder = msg.sender \\r\\n     * \\r\\n     * Requirements:\\r\\n     * \\r\\n     *      id가 존재해야 하고     \\r\\n     *      auction이고 \\r\\n     *      취소상태가 아니고\\r\\n     *      아직 정산되지 않아야 하고 \\r\\n     *      경매 종료시간이 지나야 하고 \\r\\n     *      caller는 sales[id].seller 이어야 함     \\r\\n     * \\r\\n     * Event : Clear,TransferSingle(NFTBase),Transfer(ERC20)       \\r\\n     */ \\r\\n   \\r\\n    function clear(uint256 id) public {\\r\\n        require(id <= _currentSalesId,\\\"NFTMarket/sale_is_not_open\\\");\\r\\n        require(_sales[id].isAuction, \\\"NFTMarket/sale_should_be_auction\\\");          \\r\\n        require(!_sales[id].isCanceled,\\\"NFTMarket/sale_already_cancelled\\\");    \\r\\n        require(_sales[id].buyer != address(0), \\\"NFTMarket/auction_not_bidded\\\");\\r\\n        require(!_sales[id].isSettled,\\\"NFTMarket/auction_already_settled\\\");                  \\r\\n        require(_sales[id].end < block.timestamp, \\\"NFTMarket/auction_ongoing\\\");\\r\\n        require(_msgSender() == _sales[id].seller, \\\"NFTMarket/only_seller_can_clear\\\");\\r\\n\\r\\n        settle(id,1);   \\r\\n        emit Clear(id);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev cancel : 세일 취소, escrow 반환  \\r\\n     *   args : \\r\\n     *      id : salesId\\r\\n     *      amount : bidding 금액  \\r\\n     *      bidder = msg.sender \\r\\n     *    \\r\\n     * Requirements:     \\r\\n     *      id가 존재해야 하고\\r\\n     *      취소상태가 아니고\\r\\n     *      이미 정산되지 않아야 하고 \\r\\n     *      경매의 경우 Bidder가 없어야 \\r\\n     *      caller는 sales[id].seller 이어야 함 \\r\\n     *\\r\\n     * Event : Cancel,TransferSingle(NFTBase)       \\r\\n     */ \\r\\n    function cancel(uint256 id) public {\\r\\n        require(id <= _currentSalesId,\\\"NFTMarket/sale_is_not_open\\\");\\r\\n        require(!_sales[id].isCanceled,\\\"NFTMarket/sale_already_cancelled\\\");\\r\\n        require(!_sales[id].isSettled,\\\"NFTMarket/sale_already_settled\\\");\\r\\n        if (_sales[id].isAuction)\\r\\n            require(_sales[id].buyer == address(0), \\\"NFTMarket/auction_not_cancellable\\\");\\r\\n        require(_msgSender() == _sales[id].seller, \\\"NFTMarket/only_seller_can_cancel\\\");\\r\\n        _sales[id].isCanceled = true;\\r\\n        _nftBase.safeTransferFrom(address(this),_sales[id].seller,_sales[id].nftId,_sales[id].volume,\\\"\\\");\\r\\n        emit Cancel(id);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev settle : 정산   \\r\\n     *      1. 수수료 정산     : this ->  feeTo\\r\\n\\t *      2. royalty 정산    : this ->  creator\\r\\n\\t *      3. nft 오너쉽 정리 : this -> buyer     \\r\\n     *\\r\\n     *   args : \\r\\n     *      id  : salesId\\r\\n     *      amt : number of nft in fixed-price buy or auction \\r\\n     * \\r\\n     * Requirements:\\r\\n     *\\r\\n     * - feeRatio + royaltyRatio < 100\\r\\n     *\\r\\n     * Event : TransferSingle(NFTBase), Transfer(ERC20)\\r\\n     */     \\r\\n\\r\\n    function settle(uint256 id,uint256 amt) private {\\r\\n        SaleData memory sd = _sales[id];\\r\\n  \\r\\n        uint256 amount = sd.isAuction ? sd.bid : sd.price*amt;\\r\\n        uint256 fee = amount.mul(_feeRatio).div(100);\\r\\n\\r\\n        address creator = _nftBase.getCreator(sd.nftId);\\r\\n        uint256 royaltyRatio = _nftBase.getRoyaltyRatio(sd.nftId);\\r\\n\\r\\n        require(_feeRatio.add(royaltyRatio) <= 100, \\\"NFTMarket/fee_+_royalty_>_100%\\\");\\r\\n        uint256 royalty = amount.mul(royaltyRatio).div(100);    \\r\\n\\r\\n        IERC20 erc20Token = IERC20(sd.erc20);\\r\\n        if(sd.isAuction) {\\r\\n            erc20Token.transfer(_feeTo,fee);\\r\\n            erc20Token.transfer(creator,royalty);\\r\\n            erc20Token.transfer(sd.seller,amount.sub(fee).sub(royalty));\\r\\n        } else {\\r\\n            erc20Token.transferFrom(_msgSender(),_feeTo,fee);\\r\\n            erc20Token.transferFrom(_msgSender(),creator,royalty);\\r\\n            erc20Token.transferFrom(_msgSender(),sd.seller,amount.sub(fee).sub(royalty));\\r\\n        }\\r\\n        _nftBase.safeTransferFrom(address(this),sd.buyer,sd.nftId,amt,\\\"\\\");\\r\\n\\r\\n        _sales[id].volume -= amt;\\r\\n        _sales[id].isSettled = (_sales[id].volume == 0);\\r\\n    }\\r\\n\\r\\n    function getAuctionEnd(uint256 id) external view returns (uint256) \\r\\n    {\\r\\n        require(_sales[id].isAuction,\\\"NFTMarket/sale_should_be_auction\\\");\\r\\n        return _sales[id].end;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev getSaleData : SaleData Return\\r\\n     */\\r\\n    function getSaleData(uint256 id) external view \\r\\n        returns (\\r\\n            address         \\r\\n            ,bool\\r\\n            ,uint256\\r\\n            ,uint256\\r\\n            ,address\\r\\n            ,uint256\\r\\n            ,uint256\\r\\n            ,address\\r\\n            ,uint256\\r\\n            ,uint256\\r\\n            ,bool\\r\\n            ,bool \\r\\n        ) {        \\r\\n            SaleData memory sd = _sales[id];\\r\\n            return (\\r\\n                sd.seller            \\r\\n                ,sd.isAuction\\r\\n                ,sd.nftId\\r\\n                ,sd.volume\\r\\n                ,sd.erc20\\r\\n                ,sd.price\\r\\n                ,sd.bid\\r\\n                ,sd.buyer\\r\\n                ,sd.start\\r\\n                ,sd.end\\r\\n                ,sd.isCanceled\\r\\n                ,sd.isSettled\\r\\n            );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        uint256 c = a + b;\\r\\n        if (c < a) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b > a) return (false, 0);\\r\\n        return (true, a - b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) return (true, 0);\\r\\n        uint256 c = a * b;\\r\\n        if (c / a != b) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a / b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a % b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/NFTBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"./token/ERC1155.sol\\\";\\r\\nimport \\\"./access/AccessControl.sol\\\";\\r\\nimport \\\"./access/Ownable.sol\\\";\\r\\nimport \\\"./utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n *\\r\\n * @dev Implementation of ERC1155 + NFT Token Data \\r\\n *\\r\\n * AccessControl \\r\\n *   DEFAULT_ADMIN_ROLE = 0\\r\\n *   새로운 role 생성 될때마다 adminRole = 0 이된다. \\r\\n *   따라서 자연스럽게 adminRole = DEFAULT_ADMIN_ROLE 이 된다.\\r\\n */\\r\\n\\r\\n\\r\\ncontract NFTBase is ERC1155, Ownable, AccessControl\\r\\n{\\r\\n \\r\\n    string public name;\\r\\n    string public symbol;\\r\\n\\r\\n    bytes32 private constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");        //Role Id \\r\\n\\r\\n    struct TokenData {\\r\\n        uint256 supply;                            // NFT 공급량 \\r\\n        string uri;                             // NFT url : json 화일 \\r\\n        address creator;                        // 저작권자\\r\\n        uint256 royaltyRatio;                      // 로열티 100% = 100\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => TokenData) private _tokens;     // mapping from uint256 to nft token data \\r\\n    uint256 private _currentTokenId = 0;            // 현재 tokenId\\r\\n    \\r\\n    bool private _isPrivate = true;                 // private Mint 설정 - 오직 MINTER_ROLE 보유자만 가능 \\r\\n    uint256 private _royaltyMinimum = 0;               // 로열티 최소값\\r\\n    uint256 private _royaltyMaximum = 90;              // 로열티 최대값\\r\\n    \\r\\n    //event\\r\\n    event Mint(uint256 id,uint256 supply, string uri, address indexed creator, uint256 royaltyRatio);\\r\\n    /* keccak256 \\r\\n        Mint(uint256,uint256,string,address,uint256)                : 0x21881410541b694573587a7b14f2da71c815c0d7e24797822fe90249daaf884e\\r\\n        TransferSingle(address,address,address,uint256,uint256)     : 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62\\r\\n        RoleGranted(bytes32,address,address)                        : 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d\\r\\n        RoleRevoked(bytes32,address,address)                        : 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b\\r\\n    */\\r\\n\\r\\n\\r\\n    constructor (string memory _name, string memory _symbol) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        _setupRole(DEFAULT_ADMIN_ROLE,_msgSender());        //MINTER_ROLE Amin 설정 \\r\\n        addWhiteList(_msgSender());\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev setPrivateMarket : Private Market set \\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - 100% 이하\\r\\n     */\\r\\n\\r\\n    function setPrivateMarket(bool isPrivate_) external onlyOwner  {\\r\\n        _isPrivate = isPrivate_;\\r\\n    }   \\r\\n    \\r\\n    function getPrivateMarket() external view returns(bool) {\\r\\n        return _isPrivate;\\r\\n    }\\r\\n    /**\\r\\n     * @dev setRoyaltyRange : Royalty Range set \\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     *    Royalty min <= Royalty max\\r\\n     *    0<= Royalty max <= 100\\r\\n     */    \\r\\n    function setRoyaltyRange(uint256 min,uint256 max) external {\\r\\n        require(max >= min,\\\"NFTBase/should_be_(max >= min)\\\");\\r\\n        require(max <= 100,\\\"NFTBase/should_be_(max <= 100)\\\"); \\r\\n        _royaltyMinimum = min;\\r\\n        _royaltyMaximum = max;\\r\\n    }\\r\\n    \\r\\n    function getRoyaltyRange() external view returns(uint256,uint256) {\\r\\n        return (_royaltyMinimum,_royaltyMaximum);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev addWhiteList : whitelist account add\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     *    MINTER_ROLE을 보유하고 있지 않은 address\\r\\n     *    msg_sender가 DEFAULT_ADMIN_ROLE 보유해야 \\r\\n     * \\r\\n     * Event : RoleGranted\\r\\n     */\\r\\n\\r\\n    function addWhiteList(address minter) public  {\\r\\n        require(!hasRole(MINTER_ROLE,minter),\\\"NFTBase/minter_has_role_already\\\");\\r\\n        grantRole(MINTER_ROLE,minter);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev removeWhiteList : whitelist account remove\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     *    MINTER_ROLE을 보유하고 있는 address\\r\\n     *    DEFAULT_ADMIN_ROLE DEFAULT_ADMIN_ROLE 보유해야 \\r\\n     *\\r\\n     * Event : RoleRevoked\\r\\n     *\\r\\n     */\\r\\n    function removeWhiteList(address minter)  external {\\r\\n        require(hasRole(MINTER_ROLE,minter),\\\"NFTBase/minter_has_not_role\\\");\\r\\n        revokeRole(MINTER_ROLE,minter);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev mint :   NFT Token 발행\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     *    supply > 0, uri != \\\"\\\", creator != address(0)\\r\\n     *    royalty : royalty Range안에 \\r\\n     *    Private Market의 경우 msg.seder는 MINTER_ROLE을 보유해야 \\r\\n     *\\r\\n     * Event : TransferSingle\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * Only incaseof private market, check if caller has a minter role \\r\\n     */\\r\\n    function mint(uint256 supply, string memory uri, address creator, uint256 royaltyRatio) public returns(uint256 id) {\\r\\n        require(supply > 0,\\\"NFTBase/supply_is_0\\\");\\r\\n        require(!compareStrings(uri,\\\"\\\"),\\\"NFTBase/uri_is_empty\\\");\\r\\n        require(creator != address(0),\\\"NFTBase/createor_is_0_address\\\");\\r\\n        require(_royaltyMinimum <= royaltyRatio && royaltyRatio <= _royaltyMaximum,\\\"NFTBase/royalty_out_of_range\\\");\\r\\n        \\r\\n        if(_isPrivate)\\r\\n            require(hasRole(MINTER_ROLE,_msgSender()),\\\"NFTBase/caller_has_not_minter_role\\\");\\r\\n        id = ++_currentTokenId;    \\r\\n        \\r\\n        _tokens[id].supply  = supply;\\r\\n        _tokens[id].uri     = uri;\\r\\n        _tokens[id].creator = creator;\\r\\n        _tokens[id].royaltyRatio = royaltyRatio;\\r\\n        \\r\\n        ERC1155._mint(_msgSender(),id,supply,\\\"\\\");    // TransferSingle Event  \\r\\n\\r\\n        emit Mint(id,supply,uri,creator,royaltyRatio);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev uri : NFT Token uri 조회 MI\\r\\n     */    \\r\\n    function uri(uint256 id) external view returns (string memory) {\\r\\n        return  _tokens[id].uri;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev getCreator : NFT Creator조회 \\r\\n     */        \\r\\n    function getCreator(uint256 id) external view returns (address) {\\r\\n        return _tokens[id].creator;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev getRoyaltyRatio : NFT RoyaltyRatio 조회 \\r\\n     */         \\r\\n    function getRoyaltyRatio(uint256 id) external view returns (uint256) {\\r\\n        return _tokens[id].royaltyRatio;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev compareStrings : string을 암호화해서 비교 \\r\\n     *   Solidiy string 비교함수 제공하지 않음 \\r\\n     */\\r\\n    function compareStrings(string memory a, string memory b) private pure returns (bool) {\\r\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\r\\n    }    \\r\\n\\r\\n    /**\\r\\n     * @dev getTokenData : TokenData Return\\r\\n     */\\r\\n    function getTokenData(uint256 id) external view \\r\\n        returns(\\r\\n            uint256\\r\\n            ,string memory\\r\\n            ,address\\r\\n            ,uint256) \\r\\n        {\\r\\n            TokenData memory td = _tokens[id];\\r\\n            return (\\r\\n                td.supply\\r\\n                ,td.uri\\r\\n                ,td.creator\\r\\n                ,td.royaltyRatio\\r\\n            );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/ERC20TokenList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"./utils/Address.sol\\\";\\r\\nimport \\\"./access/Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n *\\r\\n * @dev 결제용 ERC20 Token List \\r\\n *\\r\\n */\\r\\n\\r\\ncontract ERC20TokenList is Ownable {\\r\\n    using Address for address;\\r\\n\\r\\n    address[] private _addresses;\\r\\n    mapping (address => uint256) private _indexes;   // 1-based  1,2,3.....\\r\\n    \\r\\n    /**\\r\\n     * @dev contains : 기존 등록 여부 조회\\r\\n    */\\r\\n    function contains(address addr) public view returns (bool) {\\r\\n        return _indexes[addr] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev addToken : ERC20 Token 추가 \\r\\n     * \\r\\n     * Requirements:\\r\\n     *\\r\\n     *   address Not 0 address \\r\\n     *   중복여부 확인 \\r\\n     *   address가 contract 인지 확인 \\r\\n     *     \\r\\n\\t */\\r\\n    \\r\\n    function addToken(address addr) public onlyOwner {\\r\\n\\r\\n        //console.log(\\\"address = %s\\\",addr);\\r\\n        //console.log(\\\"contains = %s\\\",contains(addr));\\r\\n\\r\\n        require(addr != address(0),\\\"TokenList/address_is_0\\\");\\r\\n        require(!contains(addr),\\\"TokenList/address_already_exist\\\");\\r\\n        require(addr.isContract(),\\\"TokenList/address_is_not_contract\\\");\\r\\n\\r\\n        _addresses.push(addr);\\r\\n        _indexes[addr] = _addresses.length;\\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev removeToken : ERC20 Token 삭제 \\r\\n     * \\r\\n     * Requirements:\\r\\n     *\\r\\n     *   기존 존재여부 확인 \\r\\n     *   address가 contract 인지 확인 \\r\\n     *     \\r\\n\\t */\\r\\n\\r\\n    function removeToken(address addr) public  onlyOwner {\\r\\n        require(contains(addr),\\\"TokenList/address_is_not_exist\\\");\\r\\n        uint256 idx = _indexes[addr];\\r\\n        uint256 toDeleteIndex = idx - 1;\\r\\n        uint256 lastIndex = _addresses.length - 1;\\r\\n        \\r\\n        address lastAddress = _addresses[lastIndex];\\r\\n        \\r\\n        _addresses[toDeleteIndex] = lastAddress;\\r\\n        _indexes[lastAddress] = toDeleteIndex + 1;\\r\\n        \\r\\n        _addresses.pop();\\r\\n        delete _indexes[addr];\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev getAddressList : ERC20 Token List return \\r\\n     * \\r\\n\\t */    \\r\\n    function getAddressList() public view returns (address[] memory) {\\r\\n        return _addresses;\\r\\n    }\\r\\n    \\r\\n}\"\r\n    },\r\n    \"contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.0 <0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC1155.sol\\\";\\r\\nimport \\\"../introspection/ERC165.sol\\\";\\r\\nimport \\\"../math/SafeMath.sol\\\";\\r\\nimport \\\"../utils/Address.sol\\\";\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n *\\r\\n * @dev Implementation of the basic standard multi-token.\\r\\n * See https://eips.ethereum.org/EIPS/eip-1155\\r\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ncontract ERC1155 is Context, ERC165, IERC1155 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    // Mapping from token ID to account balances\\r\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\r\\n\\r\\n    // Mapping from account to operator approvals\\r\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    /*\\r\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\r\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\r\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\r\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\r\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\r\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\r\\n     *\\r\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\r\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev \\r\\n     */\\r\\n    constructor () {\\r\\n\\r\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\r\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOf}.\\r\\n     *\\r\\n     * Rbaequirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\r\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\r\\n        return _balances[id][account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOfBatch}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(\\r\\n        address[] memory accounts,\\r\\n        uint256[] memory ids\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\r\\n\\r\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\r\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\r\\n        }\\r\\n\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\r\\n\\r\\n        _operatorApprovals[_msgSender()][operator] = approved;\\r\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[account][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\r\\n        );\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n        _balances[id][to] = _balances[id][to].add(amount);\\r\\n\\r\\n        emit TransferSingle(operator, from, to, id, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\r\\n        );\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; ++i) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            _balances[id][from] = _balances[id][from].sub(\\r\\n                amount,\\r\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\r\\n            );\\r\\n            _balances[id][to] = _balances[id][to].add(amount);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, to, ids, amounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\r\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _balances[id][account] = _balances[id][account].add(amount);\\r\\n        emit TransferSingle(operator, address(0), account, id, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        for (uint i = 0; i < ids.length; i++) {\\r\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\r\\n\\r\\n    }\\r\\n\\r\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../utils/EnumerableSet.sol\\\";\\r\\nimport \\\"../utils/Address.sol\\\";\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module that allows children to implement role-based access\\r\\n * control mechanisms.\\r\\n *\\r\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\r\\n * in the external API and be unique. The best way to achieve this is by\\r\\n * using `public constant` hash digests:\\r\\n *\\r\\n * ```\\r\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\r\\n * ```\\r\\n *\\r\\n * Roles can be used to represent a set of permissions. To restrict access to a\\r\\n * function call, use {hasRole}:\\r\\n *\\r\\n * ```\\r\\n * function foo() public {\\r\\n *     require(hasRole(MY_ROLE, msg.sender));\\r\\n *     ...\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\r\\n * {revokeRole} functions. Each role has an associated admin role, and only\\r\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\r\\n *\\r\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\r\\n * that only accounts with this role will be able to grant or revoke other\\r\\n * roles. More complex role relationships can be created by using\\r\\n * {_setRoleAdmin}.\\r\\n *\\r\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\r\\n * grant and revoke this role. Extra precautions should be taken to secure\\r\\n * accounts that have been granted it.\\r\\n */\\r\\nabstract contract AccessControl is Context {\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    using Address for address;\\r\\n\\r\\n    struct RoleData {\\r\\n        EnumerableSet.AddressSet members;\\r\\n        bytes32 adminRole;\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 => RoleData) private _roles;\\r\\n\\r\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\r\\n        return _roles[role].members.contains(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of accounts that have `role`. Can be used\\r\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\r\\n     */\\r\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\r\\n        return _roles[role].members.length();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\r\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\r\\n     *\\r\\n     * Role bearers are not sorted in any particular way, and their ordering may\\r\\n     * change at any point.\\r\\n     *\\r\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\r\\n     * you perform all queries on the same block. See the following\\r\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\r\\n     * for more information.\\r\\n     */\\r\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\r\\n        return _roles[role].members.at(index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\r\\n        return _roles[role].adminRole;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) public virtual {\\r\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\r\\n\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) public virtual {\\r\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\r\\n\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) public virtual {\\r\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\r\\n\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\r\\n     * checks on the calling account.\\r\\n     *\\r\\n     * [WARNING]\\r\\n     * ====\\r\\n     * This function should only be called from the constructor when setting\\r\\n     * up the initial roles for the system.\\r\\n     *\\r\\n     * Using this function in any other way is effectively circumventing the admin\\r\\n     * system imposed by {AccessControl}.\\r\\n     * ====\\r\\n     */\\r\\n    function _setupRole(bytes32 role, address account) internal virtual {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\r\\n     *\\r\\n     * Emits a {RoleAdminChanged} event.\\r\\n     */\\r\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\r\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\r\\n        _roles[role].adminRole = adminRole;\\r\\n    }\\r\\n\\r\\n    function _grantRole(bytes32 role, address account) private {\\r\\n        if (_roles[role].members.add(account)) {\\r\\n            emit RoleGranted(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revokeRole(bytes32 role, address account) private {\\r\\n        if (_roles[role].members.remove(account)) {\\r\\n            emit RoleRevoked(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts may inherit from this and call {_registerInterface} to declare\\r\\n * their support of an interface.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /*\\r\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\r\\n\\r\\n    /**\\r\\n     * @dev Mapping of interface ids to whether or not it's supported.\\r\\n     */\\r\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\r\\n\\r\\n    constructor () {\\r\\n        // Derived contracts need only register support for their own interfaces,\\r\\n        // we register support for ERC165 itself here\\r\\n        _registerInterface(_INTERFACE_ID_ERC165);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     *\\r\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return _supportedInterfaces[interfaceId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Registers the contract as an implementer of the interface defined by\\r\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\r\\n     * registering its interface id is not required.\\r\\n     *\\r\\n     * See {IERC165-supportsInterface}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\r\\n     */\\r\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\r\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\r\\n        _supportedInterfaces[interfaceId] = true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Library for managing\\r\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\r\\n * types.\\r\\n *\\r\\n * Sets have the following properties:\\r\\n *\\r\\n * - Elements are added, removed, and checked for existence in constant time\\r\\n * (O(1)).\\r\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\r\\n *\\r\\n * ```\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\r\\n *\\r\\n *     // Declare a set state variable\\r\\n *     EnumerableSet.AddressSet private mySet;\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\r\\n * and `uint256` (`UintSet`) are supported.\\r\\n */\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping (bytes32 => uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\r\\n\\r\\n            bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n            // Move the last value to the index where the value to delete is\\r\\n            set._values[toDeleteIndex] = lastvalue;\\r\\n            // Update the index for the moved value\\r\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract NFTBaseLike\",\"name\":\"nftBase_\",\"type\":\"address\"},{\"internalType\":\"contract ERC20TokenListLike\",\"name\":\"erc20s_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Clear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAuction\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"Open\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"clear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAuctionEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getSaleData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAuction\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"open\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeRatio_\",\"type\":\"uint256\"}],\"name\":\"setFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeTo_\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval_\",\"type\":\"uint256\"}],\"name\":\"setInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NFTMarket","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000029d5897b0311aea8708ed9e42a2546cff943d3370000000000000000000000004eec355d7a2bf62bf7925ba92aa1973a0531219b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}