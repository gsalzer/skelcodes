{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Fund.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\n\\r\\nimport \\\"./libs/TransferHelper.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IFundManager.sol\\\";\\r\\nimport \\\"./interfaces/IFund.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\n// import \\\"./console.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function getPair(address token0, address token1)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    function getReserves() external view returns (uint256, uint256);\\r\\n}\\r\\n\\r\\ncontract Fund is IFund, ERC20 {\\r\\n    event StatuChanged(uint256 status);\\r\\n    event Invested(address indexed investor, uint256 amount);\\r\\n    event Liquidated(address indexed liquidator, uint256 netValue);\\r\\n    event Redeemed(address indexed redeemer, uint256 dfAmount);\\r\\n\\r\\n    uint256 public constant UintMax = 2**256 - 1;\\r\\n\\r\\n    uint128 public minSize; // raise size\\r\\n\\r\\n    uint128 public finalNetValue;\\r\\n\\r\\n    uint32 public startDate;\\r\\n\\r\\n    uint32 public endDate;\\r\\n\\r\\n    /**  base 100, percentage */\\r\\n    uint16 public hurdleRate;\\r\\n\\r\\n    uint16 public estimatedROE;\\r\\n\\r\\n    uint16 public performanceFee;\\r\\n\\r\\n    uint16 public maxDrawdown;\\r\\n    // percentage end\\r\\n\\r\\n    Status private fundStatus;\\r\\n\\r\\n    bool locker;\\r\\n\\r\\n    bool initialized;\\r\\n\\r\\n    address public manager;\\r\\n\\r\\n    address public controller; // FundManager address\\r\\n\\r\\n    address[] public override getToken; // tradeable getToken\\r\\n\\r\\n    uint256 public reservePoolDF; // amount of raise token of manager to create Pool\\r\\n\\r\\n    modifier lock() {\\r\\n        require(!locker, \\\"reentrant call\\\");\\r\\n        locker = true;\\r\\n        _;\\r\\n        locker = false;\\r\\n    }\\r\\n\\r\\n    modifier onlyManager() {\\r\\n        require(msg.sender == manager, \\\"only manager\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyController() {\\r\\n        require(msg.sender == controller, \\\"only controller\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier nonContract() {\\r\\n        uint256 size;\\r\\n        address account = msg.sender;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        require(size == 0, \\\"CONTRACT_INVOKE\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier ready() {\\r\\n        require(initialized, \\\"not initialized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier inRaise() {\\r\\n        require(\\r\\n            fundStatus == Status.Raise && startDate >= block.timestamp,\\r\\n            \\\"status != raise\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier inRun() {\\r\\n        require(fundStatus == Status.Run, \\\"status != run\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    function initialize(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals,\\r\\n        uint128 _minSize,\\r\\n        uint256[2] memory _dates,\\r\\n        uint16[4] memory _rates,\\r\\n        address _manager,\\r\\n        uint256 _amountOfManager,\\r\\n        address[] memory _tokens\\r\\n    ) external override lock {\\r\\n        require(!initialized, \\\"alreday initialized\\\");\\r\\n        super.initialize(_name, _symbol, _decimals);\\r\\n        initialized = true;\\r\\n        controller = msg.sender;\\r\\n        require(_tokens.length > 1, \\\"token length = 1\\\");\\r\\n        IERC20 base = IERC20(_tokens[0]);\\r\\n        require(\\r\\n            base.balanceOf(address(this)) == _amountOfManager,\\r\\n            \\\"contract's balance != amount\\\"\\r\\n        );\\r\\n        getToken = _tokens;\\r\\n\\r\\n        require(\\r\\n            _dates[1] > _dates[0] && _dates[1] <= (_dates[0] + 1000 days),\\r\\n            \\\"endDate < startDate or endDate - startDate > 1000 days\\\"\\r\\n        );\\r\\n        require(_dates[0] > block.timestamp, \\\"start date < current time\\\");\\r\\n        startDate = uint32(_dates[0]);\\r\\n        endDate = uint32(_dates[1]);\\r\\n\\r\\n        minSize = _minSize;\\r\\n\\r\\n        require(\\r\\n            _amountOfManager >= minSize / 50,\\r\\n            \\\"amountOfManager < minSize * 2%\\\"\\r\\n        );\\r\\n\\r\\n        hurdleRate = _rates[0];\\r\\n        require(hurdleRate >= 110, \\\"hurdleRate < 110\\\");\\r\\n        performanceFee = _rates[1];\\r\\n        require(performanceFee <= 80, \\\"performanceFee > 80\\\");\\r\\n        maxDrawdown = _rates[2];\\r\\n        require(\\r\\n            maxDrawdown < 100 && maxDrawdown > 5,\\r\\n            \\\"maxDrawdown => 100 or maxDrawdown <= 5\\\"\\r\\n        );\\r\\n        estimatedROE = _rates[3];\\r\\n\\r\\n        manager = _manager;\\r\\n        IConfig config = IFundManager(controller).getConfig();\\r\\n        require(config.poolCreationRate() > 0, \\\"poolCreationRate==0\\\");\\r\\n        reservePoolDF = (_amountOfManager * config.poolCreationRate()) / 10000;\\r\\n        _mint(manager, _amountOfManager - reservePoolDF);\\r\\n        _mint(address(this), reservePoolDF);\\r\\n    }\\r\\n\\r\\n    function invest(address _owner, uint256 _amount)\\r\\n        external\\r\\n        override\\r\\n        ready\\r\\n        lock\\r\\n        inRaise\\r\\n        onlyController\\r\\n    {\\r\\n        _mint(_owner, _amount);\\r\\n\\r\\n        if (_totalSupply >= minSize) {\\r\\n            minSize = uint128(_totalSupply);\\r\\n            fundStatus = Status.Run;\\r\\n            _createPool();\\r\\n        }\\r\\n        _notify();\\r\\n    }\\r\\n\\r\\n    function redeem() external ready lock {\\r\\n        address redeemer = msg.sender;\\r\\n        if (fundStatus == Status.Raise || fundStatus == Status.Run) {\\r\\n            _liquidate(redeemer);\\r\\n        }\\r\\n\\r\\n        uint256 dfBalance = balanceOf(redeemer);\\r\\n        for (uint256 i = 0; i < getToken.length; i++) {\\r\\n            address token = getToken[i];\\r\\n            uint256 total = IERC20(token).balanceOf(address(this));\\r\\n            if (total > 0) {\\r\\n                _redeemToken(\\r\\n                    token,\\r\\n                    redeemer,\\r\\n                    (total * dfBalance) / _totalSupply\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        _burn(redeemer, dfBalance);\\r\\n        _notify();\\r\\n    }\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        uint256 deadline\\r\\n    ) external inRun ready nonContract onlyManager {\\r\\n        require(\\r\\n            path.length > 1 && path.length < 6,\\r\\n            \\\"path length must be between 2-5\\\"\\r\\n        );\\r\\n        for (uint256 index = 0; index < path.length; index++) {\\r\\n            require(_inGetToken(path[index]), \\\"not in getToken\\\");\\r\\n        }\\r\\n        address first = path[0];\\r\\n        address uniswapV2Router = IFundManager(controller).uniswapV2Router();\\r\\n        _checkAndSetMaxAllowanceToUniswap(first, uniswapV2Router);\\r\\n        IUniswapV2Router02(uniswapV2Router).swapExactTokensForTokens(\\r\\n            amountIn,\\r\\n            amountOutMin,\\r\\n            path,\\r\\n            address(this),\\r\\n            deadline\\r\\n        );\\r\\n        _notify();\\r\\n    }\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        uint256 deadline\\r\\n    ) external inRun ready nonContract onlyManager {\\r\\n        require(\\r\\n            path.length > 1 && path.length < 6,\\r\\n            \\\"path length must be between 2-5\\\"\\r\\n        );\\r\\n        for (uint256 index = 0; index < path.length; index++) {\\r\\n            require(_inGetToken(path[index]), \\\"not in getToken\\\");\\r\\n        }\\r\\n        address first = path[0];\\r\\n        address uniswapV2Router = IFundManager(controller).uniswapV2Router();\\r\\n        _checkAndSetMaxAllowanceToUniswap(first, uniswapV2Router);\\r\\n        IUniswapV2Router02(uniswapV2Router).swapTokensForExactTokens(\\r\\n            amountOut,\\r\\n            amountInMax,\\r\\n            path,\\r\\n            address(this),\\r\\n            deadline\\r\\n        );\\r\\n        _notify();\\r\\n    }\\r\\n\\r\\n    function status() external view returns (Status) {\\r\\n        if (fundStatus == Status.Raise && _isRaiseFailure())\\r\\n            return Status.RaiseFailure;\\r\\n        if (fundStatus == Status.Run && block.timestamp >= endDate)\\r\\n            return Status.Liquidation;\\r\\n        return fundStatus;\\r\\n    }\\r\\n\\r\\n    function tokens() external view override returns (address[] memory) {\\r\\n        return getToken;\\r\\n    }\\r\\n\\r\\n    function netValue() external view returns (uint256) {\\r\\n        return _netValue();\\r\\n    }\\r\\n\\r\\n    function _inGetToken(address _token) internal view returns (bool) {\\r\\n        for (uint256 i; i < getToken.length; i++) {\\r\\n            if (_token == getToken[i]) return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function _isRaiseFailure() private view returns (bool) {\\r\\n        return\\r\\n            fundStatus == Status.RaiseFailure ||\\r\\n            (fundStatus == Status.Raise &&\\r\\n                block.timestamp > startDate &&\\r\\n                _totalSupply < minSize);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(\\r\\n            fundStatus != Status.Raise || from == address(0),\\r\\n            \\\"not allow transfering in raise\\\"\\r\\n        );\\r\\n        require(\\r\\n            from != manager || to == address(0),\\r\\n            \\\"not allow manager transfering\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _createPool() private {\\r\\n        uint256 liquidity = balanceOf(address(this));\\r\\n        address uniswapV2Router = IFundManager(controller).uniswapV2Router();\\r\\n        address base = getToken[0];\\r\\n        TransferHelper.safeApprove(base, uniswapV2Router, UintMax);\\r\\n        TransferHelper.safeApprove(address(this), uniswapV2Router, UintMax);\\r\\n        IUniswapV2Router02 router = IUniswapV2Router02(uniswapV2Router);\\r\\n\\r\\n        router.addLiquidity(\\r\\n            address(this),\\r\\n            base,\\r\\n            liquidity,\\r\\n            liquidity,\\r\\n            0,\\r\\n            0,\\r\\n            manager,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _notify() private {\\r\\n        IFundManager(controller).getConfig().notify(\\r\\n            IConfig.EventType.FUND_UPDATED,\\r\\n            address(this)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _netValue() private view returns (uint256) {\\r\\n        // console.log(\\\"!status\\\", uint256(fundStatus));\\r\\n        if (fundStatus == Status.Raise || fundStatus == Status.RaiseFailure) {\\r\\n            return _totalSupply;\\r\\n        }\\r\\n\\r\\n        if (fundStatus == Status.Liquidation) {\\r\\n            return finalNetValue;\\r\\n        }\\r\\n        address baseAsset = getToken[0];\\r\\n        uint256 amount = IERC20(baseAsset).balanceOf(address(this));\\r\\n        IUniswapV2Router02 router = IUniswapV2Router02(\\r\\n            IFundManager(controller).uniswapV2Router()\\r\\n        );\\r\\n        for (uint256 i = 1; i < getToken.length; i++) {\\r\\n            uint256 balance = IERC20(getToken[i]).balanceOf(address(this));\\r\\n            if (balance > 0) {\\r\\n                address token = getToken[i];\\r\\n                address pair = IUniswapV2Factory(router.factory()).getPair(\\r\\n                    baseAsset,\\r\\n                    token\\r\\n                );\\r\\n                if (pair == address(0)) {\\r\\n                    continue;\\r\\n                }\\r\\n                (uint256 baseAssetReserve, uint256 tokenReserve) = _getReserves(\\r\\n                    pair,\\r\\n                    baseAsset,\\r\\n                    token\\r\\n                );\\r\\n                amount += _quote(balance, tokenReserve, baseAssetReserve);\\r\\n                // uint256[] memory amounts = router.getAmountsOut(balance, paths);\\r\\n                // console.log(\\\"swap out 0\\\", amounts[0]);\\r\\n                // console.log(\\\"swap out 1\\\", amounts[1]);\\r\\n                // console.log(\\\"amounts length\\\", amounts.length);\\r\\n                // if (amounts.length == 2) {\\r\\n                //     amount += amounts[1];\\r\\n                // }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function _getReserves(\\r\\n        address _pair,\\r\\n        address _tokenA,\\r\\n        address _tokenB\\r\\n    ) private view returns (uint256 reserveA, uint256 reserveB) {\\r\\n        address token0 = _tokenA < _tokenB ? _tokenA : _tokenB;\\r\\n        (uint256 reserve0, uint256 reserve1) = IUniswapV2Pair(_pair)\\r\\n            .getReserves();\\r\\n        return token0 == _tokenA ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n    }\\r\\n\\r\\n    function _quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) internal pure returns (uint256 amountB) {\\r\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\r\\n        require(\\r\\n            reserveA > 0 && reserveB > 0,\\r\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\r\\n        );\\r\\n        amountB = (amountA * reserveB) / reserveA;\\r\\n    }\\r\\n\\r\\n    function _liquidate(address _liquidator) private {\\r\\n        require(balanceOf(_liquidator) > 0, \\\"balance == 0, not investor\\\");\\r\\n        uint256 value = _netValue();\\r\\n        finalNetValue = uint128(value);\\r\\n        uint256 maxDrawdownValue = (_totalSupply * maxDrawdown) / 100;\\r\\n        // console.log(\\\"liquidator\\\", _liquidator);\\r\\n        // console.log(\\\"    status\\\", uint256(fundStatus));\\r\\n        // console.log(\\\"   manager\\\", manager);\\r\\n        // console.log(\\\"  netValue\\\", value);\\r\\n        // console.log(\\\" drawValue\\\", maxDrawdownValue);\\r\\n        require(\\r\\n            block.timestamp > endDate ||\\r\\n                _isRaiseFailure() ||\\r\\n                (fundStatus == Status.Run &&\\r\\n                    (_liquidator == manager || value <= maxDrawdownValue)),\\r\\n            \\\"now <= end date or status != failure or liquidator != manager or netValue >= maxDrawdownValue\\\"\\r\\n        );\\r\\n\\r\\n        uint256 total = balanceOf(address(this));\\r\\n        if (total > 0) {\\r\\n            // return fund of creating pool to manager\\r\\n            fundStatus = Status.RaiseFailure;\\r\\n            _transfer(address(this), manager, total);\\r\\n            return;\\r\\n        }\\r\\n        fundStatus = Status.Liquidation;\\r\\n        _distributeHurdleReward();\\r\\n    }\\r\\n\\r\\n    function _distributeHurdleReward() private {\\r\\n        address base = getToken[0];\\r\\n        uint256 value = IERC20(base).balanceOf(address(this));\\r\\n        uint256 hurdleLine = (minSize * hurdleRate) / 100;\\r\\n        if (value > hurdleLine) {\\r\\n            uint256 reward = ((value - hurdleLine) * performanceFee) / 100;\\r\\n            _redeemToken(base, manager, reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _redeemToken(\\r\\n        address _token,\\r\\n        address _redeemer,\\r\\n        uint256 _amountOfRedeemer\\r\\n    ) private {\\r\\n        IConfig config = IFundManager(controller).getConfig();\\r\\n        uint256 out = fundStatus == Status.Liquidation\\r\\n            ? (_amountOfRedeemer * (10000 - config.redeemFeeRate())) / 10000\\r\\n            : _amountOfRedeemer;\\r\\n\\r\\n        uint256 fee = _amountOfRedeemer - out;\\r\\n        // console.log(\\\"amount\\\", _amountOfRedeemer);\\r\\n        // console.log(\\\"   out\\\", out);\\r\\n        // console.log(\\\"   fee\\\", fee);\\r\\n        if (out > 0) {\\r\\n            TransferHelper.safeTransfer(_token, _redeemer, out);\\r\\n        }\\r\\n        if (fee > 0) {\\r\\n            TransferHelper.safeTransfer(_token, config.feeTo(), fee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkAndSetMaxAllowanceToUniswap(address _token, address _router)\\r\\n        private\\r\\n    {\\r\\n        IERC20 token = IERC20(_token);\\r\\n        uint256 uniAllowance = token.allowance(address(this), _router);\\r\\n        if (uniAllowance <= UintMax) {\\r\\n            token.approve(_router, UintMax);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IERC20.sol\\\";\\r\\nimport \\\"./libs/SafeMath.sol\\\";\\r\\n\\r\\ncontract ERC20 is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 internal _totalSupply;\\r\\n\\r\\n    string public override name;\\r\\n    string public override symbol;\\r\\n    uint8 public override decimals;\\r\\n\\r\\n    function initialize(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimal\\r\\n    ) internal {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimal;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount)\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            _msgSender(),\\r\\n            _allowances[sender][_msgSender()].sub(\\r\\n                amount,\\r\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        public\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender].add(addedValue)\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        public\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender].sub(\\r\\n                subtractedValue,\\r\\n                \\\"ERC20: decreased allowance below zero\\\"\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(\\r\\n            amount,\\r\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(\\r\\n            amount,\\r\\n            \\\"ERC20: burn amount exceeds balance\\\"\\r\\n        );\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _msgSender() private view returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) =\\r\\n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper: APPROVE_FAILED'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        (bool success, bytes memory data) =\\r\\n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper: TRANSFER_FAILED'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\r\\n        (bool success, bytes memory data) =\\r\\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper: TRANSFER_FROM_FAILED'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IFundManager.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./IConfig.sol\\\";\\r\\n\\r\\ninterface IFundManager {\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function broadcast() external;\\r\\n\\r\\n    function uniswapV2Router() external view returns (address);\\r\\n\\r\\n    function getConfig() external view returns (IConfig);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IFund.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\n\\r\\ninterface IFund {\\r\\n    enum Status {Raise, Run, Liquidation, RaiseFailure}\\r\\n\\r\\n    function invest(address owner, uint256 amount) external;\\r\\n\\r\\n    function initialize(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals,\\r\\n        uint128 _minSize,\\r\\n        uint256[2] memory _dates,\\r\\n        uint16[4] memory _rates,\\r\\n        address _manager,\\r\\n        uint256 _amountOfManager,\\r\\n        address[] memory _tokens\\r\\n    ) external;\\r\\n\\r\\n    function tokens() external view returns (address[] memory);\\r\\n\\r\\n    function getToken(uint256) external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (uint256 amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <=0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, 'SafeMath: addition overflow');\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, 'SafeMath: subtraction overflow');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, 'SafeMath: multiplication overflow');\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, 'SafeMath: division by zero');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, 'SafeMath: modulo by zero');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfig.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\n\\r\\ninterface IConfig {\\r\\n    enum EventType {FUND_CREATED, FUND_UPDATED, STAKE_CREATED, STAKE_UPDATED, REG_CREATED, REG_UPDATED, PFUND_CREATED, PFUND_UPDATED}\\r\\n\\r\\n    function ceo() external view returns (address);\\r\\n\\r\\n    function protocolPool() external view returns (address);\\r\\n\\r\\n    function protocolToken() external view returns (address);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function nameRegistry() external view returns (address);\\r\\n\\r\\n    //  function investTokenWhitelist() external view returns (address[] memory);\\r\\n\\r\\n    function tokenMinFundSize(address token) external view returns (uint256);\\r\\n\\r\\n    function investFeeRate() external view returns (uint256);\\r\\n\\r\\n    function redeemFeeRate() external view returns (uint256);\\r\\n\\r\\n    function claimFeeRate() external view returns (uint256);\\r\\n\\r\\n    function poolCreationRate() external view returns (uint256);\\r\\n\\r\\n    function slot0() external view returns (uint256);\\r\\n\\r\\n    function slot1() external view returns (uint256);\\r\\n\\r\\n    function slot2() external view returns (uint256);\\r\\n\\r\\n    function slot3() external view returns (uint256);\\r\\n\\r\\n    function slot4() external view returns (uint256);\\r\\n\\r\\n    function notify(EventType _type, address _src) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netValue\",\"type\":\"uint256\"}],\"name\":\"Liquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dfAmount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"StatuChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UintMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedROE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalNetValue\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hurdleRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_minSize\",\"type\":\"uint128\"},{\"internalType\":\"uint256[2]\",\"name\":\"_dates\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint16[4]\",\"name\":\"_rates\",\"type\":\"uint16[4]\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfManager\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDrawdown\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSize\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"netValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservePoolDF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum IFund.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Fund","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}