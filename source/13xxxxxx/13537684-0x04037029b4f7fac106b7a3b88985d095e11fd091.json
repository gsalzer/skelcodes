{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.7 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.3.2\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File contracts/fund.sol\r\n\r\npragma solidity 0.8.7;\r\n//SPDX-License-Identifier: UNLICENSED\r\n\r\ncontract Fund3Week {\r\n    address owner = msg.sender;\r\n\r\n    // Tokens used to deposit\r\n    address[] public usdTokens;\r\n\r\n    uint256 public dateToReleaseFunds;\r\n    uint256 public dateToTransferFundsToNextContract;\r\n    uint256 ownerFullControlTime;\r\n\r\n    address public nextContract;\r\n\r\n    mapping(address => mapping(address => uint256)) public userDeposits;\r\n\r\n\r\n    modifier onlyActive() {\r\n        require(dateToReleaseFunds > 0, \"!active\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"!owner\");\r\n        _;\r\n    }\r\n\r\n    modifier timeUnlocked() {\r\n        require(block.timestamp > dateToReleaseFunds, \"!time\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyHuman() {\r\n        require(msg.sender == tx.origin, \"!human\");\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _usdTokens) {\r\n        usdTokens = _usdTokens;\r\n    }\r\n\r\n    function activate() public onlyOwner {\r\n        require(dateToReleaseFunds == 0, \"!only once\");\r\n        dateToReleaseFunds = block.timestamp + 21 days;\r\n        dateToTransferFundsToNextContract = dateToReleaseFunds + 2 days;\r\n        ownerFullControlTime = dateToTransferFundsToNextContract + 14 days;\r\n    }\r\n\r\n    /***\r\n    Deposit funds to contract.\r\n    ***/\r\n    function deposit(uint256 _amount) onlyActive onlyHuman public {\r\n        require(block.timestamp < dateToReleaseFunds, \"!too late\");\r\n        receivePayment(msg.sender, _amount);\r\n    }\r\n\r\n    /***\r\n    Withdraw funds. If @devs didn't suggest implementation of new contract users withdraw 100% thier funds\r\n    In other case 5% fee penalty\r\n    ***/\r\n    function withdraw() onlyActive onlyHuman timeUnlocked public {\r\n        uint256 fee = 0;\r\n        if (nextContract != address(0)) fee = 5; // 5%\r\n\r\n        uint256 _len = usdTokens.length;\r\n        for(uint256 i = 0; i < _len;i++) {\r\n            uint256 _amount = userDeposits[msg.sender][usdTokens[i]];\r\n            if (_amount > 0) {\r\n                uint256 _amountFee = _amount * fee / 100;\r\n                if (_amountFee > 0) {\r\n                    IERC20(usdTokens[i]).transfer(owner, _amountFee);\r\n                    _amount -= _amountFee;\r\n                }\r\n\r\n                userDeposits[msg.sender][usdTokens[i]] = 0;\r\n                IERC20(usdTokens[i]).transfer(msg.sender, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /***\r\n    Set implementation of new contract\r\n    ***/\r\n    function setNextContract(address _newContract) public onlyOwner {\r\n        require(block.timestamp < dateToReleaseFunds, \"!too late\");\r\n        nextContract = _newContract;\r\n    }\r\n\r\n    /***\r\n    Transfer(migrate) funds to new contract. User have a time until @dateToTransferFundsToNextContract to validate new contract\r\n    ***/\r\n    function transferFunds() public timeUnlocked onlyOwner {\r\n        address _nextContract = nextContract;\r\n        require(_nextContract != address(0), \"!contract\");\r\n        require(block.timestamp > dateToTransferFundsToNextContract, \"!time\");\r\n\r\n        uint256 _len = usdTokens.length;\r\n\r\n        for(uint256 i = 0;i < _len;i++) {\r\n            IERC20 _token = IERC20(usdTokens[i]);\r\n            _token.transfer(_nextContract, _token.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /***\r\n    Accept payment in any allowed token\r\n    ***/\r\n    function receivePayment(address _userAddress, uint256 _amount) internal {\r\n        uint256 _len = usdTokens.length;\r\n        for(uint256 i = 0; i < _len;i++) {\r\n            IERC20 activeCurrency = IERC20(usdTokens[i]);\r\n            uint256 decimals = IERC20Metadata(usdTokens[i]).decimals();\r\n            uint256 _amountInActiveCurrency = _amount * (10 ** decimals) / 1e18;\r\n            if (activeCurrency.allowance(_userAddress, address(this)) >= _amountInActiveCurrency && activeCurrency.balanceOf(_userAddress) >= _amountInActiveCurrency) {\r\n                activeCurrency.transferFrom(_userAddress, address(this), _amountInActiveCurrency);\r\n                userDeposits[_userAddress][usdTokens[i]] += _amountInActiveCurrency;\r\n                // SUCCESS\r\n                return;\r\n            }\r\n        }\r\n        revert(\"!payment failed\");\r\n    }\r\n\r\n    /***\r\n    In case something goes wrong, for example user sent wrong token to contract or sent from an exchange...\r\n    ***/\r\n    function externalCallEth(address payable[] memory  _to, bytes[] memory _data, uint256[] memory ethAmount) public onlyOwner payable {\r\n        require(block.timestamp > ownerFullControlTime, \"!time\");\r\n\r\n        for(uint16 i = 0; i < _to.length; i++) {\r\n            _cast(_to[i], _data[i], ethAmount[i]);\r\n        }\r\n    }\r\n\r\n    function _cast(address payable _to, bytes memory _data, uint256 _value) internal {\r\n        bool success;\r\n        bytes memory returndata;\r\n        (success, returndata) = _to.call{value:_value}(_data);\r\n        require(success, string (returndata));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_usdTokens\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateToReleaseFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateToTransferFundsToNextContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethAmount\",\"type\":\"uint256[]\"}],\"name\":\"externalCallEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"setNextContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usdTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Fund3Week","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000006b175474e89094c44da98b954eedeac495271d0f","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://eec7dcf74ec8d36dfcde615f9cf06311278c17ceef62ce58c0834514a40a98c9"}]}