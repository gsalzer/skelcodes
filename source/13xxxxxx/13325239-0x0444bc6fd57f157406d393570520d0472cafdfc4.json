{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/contract/minipool/RocketMinipoolDelegate.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./RocketMinipoolStorageLayout.sol\\\";\\nimport \\\"../../interface/casper/DepositInterface.sol\\\";\\nimport \\\"../../interface/deposit/RocketDepositPoolInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolManagerInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolQueueInterface.sol\\\";\\nimport \\\"../../interface/minipool/RocketMinipoolPenaltyInterface.sol\\\";\\nimport \\\"../../interface/network/RocketNetworkPricesInterface.sol\\\";\\nimport \\\"../../interface/node/RocketNodeManagerInterface.sol\\\";\\nimport \\\"../../interface/node/RocketNodeStakingInterface.sol\\\";\\nimport \\\"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\\\";\\nimport \\\"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\\\";\\nimport \\\"../../interface/network/RocketNetworkFeesInterface.sol\\\";\\nimport \\\"../../interface/token/RocketTokenRETHInterface.sol\\\";\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\n\\n// An individual minipool in the Rocket Pool network\\n\\ncontract RocketMinipoolDelegate is RocketMinipoolStorageLayout, RocketMinipoolInterface {\\n\\n    // Constants\\n    uint256 constant calcBase = 1 ether;\\n    uint256 constant distributionCooldown = 100;                  // Number of blocks that must pass between calls to distributeBalance\\n\\n    // Libs\\n    using SafeMath for uint;\\n\\n    // Events\\n    event StatusUpdated(uint8 indexed status, uint256 time);\\n    event EtherDeposited(address indexed from, uint256 amount, uint256 time);\\n    event EtherWithdrawn(address indexed to, uint256 amount, uint256 time);\\n    event EtherWithdrawalProcessed(address indexed executed, uint256 nodeAmount, uint256 userAmount, uint256 totalBalance, uint256 time);\\n\\n    // Status getters\\n    function getStatus() override external view returns (MinipoolStatus) { return status; }\\n    function getFinalised() override external view returns (bool) { return finalised; }\\n    function getStatusBlock() override external view returns (uint256) { return statusBlock; }\\n    function getStatusTime() override external view returns (uint256) { return statusTime; }\\n\\n    // Deposit type getter\\n    function getDepositType() override external view returns (MinipoolDeposit) { return depositType; }\\n\\n    // Node detail getters\\n    function getNodeAddress() override external view returns (address) { return nodeAddress; }\\n    function getNodeFee() override external view returns (uint256) { return nodeFee; }\\n    function getNodeDepositBalance() override external view returns (uint256) { return nodeDepositBalance; }\\n    function getNodeRefundBalance() override external view returns (uint256) { return nodeRefundBalance; }\\n    function getNodeDepositAssigned() override external view returns (bool) { return nodeDepositAssigned; }\\n\\n    // User deposit detail getters\\n    function getUserDepositBalance() override external view returns (uint256) { return userDepositBalance; }\\n    function getUserDepositAssigned() override external view returns (bool) { return userDepositAssignedTime != 0; }\\n    function getUserDepositAssignedTime() override external view returns (uint256) { return userDepositAssignedTime; }\\n\\n    // Get the withdrawal credentials for the minipool contract\\n    function getWithdrawalCredentials() override public view returns (bytes memory) {\\n        return abi.encodePacked(byte(0x01), bytes11(0x0), address(this));\\n    }\\n\\n    // Prevent direct calls to this contract\\n    modifier onlyInitialised() {\\n        require(storageState == StorageState.Initialised, \\\"Storage state not initialised\\\");\\n        _;\\n    }\\n\\n    modifier onlyUninitialised() {\\n        require(storageState == StorageState.Uninitialised, \\\"Storage state already initialised\\\");\\n        _;\\n    }\\n\\n    // Only allow access from the owning node address\\n    modifier onlyMinipoolOwner(address _nodeAddress) {\\n        require(_nodeAddress == nodeAddress, \\\"Invalid minipool owner\\\");\\n        _;\\n    }\\n\\n    // Only allow access from the owning node address or their withdrawal address\\n    modifier onlyMinipoolOwnerOrWithdrawalAddress(address _nodeAddress) {\\n        require(_nodeAddress == nodeAddress || _nodeAddress == rocketStorage.getNodeWithdrawalAddress(nodeAddress), \\\"Invalid minipool owner\\\");\\n        _;\\n    }\\n\\n    // Only allow access from the latest version of the specified Rocket Pool contract\\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\\n        require(_contractAddress == getContractAddress(_contractName), \\\"Invalid or outdated contract\\\");\\n        _;\\n    }\\n\\n    // Get the address of a Rocket Pool network contract\\n    function getContractAddress(string memory _contractName) private view returns (address) {\\n        address contractAddress = rocketStorage.getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        require(contractAddress != address(0x0), \\\"Contract not found\\\");\\n        return contractAddress;\\n    }\\n\\n    function initialise(address _nodeAddress, MinipoolDeposit _depositType) override external onlyUninitialised {\\n        // Check parameters\\n        require(_nodeAddress != address(0x0), \\\"Invalid node address\\\");\\n        require(_depositType != MinipoolDeposit.None, \\\"Invalid deposit type\\\");\\n        // Load contracts\\n        RocketNetworkFeesInterface rocketNetworkFees = RocketNetworkFeesInterface(getContractAddress(\\\"rocketNetworkFees\\\"));\\n        // Set initial status\\n        status = MinipoolStatus.Initialised;\\n        statusBlock = block.number;\\n        statusTime = block.timestamp;\\n        // Set details\\n        depositType = _depositType;\\n        nodeAddress = _nodeAddress;\\n        nodeFee = rocketNetworkFees.getNodeFee();\\n        // Set the rETH address\\n        rocketTokenRETH = getContractAddress(\\\"rocketTokenRETH\\\");\\n        // Set local copy of penalty contract\\n        rocketMinipoolPenalty = getContractAddress(\\\"rocketMinipoolPenalty\\\");\\n        // Intialise storage state\\n        storageState = StorageState.Initialised;\\n    }\\n\\n    // Assign the node deposit to the minipool\\n    // Only accepts calls from the RocketNodeDeposit contract\\n    function nodeDeposit() override external payable onlyLatestContract(\\\"rocketNodeDeposit\\\", msg.sender) onlyInitialised {\\n        // Check current status & node deposit status\\n        require(status == MinipoolStatus.Initialised, \\\"The node deposit can only be assigned while initialised\\\");\\n        require(!nodeDepositAssigned, \\\"The node deposit has already been assigned\\\");\\n        // Progress full minipool to prelaunch\\n        if (depositType == MinipoolDeposit.Full) { setStatus(MinipoolStatus.Prelaunch); }\\n        // Update node deposit details\\n        nodeDepositBalance = msg.value;\\n        nodeDepositAssigned = true;\\n        // Emit ether deposited event\\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\\n    }\\n\\n    // Assign user deposited ETH to the minipool and mark it as prelaunch\\n    // Only accepts calls from the RocketDepositPool contract\\n    function userDeposit() override external payable onlyLatestContract(\\\"rocketDepositPool\\\", msg.sender) onlyInitialised {\\n        // Check current status & user deposit status\\n        require(status >= MinipoolStatus.Initialised && status <= MinipoolStatus.Staking, \\\"The user deposit can only be assigned while initialised, in prelaunch, or staking\\\");\\n        require(userDepositAssignedTime == 0, \\\"The user deposit has already been assigned\\\");\\n        // Progress initialised minipool to prelaunch\\n        if (status == MinipoolStatus.Initialised) { setStatus(MinipoolStatus.Prelaunch); }\\n        // Update user deposit details\\n        userDepositBalance = msg.value;\\n        userDepositAssignedTime = block.timestamp;\\n        // Refinance full minipool\\n        if (depositType == MinipoolDeposit.Full) {\\n            // Update node balances\\n            nodeDepositBalance = nodeDepositBalance.sub(msg.value);\\n            nodeRefundBalance = nodeRefundBalance.add(msg.value);\\n        }\\n        // Emit ether deposited event\\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\\n    }\\n\\n    // Refund node ETH refinanced from user deposited ETH\\n    function refund() override external onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) onlyInitialised {\\n        // Check refund balance\\n        require(nodeRefundBalance > 0, \\\"No amount of the node deposit is available for refund\\\");\\n        // Refund node\\n        _refund();\\n    }\\n\\n    // Called to slash node operator's RPL balance if withdrawal balance was less than user deposit\\n    function slash() external override onlyInitialised {\\n        // Check there is a slash balance\\n        require(nodeSlashBalance > 0, \\\"No balance to slash\\\");\\n        // Perform slash\\n        _slash();\\n    }\\n\\n    // Called by node operator to finalise the pool and unlock their RPL stake\\n    function finalise() external override onlyInitialised onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) {\\n        // Can only call if withdrawable and can only be called once\\n        require(status == MinipoolStatus.Withdrawable, \\\"Minipool must be withdrawable\\\");\\n        // Node operator cannot finalise the pool unless distributeBalance has been called\\n        require(withdrawalBlock > 0, \\\"Minipool balance must have been distributed at least once\\\");\\n        // Finalise the pool\\n        _finalise();\\n    }\\n\\n    // Progress the minipool to staking, sending its ETH deposit to the VRC\\n    // Only accepts calls from the minipool owner (node)\\n    function stake(bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) override external onlyMinipoolOwner(msg.sender) onlyInitialised {\\n        // Check current status\\n        require(status == MinipoolStatus.Prelaunch, \\\"The minipool can only begin staking while in prelaunch\\\");\\n        // Progress to staking\\n        setStatus(MinipoolStatus.Staking);\\n        // Load contracts\\n        DepositInterface casperDeposit = DepositInterface(getContractAddress(\\\"casperDeposit\\\"));\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        // Get launch amount\\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\\n        // Check minipool balance\\n        require(address(this).balance >= launchAmount, \\\"Insufficient balance to begin staking\\\");\\n        // Check validator pubkey is not in use\\n        require(rocketMinipoolManager.getMinipoolByPubkey(_validatorPubkey) == address(0x0), \\\"Validator pubkey is already in use\\\");\\n        // Set minipool pubkey\\n        rocketMinipoolManager.setMinipoolPubkey(_validatorPubkey);\\n        // Send staking deposit to casper\\n        casperDeposit.deposit{value: launchAmount}(_validatorPubkey, getWithdrawalCredentials(), _validatorSignature, _depositDataRoot);\\n        // Increment node's number of staking minipools\\n        rocketMinipoolManager.incrementNodeStakingMinipoolCount(nodeAddress);\\n    }\\n\\n    // Mark the minipool as withdrawable\\n    // Only accepts calls from the RocketMinipoolStatus contract\\n    function setWithdrawable() override external onlyLatestContract(\\\"rocketMinipoolStatus\\\", msg.sender) onlyInitialised {\\n        // Get contracts\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        // Check current status\\n        require(status == MinipoolStatus.Staking, \\\"The minipool can only become withdrawable while staking\\\");\\n        // Progress to withdrawable\\n        setStatus(MinipoolStatus.Withdrawable);\\n        // Remove minipool from queue\\n        if (userDepositAssignedTime == 0) {\\n            // User deposit was never assigned so it still exists in queue, remove it\\n            RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\\\"rocketMinipoolQueue\\\"));\\n            rocketMinipoolQueue.removeMinipool(depositType);\\n        }\\n        // Decrement the node operator's staking minipool count\\n        rocketMinipoolManager.decrementNodeStakingMinipoolCount(nodeAddress);\\n    }\\n\\n    // Distributes the contract's balance and finalises the pool\\n    function distributeBalanceAndFinalise() override external onlyInitialised onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) {\\n        // Can only call if withdrawable and can only be called once\\n        require(status == MinipoolStatus.Withdrawable, \\\"Minipool must be withdrawable\\\");\\n        // Get withdrawal amount, we must also account for a possible node refund balance on the contract from users staking 32 ETH that have received a 16 ETH refund after the protocol bought out 16 ETH\\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\\n        // Process withdrawal\\n        _distributeBalance(totalBalance);\\n        // Finalise the pool\\n        _finalise();\\n    }\\n\\n    // Distributes the contract's balance\\n    // When called during staking status, requires 16 ether in the pool\\n    // When called by non-owner with less than 16 ether, requires 14 days to have passed since being made withdrawable\\n    function distributeBalance() override external onlyInitialised {\\n        // Must be called while staking or withdrawable\\n        require(status == MinipoolStatus.Staking || status == MinipoolStatus.Withdrawable, \\\"Minipool must be staking or withdrawable\\\");\\n        // Get withdrawal amount, we must also account for a possible node refund balance on the contract from users staking 32 ETH that have received a 16 ETH refund after the protocol bought out 16 ETH\\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\\n        // Get node withdrawal address\\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\\n        // If it's not the owner calling\\n        if (msg.sender != nodeAddress && msg.sender != nodeWithdrawalAddress) {\\n            // And the pool is in staking status\\n            if (status == MinipoolStatus.Staking) {\\n                // Then balance must be greater than 16 ETH\\n                require(totalBalance >= 16 ether, \\\"Balance must be greater than 16 ETH\\\");\\n            } else {\\n                // Then enough time must have elapsed\\n                require(block.timestamp > statusTime.add(14 days), \\\"Non-owner must wait 14 days after withdrawal to distribute balance\\\");\\n                // And balance must be greater than 4 ETH\\n                require(address(this).balance >= 4 ether, \\\"Balance must be greater than 4 ETH\\\");\\n            }\\n        }\\n        // Process withdrawal\\n        _distributeBalance(totalBalance);\\n    }\\n\\n    // Perform any slashings, refunds, and unlock NO's stake\\n    function _finalise() private {\\n        // Get contracts\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        // Can only finalise the pool once\\n        require(!finalised, \\\"Minipool has already been finalised\\\");\\n        // If slash is required then perform it\\n        if (nodeSlashBalance > 0) {\\n            _slash();\\n        }\\n        // Refund node operator if required\\n        if (nodeRefundBalance > 0) {\\n            _refund();\\n        }\\n        // Send any left over ETH to rETH contract\\n        if (address(this).balance > 0) {\\n            // Send user amount to rETH contract\\n            payable(rocketTokenRETH).transfer(address(this).balance);\\n        }\\n        // Trigger a deposit of excess collateral from rETH contract to deposit pool\\n        RocketTokenRETHInterface(rocketTokenRETH).depositExcessCollateral();\\n        // Unlock node operator's RPL\\n        rocketMinipoolManager.incrementNodeFinalisedMinipoolCount(nodeAddress);\\n        // Update unbonded validator count if minipool is unbonded\\n        if (depositType == MinipoolDeposit.Empty) {\\n            RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\\\"rocketDAONodeTrusted\\\"));\\n            rocketDAONodeTrusted.decrementMemberUnbondedValidatorCount(nodeAddress);\\n        }\\n        // Set finalised flag\\n        finalised = true;\\n    }\\n\\n    function _distributeBalance(uint256 _balance) private {\\n        // Rate limit this method to prevent front running\\n        require(block.number > withdrawalBlock + distributionCooldown, \\\"Distribution of this minipool's balance is on cooldown\\\");\\n        // Deposit amounts\\n        uint256 nodeAmount = 0;\\n        // Check if node operator was slashed\\n        if (_balance < userDepositBalance) {\\n            // Only slash on first call to distribute\\n            if (withdrawalBlock == 0) {\\n                // Record shortfall for slashing\\n                nodeSlashBalance = userDepositBalance.sub(_balance);\\n            }\\n        } else {\\n            // Calculate node's share of the balance\\n            nodeAmount = calculateNodeShare(_balance);\\n        }\\n        // User amount is what's left over from node's share\\n        uint256 userAmount = _balance.sub(nodeAmount);\\n        // Pay node operator via refund\\n        nodeRefundBalance = nodeRefundBalance.add(nodeAmount);\\n        // Pay user amount to rETH contract\\n        if (userAmount > 0) {\\n            // Send user amount to rETH contract\\n            payable(rocketTokenRETH).transfer(userAmount);\\n        }\\n        // Save block to prevent multiple withdrawals within a few blocks\\n        withdrawalBlock = block.number;\\n        // Log it\\n        emit EtherWithdrawalProcessed(msg.sender, nodeAmount, userAmount, _balance, block.timestamp);\\n    }\\n\\n    // Given a validator balance, this function returns what portion of it belongs to the node taking into consideration\\n    // the minipool's commission rate and any penalties it may have attracted\\n    function calculateNodeShare(uint256 _balance) override public view returns (uint256) {\\n        // Get fee and balances from minipool contract\\n        uint256 stakingDepositTotal = 32 ether;\\n        uint256 userAmount = userDepositBalance;\\n        // Check if node operator was slashed\\n        if (userAmount > _balance) {\\n            // None of balance belongs to the node\\n            return 0;\\n        }\\n        // Check if there are rewards to pay out\\n        if (_balance > stakingDepositTotal) {\\n            // Calculate rewards earned\\n            uint256 totalRewards = _balance.sub(stakingDepositTotal);\\n            // Calculate node share of rewards for the user\\n            uint256 halfRewards = totalRewards.div(2);\\n            uint256 nodeCommissionFee = halfRewards.mul(nodeFee).div(1 ether);\\n            // Check for un-bonded minipool\\n            if (depositType == MinipoolDeposit.Empty) {\\n                // Add the total rewards minus the commission to the user's total\\n                userAmount = userAmount.add(totalRewards.sub(nodeCommissionFee));\\n            } else {\\n                // Add half the rewards minus the commission fee to the user's total\\n                userAmount = userAmount.add(halfRewards.sub(nodeCommissionFee));\\n            }\\n        }\\n        // Calculate node amount as what's left over after user amount\\n        uint256 nodeAmount = _balance.sub(userAmount);\\n        // Check if node has an ETH penalty\\n        uint256 penaltyRate = RocketMinipoolPenaltyInterface(rocketMinipoolPenalty).getPenaltyRate(address(this));\\n        if (penaltyRate > 0) {\\n            uint256 penaltyAmount = nodeAmount.mul(penaltyRate).div(calcBase);\\n            if (penaltyAmount > nodeAmount) {\\n                penaltyAmount = nodeAmount;\\n            }\\n            nodeAmount = nodeAmount.sub(penaltyAmount);\\n        }\\n        return nodeAmount;\\n    }\\n\\n    // Given a validator balance, this function returns what portion of it belongs to rETH users taking into consideration\\n    // the minipool's commission rate and any penalties it may have attracted\\n    function calculateUserShare(uint256 _balance) override external view returns (uint256) {\\n        // User's share is just the balance minus node's share\\n        return _balance.sub(calculateNodeShare(_balance));\\n    }\\n\\n    // Dissolve the minipool, returning user deposited ETH to the deposit pool\\n    // Only accepts calls from the minipool owner (node), or from any address if timed out\\n    function dissolve() override external onlyInitialised {\\n        // Check current status\\n        require(status == MinipoolStatus.Initialised || status == MinipoolStatus.Prelaunch, \\\"The minipool can only be dissolved while initialised or in prelaunch\\\");\\n        // Load contracts\\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\\\"rocketDepositPool\\\"));\\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\\\"rocketMinipoolQueue\\\"));\\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\\\"rocketDAOProtocolSettingsMinipool\\\"));\\n        // Check if being dissolved by minipool owner or minipool is timed out\\n        require(\\n            msg.sender == nodeAddress ||\\n            (status == MinipoolStatus.Prelaunch && block.number.sub(statusBlock) >= rocketDAOProtocolSettingsMinipool.getLaunchTimeout()),\\n            \\\"The minipool can only be dissolved by its owner unless it has timed out\\\"\\n        );\\n        // Progress to dissolved\\n        setStatus(MinipoolStatus.Dissolved);\\n        // Transfer user balance to deposit pool\\n        if (userDepositBalance > 0) {\\n            // Store value in local\\n            uint256 recycleAmount = userDepositBalance;\\n            // Clear storage\\n            userDepositBalance = 0;\\n            userDepositAssignedTime = 0;\\n            // Transfer\\n            rocketDepositPool.recycleDissolvedDeposit{value: recycleAmount}();\\n            // Emit ether withdrawn event\\n            emit EtherWithdrawn(address(rocketDepositPool), recycleAmount, block.timestamp);\\n        } else {\\n            rocketMinipoolQueue.removeMinipool(depositType);\\n        }\\n    }\\n\\n    // Withdraw node balances from the minipool and close it\\n    // Only accepts calls from the minipool owner (node)\\n    function close() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\\n        // Check current status\\n        require(status == MinipoolStatus.Dissolved, \\\"The minipool can only be closed while dissolved\\\");\\n        // Transfer node balance to node operator\\n        uint256 nodeBalance = nodeDepositBalance.add(nodeRefundBalance);\\n        if (nodeBalance > 0) {\\n            // Update node balances\\n            nodeDepositBalance = 0;\\n            nodeRefundBalance = 0;\\n            // Get node withdrawal address\\n            address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\\n            // Transfer balance\\n            (bool success,) = nodeWithdrawalAddress.call{value: nodeBalance}(\\\"\\\");\\n            require(success, \\\"Node ETH balance was not successfully transferred to node operator\\\");\\n            // Emit ether withdrawn event\\n            emit EtherWithdrawn(nodeWithdrawalAddress, nodeBalance, block.timestamp);\\n        }\\n        // Update unbonded validator count if minipool is unbonded\\n        if (depositType == MinipoolDeposit.Empty) {\\n            RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(\\\"rocketDAONodeTrusted\\\"));\\n            rocketDAONodeTrusted.decrementMemberUnbondedValidatorCount(nodeAddress);\\n        }\\n        // Destroy minipool\\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\\\"rocketMinipoolManager\\\"));\\n        rocketMinipoolManager.destroyMinipool();\\n        // Self destruct\\n        selfdestruct(payable(rocketTokenRETH));\\n    }\\n\\n    // Set the minipool's current status\\n    function setStatus(MinipoolStatus _status) private {\\n        // Update status\\n        status = _status;\\n        statusBlock = block.number;\\n        statusTime = block.timestamp;\\n        // Emit status updated event\\n        emit StatusUpdated(uint8(_status), block.timestamp);\\n    }\\n\\n    // Transfer refunded ETH balance to the node operator\\n    function _refund() private {\\n        // Update refund balance\\n        uint256 refundAmount = nodeRefundBalance;\\n        nodeRefundBalance = 0;\\n        // Get node withdrawal address\\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\\n        // Transfer refund amount\\n        (bool success,) = nodeWithdrawalAddress.call{value: refundAmount}(\\\"\\\");\\n        require(success, \\\"ETH refund amount was not successfully transferred to node operator\\\");\\n        // Emit ether withdrawn event\\n        emit EtherWithdrawn(nodeWithdrawalAddress, refundAmount, block.timestamp);\\n    }\\n\\n    // Slash node operator's RPL balance based on nodeSlashBalance\\n    function _slash() private {\\n        // Get contracts\\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\\\"rocketNodeStaking\\\"));\\n        // Slash required amount and reset storage value\\n        uint256 slashAmount = nodeSlashBalance;\\n        nodeSlashBalance = 0;\\n        rocketNodeStaking.slashRPL(nodeAddress, slashAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/contract/minipool/RocketMinipoolStorageLayout.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../interface/RocketStorageInterface.sol\\\";\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\n\\n// The RocketMinipool contract storage layout, shared by RocketMinipoolDelegate\\n\\n// ******************************************************\\n// Note: This contract MUST NOT BE UPDATED after launch.\\n// All deployed minipool contracts must maintain a\\n// Consistent storage layout with RocketMinipoolDelegate.\\n// ******************************************************\\n\\nabstract contract RocketMinipoolStorageLayout {\\n    // Storage state enum\\n    enum StorageState {\\n        Undefined,\\n        Uninitialised,\\n        Initialised\\n    }\\n\\n\\t// Main Rocket Pool storage contract\\n    RocketStorageInterface internal rocketStorage = RocketStorageInterface(0);\\n\\n    // Status\\n    MinipoolStatus internal status;\\n    uint256 internal statusBlock;\\n    uint256 internal statusTime;\\n    uint256 internal withdrawalBlock;\\n\\n    // Deposit type\\n    MinipoolDeposit internal depositType;\\n\\n    // Node details\\n    address internal nodeAddress;\\n    uint256 internal nodeFee;\\n    uint256 internal nodeDepositBalance;\\n    bool internal nodeDepositAssigned;\\n    uint256 internal nodeRefundBalance;\\n    uint256 internal nodeSlashBalance;\\n\\n    // User deposit details\\n    uint256 internal userDepositBalance;\\n    uint256 internal userDepositAssignedTime;\\n\\n    // Upgrade options\\n    bool internal useLatestDelegate = false;\\n    address internal rocketMinipoolDelegate;\\n    address internal rocketMinipoolDelegatePrev;\\n\\n    // Local copy of RETH address\\n    address internal rocketTokenRETH;\\n\\n    // Local copy of penalty contract\\n    address internal rocketMinipoolPenalty;\\n\\n    // Used to prevent direct access to delegate and prevent calling initialise more than once\\n    StorageState storageState = StorageState.Undefined;\\n\\n    // Whether node operator has finalised the pool\\n    bool internal finalised;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/RocketStorageInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketStorageInterface {\\n\\n    // Guardian\\n    function getGuardian() external view returns(address);\\n    function setGuardian(address _newAddress) external;\\n    function confirmGuardian() external;\\n\\n    // Getters\\n    function getAddress(bytes32 _key) external view returns (address);\\n    function getUint(bytes32 _key) external view returns (uint);\\n    function getString(bytes32 _key) external view returns (string memory);\\n    function getBytes(bytes32 _key) external view returns (bytes memory);\\n    function getBool(bytes32 _key) external view returns (bool);\\n    function getInt(bytes32 _key) external view returns (int);\\n    function getBytes32(bytes32 _key) external view returns (bytes32);\\n\\n    // Setters\\n    function setAddress(bytes32 _key, address _value) external;\\n    function setUint(bytes32 _key, uint _value) external;\\n    function setString(bytes32 _key, string calldata _value) external;\\n    function setBytes(bytes32 _key, bytes calldata _value) external;\\n    function setBool(bytes32 _key, bool _value) external;\\n    function setInt(bytes32 _key, int _value) external;\\n    function setBytes32(bytes32 _key, bytes32 _value) external;\\n\\n    // Deleters\\n    function deleteAddress(bytes32 _key) external;\\n    function deleteUint(bytes32 _key) external;\\n    function deleteString(bytes32 _key) external;\\n    function deleteBytes(bytes32 _key) external;\\n    function deleteBool(bytes32 _key) external;\\n    function deleteInt(bytes32 _key) external;\\n    function deleteBytes32(bytes32 _key) external;\\n\\n    // Arithmetic\\n    function addUint(bytes32 _key, uint256 _amount) external;\\n    function subUint(bytes32 _key, uint256 _amount) external;\\n\\n    // Protected storage\\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\\n    function confirmWithdrawalAddress(address _nodeAddress) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/casper/DepositInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface DepositInterface {\\n    function deposit(bytes calldata _pubkey, bytes calldata _withdrawalCredentials, bytes calldata _signature, bytes32 _depositDataRoot) external payable;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/dao/node/RocketDAONodeTrustedInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDAONodeTrustedInterface {\\n    function getBootstrapModeDisabled() external view returns (bool);\\n    function getMemberQuorumVotesRequired() external view returns (uint256);\\n    function getMemberAt(uint256 _index) external view returns (address);\\n    function getMemberCount() external view returns (uint256);\\n    function getMemberMinRequired() external view returns (uint256);\\n    function getMemberIsValid(address _nodeAddress) external view returns (bool);\\n    function getMemberLastProposalTime(address _nodeAddress) external view returns (uint256);\\n    function getMemberID(address _nodeAddress) external view returns (string memory);\\n    function getMemberUrl(address _nodeAddress) external view returns (string memory);\\n    function getMemberJoinedTime(address _nodeAddress) external view returns (uint256);\\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) external view returns (uint256);\\n    function getMemberRPLBondAmount(address _nodeAddress) external view returns (uint256);\\n    function getMemberIsChallenged(address _nodeAddress) external view returns (bool);\\n    function getMemberUnbondedValidatorCount(address _nodeAddress) external view returns (uint256);\\n    function incrementMemberUnbondedValidatorCount(address _nodeAddress) external;\\n    function decrementMemberUnbondedValidatorCount(address _nodeAddress) external;\\n    function bootstrapMember(string memory _id, string memory _url, address _nodeAddress) external;\\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) external;\\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) external;\\n    function memberJoinRequired(string memory _id, string memory _url) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../../../types/MinipoolDeposit.sol\\\";\\n\\ninterface RocketDAOProtocolSettingsMinipoolInterface {\\n    function getLaunchBalance() external view returns (uint256);\\n    function getDepositNodeAmount(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getFullDepositNodeAmount() external view returns (uint256);\\n    function getHalfDepositNodeAmount() external view returns (uint256);\\n    function getEmptyDepositNodeAmount() external view returns (uint256);\\n    function getDepositUserAmount(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getFullDepositUserAmount() external view returns (uint256);\\n    function getHalfDepositUserAmount() external view returns (uint256);\\n    function getEmptyDepositUserAmount() external view returns (uint256);\\n    function getSubmitWithdrawableEnabled() external view returns (bool);\\n    function getLaunchTimeout() external view returns (uint256);\\n    function getMaximumCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/deposit/RocketDepositPoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketDepositPoolInterface {\\n    function getBalance() external view returns (uint256);\\n    function getExcessBalance() external view returns (uint256);\\n    function deposit() external payable;\\n    function recycleDissolvedDeposit() external payable;\\n    function recycleExcessCollateral() external payable;\\n    function recycleLiquidatedStake() external payable;\\n    function assignDeposits() external;\\n    function withdrawExcessBalance(uint256 _amount) external;\\n    function getUserLastDepositBlock(address _address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/minipool/RocketMinipoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"../../types/MinipoolStatus.sol\\\";\\nimport \\\"../RocketStorageInterface.sol\\\";\\n\\ninterface RocketMinipoolInterface {\\n    function initialise(address _nodeAddress, MinipoolDeposit _depositType) external;\\n    function getStatus() external view returns (MinipoolStatus);\\n    function getFinalised() external view returns (bool);\\n    function getStatusBlock() external view returns (uint256);\\n    function getStatusTime() external view returns (uint256);\\n    function getDepositType() external view returns (MinipoolDeposit);\\n    function getNodeAddress() external view returns (address);\\n    function getNodeFee() external view returns (uint256);\\n    function getNodeDepositBalance() external view returns (uint256);\\n    function getNodeRefundBalance() external view returns (uint256);\\n    function getNodeDepositAssigned() external view returns (bool);\\n    function getUserDepositBalance() external view returns (uint256);\\n    function getUserDepositAssigned() external view returns (bool);\\n    function getUserDepositAssignedTime() external view returns (uint256);\\n    function getWithdrawalCredentials() external view returns (bytes memory);\\n    function calculateNodeShare(uint256 _balance) external view returns (uint256);\\n    function calculateUserShare(uint256 _balance) external view returns (uint256);\\n    function nodeDeposit() external payable;\\n    function userDeposit() external payable;\\n    function distributeBalance() external;\\n    function distributeBalanceAndFinalise() external;\\n    function refund() external;\\n    function slash() external;\\n    function finalise() external;\\n    function stake(bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external;\\n    function setWithdrawable() external;\\n    function dissolve() external;\\n    function close() external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/minipool/RocketMinipoolManagerInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\nimport \\\"./RocketMinipoolInterface.sol\\\";\\n\\ninterface RocketMinipoolManagerInterface {\\n    function getMinipoolCount() external view returns (uint256);\\n    function getStakingMinipoolCount() external view returns (uint256);\\n    function getFinalisedMinipoolCount() external view returns (uint256);\\n    function getActiveMinipoolCount() external view returns (uint256);\\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) external view returns (uint256, uint256, uint256, uint256, uint256);\\n    function getMinipoolAt(uint256 _index) external view returns (address);\\n    function getNodeMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeActiveMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeStakingMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\\n    function getNodeValidatingMinipoolCount(address _nodeAddress) external view returns (uint256);\\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\\n    function getMinipoolByPubkey(bytes calldata _pubkey) external view returns (address);\\n    function getMinipoolExists(address _minipoolAddress) external view returns (bool);\\n    function getMinipoolPubkey(address _minipoolAddress) external view returns (bytes memory);\\n    function createMinipool(address _nodeAddress, MinipoolDeposit _depositType) external returns (RocketMinipoolInterface);\\n    function destroyMinipool() external;\\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) external;\\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) external;\\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) external;\\n    function setMinipoolPubkey(bytes calldata _pubkey) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/minipool/RocketMinipoolPenaltyInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketMinipoolPenaltyInterface {\\n    // Max penalty rate\\n    function setMaxPenaltyRate(uint256 _rate) external;\\n    function getMaxPenaltyRate() external view returns (uint256);\\n\\n    // Penalty rate\\n    function setPenaltyRate(address _minipoolAddress, uint256 _rate) external;\\n    function getPenaltyRate(address _minipoolAddress) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/minipool/RocketMinipoolQueueInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../../types/MinipoolDeposit.sol\\\";\\n\\ninterface RocketMinipoolQueueInterface {\\n    function getTotalLength() external view returns (uint256);\\n    function getLength(MinipoolDeposit _depositType) external view returns (uint256);\\n    function getTotalCapacity() external view returns (uint256);\\n    function getEffectiveCapacity() external view returns (uint256);\\n    function getNextCapacity() external view returns (uint256);\\n    function getNextDeposit() external view returns (MinipoolDeposit, uint256);\\n    function enqueueMinipool(MinipoolDeposit _depositType, address _minipool) external;\\n    function dequeueMinipool() external returns (address minipoolAddress);\\n    function dequeueMinipoolByDeposit(MinipoolDeposit _depositType) external returns (address minipoolAddress);\\n    function removeMinipool(MinipoolDeposit _depositType) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/network/RocketNetworkFeesInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNetworkFeesInterface {\\n    function getNodeDemand() external view returns (int256);\\n    function getNodeFee() external view returns (uint256);\\n    function getNodeFeeByDemand(int256 _nodeDemand) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/network/RocketNetworkPricesInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNetworkPricesInterface {\\n    function getPricesBlock() external view returns (uint256);\\n    function getRPLPrice() external view returns (uint256);\\n    function getEffectiveRPLStake() external view returns (uint256);\\n    function getEffectiveRPLStakeUpdatedBlock() external view returns (uint256);\\n    function getLatestReportableBlock() external view returns (uint256);\\n    function inConsensus() external view returns (bool);\\n    function submitPrices(uint256 _block, uint256 _rplPrice, uint256 _effectiveRplStake) external;\\n    function executeUpdatePrices(uint256 _block, uint256 _rplPrice, uint256 _effectiveRplStake) external;\\n    function increaseEffectiveRPLStake(uint256 _amount) external;\\n    function decreaseEffectiveRPLStake(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/node/RocketNodeManagerInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNodeManagerInterface {\\n\\n    // Structs\\n    struct TimezoneCount {\\n        string timezone;\\n        uint256 count;\\n    }\\n\\n    function getNodeCount() external view returns (uint256);\\n    function getNodeCountPerTimezone(uint256 offset, uint256 limit) external view returns (TimezoneCount[] memory);\\n    function getNodeAt(uint256 _index) external view returns (address);\\n    function getNodeExists(address _nodeAddress) external view returns (bool);\\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodeTimezoneLocation(address _nodeAddress) external view returns (string memory);\\n    function registerNode(string calldata _timezoneLocation) external;\\n    function setTimezoneLocation(string calldata _timezoneLocation) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/node/RocketNodeStakingInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketNodeStakingInterface {\\n    function getTotalRPLStake() external view returns (uint256);\\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\\n    function getTotalEffectiveRPLStake() external view returns (uint256);\\n    function calculateTotalEffectiveRPLStake(uint256 offset, uint256 limit, uint256 rplPrice) external view returns (uint256);\\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinipoolLimit(address _nodeAddress) external view returns (uint256);\\n    function stakeRPL(uint256 _amount) external;\\n    function withdrawRPL(uint256 _amount) external;\\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/token/RocketTokenRETHInterface.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface RocketTokenRETHInterface is IERC20 {\\n    function getEthValue(uint256 _rethAmount) external view returns (uint256);\\n    function getRethValue(uint256 _ethAmount) external view returns (uint256);\\n    function getExchangeRate() external view returns (uint256);\\n    function getTotalCollateral() external view returns (uint256);\\n    function getCollateralRate() external view returns (uint256);\\n    function depositExcess() external payable;\\n    function depositExcessCollateral() external;\\n    function mint(uint256 _ethAmount, address _to) external;\\n    function burn(uint256 _rethAmount) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/types/MinipoolDeposit.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Represents the type of deposits required by a minipool\\n\\nenum MinipoolDeposit {\\n    None,    // Marks an invalid deposit type\\n    Full,    // The minipool requires 32 ETH from the node operator, 16 ETH of which will be refinanced from user deposits\\n    Half,    // The minipool required 16 ETH from the node operator to be matched with 16 ETH from user deposits\\n    Empty    // The minipool requires 0 ETH from the node operator to be matched with 32 ETH from user deposits (trusted nodes only)\\n}\\n\"\r\n    },\r\n    \"/contracts/types/MinipoolStatus.sol\": {\r\n      \"content\": \"/**\\r\\n  *       .\\r\\n  *      / \\\\\\r\\n  *     |.'.|\\r\\n  *     |'.'|\\r\\n  *   ,'|   |`.\\r\\n  *  |,-'-|-'-.|\\r\\n  *   __|_| |         _        _      _____           _\\r\\n  *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n  *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n  *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n  *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n  * +---------------------------------------------------+\\r\\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\\r\\n  * +---------------------------------------------------+\\r\\n  *\\r\\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\\r\\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\\r\\n  *\\r\\n  *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n  *\\r\\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\\r\\n  *\\r\\n  */\\r\\n\\r\\npragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Represents a minipool's status within the network\\n\\nenum MinipoolStatus {\\n    Initialised,    // The minipool has been initialised and is awaiting a deposit of user ETH\\n    Prelaunch,      // The minipool has enough ETH to begin staking and is awaiting launch by the node operator\\n    Staking,        // The minipool is currently staking\\n    Withdrawable,   // The minipool has become withdrawable on the beacon chain and can be withdrawn from by the node operator\\n    Dissolved       // The minipool has been dissolved and its user deposited ETH has been returned to the deposit pool\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"EtherDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawalProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StatusUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"calculateNodeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"calculateUserShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dissolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeBalanceAndFinalise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositType\",\"outputs\":[{\"internalType\":\"enum MinipoolDeposit\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeDepositAssigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeRefundBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"enum MinipoolStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatusBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatusTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserDepositAssigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserDepositAssignedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawalCredentials\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"},{\"internalType\":\"enum MinipoolDeposit\",\"name\":\"_depositType\",\"type\":\"uint8\"}],\"name\":\"initialise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setWithdrawable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_validatorPubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_validatorSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_depositDataRoot\",\"type\":\"bytes32\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"RocketMinipoolDelegate","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"15000","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c5758a8524a097f40eb2623ac53b7c19836b3e41379ca3e43a25e8393b91ea95"}]}