{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.0;\r\n\r\ninterface ERC721 {\r\n  function safeTransferFrom(address from,address to,uint256 tokenId) external;\r\n}\r\n\r\ninterface ERC20 {\r\n  function transferFrom(address src, address dst, uint wad)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n\r\ncontract Golomtrader {\r\n  mapping(bytes32 => bool) public orderhashes; // keep tracks of orderhashes that are filled or cancelled so they cant be filled again \r\n  address payable owner;\r\n  ERC20 wethcontract;\r\n  event Orderfilled(address indexed from,address indexed to, bytes32 indexed id, uint ethamt,address refferer,uint feeamt);\r\n  event Offerfilled(address indexed from,address indexed to, bytes32 indexed id, uint ethamt,uint feeamt);\r\n  event Ordercancelled(bytes32 indexed id);\r\n\r\n  constructor ()\r\n        public\r\n  {\r\n    owner = payable(msg.sender);\r\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    wethcontract = ERC20(WETH);\r\n  }\r\n\r\n// called by buyer of ERC721 nft with a valid signature from seller of nft and sending the correct eth in the transaction\r\n  function executeOrderIfSignatureMatch(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address contractaddress,\r\n    uint256 deadline,\r\n    uint256 ethamt,\r\n    uint256 tokenid,\r\n    address payable signer,\r\n    uint256 feeamt,\r\n    address refferer\r\n  ) external payable {\r\n    require(block.timestamp < deadline, \"Signed transaction expired\");\r\n\r\n    bytes32 eip712DomainHash = keccak256(\r\n        abi.encode(\r\n            keccak256(\r\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n            ),\r\n            keccak256(bytes(\"GOLOM.IO\")),\r\n            keccak256(bytes(\"1\")),\r\n            1,\r\n            address(this)\r\n        )\r\n    );  \r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address contractaddress,uint tokenid,uint ethamt,uint deadline,uint feeamt,address signer)\"),\r\n          contractaddress,\r\n          tokenid,\r\n          ethamt,\r\n          deadline,\r\n          feeamt,\r\n          signer\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", eip712DomainHash, hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(signaturesigner == signer, \"invalid signature\");\r\n    require(msg.value == ethamt, \"wrong eth amt\");\r\n    require(orderhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    orderhashes[hashStruct]=true; // prevent reentrency and also doesnt allow any order to be filled more then once\r\n    ERC721 nftcontract = ERC721(contractaddress);\r\n    nftcontract.safeTransferFrom(signer,msg.sender ,tokenid); // transfer \r\n\r\n    if (feeamt>0){\r\n      owner.transfer(feeamt); // fee transfer to owner\r\n    }\r\n    signer.transfer(msg.value-feeamt); // transfer of eth to seller of nft\r\n    emit Orderfilled(signer, msg.sender, hashStruct , ethamt , refferer ,feeamt);\r\n  }\r\n\r\n    // invalidates an offchain signature so it cant be filled by anyone\r\n\r\n  function cancelOrder(    \r\n    address contractaddress,\r\n    uint256 deadline,\r\n    uint256 ethamt,\r\n    uint256 tokenid,\r\n    uint256 feeamt\r\n) external{\r\n      bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address contractaddress,uint tokenid,uint ethamt,uint deadline,uint feeamt ,address signer)\"),\r\n          contractaddress,\r\n          tokenid,\r\n          ethamt,\r\n          deadline,\r\n          feeamt,\r\n          msg.sender\r\n        )\r\n    );\r\n        orderhashes[hashStruct]=true;  // no need to check for signature validation since sender can only invalidate his own order\r\n        emit Ordercancelled(hashStruct);\r\n  }\r\n\r\n// returns Keccak256 hash of an order\r\n  function Orderstruct(   \r\n    address contractaddress,\r\n    uint256 deadline,\r\n    uint256 ethamt,\r\n    uint256 tokenid,\r\n    uint256 feeamt,\r\n    address signer\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address contractaddress,uint tokenid,uint ethamt,uint deadline,uint feeamt ,address signer)\"),\r\n          contractaddress,\r\n          tokenid,\r\n          ethamt,\r\n          deadline,\r\n          feeamt,\r\n          signer\r\n        )\r\n    );\r\n    }\r\n\r\n\r\n\r\n\r\n  // called by a seller of nft when he sees an appropriate signed offer for his nft \r\n  // transfers weth from the offer signer to the nftowner with fees to contractowner\r\n  // transfers nft from caller/nftowner to the offer signer\r\n\r\n  function executeOfferIfSignatureMatch(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address contractaddress,\r\n    uint256 deadline,\r\n    uint256 ethamt,\r\n    uint256 tokenid,\r\n    address signer,\r\n    uint256 feeamt\r\n  ) external {\r\n    require(block.timestamp < deadline, \"Signed transaction expired\");\r\n\r\n    bytes32 eip712DomainHash = keccak256(\r\n        abi.encode(\r\n            keccak256(\r\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n            ),\r\n            keccak256(bytes(\"GOLOM.IO\")),\r\n            keccak256(bytes(\"1\")),\r\n            1,\r\n            address(this)\r\n        )\r\n    );  \r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address contractaddress,uint tokenid,uint ethamt,uint deadline,uint feeamt,address signer)\"),\r\n          contractaddress,\r\n          tokenid,\r\n          ethamt,\r\n          deadline,\r\n          feeamt,\r\n          signer\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", eip712DomainHash, hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(signaturesigner == signer, \"invalid signature\");\r\n    require(orderhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    if (feeamt>0){\r\n      require(wethcontract.transferFrom(signer, owner , feeamt),\"error in weth transfer\");\r\n    }\r\n    require(wethcontract.transferFrom(signer, msg.sender, ethamt-feeamt),\"error in weth transfer\");\r\n    orderhashes[hashStruct]=true;\r\n    ERC721 nftcontract = ERC721(contractaddress);\r\n    nftcontract.safeTransferFrom(msg.sender,signer ,tokenid);\r\n    emit Offerfilled(signer, msg.sender, hashStruct , ethamt ,feeamt);\r\n  }\r\n\r\n  // invalidates an offchain signature so it cant be filled by anyone\r\n  function cancelOffer(    \r\n    address contractaddress,\r\n    uint256 deadline,\r\n    uint256 ethamt,\r\n    uint256 tokenid,\r\n    uint256 feeamt\r\n) external{\r\n      bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address contractaddress,uint tokenid,uint ethamt,uint deadline,uint feeamt ,address signer)\"),\r\n          contractaddress,\r\n          tokenid,\r\n          ethamt,\r\n          deadline,\r\n          feeamt,\r\n          msg.sender\r\n        )\r\n    );\r\n      orderhashes[hashStruct]=true;  \r\n      emit Ordercancelled(hashStruct);\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethamt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeamt\",\"type\":\"uint256\"}],\"name\":\"Offerfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Ordercancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethamt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refferer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeamt\",\"type\":\"uint256\"}],\"name\":\"Orderfilled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethamt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeamt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"Orderstruct\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethamt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeamt\",\"type\":\"uint256\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethamt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeamt\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethamt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeamt\",\"type\":\"uint256\"}],\"name\":\"executeOfferIfSignatureMatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethamt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeamt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refferer\",\"type\":\"address\"}],\"name\":\"executeOrderIfSignatureMatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderhashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Golomtrader","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c6adcf7928863bb9b0aa64a0cf98ac25e67e32ea8fd6933420484bbb274e6329"}]}