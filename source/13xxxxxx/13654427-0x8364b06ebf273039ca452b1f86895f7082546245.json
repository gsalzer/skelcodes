{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RainbowRouter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity =0.8.7;\\nimport \\\"./routers/BaseAggregator.sol\\\";\\n\\n/// @title Rainbow swap aggregator contract\\ncontract RainbowRouter is BaseAggregator {\\n    address public owner;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        status = 1;\\n    }\\n\\n    /// @dev modifier that ensures only the owner is allowed to call a specific method\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"ONLY_OWNER\\\");\\n        _;\\n    }\\n\\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\\n    /// @param newOwner address of the new owner\\n    /// Can only be called by the current owner.\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"ZERO_ADDRESS\\\");\\n        owner = newOwner;\\n    }\\n\\n    /// @dev method to withdraw ERC20 tokens (from the fees)\\n    /// @param token address of the token to withdraw\\n    /// @param to address that's receiving the tokens\\n    /// @param amount amount of tokens to withdraw\\n    function withdrawTokenFees(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner {\\n        TransferHelper.safeTransfer(token, to, amount);\\n    }\\n\\n    /// @dev method to withdraw ETH (from the fees)\\n    /// @param to address that's receiving the ETH\\n    /// @param amount amount of ETH to withdraw\\n    function withdrawEthFees(address to, uint256 amount) external onlyOwner {\\n        TransferHelper.safeTransferETH(to, amount);\\n    }\\n\\n    /// @dev method to approve other ERC20s\\n    // This is useful so we can manually preapprove top pairs\\n    // making future swaps consume less gas\\n    /// @param token address of the token to approve\\n    /// @param spender address that will be approved to spend the tokens\\n    /// @param amount allowance amount\\n    function approveToken(\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) external onlyOwner {\\n        TransferHelper.safeApprove(token, spender, amount);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/routers/BaseAggregator.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity =0.8.7;\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../libraries/TransferHelper.sol\\\";\\n\\n/// @title Rainbow base aggregator contract\\ncontract BaseAggregator {\\n    /// @dev Used to prevent re-entrancy\\n    uint256 internal status;\\n\\n    /// @dev modifier that prevents reentrancy attacks on specific methods\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, status will be 1\\n        require(status != 2, \\\"NON_REENTRANT\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        status = 2;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        status = 1;\\n    }\\n\\n    /** INTERNAL **/\\n\\n    /// @dev internal method that executes ERC20 to ETH token swaps with the ability to take a fee from the output\\n    function _fillQuoteTokenToEth(\\n        address sellTokenAddress,\\n        address payable swapTarget,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feePercentageBasisPoints\\n    ) internal {\\n        // 1 - Get the initial eth amount\\n        uint256 initialEthAmount = address(this).balance - msg.value;\\n\\n        // 2 - Move the tokens to this contract\\n        TransferHelper.safeTransferFrom(\\n            sellTokenAddress,\\n            msg.sender,\\n            address(this),\\n            sellAmount\\n        );\\n\\n        // 3 - Approve the aggregator's contract to swap the tokens\\n        if (\\n            IERC20(sellTokenAddress).allowance(address(this), swapTarget) <\\n            sellAmount\\n        ) {\\n            TransferHelper.safeApprove(\\n                sellTokenAddress,\\n                swapTarget,\\n                type(uint256).max\\n            );\\n        }\\n\\n        // 4 - Call the encoded swap function call on the contract at `swapTarget`,\\n        // passing along any ETH attached to this function call to cover protocol fees.\\n        (bool success, ) = swapTarget.call{value: msg.value}(swapCallData);\\n        require(success, \\\"SWAP_CALL_FAILED\\\");\\n\\n        // 5 - Substract the fees and send the rest to the user\\n        // Fees will be held in this contract\\n        uint256 finalEthAmount = address(this).balance;\\n        uint256 ethDiff = finalEthAmount - initialEthAmount;\\n\\n        if (feePercentageBasisPoints > 0) {\\n            uint256 fees = (ethDiff * feePercentageBasisPoints) / 10000;\\n            uint256 amountMinusFees = ethDiff - fees;\\n            TransferHelper.safeTransferETH(msg.sender, amountMinusFees);\\n            // when there's no fee, 1inch sends the fund directly to the user\\n            // we check to prevent sending 0 ETH in that case\\n        } else if (ethDiff > 0) {\\n            TransferHelper.safeTransferETH(msg.sender, ethDiff);\\n        }\\n    }\\n\\n    /// @dev internal method that executes ERC20 to ERC20 token swaps with the ability to take a fee from the input\\n    function _fillQuoteTokenToToken(\\n        address sellTokenAddress,\\n        address buyTokenAddress,\\n        address payable swapTarget,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feeAmount\\n    ) internal {\\n        // 1 - Get the initial balance of the output token\\n        uint256 boughtAmount = IERC20(buyTokenAddress).balanceOf(address(this));\\n\\n        // 2 - Move the tokens to this contract (which includes our fees)\\n        TransferHelper.safeTransferFrom(\\n            sellTokenAddress,\\n            msg.sender,\\n            address(this),\\n            sellAmount\\n        );\\n\\n        // 3 - Approve the aggregator's contract to swap the tokens if needed\\n        if (\\n            IERC20(sellTokenAddress).allowance(address(this), swapTarget) <\\n            sellAmount - feeAmount\\n        ) {\\n            TransferHelper.safeApprove(\\n                sellTokenAddress,\\n                swapTarget,\\n                type(uint256).max\\n            );\\n        }\\n\\n        // 4 - Call the encoded swap function call on the contract at `swapTarget`,\\n        // passing along any ETH attached to this function call to cover protocol fees.\\n        // the swapCallData is passing sellAmount - feeAmount as the input\\n        // so we can keep the fees in this contract\\n        (bool success, ) = swapTarget.call{value: msg.value}(swapCallData);\\n        require(success, \\\"SWAP_CALL_FAILED\\\");\\n\\n        // 5 - Send tokens to the user\\n        boughtAmount =\\n            IERC20(buyTokenAddress).balanceOf(address(this)) -\\n            boughtAmount;\\n        TransferHelper.safeTransfer(buyTokenAddress, msg.sender, boughtAmount);\\n    }\\n\\n    /** EXTERNAL **/\\n\\n    /// @param buyTokenAddress the address of token that the user should receive\\n    /// @param swapTarget the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param feeAmount the amount of ETH that we will take as a fee\\n    function fillQuoteEthToToken(\\n        address buyTokenAddress,\\n        address payable swapTarget,\\n        bytes calldata swapCallData,\\n        uint256 feeAmount\\n    ) public payable nonReentrant {\\n        // 1 - Call the encoded swap function call on the contract at `swapTarget`,\\n        // passing along any ETH attached to this function call to cover protocol fees\\n        // minus our fees, which are kept in this contract\\n        (bool success, ) = swapTarget.call{value: msg.value - feeAmount}(\\n            swapCallData\\n        );\\n        require(success, \\\"SWAP_CALL_FAILED\\\");\\n\\n        // 2 - Send the received tokens back to the user\\n        TransferHelper.safeTransfer(\\n            buyTokenAddress,\\n            msg.sender,\\n            IERC20(buyTokenAddress).balanceOf(address(this))\\n        );\\n    }\\n\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param buyTokenAddress the address of token that the user should receive\\n    /// @param swapTarget the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feeAmount the amount of the tokens to sell that we will take as a fee\\n    function fillQuoteTokenToToken(\\n        address sellTokenAddress,\\n        address buyTokenAddress,\\n        address payable swapTarget,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feeAmount\\n    ) public payable nonReentrant {\\n        _fillQuoteTokenToToken(\\n            sellTokenAddress,\\n            buyTokenAddress,\\n            swapTarget,\\n            swapCallData,\\n            sellAmount,\\n            feeAmount\\n        );\\n    }\\n\\n    /// @dev method that executes ERC20 to ERC20 token swaps with the ability to take a fee from the input\\n    // and accepts a signature to use permit, so the user doesn't have to make an previous approval transaction\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param buyTokenAddress the address of token that the user should receive\\n    /// @param swapTarget the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feeAmount the amount of the tokens to sell that we will take as a fee\\n    /// @param permitSignature struct containing the value, nonce, deadline, v, r and s values of the permit signature\\n    function fillQuoteTokenToTokenWithPermit(\\n        address sellTokenAddress,\\n        address buyTokenAddress,\\n        address payable swapTarget,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feeAmount,\\n        TransferHelper.Permit calldata permitSignature\\n    ) public payable nonReentrant {\\n        // 1 - Apply permit\\n        TransferHelper.permit(\\n            permitSignature,\\n            sellTokenAddress,\\n            msg.sender,\\n            address(this)\\n        );\\n\\n        //2 - Call fillQuoteTokenToToken\\n        _fillQuoteTokenToToken(\\n            sellTokenAddress,\\n            buyTokenAddress,\\n            swapTarget,\\n            swapCallData,\\n            sellAmount,\\n            feeAmount\\n        );\\n    }\\n\\n    /// @dev method that executes ERC20 to ETH token swaps with the ability to take a fee from the output\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param swapTarget the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feePercentageBasisPoints the amount of ETH that we will take as a fee in 10000 basis points\\n    function fillQuoteTokenToEth(\\n        address sellTokenAddress,\\n        address payable swapTarget,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feePercentageBasisPoints\\n    ) public payable nonReentrant {\\n        _fillQuoteTokenToEth(\\n            sellTokenAddress,\\n            swapTarget,\\n            swapCallData,\\n            sellAmount,\\n            feePercentageBasisPoints\\n        );\\n    }\\n\\n    /// @dev method that executes ERC20 to ETH token swaps with the ability to take a fee from the output\\n    // and accepts a signature to use permit, so the user doesn't have to make an previous approval transaction\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param swapTarget the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feePercentageBasisPoints the amount of ETH that we will take as a fee in 10000 basis points\\n    /// @param permitSignature struct containing the amount, nonce, deadline, v, r and s values of the permit signature\\n    function fillQuoteTokenToEthWithPermit(\\n        address sellTokenAddress,\\n        address payable swapTarget,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feePercentageBasisPoints,\\n        TransferHelper.Permit calldata permitSignature\\n    ) public payable nonReentrant {\\n        // 1 - Apply permit\\n        TransferHelper.permit(\\n            permitSignature,\\n            sellTokenAddress,\\n            msg.sender,\\n            address(this)\\n        );\\n\\n        // 2 - call fillQuoteTokenToEth\\n        _fillQuoteTokenToEth(\\n            sellTokenAddress,\\n            swapTarget,\\n            swapCallData,\\n            sellAmount,\\n            feePercentageBasisPoints\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity =0.8.7;\\n\\ninterface IERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity =0.8.7;\\nimport \\\"../interfaces/IERC2612.sol\\\";\\nimport \\\"../interfaces/IDAI.sol\\\";\\n\\n/// @title TransferHelper\\n/// @dev Helper methods for interacting with ERC20 tokens and sending ETH\\nlibrary TransferHelper {\\n    address constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    struct Permit {\\n        uint256 value;\\n        uint256 nonce;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @dev Approval method with revert in case of failure\\n    /// @param token address of the token to approve\\n    /// @param to address to approve\\n    /// @param value amount to approve\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"APPROVE_FAILED\\\"\\n        );\\n    }\\n\\n    /// @dev Transfer method with revert in case of failure\\n    /// @param token address of the token to transfer\\n    /// @param to address to receive the tokens\\n    /// @param value amount to transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    /// @dev TransferFrom method with revert in case of failure\\n    /// @param token address of the token to transfer\\n    /// @param from address to move the tokens from\\n    /// @param to address to receive the tokens\\n    /// @param value amount to transfer\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    /// @dev transfer eth method with revert in case of failure\\n    /// @param to address that will receive ETH\\n    /// @param value amount of ETH to transfer\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /// @dev permit method helper that will handle both known implementations\\n    // DAI vs ERC2612 tokens\\n    /// @param permitSignature bytes containing the encoded permit signature\\n    /// @param tokenAddress address of the token that will be permitted\\n    /// @param holder address that holds the tokens to be permitted\\n    /// @param spender address that will be permitted to spend the tokens\\n    function permit(\\n        Permit memory permitSignature,\\n        address tokenAddress,\\n        address holder,\\n        address spender\\n    ) internal {\\n        if (tokenAddress == DAI_ADDRESS) {\\n            IDAI(tokenAddress).permit(\\n                holder,\\n                spender,\\n                permitSignature.nonce,\\n                permitSignature.deadline,\\n                true,\\n                permitSignature.v,\\n                permitSignature.r,\\n                permitSignature.s\\n            );\\n        } else {\\n            IERC2612(tokenAddress).permit(\\n                holder,\\n                spender,\\n                permitSignature.value,\\n                permitSignature.deadline,\\n                permitSignature.v,\\n                permitSignature.r,\\n                permitSignature.s\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC2612.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity =0.8.7;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC2612 is IERC20 {\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function _nonces(address owner) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDAI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity =0.8.7;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IDAI is IERC20 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"fillQuoteEthToToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentageBasisPoints\",\"type\":\"uint256\"}],\"name\":\"fillQuoteTokenToEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentageBasisPoints\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct TransferHelper.Permit\",\"name\":\"permitSignature\",\"type\":\"tuple\"}],\"name\":\"fillQuoteTokenToEthWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"fillQuoteTokenToToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct TransferHelper.Permit\",\"name\":\"permitSignature\",\"type\":\"tuple\"}],\"name\":\"fillQuoteTokenToTokenWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"RainbowRouter","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}