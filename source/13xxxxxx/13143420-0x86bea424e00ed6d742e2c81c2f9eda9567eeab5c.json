{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/editions/droppable/DroppableEditionsLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {IERC721, IERC721Events, IERC721Receiver, IERC721Metadata, IERC165} from \\\"../../../external/interface/IERC721.sol\\\";\\nimport {IERC2309} from \\\"../../../external/interface/IERC2309.sol\\\";\\nimport {ITreasuryConfig} from \\\"../../../interface/ITreasuryConfig.sol\\\";\\nimport {IMirrorTreasury} from \\\"../../../interface/IMirrorTreasury.sol\\\";\\nimport {InitializedGovernable} from \\\"../../../lib/InitializedGovernable.sol\\\";\\nimport {Pausable} from \\\"../../../lib/Pausable.sol\\\";\\nimport {Reentrancy} from \\\"../../../lib/Reentrancy.sol\\\";\\nimport {DroppableEditionsStorage} from \\\"./DroppableEditionsStorage.sol\\\";\\nimport {IDroppableEditionsLogicEvents} from \\\"./interface/IDroppableEditionsLogic.sol\\\";\\nimport {IProxyRegistry} from '../../../external/opensea/IProxyRegistry.sol';\\n\\n/**\\n * @title DroppableEditionsLogic\\n * @author MirrorXYZ\\n */\\ncontract DroppableEditionsLogic is \\n    DroppableEditionsStorage,\\n    InitializedGovernable,\\n    Pausable,\\n    IDroppableEditionsLogicEvents,\\n    IERC721,\\n    IERC721Events,\\n    IERC165,\\n    IERC721Metadata,\\n    IERC2309,\\n    Reentrancy\\n{\\n\\n    /// @notice IERC721Metadata\\n    string public override name;\\n    string public override symbol;\\n\\n    constructor(\\n        address owner_,\\n        address governor_,\\n        address proxyRegistry_\\n    ) InitializedGovernable(owner_, governor_) Pausable(true) {\\n        proxyRegistry = proxyRegistry_;\\n    }\\n\\n    // ============ Pause Methods ============\\n\\n    /// @notice pause purchases\\n    function pause() public onlyGovernance {\\n        _pause();\\n    }\\n\\n    /// @notice unpause purchases\\n    function unpause() public onlyGovernance {\\n        _unpause();\\n    }\\n\\n    // ============ Edition Methods ============\\n\\n    function purchase(address recipient)\\n        external\\n        payable\\n        whenNotPaused\\n        returns (uint256 tokenId)\\n    {\\n        // Check that recipient has not already purchased\\n        require(!purchased[recipient], \\\"already purchased\\\");\\n        // Check that enough funds have been sent to purchase an edition.\\n        require(msg.value >= price, \\\"insufficient funds\\\");\\n        // Track and update token id.\\n        tokenId = allocation + nonAllocatedPurchases;\\n        // Check that there are still tokens available to purchase.\\n        require(tokenId < quantity, \\\"sold out\\\");\\n        // Mint a new token for the sender, using the `tokenId`.\\n        purchased[recipient] = true;\\n        _mint(recipient, tokenId);\\n        emit EditionPurchased(tokenId, msg.value, msg.sender, recipient);\\n\\n        nonAllocatedPurchases += 1;\\n    }\\n\\n    // ============ NFT Methods ============\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    function balanceOf(address owner_) public view override returns (uint256) {\\n        require(\\n            owner_ != address(0),\\n            \\\"zero address\\\"\\n        );\\n\\n        return _balances[owner_];\\n    }\\n\\n    function burn(uint256 tokenId) public {\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"not approved\\\"\\n        );\\n\\n        _burn(tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public override {\\n        //solhint-disable-next-line max-line-length\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"not approved\\\"\\n        );\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public override {\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"not approved\\\"\\n        );\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(baseURI, _toString(tokenId)));\\n    }\\n\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"current owner\\\");\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\\"not approved\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"nonexistent\\\"\\n        );\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address approver, bool approved)\\n        public\\n        override\\n    {\\n        require(approver != msg.sender, \\\"approve to caller\\\");\\n\\n        _operatorApprovals[msg.sender][approver] = approved;\\n        emit ApprovalForAll(msg.sender, approver, approved);\\n    }\\n\\n    /**\\n     * @notice OpenSea proxy contracts are approved by default.\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        // Approve all OpenSea proxy contracts for easy trading.\\n        if (IProxyRegistry(proxyRegistry).proxies(owner) == operator) {\\n            return true;\\n        }\\n\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /// @notice e.g. https://mirror-api.com/editions/metadata\\n    function contractURI() public view returns (string memory) {\\n        return string(abi.encodePacked(baseURI, \\\"metadata\\\"));\\n    }\\n\\n    /**\\n     * @notice The hash of the given content for the NFT. Can be used\\n     * for IPFS storage, verifying authenticity, etc.\\n     */\\n    function getContentHash(uint256) public view returns (bytes32) {\\n        return contentHash;\\n    }\\n\\n    // ============ Operational Methods ============\\n\\n    function withdrawFunds() external Reentrancy.nonReentrant {\\n        // Transfer the fee to the treasury.\\n        // Treasury fee is paid first for efficiency, so we don't have to calculate\\n        // the fee and the revenue amount. Also prevents a reentrancy attack scenario that\\n        // avoids paying treasury.\\n        uint256 fee = feeAmount(address(this).balance);\\n        IMirrorTreasury(ITreasuryConfig(treasuryConfig).treasury())\\n            .contribute{value: fee}(fee);\\n\\n        // Transfer the remaining available balance to the fundingRecipient.\\n        _sendFunds(fundingRecipient, address(this).balance);\\n    }\\n\\n    function feeAmount(uint256 amount) public view returns (uint256) {\\n        return (feePercentage * amount) / 10000;\\n    }\\n\\n    // ============ Admin Methods ============\\n\\n    function changeBaseURI(string memory baseURI_) public onlyGovernance {\\n        baseURI = baseURI_;\\n    }\\n\\n    // ============ Drop Distribution Methods ============\\n\\n    function purchaseWithProof(\\n        address account,\\n        uint256 allocation,\\n        uint256 price,\\n        uint256 index,\\n        bytes32[] calldata merkleProof\\n    ) external payable {\\n        require(price * allocation <= msg.value, \\\"insufficient funds\\\");\\n\\n        require(\\n            !isClaimed(index, account),\\n            \\\"already claimed\\\"\\n        );\\n\\n        setClaimed(index, account);\\n\\n        require(\\n            verifyProof(\\n                merkleProof,\\n                merkleRoot,\\n                getNode(index, price, account, allocation)\\n            ),\\n            \\\"invalid proof\\\"\\n        );\\n\\n        // \\\"MINT\\\"\\n        indexToClaimer[currentIndexId] = account;\\n        currentIndexId += 1;\\n        claimerToAllocation[account] = allocation;\\n        claimedTokens += allocation;\\n        _balances[account] += allocation;\\n\\n        emit ConsecutiveTransfer(\\n            nextTokenId,\\n            nextTokenId + allocation - 1,\\n            address(0),\\n            account\\n        );\\n\\n        nextTokenId += allocation;\\n    }\\n\\n    function ownerOf(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (address owner)\\n    {\\n        \\n        // Check if we are referring to a token that was preallocated.\\n        if (tokenId < allocation) {\\n            // It may have not been claimed.\\n            require(tokenId < claimedTokens, \\\"nonexistent\\\");\\n\\n            // Check if this token was allocated but then burned.\\n            require(!burned[tokenId], \\\"nonexistent\\\");\\n\\n            // Check if this token was allocated and then transferred.\\n            if (_owners[tokenId] != address(0)) {\\n                // The token was allocated, but then transferred.\\n                return _owners[tokenId];\\n            }\\n            \\n            // The token has been claimed and not transferred!\\n            // We need to find the claimer from this tokenId.\\n            uint256 indexTracker;\\n            for (uint256 i = 0; i < currentIndexId; i++) {\\n                address claimer = indexToClaimer[i];\\n                indexTracker += claimerToAllocation[claimer];\\n                if (tokenId < indexTracker) {\\n                    return claimer;\\n                }\\n            }\\n        }\\n        \\n        owner = _owners[tokenId];\\n\\n        require(owner != address(0), \\\"nonexistent\\\");\\n    }\\n\\n\\n    function isClaimed(uint256 index, address account)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return claimed[getClaimHash(index, account)];\\n    }\\n\\n    function setClaimed(uint256 index, address account) private {\\n        claimed[getClaimHash(index, account)] = true;\\n    }\\n\\n    function getClaimHash(uint256 index, address account)\\n        private\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(index, account));\\n    }\\n\\n    function getNode(uint256 index, uint256 price, address account, uint256 allocation)\\n        private\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(account, allocation, price, index));\\n    }\\n\\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\\n    function verifyProof(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) private pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n\\n\\n    // ============ Private Methods ============\\n\\n    /// @notice from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n    function _toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function _sendFunds(address payable recipient, uint256 amount) private {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"insufficient balance\\\"\\n        );\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"recipient reverted\\\");\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        if (tokenId < allocation && !_burned[tokenId]) {\\n            return true;\\n        }\\n\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        address owner_ = ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        if (_balances[owner_] > 0) {\\n            _balances[owner_] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        _burned[tokenId] = true;\\n\\n        emit Transfer(owner_, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal pure returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, _data),\\n            \\\"non ERC721Receiver\\\"\\n        );\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"nonexistent\\\"\\n        );\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"zero address\\\");\\n        require(!_exists(tokenId), \\\"already minted\\\");\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(\\n            ownerOf(tokenId) == from,\\n            \\\"token not owned\\\"\\n        );\\n        require(\\n            to != address(0),\\n            \\\"zero address\\\"\\n        );\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        if (_balances[from] > 0) {\\n            _balances[from] -= 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n        _balances[to] += 1;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (isContract(to)) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\n                        \\\"non ERC721Receiver\\\"\\n                    );\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f6a1666fac8ecff5dd467d0938069bc221ea9e0/contracts/utils/Address.sol\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\"\r\n    },\r\n    \"contracts/external/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC721 {\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Events {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interface/IERC2309.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC2309 {\\n    event ConsecutiveTransfer(\\n        uint256 indexed fromTokenId,\\n        uint256 toTokenId,\\n        address indexed fromAddress,\\n        address indexed toAddress\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IMirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorTreasury {\\n    function transferFunds(address payable to, uint256 value) external;\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function contributeWithTributary(address tributary) external payable;\\n\\n    function contribute(uint256 amount) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/InitializedGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\nimport {IGovernable} from \\\"../lib/interface/IGovernable.sol\\\";\\n\\ncontract InitializedGovernable is Ownable, IGovernable {\\n    // ============ Events ============\\n\\n    event GovernorChanged(\\n        address indexed previousGovernor,\\n        address indexed newGovernor\\n    );\\n\\n    // ============ Mutable Storage ============\\n\\n    // Mirror governance contract.\\n    address public override governor;\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyGovernance() {\\n        require(isOwner() || isGovernor(), \\\"caller is not governance\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"caller is not governor\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(address owner_, address governor_) Ownable(owner_) {\\n        _setGovernor(governor_);\\n    }\\n\\n    // ============ Administration ============\\n\\n    function changeGovernor(address governor_) public override onlyGovernance {\\n        _setGovernor(governor_);\\n    }\\n\\n    // ============ Utility Functions ============\\n\\n    function isGovernor() public view override returns (bool) {\\n        return msg.sender == governor;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _setGovernor(address governor_) internal {\\n        emit GovernorChanged(governor, governor_);\\n\\n        governor = governor_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IPausableEvents {\\n    /// @notice Emitted when the pause is triggered by `account`.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted by `account`.\\n    event Unpaused(address account);\\n}\\n\\ninterface IPausable {\\n    function paused() external returns (bool);\\n}\\n\\ncontract Pausable is IPausable, IPausableEvents {\\n    bool public override paused;\\n\\n    // Modifiers\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Initializes the contract in unpaused state.\\n    constructor(bool paused_) {\\n        paused = paused_;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Reentrancy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Reentrancy {\\n    // ============ Constants ============\\n\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    // ============ Mutable Storage ============\\n\\n    uint256 internal reentrancyStatus;\\n\\n    // ============ Modifiers ============\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancyStatus != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancyStatus = REENTRANCY_ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip2200)\\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/droppable/DroppableEditionsStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title DroppableEditionsStorage\\n * @author MirrorXYZ\\n */\\ncontract DroppableEditionsStorage {\\n    // ============ Structs ============\\n\\n    /// @notice Contains general data about the NFT.\\n    struct NFTMetadata {\\n        string name;\\n        string symbol;\\n        string baseURI;\\n        bytes32 contentHash;\\n    }\\n\\n    /// @notice Contains information pertaining to the edition spec.\\n    struct EditionData {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        uint256 allocation;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n    }\\n\\n    /// @notice Contains information about funds disbursement.\\n    struct AdminData {\\n        // Operator of this contract.\\n        address operator;\\n        bytes32 merkleRoot;\\n        // Address that receive gov tokens via treasury.\\n        address tributary;\\n        // The account that will receive sales revenue.\\n        address payable fundingRecipient;\\n        // The fee taken when withdrawing funds\\n        uint256 feePercentage;\\n    }\\n\\n    // ============ Storage for Setup ============\\n\\n    /// @notice NFTMetadata`\\n    string public baseURI;\\n    bytes32 contentHash;\\n\\n    /// @notice EditionData\\n    uint256 public allocation;\\n    uint256 public quantity;\\n    uint256 public price;\\n\\n    /// @notice EditionConfig\\n    address public operator;\\n    address public tributary;\\n    address payable public fundingRecipient;\\n    uint256 feePercentage;\\n\\n    /// @notice Treasury Config, provided at setup, for finding the treasury address.\\n    address treasuryConfig;\\n\\n    // ============ Mutable Runtime Storage ============\\n\\n    /// @notice `nextTokenId` increments with each token purchased, globally across all editions.\\n    uint256 internal nextTokenId;\\n    /// @notice The number of tokens that have moved outside of the pre-mint allocation.\\n    uint256 internal allocationsTransferred = 0;\\n\\n    /**\\n     * @notice A special mapping of burned tokens, to take care of burning within\\n     * the tokenId range of the allocation.\\n     */\\n    mapping(uint256 => bool) internal _burned;\\n\\n    // ============ Mutable Internal NFT Storage ============\\n\\n    mapping(uint256 => address) internal _owners;\\n    mapping(address => uint256) internal _balances;\\n    mapping(uint256 => address) internal _tokenApprovals;\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n    /// @notice Only allow one purchase per account.\\n    mapping(address => bool) internal purchased;\\n\\n    // OpenSea's Proxy Registry\\n    address public proxyRegistry;\\n\\n    bytes32 public merkleRoot;\\n\\n    uint256 currentTokenId;\\n    uint256 currentIndexId;\\n    uint256 claimedTokens;\\n    uint256 nonAllocatedPurchases = 0;\\n\\n    mapping(uint256 => bool) public burned;\\n\\n    mapping(uint256 => address) public indexToClaimer;\\n    mapping(address => uint256) public claimerToAllocation;\\n\\n    mapping(bytes32 => bool) public claimed;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice Allows to renounce upgrades\\n    bool public upgradesAllowed = true;\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/droppable/interface/IDroppableEditionsLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IDroppableEditionsLogicEvents {\\n    event EditionPurchased(\\n        uint256 indexed tokenId,\\n        uint256 amountPaid,\\n        address buyer,\\n        address receiver\\n    );\\n\\n    event EditionCreatorChanged(\\n        address indexed previousCreator,\\n        address indexed newCreator\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/external/opensea/IProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\ninterface IProxyRegistry {\\n    function proxies(address) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Ownable {\\n    address public owner;\\n    address private nextOwner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IGovernable {\\n    function changeGovernor(address governor_) external;\\n\\n    function isGovernor() external view returns (bool);\\n\\n    function governor() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proxyRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousCreator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"EditionCreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"EditionPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"changeBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimerToAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getContentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexToClaimer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchaseWithProof\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tributary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradesAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DroppableEditionsLogic","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b570000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b57000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c1","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}