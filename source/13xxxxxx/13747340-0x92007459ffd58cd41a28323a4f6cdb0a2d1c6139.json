{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/distributors/open-sale/MirrorOpenSaleV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {IMirrorOpenSaleV0, IMirrorOpenSaleV0Events} from \\\"./interface/IMirrorOpenSaleV0.sol\\\";\\nimport {Reentrancy} from \\\"../../lib/Reentrancy.sol\\\";\\nimport {IERC165} from \\\"../../lib/ERC165/interface/IERC165.sol\\\";\\nimport {IERC2981} from \\\"../../lib/ERC2981/interface/IERC2981.sol\\\";\\nimport {ITreasuryConfig} from \\\"../../treasury/interface/ITreasuryConfig.sol\\\";\\nimport {IMirrorTreasury} from \\\"../../treasury/interface/IMirrorTreasury.sol\\\";\\nimport {IMirrorFeeRegistry} from \\\"../../fee-registry/MirrorFeeRegistry.sol\\\";\\nimport {IERC721Events} from \\\"../../lib/ERC721/interface/IERC721.sol\\\";\\n\\n/**\\n * @title MirrorOpenSaleV0\\n *\\n * @notice The Mirror Open Sale allows anyone to list an ERC721 with a tokenId range.\\n *\\n * Each token will be sold with tokenId incrementing starting at the lower end of the range.\\n * To minimize storage we hash all sale configuration to generate a unique ID and only store\\n * the necessary data that maintains the sale state.\\n *\\n * The token holder must first approve this contract otherwise purchasing will revert.\\n *\\n * The contract forwards the ether payment to the specified recipient and pays an optional fee\\n * to the Mirror Treasury (0x138c3d30a724de380739aad9ec94e59e613a9008). Additionally, sale\\n * royalties are distributed using the NFT Roylaties Standard (EIP-2981).\\n *\\n * @author MirrorXYZ\\n */\\ncontract MirrorOpenSaleV0 is\\n    IMirrorOpenSaleV0,\\n    IMirrorOpenSaleV0Events,\\n    IERC721Events,\\n    Reentrancy\\n{\\n    /// @notice Version\\n    uint8 public constant VERSION = 0;\\n\\n    /// @notice Mirror treasury configuration\\n    address public immutable override treasuryConfig;\\n\\n    /// @notice Mirror fee registry\\n    address public immutable override feeRegistry;\\n\\n    /// @notice Mirror tributary registry\\n    address public immutable override tributaryRegistry;\\n\\n    /// @notice Map of sale data hash to sale state\\n    mapping(bytes32 => Sale) internal sales_;\\n\\n    /// @notice Store configuration and registry addresses as immutable\\n    /// @param treasuryConfig_ address for Mirror treasury configuration\\n    /// @param feeRegistry_ address for Mirror fee registry\\n    /// @param tributaryRegistry_ address for Mirror tributary registry\\n    constructor(\\n        address treasuryConfig_,\\n        address feeRegistry_,\\n        address tributaryRegistry_\\n    ) {\\n        treasuryConfig = treasuryConfig_;\\n        feeRegistry = feeRegistry_;\\n        tributaryRegistry = tributaryRegistry_;\\n    }\\n\\n    /// @notice Get stored state for a specific sale\\n    /// @param h keccak256 of sale configuration (see `_getHash`)\\n    function sale(bytes32 h) external view override returns (Sale memory) {\\n        return sales_[h];\\n    }\\n\\n    /// @notice Register a sale\\n    /// @dev only the token itself or the operator can list tokens\\n    /// @param saleConfig_ sale configuration\\n    function register(SaleConfig calldata saleConfig_) external override {\\n        require(\\n            msg.sender == saleConfig_.token ||\\n                msg.sender == saleConfig_.operator,\\n            \\\"cannot register\\\"\\n        );\\n\\n        _register(saleConfig_);\\n    }\\n\\n    /// @notice Close a sale\\n    /// @dev Reverts if called by an account that does not operate the sale\\n    /// @param saleConfig_ sale configuration\\n    function close(SaleConfig calldata saleConfig_) external override {\\n        require(msg.sender == saleConfig_.operator, \\\"not operator\\\");\\n\\n        _setSaleStatus(saleConfig_, false);\\n    }\\n\\n    /// @notice Open a sale\\n    /// @dev Reverts if called by an account that does not operate the sale\\n    /// @param saleConfig_ sale configuration\\n    function open(SaleConfig calldata saleConfig_) external override {\\n        require(msg.sender == saleConfig_.operator, \\\"not operator\\\");\\n\\n        _setSaleStatus(saleConfig_, true);\\n    }\\n\\n    /// @notice Purchase a token\\n    /// @dev Reverts if the sale configuration does not hash to an open sale,\\n    ///  not enough ether is sent, he sale is sold out, or if token approval\\n    ///  has not been granted. Sends funds to the recipient and treasury.\\n    /// @param saleConfig_ sale configuration\\n    /// @param recipient account that will receive the purchased token\\n    function purchase(SaleConfig calldata saleConfig_, address recipient)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n    {\\n        // generate hash of sale data\\n        bytes32 h = _getHash(saleConfig_);\\n\\n        // retrive stored sale data\\n        Sale storage s = sales_[h];\\n\\n        // the registered field serves to assert that the hash maps to\\n        // a listed sale and the open field asserts the listed sale is open\\n        require(s.registered && s.open, \\\"closed sale\\\");\\n\\n        // assert correct amount of eth is received\\n        require(msg.value == saleConfig_.price, \\\"incorrect value\\\");\\n\\n        // calculate next tokenId, and increment amount sold\\n        uint256 tokenId = saleConfig_.startTokenId + s.sold++;\\n\\n        // check that the tokenId is valid\\n        require(tokenId <= saleConfig_.endTokenId, \\\"sold out\\\");\\n\\n        // transfer token to recipient\\n        IERC721(saleConfig_.token).transferFrom(\\n            saleConfig_.operator,\\n            recipient,\\n            tokenId\\n        );\\n\\n        emit Purchase(\\n            // h\\n            h,\\n            // token\\n            saleConfig_.token,\\n            // tokenId\\n            tokenId,\\n            // buyer\\n            msg.sender,\\n            // recipient\\n            recipient\\n        );\\n\\n        // send funds to recipient and pay fees if necessary\\n        _withdraw(\\n            saleConfig_.operator,\\n            saleConfig_.token,\\n            tokenId,\\n            h,\\n            saleConfig_.recipient,\\n            msg.value,\\n            saleConfig_.feePercentage\\n        );\\n    }\\n\\n    // ============ Internal Methods ============\\n\\n    function _feeAmount(uint256 amount, uint256 fee)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (amount * fee) / 10_000;\\n    }\\n\\n    function _getHash(SaleConfig calldata saleConfig_)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    saleConfig_.token,\\n                    saleConfig_.startTokenId,\\n                    saleConfig_.endTokenId,\\n                    saleConfig_.operator,\\n                    saleConfig_.recipient,\\n                    saleConfig_.price,\\n                    saleConfig_.open,\\n                    saleConfig_.feePercentage\\n                )\\n            );\\n    }\\n\\n    function _register(SaleConfig calldata saleConfig_) internal {\\n        // get maximum fee from fees registry\\n        uint256 maxFee = IMirrorFeeRegistry(feeRegistry).maxFee();\\n\\n        // allow to pay any fee below the max, including no fees\\n        require(saleConfig_.feePercentage <= maxFee, \\\"fee too high\\\");\\n\\n        // generate hash of sale data\\n        bytes32 h = _getHash(saleConfig_);\\n\\n        // assert the sale has not been registered previously\\n        require(!sales_[h].registered, \\\"sale already registered\\\");\\n\\n        // store critical sale data\\n        sales_[h] = Sale({\\n            registered: true,\\n            open: saleConfig_.open,\\n            sold: 0,\\n            operator: saleConfig_.operator\\n        });\\n\\n        // all fields used to generate the hash need to be emitted to store and\\n        // generate the hash off-chain for interacting with the sale\\n        emit RegisteredSale(\\n            // h\\n            h,\\n            // token\\n            saleConfig_.token,\\n            // startTokenId\\n            saleConfig_.startTokenId,\\n            // endTokenId\\n            saleConfig_.endTokenId,\\n            // operator\\n            saleConfig_.operator,\\n            // recipient\\n            saleConfig_.recipient,\\n            // price\\n            saleConfig_.price,\\n            // open\\n            saleConfig_.open,\\n            // feePercentage\\n            saleConfig_.feePercentage\\n        );\\n\\n        if (saleConfig_.open) {\\n            emit OpenSale(h);\\n        } else {\\n            emit CloseSale(h);\\n        }\\n    }\\n\\n    function _setSaleStatus(SaleConfig calldata saleConfig_, bool status)\\n        internal\\n    {\\n        bytes32 h = _getHash(saleConfig_);\\n\\n        // assert the sale is registered\\n        require(sales_[h].registered, \\\"unregistered sale\\\");\\n\\n        require(sales_[h].open != status, \\\"status already set\\\");\\n\\n        sales_[h].open = status;\\n\\n        if (status) {\\n            emit OpenSale(h);\\n        } else {\\n            emit CloseSale(h);\\n        }\\n    }\\n\\n    function _withdraw(\\n        address operator,\\n        address token,\\n        uint256 tokenId,\\n        bytes32 h,\\n        address recipient,\\n        uint256 totalAmount,\\n        uint256 feePercentage\\n    ) internal {\\n        uint256 feeAmount = 0;\\n\\n        if (feePercentage > 0) {\\n            // calculate fee amount\\n            feeAmount = _feeAmount(totalAmount, feePercentage);\\n\\n            // contribute to treasury\\n            IMirrorTreasury(ITreasuryConfig(treasuryConfig).treasury())\\n                .contributeWithTributary{value: feeAmount}(operator);\\n        }\\n\\n        uint256 saleAmount = totalAmount - feeAmount;\\n\\n        (address royaltyRecipient, uint256 royaltyAmount) = _royaltyInfo(\\n            token,\\n            tokenId,\\n            saleAmount\\n        );\\n\\n        require(royaltyAmount < saleAmount, \\\"invalid royalty amount\\\");\\n\\n        if (msg.sender == royaltyRecipient || royaltyRecipient == address(0)) {\\n            // transfer funds to recipient\\n            _send(payable(recipient), saleAmount);\\n\\n            // emit an event describing the withdrawal\\n            emit Withdraw(h, totalAmount, feeAmount, recipient);\\n        } else {\\n            // transfer funds to recipient\\n            _send(payable(recipient), saleAmount - royaltyAmount);\\n\\n            // transfer royalties\\n            _send(payable(royaltyRecipient), royaltyAmount);\\n\\n            // emit an event describing the withdrawal\\n            emit Withdraw(h, totalAmount, feeAmount, recipient);\\n        }\\n    }\\n\\n    function _royaltyInfo(\\n        address token,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) internal view returns (address royaltyRecipient, uint256 royaltyAmount) {\\n        // get royalty info\\n        if (IERC165(token).supportsInterface(type(IERC2981).interfaceId)) {\\n            (royaltyRecipient, royaltyAmount) = IERC2981(token).royaltyInfo(\\n                tokenId,\\n                amount\\n            );\\n        }\\n    }\\n\\n    function _send(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"recipient reverted\\\");\\n    }\\n}\\n\\ninterface IERC721 {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/distributors/open-sale/interface/IMirrorOpenSaleV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IMirrorOpenSaleV0Events {\\n    event RegisteredSale(\\n        bytes32 h,\\n        address indexed token,\\n        uint256 startTokenId,\\n        uint256 endTokenId,\\n        address indexed operator,\\n        address indexed recipient,\\n        uint256 price,\\n        bool open,\\n        uint256 feePercentage\\n    );\\n\\n    event Purchase(\\n        bytes32 h,\\n        address indexed token,\\n        uint256 tokenId,\\n        address indexed buyer,\\n        address indexed recipient\\n    );\\n\\n    event Withdraw(\\n        bytes32 h,\\n        uint256 amount,\\n        uint256 fee,\\n        address indexed recipient\\n    );\\n\\n    event OpenSale(bytes32 h);\\n\\n    event CloseSale(bytes32 h);\\n}\\n\\ninterface IMirrorOpenSaleV0 {\\n    struct Sale {\\n        bool registered;\\n        bool open;\\n        uint256 sold;\\n        address operator;\\n    }\\n\\n    struct SaleConfig {\\n        address token;\\n        uint256 startTokenId;\\n        uint256 endTokenId;\\n        address operator;\\n        address recipient;\\n        uint256 price;\\n        bool open;\\n        uint256 feePercentage;\\n    }\\n\\n    function treasuryConfig() external returns (address);\\n\\n    function feeRegistry() external returns (address);\\n\\n    function tributaryRegistry() external returns (address);\\n\\n    function sale(bytes32 h) external view returns (Sale memory);\\n\\n    function register(SaleConfig calldata saleConfig_) external;\\n\\n    function close(SaleConfig calldata saleConfig_) external;\\n\\n    function open(SaleConfig calldata saleConfig_) external;\\n\\n    function purchase(SaleConfig calldata saleConfig_, address recipient)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Reentrancy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ncontract Reentrancy {\\n    // ============ Constants ============\\n\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    // ============ Mutable Storage ============\\n\\n    uint256 internal reentrancyStatus;\\n\\n    // ============ Modifiers ============\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancyStatus != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancyStatus = REENTRANCY_ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip2200)\\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC165/interface/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC2981/interface/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\n/**\\n * @title IERC2981\\n * @notice Interface for the NFT Royalty Standard\\n */\\ninterface IERC2981 {\\n    // / bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n\\n    /**\\n     * @notice Called with the sale price to determine how much royalty\\n     *         is owed and to whom.\\n     * @param _tokenId - the NFT asset queried for royalty information\\n     * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n     * @return receiver - address of who should be sent the royalty payment\\n     * @return royaltyAmount - the royalty payment amount for _salePrice\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/interface/IMirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IMirrorTreasury {\\n    function transferFunds(address payable to, uint256 value) external;\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function contributeWithTributary(address tributary) external payable;\\n\\n    function contribute(uint256 amount) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/fee-registry/MirrorFeeRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\n\\ninterface IMirrorFeeRegistry {\\n    function maxFee() external returns (uint256);\\n\\n    function updateMaxFee(uint256 newFee) external;\\n}\\n\\n/**\\n * @title MirrorFeeRegistry\\n * @author MirrorXYZ\\n */\\ncontract MirrorFeeRegistry is IMirrorFeeRegistry, Ownable {\\n    uint256 public override maxFee = 500;\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    function updateMaxFee(uint256 newFee) external override onlyOwner {\\n        maxFee = newFee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC721/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC721 {\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Events {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Burnable is IERC721 {\\n    function burn(uint256 tokenId) external;\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC721Royalties {\\n    function getFeeRecipients(uint256 id)\\n        external\\n        view\\n        returns (address payable[] memory);\\n\\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ncontract Ownable is IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributaryRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"}],\"name\":\"CloseSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"}],\"name\":\"OpenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"name\":\"RegisteredSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct IMirrorOpenSaleV0.SaleConfig\",\"name\":\"saleConfig_\",\"type\":\"tuple\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct IMirrorOpenSaleV0.SaleConfig\",\"name\":\"saleConfig_\",\"type\":\"tuple\"}],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct IMirrorOpenSaleV0.SaleConfig\",\"name\":\"saleConfig_\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct IMirrorOpenSaleV0.SaleConfig\",\"name\":\"saleConfig_\",\"type\":\"tuple\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"}],\"name\":\"sale\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"internalType\":\"struct IMirrorOpenSaleV0.Sale\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tributaryRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MirrorOpenSaleV0","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000021a93be569666527dae0fdbfbe7715299dec12020000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b570000000000000000000000001171b858777120a59a6cc8148edda8982f187cd8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}