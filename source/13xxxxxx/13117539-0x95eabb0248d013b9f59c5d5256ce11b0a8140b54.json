{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/open-zeppelin/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.5;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n  bytes16 private constant alphabet = '0123456789abcdef';\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n   */\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n    if (value == 0) {\\n      return '0';\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n   */\\n  function toHexString(uint256 value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return '0x00';\\n    }\\n    uint256 temp = value;\\n    uint256 length = 0;\\n    while (temp != 0) {\\n      length++;\\n      temp >>= 8;\\n    }\\n    return toHexString(value, length);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n   */\\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n    bytes memory buffer = new bytes(2 * length + 2);\\n    buffer[0] = '0';\\n    buffer[1] = 'x';\\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\\n      buffer[i] = alphabet[value & 0xf];\\n      value >>= 4;\\n    }\\n    require(value == 0, 'Strings: hex length insufficient');\\n    return string(buffer);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\nimport './IERC165.sol';\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/DydxGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { AccessControl } from '../dependencies/open-zeppelin/AccessControl.sol';\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IDydxGovernor } from '../interfaces/IDydxGovernor.sol';\\nimport { IExecutorWithTimelock } from '../interfaces/IExecutorWithTimelock.sol';\\nimport { IGovernanceStrategy } from '../interfaces/IGovernanceStrategy.sol';\\nimport { IProposalValidator } from '../interfaces/IProposalValidator.sol';\\nimport { IVotingStrategy } from '../interfaces/IVotingStrategy.sol';\\nimport { isContract, getChainId } from '../misc/Helpers.sol';\\n\\n/**\\n * @title dYdX governor contract.\\n * @author dYdX\\n *\\n * @notice Main point of interaction for dYdX governance. Holds governance proposals. Delegates to\\n *  the governance strategy contract to determine how voting and proposing powers are counted. The\\n *  content of a proposal is a sequence of function calls. These function calls must be made\\n *  through authorized executor contracts.\\n *\\n *  Functionality includes:\\n *    - Create a proposal\\n *    - Cancel a proposal\\n *    - Queue a proposal\\n *    - Execute a proposal\\n *    - Submit a vote to a proposal\\n *\\n *  Proposal state transitions in success case:\\n *\\n *    Pending => Active => Succeeded => Queued => Executed\\n *\\n *  Proposal state transitions in failure cases:\\n *\\n *    Pending => Active => Failed\\n *    Pending => Active => Succeeded => Queued => Expired\\n *    Pending => Canceled\\n *    Pending => Active => Canceled\\n *    Pending => Active => Succeeded => Canceled\\n *    Pending => Active => Succeeded => Queued => Canceled\\n **/\\ncontract DydxGovernor is\\n  AccessControl,\\n  IDydxGovernor\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\\n  bytes32 public constant ADD_EXECUTOR_ROLE = keccak256('ADD_EXECUTOR_ROLE');\\n\\n  // ============ Storage ============\\n\\n  address private _governanceStrategy;\\n  uint256 private _votingDelay;\\n  uint256 private _proposalsCount;\\n  mapping(uint256 => Proposal) private _proposals;\\n  mapping(address => bool) private _authorizedExecutors;\\n\\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\\n  );\\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256(\\n    'VoteEmitted(uint256 id,bool support)'\\n  );\\n  string public constant EIP712_DOMAIN_NAME = 'dYdX Governance';\\n\\n  constructor(\\n    address governanceStrategy,\\n    uint256 votingDelay,\\n    address addExecutorAdmin\\n  ) {\\n    _setGovernanceStrategy(governanceStrategy);\\n    _setVotingDelay(votingDelay);\\n\\n    // Assign roles.\\n    _setupRole(OWNER_ROLE, msg.sender);\\n    _setupRole(ADD_EXECUTOR_ROLE, addExecutorAdmin);\\n\\n    // Set OWNER_ROLE as the admin for all roles.\\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(ADD_EXECUTOR_ROLE, OWNER_ROLE);\\n  }\\n\\n  struct CreateVars {\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 previousProposalsCount;\\n  }\\n\\n  /**\\n   * @notice Creates a Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  function create(\\n    IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash\\n  ) external override returns (uint256) {\\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\\n    require(\\n      targets.length == values.length &&\\n        targets.length == signatures.length &&\\n        targets.length == calldatas.length &&\\n        targets.length == withDelegatecalls.length,\\n      'INCONSISTENT_PARAMS_LENGTH'\\n    );\\n\\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\\n\\n    require(\\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\\n        this,\\n        msg.sender,\\n        block.number - 1\\n      ),\\n      'PROPOSITION_CREATION_INVALID'\\n    );\\n\\n    CreateVars memory vars;\\n\\n    vars.startBlock = block.number.add(_votingDelay);\\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\\n\\n    vars.previousProposalsCount = _proposalsCount;\\n\\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\\n    newProposal.id = vars.previousProposalsCount;\\n    newProposal.creator = msg.sender;\\n    newProposal.executor = executor;\\n    newProposal.targets = targets;\\n    newProposal.values = values;\\n    newProposal.signatures = signatures;\\n    newProposal.calldatas = calldatas;\\n    newProposal.withDelegatecalls = withDelegatecalls;\\n    newProposal.startBlock = vars.startBlock;\\n    newProposal.endBlock = vars.endBlock;\\n    newProposal.strategy = _governanceStrategy;\\n    newProposal.ipfsHash = ipfsHash;\\n    _proposalsCount = vars.previousProposalsCount + 1;\\n\\n    emit ProposalCreated(\\n      vars.previousProposalsCount,\\n      msg.sender,\\n      executor,\\n      targets,\\n      values,\\n      signatures,\\n      calldatas,\\n      withDelegatecalls,\\n      vars.startBlock,\\n      vars.endBlock,\\n      _governanceStrategy,\\n      ipfsHash\\n    );\\n\\n    return newProposal.id;\\n  }\\n\\n  /**\\n   * @dev Cancels a Proposal. Callable by anyone if the conditions on the executor are fulfilled.\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external override {\\n    ProposalState state = getProposalState(proposalId);\\n    require(\\n      state != ProposalState.Canceled &&\\n        state != ProposalState.Failed &&\\n        state != ProposalState.Expired &&\\n        state != ProposalState.Executed,\\n      'ONLY_BEFORE_EXECUTED'\\n    );\\n\\n    Proposal storage proposal = _proposals[proposalId];\\n    require(\\n      IProposalValidator(address(proposal.executor)).validateProposalCancellation(\\n        this,\\n        proposal.creator,\\n        block.number - 1\\n      ),\\n      'PROPOSITION_CANCELLATION_INVALID'\\n    );\\n    proposal.canceled = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      proposal.executor.cancelTransaction(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n\\n    emit ProposalCanceled(proposalId);\\n  }\\n\\n  /**\\n   * @dev Queue the proposal. Requires that the proposal succeeded.\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external override {\\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\\n    Proposal storage proposal = _proposals[proposalId];\\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      _queueOrRevert(\\n        proposal.executor,\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    proposal.executionTime = executionTime;\\n\\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Execute the proposal. Requires that the proposal is queued.\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable override {\\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\\n    Proposal storage proposal = _proposals[proposalId];\\n    proposal.executed = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    emit ProposalExecuted(proposalId, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   **/\\n  function submitVote(uint256 proposalId, bool support) external override {\\n    return _submitVote(msg.sender, proposalId, support);\\n  }\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external override {\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        keccak256(\\n          abi.encode(\\n            DOMAIN_TYPEHASH,\\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\\n            getChainId(),\\n            address(this)\\n          )\\n        ),\\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\\n      )\\n    );\\n    address signer = ecrecover(digest, v, r, s);\\n    require(signer != address(0), 'INVALID_SIGNATURE');\\n    return _submitVote(signer, proposalId, support);\\n  }\\n\\n  /**\\n   * @dev Set new GovernanceStrategy\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\\n   **/\\n  function setGovernanceStrategy(address governanceStrategy)\\n    external\\n    override\\n    onlyRole(OWNER_ROLE)\\n  {\\n    _setGovernanceStrategy(governanceStrategy);\\n  }\\n\\n  /**\\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param votingDelay new voting delay in terms of blocks\\n   **/\\n  function setVotingDelay(uint256 votingDelay)\\n    external\\n    override\\n    onlyRole(OWNER_ROLE)\\n  {\\n    _setVotingDelay(votingDelay);\\n  }\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors)\\n    public\\n    override\\n    onlyRole(ADD_EXECUTOR_ROLE)\\n  {\\n    for (uint256 i = 0; i < executors.length; i++) {\\n      _authorizeExecutor(executors[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors)\\n    public\\n    override\\n    onlyRole(OWNER_ROLE)\\n  {\\n    for (uint256 i = 0; i < executors.length; i++) {\\n      _unauthorizeExecutor(executors[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Getter of the current GovernanceStrategy address\\n   * @return The address of the current GovernanceStrategy contracts\\n   **/\\n  function getGovernanceStrategy() external view override returns (address) {\\n    return _governanceStrategy;\\n  }\\n\\n  /**\\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n   * Different from the voting duration\\n   * @return The voting delay in number of blocks\\n   **/\\n  function getVotingDelay() external view override returns (uint256) {\\n    return _votingDelay;\\n  }\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\\n    return _authorizedExecutors[executor];\\n  }\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view override returns (uint256) {\\n    return _proposalsCount;\\n  }\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVotes memory object\\n   **/\\n  function getProposalById(uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (ProposalWithoutVotes memory)\\n  {\\n    Proposal storage proposal = _proposals[proposalId];\\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\\n      id: proposal.id,\\n      creator: proposal.creator,\\n      executor: proposal.executor,\\n      targets: proposal.targets,\\n      values: proposal.values,\\n      signatures: proposal.signatures,\\n      calldatas: proposal.calldatas,\\n      withDelegatecalls: proposal.withDelegatecalls,\\n      startBlock: proposal.startBlock,\\n      endBlock: proposal.endBlock,\\n      executionTime: proposal.executionTime,\\n      forVotes: proposal.forVotes,\\n      againstVotes: proposal.againstVotes,\\n      executed: proposal.executed,\\n      canceled: proposal.canceled,\\n      strategy: proposal.strategy,\\n      ipfsHash: proposal.ipfsHash\\n    });\\n\\n    return proposalWithoutVotes;\\n  }\\n\\n  /**\\n   * @notice Get information about a voter's vote on a proposal.\\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    view\\n    override\\n    returns (Vote memory)\\n  {\\n    return _proposals[proposalId].votes[voter];\\n  }\\n\\n  /**\\n   * @notice Get the current state of a proposal.\\n   * @param proposalId id of the proposal\\n   * @return The current state of the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\\n    require(_proposalsCount > proposalId, 'INVALID_PROPOSAL_ID');\\n    Proposal storage proposal = _proposals[proposalId];\\n    if (proposal.canceled) {\\n      return ProposalState.Canceled;\\n    } else if (block.number <= proposal.startBlock) {\\n      return ProposalState.Pending;\\n    } else if (block.number <= proposal.endBlock) {\\n      return ProposalState.Active;\\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\\n      return ProposalState.Failed;\\n    } else if (proposal.executionTime == 0) {\\n      return ProposalState.Succeeded;\\n    } else if (proposal.executed) {\\n      return ProposalState.Executed;\\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\\n      return ProposalState.Expired;\\n    } else {\\n      return ProposalState.Queued;\\n    }\\n  }\\n\\n  function _queueOrRevert(\\n    IExecutorWithTimelock executor,\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory callData,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) internal {\\n    require(\\n      !executor.isActionQueued(\\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\\n      ),\\n      'DUPLICATED_ACTION'\\n    );\\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\\n  }\\n\\n  function _submitVote(\\n    address voter,\\n    uint256 proposalId,\\n    bool support\\n  ) internal {\\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\\n    Proposal storage proposal = _proposals[proposalId];\\n    Vote storage vote = proposal.votes[voter];\\n\\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\\n\\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\\n      voter,\\n      proposal.startBlock\\n    );\\n\\n    if (support) {\\n      proposal.forVotes = proposal.forVotes.add(votingPower);\\n    } else {\\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\\n    }\\n\\n    vote.support = support;\\n    vote.votingPower = uint248(votingPower);\\n\\n    emit VoteEmitted(proposalId, voter, support, votingPower);\\n  }\\n\\n  function _setGovernanceStrategy(address governanceStrategy) internal {\\n    _governanceStrategy = governanceStrategy;\\n\\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\\n  }\\n\\n  function _setVotingDelay(uint256 votingDelay) internal {\\n    _votingDelay = votingDelay;\\n\\n    emit VotingDelayChanged(votingDelay, msg.sender);\\n  }\\n\\n  function _authorizeExecutor(address executor) internal {\\n    _authorizedExecutors[executor] = true;\\n    emit ExecutorAuthorized(executor);\\n  }\\n\\n  function _unauthorizeExecutor(address executor) internal {\\n    _authorizedExecutors[executor] = false;\\n    emit ExecutorUnauthorized(executor);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDydxGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IExecutorWithTimelock } from './IExecutorWithTimelock.sol';\\n\\ninterface IDydxGovernor {\\n\\n  enum ProposalState {\\n    Pending,\\n    Canceled,\\n    Active,\\n    Failed,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed\\n  }\\n\\n  struct Vote {\\n    bool support;\\n    uint248 votingPower;\\n  }\\n\\n  struct Proposal {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct ProposalWithoutVotes {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n  }\\n\\n  /**\\n   * @dev emitted when a new proposal is created\\n   * @param id Id of the proposal\\n   * @param creator address of the creator\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param startBlock block number when vote starts\\n   * @param endBlock block number when vote ends\\n   * @param strategy address of the governanceStrategy contract\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  event ProposalCreated(\\n    uint256 id,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    address[] targets,\\n    uint256[] values,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startBlock,\\n    uint256 endBlock,\\n    address strategy,\\n    bytes32 ipfsHash\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param id Id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 id);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param id Id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param id Id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param id Id of the proposal\\n   * @param voter address of the voter\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\\n\\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\\n\\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\\n\\n  event ExecutorAuthorized(address executor);\\n\\n  event ExecutorUnauthorized(address executor);\\n\\n  /**\\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  function create(\\n    IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Cancels a Proposal, when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   **/\\n  function submitVote(uint256 proposalId, bool support) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Set new GovernanceStrategy\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\\n   **/\\n  function setGovernanceStrategy(address governanceStrategy) external;\\n\\n  /**\\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param votingDelay new voting delay in seconds\\n   **/\\n  function setVotingDelay(uint256 votingDelay) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Getter of the current GovernanceStrategy address\\n   * @return The address of the current GovernanceStrategy contracts\\n   **/\\n  function getGovernanceStrategy() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n   * Different from the voting duration\\n   * @return The voting delay in seconds\\n   **/\\n  function getVotingDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVotes memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from './IDydxGovernor.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Function, called by Governance, that executes a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IGovernanceStrategy {\\n\\n  /**\\n   * @dev Returns the Proposition Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\\n   * @return Power number\\n   **/\\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Proposition Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Voting Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the Vote Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Vote Power\\n   * @return Vote number\\n   **/\\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from './IDydxGovernor.sol';\\n\\ninterface IProposalValidator {\\n\\n  /**\\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be created\\n   **/\\n  function validateCreatorOfProposal(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n   * @param governance Governance Contract\\n   * @param user Address of the user to be challenged.\\n   * @param blockNumber Block Number against which to make the challenge.\\n   * @return true if user has enough power\\n   **/\\n  function isPropositionPowerEnough(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\\n   * @param governance Governance Contract\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return minimum Proposition Power needed\\n   **/\\n  function getMinimumPropositionPowerNeeded(IDydxGovernor governance, uint256 blockNumber)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns whether a proposal passed or not\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isProposalPassed(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n   * @param votingSupply Total number of oustanding voting tokens\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\\n\\n  /**\\n   * @dev Get proposition threshold constant value\\n   * @return the proposition threshold value (100 <=> 1%)\\n   **/\\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\\n\\n  /**\\n   * @dev Get voting duration constant value\\n   * @return the voting duration value in seconds\\n   **/\\n  function VOTING_DURATION() external view returns (uint256);\\n\\n  /**\\n   * @dev Get the vote differential threshold constant value\\n   * to compare with % of for votes/total supply - % of against votes/total supply\\n   * @return the vote differential threshold value (100 <=> 1%)\\n   **/\\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\\n\\n  /**\\n   * @dev Get quorum threshold constant value\\n   * to compare with % of for votes/total supply\\n   * @return the quorum threshold value (100 <=> 1%)\\n   **/\\n  function MINIMUM_QUORUM() external view returns (uint256);\\n\\n  /**\\n   * @dev precision helper: 100% = 10000\\n   * @return one hundred percents with our chosen precision\\n   **/\\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IVotingStrategy {\\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nfunction getChainId() pure returns (uint256) {\\n  uint256 chainId;\\n  assembly {\\n    chainId := chainid()\\n  }\\n  return chainId;\\n}\\n\\nfunction isContract(address account) view returns (bool) {\\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n  // for accounts without code, i.e. `keccak256('')`\\n  bytes32 codehash;\\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n  // solhint-disable-next-line no-inline-assembly\\n  assembly {\\n    codehash := extcodehash(account)\\n  }\\n  return (codehash != accountHash && codehash != 0x0);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/ProposalValidatorMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IDydxGovernor } from '../../interfaces/IDydxGovernor.sol';\\nimport { IGovernanceStrategy } from '../../interfaces/IGovernanceStrategy.sol';\\nimport { IProposalValidator } from '../../interfaces/IProposalValidator.sol';\\n\\n/**\\n * @title Proposal validator contract mixin, inherited the governance executor contract.\\n * @dev Validates/Invalidations propositions state modifications.\\n * Proposition Power functions: Validates proposition creations/ cancellation\\n * Voting Power functions: Validates success of propositions.\\n * @author dYdX\\n **/\\ncontract ProposalValidatorMixin is IProposalValidator {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override PROPOSITION_THRESHOLD;\\n  uint256 public immutable override VOTING_DURATION;\\n  uint256 public immutable override VOTE_DIFFERENTIAL;\\n  uint256 public immutable override MINIMUM_QUORUM;\\n  uint256 public constant override ONE_HUNDRED_WITH_PRECISION = 10000; // Represents 100%.\\n\\n  /**\\n   * @dev Constructor\\n   * @param propositionThreshold minimum percentage of supply needed to submit a proposal\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   * @param votingDuration duration in blocks of the voting period\\n   * @param voteDifferential percentage of supply that `for` votes need to be over `against`\\n   *   in order for the proposal to pass\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   * @param minimumQuorum minimum percentage of the supply in FOR-voting-power need for a proposal to pass\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   **/\\n  constructor(\\n    uint256 propositionThreshold,\\n    uint256 votingDuration,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  ) {\\n    PROPOSITION_THRESHOLD = propositionThreshold;\\n    VOTING_DURATION = votingDuration;\\n    VOTE_DIFFERENTIAL = voteDifferential;\\n    MINIMUM_QUORUM = minimumQuorum;\\n  }\\n\\n  /**\\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be created\\n   **/\\n  function validateCreatorOfProposal(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view override returns (bool) {\\n    return isPropositionPowerEnough(governance, user, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * Needs to creator to have lost proposition power threashold\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view override returns (bool) {\\n    return !isPropositionPowerEnough(governance, user, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n   * @param governance Governance Contract\\n   * @param user Address of the user to be challenged.\\n   * @param blockNumber Block Number against which to make the challenge.\\n   * @return true if user has enough power\\n   **/\\n  function isPropositionPowerEnough(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) public view override returns (bool) {\\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\\n      governance.getGovernanceStrategy()\\n    );\\n    return\\n      currentGovernanceStrategy.getPropositionPowerAt(user, blockNumber) >=\\n      getMinimumPropositionPowerNeeded(governance, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\\n   * @param governance Governance Contract\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return minimum Proposition Power needed\\n   **/\\n  function getMinimumPropositionPowerNeeded(IDydxGovernor governance, uint256 blockNumber)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\\n      governance.getGovernanceStrategy()\\n    );\\n    return\\n      currentGovernanceStrategy\\n        .getTotalPropositionSupplyAt(blockNumber)\\n        .mul(PROPOSITION_THRESHOLD)\\n        .div(ONE_HUNDRED_WITH_PRECISION);\\n  }\\n\\n  /**\\n   * @dev Returns whether a proposal passed or not\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isProposalPassed(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    return (isQuorumValid(governance, proposalId) &&\\n      isVoteDifferentialValid(governance, proposalId));\\n  }\\n\\n  /**\\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n   * @param votingSupply Total number of oustanding voting tokens\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function getMinimumVotingPowerNeeded(uint256 votingSupply)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return votingSupply.mul(MINIMUM_QUORUM).div(ONE_HUNDRED_WITH_PRECISION);\\n  }\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IDydxGovernor governance, uint256 proposalId)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IDydxGovernor.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\\n      proposal.startBlock\\n    );\\n\\n    return proposal.forVotes >= getMinimumVotingPowerNeeded(votingSupply);\\n  }\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IDydxGovernor governance, uint256 proposalId)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IDydxGovernor.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\\n      proposal.startBlock\\n    );\\n\\n    return (proposal.forVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply) >\\n      proposal.againstVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply).add(\\n        VOTE_DIFFERENTIAL\\n      ));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/PriorityExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { PriorityTimelockExecutorMixin } from './PriorityTimelockExecutorMixin.sol';\\nimport { ProposalValidatorMixin } from './ProposalValidatorMixin.sol';\\n\\n/**\\n * @title Time Locked, Validator, Executor Contract\\n * @dev Contract\\n * - Validate Proposal creations / cancellation\\n * - Validate Vote Quorum and Vote success on proposal\\n * - Queue, Execute, Cancel, successful proposals' transactions.\\n * @author dYdX\\n **/\\ncontract PriorityExecutor is PriorityTimelockExecutorMixin, ProposalValidatorMixin {\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    uint256 priorityPeriod,\\n    uint256 propositionThreshold,\\n    uint256 voteDuration,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum,\\n    address priorityExecutor\\n  )\\n    PriorityTimelockExecutorMixin(\\n      admin,\\n      delay,\\n      gracePeriod,\\n      minimumDelay,\\n      maximumDelay,\\n      priorityPeriod,\\n      priorityExecutor\\n    )\\n    ProposalValidatorMixin(\\n      propositionThreshold,\\n      voteDuration,\\n      voteDifferential,\\n      minimumQuorum\\n    )\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/PriorityTimelockExecutorMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IPriorityTimelockExecutor } from '../../interfaces/IPriorityTimelockExecutor.sol';\\nimport { IDydxGovernor } from '../../interfaces/IDydxGovernor.sol';\\n\\n/**\\n * @title Time-locked executor contract mixin, inherited the governance executor contract.\\n * @dev Contract that can queue, execute, cancel transactions voted by Governance\\n * Queued transactions can be executed after a delay and until\\n * Grace period is not over.\\n * @author dYdX\\n **/\\ncontract PriorityTimelockExecutorMixin is IPriorityTimelockExecutor {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override GRACE_PERIOD;\\n  uint256 public immutable override MINIMUM_DELAY;\\n  uint256 public immutable override MAXIMUM_DELAY;\\n\\n  address private _admin;\\n  address private _pendingAdmin;\\n  mapping(address => bool) private _isPriorityController;\\n\\n  uint256 private _delay;\\n  uint256 private _priorityPeriod;\\n\\n  mapping(bytes32 => bool) private _queuedTransactions;\\n  mapping(bytes32 => bool) private _priorityUnlockedTransactions;\\n\\n  /**\\n   * @dev Constructor\\n   * @param admin admin address, that can call the main functions, (Governance)\\n   * @param delay minimum time between queueing and execution of proposal\\n   * @param gracePeriod time after `delay` while a proposal can be executed\\n   * @param minimumDelay lower threshold of `delay`, in seconds\\n   * @param maximumDelay upper threhold of `delay`, in seconds\\n   * @param priorityPeriod time at end of delay period during which a priority controller may “unlock”\\n   * @param priorityController address which may execute proposals during the priority window\\n   *  the proposal for early execution\\n   **/\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    uint256 priorityPeriod,\\n    address priorityController\\n  ) {\\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\\n    _validatePriorityPeriod(delay, priorityPeriod);\\n    _delay = delay;\\n    _priorityPeriod = priorityPeriod;\\n    _admin = admin;\\n\\n    GRACE_PERIOD = gracePeriod;\\n    MINIMUM_DELAY = minimumDelay;\\n    MAXIMUM_DELAY = maximumDelay;\\n\\n    emit NewDelay(delay);\\n    emit NewPriorityPeriod(priorityPeriod);\\n    emit NewAdmin(admin);\\n\\n    _updatePriorityController(priorityController, true);\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == _admin, 'ONLY_BY_ADMIN');\\n    _;\\n  }\\n\\n  modifier onlyTimelock() {\\n    require(msg.sender == address(this), 'ONLY_BY_THIS_TIMELOCK');\\n    _;\\n  }\\n\\n  modifier onlyPendingAdmin() {\\n    require(msg.sender == _pendingAdmin, 'ONLY_BY_PENDING_ADMIN');\\n    _;\\n  }\\n\\n  modifier onlyPriorityController() {\\n    require(_isPriorityController[msg.sender], 'ONLY_BY_PRIORITY_CONTROLLER');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Set the delay\\n   * @param delay delay between queue and execution of proposal\\n   **/\\n  function setDelay(uint256 delay) public onlyTimelock {\\n    _validateDelay(delay);\\n    _validatePriorityPeriod(delay, _priorityPeriod);\\n    _delay = delay;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  /**\\n   * @dev Set the priority period\\n   * @param priorityPeriod time at end of delay period during which a priority controller may “unlock”\\n   *  the proposal for early execution\\n   **/\\n  function setPriorityPeriod(uint256 priorityPeriod) public onlyTimelock {\\n    _validatePriorityPeriod(_delay, priorityPeriod);\\n    _priorityPeriod = priorityPeriod;\\n\\n    emit NewPriorityPeriod(priorityPeriod);\\n  }\\n\\n  /**\\n   * @dev Function enabling pending admin to become admin\\n   **/\\n  function acceptAdmin() public onlyPendingAdmin {\\n    _admin = msg.sender;\\n    _pendingAdmin = address(0);\\n\\n    emit NewAdmin(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Setting a new pending admin (that can then become admin)\\n   * Can only be called by this executor (i.e via proposal)\\n   * @param newPendingAdmin address of the new admin\\n   **/\\n  function setPendingAdmin(address newPendingAdmin) public onlyTimelock {\\n    _pendingAdmin = newPendingAdmin;\\n\\n    emit NewPendingAdmin(newPendingAdmin);\\n  }\\n\\n  /**\\n   * @dev Add or remove a priority controller.\\n   */\\n  function updatePriorityController(address account, bool isPriorityController) public onlyTimelock {\\n    _updatePriorityController(account, isPriorityController);\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\\n\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = true;\\n\\n    emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash of the canceled tx\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = false;\\n\\n    emit CancelledAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall\\n    );\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that executes a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the callData executed as memory bytes\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public payable override onlyAdmin returns (bytes memory) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\\n    require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\\n\\n    // Require either that:\\n    //  - the timelock elapsed; or\\n    //  - the transaction was unlocked by a priority controller, and we are in the priority\\n    //    execution window.\\n    if (_priorityUnlockedTransactions[actionHash]) {\\n      require(block.timestamp >= executionTime.sub(_priorityPeriod), 'NOT_IN_PRIORITY_WINDOW');\\n    } else {\\n      require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\\n    }\\n\\n    _queuedTransactions[actionHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    bool success;\\n    bytes memory resultData;\\n    if (withDelegatecall) {\\n      require(msg.value >= value, \\\"NOT_ENOUGH_MSG_VALUE\\\");\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.delegatecall(callData);\\n    } else {\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.call{value: value}(callData);\\n    }\\n\\n    require(success, 'FAILED_ACTION_EXECUTION');\\n\\n    emit ExecutedAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall,\\n      resultData\\n    );\\n\\n    return resultData;\\n  }\\n\\n  /**\\n   * @dev Function, called by a priority controller, to lock or unlock a proposal for execution\\n   *  during the priority period.\\n   * @param actionHash hash of the action\\n   * @param isUnlockedForExecution whether the proposal is executable during the priority period\\n   */\\n  function setTransactionPriorityStatus(\\n    bytes32 actionHash,\\n    bool isUnlockedForExecution\\n  ) public onlyPriorityController {\\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\\n    _priorityUnlockedTransactions[actionHash] = isUnlockedForExecution;\\n    emit UpdatedActionPriorityStatus(actionHash, isUnlockedForExecution);\\n  }\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view override returns (address) {\\n    return _admin;\\n  }\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view override returns (address) {\\n    return _pendingAdmin;\\n  }\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view override returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @dev Getter of the priority period, which is amount of time before mandatory\\n   * timelock delay that a proposal can be executed early only by a priority controller.\\n   * @return The priority period in seconds.\\n   **/\\n  function getPriorityPeriod() external view returns (uint256) {\\n    return _priorityPeriod;\\n  }\\n\\n  /**\\n   * @dev Getter for whether an address is a priority controller.\\n   * @param account address to check for being a priority controller\\n   * @return True if `account` is a priority controller, false if not.\\n   **/\\n  function isPriorityController(address account) external view returns (bool) {\\n    return _isPriorityController[account];\\n  }\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view override returns (bool) {\\n    return _queuedTransactions[actionHash];\\n  }\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) has priority status\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function hasPriorityStatus(bytes32 actionHash) external view returns (bool) {\\n    return _priorityUnlockedTransactions[actionHash];\\n  }\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IDydxGovernor.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n\\n    return (block.timestamp > proposal.executionTime.add(GRACE_PERIOD));\\n  }\\n\\n  function _updatePriorityController(address account, bool isPriorityController) internal {\\n    _isPriorityController[account] = isPriorityController;\\n    emit PriorityControllerUpdated(account, isPriorityController);\\n  }\\n\\n  function _validateDelay(uint256 delay) internal view {\\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\\n  }\\n\\n  function _validatePriorityPeriod(uint256 delay, uint256 priorityPeriod) internal view {\\n    require(priorityPeriod <= delay, 'PRIORITY_PERIOD_LONGER_THAN_DELAY');\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriorityTimelockExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from './IDydxGovernor.sol';\\nimport { IExecutorWithTimelock } from './IExecutorWithTimelock.sol';\\n\\ninterface IPriorityTimelockExecutor is IExecutorWithTimelock {\\n\\n  /**\\n   * @dev emitted when a priority controller is added or removed\\n   * @param account address added or removed\\n   * @param isPriorityController whether the account is now a priority controller\\n   */\\n  event PriorityControllerUpdated(address account, bool isPriorityController);\\n\\n\\n  /**\\n   * @dev emitted when a new priority period is set\\n   * @param priorityPeriod new priority period\\n   **/\\n  event NewPriorityPeriod(uint256 priorityPeriod);\\n\\n  /**\\n   * @dev emitted when an action is locked or unlocked for execution by a priority controller\\n   * @param actionHash hash of the action\\n   * @param isUnlockedForExecution whether the proposal is executable during the priority period\\n   */\\n  event UpdatedActionPriorityStatus(bytes32 actionHash, bool isUnlockedForExecution);\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/FlashAttacks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from '../interfaces/IDydxGovernor.sol';\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\nimport { IExecutorWithTimelock } from '../interfaces/IExecutorWithTimelock.sol';\\n\\ncontract FlashAttacks {\\n\\n  IERC20 internal immutable TOKEN;\\n  address internal immutable MINTER;\\n  IDydxGovernor internal immutable GOV;\\n\\n  constructor(address _token, address _MINTER, address _governance) {\\n    TOKEN = IERC20(_token);\\n    MINTER = _MINTER;\\n    GOV = IDydxGovernor(_governance);\\n  }\\n\\n  function flashVote(uint256 votePower, uint256 proposalId, bool support) external {\\n    TOKEN.transferFrom(MINTER,address(this), votePower);\\n    GOV.submitVote(proposalId, support);\\n    TOKEN.transfer(MINTER, votePower);\\n  }\\n\\n  function flashVotePermit(uint256 votePower, uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s) external {\\n    TOKEN.transferFrom(MINTER, address(this), votePower);\\n    GOV.submitVoteBySignature(proposalId, support, v, r, s);\\n    TOKEN.transfer(MINTER, votePower);\\n  }\\n\\n  function flashProposal(uint256 proposalPower, IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash) external {\\n    TOKEN.transferFrom(MINTER, address(this),proposalPower);\\n    GOV.create(executor, targets, values, signatures, calldatas, withDelegatecalls, ipfsHash);\\n    TOKEN.transfer(MINTER, proposalPower);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/ExecutorWithTimelockMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IExecutorWithTimelock } from '../../interfaces/IExecutorWithTimelock.sol';\\nimport { IDydxGovernor } from '../../interfaces/IDydxGovernor.sol';\\n\\n/**\\n * @title Time-locked executor contract mixin, inherited the governance executor contract.\\n * @dev Contract that can queue, execute, cancel transactions voted by Governance\\n * Queued transactions can be executed after a delay and until\\n * Grace period is not over.\\n * @author dYdX\\n **/\\ncontract ExecutorWithTimelockMixin is IExecutorWithTimelock {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override GRACE_PERIOD;\\n  uint256 public immutable override MINIMUM_DELAY;\\n  uint256 public immutable override MAXIMUM_DELAY;\\n\\n  address private _admin;\\n  address private _pendingAdmin;\\n  uint256 private _delay;\\n\\n  mapping(bytes32 => bool) private _queuedTransactions;\\n\\n  /**\\n   * @dev Constructor\\n   * @param admin admin address, that can call the main functions, (Governance)\\n   * @param delay minimum time between queueing and execution of proposal\\n   * @param gracePeriod time after `delay` while a proposal can be executed\\n   * @param minimumDelay lower threshold of `delay`, in seconds\\n   * @param maximumDelay upper threhold of `delay`, in seconds\\n   **/\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay\\n  ) {\\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\\n    _delay = delay;\\n    _admin = admin;\\n\\n    GRACE_PERIOD = gracePeriod;\\n    MINIMUM_DELAY = minimumDelay;\\n    MAXIMUM_DELAY = maximumDelay;\\n\\n    emit NewDelay(delay);\\n    emit NewAdmin(admin);\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == _admin, 'ONLY_BY_ADMIN');\\n    _;\\n  }\\n\\n  modifier onlyTimelock() {\\n    require(msg.sender == address(this), 'ONLY_BY_THIS_TIMELOCK');\\n    _;\\n  }\\n\\n  modifier onlyPendingAdmin() {\\n    require(msg.sender == _pendingAdmin, 'ONLY_BY_PENDING_ADMIN');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Set the delay\\n   * @param delay delay between queue and execution of proposal\\n   **/\\n  function setDelay(uint256 delay) public onlyTimelock {\\n    _validateDelay(delay);\\n    _delay = delay;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  /**\\n   * @dev Function enabling pending admin to become admin\\n   **/\\n  function acceptAdmin() public onlyPendingAdmin {\\n    _admin = msg.sender;\\n    _pendingAdmin = address(0);\\n\\n    emit NewAdmin(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Setting a new pending admin (that can then become admin)\\n   * Can only be called by this executor (i.e via proposal)\\n   * @param newPendingAdmin address of the new admin\\n   **/\\n  function setPendingAdmin(address newPendingAdmin) public onlyTimelock {\\n    _pendingAdmin = newPendingAdmin;\\n\\n    emit NewPendingAdmin(newPendingAdmin);\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that queues a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\\n\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = true;\\n\\n    emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash of the canceled tx\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = false;\\n\\n    emit CancelledAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall\\n    );\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that executes a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the callData executed as memory bytes\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public payable override onlyAdmin returns (bytes memory) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\\n    require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\\n    require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\\n\\n    _queuedTransactions[actionHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    bool success;\\n    bytes memory resultData;\\n    if (withDelegatecall) {\\n      require(msg.value >= value, \\\"NOT_ENOUGH_MSG_VALUE\\\");\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.delegatecall(callData);\\n    } else {\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.call{value: value}(callData);\\n    }\\n\\n    require(success, 'FAILED_ACTION_EXECUTION');\\n\\n    emit ExecutedAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall,\\n      resultData\\n    );\\n\\n    return resultData;\\n  }\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view override returns (address) {\\n    return _admin;\\n  }\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view override returns (address) {\\n    return _pendingAdmin;\\n  }\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view override returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view override returns (bool) {\\n    return _queuedTransactions[actionHash];\\n  }\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IDydxGovernor.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n\\n    return (block.timestamp > proposal.executionTime.add(GRACE_PERIOD));\\n  }\\n\\n  function _validateDelay(uint256 delay) internal view {\\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\n/**\\n * @title Math\\n * @author dYdX\\n *\\n * @dev Library for non-standard Math functions.\\n */\\nlibrary Math {\\n  using SafeMath for uint256;\\n\\n  // ============ Library Functions ============\\n\\n  /**\\n   * @dev Return `ceil(numerator / denominator)`.\\n   */\\n  function divRoundUp(uint256 numerator, uint256 denominator) internal pure returns (uint256) {\\n    if (numerator == 0) {\\n      // SafeMath will check for zero denominator\\n      return SafeMath.div(0, denominator);\\n    }\\n    return numerator.sub(1).div(denominator).add(1);\\n  }\\n\\n  /**\\n   * @dev Returns the minimum between a and b.\\n   */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the maximum between a and b.\\n   */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/TreasuryVester.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\ncontract TreasuryVester {\\n    using SafeMath for uint256;\\n\\n    address public dydx;\\n    address public recipient;\\n\\n    uint256 public vestingAmount;\\n    uint256 public vestingBegin;\\n    uint256 public vestingCliff;\\n    uint256 public vestingEnd;\\n\\n    uint256 public lastUpdate;\\n\\n    constructor(\\n        address dydx_,\\n        address recipient_,\\n        uint256 vestingAmount_,\\n        uint256 vestingBegin_,\\n        uint256 vestingCliff_,\\n        uint256 vestingEnd_\\n    ) {\\n        require(vestingBegin_ >= block.timestamp, 'VESTING_BEGIN_TOO_EARLY');\\n        require(vestingCliff_ >= vestingBegin_, 'VESTING_CLIFF_BEFORE_BEGIN');\\n        require(vestingEnd_ > vestingCliff_, 'VESTING_END_BEFORE_CLIFF');\\n\\n        dydx = dydx_;\\n        recipient = recipient_;\\n\\n        vestingAmount = vestingAmount_;\\n        vestingBegin = vestingBegin_;\\n        vestingCliff = vestingCliff_;\\n        vestingEnd = vestingEnd_;\\n\\n        lastUpdate = vestingBegin;\\n    }\\n\\n    function setRecipient(address recipient_) public {\\n        require(msg.sender == recipient, 'SET_RECIPIENT_UNAUTHORIZED');\\n        recipient = recipient_;\\n    }\\n\\n    function claim() public {\\n        require(block.timestamp >= vestingCliff, 'CLAIM_TOO_EARLY');\\n        uint256 amount;\\n        if (block.timestamp >= vestingEnd) {\\n            amount = IDydx(dydx).balanceOf(address(this));\\n        } else {\\n            amount = vestingAmount.mul(block.timestamp - lastUpdate).div(vestingEnd - vestingBegin);\\n            lastUpdate = block.timestamp;\\n        }\\n        IDydx(dydx).transfer(recipient, amount);\\n    }\\n}\\n\\ninterface IDydx {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address dst, uint256 rawAmount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/ClaimsProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\ninterface ISafetyModuleV1 {\\n  function claimRewardsFor(\\n    address staker,\\n    address recipient\\n  )\\n    external\\n    returns (uint256);\\n}\\n\\ninterface ILiquidityStakingV1 {\\n  function claimRewardsFor(\\n    address staker,\\n    address recipient\\n  )\\n    external\\n    returns (uint256);\\n}\\n\\ninterface IMerkleDistributorV1 {\\n  function claimRewardsFor(\\n    address user,\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    returns (uint256);\\n}\\n\\ninterface ITreasuryVester {\\n  function claim() external;\\n}\\n\\n/**\\n * @title ClaimsProxy\\n * @author dYdX\\n *\\n * @notice Contract which claims DYDX rewards from multiple contracts on behalf of a user.\\n *\\n *  Requires the following permissions:\\n *    - Set as the CLAIMS_PROXY on the SafetyModuleV1 contract.\\n *    - Has role CLAIM_OPERATOR_ROLE on the LiquidityStakingV1 contract.\\n *    - Has role CLAIM_OPERATOR_ROLE on the MerkleDistributorV1 contract.\\n */\\ncontract ClaimsProxy {\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  ISafetyModuleV1 public immutable SAFETY_MODULE;\\n  ILiquidityStakingV1 public immutable LIQUIDITY_STAKING;\\n  IMerkleDistributorV1 public immutable MERKLE_DISTRIBUTOR;\\n  ITreasuryVester public immutable REWARDS_TREASURY_VESTER;\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    ISafetyModuleV1 safetyModule,\\n    ILiquidityStakingV1 liquidityStaking,\\n    IMerkleDistributorV1 merkleDistributor,\\n    ITreasuryVester rewardsTreasuryVester\\n  ) {\\n    SAFETY_MODULE = safetyModule;\\n    LIQUIDITY_STAKING = liquidityStaking;\\n    MERKLE_DISTRIBUTOR = merkleDistributor;\\n    REWARDS_TREASURY_VESTER = rewardsTreasuryVester;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Claim rewards from zero or more rewards contracts. All rewards are sent directly to\\n   *  the sender's address.\\n   *\\n   * @param  claimSafetyRewards       Whether or not to claim rewards from SafetyModuleV1.\\n   * @param  claimLiquidityRewards    Whether or not to claim rewards from LiquidityStakingV1.\\n   * @param  merkleCumulativeAmount   The cumulative rewards amount for the user in the\\n   *                                  MerkleDistributorV1 rewards Merkle tree, or zero to skip\\n   *                                  claiming from this contract.\\n   * @param  merkleProof              The Merkle proof for the user's cumulative rewards.\\n   * @param  vestFromTreasuryVester   Whether or not to vest rewards from the rewards treasury\\n   *                                  vester to the rewards treasury (e.g. set to true if rewards\\n   *                                  treasury has insufficient funds for users, and false otherwise).\\n   *\\n   * @return The total number of rewards claimed.\\n   */\\n  function claimRewards(\\n    bool claimSafetyRewards,\\n    bool claimLiquidityRewards,\\n    uint256 merkleCumulativeAmount,\\n    bytes32[] calldata merkleProof,\\n    bool vestFromTreasuryVester\\n  )\\n    external\\n    returns (uint256)\\n  {\\n    if (vestFromTreasuryVester) {\\n      // call rewards treasury vester so that rewards treasury has sufficient rewards\\n      REWARDS_TREASURY_VESTER.claim();\\n    }\\n\\n    address user = msg.sender;\\n\\n    uint256 amount1 = 0;\\n    uint256 amount2 = 0;\\n    uint256 amount3 = 0;\\n\\n    if (claimSafetyRewards) {\\n      amount1 = SAFETY_MODULE.claimRewardsFor(user, user);\\n    }\\n    if (claimLiquidityRewards) {\\n      amount2 = LIQUIDITY_STAKING.claimRewardsFor(user, user);\\n    }\\n    if (merkleCumulativeAmount != 0) {\\n      amount3 = MERKLE_DISTRIBUTOR.claimRewardsFor(user, merkleCumulativeAmount, merkleProof);\\n    }\\n\\n    return amount1.add(amount2).add(amount3);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/MerkleDistributorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { Ownable } from '../../dependencies/open-zeppelin/Ownable.sol';\\nimport { MerkleProof } from '../../dependencies/open-zeppelin/MerkleProof.sol';\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { IRewardsOracle } from '../../interfaces/IRewardsOracle.sol';\\nimport { MD1Claims } from './impl/MD1Claims.sol';\\nimport { MD1RootUpdates } from './impl/MD1RootUpdates.sol';\\nimport { MD1Configuration } from './impl/MD1Configuration.sol';\\nimport { MD1Getters } from './impl/MD1Getters.sol';\\n\\n/**\\n * @title MerkleDistributorV1\\n * @author dYdX\\n *\\n * @notice Distributes DYDX token rewards according to a Merkle tree of balances. The tree can be\\n *  updated periodially with each user's cumulative rewards balance, allowing new rewards to be\\n *  distributed to users over time.\\n *\\n *  An update is performed by setting the proposed Merkle root to the latest value returned by\\n *  the oracle contract. The proposed Merkle root can be made active after a waiting period has\\n *  elapsed. During the waiting period, dYdX governance has the opportunity to freeze the Merkle\\n *  root, in case the proposed root is incorrect or malicious.\\n */\\ncontract MerkleDistributorV1 is\\n  MD1RootUpdates,\\n  MD1Claims,\\n  MD1Configuration,\\n  MD1Getters\\n{\\n  // ============ Constructor ============\\n\\n  constructor(\\n    address rewardsToken,\\n    address rewardsTreasury\\n  )\\n    MD1Claims(rewardsToken, rewardsTreasury)\\n    {}\\n\\n  // ============ External Functions ============\\n\\n  function initialize(\\n    address rewardsOracle,\\n    string calldata ipnsName,\\n    uint256 ipfsUpdatePeriod,\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha,\\n    uint256 epochInterval,\\n    uint256 epochOffset\\n  )\\n    external\\n    initializer\\n  {\\n    __MD1Roles_init();\\n    __MD1Configuration_init(\\n      rewardsOracle,\\n      ipnsName,\\n      ipfsUpdatePeriod,\\n      marketMakerRewardsAmount,\\n      traderRewardsAmount,\\n      traderScoreAlpha\\n    );\\n    __MD1EpochSchedule_init(epochInterval, epochOffset);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @dev Returns the revision of the implementation contract. Used by VersionedInitializable.\\n   *\\n   * @return The revision number.\\n   */\\n  function getRevision()\\n    internal\\n    pure\\n    override\\n    returns (uint256)\\n  {\\n    return 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './Context.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardsOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\ninterface IRewardsOracle {\\n\\n  /**\\n   * @notice Returns the oracle value, agreed upon by all oracle signers. If the signers have not\\n   *  agreed upon a value, should return zero for all return values.\\n   *\\n   * @return  merkleRoot  The Merkle root for the next Merkle distributor update.\\n   * @return  epoch       The epoch number corresponding to the new Merkle root.\\n   * @return  ipfsCid     An IPFS CID pointing to the Merkle tree data.\\n   */\\n  function read()\\n    external\\n    virtual\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid);\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Claims.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { MerkleProof } from '../../../dependencies/open-zeppelin/MerkleProof.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { MD1Roles } from './MD1Roles.sol';\\n\\n/**\\n * @title MD1Claims\\n * @author dYdX\\n *\\n * @notice Allows rewards to be claimed by providing a Merkle proof of the rewards amount.\\n */\\nabstract contract MD1Claims is\\n  MD1Roles\\n{\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @notice The token distributed as rewards.\\n  IERC20 public immutable REWARDS_TOKEN;\\n\\n  /// @notice Address to pull rewards from. Must have provided an allowance to this contract.\\n  address public immutable REWARDS_TREASURY;\\n\\n  // ============ Events ============\\n\\n  /// @notice Emitted when a user claims rewards.\\n  event RewardsClaimed(\\n    address account,\\n    uint256 amount\\n  );\\n\\n  /// @notice Emitted when a user opts into or out of the claim-for allowlist.\\n  event AlwaysAllowClaimForUpdated(\\n    address user,\\n    bool allow\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    address rewardsToken,\\n    address rewardsTreasury\\n  ) {\\n    REWARDS_TOKEN = IERC20(rewardsToken);\\n    REWARDS_TREASURY = rewardsTreasury;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Claim the remaining unclaimed rewards for the sender.\\n   *\\n   *  Reverts if the provided Merkle proof is invalid.\\n   *\\n   * @param  cumulativeAmount  The total all-time rewards this user has earned.\\n   * @param  merkleProof       The Merkle proof for the user and cumulative amount.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function claimRewards(\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    return _claimRewards(msg.sender, cumulativeAmount, merkleProof);\\n  }\\n\\n  /**\\n   * @notice Claim the remaining unclaimed rewards for a user, and send them to that user.\\n   *\\n   *  The caller must be authorized with CLAIM_OPERATOR_ROLE unless the specified user has opted\\n   *  into the claim-for allowlist. In any case, rewards are transfered to the original user\\n   *  specified in the Merkle tree.\\n   *\\n   *  Reverts if the provided Merkle proof is invalid.\\n   *\\n   * @param  user              Address of the user on whose behalf to trigger a claim.\\n   * @param  cumulativeAmount  The total all-time rewards this user has earned.\\n   * @param  merkleProof       The Merkle proof for the user and cumulative amount.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function claimRewardsFor(\\n    address user,\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    require(\\n      (\\n        hasRole(CLAIM_OPERATOR_ROLE, msg.sender) ||\\n        _ALWAYS_ALLOW_CLAIMS_FOR_[user]\\n      ),\\n      'MD1Claims: Do not have permission to claim for this user'\\n    );\\n    return _claimRewards(user, cumulativeAmount, merkleProof);\\n  }\\n\\n  /**\\n   * @notice Opt into allowing anyone to claim on the sender's behalf.\\n   *\\n   *  Note that this does not affect who receives the funds. The user specified in the Merkle tree\\n   *  receives those rewards regardless of who issues the claim.\\n   *\\n   *  Note that addresses with the CLAIM_OPERATOR_ROLE ignore this allowlist when triggering claims.\\n   *\\n   * @param  allow  Whether or not to allow claims on the sender's behalf.\\n   */\\n  function setAlwaysAllowClaimsFor(\\n    bool allow\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _ALWAYS_ALLOW_CLAIMS_FOR_[msg.sender] = allow;\\n    emit AlwaysAllowClaimForUpdated(msg.sender, allow);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @notice Claim the remaining unclaimed rewards for a user, and send them to that user.\\n   *\\n   *  Reverts if the provided Merkle proof is invalid.\\n   *\\n   * @param  user              Address of the user.\\n   * @param  cumulativeAmount  The total all-time rewards this user has earned.\\n   * @param  merkleProof       The Merkle proof for the user and cumulative amount.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function _claimRewards(\\n    address user,\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    // Get the active Merkle root.\\n    bytes32 merkleRoot = _ACTIVE_ROOT_.merkleRoot;\\n\\n    // Verify the Merkle proof.\\n    bytes32 node = keccak256(abi.encodePacked(user, cumulativeAmount));\\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MD1Claims: Invalid Merkle proof');\\n\\n    // Get the claimable amount.\\n    //\\n    // Note: If this reverts, then there was an error in the Merkle tree, since the cumulative\\n    // amount for a given user should never decrease over time.\\n    uint256 claimable = cumulativeAmount.sub(_CLAIMED_[user]);\\n\\n    if (claimable == 0) {\\n      return 0;\\n    }\\n\\n    // Mark the user as having claimed the full amount.\\n    _CLAIMED_[user] = cumulativeAmount;\\n\\n    // Send the user the claimable amount.\\n    REWARDS_TOKEN.safeTransferFrom(REWARDS_TREASURY, user, claimable);\\n\\n    emit RewardsClaimed(user, claimable);\\n\\n    return claimable;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1RootUpdates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { MerkleProof } from '../../../dependencies/open-zeppelin/MerkleProof.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { MD1Pausable } from './MD1Pausable.sol';\\n\\n/**\\n * @title MD1RootUpdates\\n * @author dYdX\\n *\\n * @notice Handles updates to the Merkle root.\\n */\\nabstract contract MD1RootUpdates is\\n  MD1Pausable\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @notice The waiting period before a proposed Merkle root can become active, in seconds.\\n  uint256 public constant WAITING_PERIOD = 7 days;\\n\\n  // ============ Events ============\\n\\n  /// @notice Emitted when a new Merkle root is proposed and the waiting period begins.\\n  event RootProposed(\\n    bytes32 merkleRoot,\\n    uint256 epoch,\\n    bytes ipfsCid,\\n    uint256 waitingPeriodEnd\\n  );\\n\\n  /// @notice Emitted when a new Merkle root becomes active.\\n  event RootUpdated(\\n    bytes32 merkleRoot,\\n    uint256 epoch,\\n    bytes ipfsCid\\n  );\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Set the proposed root parameters to the values returned by the oracle, and start the\\n   *  waiting period. Anyone may call this function.\\n   *\\n   *  Reverts if the oracle root is bytes32(0).\\n   *  Reverts if the oracle root parameters are equal to the proposed root parameters.\\n   *  Reverts if the oracle root epoch is not equal to the next root epoch.\\n   */\\n  function proposeRoot()\\n    external\\n    nonReentrant\\n  {\\n    // Read the latest values from the oracle.\\n    (\\n      bytes32 merkleRoot,\\n      uint256 epoch,\\n      bytes memory ipfsCid\\n    ) = _REWARDS_ORACLE_.read();\\n\\n    require(merkleRoot != bytes32(0), 'MD1RootUpdates: Oracle root is zero (unset)');\\n    require(\\n      (\\n        merkleRoot != _PROPOSED_ROOT_.merkleRoot ||\\n        epoch != _PROPOSED_ROOT_.epoch ||\\n        keccak256(ipfsCid) != keccak256(_PROPOSED_ROOT_.ipfsCid)\\n      ),\\n      'MD1RootUpdates: Oracle root was already proposed'\\n    );\\n    require(epoch == getNextRootEpoch(), 'MD1RootUpdates: Oracle epoch is not next root epoch');\\n\\n    // Set the proposed root and the waiting period for the proposed root to become active.\\n    _PROPOSED_ROOT_ = MD1Types.MerkleRoot({\\n      merkleRoot: merkleRoot,\\n      epoch: epoch,\\n      ipfsCid: ipfsCid\\n    });\\n    uint256 waitingPeriodEnd = block.timestamp.add(WAITING_PERIOD);\\n    _WAITING_PERIOD_END_ = waitingPeriodEnd;\\n\\n    emit RootProposed(merkleRoot, epoch, ipfsCid, waitingPeriodEnd);\\n  }\\n\\n  /**\\n   * @notice Set the active root parameters to the proposed root parameters.\\n   *\\n   *  Reverts if root updates are paused.\\n   *  Reverts if the proposed root is bytes32(0).\\n   *  Reverts if the proposed root epoch is not equal to the next root epoch.\\n   *  Reverts if the waiting period for the proposed root has not elapsed.\\n   */\\n  function updateRoot()\\n    external\\n    nonReentrant\\n    whenNotPaused\\n  {\\n    // Get the proposed root parameters.\\n    bytes32 merkleRoot = _PROPOSED_ROOT_.merkleRoot;\\n    uint256 epoch = _PROPOSED_ROOT_.epoch;\\n    bytes memory ipfsCid = _PROPOSED_ROOT_.ipfsCid;\\n\\n    require(merkleRoot != bytes32(0), 'MD1RootUpdates: Proposed root is zero (unset)');\\n    require(epoch == getNextRootEpoch(), 'MD1RootUpdates: Proposed epoch is not next root epoch');\\n    require(\\n      block.timestamp >= _WAITING_PERIOD_END_,\\n      'MD1RootUpdates: Waiting period has not elapsed'\\n    );\\n\\n    // Set the active root.\\n    _ACTIVE_ROOT_.merkleRoot = merkleRoot;\\n    _ACTIVE_ROOT_.epoch = epoch;\\n    _ACTIVE_ROOT_.ipfsCid = ipfsCid;\\n\\n    emit RootUpdated(merkleRoot, epoch, ipfsCid);\\n  }\\n\\n  /**\\n   * @notice Returns true if there is a proposed root waiting to become active, the waiting period\\n   *  for that root has elapsed, and root updates are not paused.\\n   *\\n   * @return Boolean `true` if the active root can be updated to the proposed root, else `false`.\\n   */\\n  function canUpdateRoot()\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return (\\n      hasPendingRoot() &&\\n      block.timestamp >= _WAITING_PERIOD_END_ &&\\n      !_ARE_ROOT_UPDATES_PAUSED_\\n    );\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Returns true if there is a proposed root waiting to become active. This is the case if\\n   *  and only if the proposed root is not zero and the proposed root epoch is equal to the next\\n   *  root epoch.\\n   */\\n  function hasPendingRoot()\\n    public\\n    view\\n    returns (bool)\\n  {\\n    // Get the proposed parameters.\\n    bytes32 merkleRoot = _PROPOSED_ROOT_.merkleRoot;\\n    uint256 epoch = _PROPOSED_ROOT_.epoch;\\n\\n    if (merkleRoot == bytes32(0)) {\\n      return false;\\n    }\\n    return epoch == getNextRootEpoch();\\n  }\\n\\n  /**\\n   * @notice Get the next root epoch. If the active root is zero, then the next root epoch is zero,\\n   *  otherwise, it is equal to the active root epoch plus one.\\n   */\\n  function getNextRootEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    bytes32 merkleRoot = _ACTIVE_ROOT_.merkleRoot;\\n\\n    if (merkleRoot == bytes32(0)) {\\n      return 0;\\n    }\\n\\n    return _ACTIVE_ROOT_.epoch.add(1);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Configuration.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { IRewardsOracle } from '../../../interfaces/IRewardsOracle.sol';\\nimport { MD1EpochSchedule } from './MD1EpochSchedule.sol';\\nimport { MD1Roles } from './MD1Roles.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\n\\n/**\\n * @title MD1Configuration\\n * @author dYdX\\n *\\n * @notice Functions for modifying the Merkle distributor rewards configuration.\\n *\\n *  The more sensitive configuration values, which potentially give full control over the contents\\n *  of the Merkle tree, may only be updated by the OWNER_ROLE. Other values may be configured by\\n *  the CONFIG_UPDATER_ROLE.\\n *\\n *  Note that these configuration values are made available externally but are not used internally\\n *  within this contract, with the exception of the IPFS update period which is used by\\n *  the getIpfsEpoch() function.\\n */\\nabstract contract MD1Configuration is\\n  MD1EpochSchedule,\\n  MD1Roles\\n{\\n  // ============ Constants ============\\n\\n  uint256 public constant TRADER_SCORE_ALPHA_BASE = 10 ** 18;\\n\\n  // ============ Events ============\\n\\n  event RewardsOracleChanged(\\n    address rewardsOracle\\n  );\\n\\n  event IpnsNameUpdated(\\n    string ipnsName\\n  );\\n\\n  event IpfsUpdatePeriodUpdated(\\n    uint256 ipfsUpdatePeriod\\n  );\\n\\n  event RewardsParametersUpdated(\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  );\\n\\n  // ============ Initializer ============\\n\\n  function __MD1Configuration_init(\\n    address rewardsOracle,\\n    string calldata ipnsName,\\n    uint256 ipfsUpdatePeriod,\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  )\\n    internal\\n  {\\n    _setRewardsOracle(rewardsOracle);\\n    _setIpnsName(ipnsName);\\n    _setIpfsUpdatePeriod(ipfsUpdatePeriod);\\n    _setRewardsParameters(\\n      marketMakerRewardsAmount,\\n      traderRewardsAmount,\\n      traderScoreAlpha\\n    );\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Set the address of the oracle which provides Merkle root updates.\\n   *\\n   * @param  rewardsOracle  The new oracle address.\\n   */\\n  function setRewardsOracle(\\n    address rewardsOracle\\n  )\\n    external\\n    onlyRole(OWNER_ROLE)\\n    nonReentrant\\n  {\\n    _setRewardsOracle(rewardsOracle);\\n  }\\n\\n  /**\\n   * @notice Set the IPNS name to which trader and market maker exchange statistics are published.\\n   *\\n   * @param  ipnsName  The new IPNS name.\\n   */\\n  function setIpnsName(\\n    string calldata ipnsName\\n  )\\n    external\\n    onlyRole(OWNER_ROLE)\\n    nonReentrant\\n  {\\n    _setIpnsName(ipnsName);\\n  }\\n\\n  /**\\n   * @notice Set the period of time after the epoch end after which the new epoch exchange\\n   *  statistics should be available on IPFS via the IPNS name.\\n   *\\n   *  This can be used as a trigger for “keepers” who are incentivized to call the proposeRoot()\\n   *  and updateRoot() functions as needed.\\n   *\\n   * @param  ipfsUpdatePeriod  The new IPFS update period, in seconds.\\n   */\\n  function setIpfsUpdatePeriod(\\n    uint256 ipfsUpdatePeriod\\n  )\\n    external\\n    onlyRole(CONFIG_UPDATER_ROLE)\\n    nonReentrant\\n  {\\n    _setIpfsUpdatePeriod(ipfsUpdatePeriod);\\n  }\\n\\n  /**\\n   * @notice Set the rewards formula parameters.\\n   *\\n   * @param  marketMakerRewardsAmount  Max rewards distributed per epoch as market maker incentives.\\n   * @param  traderRewardsAmount       Max rewards distributed per epoch as trader incentives.\\n   * @param  traderScoreAlpha          The alpha parameter between 0 and 1, in units out of 10^18.\\n   */\\n  function setRewardsParameters(\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  )\\n    external\\n    onlyRole(CONFIG_UPDATER_ROLE)\\n    nonReentrant\\n  {\\n    _setRewardsParameters(marketMakerRewardsAmount, traderRewardsAmount, traderScoreAlpha);\\n  }\\n\\n  /**\\n   * @notice Set the parameters defining the function from timestamp to epoch number.\\n   *\\n   * @param  interval  The length of an epoch, in seconds.\\n   * @param  offset    The start of epoch zero, in seconds.\\n   */\\n  function setEpochParameters(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    external\\n    onlyRole(CONFIG_UPDATER_ROLE)\\n    nonReentrant\\n  {\\n    _setEpochParameters(interval, offset);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _setRewardsOracle(\\n    address rewardsOracle\\n  )\\n    internal\\n  {\\n    _REWARDS_ORACLE_ = IRewardsOracle(rewardsOracle);\\n    emit RewardsOracleChanged(rewardsOracle);\\n  }\\n\\n  function _setIpnsName(\\n    string calldata ipnsName\\n  )\\n    internal\\n  {\\n    _IPNS_NAME_ = ipnsName;\\n    emit IpnsNameUpdated(ipnsName);\\n  }\\n\\n  function _setIpfsUpdatePeriod(\\n    uint256 ipfsUpdatePeriod\\n  )\\n    internal\\n  {\\n    _IPFS_UPDATE_PERIOD_ = ipfsUpdatePeriod;\\n    emit IpfsUpdatePeriodUpdated(ipfsUpdatePeriod);\\n  }\\n\\n  function _setRewardsParameters(\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  )\\n    internal\\n  {\\n    require(\\n      traderScoreAlpha <= TRADER_SCORE_ALPHA_BASE,\\n      'MD1Configuration: Invalid traderScoreAlpha'\\n    );\\n\\n    _MARKET_MAKER_REWARDS_AMOUNT_ = marketMakerRewardsAmount;\\n    _TRADER_REWARDS_AMOUNT_ = traderRewardsAmount;\\n    _TRADER_SCORE_ALPHA_ = traderScoreAlpha;\\n\\n    emit RewardsParametersUpdated(\\n      marketMakerRewardsAmount,\\n      traderRewardsAmount,\\n      traderScoreAlpha\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Getters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { IRewardsOracle } from '../../../interfaces/IRewardsOracle.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { MD1Storage } from './MD1Storage.sol';\\n\\n/**\\n * @title MD1Getters\\n * @author dYdX\\n *\\n * @notice Simple getter functions.\\n */\\nabstract contract MD1Getters is\\n  MD1Storage\\n{\\n  /**\\n   * @notice Get the address of the oracle which provides Merkle root updates.\\n   *\\n   * @return The address of the oracle.\\n   */\\n  function getRewardsOracle()\\n    external\\n    view\\n    returns (IRewardsOracle)\\n  {\\n    return _REWARDS_ORACLE_;\\n  }\\n\\n  /**\\n   * @notice Get the IPNS name to which trader and market maker exchange statistics are published.\\n   *\\n   * @return The IPNS name.\\n   */\\n  function getIpnsName()\\n    external\\n    view\\n    returns (string memory)\\n  {\\n    return _IPNS_NAME_;\\n  }\\n\\n  /**\\n   * @notice Get the period of time after the epoch end after which the new epoch exchange\\n   *  statistics should be available on IPFS via the IPNS name.\\n   *\\n   * @return The IPFS update period, in seconds.\\n   */\\n  function getIpfsUpdatePeriod()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _IPFS_UPDATE_PERIOD_;\\n  }\\n\\n  /**\\n   * @notice Get the rewards formula parameters.\\n   *\\n   * @return Max rewards distributed per epoch as market maker incentives.\\n   * @return Max rewards distributed per epoch as trader incentives.\\n   * @return The alpha parameter between 0 and 1, in units out of 10^18.\\n   */\\n  function getRewardsParameters()\\n    external\\n    view\\n    returns (uint256, uint256, uint256)\\n  {\\n    return (\\n      _MARKET_MAKER_REWARDS_AMOUNT_,\\n      _TRADER_REWARDS_AMOUNT_,\\n      _TRADER_SCORE_ALPHA_\\n    );\\n  }\\n\\n  /**\\n   * @notice Get the parameters specifying the function from timestamp to epoch number.\\n   *\\n   * @return The parameters struct with `interval` and `offset` fields.\\n   */\\n  function getEpochParameters()\\n    external\\n    view\\n    returns (MD1Types.EpochParameters memory)\\n  {\\n    return _EPOCH_PARAMETERS_;\\n  }\\n\\n  /**\\n   * @notice Get the active Merkle root and associated parameters.\\n   *\\n   * @return  merkleRoot  The active Merkle root.\\n   * @return  epoch       The epoch number corresponding to this Merkle tree.\\n   * @return  ipfsCid     An IPFS CID pointing to the Merkle tree data.\\n   */\\n  function getActiveRoot()\\n    external\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid)\\n  {\\n    merkleRoot = _ACTIVE_ROOT_.merkleRoot;\\n    epoch = _ACTIVE_ROOT_.epoch;\\n    ipfsCid = _ACTIVE_ROOT_.ipfsCid;\\n  }\\n\\n  /**\\n   * @notice Get the proposed Merkle root and associated parameters.\\n   *\\n   * @return  merkleRoot  The active Merkle root.\\n   * @return  epoch       The epoch number corresponding to this Merkle tree.\\n   * @return  ipfsCid     An IPFS CID pointing to the Merkle tree data.\\n   */\\n  function getProposedRoot()\\n    external\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid)\\n  {\\n    merkleRoot = _PROPOSED_ROOT_.merkleRoot;\\n    epoch = _PROPOSED_ROOT_.epoch;\\n    ipfsCid = _PROPOSED_ROOT_.ipfsCid;\\n  }\\n\\n  /**\\n   * @notice Get the time at which the proposed root may become active.\\n   *\\n   * @return The time at which the proposed root may become active, in epoch seconds.\\n   */\\n  function getWaitingPeriodEnd()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _WAITING_PERIOD_END_;\\n  }\\n\\n  /**\\n   * @notice Check whether root updates are currently paused.\\n   *\\n   * @return Boolean `true` if root updates are currently paused, otherwise, `false`.\\n   */\\n  function getAreRootUpdatesPaused()\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _ARE_ROOT_UPDATES_PAUSED_;\\n  }\\n\\n  /**\\n   * @notice Get the tokens claimed so far by a given user.\\n   *\\n   * @param  user  The address of the user.\\n   *\\n   * @return The tokens claimed so far by that user.\\n   */\\n  function getClaimed(address user)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _CLAIMED_[user];\\n  }\\n\\n  /**\\n   * @notice Check whether the user opted into allowing anyone to trigger a claim on their behalf.\\n   *\\n   * @param  user  The address of the user.\\n   *\\n   * @return Boolean `true` if any address may trigger claims for the user, otherwise `false`.\\n   */\\n  function getAlwaysAllowClaimsFor(address user)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _ALWAYS_ALLOW_CLAIMS_FOR_[user];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { SafeMath } from './SafeMath.sol';\\nimport { Address } from './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\\n * Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/lib/MD1Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary MD1Types {\\n\\n  /**\\n   * @dev The parameters used to convert a timestamp to an epoch number.\\n   */\\n  struct EpochParameters {\\n    uint128 interval;\\n    uint128 offset;\\n  }\\n\\n  /**\\n   * @dev The parameters related to a certain version of the Merkle root.\\n   */\\n  struct MerkleRoot {\\n    bytes32 merkleRoot;\\n    uint256 epoch;\\n    bytes ipfsCid;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { MD1Storage } from './MD1Storage.sol';\\n\\n/**\\n * @title MD1Roles\\n * @author dYdX\\n *\\n * @notice Defines roles used in the MerkleDistributorV1 contract. The hierarchy of roles and\\n *  powers of each role are described below.\\n *\\n *  Roles:\\n *\\n *    OWNER_ROLE\\n *      | -> May add or remove addresses from any of the below roles it manages.\\n *      | -> May update the rewards oracle address.\\n *      | -> May update the IPNS name.\\n *      |\\n *      +-- CONFIG_UPDATER_ROLE\\n *      |     -> May update parameters affecting the formulae used to calculate rewards.\\n *      |     -> May update the epoch schedule.\\n *      |     -> May update the IPFS update period.\\n *      |\\n *      +-- PAUSER_ROLE\\n *      |     -> May pause updates to the Merkle root.\\n *      |\\n *      +-- UNPAUSER_ROLE\\n *      |     -> May unpause updates to the Merkle root.\\n *      |\\n *      +-- CLAIM_OPERATOR_ROLE\\n *            -> May trigger a claim on behalf of a user (but the recipient is always the user).\\n */\\nabstract contract MD1Roles is\\n  MD1Storage\\n{\\n  bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\\n  bytes32 public constant CONFIG_UPDATER_ROLE = keccak256('CONFIG_UPDATER_ROLE');\\n  bytes32 public constant PAUSER_ROLE = keccak256('PAUSER_ROLE');\\n  bytes32 public constant UNPAUSER_ROLE = keccak256('UNPAUSER_ROLE');\\n  bytes32 public constant CLAIM_OPERATOR_ROLE = keccak256('CLAIM_OPERATOR_ROLE');\\n\\n  function __MD1Roles_init()\\n    internal\\n  {\\n    // Assign the OWNER_ROLE to the sender.\\n    _setupRole(OWNER_ROLE, msg.sender);\\n\\n    // Set OWNER_ROLE as the admin of all roles.\\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(CONFIG_UPDATER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(UNPAUSER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(CLAIM_OPERATOR_ROLE, OWNER_ROLE);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Address.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  AccessControlUpgradeable\\n} from '../../../dependencies/open-zeppelin/AccessControlUpgradeable.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { IRewardsOracle } from '../../../interfaces/IRewardsOracle.sol';\\nimport { ReentrancyGuard } from '../../../utils/ReentrancyGuard.sol';\\nimport { VersionedInitializable } from '../../../utils/VersionedInitializable.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\n\\n/**\\n * @title MD1Storage\\n * @author dYdX\\n *\\n * @dev Storage contract. Contains or inherits from all contract with storage.\\n */\\nabstract contract MD1Storage is\\n  AccessControlUpgradeable,\\n  ReentrancyGuard,\\n  VersionedInitializable\\n{\\n  // ============ Configuration ============\\n\\n  /// @dev The oracle which provides Merkle root updates.\\n  IRewardsOracle internal _REWARDS_ORACLE_;\\n\\n  /// @dev The IPNS name to which trader and market maker exchange statistics are published.\\n  string internal _IPNS_NAME_;\\n\\n  /// @dev Period of time after the epoch end after which the new epoch exchange statistics should\\n  ///  be available on IPFS via the IPNS name. This can be used as a trigger for “keepers” who are\\n  ///  incentivized to call the proposeRoot() and updateRoot() functions as needed.\\n  uint256 internal _IPFS_UPDATE_PERIOD_;\\n\\n  /// @dev Max rewards distributed per epoch as market maker incentives.\\n  uint256 internal _MARKET_MAKER_REWARDS_AMOUNT_;\\n\\n  /// @dev Max rewards distributed per epoch as trader incentives.\\n  uint256 internal _TRADER_REWARDS_AMOUNT_;\\n\\n  /// @dev Parameter affecting the calculation of trader rewards. This is a value\\n  ///  between 0 and 1, represented here in units out of 10^18.\\n  uint256 internal _TRADER_SCORE_ALPHA_;\\n\\n  // ============ Epoch Schedule ============\\n\\n  /// @dev The parameters specifying the function from timestamp to epoch number.\\n  MD1Types.EpochParameters internal _EPOCH_PARAMETERS_;\\n\\n  // ============ Root Updates ============\\n\\n  /// @dev The active Merkle root and associated parameters.\\n  MD1Types.MerkleRoot internal _ACTIVE_ROOT_;\\n\\n  /// @dev The proposed Merkle root and associated parameters.\\n  MD1Types.MerkleRoot internal _PROPOSED_ROOT_;\\n\\n  /// @dev The time at which the proposed root may become active.\\n  uint256 internal _WAITING_PERIOD_END_;\\n\\n  /// @dev Whether root updates are currently paused.\\n  bool internal _ARE_ROOT_UPDATES_PAUSED_;\\n\\n  // ============ Claims ============\\n\\n  /// @dev Mapping of (user address) => (number of tokens claimed).\\n  mapping(address => uint256) internal _CLAIMED_;\\n\\n  /// @dev Whether the user has opted into allowing anyone to trigger a claim on their behalf.\\n  mapping(address => bool) internal _ALWAYS_ALLOW_CLAIMS_FOR_;\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\nimport './Context.sol';\\nimport './Strings.sol';\\nimport './ERC165.sol';\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n  function grantRole(bytes32 role, address account) external;\\n\\n  function revokeRole(bytes32 role, address account) external;\\n\\n  function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Context, IAccessControlUpgradeable, ERC165 {\\n  struct RoleData {\\n    mapping(address => bool) members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {_setupRole}.\\n   */\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Modifier that checks that an account has a specific role. Reverts\\n   * with a standardized message including the required role.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   *\\n   * _Available since v4.1._\\n   */\\n  modifier onlyRole(bytes32 role) {\\n    _checkRole(role, _msgSender());\\n    _;\\n  }\\n\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return\\n      interfaceId == type(IAccessControlUpgradeable).interfaceId ||\\n      super.supportsInterface(interfaceId);\\n  }\\n\\n  /**\\n   * @dev Returns `true` if `account` has been granted `role`.\\n   */\\n  function hasRole(bytes32 role, address account) public view override returns (bool) {\\n    return _roles[role].members[account];\\n  }\\n\\n  /**\\n   * @dev Revert with a standard message if `account` is missing `role`.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   */\\n  function _checkRole(bytes32 role, address account) internal view {\\n    if (!hasRole(role, account)) {\\n      revert(\\n        string(\\n          abi.encodePacked(\\n            'AccessControl: account ',\\n            Strings.toHexString(uint160(account), 20),\\n            ' is missing role ',\\n            Strings.toHexString(uint256(role), 32)\\n          )\\n        )\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\\n   * {revokeRole}.\\n   *\\n   * To change a role's admin, use {_setRoleAdmin}.\\n   */\\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function grantRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from `account`.\\n   *\\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function revokeRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from the calling account.\\n   *\\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n   * purpose is to provide a mechanism for accounts to lose their privileges\\n   * if they are compromised (such as when a trusted device is misplaced).\\n   *\\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must be `account`.\\n   */\\n  function renounceRole(bytes32 role, address account) public virtual override {\\n    require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event. Note that unlike {grantRole}, this function doesn't perform any\\n   * checks on the calling account.\\n   *\\n   * [WARNING]\\n   * ====\\n   * This function should only be called from the constructor when setting\\n   * up the initial roles for the system.\\n   *\\n   * Using this function in any other way is effectively circumventing the admin\\n   * system imposed by {AccessControl}.\\n   * ====\\n   */\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Sets `adminRole` as ``role``'s admin role.\\n   *\\n   * Emits a {RoleAdminChanged} event.\\n   */\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (!hasRole(role, account)) {\\n      _roles[role].members[account] = true;\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (hasRole(role, account)) {\\n      _roles[role].members[account] = false;\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n\\n  uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title ReentrancyGuard\\n * @author dYdX\\n *\\n * @dev Updated ReentrancyGuard library designed to be used with Proxy Contracts.\\n */\\nabstract contract ReentrancyGuard {\\n  uint256 private constant NOT_ENTERED = 1;\\n  uint256 private constant ENTERED = uint256(int256(-1));\\n\\n  uint256 private _STATUS_;\\n\\n  constructor() internal {\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n\\n  modifier nonReentrant() {\\n    require(_STATUS_ != ENTERED, 'ReentrancyGuard: reentrant call');\\n    _STATUS_ = ENTERED;\\n    _;\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/VersionedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @title VersionedInitializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n * @author dYdX, inspired by the OpenZeppelin Initializable contract\\n */\\nabstract contract VersionedInitializable {\\n    /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n    uint256 internal lastInitializedRevision = 0;\\n\\n   /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(revision > lastInitializedRevision, \\\"Contract instance has already been initialized\\\");\\n\\n        lastInitializedRevision = revision;\\n\\n        _;\\n\\n    }\\n\\n    /// @dev returns the revision number of the contract.\\n    /// Needs to be defined in the inherited class as a constant.\\n    function getRevision() internal pure virtual returns(uint256);\\n\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { MD1Roles } from './MD1Roles.sol';\\n\\n/**\\n * @title MD1Pausable\\n * @author dYdX\\n *\\n * @notice Allows authorized addresses to pause updates to the Merkle root.\\n *\\n *  For the Merkle root to be updated, the root must first be set on the oracle contract, then\\n *  proposed on this contract, at which point the waiting period begins. During the waiting period,\\n *  the root should be verified, and updates should be paused by the PAUSER_ROLE if the root is\\n *  found to be incorrect.\\n */\\nabstract contract MD1Pausable is\\n  MD1Roles\\n{\\n  // ============ Events ============\\n\\n  /// @notice Emitted when root updates are paused.\\n  event RootUpdatesPaused();\\n\\n  /// @notice Emitted when root updates are unpaused.\\n  event RootUpdatesUnpaused();\\n\\n  // ============ Modifiers ============\\n\\n  /**\\n   * @dev Enforce that a function may be called only while root updates are not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!_ARE_ROOT_UPDATES_PAUSED_, 'MD1Pausable: Updates paused');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Enforce that a function may be called only while root updates are paused.\\n   */\\n  modifier whenPaused() {\\n    require(_ARE_ROOT_UPDATES_PAUSED_, 'MD1Pausable: Updates not paused');\\n    _;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @dev Called by PAUSER_ROLE to prevent proposed Merkle roots from becoming active.\\n   */\\n  function pauseRootUpdates()\\n    onlyRole(PAUSER_ROLE)\\n    whenNotPaused\\n    nonReentrant\\n    external\\n  {\\n    _ARE_ROOT_UPDATES_PAUSED_ = true;\\n    emit RootUpdatesPaused();\\n  }\\n\\n  /**\\n   * @dev Called by UNPAUSER_ROLE to resume allowing proposed Merkle roots to become active.\\n   */\\n  function unpauseRootUpdates()\\n    onlyRole(UNPAUSER_ROLE)\\n    whenPaused\\n    nonReentrant\\n    external\\n  {\\n    _ARE_ROOT_UPDATES_PAUSED_ = false;\\n    emit RootUpdatesUnpaused();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1EpochSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { MD1Storage } from './MD1Storage.sol';\\n\\n/**\\n * @title MD1EpochSchedule\\n * @author dYdX\\n *\\n * @dev Defines a function from block timestamp to epoch number.\\n *\\n *  Note that the current and IPFS epoch numbers are made available externally but are not used\\n *  internally within this contract.\\n *\\n *  The formula used is `n = floor((t - b) / a)` where:\\n *    - `n` is the epoch number\\n *    - `t` is the timestamp (in seconds)\\n *    - `b` is a non-negative offset, indicating the start of epoch zero (in seconds)\\n *    - `a` is the length of an epoch, a.k.a. the interval (in seconds)\\n */\\nabstract contract MD1EpochSchedule is\\n  MD1Storage\\n{\\n  using SafeCast for uint256;\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  event EpochScheduleUpdated(\\n    MD1Types.EpochParameters epochParameters\\n  );\\n\\n  // ============ Initializer ============\\n\\n  function __MD1EpochSchedule_init(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    internal\\n  {\\n    _setEpochParameters(interval, offset);\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Get the epoch at the current block timestamp.\\n   *\\n   *  Reverts if epoch zero has not started.\\n   *\\n   * @return The current epoch number.\\n   */\\n  function getCurrentEpoch()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _getEpochAtTimestamp(\\n      block.timestamp,\\n      'MD1EpochSchedule: Epoch zero has not started'\\n    );\\n  }\\n\\n  /**\\n   * @notice Get the latest epoch number for which we expect to have data available on IPFS.\\n   *  This is equal to the current epoch number, delayed by the IPFS update period.\\n   *\\n   *  Reverts if epoch zero did not begin at least `_IPFS_UPDATE_PERIOD_` seconds ago.\\n   *\\n   * @return The latest epoch number for which we expect to have data available on IPFS.\\n   */\\n  function getIpfsEpoch()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _getEpochAtTimestamp(\\n      block.timestamp.sub(_IPFS_UPDATE_PERIOD_),\\n      'MD1EpochSchedule: IPFS epoch zero has not started'\\n    );\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _getEpochAtTimestamp(\\n    uint256 timestamp,\\n    string memory revertReason\\n  )\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    MD1Types.EpochParameters memory epochParameters = _EPOCH_PARAMETERS_;\\n\\n    uint256 interval = uint256(epochParameters.interval);\\n    uint256 offset = uint256(epochParameters.offset);\\n\\n    require(timestamp >= offset, revertReason);\\n\\n    return timestamp.sub(offset).div(interval);\\n  }\\n\\n  function _setEpochParameters(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    internal\\n  {\\n    require(interval != 0, 'MD1EpochSchedule: Interval cannot be zero');\\n\\n    MD1Types.EpochParameters memory epochParameters = MD1Types.EpochParameters({\\n      interval: interval.toUint128(),\\n      offset: offset.toUint128()\\n    });\\n\\n    _EPOCH_PARAMETERS_ = epochParameters;\\n\\n    emit EpochScheduleUpdated(epochParameters);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/lib/SafeCast.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Methods for downcasting unsigned integers, reverting on overflow.\\n */\\nlibrary SafeCast {\\n\\n  /**\\n   * @dev Downcast to a uint128, reverting on overflow.\\n   */\\n  function toUint128(uint256 a) internal pure returns (uint128) {\\n    uint128 b = uint128(a);\\n    require(uint256(b) == a, 'SafeCast: toUint128 overflow');\\n    return b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/oracles/MD1ChainlinkAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  ChainlinkClient,\\n  Chainlink\\n} from '@chainlink/contracts/src/v0.7/ChainlinkClient.sol';\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { IMerkleDistributorV1 } from '../../../interfaces/IMerkleDistributorV1.sol';\\nimport { IRewardsOracle } from '../../../interfaces/IRewardsOracle.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\n\\n/**\\n * @title MD1ChainlinkAdapter\\n * @author dYdX\\n *\\n * @notice Chainlink oracle adapter to be read by the MerkleDistributorV1 contract.\\n */\\ncontract MD1ChainlinkAdapter is\\n  ChainlinkClient,\\n  IRewardsOracle\\n{\\n  using Chainlink for Chainlink.Request;\\n  using SafeERC20 for IERC20;\\n\\n  // ============ Events ============\\n\\n  /// @notice Emitted when the oracle data is updated.\\n  event OracleRootUpdated(\\n    bytes32 merkleRoot,\\n    uint256 epoch,\\n    bytes ipfsCid\\n  );\\n\\n  // ============ Constants ============\\n\\n  /// @notice Address of the LINK token, used to pay for requests for oracle data.\\n  IERC20 public immutable CHAINLINK_TOKEN;\\n\\n  /// @notice The address of the Merkle distributor contract, which determines rewards parameters.\\n  IMerkleDistributorV1 public immutable MERKLE_DISTRIBUTOR;\\n\\n  /// @notice The address to which the Chainlink request is sent.\\n  address public immutable ORACLE_CONTRACT;\\n\\n  /// @notice The address which will call writeOracleData().\\n  address public immutable ORACLE_EXTERNAL_ADAPTER;\\n\\n  /// @notice Chainlink ID for the job.\\n  bytes32 public immutable JOB_ID;\\n\\n  // ============ Storage ============\\n\\n  /// @dev Mapping from Chainlink request ID to the address that initated the request.\\n  mapping(bytes32 => address) internal _OPEN_REQUESTS_;\\n\\n  /// @dev The latest oracle data.\\n  MD1Types.MerkleRoot internal _ORACLE_ROOT_;\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    address chainlinkToken,\\n    address merkleDistributor,\\n    address oracleContract,\\n    address oracleExternalAdapter,\\n    bytes32 jobId\\n  ) {\\n    setChainlinkToken(chainlinkToken);\\n    CHAINLINK_TOKEN = IERC20(chainlinkToken);\\n    MERKLE_DISTRIBUTOR = IMerkleDistributorV1(merkleDistributor);\\n    ORACLE_CONTRACT = oracleContract;\\n    ORACLE_EXTERNAL_ADAPTER = oracleExternalAdapter;\\n    JOB_ID = jobId;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Helper function which transfers the fee and makes a request in a single transaction.\\n   *\\n   * @param  fee  The LINK amount to pay for the request.\\n   */\\n  function transferAndRequestOracleData(\\n    uint256 fee\\n  )\\n    external\\n  {\\n    CHAINLINK_TOKEN.safeTransferFrom(msg.sender, address(this), fee);\\n    requestOracleData(fee);\\n  }\\n\\n  /**\\n   * @notice Called by the oracle external adapter to write data in response to a request.\\n   *\\n   *  This should be called before fulfillRequest() is called.\\n   *\\n   * @param  merkleRoot  Root hash of the Merkle tree for this epoch's rewards distribution.\\n   * @param  epoch       The epoch number for this rewards distribution.\\n   * @param  ipfsCid     The IPFS CID with the full Merkle tree data.\\n   */\\n  function writeOracleData(\\n    bytes32 merkleRoot,\\n    uint256 epoch,\\n    bytes calldata ipfsCid\\n  )\\n    external\\n  {\\n    require(\\n      msg.sender == ORACLE_EXTERNAL_ADAPTER,\\n      'MD1ChainlinkAdapter: Sender must be the oracle external adapter'\\n    );\\n\\n    _ORACLE_ROOT_ = MD1Types.MerkleRoot({\\n      merkleRoot: merkleRoot,\\n      epoch: epoch,\\n      ipfsCid: ipfsCid\\n    });\\n\\n    emit OracleRootUpdated(merkleRoot, epoch, ipfsCid);\\n  }\\n\\n  /**\\n   * @notice Callback function for the oracle to record fulfillment of a request.\\n   */\\n  function fulfillRequest(\\n    bytes32 requestId\\n  )\\n    external\\n    recordChainlinkFulfillment(requestId)\\n  {\\n    delete _OPEN_REQUESTS_[requestId];\\n  }\\n\\n  /**\\n   * @notice Allow the initiator of a request to cancel that request. The request must have expired.\\n   *\\n   *  The LINK fee for the request will be refunded back to this contract.\\n   */\\n  function cancelRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  )\\n    external\\n  {\\n    require(\\n      msg.sender == _OPEN_REQUESTS_[requestId],\\n      'Request is not open or sender was not the initiator'\\n    );\\n    cancelChainlinkRequest(requestId, payment, callbackFunc, expiration);\\n  }\\n\\n  /**\\n   * @notice Read the latest data written by the oracle. This will be called by MerkleDistributorV1.\\n   *\\n   * @return  merkleRoot  The Merkle root for the next Merkle distributor update.\\n   * @return  epoch       The epoch number corresponding to the new Merkle root.\\n   * @return  ipfsCid     An IPFS CID pointing to the Merkle tree data.\\n   */\\n  function read()\\n    external\\n    override\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid)\\n  {\\n    merkleRoot = _ORACLE_ROOT_.merkleRoot;\\n    epoch = _ORACLE_ROOT_.epoch;\\n    ipfsCid = _ORACLE_ROOT_.ipfsCid;\\n  }\\n\\n  /**\\n   * @notice If a request with the specified ID is open, returns the address that initiated it.\\n   *\\n   * @param  requestId  The Chainlink request ID.\\n   *\\n   * @return The address that initiated request, or the zero address if the request is not open.\\n   */\\n  function getOpenRequest(\\n    bytes32 requestId\\n  )\\n    external\\n    view\\n    returns (address)\\n  {\\n    return _OPEN_REQUESTS_[requestId];\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Request the latest oracle data.\\n   *\\n   *  In response to this request, if sufficient fee is provided, the Chainlink node is expected to\\n   *  call the writeOracleData() function, followed by the fulfillRequest() function.\\n   *\\n   *  Reverts if this contract does not have LINK to pay the fee.\\n   *\\n   *  If the fee is less than the amount agreed to by the external (off-chain) oracle adapter, then\\n   *  the external adapter may ignore the request.\\n   *\\n   * @param  fee  The LINK amount to pay for the request.\\n   */\\n  function requestOracleData(\\n    uint256 fee\\n  )\\n    public\\n  {\\n    // Read parameters from the Merkle distributor contract.\\n    string memory ipnsName = MERKLE_DISTRIBUTOR.getIpnsName();\\n    (\\n      uint256 marketMakerRewardsAmount,\\n      uint256 traderRewardsAmount,\\n      uint256 traderScoreAlpha\\n    ) = MERKLE_DISTRIBUTOR.getRewardsParameters();\\n    (, , bytes memory activeRootIpfsCid) = MERKLE_DISTRIBUTOR.getActiveRoot();\\n    uint256 newEpoch = MERKLE_DISTRIBUTOR.getNextRootEpoch();\\n\\n    // Build the Chainlink request.\\n    Chainlink.Request memory req = buildChainlinkRequest(\\n      JOB_ID,\\n      address(this),\\n      this.fulfillRequest.selector\\n    );\\n    req.addBytes('callbackAddress', abi.encodePacked(address(this)));\\n    req.add('ipnsName', ipnsName);\\n    req.addUint('marketMakerRewardsAmount', marketMakerRewardsAmount);\\n    req.addUint('traderRewardsAmount', traderRewardsAmount);\\n    req.addUint('traderScoreAlpha', traderScoreAlpha);\\n    req.addBytes('activeRootIpfsCid', activeRootIpfsCid);\\n    req.addUint('newEpoch', newEpoch);\\n\\n    // Send the Chainlink request.\\n    //\\n    // Note: This emits ChainlinkRequested(bytes32 indexed id);\\n    bytes32 requestId = sendChainlinkRequestTo(ORACLE_CONTRACT, req, fee);\\n\\n    // Store the address that initiated the request. This address may cancel the request.\\n    _OPEN_REQUESTS_[requestId] = msg.sender;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/ChainlinkClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Chainlink.sol\\\";\\nimport \\\"./interfaces/ENSInterface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./interfaces/PointerInterface.sol\\\";\\nimport { ENSResolver as ENSResolver_Chainlink } from \\\"./vendor/ENSResolver.sol\\\";\\n\\n/**\\n * @title The ChainlinkClient contract\\n * @notice Contract writers can inherit this contract in order to create requests for the\\n * Chainlink network\\n */\\ncontract ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  uint256 constant internal LINK_DIVISIBILITY = 10**18;\\n  uint256 constant private AMOUNT_OVERRIDE = 0;\\n  address constant private SENDER_OVERRIDE = address(0);\\n  uint256 constant private ORACLE_ARGS_VERSION = 1;\\n  uint256 constant private OPERATOR_ARGS_VERSION = 2;\\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\\\"link\\\");\\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\\\"oracle\\\");\\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\\n\\n  ENSInterface private ens;\\n  bytes32 private ensNode;\\n  LinkTokenInterface private link;\\n  OperatorInterface private oracle;\\n  uint256 private requestCount = 1;\\n  mapping(bytes32 => address) private pendingRequests;\\n\\n  event ChainlinkRequested(\\n    bytes32 indexed id\\n  );\\n  event ChainlinkFulfilled(\\n    bytes32 indexed id\\n  );\\n  event ChainlinkCancelled(\\n    bytes32 indexed id\\n  );\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackAddress The callback address that the response will be sent to\\n   * @param callbackFunctionSignature The callback function signature to use for the callback address\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildChainlinkRequest(\\n    bytes32 specId,\\n    address callbackAddress,\\n    bytes4 callbackFunctionSignature\\n  )\\n    internal\\n    pure\\n    returns (\\n      Chainlink.Request memory\\n    )\\n  {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, callbackAddress, callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequest(\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32\\n    )\\n  {\\n    return sendChainlinkRequestTo(address(oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    return rawRequest(oracleAddress, req, payment, ORACLE_ARGS_VERSION, oracle.oracleRequest.selector);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Calls `requestOracleDataFrom` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function requestOracleData(\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32\\n    )\\n  {\\n    return requestOracleDataFrom(address(oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function requestOracleDataFrom(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    return rawRequest(oracleAddress, req, payment, OPERATOR_ARGS_VERSION, oracle.requestOracleData.selector);\\n  }\\n\\n  /**\\n   * @notice Make a request to an oracle\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @param argsVersion The version of data support (single word, multi word)\\n   * @return requestId The request ID\\n   */\\n  function rawRequest(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment,\\n    uint256 argsVersion,\\n    bytes4 funcSelector\\n  )\\n    private\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    requestId = keccak256(abi.encodePacked(this, requestCount));\\n    req.nonce = requestCount;\\n    pendingRequests[requestId] = oracleAddress;\\n    emit ChainlinkRequested(requestId);\\n    bytes memory encodedData = abi.encodeWithSelector(\\n      funcSelector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      req.callbackAddress,\\n      req.callbackFunctionId,\\n      req.nonce,\\n      argsVersion,\\n      req.buf.buf);\\n    require(link.transferAndCall(oracleAddress, payment, encodedData), \\\"unable to transferAndCall to oracle\\\");\\n    requestCount += 1;\\n  }\\n\\n  /**\\n   * @notice Allows a request to be cancelled if it has not been fulfilled\\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\\n   * Deletes the request from the `pendingRequests` mapping.\\n   * Emits ChainlinkCancelled event.\\n   * @param requestId The request ID\\n   * @param payment The amount of LINK sent for the request\\n   * @param callbackFunc The callback function specified for the request\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelChainlinkRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  )\\n    internal\\n  {\\n    OperatorInterface requested = OperatorInterface(pendingRequests[requestId]);\\n    delete pendingRequests[requestId];\\n    emit ChainlinkCancelled(requestId);\\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle address\\n   * @param oracleAddress The address of the oracle contract\\n   */\\n  function setChainlinkOracle(\\n    address oracleAddress\\n  )\\n    internal\\n  {\\n    oracle = OperatorInterface(oracleAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the LINK token address\\n   * @param linkAddress The address of the LINK token contract\\n   */\\n  function setChainlinkToken(\\n    address linkAddress\\n  )\\n    internal\\n  {\\n    link = LinkTokenInterface(linkAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the Chainlink token address for the public\\n   * network as given by the Pointer contract\\n   */\\n  function setPublicChainlinkToken() \\n    internal\\n  {\\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the LINK token\\n   * @return The address of the LINK token\\n   */\\n  function chainlinkTokenAddress()\\n    internal\\n    view\\n    returns (\\n      address\\n    )\\n  {\\n    return address(link);\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the oracle contract\\n   * @return The address of the oracle contract\\n   */\\n  function chainlinkOracleAddress()\\n    internal\\n    view\\n    returns (\\n      address\\n    )\\n  {\\n    return address(oracle);\\n  }\\n\\n  /**\\n   * @notice Allows for a request which was created on another contract to be fulfilled\\n   * on this contract\\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\\n   * @param requestId The request ID used for the response\\n   */\\n  function addChainlinkExternalRequest(\\n    address oracleAddress,\\n    bytes32 requestId\\n  )\\n    internal\\n    notPendingRequest(requestId)\\n  {\\n    pendingRequests[requestId] = oracleAddress;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\\n   * @dev Accounts for subnodes having different resolvers\\n   * @param ensAddress The address of the ENS contract\\n   * @param node The ENS node hash\\n   */\\n  function useChainlinkWithENS(\\n    address ensAddress,\\n    bytes32 node\\n  )\\n    internal\\n  {\\n    ens = ENSInterface(ensAddress);\\n    ensNode = node;\\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(linkSubnode));\\n    setChainlinkToken(resolver.addr(linkSubnode));\\n    updateChainlinkOracleWithENS();\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle contract with the address resolved by ENS\\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\\n   */\\n  function updateChainlinkOracleWithENS()\\n    internal\\n  {\\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(oracleSubnode));\\n    setChainlinkOracle(resolver.addr(oracleSubnode));\\n  }\\n\\n  /**\\n   * @notice Ensures that the fulfillment is valid for this contract\\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\\n   * @param requestId The request ID for fulfillment\\n   */\\n  function validateChainlinkCallback(\\n    bytes32 requestId\\n  )\\n    internal\\n    recordChainlinkFulfillment(requestId)\\n    // solhint-disable-next-line no-empty-blocks\\n  {}\\n\\n  /**\\n   * @dev Reverts if the sender is not the oracle of the request.\\n   * Emits ChainlinkFulfilled event.\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier recordChainlinkFulfillment(\\n    bytes32 requestId\\n  )\\n  {\\n    require(msg.sender == pendingRequests[requestId],\\n            \\\"Source must be the oracle of the request\\\");\\n    delete pendingRequests[requestId];\\n    emit ChainlinkFulfilled(requestId);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the request is already pending\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier notPendingRequest(\\n    bytes32 requestId\\n  )\\n  {\\n    require(pendingRequests[requestId] == address(0), \\\"Request is already pending\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleDistributorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title IMerkleDistributorV1\\n * @author dYdX\\n *\\n * @notice Partial interface for the MerkleDistributorV1 contract.\\n */\\ninterface IMerkleDistributorV1 {\\n\\n  function getIpnsName()\\n    external\\n    virtual\\n    view\\n    returns (string memory);\\n\\n  function getRewardsParameters()\\n    external\\n    virtual\\n    view\\n    returns (uint256, uint256, uint256);\\n\\n  function getActiveRoot()\\n    external\\n    virtual\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid);\\n\\n  function getNextRootEpoch()\\n    external\\n    virtual\\n    view\\n    returns (uint256);\\n\\n  function claimRewards(\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/Chainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport { CBORChainlink } from \\\"./vendor/CBORChainlink.sol\\\";\\nimport { BufferChainlink } from \\\"./vendor/BufferChainlink.sol\\\";\\n\\n/**\\n * @title Library for common Chainlink functions\\n * @dev Uses imported CBOR library for encoding to buffer\\n */\\nlibrary Chainlink {\\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\\n\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  struct Request {\\n    bytes32 id;\\n    address callbackAddress;\\n    bytes4 callbackFunctionId;\\n    uint256 nonce;\\n    BufferChainlink.buffer buf;\\n  }\\n\\n  /**\\n   * @notice Initializes a Chainlink request\\n   * @dev Sets the ID, callback address, and callback function signature on the request\\n   * @param self The uninitialized request\\n   * @param jobId The Job Specification ID\\n   * @param callbackAddr The callback address\\n   * @param callbackFunc The callback function signature\\n   * @return The initialized request\\n   */\\n  function initialize(\\n    Request memory self,\\n    bytes32 jobId,\\n    address callbackAddr,\\n    bytes4 callbackFunc\\n  )\\n    internal\\n    pure\\n    returns (\\n      Chainlink.Request memory\\n    )\\n  {\\n    BufferChainlink.init(self.buf, defaultBufferSize);\\n    self.id = jobId;\\n    self.callbackAddress = callbackAddr;\\n    self.callbackFunctionId = callbackFunc;\\n    return self;\\n  }\\n\\n  /**\\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\\n   * @param self The initialized request\\n   * @param data The CBOR data\\n   */\\n  function setBuffer(\\n    Request memory self,\\n    bytes memory data\\n  )\\n    internal\\n    pure\\n  {\\n    BufferChainlink.init(self.buf, data.length);\\n    BufferChainlink.append(self.buf, data);\\n  }\\n\\n  /**\\n   * @notice Adds a string value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The string value to add\\n   */\\n  function add(\\n    Request memory self,\\n    string memory key,\\n    string memory value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeString(value);\\n  }\\n\\n  /**\\n   * @notice Adds a bytes value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The bytes value to add\\n   */\\n  function addBytes(\\n    Request memory self,\\n    string memory key,\\n    bytes memory value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeBytes(value);\\n  }\\n\\n  /**\\n   * @notice Adds a int256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The int256 value to add\\n   */\\n  function addInt(\\n    Request memory self,\\n    string memory key,\\n    int256 value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds a uint256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The uint256 value to add\\n   */\\n  function addUint(\\n    Request memory self,\\n    string memory key,\\n    uint256 value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeUInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds an array of strings to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param values The array of string values to add\\n   */\\n  function addStringArray(\\n    Request memory self,\\n    string memory key,\\n    string[] memory values\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.startArray();\\n    for (uint256 i = 0; i < values.length; i++) {\\n      self.buf.encodeString(values[i]);\\n    }\\n    self.buf.endSequence();\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/ENSInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface ENSInterface {\\n\\n  // Logged when the owner of a node assigns a new owner to a subnode.\\n  event NewOwner(\\n    bytes32 indexed node,\\n    bytes32 indexed label,\\n    address owner\\n  );\\n\\n  // Logged when the owner of a node transfers ownership to a new account.\\n  event Transfer(\\n    bytes32 indexed node,\\n    address owner\\n  );\\n\\n  // Logged when the resolver for a node changes.\\n  event NewResolver(\\n    bytes32 indexed node,\\n    address resolver\\n  );\\n\\n  // Logged when the TTL of a node changes\\n  event NewTTL(\\n    bytes32 indexed node,\\n    uint64 ttl\\n  );\\n\\n\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner\\n  ) external;\\n\\n  function setResolver(\\n    bytes32 node,\\n    address resolver\\n  ) external;\\n\\n  function setOwner(\\n    bytes32 node,\\n    address owner\\n  ) external;\\n\\n  function setTTL(\\n    bytes32 node,\\n    uint64 ttl\\n  ) external;\\n\\n  function owner(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n\\n  function resolver(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n\\n  function ttl(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (\\n      uint64\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface LinkTokenInterface {\\n\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 remaining\\n    );\\n\\n  function approve(\\n    address spender,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function balanceOf(\\n    address owner\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 balance\\n    );\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8 decimalPlaces\\n    );\\n\\n  function decreaseApproval(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function increaseApproval(\\n    address spender,\\n    uint256 subtractedValue\\n  ) external;\\n\\n  function name()\\n    external\\n    view\\n    returns (\\n      string memory tokenName\\n    );\\n\\n  function symbol()\\n    external\\n    view\\n    returns (\\n      string memory tokenSymbol\\n    );\\n\\n  function totalSupply()\\n    external\\n    view\\n    returns (\\n      uint256 totalTokensIssued\\n    );\\n\\n  function transfer(\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/OperatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ChainlinkRequestInterface.sol\\\";\\nimport \\\"./OracleInterface.sol\\\";\\n\\ninterface OperatorInterface is\\n  ChainlinkRequestInterface,\\n  OracleInterface\\n{\\n\\n  function requestOracleData(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  )\\n    external;\\n\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool\\n    );\\n\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/PointerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface PointerInterface {\\n  \\n  function getAddress()\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/vendor/ENSResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nabstract contract ENSResolver {\\n  function addr(\\n    bytes32 node\\n  )\\n    public\\n    view\\n    virtual\\n    returns (\\n      address\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/vendor/CBORChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.19;\\n\\nimport { BufferChainlink } from \\\"./BufferChainlink.sol\\\";\\n\\nlibrary CBORChainlink {\\n  using BufferChainlink for BufferChainlink.buffer;\\n\\n  uint8 private constant MAJOR_TYPE_INT = 0;\\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\\n  uint8 private constant MAJOR_TYPE_STRING = 3;\\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n  uint8 private constant MAJOR_TYPE_MAP = 5;\\n  uint8 private constant MAJOR_TYPE_TAG = 6;\\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n  function encodeType(\\n    BufferChainlink.buffer memory buf,\\n    uint8 major,\\n    uint value\\n  )\\n    private\\n    pure\\n  {\\n    if(value <= 23) {\\n      buf.appendUint8(uint8((major << 5) | value));\\n    } else if(value <= 0xFF) {\\n      buf.appendUint8(uint8((major << 5) | 24));\\n      buf.appendInt(value, 1);\\n    } else if(value <= 0xFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 25));\\n      buf.appendInt(value, 2);\\n    } else if(value <= 0xFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 26));\\n      buf.appendInt(value, 4);\\n    } else if(value <= 0xFFFFFFFFFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 27));\\n      buf.appendInt(value, 8);\\n    }\\n  }\\n\\n  function encodeIndefiniteLengthType(\\n    BufferChainlink.buffer memory buf,\\n    uint8 major\\n  )\\n    private\\n    pure\\n  {\\n    buf.appendUint8(uint8((major << 5) | 31));\\n  }\\n\\n  function encodeUInt(\\n    BufferChainlink.buffer memory buf,\\n    uint value\\n  )\\n    internal\\n    pure\\n  {\\n    encodeType(buf, MAJOR_TYPE_INT, value);\\n  }\\n\\n  function encodeInt(\\n    BufferChainlink.buffer memory buf,\\n    int value\\n  )\\n    internal\\n    pure\\n  {\\n    if(value < -0x10000000000000000) {\\n      encodeSignedBigNum(buf, value);\\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, value);\\n    } else if(value >= 0) {\\n      encodeType(buf, MAJOR_TYPE_INT, uint(value));\\n    } else {\\n      encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\\n    }\\n  }\\n\\n  function encodeBytes(\\n    BufferChainlink.buffer memory buf,\\n    bytes memory value\\n  )\\n    internal\\n    pure\\n  {\\n    encodeType(buf, MAJOR_TYPE_BYTES, value.length);\\n    buf.append(value);\\n  }\\n\\n  function encodeBigNum(\\n    BufferChainlink.buffer memory buf,\\n    int value\\n  )\\n    internal\\n    pure\\n  {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint(value)));\\n  }\\n\\n  function encodeSignedBigNum(\\n    BufferChainlink.buffer memory buf,\\n    int input\\n  )\\n    internal\\n    pure\\n  {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint(-1 - input)));\\n  }\\n\\n  function encodeString(\\n    BufferChainlink.buffer memory buf,\\n    string memory value\\n  )\\n    internal\\n    pure\\n  {\\n    encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\\n    buf.append(bytes(value));\\n  }\\n\\n  function startArray(\\n    BufferChainlink.buffer memory buf\\n  )\\n    internal\\n    pure\\n  {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n  }\\n\\n  function startMap(\\n    BufferChainlink.buffer memory buf\\n  )\\n    internal\\n    pure\\n  {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n  }\\n\\n  function endSequence(\\n    BufferChainlink.buffer memory buf\\n  )\\n    internal\\n    pure\\n  {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/vendor/BufferChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for writing to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary BufferChainlink {\\n  /**\\n  * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n  *      a capacity. The capacity may be longer than the current value, in\\n  *      which case it can be extended without the need to allocate more memory.\\n  */\\n  struct buffer {\\n    bytes buf;\\n    uint capacity;\\n  }\\n\\n  /**\\n  * @dev Initializes a buffer with an initial capacity.\\n  * @param buf The buffer to initialize.\\n  * @param capacity The number of bytes of space to allocate the buffer.\\n  * @return The buffer, for chaining.\\n  */\\n  function init(\\n    buffer memory buf,\\n    uint capacity\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (capacity % 32 != 0) {\\n      capacity += 32 - (capacity % 32);\\n    }\\n    // Allocate space for the buffer data\\n    buf.capacity = capacity;\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(buf, ptr)\\n      mstore(ptr, 0)\\n      mstore(0x40, add(32, add(ptr, capacity)))\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Initializes a new buffer from an existing bytes object.\\n  *      Changes to the buffer may mutate the original value.\\n  * @param b The bytes object to initialize the buffer with.\\n  * @return A new buffer.\\n  */\\n  function fromBytes(\\n    bytes memory b\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    buffer memory buf;\\n    buf.buf = b;\\n    buf.capacity = b.length;\\n    return buf;\\n  }\\n\\n  function resize(\\n    buffer memory buf,\\n    uint capacity\\n  )\\n    private\\n    pure\\n  {\\n    bytes memory oldbuf = buf.buf;\\n    init(buf, capacity);\\n    append(buf, oldbuf);\\n  }\\n\\n  function max(\\n    uint a,\\n    uint b\\n  )\\n    private\\n    pure\\n    returns(\\n      uint\\n    )\\n  {\\n    if (a > b) {\\n      return a;\\n    }\\n    return b;\\n  }\\n\\n  /**\\n  * @dev Sets buffer length to 0.\\n  * @param buf The buffer to truncate.\\n  * @return The original buffer, for chaining..\\n  */\\n  function truncate(\\n    buffer memory buf\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    assembly {\\n      let bufptr := mload(buf)\\n      mstore(bufptr, 0)\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The start offset to write to.\\n  * @param data The data to append.\\n  * @param len The number of bytes to copy.\\n  * @return The original buffer, for chaining.\\n  */\\n  function write(\\n    buffer memory buf,\\n    uint off,\\n    bytes memory data,\\n    uint len\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    require(len <= data.length);\\n\\n    if (off + len > buf.capacity) {\\n      resize(buf, max(buf.capacity, len + off) * 2);\\n    }\\n\\n    uint dest;\\n    uint src;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Start address = buffer address + offset + sizeof(buffer length)\\n      dest := add(add(bufptr, 32), off)\\n      // Update buffer length if we're extending it\\n      if gt(add(len, off), buflen) {\\n        mstore(bufptr, add(len, off))\\n      }\\n      src := add(data, 32)\\n    }\\n\\n    // Copy word-length chunks while possible\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    // Copy remaining bytes\\n    uint mask = 256 ** (32 - len) - 1;\\n    assembly {\\n      let srcpart := and(mload(src), not(mask))\\n      let destpart := and(mload(dest), mask)\\n      mstore(dest, or(destpart, srcpart))\\n    }\\n\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @param len The number of bytes to copy.\\n  * @return The original buffer, for chaining.\\n  */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data,\\n    uint len\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, data, len);\\n  }\\n\\n  /**\\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, data, data.length);\\n  }\\n\\n  /**\\n  * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n  *      capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write the byte at.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function writeUint8(\\n    buffer memory buf,\\n    uint off,\\n    uint8 data\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (off >= buf.capacity) {\\n      resize(buf, buf.capacity * 2);\\n    }\\n\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Address = buffer address + sizeof(buffer length) + off\\n      let dest := add(add(bufptr, off), 32)\\n      mstore8(dest, data)\\n      // Update buffer length if we extended it\\n      if eq(off, buflen) {\\n        mstore(bufptr, add(buflen, 1))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n  *      capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function appendUint8(\\n    buffer memory buf,\\n    uint8 data\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    return writeUint8(buf, buf.buf.length, data);\\n  }\\n\\n  /**\\n  * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n  *      exceed the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write at.\\n  * @param data The data to append.\\n  * @param len The number of bytes to write (left-aligned).\\n  * @return The original buffer, for chaining.\\n  */\\n  function write(\\n    buffer memory buf,\\n    uint off,\\n    bytes32 data,\\n    uint len\\n  )\\n    private\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint mask = 256 ** len - 1;\\n    // Right-align data\\n    data = data >> (8 * (32 - len));\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + sizeof(buffer length) + off + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n  *      capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write at.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function writeBytes20(\\n    buffer memory buf,\\n    uint off,\\n    bytes20 data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, off, bytes32(data), 20);\\n  }\\n\\n  /**\\n  * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chhaining.\\n  */\\n  function appendBytes20(\\n    buffer memory buf,\\n    bytes20 data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, bytes32(data), 20);\\n  }\\n\\n  /**\\n  * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function appendBytes32(\\n    buffer memory buf,\\n    bytes32 data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, data, 32);\\n  }\\n\\n  /**\\n  * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write at.\\n  * @param data The data to append.\\n  * @param len The number of bytes to write (right-aligned).\\n  * @return The original buffer, for chaining.\\n  */\\n  function writeInt(\\n    buffer memory buf,\\n    uint off,\\n    uint data,\\n    uint len\\n  )\\n    private\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint mask = 256 ** len - 1;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + off + sizeof(buffer length) + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n    * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n    * exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer.\\n    */\\n  function appendInt(\\n    buffer memory buf,\\n    uint data,\\n    uint len\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    return writeInt(buf, buf.buf.length, data, len);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/ChainlinkRequestInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface ChainlinkRequestInterface {\\n  function oracleRequest(\\n    address sender,\\n    uint256 requestPrice,\\n    bytes32 serviceAgreementID,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface OracleInterface {\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  )\\n    external\\n    returns (\\n      bool\\n    );\\n\\n  function withdraw(\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  function withdrawable()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockRewardsOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport { IRewardsOracle } from '../interfaces/IRewardsOracle.sol';\\n\\ncontract MockRewardsOracle is IRewardsOracle {\\n\\n  bytes32 _MERKLE_ROOT_;\\n  uint256 _EPOCH_;\\n  bytes _IPFS_CID_;\\n\\n  function read()\\n    external\\n    override\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid)\\n  {\\n    return (_MERKLE_ROOT_, _EPOCH_, _IPFS_CID_);\\n  }\\n\\n  function setMockValue(\\n    bytes32 merkleRoot,\\n    uint256 epoch,\\n    bytes calldata ipfsCid\\n  )\\n    external\\n  {\\n    _MERKLE_ROOT_ = merkleRoot;\\n    _EPOCH_ = epoch;\\n    _IPFS_CID_ = ipfsCid;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport { OwnableUpgradeable } from '../dependencies/open-zeppelin/OwnableUpgradeable.sol';\\nimport { SafeERC20 } from '../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { VersionedInitializable } from '../utils/VersionedInitializable.sol';\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\n\\n/**\\n * @title Treasury \\n * @notice Stores DYDX kept for incentives, just giving approval to the different\\n * systems that will pull DYDX funds for their specific use case.\\n * @author dYdX\\n **/\\ncontract Treasury is\\nOwnableUpgradeable,\\nVersionedInitializable\\n{\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public constant REVISION = 1;\\n\\n  function getRevision() internal pure override returns (uint256) {\\n    return REVISION;\\n  }\\n\\n  function initialize() external initializer {\\n    __Ownable_init();\\n  }\\n\\n  function approve(\\n    address token,\\n    address recipient,\\n    uint256 amount\\n  ) external onlyOwner {\\n    // SafeERC20 safeApprove requires setting to zero first.\\n    IERC20(token).safeApprove(recipient, 0);\\n    IERC20(token).safeApprove(recipient, amount);\\n  }\\n\\n  function transfer(\\n    address token,\\n    address recipient,\\n    uint256 amount\\n  ) external onlyOwner {\\n    IERC20(token).safeTransfer(recipient, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/misc/TreasuryMerkleClaimProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeERC20 } from '../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\n\\ninterface IMerkleDistributorV1 {\\n  function claimRewards(\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    returns (uint256);\\n}\\n\\n/**\\n * @title  TreasuryMerkleClaimProxy\\n * @author dYdX\\n *\\n * @notice Contract which claims DYDX rewards from the merkle distributor and immediately\\n *         transfers the rewards to the community treasury.\\n *\\n *         This contract is meant to be used for transferring all unclaimed epoch zero retroactive\\n *         mining rewards to the community treasury. \\n */\\ncontract TreasuryMerkleClaimProxy {\\n  using SafeERC20 for IERC20;\\n\\n  // ============ Constants ============\\n\\n  IMerkleDistributorV1 public immutable MERKLE_DISTRIBUTOR;\\n  /// @notice Address to send claimed merkle rewards to.\\n  address public immutable COMMUNITY_TREASURY;\\n  IERC20 public immutable REWARDS_TOKEN;\\n\\n  // ============ Constructor ============\\n\\n  constructor(IMerkleDistributorV1 merkleDistributor, address communityTreasury, IERC20 rewardsToken) {\\n    MERKLE_DISTRIBUTOR = merkleDistributor;\\n    COMMUNITY_TREASURY = communityTreasury;\\n    REWARDS_TOKEN = rewardsToken;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Claims rewards from merkle distributor and forwards them to the community treasury.\\n   *\\n   * @param  merkleCumulativeAmount   The cumulative rewards amount owned by this proxy on behalf of the treasury,\\n   *                                  in the MerkleDistributorV1 rewards tree.\\n   * @param  merkleProof              The Merkle proof to claim rewards for this proxy on behalf of the treasury.\\n   *\\n   * @return The total number of rewards claimed and transferred to the community treasury.\\n   */\\n  function claimRewards(\\n    uint256 merkleCumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    returns (uint256)\\n  {\\n    uint256 claimedRewards = MERKLE_DISTRIBUTOR.claimRewards(merkleCumulativeAmount, merkleProof);\\n\\n    REWARDS_TOKEN.safeTransfer(COMMUNITY_TREASURY, claimedRewards);\\n\\n    return claimedRewards;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.5;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string internal _name;\\n    string internal _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() virtual public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() virtual public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() virtual public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/token/MintableErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport { ERC20 } from '../../dependencies/open-zeppelin/ERC20.sol';\\n\\n/**\\n * @title MintableErc20\\n * @author dYdX\\n *\\n * @notice Test ERC20 token that allows anyone to mint.\\n */\\ncontract MintableErc20 is\\n  ERC20\\n{\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    uint8 decimals\\n  )\\n    ERC20(name, symbol)\\n  {\\n    _setupDecimals(decimals);\\n  }\\n\\n  /**\\n   * @notice Mint tokens to the specified account.\\n   *\\n   * @param  account  The account to receive minted tokens.\\n   * @param  value    The amount of tokens to mint.\\n   */\\n  function mint(\\n    address account,\\n    uint256 value\\n  )\\n    external\\n  {\\n    _mint(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/token/MockChainlinkToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\n\\nimport { MintableErc20 } from './MintableErc20.sol';\\n\\n/**\\n * @title MockChainlinkToken\\n * @author dYdX\\n *\\n * @notice Mock Chainlink token.\\n */\\ncontract MockChainlinkToken is\\n  MintableErc20\\n{\\n  address public _CALLED_WITH_TO_;\\n  uint256 public _CALLED_WITH_VALUE_;\\n  bytes public _CALLED_WITH_DATA_;\\n\\n  constructor()\\n    MintableErc20('Mock Chainlink Token', 'LINK', 18)\\n  {}\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes memory data\\n  )\\n    external\\n    returns (bool success)\\n  {\\n    _CALLED_WITH_TO_ = to;\\n    _CALLED_WITH_VALUE_ = value;\\n    _CALLED_WITH_DATA_ = data;\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/token/DydxToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport { ERC20 } from '../../dependencies/open-zeppelin/ERC20.sol';\\nimport { Ownable } from '../../dependencies/open-zeppelin/Ownable.sol';\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { GovernancePowerDelegationERC20Mixin } from './GovernancePowerDelegationERC20Mixin.sol';\\n\\n/**\\n * @title DydxToken\\n * @author dYdX\\n *\\n * @notice The dYdX governance token.\\n */\\ncontract DydxToken is\\n  GovernancePowerDelegationERC20Mixin,\\n  Ownable\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  /**\\n   * @dev Emitted when an address has been added to or removed from the token transfer allowlist.\\n   *\\n   * @param  account    Address that was added to or removed from the token transfer allowlist.\\n   * @param  isAllowed  True if the address was added to the allowlist, false if removed.\\n   */\\n  event TransferAllowlistUpdated(address account, bool isAllowed);\\n\\n  /**\\n   * @dev Emitted when the transfer restriction timestamp is reassigned.\\n   *\\n   * @param  transfersRestrictedBefore  The new timestamp on and after which non-allowlisted transfers may occur.\\n   */\\n  event TransfersRestrictedBeforeUpdated(uint256 transfersRestrictedBefore);\\n\\n  // ============ Constants ============\\n\\n  string internal constant NAME = 'dYdX';\\n  string internal constant SYMBOL = 'DYDX';\\n\\n  uint256 public constant INITIAL_SUPPLY = 1_000_000_000 ether;\\n\\n  bytes32 public immutable DOMAIN_SEPARATOR;\\n  bytes public constant EIP712_VERSION = '1';\\n  bytes32 public constant EIP712_DOMAIN = keccak256(\\n    'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n  );\\n  bytes32 public constant PERMIT_TYPEHASH = keccak256(\\n    'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\\n  );\\n\\n  /// @notice Minimum time between mints.\\n  uint256 public constant MINT_MIN_INTERVAL = 365 days;\\n\\n  /// @notice Cap on the percentage of the total supply that can be minted at each mint.\\n  ///  Denominated in percentage points (units out of 100).\\n  uint256 public immutable MINT_MAX_PERCENT;\\n\\n  /// @notice The timestamp on and after which the transfer restriction must be lifted.\\n  uint256 public immutable TRANSFER_RESTRICTION_LIFTED_NO_LATER_THAN;\\n\\n  // ============ Storage ============\\n\\n  /// @dev Mapping from (owner) => (next valid nonce) for EIP-712 signatures.\\n  mapping(address => uint256) internal _nonces;\\n\\n  mapping(address => mapping(uint256 => Snapshot)) public _votingSnapshots;\\n  mapping(address => uint256) public _votingSnapshotsCounts;\\n  mapping(address => address) public _votingDelegates;\\n\\n  mapping(address => mapping(uint256 => Snapshot)) public _propositionPowerSnapshots;\\n  mapping(address => uint256) public _propositionPowerSnapshotsCounts;\\n  mapping(address => address) public _propositionPowerDelegates;\\n\\n  /// @notice Snapshots of the token total supply, at each block where the total supply has changed.\\n  mapping(uint256 => Snapshot) public _totalSupplySnapshots;\\n\\n  /// @notice Number of snapshots of the token total supply.\\n  uint256 public _totalSupplySnapshotsCount;\\n\\n  /// @notice Allowlist of addresses which may send or receive tokens while transfers are\\n  ///  otherwise restricted.\\n  mapping(address => bool) public _tokenTransferAllowlist;\\n\\n  /// @notice The timestamp on and after which minting may occur.\\n  uint256 public _mintingRestrictedBefore;\\n\\n  /// @notice The timestamp on and after which non-allowlisted transfers may occur.\\n  uint256 public _transfersRestrictedBefore;\\n\\n  // ============ Constructor ============\\n\\n  /**\\n   * @notice Constructor.\\n   *\\n   * @param  distributor                           The address which will receive the initial supply of tokens.\\n   * @param  transfersRestrictedBefore             Timestamp, before which transfers are restricted unless the\\n   *                                               origin or destination address is in the allowlist.\\n   * @param  transferRestrictionLiftedNoLaterThan  Timestamp, which is the maximum timestamp that transfer\\n   *                                               restrictions can be extended to.\\n   * @param  mintingRestrictedBefore               Timestamp, before which minting is not allowed.\\n   * @param  mintMaxPercent                        Cap on the percentage of the total supply that can be minted at\\n   *                                               each mint.\\n   */\\n  constructor(\\n    address distributor,\\n    uint256 transfersRestrictedBefore,\\n    uint256 transferRestrictionLiftedNoLaterThan,\\n    uint256 mintingRestrictedBefore,\\n    uint256 mintMaxPercent\\n  )\\n    ERC20(NAME, SYMBOL)\\n  {\\n    uint256 chainId;\\n\\n    // solium-disable-next-line\\n    assembly {\\n      chainId := chainid()\\n    }\\n\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        EIP712_DOMAIN,\\n        keccak256(bytes(NAME)),\\n        keccak256(bytes(EIP712_VERSION)),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n\\n    // Validate and set parameters.\\n    require(transfersRestrictedBefore > block.timestamp, 'TRANSFERS_RESTRICTED_BEFORE_TOO_EARLY');\\n    require(transfersRestrictedBefore <= transferRestrictionLiftedNoLaterThan, 'MAX_TRANSFER_RESTRICTION_TOO_EARLY');\\n    require(mintingRestrictedBefore > block.timestamp, 'MINTING_RESTRICTED_BEFORE_TOO_EARLY');\\n    _transfersRestrictedBefore = transfersRestrictedBefore;\\n    TRANSFER_RESTRICTION_LIFTED_NO_LATER_THAN = transferRestrictionLiftedNoLaterThan;\\n    _mintingRestrictedBefore = mintingRestrictedBefore;\\n    MINT_MAX_PERCENT = mintMaxPercent;\\n\\n    // Mint the initial supply.\\n    _mint(distributor, INITIAL_SUPPLY);\\n\\n    emit TransfersRestrictedBeforeUpdated(transfersRestrictedBefore);\\n  }\\n\\n  // ============ Other Functions ============\\n\\n  /**\\n   * @notice Adds addresses to the token transfer allowlist. Reverts if any of the addresses\\n   *  already exist in the allowlist. Only callable by owner.\\n   *\\n   * @param  addressesToAdd  Addresses to add to the token transfer allowlist.\\n   */\\n  function addToTokenTransferAllowlist(address[] calldata addressesToAdd)\\n    external\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i < addressesToAdd.length; i++) {\\n      require(\\n        !_tokenTransferAllowlist[addressesToAdd[i]],\\n        'ADDRESS_EXISTS_IN_TRANSFER_ALLOWLIST'\\n      );\\n      _tokenTransferAllowlist[addressesToAdd[i]] = true;\\n      emit TransferAllowlistUpdated(addressesToAdd[i], true);\\n    }\\n  }\\n\\n  /**\\n   * @notice Removes addresses from the token transfer allowlist. Reverts if any of the addresses\\n   *  don't exist in the allowlist. Only callable by owner.\\n   *\\n   * @param  addressesToRemove  Addresses to remove from the token transfer allowlist.\\n   */\\n  function removeFromTokenTransferAllowlist(address[] calldata addressesToRemove)\\n    external\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i < addressesToRemove.length; i++) {\\n      require(\\n        _tokenTransferAllowlist[addressesToRemove[i]],\\n        'ADDRESS_DOES_NOT_EXIST_IN_TRANSFER_ALLOWLIST'\\n      );\\n      _tokenTransferAllowlist[addressesToRemove[i]] = false;\\n      emit TransferAllowlistUpdated(addressesToRemove[i], false);\\n    }\\n  }\\n\\n  /**\\n   * @notice Updates the transfer restriction. Reverts if the transfer restriction has already passed,\\n   *  the new transfer restriction is earlier than the previous one, or the new transfer restriction is\\n   *  after the maximum transfer restriction.\\n   *\\n   * @param  transfersRestrictedBefore  The timestamp on and after which non-allowlisted transfers may occur.\\n   */\\n  function updateTransfersRestrictedBefore(uint256 transfersRestrictedBefore)\\n    external\\n    onlyOwner\\n  {\\n    uint256 previousTransfersRestrictedBefore = _transfersRestrictedBefore;\\n    require(block.timestamp < previousTransfersRestrictedBefore, 'TRANSFER_RESTRICTION_ENDED');\\n    require(previousTransfersRestrictedBefore <= transfersRestrictedBefore, 'NEW_TRANSFER_RESTRICTION_TOO_EARLY');\\n    require(transfersRestrictedBefore <= TRANSFER_RESTRICTION_LIFTED_NO_LATER_THAN, 'AFTER_MAX_TRANSFER_RESTRICTION');\\n\\n    _transfersRestrictedBefore = transfersRestrictedBefore;\\n\\n    emit TransfersRestrictedBeforeUpdated(transfersRestrictedBefore);\\n  }\\n\\n  /**\\n   * @notice Mint new tokens. Only callable by owner after the required time period has elapsed.\\n   *\\n   * @param  recipient  The address to receive minted tokens.\\n   * @param  amount     The number of tokens to mint.\\n   */\\n  function mint(address recipient, uint256 amount)\\n    external\\n    onlyOwner\\n  {\\n    require(block.timestamp >= _mintingRestrictedBefore, 'MINT_TOO_EARLY');\\n    require(amount <= totalSupply().mul(MINT_MAX_PERCENT).div(100), 'MAX_MINT_EXCEEDED');\\n\\n    // Update the next allowed minting time.\\n    _mintingRestrictedBefore = block.timestamp.add(MINT_MIN_INTERVAL);\\n\\n    // Mint the amount.\\n    _mint(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Implements the permit function as specified in EIP-2612.\\n   *\\n   * @param  owner     Address of the token owner.\\n   * @param  spender   Address of the spender.\\n   * @param  value     Amount of allowance.\\n   * @param  deadline  Expiration timestamp for the signature.\\n   * @param  v         Signature param.\\n   * @param  r         Signature param.\\n   * @param  s         Signature param.\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  )\\n    external\\n  {\\n    require(owner != address(0), 'INVALID_OWNER');\\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\\n    uint256 currentValidNonce = _nonces[owner];\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        DOMAIN_SEPARATOR,\\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\\n      )\\n    );\\n\\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\\n    _nonces[owner] = currentValidNonce.add(1);\\n    _approve(owner, spender, value);\\n  }\\n\\n  /**\\n   * @notice Get the next valid nonce for EIP-712 signatures.\\n   *\\n   *  This nonce should be used when signing for any of the following functions:\\n   *   - permit()\\n   *   - delegateByTypeBySig()\\n   *   - delegateBySig()\\n   */\\n  function nonces(address owner)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _nonces[owner];\\n  }\\n\\n  function transfer(address recipient, uint256 amount)\\n    public\\n    override\\n    returns (bool)\\n  {\\n    _requireTransferAllowed(_msgSender(), recipient);\\n    return super.transfer(recipient, amount);\\n  }\\n\\n  function transferFrom(address sender, address recipient, uint256 amount)\\n    public\\n    override\\n    returns (bool)\\n  {\\n    _requireTransferAllowed(sender, recipient);\\n    return super.transferFrom(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Override _mint() to write a snapshot whenever the total supply changes.\\n   *\\n   *  These snapshots are intended to be used by the governance strategy.\\n   *\\n   *  Note that the ERC20 _burn() function is never used. If desired, an official burn mechanism\\n   *  could be implemented external to this contract, and accounted for in the governance strategy.\\n   */\\n  function _mint(address account, uint256 amount)\\n    internal\\n    override\\n  {\\n    super._mint(account, amount);\\n\\n    uint256 snapshotsCount = _totalSupplySnapshotsCount;\\n    uint128 currentBlock = uint128(block.number);\\n    uint128 newValue = uint128(totalSupply());\\n\\n    // Note: There is no special case for the total supply being updated multiple times in the same\\n    // block. That should never occur.\\n    _totalSupplySnapshots[snapshotsCount] = Snapshot(currentBlock, newValue);\\n    _totalSupplySnapshotsCount = snapshotsCount.add(1);\\n  }\\n\\n  function _requireTransferAllowed(address sender, address recipient)\\n    view\\n    internal\\n  {\\n    // Compare against the constant `TRANSFER_RESTRICTION_LIFTED_NO_LATER_THAN` first\\n    // to avoid additional gas costs from reading from storage.\\n    if (\\n      block.timestamp < TRANSFER_RESTRICTION_LIFTED_NO_LATER_THAN &&\\n      block.timestamp < _transfersRestrictedBefore\\n    ) {\\n      // While transfers are restricted, a transfer is permitted if either the sender or the\\n      // recipient is on the allowlist.\\n      require(\\n        _tokenTransferAllowlist[sender] || _tokenTransferAllowlist[recipient],\\n        'NON_ALLOWLIST_TRANSFERS_DISABLED'\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Writes a snapshot before any transfer operation, including: _transfer, _mint and _burn.\\n   *  - On _transfer, it writes snapshots for both 'from' and 'to'.\\n   *  - On _mint, only for `to`.\\n   *  - On _burn, only for `from`.\\n   *\\n   * @param  from    The sender.\\n   * @param  to      The recipient.\\n   * @param  amount  The amount being transfered.\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  )\\n    internal\\n    override\\n  {\\n    address votingFromDelegatee = _getDelegatee(from, _votingDelegates);\\n    address votingToDelegatee = _getDelegatee(to, _votingDelegates);\\n\\n    _moveDelegatesByType(\\n      votingFromDelegatee,\\n      votingToDelegatee,\\n      amount,\\n      DelegationType.VOTING_POWER\\n    );\\n\\n    address propPowerFromDelegatee = _getDelegatee(from, _propositionPowerDelegates);\\n    address propPowerToDelegatee = _getDelegatee(to, _propositionPowerDelegates);\\n\\n    _moveDelegatesByType(\\n      propPowerFromDelegatee,\\n      propPowerToDelegatee,\\n      amount,\\n      DelegationType.PROPOSITION_POWER\\n    );\\n  }\\n\\n  function _getDelegationDataByType(DelegationType delegationType)\\n    internal\\n    override\\n    view\\n    returns (\\n      mapping(address => mapping(uint256 => Snapshot)) storage, // snapshots\\n      mapping(address => uint256) storage, // snapshots count\\n      mapping(address => address) storage // delegatees list\\n    )\\n  {\\n    if (delegationType == DelegationType.VOTING_POWER) {\\n      return (_votingSnapshots, _votingSnapshotsCounts, _votingDelegates);\\n    } else {\\n      return (\\n        _propositionPowerSnapshots,\\n        _propositionPowerSnapshotsCounts,\\n        _propositionPowerDelegates\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Delegates specific governance power from signer to `delegatee` using an EIP-712 signature.\\n   *\\n   * @param  delegatee       The address to delegate votes to.\\n   * @param  delegationType  The type of delegation (VOTING_POWER, PROPOSITION_POWER).\\n   * @param  nonce           The signer's nonce for EIP-712 signatures on this contract.\\n   * @param  expiry          Expiration timestamp for the signature.\\n   * @param  v               Signature param.\\n   * @param  r               Signature param.\\n   * @param  s               Signature param.\\n   */\\n  function delegateByTypeBySig(\\n    address delegatee,\\n    DelegationType delegationType,\\n    uint256 nonce,\\n    uint256 expiry,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  )\\n    public\\n  {\\n    bytes32 structHash = keccak256(\\n      abi.encode(DELEGATE_BY_TYPE_TYPEHASH, delegatee, uint256(delegationType), nonce, expiry)\\n    );\\n    bytes32 digest = keccak256(abi.encodePacked('\\\\x19\\\\x01', DOMAIN_SEPARATOR, structHash));\\n    address signer = ecrecover(digest, v, r, s);\\n    require(signer != address(0), 'INVALID_SIGNATURE');\\n    require(nonce == _nonces[signer]++, 'INVALID_NONCE');\\n    require(block.timestamp <= expiry, 'INVALID_EXPIRATION');\\n    _delegateByType(signer, delegatee, delegationType);\\n  }\\n\\n  /**\\n   * @dev Delegates both governance powers from signer to `delegatee` using an EIP-712 signature.\\n   *\\n   * @param  delegatee  The address to delegate votes to.\\n   * @param  nonce      The signer's nonce for EIP-712 signatures on this contract.\\n   * @param  expiry     Expiration timestamp for the signature.\\n   * @param  v          Signature param.\\n   * @param  r          Signature param.\\n   * @param  s          Signature param.\\n   */\\n  function delegateBySig(\\n    address delegatee,\\n    uint256 nonce,\\n    uint256 expiry,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  )\\n    public\\n  {\\n    bytes32 structHash = keccak256(abi.encode(DELEGATE_TYPEHASH, delegatee, nonce, expiry));\\n    bytes32 digest = keccak256(abi.encodePacked('\\\\x19\\\\x01', DOMAIN_SEPARATOR, structHash));\\n    address signer = ecrecover(digest, v, r, s);\\n    require(signer != address(0), 'INVALID_SIGNATURE');\\n    require(nonce == _nonces[signer]++, 'INVALID_NONCE');\\n    require(block.timestamp <= expiry, 'INVALID_EXPIRATION');\\n    _delegateByType(signer, delegatee, DelegationType.VOTING_POWER);\\n    _delegateByType(signer, delegatee, DelegationType.PROPOSITION_POWER);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/token/GovernancePowerDelegationERC20Mixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport { ERC20 } from '../../dependencies/open-zeppelin/ERC20.sol';\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport {\\n  IGovernancePowerDelegationERC20\\n} from '../../interfaces/IGovernancePowerDelegationERC20.sol';\\n\\n/**\\n * @title GovernancePowerDelegationERC20Mixin\\n * @author dYdX\\n *\\n * @notice Provides support for two types of governance powers, both endowed by the governance\\n *  token, and separately delegatable. Provides functions for delegation and for querying a user's\\n *  power at a certain block number.\\n */\\nabstract contract GovernancePowerDelegationERC20Mixin is\\n  ERC20,\\n  IGovernancePowerDelegationERC20\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @notice EIP-712 typehash for delegation by signature of a specific governance power type.\\n  bytes32 public constant DELEGATE_BY_TYPE_TYPEHASH = keccak256(\\n    'DelegateByType(address delegatee,uint256 type,uint256 nonce,uint256 expiry)'\\n  );\\n\\n  /// @notice EIP-712 typehash for delegation by signature of all governance powers.\\n  bytes32 public constant DELEGATE_TYPEHASH = keccak256(\\n    'Delegate(address delegatee,uint256 nonce,uint256 expiry)'\\n  );\\n\\n  // ============ Structs ============\\n\\n  /// @dev Snapshot of a value on a specific block, used to track voting power for proposals.\\n  struct Snapshot {\\n    uint128 blockNumber;\\n    uint128 value;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Delegates a specific governance power to a delegatee.\\n   *\\n   * @param  delegatee       The address to delegate power to.\\n   * @param  delegationType  The type of delegation (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function delegateByType(address delegatee, DelegationType delegationType)\\n    external\\n    override\\n  {\\n    _delegateByType(msg.sender, delegatee, delegationType);\\n  }\\n\\n  /**\\n   * @notice Delegates all governance powers to a delegatee.\\n   *\\n   * @param  delegatee  The address to delegate power to.\\n   */\\n  function delegate(address delegatee)\\n    external\\n    override\\n  {\\n    _delegateByType(msg.sender, delegatee, DelegationType.VOTING_POWER);\\n    _delegateByType(msg.sender, delegatee, DelegationType.PROPOSITION_POWER);\\n  }\\n\\n  /**\\n   * @notice Returns the delegatee of a user.\\n   *\\n   * @param  delegator       The address of the delegator.\\n   * @param  delegationType  The type of delegation (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function getDelegateeByType(address delegator, DelegationType delegationType)\\n    external\\n    override\\n    view\\n    returns (address)\\n  {\\n    (, , mapping(address => address) storage delegates) = _getDelegationDataByType(delegationType);\\n\\n    return _getDelegatee(delegator, delegates);\\n  }\\n\\n  /**\\n   * @notice Returns the current power of a user. The current power is the power delegated\\n   *  at the time of the last snapshot.\\n   *\\n   * @param  user            The user whose power to query.\\n   * @param  delegationType  The type of power (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function getPowerCurrent(address user, DelegationType delegationType)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    (\\n      mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\\n      mapping(address => uint256) storage snapshotsCounts,\\n      // delegates\\n    ) = _getDelegationDataByType(delegationType);\\n\\n    return _searchByBlockNumber(snapshots, snapshotsCounts, user, block.number);\\n  }\\n\\n  /**\\n   * @notice Returns the power of a user at a certain block.\\n   *\\n   * @param  user            The user whose power to query.\\n   * @param  blockNumber     The block number at which to get the user's power.\\n   * @param  delegationType  The type of power (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function getPowerAtBlock(\\n    address user,\\n    uint256 blockNumber,\\n    DelegationType delegationType\\n  ) external override view returns (uint256) {\\n    (\\n      mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\\n      mapping(address => uint256) storage snapshotsCounts,\\n      // delegates\\n    ) = _getDelegationDataByType(delegationType);\\n\\n    return _searchByBlockNumber(snapshots, snapshotsCounts, user, blockNumber);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @dev Delegates one specific power to a delegatee.\\n   *\\n   * @param  delegator       The user whose power to delegate.\\n   * @param  delegatee       The address to delegate power to.\\n   * @param  delegationType  The type of power (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function _delegateByType(\\n    address delegator,\\n    address delegatee,\\n    DelegationType delegationType\\n  ) internal {\\n    require(delegatee != address(0), 'INVALID_DELEGATEE');\\n\\n    (, , mapping(address => address) storage delegates) = _getDelegationDataByType(delegationType);\\n\\n    uint256 delegatorBalance = balanceOf(delegator);\\n\\n    address previousDelegatee = _getDelegatee(delegator, delegates);\\n\\n    delegates[delegator] = delegatee;\\n\\n    _moveDelegatesByType(previousDelegatee, delegatee, delegatorBalance, delegationType);\\n    emit DelegateChanged(delegator, delegatee, delegationType);\\n  }\\n\\n  /**\\n   * @dev Moves power from one user to another.\\n   *\\n   * @param  from            The user from which delegated power is moved.\\n   * @param  to              The user that will receive the delegated power.\\n   * @param  amount          The amount of power to be moved.\\n   * @param  delegationType  The type of power (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function _moveDelegatesByType(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    DelegationType delegationType\\n  ) internal {\\n    if (from == to) {\\n      return;\\n    }\\n\\n    (\\n      mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\\n      mapping(address => uint256) storage snapshotsCounts,\\n      // delegates\\n    ) = _getDelegationDataByType(delegationType);\\n\\n    if (from != address(0)) {\\n      uint256 previous = 0;\\n      uint256 fromSnapshotsCount = snapshotsCounts[from];\\n\\n      if (fromSnapshotsCount != 0) {\\n        previous = snapshots[from][fromSnapshotsCount - 1].value;\\n      } else {\\n        previous = balanceOf(from);\\n      }\\n\\n      uint256 newAmount = previous.sub(amount);\\n      _writeSnapshot(\\n        snapshots,\\n        snapshotsCounts,\\n        from,\\n        uint128(newAmount)\\n      );\\n\\n      emit DelegatedPowerChanged(from, newAmount, delegationType);\\n    }\\n\\n    if (to != address(0)) {\\n      uint256 previous = 0;\\n      uint256 toSnapshotsCount = snapshotsCounts[to];\\n      if (toSnapshotsCount != 0) {\\n        previous = snapshots[to][toSnapshotsCount - 1].value;\\n      } else {\\n        previous = balanceOf(to);\\n      }\\n\\n      uint256 newAmount = previous.add(amount);\\n      _writeSnapshot(\\n        snapshots,\\n        snapshotsCounts,\\n        to,\\n        uint128(newAmount)\\n      );\\n\\n      emit DelegatedPowerChanged(to, newAmount, delegationType);\\n    }\\n  }\\n\\n  /**\\n   * @dev Searches for a balance snapshot by block number using binary search.\\n   *\\n   * @param  snapshots        The mapping of snapshots by user.\\n   * @param  snapshotsCounts  The mapping of the number of snapshots by user.\\n   * @param  user             The user for which the snapshot is being searched.\\n   * @param  blockNumber      The block number being searched.\\n   */\\n  function _searchByBlockNumber(\\n    mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\\n    mapping(address => uint256) storage snapshotsCounts,\\n    address user,\\n    uint256 blockNumber\\n  ) internal view returns (uint256) {\\n    require(blockNumber <= block.number, 'INVALID_BLOCK_NUMBER');\\n\\n    uint256 snapshotsCount = snapshotsCounts[user];\\n\\n    if (snapshotsCount == 0) {\\n      return balanceOf(user);\\n    }\\n\\n    // First check most recent balance\\n    if (snapshots[user][snapshotsCount - 1].blockNumber <= blockNumber) {\\n      return snapshots[user][snapshotsCount - 1].value;\\n    }\\n\\n    // Next check implicit zero balance\\n    if (snapshots[user][0].blockNumber > blockNumber) {\\n      return 0;\\n    }\\n\\n    uint256 lower = 0;\\n    uint256 upper = snapshotsCount - 1;\\n    while (upper > lower) {\\n      uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n      Snapshot memory snapshot = snapshots[user][center];\\n      if (snapshot.blockNumber == blockNumber) {\\n        return snapshot.value;\\n      } else if (snapshot.blockNumber < blockNumber) {\\n        lower = center;\\n      } else {\\n        upper = center - 1;\\n      }\\n    }\\n    return snapshots[user][lower].value;\\n  }\\n\\n  /**\\n   * @dev Returns delegation data (snapshot, snapshotsCount, delegates) by delegation type.\\n   *\\n   *  Note: This mixin contract does not itself define any storage, and we require the inheriting\\n   *  contract to implement this method to provide access to the relevant mappings in storage.\\n   *  This pattern was implemented by Aave for legacy reasons and we have decided not to change it.\\n   *\\n   * @param  delegationType  The type of power (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function _getDelegationDataByType(DelegationType delegationType)\\n    internal\\n    virtual\\n    view\\n    returns (\\n      mapping(address => mapping(uint256 => Snapshot)) storage, // snapshots\\n      mapping(address => uint256) storage, // snapshotsCount\\n      mapping(address => address) storage // delegates\\n    );\\n\\n  /**\\n   * @dev Writes a snapshot of a user's token/power balance.\\n   *\\n   * @param  snapshots        The mapping of snapshots by user.\\n   * @param  snapshotsCounts  The mapping of the number of snapshots by user.\\n   * @param  owner            The user whose power to snapshot.\\n   * @param  newValue         The new balance to snapshot at the current block.\\n   */\\n  function _writeSnapshot(\\n    mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\\n    mapping(address => uint256) storage snapshotsCounts,\\n    address owner,\\n    uint128 newValue\\n  ) internal {\\n    uint128 currentBlock = uint128(block.number);\\n\\n    uint256 ownerSnapshotsCount = snapshotsCounts[owner];\\n    mapping(uint256 => Snapshot) storage ownerSnapshots = snapshots[owner];\\n\\n    if (\\n      ownerSnapshotsCount != 0 &&\\n      ownerSnapshots[ownerSnapshotsCount - 1].blockNumber == currentBlock\\n    ) {\\n      // Doing multiple operations in the same block\\n      ownerSnapshots[ownerSnapshotsCount - 1].value = newValue;\\n    } else {\\n      ownerSnapshots[ownerSnapshotsCount] = Snapshot(currentBlock, newValue);\\n      snapshotsCounts[owner] = ownerSnapshotsCount + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the delegatee of a user. If a user never performed any delegation, their\\n   *  delegated address will be 0x0, in which case we return the user's own address.\\n   *\\n   * @param  delegator  The address of the user for which return the delegatee.\\n   * @param  delegates  The mapping of delegates for a particular type of delegation.\\n   */\\n  function _getDelegatee(\\n    address delegator,\\n    mapping(address => address) storage delegates\\n  )\\n    internal\\n    view\\n    returns (address)\\n  {\\n    address previousDelegatee = delegates[delegator];\\n\\n    if (previousDelegatee == address(0)) {\\n      return delegator;\\n    }\\n\\n    return previousDelegatee;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernancePowerDelegationERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface IGovernancePowerDelegationERC20 {\\n\\n  enum DelegationType {\\n    VOTING_POWER,\\n    PROPOSITION_POWER\\n  }\\n\\n  /**\\n   * @dev Emitted when a user delegates governance power to another user.\\n   *\\n   * @param  delegator       The delegator.\\n   * @param  delegatee       The delegatee.\\n   * @param  delegationType  The type of delegation (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  event DelegateChanged(\\n    address indexed delegator,\\n    address indexed delegatee,\\n    DelegationType delegationType\\n  );\\n\\n  /**\\n   * @dev Emitted when an action changes the delegated power of a user.\\n   *\\n   * @param  user            The user whose delegated power has changed.\\n   * @param  amount          The new amount of delegated power for the user.\\n   * @param  delegationType  The type of delegation (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  event DelegatedPowerChanged(address indexed user, uint256 amount, DelegationType delegationType);\\n\\n  /**\\n   * @dev Delegates a specific governance power to a delegatee.\\n   *\\n   * @param  delegatee       The address to delegate power to.\\n   * @param  delegationType  The type of delegation (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function delegateByType(address delegatee, DelegationType delegationType) external virtual;\\n\\n  /**\\n   * @dev Delegates all governance powers to a delegatee.\\n   *\\n   * @param  delegatee  The user to which the power will be delegated.\\n   */\\n  function delegate(address delegatee) external virtual;\\n\\n  /**\\n   * @dev Returns the delegatee of an user.\\n   *\\n   * @param  delegator       The address of the delegator.\\n   * @param  delegationType  The type of delegation (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function getDelegateeByType(address delegator, DelegationType delegationType)\\n    external\\n    view\\n    virtual\\n    returns (address);\\n\\n  /**\\n   * @dev Returns the current delegated power of a user. The current power is the power delegated\\n   *  at the time of the last snapshot.\\n   *\\n   * @param  user            The user whose power to query.\\n   * @param  delegationType  The type of power (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function getPowerCurrent(address user, DelegationType delegationType)\\n    external\\n    view\\n    virtual\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the delegated power of a user at a certain block.\\n   *\\n   * @param  user            The user whose power to query.\\n   * @param  blockNumber     The block number at which to get the user's power.\\n   * @param  delegationType  The type of power (VOTING_POWER, PROPOSITION_POWER).\\n   */\\n  function getPowerAtBlock(\\n    address user,\\n    uint256 blockNumber,\\n    DelegationType delegationType\\n  )\\n    external\\n    view\\n    virtual\\n    returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernanceStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IGovernanceStrategy } from '../interfaces/IGovernanceStrategy.sol';\\nimport { IGovernancePowerDelegationERC20 } from '../interfaces/IGovernancePowerDelegationERC20.sol';\\nimport { GovernancePowerDelegationERC20Mixin } from './token/GovernancePowerDelegationERC20Mixin.sol';\\n\\ninterface IDydxToken {\\n  function _totalSupplySnapshots(uint256) external view returns (GovernancePowerDelegationERC20Mixin.Snapshot memory);\\n  function _totalSupplySnapshotsCount() external view returns (uint256);\\n}\\n\\n/**\\n * @title Governance Strategy contract\\n * @dev Smart contract containing logic to measure users' relative power to propose and vote.\\n * User Power = User Power from DYDX token + User Power from staked-DYDX token.\\n * User Power from Token = Token Power + Token Power as Delegatee [- Token Power if user has delegated]\\n * Two wrapper functions linked to DYDX tokens's GovernancePowerDelegationERC20Mixin.sol implementation\\n * - getPropositionPowerAt: fetching a user Proposition Power at a specified block\\n * - getVotingPowerAt: fetching a user Voting Power at a specified block\\n * @author dYdX\\n **/\\ncontract GovernanceStrategy is IGovernanceStrategy {\\n  address public immutable DYDX_TOKEN;\\n  address public immutable STAKED_DYDX_TOKEN;\\n\\n  /**\\n   * @dev Constructor, register tokens used for Voting and Proposition Powers.\\n   * @param dydxToken The address of the DYDX token contract.\\n   * @param stakedDydxToken The address of the staked-DYDX token Contract\\n   **/\\n  constructor(address dydxToken, address stakedDydxToken) {\\n    DYDX_TOKEN = dydxToken;\\n    STAKED_DYDX_TOKEN = stakedDydxToken;\\n  }\\n\\n  /**\\n   * @dev Get the supply of proposition power, for the purpose of determining if a proposing\\n   *  threshold was reached.\\n   * @param blockNumber Block number at which to evaluate\\n   * @return Returns token supply at blockNumber.\\n   **/\\n  function getTotalPropositionSupplyAt(uint256 blockNumber) public view override returns (uint256) {\\n    return _getTotalSupplyAt(blockNumber);\\n  }\\n\\n  /**\\n   * @dev Get the supply of voting power, for the purpose of determining if quorum or vote\\n   *  differential tresholds were reached.\\n   * @param blockNumber Block number at which to evaluate\\n   * @return Returns token supply at blockNumber.\\n   **/\\n  function getTotalVotingSupplyAt(uint256 blockNumber) public view override returns (uint256) {\\n    return _getTotalSupplyAt(blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns the Proposition Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\\n   * @return Power number\\n   **/\\n  function getPropositionPowerAt(address user, uint256 blockNumber)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return\\n      _getPowerByTypeAt(user, blockNumber, IGovernancePowerDelegationERC20.DelegationType.PROPOSITION_POWER);\\n  }\\n\\n  /**\\n   * @dev Returns the Vote Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Vote Power\\n   * @return Vote number\\n   **/\\n  function getVotingPowerAt(address user, uint256 blockNumber)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return _getPowerByTypeAt(user, blockNumber, IGovernancePowerDelegationERC20.DelegationType.VOTING_POWER);\\n  }\\n\\n  function _getPowerByTypeAt(\\n    address user,\\n    uint256 blockNumber,\\n    IGovernancePowerDelegationERC20.DelegationType powerType\\n  ) internal view returns (uint256) {\\n    return\\n      IGovernancePowerDelegationERC20(DYDX_TOKEN).getPowerAtBlock(user, blockNumber, powerType) +\\n      IGovernancePowerDelegationERC20(STAKED_DYDX_TOKEN).getPowerAtBlock(user, blockNumber, powerType);\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of DYDX token at a specific block number.\\n   * @param blockNumber Blocknumber at which to fetch DYDX token supply.\\n   * @return Total DYDX token supply at block number.\\n   **/\\n  function _getTotalSupplyAt(uint256 blockNumber) internal view returns (uint256) {\\n    IDydxToken dydxToken = IDydxToken(DYDX_TOKEN);\\n    uint256 snapshotsCount = dydxToken._totalSupplySnapshotsCount();\\n\\n    // Iterate in reverse over the total supply snapshots, up to index 1.\\n    for (uint256 i = snapshotsCount - 1; i != 0; i--) {\\n      GovernancePowerDelegationERC20Mixin.Snapshot memory snapshot = dydxToken._totalSupplySnapshots(i);\\n      if (snapshot.blockNumber <= blockNumber) {\\n        return snapshot.value;\\n      }\\n    }\\n\\n    // If blockNumber was on or after the first snapshot, then return the initial supply.\\n    // Else, blockNumber is before token launch so return 0.\\n    GovernancePowerDelegationERC20Mixin.Snapshot memory firstSnapshot = dydxToken._totalSupplySnapshots(0);\\n    if (firstSnapshot.blockNumber <= blockNumber) {\\n      return firstSnapshot.value;\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernancePowerWithSnapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport { ERC20 } from '../dependencies/open-zeppelin/ERC20.sol';\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\nimport { GovernancePowerDelegationERC20Mixin } from './token/GovernancePowerDelegationERC20Mixin.sol';\\n\\n/**\\n * @title GovernancePowerWithSnapshot\\n * @notice ERC20 including snapshots of balances on transfer-related actions\\n * @author dYdX\\n **/\\nabstract contract GovernancePowerWithSnapshot is GovernancePowerDelegationERC20Mixin {\\n  using SafeMath for uint256;\\n\\n  /**\\n   * @dev The following storage layout points to the prior StakedToken.sol implementation:\\n   * _snapshots => _votingSnapshots\\n   * _snapshotsCounts =>  _votingSnapshotsCounts\\n   */\\n  mapping(address => mapping(uint256 => Snapshot)) public _votingSnapshots;\\n  mapping(address => uint256) public _votingSnapshotsCounts;\\n}\\n\"\r\n    },\r\n    \"contracts/misc/StarkExRemoverGovernorV2.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { Ownable } from '../dependencies/open-zeppelin/Ownable.sol';\\nimport { IStarkPerpetual } from '../interfaces/IStarkPerpetual.sol';\\n\\n/**\\n * @title StarkExRemoverGovernorV2\\n * @author dYdX\\n *\\n * @notice This is a StarkEx governor contract whose sole purpose is to remove other governors.\\n *\\n *  This contract can be nominated by a StarkEx governor in order to allow themselves to be removed\\n *  “automatically” from the governor role. The governor should nominate this contract to the main\\n *  and proxy governor roles, while ensuring that the MAIN_GOVERNORS_TO_REMOVE and\\n *  PROXY_GOVERNORS_TO_REMOVE values are correctly set.\\n */\\ncontract StarkExRemoverGovernorV2 is\\n  Ownable\\n{\\n  IStarkPerpetual public immutable STARK_PERPETUAL;\\n  address[] public MAIN_GOVERNORS_TO_REMOVE;\\n  address[] public PROXY_GOVERNORS_TO_REMOVE;\\n\\n  constructor(\\n    address starkPerpetual,\\n    address[] memory mainGovernorsToRemove,\\n    address[] memory proxyGovernorsToRemove\\n  ) {\\n    STARK_PERPETUAL = IStarkPerpetual(starkPerpetual);\\n    MAIN_GOVERNORS_TO_REMOVE = mainGovernorsToRemove;\\n    PROXY_GOVERNORS_TO_REMOVE = proxyGovernorsToRemove;\\n  }\\n\\n  function mainAcceptGovernance()\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.mainAcceptGovernance();\\n  }\\n\\n  function proxyAcceptGovernance()\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.proxyAcceptGovernance();\\n  }\\n\\n  function mainRemoveGovernor(\\n    uint256 i\\n  )\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.mainRemoveGovernor(MAIN_GOVERNORS_TO_REMOVE[i]);\\n  }\\n\\n  function proxyRemoveGovernor(\\n    uint256 i\\n  )\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.proxyRemoveGovernor(PROXY_GOVERNORS_TO_REMOVE[i]);\\n  }\\n\\n  function numMainGovernorsToRemove()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return MAIN_GOVERNORS_TO_REMOVE.length;\\n  }\\n\\n  function numProxyGovernorsToRemove()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return PROXY_GOVERNORS_TO_REMOVE.length;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStarkPerpetual.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title IStarkPerpetual\\n * @author dYdX\\n *\\n * @notice Partial interface for the StarkPerpetual contract, for accessing the dYdX L2 exchange.\\n * @dev See https://github.com/starkware-libs/starkex-contracts\\n */\\ninterface IStarkPerpetual {\\n\\n  function registerUser(\\n    address ethKey,\\n    uint256 starkKey,\\n    bytes calldata signature\\n  ) external;\\n\\n  function deposit(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId,\\n    uint256 quantizedAmount\\n  ) external;\\n\\n  function withdraw(uint256 starkKey, uint256 assetType) external;\\n\\n  function forcedWithdrawalRequest(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    uint256 quantizedAmount,\\n    bool premiumCost\\n  ) external;\\n\\n  function forcedTradeRequest(\\n    uint256 starkKeyA,\\n    uint256 starkKeyB,\\n    uint256 vaultIdA,\\n    uint256 vaultIdB,\\n    uint256 collateralAssetId,\\n    uint256 syntheticAssetId,\\n    uint256 amountCollateral,\\n    uint256 amountSynthetic,\\n    bool aIsBuyingSynthetic,\\n    uint256 submissionExpirationTime,\\n    uint256 nonce,\\n    bytes calldata signature,\\n    bool premiumCost\\n  ) external;\\n\\n  function mainAcceptGovernance() external;\\n  function proxyAcceptGovernance() external;\\n\\n  function mainRemoveGovernor(address governorForRemoval) external;\\n  function proxyRemoveGovernor(address governorForRemoval) external;\\n\\n  function registerAssetConfigurationChange(uint256 assetId, bytes32 configHash) external;\\n  function applyAssetConfigurationChange(uint256 assetId, bytes32 configHash) external;\\n\\n  function registerGlobalConfigurationChange(bytes32 configHash) external;\\n  function applyGlobalConfigurationChange(bytes32 configHash) external;\\n\\n  function getEthKey(uint256 starkKey) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/StarkExRemoverGovernor.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { Ownable } from '../dependencies/open-zeppelin/Ownable.sol';\\nimport { IStarkPerpetual } from '../interfaces/IStarkPerpetual.sol';\\n\\n/**\\n * @title StarkExRemoverGovernor\\n * @author dYdX\\n *\\n * @notice This is a StarkEx governor contract whose sole purpose is to remove another governor.\\n *\\n *  This contract can be nominated by a StarkEx governor in order to allow themselves to be removed\\n *  “automatically” from the governor role. The governor should nominate this contract to the main\\n *  and proxy governor roles, while ensuring that the GOVERNOR_TO_REMOVE address is correctly set\\n *  to their own address.\\n */\\ncontract StarkExRemoverGovernor is\\n  Ownable\\n{\\n  IStarkPerpetual public immutable STARK_PERPETUAL;\\n  address public immutable GOVERNOR_TO_REMOVE;\\n\\n  constructor(\\n    address starkPerpetual,\\n    address governorToRemove\\n  ) {\\n    STARK_PERPETUAL = IStarkPerpetual(starkPerpetual);\\n    GOVERNOR_TO_REMOVE = governorToRemove;\\n  }\\n\\n  function mainAcceptGovernance()\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.mainAcceptGovernance();\\n  }\\n\\n  function proxyAcceptGovernance()\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.proxyAcceptGovernance();\\n  }\\n\\n  function mainRemoveGovernor()\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.mainRemoveGovernor(GOVERNOR_TO_REMOVE);\\n  }\\n\\n  function proxyRemoveGovernor()\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.proxyRemoveGovernor(GOVERNOR_TO_REMOVE);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/StarkExHelperGovernor.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { Ownable } from '../dependencies/open-zeppelin/Ownable.sol';\\nimport { IStarkPerpetual } from '../interfaces/IStarkPerpetual.sol';\\n\\n/**\\n * @title StarkExHelperGovernor\\n * @author dYdX\\n *\\n * @notice This is a StarkEx governor which can be used by the owner to execute config changes.\\n */\\ncontract StarkExHelperGovernor is\\n  Ownable\\n{\\n  IStarkPerpetual public immutable STARK_PERPETUAL;\\n\\n  constructor(\\n    address starkPerpetual\\n  ) {\\n    STARK_PERPETUAL = IStarkPerpetual(starkPerpetual);\\n  }\\n\\n  function mainAcceptGovernance()\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.mainAcceptGovernance();\\n  }\\n\\n  /**\\n   * @notice Helper function to register and apply multiple asset configuration changes.\\n   *\\n   *  Requires that there is no timelock set on the StarkEx contract.\\n   *\\n   * @param  assetIds      Array of asset IDs for the assets to be configured.\\n   * @param  configHashes  Array of hashes of the asset configurations.\\n   */\\n  function executeAssetConfigurationChanges(\\n    uint256[] calldata assetIds,\\n    bytes32[] calldata configHashes\\n  )\\n    external\\n    onlyOwner\\n  {\\n    require(\\n      assetIds.length == configHashes.length,\\n      'StarkExHelperGovernor: Input params must have the same length'\\n    );\\n    for (uint256 i = 0; i < assetIds.length; i++) {\\n      STARK_PERPETUAL.registerAssetConfigurationChange(assetIds[i], configHashes[i]);\\n      STARK_PERPETUAL.applyAssetConfigurationChange(assetIds[i], configHashes[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Helper function to register and apply a global configuration change.\\n   *\\n   *  Requires that there is no timelock set on the StarkEx contract.\\n   *\\n   * @param  configHash  The hash of the global configuration.\\n   */\\n  function executeGlobalConfigurationChange(\\n    bytes32 configHash\\n  )\\n    external\\n    onlyOwner\\n  {\\n    STARK_PERPETUAL.registerGlobalConfigurationChange(configHash);\\n    STARK_PERPETUAL.applyGlobalConfigurationChange(configHash);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/ProxyAdmin.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.5;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./AdminUpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title ProxyAdmin\\n * @dev This contract is the admin of a proxy, and is in charge\\n * of upgrading it as well as transferring it to another admin.\\n */\\ncontract ProxyAdmin is Ownable {\\n  \\n  /**\\n   * @dev Returns the current implementation of a proxy.\\n   * This is needed because only the proxy admin can query it.\\n   * @return The address of the current implementation of the proxy.\\n   */\\n  function getProxyImplementation(AdminUpgradeabilityProxy proxy) public view returns (address) {\\n    // We need to manually run the static call since the getter cannot be flagged as view\\n    // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n    require(success);\\n    return abi.decode(returndata, (address));\\n  }\\n\\n  /**\\n   * @dev Returns the admin of a proxy. Only the admin can query it.\\n   * @return The address of the current admin of the proxy.\\n   */\\n  function getProxyAdmin(AdminUpgradeabilityProxy proxy) public view returns (address) {\\n    // We need to manually run the static call since the getter cannot be flagged as view\\n    // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n    require(success);\\n    return abi.decode(returndata, (address));\\n  }\\n\\n  /**\\n   * @dev Changes the admin of a proxy.\\n   * @param proxy Proxy to change admin.\\n   * @param newAdmin Address to transfer proxy administration to.\\n   */\\n  function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin) public onlyOwner {\\n    proxy.changeAdmin(newAdmin);\\n  }\\n\\n  /**\\n   * @dev Upgrades a proxy to the newest implementation of a contract.\\n   * @param proxy Proxy to be upgraded.\\n   * @param implementation the address of the Implementation.\\n   */\\n  function upgrade(AdminUpgradeabilityProxy proxy, address implementation) public onlyOwner {\\n    proxy.upgradeTo(implementation);\\n  }\\n\\n  /**\\n   * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\\n   * This is useful to initialize the proxied contract.\\n   * @param proxy Proxy to be upgraded.\\n   * @param implementation Address of the Implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeAndCall(AdminUpgradeabilityProxy proxy, address implementation, bytes memory data) payable public onlyOwner {\\n    proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/AdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.5;\\n\\nimport './BaseAdminUpgradeabilityProxy.sol';\\n\\n/**\\n * @title AdminUpgradeabilityProxy\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \\n * initializing the implementation, admin, and init data.\\n */\\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\\n  /**\\n   * Contract constructor.\\n   * @param _logic address of the initial implementation.\\n   * @param _admin Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\\n    _setAdmin(_admin);\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\\n    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');\\n    super._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/BaseAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\nimport './UpgradeabilityProxy.sol';\\n\\n/**\\n * @title BaseAdminUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks.\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  /**\\n   * @dev Emitted when the administration has been transferred.\\n   * @param previousAdmin Address of the previous admin.\\n   * @param newAdmin Address of the new admin.\\n   */\\n  event AdminChanged(address previousAdmin, address newAdmin);\\n\\n  /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n\\n  bytes32\\n    internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n  /**\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\n   * to the implementation.\\n   */\\n  modifier ifAdmin() {\\n    if (msg.sender == _admin()) {\\n      _;\\n    } else {\\n      _fallback();\\n    }\\n  }\\n\\n  /**\\n   * @return The address of the proxy admin.\\n   */\\n  function admin() external ifAdmin returns (address) {\\n    return _admin();\\n  }\\n\\n  /**\\n   * @return The address of the implementation.\\n   */\\n  function implementation() external ifAdmin returns (address) {\\n    return _implementation();\\n  }\\n\\n  /**\\n   * @dev Changes the admin of the proxy.\\n   * Only the current admin can call this function.\\n   * @param newAdmin Address to transfer proxy administration to.\\n   */\\n  function changeAdmin(address newAdmin) external ifAdmin {\\n    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');\\n    emit AdminChanged(_admin(), newAdmin);\\n    _setAdmin(newAdmin);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function upgradeTo(address newImplementation) external ifAdmin {\\n    _upgradeTo(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\\n    external\\n    payable\\n    ifAdmin\\n  {\\n    _upgradeTo(newImplementation);\\n    (bool success, ) = newImplementation.delegatecall(data);\\n    require(success);\\n  }\\n\\n  /**\\n   * @return adm The admin slot.\\n   */\\n  function _admin() internal view returns (address adm) {\\n    bytes32 slot = ADMIN_SLOT;\\n    assembly {\\n      adm := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Sets the address of the proxy admin.\\n   * @param newAdmin Address of the new proxy admin.\\n   */\\n  function _setAdmin(address newAdmin) internal {\\n    bytes32 slot = ADMIN_SLOT;\\n\\n    assembly {\\n      sstore(slot, newAdmin)\\n    }\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal virtual override {\\n    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');\\n    super._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/UpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\nimport './BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title UpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\\n * implementation and init data.\\n */\\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  /**\\n   * @dev Contract constructor.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  constructor(address _logic, bytes memory _data) public payable {\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\\n    _setImplementation(_logic);\\n    if (_data.length > 0) {\\n      (bool success, ) = _logic.delegatecall(_data);\\n      require(success);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/BaseUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\nimport './Proxy.sol';\\nimport './Address.sol';\\n\\n/**\\n * @title BaseUpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract BaseUpgradeabilityProxy is Proxy {\\n  /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n  event Upgraded(address indexed implementation);\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32\\n    internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n  /**\\n   * @dev Returns the current implementation.\\n   * @return impl Address of the current implementation\\n   */\\n  function _implementation() internal override view returns (address impl) {\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n    assembly {\\n      impl := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _upgradeTo(address newImplementation) internal {\\n    _setImplementation(newImplementation);\\n    emit Upgraded(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _setImplementation(address newImplementation) internal {\\n    require(\\n      Address.isContract(newImplementation),\\n      'Cannot set a proxy implementation to a non-contract address'\\n    );\\n\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n    assembly {\\n      sstore(slot, newImplementation)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Proxy.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\nabstract contract Proxy {\\n  /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n  fallback() external payable {\\n    _fallback();\\n  }\\n\\n  /**\\n   * @return The Address of the implementation.\\n   */\\n  function _implementation() internal virtual view returns (address);\\n\\n  /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n  function _delegate(address implementation) internal {\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize())\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize())\\n\\n      switch result\\n        // delegatecall returns 0 on error.\\n        case 0 {\\n          revert(0, returndatasize())\\n        }\\n        default {\\n          return(0, returndatasize())\\n        }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n  function _willFallback() internal virtual {}\\n\\n  /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n  function _fallback() internal {\\n    _willFallback();\\n    _delegate(_implementation());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/InitializableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport './BaseAdminUpgradeabilityProxy.sol';\\nimport './InitializableUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableAdminUpgradeabilityProxy\\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\\n * initializing the implementation, admin, and init data.\\n */\\ncontract InitializableAdminUpgradeabilityProxy is\\n  BaseAdminUpgradeabilityProxy,\\n  InitializableUpgradeabilityProxy\\n{\\n  /**\\n   * Contract initializer.\\n   * @param _logic address of the initial implementation.\\n   * @param _admin Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  function initialize(\\n    address _logic,\\n    address _admin,\\n    bytes memory _data\\n  ) public payable {\\n    require(_implementation() == address(0));\\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\\n    _setAdmin(_admin);\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\\n    BaseAdminUpgradeabilityProxy._willFallback();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/InitializableUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport './BaseUpgradeabilityProxy.sol';\\n\\n/**\\n * @title InitializableUpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\n * implementation and init data.\\n */\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n  /**\\n   * @dev Contract initializer.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  function initialize(address _logic, bytes memory _data) public payable {\\n    require(_implementation() == address(0));\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\\n    _setImplementation(_logic);\\n    if (_data.length > 0) {\\n      (bool success, ) = _logic.delegatecall(_data);\\n      require(success);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockStarkPerpetual.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\n\\n/**\\n * @title MockStarkPerpetual\\n * @author dYdX\\n *\\n * @notice Mock implementation for the StarkPerpetual contract, for accessing the dYdX L2 exchange.\\n * @dev See https://github.com/starkware-libs/starkex-contracts\\n */\\ncontract MockStarkPerpetual {\\n\\n  // ============ Mock Exchange Functionality ============\\n\\n  event MockStarkRegistered(address ethKey, uint256 starkKey, bytes signature);\\n\\n  event MockStarkDeposited(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId,\\n    uint256 quantizedAmount\\n  );\\n\\n  event MockStarkWithdrew(uint256 starkKey, uint256 assetType, uint256 amount);\\n\\n  mapping(uint256 => address) public _REGISTRATIONS_;\\n\\n  mapping(address => uint256) public _DEPOSITS_;\\n\\n  IERC20 public immutable TOKEN;\\n\\n  constructor(IERC20 token) {\\n    TOKEN = token;\\n  }\\n\\n  function registerUser(\\n    address ethKey,\\n    uint256 starkKey,\\n    bytes calldata signature\\n  ) external {\\n    _REGISTRATIONS_[starkKey] = ethKey;\\n    emit MockStarkRegistered(ethKey, starkKey, signature);\\n  }\\n\\n  function deposit(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId,\\n    uint256 quantizedAmount\\n  ) external {\\n    // Require registered.\\n    getEthKey(starkKey);\\n\\n    // Assume no overflow since this is just for test purposes.\\n    _DEPOSITS_[msg.sender] = _DEPOSITS_[msg.sender] + quantizedAmount;\\n    require(TOKEN.transferFrom(msg.sender, address(this), quantizedAmount));\\n    emit MockStarkDeposited(starkKey, assetType, vaultId, quantizedAmount);\\n  }\\n\\n  function withdraw(uint256 starkKey, uint256 assetType) external {\\n    // Require registered.\\n    getEthKey(starkKey);\\n\\n    uint256 amount = _DEPOSITS_[msg.sender];\\n    _DEPOSITS_[msg.sender] = 0;\\n    require(TOKEN.transfer(msg.sender, amount));\\n    emit MockStarkWithdrew(starkKey, assetType, amount);\\n  }\\n\\n  function forcedWithdrawalRequest(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    uint256 quantizedAmount,\\n    bool premiumCost\\n  ) external {\\n    // Require registered.\\n    getEthKey(starkKey);\\n  }\\n\\n  function getEthKey(uint256 starkKey) public view returns(address) {\\n    address ethKey = _REGISTRATIONS_[starkKey];\\n    require(ethKey != address(0), 'USER_UNREGISTERED');\\n    return ethKey;\\n  }\\n\\n  // ============ Mock Governance Functionality ============\\n\\n  mapping(address => bool) public _MAIN_GOVERNORS_;\\n  mapping(address => bool) public _PROXY_GOVERNORS_;\\n  mapping(uint256 => mapping(bytes32 => bool)) public _REGISTERED_ASSET_CONFIGS_;\\n  mapping(bytes32 => bool) public _REGISTERED_GLOBAL_CONFIGS_;\\n  mapping(uint256 => bytes32) public _ASSET_CONFIGS_;\\n  bytes32 public _GLOBAL_CONFIG_;\\n\\n  function mainAcceptGovernance() external {\\n    // Assume already nominated.\\n    _MAIN_GOVERNORS_[msg.sender] = true;\\n  }\\n\\n  function proxyAcceptGovernance() external {\\n    // Assume already nominated.\\n    _PROXY_GOVERNORS_[msg.sender] = true;\\n  }\\n\\n  function mainRemoveGovernor(address governorForRemoval) external {\\n    require(_MAIN_GOVERNORS_[msg.sender], 'MockStarkPerpetual: Sender is not a main governor');\\n    require(governorForRemoval != msg.sender, 'MockStarkPerpetual: Cannot remove self');\\n    _MAIN_GOVERNORS_[governorForRemoval] = false;\\n  }\\n\\n  function proxyRemoveGovernor(address governorForRemoval) external {\\n    require(_PROXY_GOVERNORS_[msg.sender], 'MockStarkPerpetual: Sender is not a proxy governor');\\n    require(governorForRemoval != msg.sender, 'MockStarkPerpetual: Cannot remove self');\\n    _PROXY_GOVERNORS_[governorForRemoval] = false;\\n  }\\n\\n  function registerAssetConfigurationChange(uint256 assetId, bytes32 configHash) external {\\n    require(_MAIN_GOVERNORS_[msg.sender], 'MockStarkPerpetual: Sender is not a main governor');\\n    _REGISTERED_ASSET_CONFIGS_[assetId][configHash] = true;\\n  }\\n\\n  function applyAssetConfigurationChange(uint256 assetId, bytes32 configHash) external {\\n    require(_MAIN_GOVERNORS_[msg.sender], 'MockStarkPerpetual: Sender is not a main governor');\\n    require(\\n      _REGISTERED_ASSET_CONFIGS_[assetId][configHash],\\n      'MockStarkPerpetual: Asset config not registered'\\n    );\\n    _ASSET_CONFIGS_[assetId] = configHash;\\n  }\\n\\n  function registerGlobalConfigurationChange(bytes32 configHash) external {\\n    require(_MAIN_GOVERNORS_[msg.sender], 'MockStarkPerpetual: Sender is not a main governor');\\n    _REGISTERED_GLOBAL_CONFIGS_[configHash] = true;\\n  }\\n\\n  function applyGlobalConfigurationChange(bytes32 configHash) external {\\n    require(_MAIN_GOVERNORS_[msg.sender], 'MockStarkPerpetual: Sender is not a main governor');\\n    require(\\n      _REGISTERED_GLOBAL_CONFIGS_[configHash],\\n      'MockStarkPerpetual: Global config not registered'\\n    );\\n    _GLOBAL_CONFIG_ = configHash;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/DoubleTransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport '../interfaces/IERC20.sol';\\n\\ncontract DoubleTransferHelper {\\n  IERC20 public immutable TOKEN;\\n\\n  constructor(IERC20 token) public {\\n    TOKEN = token;\\n  }\\n\\n  function doubleSend(\\n    address to,\\n    uint256 amount1,\\n    uint256 amount2\\n  ) external {\\n    TOKEN.transfer(to, amount1);\\n    TOKEN.transfer(to, amount2);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nimport { IERC20 } from './IERC20.sol';\\n\\n/**\\n * @dev Interface for ERC20 including metadata\\n **/\\ninterface IERC20Detailed is IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { ExecutorWithTimelockMixin } from './ExecutorWithTimelockMixin.sol';\\nimport { ProposalValidatorMixin } from './ProposalValidatorMixin.sol';\\n\\n/**\\n * @title Time Locked, Validator, Executor Contract\\n * @dev Contract\\n * - Validate Proposal creations/ cancellation\\n * - Validate Vote Quorum and Vote success on proposal\\n * - Queue, Execute, Cancel, successful proposals' transactions.\\n * @author dYdX\\n **/\\ncontract Executor is ExecutorWithTimelockMixin, ProposalValidatorMixin {\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    uint256 propositionThreshold,\\n    uint256 voteDuration,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  )\\n    ExecutorWithTimelockMixin(admin, delay, gracePeriod, minimumDelay, maximumDelay)\\n    ProposalValidatorMixin(propositionThreshold, voteDuration, voteDifferential, minimumQuorum)\\n  {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IMerkleDistributorV1\",\"name\":\"merkleDistributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"communityTreasury\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"rewardsToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"COMMUNITY_TREASURY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MERKLE_DISTRIBUTOR\",\"outputs\":[{\"internalType\":\"contract IMerkleDistributorV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleCumulativeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TreasuryMerkleClaimProxy","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000001d3348601968ab85b4bb028979006eac235a588000000000000000000000000e710ced57456d3a16152c32835b5fb4e72d9ea5b00000000000000000000000092d6c1e31e14520e676a687f0a93788b716beff5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}