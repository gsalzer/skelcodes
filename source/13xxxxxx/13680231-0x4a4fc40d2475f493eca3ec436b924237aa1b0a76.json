{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PoolStakes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./interfaces/Constants.sol\\\";\\nimport { PoolParams } from \\\"./interfaces/Types.sol\\\";\\nimport \\\"./interfaces/IVestingPools.sol\\\";\\nimport \\\"./utils/Claimable.sol\\\";\\nimport \\\"./utils/DefaultOwnable.sol\\\";\\nimport { DefaultOwnerAddress, TokenAddress, VestingPoolsAddress } from \\\"./utils/Linking.sol\\\";\\nimport \\\"./utils/ProxyFactory.sol\\\";\\nimport \\\"./utils/SafeUints.sol\\\";\\n\\n/**\\n * @title PoolStakes\\n * @notice The contract claims (ERC-20) token from the \\\"VestingPools\\\" contract\\n * and then let \\\"stakeholders\\\" withdraw token amounts prorate to their stakes.\\n * @dev A few copy of this contract (i.e. proxies created via the {createProxy}\\n * method) are supposed to run. Every proxy distributes its own \\\"vesting pool\\\",\\n * so it (the proxy) must be registered with the \\\"VestingPools\\\" contract as the\\n * \\\"wallet\\\" for that \\\"vesting pool\\\".\\n */\\ncontract PoolStakes is\\n    Claimable,\\n    SafeUints,\\n    ProxyFactory,\\n    DefaultOwnable,\\n    Constants\\n{\\n    // @dev \\\"Stake\\\" of a \\\"stakeholder\\\" in the \\\"vesting pool\\\"\\n    struct Stake {\\n        // token amount allocated for the stakeholder\\n        uint96 allocated;\\n        // token amount released to the stakeholder so far\\n        uint96 released;\\n    }\\n\\n    /// @notice ID of the vesting pool this contract is the \\\"wallet\\\" for\\n    uint16 public poolId;\\n    /// @notice Token amount the vesting pool is set to vest\\n    uint96 public allocation;\\n    /// @notice Token amount allocated from {allocation} to stakeholders so far\\n    /// @dev It is the total amount of all {stakes[..].allocated}\\n    uint96 public allocated;\\n\\n    /// @notice Token amount released to stakeholders so far\\n    /// @dev It is the total amount of all {stakes[..].released}\\n    uint96 public released;\\n    /// @notice Share of vested amount attributable to 1 unit of {allocation}\\n    /// @dev Stakeholder \\\"h\\\" may withdraw from the contract this token amount:\\n    ///     factor/SCALE * stakes[h].allocated - stakes[h].released\\n    uint160 public factor;\\n\\n    // mapping from stakeholder address to stake\\n    mapping(address => Stake) public stakes;\\n\\n    event VestingClaimed(uint256 amount);\\n    event Released(address indexed holder, uint256 amount);\\n    event StakeAdded(address indexed holder, uint256 allocated);\\n    event StakeSplit(\\n        address indexed holder,\\n        uint256 allocated,\\n        uint256 released\\n    );\\n\\n    /// @notice Returns address of the token being vested\\n    function token() external view returns (address) {\\n        return address(_getToken());\\n    }\\n\\n    /// @notice Returns address of the {VestingPool} smart contract\\n    function vestingPools() external view returns (address) {\\n        return address(_getVestingPools());\\n    }\\n\\n    /// @notice Returns token amount the specified stakeholder may withdraw now\\n    function releasableAmount(address holder) external view returns (uint256) {\\n        Stake memory stake = _getStake(holder);\\n        return _releasableAmount(stake, uint256(factor));\\n    }\\n\\n    /// @notice Returns token amount the specified stakeholder may withdraw now\\n    /// on top of the {releasableAmount} should {claimVesting} be called\\n    function unclaimedShare(address holder) external view returns (uint256) {\\n        Stake memory stake = _getStake(holder);\\n        uint256 unclaimed = _getVestingPools().releasableAmount(poolId);\\n        return (unclaimed * uint256(stake.allocated)) / allocation;\\n    }\\n\\n    /// @notice Claims vesting to this contract from the vesting pool\\n    function claimVesting() external {\\n        _claimVesting();\\n    }\\n\\n    /////////////////////\\n    //// StakeHolder ////\\n    /////////////////////\\n\\n    /// @notice Sends the releasable amount to the message sender\\n    /// @dev Stakeholder only may call\\n    function withdraw() external {\\n        _withdraw(msg.sender); // throws if msg.sender is not a stakeholder\\n    }\\n\\n    /// @notice Calls {claimVesting} and sends the releasable amount to the message sender\\n    /// @dev Stakeholder only may call\\n    function claimAndWithdraw() external {\\n        _claimVesting();\\n        _withdraw(msg.sender); // throws if msg.sender is not a stakeholder\\n    }\\n\\n    /// @notice Allots a new stake out of the stake of the message sender\\n    /// @dev Stakeholder only may call\\n    function splitStake(address newHolder, uint256 newAmount) external {\\n        address holder = msg.sender;\\n        require(newHolder != holder, \\\"PStakes: duplicated address\\\");\\n\\n        Stake memory stake = _getStake(holder);\\n        require(newAmount <= stake.allocated, \\\"PStakes: too large allocated\\\");\\n\\n        uint256 updAmount = uint256(stake.allocated) - newAmount;\\n        uint256 updReleased = (uint256(stake.released) * updAmount) /\\n            uint256(stake.allocated);\\n        stakes[holder] = Stake(_safe96(updAmount), _safe96(updReleased));\\n        emit StakeSplit(holder, updAmount, updReleased);\\n\\n        uint256 newVested = uint256(stake.released) - updReleased;\\n        stakes[newHolder] = Stake(_safe96(newAmount), _safe96(newVested));\\n        emit StakeSplit(newHolder, newAmount, newVested);\\n    }\\n\\n    //////////////////\\n    //// Owner ////\\n    //////////////////\\n\\n    /// @notice Inits the contract and adds stakes\\n    /// @dev Owner only may call on a proxy (but not on the implementation)\\n    function addStakes(\\n        uint256 _poolId,\\n        address[] calldata holders,\\n        uint256[] calldata allocations,\\n        uint256 unallocated\\n    ) external onlyOwner {\\n        if (allocation == 0) {\\n            _init(_poolId);\\n        } else {\\n            require(_poolId == poolId, \\\"PStakes: pool mismatch\\\");\\n        }\\n\\n        uint256 nEntries = holders.length;\\n        require(nEntries == allocations.length, \\\"PStakes: length mismatch\\\");\\n        uint256 updAllocated = uint256(allocated);\\n        for (uint256 i = 0; i < nEntries; i++) {\\n            _throwZeroHolderAddress(holders[i]);\\n            require(\\n                stakes[holders[i]].allocated == 0,\\n                \\\"PStakes: holder exists\\\"\\n            );\\n            require(allocations[i] > 0, \\\"PStakes: zero allocation\\\");\\n\\n            updAllocated += allocations[i];\\n            stakes[holders[i]] = Stake(_safe96(allocations[i]), 0);\\n            emit StakeAdded(holders[i], allocations[i]);\\n        }\\n        require(\\n            updAllocated + unallocated == allocation,\\n            \\\"PStakes: invalid allocation\\\"\\n        );\\n        allocated = _safe96(updAllocated);\\n    }\\n\\n    /// @notice Calls {claimVesting} and sends releasable tokens to specified stakeholders\\n    /// @dev Owner may call only\\n    function massWithdraw(address[] calldata holders) external onlyOwner {\\n        _claimVesting();\\n        for (uint256 i = 0; i < holders.length; i++) {\\n            _withdraw(holders[i]);\\n        }\\n    }\\n\\n    /// @notice Withdraws accidentally sent token from this contract\\n    /// @dev Owner may call only\\n    function claimErc20(\\n        address claimedToken,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner nonReentrant {\\n        IERC20 vestedToken = IERC20(address(_getToken()));\\n        if (claimedToken == address(vestedToken)) {\\n            uint256 balance = vestedToken.balanceOf(address(this));\\n            require(\\n                balance - amount >= allocation - released,\\n                \\\"PStakes: too big amount\\\"\\n            );\\n        }\\n        _claimErc20(claimedToken, to, amount);\\n    }\\n\\n    /// @notice Removes the contract from blockchain when tokens are released\\n    /// @dev Owner only may call on a proxy (but not on the implementation)\\n    function removeContract() external onlyOwner {\\n        // avoid accidental removing of the implementation\\n        _throwImplementation();\\n\\n        require(allocation == released, \\\"PStakes: unpaid stakes\\\");\\n\\n        IERC20 vestedToken = IERC20(address(_getToken()));\\n        uint256 balance = vestedToken.balanceOf(address(this));\\n        require(balance == 0, \\\"PStakes: non-zero balance\\\");\\n\\n        selfdestruct(payable(msg.sender));\\n    }\\n\\n    //////////////////\\n    //// Internal ////\\n    //////////////////\\n\\n    /// @dev Returns the address of the default owner\\n    // (declared `view` rather than `pure` to facilitate testing)\\n    function _defaultOwner() internal view virtual override returns (address) {\\n        return address(DefaultOwnerAddress);\\n    }\\n\\n    /// @dev Returns Token contract address\\n    // (declared `view` rather than `pure` to facilitate testing)\\n    function _getToken() internal view virtual returns (IERC20) {\\n        return IERC20(address(TokenAddress));\\n    }\\n\\n    /// @dev Returns VestingPools contract address\\n    // (declared `view` rather than `pure` to facilitate testing)\\n    function _getVestingPools() internal view virtual returns (IVestingPools) {\\n        return IVestingPools(address(VestingPoolsAddress));\\n    }\\n\\n    /// @dev Returns the stake of the specified stakeholder reverting on errors\\n    function _getStake(address holder) internal view returns (Stake memory) {\\n        _throwZeroHolderAddress(holder);\\n        Stake memory stake = stakes[holder];\\n        require(stake.allocated != 0, \\\"PStakes: unknown stake\\\");\\n        return stake;\\n    }\\n\\n    /// @notice Initialize the contract\\n    /// @dev May be called on a proxy only (but not on the implementation)\\n    function _init(uint256 _poolId) internal {\\n        _throwImplementation();\\n        require(_poolId < 2**16, \\\"PStakes:unsafePoolId\\\");\\n\\n        IVestingPools pools = _getVestingPools();\\n        address wallet = pools.getWallet(_poolId);\\n        require(wallet == address(this), \\\"PStakes:invalidPool\\\");\\n        PoolParams memory pool = pools.getPool(_poolId);\\n        require(pool.sAllocation != 0, \\\"PStakes:zeroPool\\\");\\n\\n        poolId = uint16(_poolId);\\n        allocation = _safe96(uint256(pool.sAllocation) * SCALE);\\n    }\\n\\n    /// @dev Returns amount that may be released for the given stake and factor\\n    function _releasableAmount(Stake memory stake, uint256 _factor)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 share = (_factor * uint256(stake.allocated)) / SCALE;\\n        if (share > stake.allocated) {\\n            // imprecise division safeguard\\n            share = uint256(stake.allocated);\\n        }\\n        return share - uint256(stake.released);\\n    }\\n\\n    /// @dev Claims vesting to this contract from the vesting pool\\n    function _claimVesting() internal {\\n        // (reentrancy attack impossible - known contract called)\\n        uint256 justVested = _getVestingPools().release(poolId, 0);\\n        factor += uint160((justVested * SCALE) / uint256(allocation));\\n        emit VestingClaimed(justVested);\\n    }\\n\\n    /// @dev Sends the releasable amount of the specified placeholder\\n    function _withdraw(address holder) internal {\\n        Stake memory stake = _getStake(holder);\\n        uint256 releasable = _releasableAmount(stake, uint256(factor));\\n        require(releasable > 0, \\\"PStakes: nothing to withdraw\\\");\\n\\n        stakes[holder].released = _safe96(uint256(stake.released) + releasable);\\n        released = _safe96(uint256(released) + releasable);\\n\\n        // (reentrancy attack impossible - known contract called)\\n        require(_getToken().transfer(holder, releasable), \\\"PStakes:E1\\\");\\n        emit Released(holder, releasable);\\n    }\\n\\n    function _throwZeroHolderAddress(address holder) private pure {\\n        require(holder != address(0), \\\"PStakes: zero holder address\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract Constants {\\n    // $ZKP token max supply\\n    uint256 internal constant MAX_SUPPLY = 1e27;\\n\\n    // Scaling factor in token amount calculations\\n    uint256 internal constant SCALE = 1e12;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev To save gas, params are packed to fit into a single storage slot.\\n * Some amounts are scaled (divided) by {SCALE} - note names starting with\\n * the letter \\\"s\\\" (stands for \\\"scaled\\\") followed by a capital letter.\\n */\\nstruct PoolParams {\\n    // if `true`, allocation gets pre-minted, otherwise minted when vested\\n    bool isPreMinted;\\n    // if `true`, the owner may change {start} and {duration}\\n    bool isAdjustable;\\n    // (UNIX) time when vesting starts\\n    uint32 start;\\n    // period in days (since the {start}) of vesting\\n    uint16 vestingDays;\\n    // scaled total amount to (ever) vest from the pool\\n    uint48 sAllocation;\\n    // out of {sAllocation}, amount (also scaled) to be unlocked on the {start}\\n    uint48 sUnlocked;\\n    // amount vested from the pool so far (without scaling)\\n    uint96 vested;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVestingPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { PoolParams } from \\\"./Types.sol\\\";\\n\\ninterface IVestingPools {\\n    /**\\n     * @notice Returns Token address.\\n     */\\n    function token() external view returns (address);\\n\\n    /**\\n     * @notice Returns the wallet address of the specified pool.\\n     */\\n    function getWallet(uint256 poolId) external view returns (address);\\n\\n    /**\\n     * @notice Returns parameters of the specified pool.\\n     */\\n    function getPool(uint256 poolId) external view returns (PoolParams memory);\\n\\n    /**\\n     * @notice Returns the amount that may be vested now from the given pool.\\n     */\\n    function releasableAmount(uint256 poolId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount that has been vested from the given pool\\n     */\\n    function vestedAmount(uint256 poolId) external view returns (uint256);\\n\\n    /**\\n     * @notice Vests the specified amount from the given pool to the pool wallet.\\n     * If the amount is zero, it vests the entire \\\"releasable\\\" amount.\\n     * @dev Pool wallet may call only.\\n     * @return released - Amount released.\\n     */\\n    function release(uint256 poolId, uint256 amount)\\n        external\\n        returns (uint256 released);\\n\\n    /**\\n     * @notice Vests the specified amount from the given pool to the given address.\\n     * If the amount is zero, it vests the entire \\\"releasable\\\" amount.\\n     * @dev Pool wallet may call only.\\n     * @return released - Amount released.\\n     */\\n    function releaseTo(\\n        uint256 poolId,\\n        address account,\\n        uint256 amount\\n    ) external returns (uint256 released);\\n\\n    /**\\n     * @notice Updates the wallet for the given pool.\\n     * @dev (Current) wallet may call only.\\n     */\\n    function updatePoolWallet(uint256 poolId, address newWallet) external;\\n\\n    /**\\n     * @notice Adds new vesting pools with given wallets and parameters.\\n     * @dev Owner may call only.\\n     */\\n    function addVestingPools(\\n        address[] memory wallets,\\n        PoolParams[] memory params\\n    ) external;\\n\\n    /**\\n     * @notice Update `start` and `duration` for the given pool.\\n     * @param start - new (UNIX) time vesting starts at\\n     * @param vestingDays - new period in days, when vesting lasts\\n     * @dev Owner may call only.\\n     */\\n    function updatePoolTime(\\n        uint256 poolId,\\n        uint32 start,\\n        uint16 vestingDays\\n    ) external;\\n\\n    /// @notice Emitted on an amount vesting.\\n    event Released(uint256 indexed poolId, address to, uint256 amount);\\n\\n    /// @notice Emitted on a pool wallet update.\\n    event WalletUpdated(uint256 indexedpoolId, address indexed newWallet);\\n\\n    /// @notice Emitted on a new pool added.\\n    event PoolAdded(\\n        uint256 indexed poolId,\\n        address indexed wallet,\\n        uint256 allocation\\n    );\\n\\n    /// @notice Emitted on a pool params update.\\n    event PoolUpdated(\\n        uint256 indexed poolId,\\n        uint256 start,\\n        uint256 vestingDays\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.8.0;\\n\\n/**\\n * @title Claimable\\n * @notice It withdraws accidentally sent tokens from this contract.\\n * @dev It provides reentrancy guard. The code borrowed from openzeppelin-contracts.\\n * Unlike original code, this version does not require `constructor` call.\\n */\\ncontract Claimable {\\n    bytes4 private constant SELECTOR_TRANSFER =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _reentrancyStatus;\\n\\n    /// @dev Withdraws ERC20 tokens from this contract\\n    /// (take care of reentrancy attack risk mitigation)\\n    function _claimErc20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(SELECTOR_TRANSFER, to, amount)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"claimErc20: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_reentrancyStatus != _ENTERED, \\\"claimErc20: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _reentrancyStatus = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _reentrancyStatus = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DefaultOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * Inspired and borrowed by/from the openzeppelin/contracts` {Ownable}.\\n * Unlike openzeppelin` version:\\n * - by default, the owner account is the one returned by the {_defaultOwner}\\n * function, but not the deployer address;\\n * - this contract has no constructor and may run w/o initialization;\\n * - the {renounceOwnership} function removed.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n * The child contract must define the {_defaultOwner} function.\\n */\\nabstract contract DefaultOwnable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @dev Returns the current owner address, if it's defined, or the default owner address otherwise.\\n    function owner() public view virtual returns (address) {\\n        return _owner == address(0) ? _defaultOwner() : _owner;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /// @dev Transfers ownership of the contract to the `newOwner`. The owner can only call.\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    function _defaultOwner() internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Linking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This file contains fake libs just for static linking.\\n * These fake libs' code is assumed to never run.\\n * On compilation of dependant contracts, instead of fake libs addresses,\\n * indicate addresses of deployed real contracts (or accounts).\\n */\\n\\n/// @dev Address of the ZKPToken contract ('../ZKPToken.sol') instance\\nlibrary TokenAddress {\\n    function neverCallIt() external pure {\\n        revert(\\\"FAKE\\\");\\n    }\\n}\\n\\n/// @dev Address of the VestingPools ('../VestingPools.sol') instance\\nlibrary VestingPoolsAddress {\\n    function neverCallIt() external pure {\\n        revert(\\\"FAKE\\\");\\n    }\\n}\\n\\n/// @dev Address of the PoolStakes._defaultOwner\\n// (NB: if it's not a multisig, transfer ownership to a Multisig contract)\\nlibrary DefaultOwnerAddress {\\n    function neverCallIt() external pure {\\n        revert(\\\"FAKE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable no-inline-assembly\\npragma solidity >0.8.0;\\n\\n/**\\n * @title ProxyFactory\\n * @notice It \\\"clones\\\" the (child) contract deploying EIP-1167 proxies\\n * @dev Generated proxies:\\n * - being the EIP-1167 proxy, DELEGATECALL this (child) contract\\n * - support EIP-1967 specs for the \\\"implementation slot\\\"\\n *  (it gives explorers/wallets more chances to \\\"understand\\\" it's a proxy)\\n */\\nabstract contract ProxyFactory {\\n    // Storage slot that the EIP-1967 defines for the \\\"implementation\\\" address\\n    // (`uint256(keccak256('eip1967.proxy.implementation')) - 1`)\\n    bytes32 private constant IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @dev Emits when a new proxy is created\\n    event NewProxy(address proxy);\\n\\n    /**\\n     * @notice Returns `true` if called on a proxy (rather than implementation)\\n     */\\n    function isProxy() external view returns (bool) {\\n        return _isProxy();\\n    }\\n\\n    /**\\n     * @notice Deploys a new proxy instance that DELEGATECALLs this contract\\n     * @dev Must be called on the implementation (reverts if a proxy is called)\\n     */\\n    function createProxy() external returns (address proxy) {\\n        _throwProxy();\\n\\n        // CREATE an EIP-1167 proxy instance with the target being this contract\\n        bytes20 target = bytes20(address(this));\\n        assembly {\\n            let initCode := mload(0x40)\\n            mstore(\\n                initCode,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n            mstore(add(initCode, 0x14), target)\\n            mstore(\\n                add(initCode, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n            // note, 0x37 (55 bytes) is the init bytecode length\\n            // while the deployed bytecode length is 0x2d (45 bytes) only\\n            proxy := create(0, initCode, 0x37)\\n        }\\n\\n        // Write this contract address into the proxy' \\\"implementation\\\" slot\\n        // (reentrancy attack impossible - this contract called)\\n        ProxyFactory(proxy).initProxy(address(this));\\n\\n        emit NewProxy(proxy);\\n    }\\n\\n    /**\\n     * @dev Writes given address into the \\\"implementation\\\" slot of a new proxy.\\n     * !!! It MUST (and may only) be called:\\n     * - via the implementation instance with the {createProxy} method\\n     * - on a newly deployed proxy only\\n     * It reverts if called on the implementation or on initialized proxies.\\n     */\\n    function initProxy(address impl) external {\\n        _throwImplementation();\\n        require(\\n            _getImplementation() == address(0),\\n            \\\"ProxyFactory:ALREADY_INITIALIZED\\\"\\n        );\\n\\n        // write into the \\\"implementation\\\" slot\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            sstore(slot, impl)\\n        }\\n    }\\n\\n    /// @dev Returns true if called on a proxy instance\\n    function _isProxy() internal view virtual returns (bool) {\\n        // for a DELEGATECALLed contract, `this` and `extcodesize`\\n        // are the address and the code size of the calling contract\\n        // (for a CALLed contract, they are ones of that called contract)\\n        uint256 _size;\\n        address _this = address(this);\\n        assembly {\\n            _size := extcodesize(_this)\\n        }\\n\\n        // shall be the same as the one the `createProxy` generates\\n        return _size == 45;\\n    }\\n\\n    /// @dev Returns the address stored in the \\\"implementation\\\" slot\\n    function _getImplementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /// @dev Throws if called on the implementation\\n    function _throwImplementation() internal view {\\n        require(_isProxy(), \\\"ProxyFactory:IMPL_CALLED\\\");\\n    }\\n\\n    /// @dev Throws if called on a proxy\\n    function _throwProxy() internal view {\\n        require(!_isProxy(), \\\"ProxyFactory:PROXY_CALLED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeUints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.8.0;\\n\\n/**\\n * @title SafeUints\\n * @notice Util functions which throws if a uint256 can't fit into smaller uints.\\n */\\ncontract SafeUints {\\n    // @dev Checks if the given uint256 does not overflow uint96\\n    function _safe96(uint256 n) internal pure returns (uint96) {\\n        require(n < 2**96, \\\"VPools: Unsafe96\\\");\\n        return uint96(n);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/utils/Linking.sol\": {\r\n        \"DefaultOwnerAddress\": \"0x505796f5bc290269d2522cf19135ad7aa60dfd77\",\r\n        \"TokenAddress\": \"0x909e34d3f6124c324ac83dcca84b74398a6fa173\",\r\n        \"VestingPoolsAddress\": \"0xb476104aa9d1f30180a01987fb09b1e96ddcf14b\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"NewProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"}],\"name\":\"StakeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"}],\"name\":\"StakeSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allocations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"unallocated\",\"type\":\"uint256\"}],\"name\":\"addStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocated\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocation\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factor\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"initProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"}],\"name\":\"massWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"releasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"splitStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"allocated\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"released\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"unclaimedShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PoolStakes","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}