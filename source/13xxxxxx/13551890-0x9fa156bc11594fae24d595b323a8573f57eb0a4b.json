{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/utils/SignerV2.sol\": {\r\n      \"content\": \"/*\\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\\n*/\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Signer contract. Enables signing transaction before sending it to Gnosis Safe.\\n// Copyright (C) 2021 PrimeDao\\n\\n// solium-disable linebreak-style\\npragma solidity 0.8.9;\\n\\nimport \\\"./interface/Safe.sol\\\";\\nimport \\\"@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol\\\";\\n\\n/**\\n * @title PrimeDAO Signer Contract\\n * @dev   Enables signing approved function signature transaction before sending it to Gnosis Safe.\\n */\\ncontract SignerV2 is ISignatureValidator {\\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\\n        0x7a9f5b2bf4dbb53eb85e012c6094a3d71d76e5bfe821f44ab63ed59311264e35;\\n    bytes32 private constant MSG_TYPEHASH =\\n        0xa1a7ad659422d5fc08fdc481fd7d8af8daf7993bc4e833452b0268ceaab66e5d; // mapping for msg typehash\\n\\n    mapping(bytes32 => bytes32) public approvedSignatures;\\n\\n    /* solium-disable */\\n    address public safe;\\n    mapping(address => mapping(bytes4 => bool)) public allowedTransactions;\\n    /* solium-enable */\\n\\n    event SignatureCreated(bytes signature, bytes32 indexed hash);\\n\\n    modifier onlySafe() {\\n        require(msg.sender == safe, \\\"Signer: only safe functionality\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev                       Signer Constructor\\n     * @param _safe               Gnosis Safe address.\\n     * @param _contracts          array of contract addresses\\n     * @param _functionSignatures array of function signatures\\n     */\\n    constructor(\\n        address _safe,\\n        address[] memory _contracts,\\n        bytes4[] memory _functionSignatures\\n    ) {\\n        require(_safe != address(0), \\\"Signer: Safe address zero\\\");\\n        safe = _safe;\\n        for (uint256 i; i < _contracts.length; i++) {\\n            require(\\n                _contracts[i] != address(0),\\n                \\\"Signer: contract address zero\\\"\\n            );\\n            require(\\n                _functionSignatures[i] != bytes4(0),\\n                \\\"Signer: function signature zero\\\"\\n            );\\n            allowedTransactions[_contracts[i]][_functionSignatures[i]] = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev                   Signature generator\\n     * @param _to             receiver address.\\n     * @param _value          value in wei.\\n     * @param _data           encoded transaction data.\\n     * @param _operation      type of operation call.\\n     * @param _safeTxGas      safe transaction gas for gnosis safe.\\n     * @param _baseGas        base gas for gnosis safe.\\n     * @param _gasPrice       gas price for gnosis safe transaction.\\n     * @param _gasToken       token which gas needs to paid for gnosis safe transaction.\\n     * @param _refundReceiver address account to receive refund for remaining gas.\\n     * @param _nonce          gnosis safe contract nonce.\\n     */\\n    function generateSignature(\\n        address _to,\\n        uint256 _value,\\n        bytes calldata _data,\\n        Enum.Operation _operation,\\n        uint256 _safeTxGas,\\n        uint256 _baseGas,\\n        uint256 _gasPrice,\\n        address _gasToken,\\n        address _refundReceiver,\\n        uint256 _nonce\\n    ) external returns (bytes memory signature, bytes32 hash) {\\n        // check if transaction parameters are correct\\n        require(\\n            allowedTransactions[_to][_getFunctionHashFromData(_data)],\\n            \\\"Signer: invalid function\\\"\\n        );\\n        require(\\n            _value == 0 &&\\n                _refundReceiver == address(0) &&\\n                _operation == Enum.Operation.Call,\\n            \\\"Signer: invalid arguments\\\"\\n        );\\n\\n        // get contractTransactionHash from gnosis safe\\n        hash = Safe(safe).getTransactionHash(\\n            _to,\\n            0,\\n            _data,\\n            _operation,\\n            _safeTxGas,\\n            _baseGas,\\n            _gasPrice,\\n            _gasToken,\\n            _refundReceiver,\\n            _nonce\\n        );\\n\\n        bytes memory paddedAddress = bytes.concat(\\n            bytes12(0),\\n            bytes20(address(this))\\n        );\\n        bytes memory messageHash = _encodeMessageHash(hash);\\n        // check if transaction is not signed before\\n        // solhint-disable-next-line reason-string\\n        require(\\n            approvedSignatures[hash] != keccak256(messageHash),\\n            \\\"Signer: transaction already signed\\\"\\n        );\\n\\n        // generate signature and add it to approvedSignatures mapping\\n        signature = bytes.concat(\\n            paddedAddress,\\n            bytes32(uint256(65)),\\n            bytes1(0),\\n            bytes32(uint256(messageHash.length)),\\n            messageHash\\n        );\\n        approvedSignatures[hash] = keccak256(messageHash);\\n        emit SignatureCreated(signature, hash);\\n    }\\n\\n    /**\\n     * @dev                Validate signature using EIP1271\\n     * @param _data        Encoded transaction hash supplied to verify signature.\\n     * @param _signature   Signature that needs to be verified.\\n     */\\n    function isValidSignature(bytes memory _data, bytes memory _signature)\\n        public\\n        view\\n        override\\n        returns (bytes4)\\n    {\\n        if (_data.length == 32) {\\n            bytes32 hash;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                hash := mload(add(_data, 32))\\n            }\\n            if (approvedSignatures[hash] == keccak256(_signature)) {\\n                return EIP1271_MAGIC_VALUE;\\n            }\\n        } else {\\n            if (approvedSignatures[keccak256(_data)] == keccak256(_signature)) {\\n                return EIP1271_MAGIC_VALUE;\\n            }\\n        }\\n        return \\\"0x\\\";\\n    }\\n\\n    /**\\n     * @dev               Get the byte hash of function call i.e. first four bytes of data\\n     * @param data        encoded transaction data.\\n     */\\n    function _getFunctionHashFromData(bytes memory data)\\n        private\\n        pure\\n        returns (bytes4 functionHash)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            functionHash := mload(add(data, 32))\\n        }\\n    }\\n\\n    /**\\n     * @dev                encode message with contants\\n     * @param message      the message that needs to be encoded\\n     */\\n    function _encodeMessageHash(bytes32 message)\\n        private\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes32 safeMessageHash = keccak256(abi.encode(MSG_TYPEHASH, message));\\n        return\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x23),\\n                keccak256(\\n                    abi.encode(DOMAIN_SEPARATOR_TYPEHASH, safeMessageHash)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev                set new safe\\n     * @param _safe        safe address\\n     */\\n    function setSafe(address _safe) public onlySafe {\\n        require(_safe != address(0), \\\"Signer: Safe zero address\\\");\\n        safe = _safe;\\n    }\\n\\n    /**\\n     * @dev                      add new contracts and functions\\n     * @param _contract          contract address\\n     * @param _functionSignature function signature for the contract\\n     */\\n    function approveNewTransaction(address _contract, bytes4 _functionSignature)\\n        external\\n        onlySafe\\n    {\\n        require(_contract != address(0), \\\"Signer: contract address zero\\\");\\n        require(\\n            _functionSignature != bytes4(0),\\n            \\\"Signer: function signature zero\\\"\\n        );\\n        allowedTransactions[_contract][_functionSignature] = true;\\n    }\\n\\n    /**\\n     * @dev                      add new contracts and functions\\n     * @param _contract           contract address\\n     * @param _functionSignature function signature for the contract\\n     */\\n    function removeAllowedTransaction(\\n        address _contract,\\n        bytes4 _functionSignature\\n    ) external onlySafe {\\n        // solhint-disable-next-line reason-string\\n        require(\\n            allowedTransactions[_contract][_functionSignature] == true,\\n            \\\"Signer: only approved transactions can be removed\\\"\\n        );\\n        allowedTransactions[_contract][_functionSignature] = false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/interface/Safe.sol\": {\r\n      \"content\": \"/*\\n\\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\\n\\n*/\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/* solium-disable */\\npragma solidity 0.8.9;\\n\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\ninterface Safe {\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        uint256 _nonce\\n    ) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract ISignatureValidatorConstants {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\\n}\\n\\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param _data Arbitrary length data signed on the behalf of address(this)\\n     * @param _signature Signature byte array associated with _data\\n     *\\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safe\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"_functionSignatures\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"SignatureCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"allowedTransactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_functionSignature\",\"type\":\"bytes4\"}],\"name\":\"approveNewTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approvedSignatures\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"_operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_gasToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"generateSignature\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_functionSignature\",\"type\":\"bytes4\"}],\"name\":\"removeAllowedTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safe\",\"type\":\"address\"}],\"name\":\"setSafe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SignerV2","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000052f50f557704938df066ec4db7426d66538e7796000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f50c85e4f8903b38cd6cc2d73678a5be1fac5e0a0000000000000000000000000000000000000000000000000000000000000001fd3bd38a00000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}