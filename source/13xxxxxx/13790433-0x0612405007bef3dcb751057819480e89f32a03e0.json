{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/SeedPhraseUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../interfaces/IKarmaScore.sol\\\";\\nimport \\\"./NilProtocolUtils.sol\\\";\\nimport \\\"../libraries/NilProtocolUtils.sol\\\";\\n\\nlibrary SeedPhraseUtils {\\n    using Strings for uint256;\\n    using Strings for uint16;\\n    using Strings for uint8;\\n\\n    struct Random {\\n        uint256 seed;\\n        uint256 offsetBit;\\n    }\\n\\n    struct Colors {\\n        string background;\\n        string panel;\\n        string panel2;\\n        string panelStroke;\\n        string selectedCircleStroke;\\n        string selectedCircleFill;\\n        string selectedCircleFill2;\\n        string negativeCircleStroke;\\n        string negativeCircleFill;\\n        string blackOrWhite;\\n        string dynamicOpacity;\\n        string backgroundCircle;\\n    }\\n\\n    struct Attrs {\\n        bool showStroke;\\n        bool border;\\n        bool showPanel;\\n        bool backgroundSquare;\\n        bool bigBackgroundCircle;\\n        bool showGrid;\\n        bool backgroundCircles;\\n        bool greyscale;\\n        bool doublePanel;\\n        uint16 bipWordId;\\n        uint16 secondBipWordId;\\n    }\\n\\n    uint8 internal constant strokeWeight = 7;\\n    uint16 internal constant segmentSize = 100;\\n    uint16 internal constant radius = 50;\\n    uint16 internal constant padding = 10;\\n    uint16 internal constant viewBox = 1600;\\n    uint16 internal constant panelWidth = segmentSize * 4;\\n    uint16 internal constant panelHeight = segmentSize * 10;\\n    uint16 internal constant singlePanelX = (segmentSize * 6);\\n    uint16 internal constant doublePanel1X = (segmentSize * 3);\\n    uint16 internal constant doublePanel2X = doublePanel1X + (segmentSize * 6);\\n    uint16 internal constant panelY = (segmentSize * 3);\\n\\n    function generateSeed(uint256 tokenId, uint256 vrfRandomValue) external view returns (bytes32) {\\n        return keccak256(abi.encode(tokenId, block.timestamp, block.difficulty, vrfRandomValue));\\n    }\\n\\n    function _shouldAddTrait(\\n        bool isTrue,\\n        bytes memory trueName,\\n        bytes memory falseName,\\n        uint8 prevRank,\\n        uint8 newRank,\\n        bytes memory traits\\n    ) internal pure returns (bytes memory, uint8) {\\n        if (isTrue) {\\n            traits = abi.encodePacked(traits, ',{\\\"value\\\": \\\"', trueName, '\\\"}');\\n        }\\n        // Only add the falsy trait if it's named (e.g. there's no negative version of \\\"greyscale\\\")\\n        else if (falseName.length != 0) {\\n            traits = abi.encodePacked(traits, ',{\\\"value\\\": \\\"', falseName, '\\\"}');\\n        }\\n\\n        // Return new (higher rank if trait is true)\\n        return (traits, (isTrue ? newRank : prevRank));\\n    }\\n\\n    function tokenTraits(Attrs memory attributes) internal pure returns (bytes memory traits, uint8 rarityRating) {\\n        rarityRating = 0;\\n        traits = abi.encodePacked(\\\"[\\\");\\n        // Add both words to trait if a double panel\\n        if (attributes.doublePanel) {\\n            traits = abi.encodePacked(\\n                traits,\\n                '{\\\"trait_type\\\": \\\"Double Panel BIP39 IDs\\\", \\\"value\\\": \\\"',\\n                attributes.bipWordId.toString(),\\n                \\\" - \\\",\\n                attributes.secondBipWordId.toString(),\\n                '\\\"},',\\n                '{\\\"value\\\": \\\"Double Panel\\\"}'\\n            );\\n        } else {\\n            traits = abi.encodePacked(\\n                traits,\\n                '{\\\"trait_type\\\": \\\"BIP39 ID\\\",  \\\"display_type\\\": \\\"number\\\", \\\"max_value\\\": 2048, \\\"value\\\": ',\\n                attributes.bipWordId.toString(),\\n                \\\"}\\\"\\n            );\\n        }\\n        // Stroke trait - rank 1\\n        (traits, rarityRating) = _shouldAddTrait(\\n            !attributes.showStroke,\\n            \\\"No Stroke\\\",\\n            \\\"OG Stroke\\\",\\n            rarityRating,\\n            1,\\n            traits\\n        );\\n        // Border - rank 2\\n        (traits, rarityRating) = _shouldAddTrait(attributes.border, \\\"Border\\\", \\\"\\\", rarityRating, 2, traits);\\n        // No Panel - rank 3\\n        (traits, rarityRating) = _shouldAddTrait(\\n            !attributes.showPanel,\\n            \\\"No Panel\\\",\\n            \\\"OG Panel\\\",\\n            rarityRating,\\n            3,\\n            traits\\n        );\\n        // Symmetry Group Square - rank 4\\n        (traits, rarityRating) = _shouldAddTrait(\\n            attributes.backgroundSquare,\\n            \\\"Group Square\\\",\\n            \\\"\\\",\\n            rarityRating,\\n            4,\\n            traits\\n        );\\n        // Symmetry Group Circle - rank 5\\n        (traits, rarityRating) = _shouldAddTrait(\\n            attributes.bigBackgroundCircle,\\n            \\\"Group Circle\\\",\\n            \\\"\\\",\\n            rarityRating,\\n            5,\\n            traits\\n        );\\n        // Caged - rank 6\\n        (traits, rarityRating) = _shouldAddTrait(attributes.showGrid, \\\"Caged\\\", \\\"\\\", rarityRating, 6, traits);\\n        // Bubblewrap - rank 7\\n        (traits, rarityRating) = _shouldAddTrait(\\n            attributes.backgroundCircles,\\n            \\\"Bubblewrap\\\",\\n            \\\"\\\",\\n            rarityRating,\\n            7,\\n            traits\\n        );\\n        // Monochrome - rank 8\\n        (traits, rarityRating) = _shouldAddTrait(attributes.greyscale, \\\"Monochrome\\\", \\\"\\\", rarityRating, 8, traits);\\n\\n        traits = abi.encodePacked(traits, \\\"]\\\");\\n    }\\n\\n    /**\\n     * @notice Generates the art defining attributes\\n     * @param bipWordId bip39 word id\\n     * @param secondBipWordId ^ only for a double panel\\n     * @param random RNG\\n     * @param predefinedRarity double panels trait to carry over\\n     * @return attributes struct\\n     */\\n    function tokenAttributes(\\n        uint16 bipWordId,\\n        uint16 secondBipWordId,\\n        Random memory random,\\n        uint8 predefinedRarity\\n    ) internal pure returns (Attrs memory attributes) {\\n        attributes = Attrs({\\n            showStroke: (predefinedRarity == 1) ? false : _boolPercentage(random, 70), // rank 1\\n            border: (predefinedRarity == 2) ? true : _boolPercentage(random, 30), // rank 2\\n            showPanel: (predefinedRarity == 3) ? false : _boolPercentage(random, 80), // rank 3\\n            backgroundSquare: (predefinedRarity == 4) ? true : _boolPercentage(random, 18), // rank 4\\n            bigBackgroundCircle: (predefinedRarity == 5) ? true : _boolPercentage(random, 12), // rank = 5\\n            showGrid: (predefinedRarity == 6) ? true : _boolPercentage(random, 6), // rank 6\\n            backgroundCircles: (predefinedRarity == 7) ? true : _boolPercentage(random, 4), // rank 7\\n            greyscale: (predefinedRarity == 8) ? true : _boolPercentage(random, 2), // rank 8\\n            bipWordId: bipWordId,\\n            doublePanel: (secondBipWordId > 0),\\n            secondBipWordId: secondBipWordId\\n        });\\n\\n        // Rare attributes should always superseed less-rare\\n        // If greyscale OR grid is true then turn on stroke (as it is required)\\n        if (attributes.showGrid || attributes.greyscale) {\\n            attributes.showStroke = true;\\n        }\\n        // backgroundCircles superseeds grid (they cannot co-exist)\\n        if (attributes.backgroundCircles) {\\n            attributes.showGrid = false;\\n        }\\n        // Border cannot be on if background shapes are turned on\\n        if (attributes.bigBackgroundCircle || attributes.backgroundSquare) {\\n            attributes.border = false;\\n            // Big Background Shapes cannot co-exist\\n            if (attributes.bigBackgroundCircle) {\\n                attributes.backgroundSquare = false;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Converts a tokenId (uint256) into the formats needed to generate the art\\n     * @param tokenId tokenId (also the BIP39 word)\\n     * @return tokenArray with prepended 0's (if tokenId is less that 4 digits) also returns in string format\\n     */\\n    function _transformTokenId(uint256 tokenId) internal pure returns (uint8[4] memory tokenArray, string memory) {\\n        bytes memory tokenString;\\n        uint8 digit;\\n\\n        for (int8 i = 3; i >= 0; i--) {\\n            digit = uint8(tokenId % 10); // This returns the final digit in the token\\n            if (tokenId > 0) {\\n                tokenId = tokenId / 10; // this removes the last digit from the token as we've grabbed the digit already\\n                tokenArray[uint8(i)] = digit;\\n            }\\n            tokenString = abi.encodePacked(digit.toString(), tokenString);\\n        }\\n\\n        return (tokenArray, string(tokenString));\\n    }\\n\\n    function _renderText(string memory text, string memory color) internal pure returns (bytes memory svg) {\\n        svg = abi.encodePacked(\\n            \\\"<text x='1500' y='1500' text-anchor='end' style='font:700 36px &quot;Courier New&quot;;fill:\\\",\\n            color,\\n            \\\";opacity:.4'>#\\\",\\n            text,\\n            \\\"</text>\\\"\\n        );\\n\\n        return svg;\\n    }\\n\\n    function _backgroundShapeSizing(Random memory random, Attrs memory attributes)\\n        internal\\n        pure\\n        returns (uint16, uint16)\\n    {\\n        uint256 idx;\\n        // If we DON'T have a 'doublePanel' or 'no panel' we can return the default sizing\\n        if (!attributes.doublePanel && attributes.showPanel) {\\n            uint16[2][6] memory defaultSizing = [\\n                [1275, 200],\\n                [1150, 375],\\n                [900, 300],\\n                [925, 225],\\n                [850, 150],\\n                [775, 125]\\n            ];\\n            idx = SeedPhraseUtils._next(random, 0, defaultSizing.length);\\n            return (defaultSizing[idx][0], defaultSizing[idx][1]);\\n        }\\n\\n        // Otherwise we need to return some slightly different data\\n        if (attributes.bigBackgroundCircle) {\\n            uint16[2][4] memory restrictedCircleDimensions = [[1150, 150], [1275, 200], [1300, 100], [1350, 200]];\\n            idx = SeedPhraseUtils._next(random, 0, restrictedCircleDimensions.length);\\n            return (restrictedCircleDimensions[idx][0], restrictedCircleDimensions[idx][1]);\\n        }\\n\\n        // Else we can assume that it is backgroundSquares\\n        uint16[2][4] memory restrictedSquareDimensions = [[1150, 50], [1100, 125], [1275, 200], [1300, 150]];\\n        idx = SeedPhraseUtils._next(random, 0, restrictedSquareDimensions.length);\\n        return (restrictedSquareDimensions[idx][0], restrictedSquareDimensions[idx][1]);\\n    }\\n\\n    function _getStrokeStyle(\\n        bool showStroke,\\n        string memory color,\\n        string memory opacity,\\n        uint8 customStrokeWeight\\n    ) internal pure returns (bytes memory strokeStyle) {\\n        if (showStroke) {\\n            strokeStyle = abi.encodePacked(\\n                \\\" style='stroke-opacity:\\\",\\n                opacity,\\n                \\\";stroke:\\\",\\n                color,\\n                \\\";stroke-width:\\\",\\n                customStrokeWeight.toString(),\\n                \\\"' \\\"\\n            );\\n\\n            return strokeStyle;\\n        }\\n    }\\n\\n    function _getPalette(Random memory random, Attrs memory attributes) internal pure returns (Colors memory) {\\n        string[6] memory selectedPallet;\\n        uint8[6] memory lumosity;\\n        if (attributes.greyscale) {\\n            selectedPallet = [\\\"#f8f9fa\\\", \\\"#c3c4c4\\\", \\\"#909091\\\", \\\"#606061\\\", \\\"#343435\\\", \\\"#0a0a0b\\\"];\\n            lumosity = [249, 196, 144, 96, 52, 10];\\n        } else {\\n            uint256 randPalette = SeedPhraseUtils._next(random, 0, 25);\\n            if (randPalette == 0) {\\n                selectedPallet = [\\\"#ffe74c\\\", \\\"#ff5964\\\", \\\"#ffffff\\\", \\\"#6bf178\\\", \\\"#35a7ff\\\", \\\"#5b3758\\\"];\\n                lumosity = [225, 125, 255, 204, 149, 65];\\n            } else if (randPalette == 1) {\\n                selectedPallet = [\\\"#ff0000\\\", \\\"#ff8700\\\", \\\"#e4ff33\\\", \\\"#a9ff1f\\\", \\\"#0aefff\\\", \\\"#0a33ff\\\"];\\n                lumosity = [54, 151, 235, 221, 191, 57];\\n            } else if (randPalette == 2) {\\n                selectedPallet = [\\\"#f433ab\\\", \\\"#cb04a5\\\", \\\"#934683\\\", \\\"#65334d\\\", \\\"#2d1115\\\", \\\"#e0e2db\\\"];\\n                lumosity = [101, 58, 91, 64, 23, 225];\\n            } else if (randPalette == 3) {\\n                selectedPallet = [\\\"#f08700\\\", \\\"#f6aa28\\\", \\\"#f9d939\\\", \\\"#00a6a6\\\", \\\"#bbdef0\\\", \\\"#23556c\\\"];\\n                lumosity = [148, 177, 212, 131, 216, 76];\\n            } else if (randPalette == 4) {\\n                selectedPallet = [\\\"#f7e6de\\\", \\\"#e5b59e\\\", \\\"#cb7d52\\\", \\\"#bb8f77\\\", \\\"#96624a\\\", \\\"#462b20\\\"];\\n                lumosity = [233, 190, 138, 151, 107, 48];\\n            } else if (randPalette == 5) {\\n                selectedPallet = [\\\"#f61379\\\", \\\"#d91cbc\\\", \\\"#da81ee\\\", \\\"#5011e4\\\", \\\"#4393ef\\\", \\\"#8edef6\\\"];\\n                lumosity = [75, 80, 156, 46, 137, 207];\\n            } else if (randPalette == 6) {\\n                selectedPallet = [\\\"#010228\\\", \\\"#006aa3\\\", \\\"#005566\\\", \\\"#2ac1df\\\", \\\"#82dded\\\", \\\"#dbf5fa\\\"];\\n                lumosity = [5, 88, 68, 163, 203, 240];\\n            } else if (randPalette == 7) {\\n                selectedPallet = [\\\"#f46036\\\", \\\"#5b85aa\\\", \\\"#414770\\\", \\\"#372248\\\", \\\"#171123\\\", \\\"#f7f5fb\\\"];\\n                lumosity = [124, 127, 73, 41, 20, 246];\\n            } else if (randPalette == 8) {\\n                selectedPallet = [\\\"#393d3f\\\", \\\"#fdfdff\\\", \\\"#c6c5b9\\\", \\\"#62929e\\\", \\\"#546a7b\\\", \\\"#c52233\\\"];\\n                lumosity = [60, 253, 196, 137, 103, 70];\\n            } else if (randPalette == 9) {\\n                selectedPallet = [\\\"#002626\\\", \\\"#0e4749\\\", \\\"#95c623\\\", \\\"#e55812\\\", \\\"#efe7da\\\", \\\"#8ddbe0\\\"];\\n                lumosity = [30, 59, 176, 113, 232, 203];\\n            } else if (randPalette == 10) {\\n                selectedPallet = [\\\"#03071e\\\", \\\"#62040d\\\", \\\"#d00000\\\", \\\"#e85d04\\\", \\\"#faa307\\\", \\\"#ffcb47\\\"];\\n                lumosity = [8, 25, 44, 116, 170, 205];\\n            } else if (randPalette == 11) {\\n                selectedPallet = [\\\"#f56a00\\\", \\\"#ff931f\\\", \\\"#ffd085\\\", \\\"#20003d\\\", \\\"#7b2cbf\\\", \\\"#c698eb\\\"];\\n                lumosity = [128, 162, 213, 11, 71, 168];\\n            } else if (randPalette == 12) {\\n                selectedPallet = [\\\"#800016\\\", \\\"#ffffff\\\", \\\"#ff002b\\\", \\\"#407ba7\\\", \\\"#004e89\\\", \\\"#00043a\\\"];\\n                lumosity = [29, 255, 57, 114, 66, 7];\\n            } else if (randPalette == 13) {\\n                selectedPallet = [\\\"#d6d6d6\\\", \\\"#f9f7dc\\\", \\\"#ffee32\\\", \\\"#ffd100\\\", \\\"#202020\\\", \\\"#6c757d\\\"];\\n                lumosity = [214, 245, 228, 204, 32, 116];\\n            } else if (randPalette == 14) {\\n                selectedPallet = [\\\"#fff5d6\\\", \\\"#ccc5b9\\\", \\\"#403d39\\\", \\\"#252422\\\", \\\"#eb5e28\\\", \\\"#bb4111\\\"];\\n                lumosity = [245, 198, 61, 36, 120, 87];\\n            } else if (randPalette == 15) {\\n                selectedPallet = [\\\"#0c0f0a\\\", \\\"#ff206e\\\", \\\"#fbff12\\\", \\\"#41ead4\\\", \\\"#6c20fd\\\", \\\"#ffffff\\\"];\\n                lumosity = [14, 85, 237, 196, 224, 255];\\n            } else if (randPalette == 16) {\\n                selectedPallet = [\\\"#fdd8d8\\\", \\\"#f67979\\\", \\\"#e51010\\\", \\\"#921314\\\", \\\"#531315\\\", \\\"#151315\\\"];\\n                lumosity = [224, 148, 61, 46, 33, 20];\\n            } else if (randPalette == 17) {\\n                selectedPallet = [\\\"#000814\\\", \\\"#002752\\\", \\\"#0066cc\\\", \\\"#f5bc00\\\", \\\"#ffd60a\\\", \\\"#ffee99\\\"];\\n                lumosity = [7, 34, 88, 187, 208, 235];\\n            } else if (randPalette == 18) {\\n                selectedPallet = [\\\"#010b14\\\", \\\"#022d4f\\\", \\\"#fdfffc\\\", \\\"#2ec4b6\\\", \\\"#e71d36\\\", \\\"#ff990a\\\"];\\n                lumosity = [10, 38, 254, 163, 74, 164];\\n            } else if (randPalette == 19) {\\n                selectedPallet = [\\\"#fd650d\\\", \\\"#d90368\\\", \\\"#820263\\\", \\\"#291720\\\", \\\"#06efa9\\\", \\\"#0d5943\\\"];\\n                lumosity = [127, 56, 36, 27, 184, 71];\\n            } else if (randPalette == 20) {\\n                selectedPallet = [\\\"#002914\\\", \\\"#005200\\\", \\\"#34a300\\\", \\\"#70e000\\\", \\\"#aef33f\\\", \\\"#e0ff85\\\"];\\n                lumosity = [31, 59, 128, 184, 215, 240];\\n            } else if (randPalette == 21) {\\n                selectedPallet = [\\\"#001413\\\", \\\"#fafffe\\\", \\\"#6f0301\\\", \\\"#a92d04\\\", \\\"#f6b51d\\\", \\\"#168eb6\\\"];\\n                lumosity = [16, 254, 26, 68, 184, 119];\\n            } else if (randPalette == 22) {\\n                selectedPallet = [\\\"#6a1f10\\\", \\\"#d53e20\\\", \\\"#f7d1ca\\\", \\\"#c4f3fd\\\", \\\"#045362\\\", \\\"#fffbfa\\\"];\\n                lumosity = [46, 92, 217, 234, 67, 252];\\n            } else if (randPalette == 23) {\\n                selectedPallet = [\\\"#6b42ff\\\", \\\"#a270ff\\\", \\\"#dda1f7\\\", \\\"#ffd6eb\\\", \\\"#ff8fb2\\\", \\\"#f56674\\\"];\\n                lumosity = [88, 133, 180, 224, 169, 133];\\n            } else if (randPalette == 24) {\\n                selectedPallet = [\\\"#627132\\\", \\\"#273715\\\", \\\"#99a271\\\", \\\"#fefae1\\\", \\\"#e0a35c\\\", \\\"#bf6b21\\\"];\\n                lumosity = [105, 49, 157, 249, 171, 120];\\n            }\\n        }\\n\\n        // Randomize pallet order here...\\n        return _shufflePallet(random, selectedPallet, lumosity, attributes);\\n    }\\n\\n    function _shufflePallet(\\n        Random memory random,\\n        string[6] memory hexColors,\\n        uint8[6] memory lumaValues,\\n        Attrs memory attributes\\n    ) internal pure returns (Colors memory) {\\n        // Shuffle colors and luma values with the same index\\n        for (uint8 i = 0; i < hexColors.length; i++) {\\n            // n = Pick random i > (array length - i)\\n            uint256 n = i + SeedPhraseUtils._next(random, 0, (hexColors.length - i));\\n            // temp = Temporarily store value from array[n]\\n            string memory tempHex = hexColors[n];\\n            uint8 tempLuma = lumaValues[n];\\n            // Swap n value with i value\\n            hexColors[n] = hexColors[i];\\n            hexColors[i] = tempHex;\\n            lumaValues[n] = lumaValues[i];\\n            lumaValues[i] = tempLuma;\\n        }\\n\\n        Colors memory pallet = Colors({\\n            background: hexColors[0],\\n            panel: hexColors[1],\\n            panel2: \\\"\\\", // panel2 should match selected circles\\n            panelStroke: hexColors[2],\\n            selectedCircleStroke: hexColors[2], // Match panel stroke\\n            negativeCircleStroke: hexColors[3],\\n            negativeCircleFill: hexColors[4],\\n            selectedCircleFill: hexColors[5],\\n            selectedCircleFill2: \\\"\\\", // should match panel1\\n            backgroundCircle: \\\"\\\",\\n            blackOrWhite: lumaValues[0] < 150 ? \\\"#fff\\\" : \\\"#000\\\",\\n            dynamicOpacity: lumaValues[0] < 150 ? \\\"0.08\\\" : \\\"0.04\\\"\\n        });\\n\\n        if (attributes.doublePanel) {\\n            pallet.panel2 = pallet.selectedCircleFill;\\n            pallet.selectedCircleFill2 = pallet.panel;\\n        }\\n\\n        if (attributes.bigBackgroundCircle) {\\n            // Set background circle colors here\\n            pallet.backgroundCircle = pallet.background;\\n            pallet.background = pallet.panel;\\n            // Luma based on 'new background', previous background is used for bgCircleColor)\\n            pallet.blackOrWhite = lumaValues[1] < 150 ? \\\"#fff\\\" : \\\"#000\\\";\\n            pallet.dynamicOpacity = lumaValues[1] < 150 ? \\\"0.08\\\" : \\\"0.04\\\";\\n        }\\n\\n        return pallet;\\n    }\\n\\n    /// @notice get an random number between (min and max) using seed and offseting bits\\n    ///         this function assumes that max is never bigger than 0xffffff (hex color with opacity included)\\n    /// @dev this function is simply used to get random number using a seed.\\n    ///      if does bitshifting operations to try to reuse the same seed as much as possible.\\n    ///      should be enough for anyth\\n    /// @param random the randomizer\\n    /// @param min the minimum\\n    /// @param max the maximum\\n    /// @return result the resulting pseudo random number\\n    function _next(\\n        Random memory random,\\n        uint256 min,\\n        uint256 max\\n    ) internal pure returns (uint256 result) {\\n        uint256 newSeed = random.seed;\\n        uint256 newOffset = random.offsetBit + 3;\\n\\n        uint256 maxOffset = 4;\\n        uint256 mask = 0xf;\\n        if (max > 0xfffff) {\\n            mask = 0xffffff;\\n            maxOffset = 24;\\n        } else if (max > 0xffff) {\\n            mask = 0xfffff;\\n            maxOffset = 20;\\n        } else if (max > 0xfff) {\\n            mask = 0xffff;\\n            maxOffset = 16;\\n        } else if (max > 0xff) {\\n            mask = 0xfff;\\n            maxOffset = 12;\\n        } else if (max > 0xf) {\\n            mask = 0xff;\\n            maxOffset = 8;\\n        }\\n\\n        // if offsetBit is too high to get the max number\\n        // just get new seed and restart offset to 0\\n        if (newOffset > (256 - maxOffset)) {\\n            newOffset = 0;\\n            newSeed = uint256(keccak256(abi.encode(newSeed)));\\n        }\\n\\n        uint256 offseted = (newSeed >> newOffset);\\n        uint256 part = offseted & mask;\\n        result = min + (part % (max - min));\\n\\n        random.seed = newSeed;\\n        random.offsetBit = newOffset;\\n    }\\n\\n    function _boolPercentage(Random memory random, uint256 percentage) internal pure returns (bool) {\\n        // E.G. If percentage = 30, and random = 0-29 we return true\\n        // Percentage = 1, random = 0 (TRUE)\\n        return (SeedPhraseUtils._next(random, 0, 100) < percentage);\\n    }\\n\\n    /// @param random source of randomness (based on tokenSeed)\\n    /// @param attributes art attributes\\n    /// @return the json\\n    function render(SeedPhraseUtils.Random memory random, SeedPhraseUtils.Attrs memory attributes)\\n        external\\n        pure\\n        returns (string memory)\\n    {\\n        // Get color pallet\\n        SeedPhraseUtils.Colors memory pallet = SeedPhraseUtils._getPalette(random, attributes);\\n\\n        //  Start SVG (viewbox & static patterns)\\n        bytes memory svg = abi.encodePacked(\\n            \\\"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1600 1600'><path fill='\\\",\\n            pallet.background,\\n            \\\"' \\\",\\n            SeedPhraseUtils._getStrokeStyle(attributes.border, pallet.blackOrWhite, \\\"0.3\\\", 50),\\n            \\\" d='M0 0h1600v1600H0z'/>\\\",\\n            \\\"  <pattern id='panelCircles' x='0' y='0' width='.25' height='.1' patternUnits='objectBoundingBox'>\\\",\\n            \\\"<circle cx='50' cy='50' r='40' fill='\\\",\\n            pallet.negativeCircleFill,\\n            \\\"' \\\",\\n            SeedPhraseUtils._getStrokeStyle(attributes.showStroke, pallet.negativeCircleStroke, \\\"1\\\", strokeWeight),\\n            \\\" /></pattern>\\\"\\n        );\\n        // Render optional patterns (grid OR background circles)\\n        if (attributes.backgroundCircles) {\\n            svg = abi.encodePacked(\\n                svg,\\n                \\\"<pattern id='backgroundCircles' x='0' y='0' width='100' height='100'\\\",\\n                \\\" patternUnits='userSpaceOnUse'><circle cx='50' cy='50' r='40' fill='\\\",\\n                pallet.blackOrWhite,\\n                \\\"' style='fill-opacity: \\\",\\n                pallet.dynamicOpacity,\\n                \\\";'></circle></pattern><path fill='url(#backgroundCircles)' d='M0 0h1600v1600H0z'/>\\\"\\n            );\\n        } else if (attributes.showGrid) {\\n            svg = abi.encodePacked(\\n                svg,\\n                \\\"<pattern id='grid' x='0' y='0' width='100' height='100'\\\",\\n                \\\" patternUnits='userSpaceOnUse'><rect x='0' y='0' width='100' height='100' fill='none' \\\",\\n                SeedPhraseUtils._getStrokeStyle(true, pallet.blackOrWhite, pallet.dynamicOpacity, strokeWeight),\\n                \\\" /></pattern><path fill='url(#grid)' d='M0 0h1600v1600H0z'/>\\\"\\n            );\\n        }\\n        if (attributes.bigBackgroundCircle) {\\n            (uint16 shapeSize, uint16 stroke) = SeedPhraseUtils._backgroundShapeSizing(random, attributes);\\n            // uint16 centerCircle = (viewBox / 2); // Viewbox = 1600, Center = 800\\n            svg = abi.encodePacked(\\n                svg,\\n                \\\"<circle cx='800' cy='800' r='\\\",\\n                (shapeSize / 2).toString(),\\n                \\\"' fill='\\\",\\n                pallet.backgroundCircle,\\n                \\\"' stroke='\\\",\\n                pallet.negativeCircleStroke,\\n                \\\"' style='stroke-width:\\\",\\n                stroke.toString(),\\n                \\\";stroke-opacity:0.3'/>\\\"\\n            );\\n        } else if (attributes.backgroundSquare) {\\n            (uint16 shapeSize, uint16 stroke) = SeedPhraseUtils._backgroundShapeSizing(random, attributes);\\n            uint16 centerSquare = ((viewBox - shapeSize) / 2);\\n            svg = abi.encodePacked(\\n                svg,\\n                \\\"<rect x='\\\",\\n                centerSquare.toString(),\\n                \\\"' y='\\\",\\n                centerSquare.toString(),\\n                \\\"' width='\\\",\\n                shapeSize.toString(),\\n                \\\"' height='\\\",\\n                shapeSize.toString(),\\n                \\\"' fill='\\\",\\n                pallet.backgroundCircle,\\n                \\\"' stroke='\\\",\\n                pallet.negativeCircleStroke,\\n                \\\"' style='stroke-width:\\\",\\n                stroke.toString(),\\n                \\\";stroke-opacity:0.3'/>\\\"\\n            );\\n        }\\n\\n        // Double panel (only if holder has burned two tokens from the defined pairings)\\n        if (attributes.doublePanel) {\\n            (uint8[4] memory firstBipIndexArray, string memory firstBipIndexStr) = SeedPhraseUtils._transformTokenId(\\n                attributes.bipWordId\\n            );\\n            (uint8[4] memory secondBipIndexArray, string memory secondBipIndexStr) = SeedPhraseUtils._transformTokenId(\\n                attributes.secondBipWordId\\n            );\\n\\n            svg = abi.encodePacked(\\n                svg,\\n                _renderSinglePanel(firstBipIndexArray, attributes, pallet, doublePanel1X, false),\\n                _renderSinglePanel(secondBipIndexArray, attributes, pallet, doublePanel2X, true)\\n            );\\n\\n            // Create text\\n            bytes memory combinedText = abi.encodePacked(firstBipIndexStr, \\\" - #\\\", secondBipIndexStr);\\n            svg = abi.encodePacked(\\n                svg,\\n                SeedPhraseUtils._renderText(string(combinedText), pallet.blackOrWhite),\\n                \\\"</svg>\\\"\\n            );\\n        }\\n        // Single Panel\\n        else {\\n            (uint8[4] memory bipIndexArray, string memory bipIndexStr) = SeedPhraseUtils._transformTokenId(\\n                attributes.bipWordId\\n            );\\n            svg = abi.encodePacked(svg, _renderSinglePanel(bipIndexArray, attributes, pallet, singlePanelX, false));\\n\\n            // Add closing text and svg element\\n            svg = abi.encodePacked(svg, SeedPhraseUtils._renderText(bipIndexStr, pallet.blackOrWhite), \\\"</svg>\\\");\\n        }\\n\\n        return string(svg);\\n    }\\n\\n    function _renderSinglePanel(\\n        uint8[4] memory bipIndexArray,\\n        SeedPhraseUtils.Attrs memory attributes,\\n        SeedPhraseUtils.Colors memory pallet,\\n        uint16 panelX,\\n        bool secondPanel\\n    ) internal pure returns (bytes memory panelSvg) {\\n        // Draw panels\\n        bool squareEdges = (attributes.doublePanel && attributes.backgroundSquare);\\n        if (attributes.showPanel) {\\n            panelSvg = abi.encodePacked(\\n                \\\"<rect x='\\\",\\n                (panelX - padding).toString(),\\n                \\\"' y='\\\",\\n                (panelY - padding).toString(),\\n                \\\"' width='\\\",\\n                (panelWidth + (padding * 2)).toString(),\\n                \\\"' height='\\\",\\n                (panelHeight + (padding * 2)).toString(),\\n                \\\"' rx='\\\",\\n                (squareEdges ? 0 : radius).toString(),\\n                \\\"' fill='\\\",\\n                (secondPanel ? pallet.panel2 : pallet.panel),\\n                \\\"' \\\",\\n                SeedPhraseUtils._getStrokeStyle(attributes.showStroke, pallet.panelStroke, \\\"1\\\", strokeWeight),\\n                \\\"/>\\\"\\n            );\\n        }\\n        // Fill panel with negative circles, should resemble M600 300h400v1000H600z\\n        panelSvg = abi.encodePacked(\\n            panelSvg,\\n            \\\"<path fill='url(#panelCircles)' d='M\\\",\\n            panelX.toString(),\\n            \\\" \\\",\\n            panelY.toString(),\\n            \\\"h\\\",\\n            panelWidth.toString(),\\n            \\\"v\\\",\\n            panelHeight.toString(),\\n            \\\"H\\\",\\n            panelX.toString(),\\n            \\\"z'/>\\\"\\n        );\\n        // Draw selected circles\\n        panelSvg = abi.encodePacked(\\n            panelSvg,\\n            _renderSelectedCircles(bipIndexArray, pallet, attributes.showStroke, panelX, secondPanel)\\n        );\\n    }\\n\\n    function _renderSelectedCircles(\\n        uint8[4] memory bipIndexArray,\\n        SeedPhraseUtils.Colors memory pallet,\\n        bool showStroke,\\n        uint16 panelX,\\n        bool secondPanel\\n    ) internal pure returns (bytes memory svg) {\\n        for (uint8 i = 0; i < bipIndexArray.length; i++) {\\n            svg = abi.encodePacked(\\n                svg,\\n                \\\"<circle cx='\\\",\\n                (panelX + (segmentSize * i) + radius).toString(),\\n                \\\"' cy='\\\",\\n                (panelY + (segmentSize * bipIndexArray[i]) + radius).toString(),\\n                \\\"' r='41' fill='\\\", // Increase the size a tiny bit here (+1) to hide negative circle outline\\n                (secondPanel ? pallet.selectedCircleFill2 : pallet.selectedCircleFill),\\n                \\\"' \\\",\\n                SeedPhraseUtils._getStrokeStyle(showStroke, pallet.selectedCircleStroke, \\\"1\\\", strokeWeight),\\n                \\\" />\\\"\\n            );\\n        }\\n    }\\n\\n    function getRarityRating(bytes32 tokenSeed) external pure returns (uint8) {\\n        SeedPhraseUtils.Random memory random = SeedPhraseUtils.Random({ seed: uint256(tokenSeed), offsetBit: 0 });\\n        (, uint8 rarityRating) = SeedPhraseUtils.tokenTraits(SeedPhraseUtils.tokenAttributes(0, 0, random, 0));\\n\\n        return rarityRating;\\n    }\\n\\n    function getTraitsAndAttributes(\\n        uint16 bipWordId,\\n        uint16 secondBipWordId,\\n        uint8 rarityValue,\\n        SeedPhraseUtils.Random memory random\\n    ) external pure returns (bytes memory, SeedPhraseUtils.Attrs memory) {\\n        SeedPhraseUtils.Attrs memory attributes = SeedPhraseUtils.tokenAttributes(\\n            bipWordId,\\n            secondBipWordId,\\n            random,\\n            rarityValue\\n        );\\n\\n        (bytes memory traits, ) = SeedPhraseUtils.tokenTraits(attributes);\\n\\n        return (traits, attributes);\\n    }\\n\\n    function getKarma(IKarmaScore karma, bytes memory data, address account) external view returns (uint256) {\\n        if (data.length > 0) {\\n            (, uint256 karmaScore, ) = abi.decode(data, (address, uint256, bytes32[]));\\n            if (karma.verify(account, karmaScore, data)) {\\n                return account == address(0) ? 1000 : karmaScore;\\n            }\\n        }\\n        return 1000;\\n    }\\n\\n    function shuffleBipWords(uint256 randomValue) external pure returns (uint16[] memory) {\\n        uint16 size = 2048;\\n        uint16[] memory result = new uint16[](size);\\n\\n        // Initialize array.\\n        for (uint16 i = 0; i < size; i++) {\\n            result[i] = i + 1;\\n        }\\n\\n        // Set the initial randomness based on the provided entropy from VRF.\\n        bytes32 random = keccak256(abi.encodePacked(randomValue));\\n\\n        // Set the last item of the array which will be swapped.\\n        uint16 lastItem = size - 1;\\n\\n        // We need to do `size - 1` iterations to completely shuffle the array.\\n        for (uint16 i = 1; i < size - 1; i++) {\\n            // Select a number based on the randomness.\\n            uint16 selectedItem = uint16(uint256(random) % lastItem);\\n\\n            // Swap items `selected_item <> last_item`.\\n            (result[lastItem], result[selectedItem]) = (result[selectedItem], result[lastItem]);\\n\\n            // Decrease the size of the possible shuffle\\n            // to preserve the already shuffled items.\\n            // The already shuffled items are at the end of the array.\\n            lastItem--;\\n\\n            // Generate new randomness.\\n            random = keccak256(abi.encodePacked(random));\\n        }\\n\\n        return result;\\n    }\\n\\n    function getDescriptionPt1() internal pure returns (string memory) {\\n        return \\\"\\\\\\\"Seed Phrase is a 'Crypto Native' *fully* on-chain collection.\\\\\\\\n\\\\\\\\nA '*SEED*' is unique, it represents a single word from the BIP-0039 word list (the most commonly used word list to generate a seed/recovery phrase, think of it as a dictionary that only holds 2048 words).\\\\\\\\n\\\\\\\\n***Your 'SEED*' = *Your 'WORD*' in the list.**  \\\\\\\\nClick [here](https://www.seedphrase.codes/token?id=\\\";\\n\\n    }\\n\\n    function getDescriptionPt2() internal pure returns (string memory) {\\n        return \\\") to decipher *your 'SEED*' and find out which word it translates to!\\\\\\\\n\\\\\\\\nFor Licensing, T&Cs or any other info, please visit: [www.seedphrase.codes](https://www.seedphrase.codes/).\\\\\\\"\\\";\\n    }\\n\\n    function getTokenURI(string memory output, bytes memory traits, uint256 tokenId) external pure returns (string memory) {\\n        return string(\\n            abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                    NilProtocolUtils.base64encode(\\n                    bytes(\\n                        string(\\n                            abi.encodePacked(\\n                                '{\\\"name\\\": \\\"Seed Phrase #',\\n                                    NilProtocolUtils.stringify(tokenId),\\n                                '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                                    NilProtocolUtils.base64encode(bytes(output)),\\n                                '\\\", \\\"attributes\\\": ',\\n                                traits,\\n                                ', \\\"description\\\": ',\\n                                getDescriptionPt1(),\\n                                tokenId.toString(),\\n                                getDescriptionPt2(),\\n                                \\\"}\\\"\\n                            )\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKarmaScore.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(     (@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(   @@@@@@@@@@@@@@@@@@@@(            @@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@             @@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@(            @@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@(            @@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@     @@@@@@@     @@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@(         @@(         @@(            @@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@          @@          @@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@     @@@@@@@     @@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@ @@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(     @@@@@@@     @@@@@@@     @@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @           @           @@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@(            @@@         @@@         @@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@     @@@@@@@     @@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@(            @@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@(            @@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@(            @@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@(     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n */\\npragma solidity >=0.8.4;\\n\\ninterface IKarmaScore {\\n    function verify(\\n        address account,\\n        uint256 score,\\n        bytes calldata data\\n    ) external view returns (bool);\\n\\n    function merkleRoot() external view returns (bytes32);\\n\\n    function setMerkleRoot(bytes32 _merkleRoot) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NilProtocolUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nlibrary NilProtocolUtils {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// [MIT License]\\n    /// @title Base64\\n    /// @notice Provides a function for encoding some bytes in base64\\n    /// @author Brecht Devos <brecht@loopring.org>\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function base64encode(bytes memory data) external pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n\\n    // @notice converts number to string\\n    function stringify(uint256 value) external pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/NilProtocolUtils.sol\": {\r\n        \"NilProtocolUtils\": \"0x61fae53d161095e9b75306837ff06c7b778f6504\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vrfRandomValue\",\"type\":\"uint256\"}],\"name\":\"generateSeed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKarmaScore\",\"name\":\"karma\",\"type\":\"IKarmaScore\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getKarma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenSeed\",\"type\":\"bytes32\"}],\"name\":\"getRarityRating\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"output\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"traits\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"bipWordId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"secondBipWordId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"rarityValue\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offsetBit\",\"type\":\"uint256\"}],\"internalType\":\"struct SeedPhraseUtils.Random\",\"name\":\"random\",\"type\":\"tuple\"}],\"name\":\"getTraitsAndAttributes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"showStroke\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"border\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"showPanel\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backgroundSquare\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"bigBackgroundCircle\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"showGrid\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backgroundCircles\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"greyscale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"doublePanel\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"bipWordId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"secondBipWordId\",\"type\":\"uint16\"}],\"internalType\":\"struct SeedPhraseUtils.Attrs\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offsetBit\",\"type\":\"uint256\"}],\"internalType\":\"struct SeedPhraseUtils.Random\",\"name\":\"random\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"showStroke\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"border\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"showPanel\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backgroundSquare\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"bigBackgroundCircle\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"showGrid\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backgroundCircles\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"greyscale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"doublePanel\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"bipWordId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"secondBipWordId\",\"type\":\"uint16\"}],\"internalType\":\"struct SeedPhraseUtils.Attrs\",\"name\":\"attributes\",\"type\":\"tuple\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomValue\",\"type\":\"uint256\"}],\"name\":\"shuffleBipWords\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"SeedPhraseUtils","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"300","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}