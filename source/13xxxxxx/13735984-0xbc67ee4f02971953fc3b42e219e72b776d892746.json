{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"YTCZap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./IYieldTokenCompounding.sol\\\";\\r\\nimport \\\"./balancer-core-v2/lib/openzeppelin/IERC20.sol\\\";\\r\\nimport \\\"./balancer-core-v2/lib/openzeppelin/SafeMath.sol\\\";\\r\\nimport \\\"./balancer-core-v2/lib/openzeppelin/SafeERC20.sol\\\";\\r\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\n/// @notice Yield token compounding without having to swap to basetokens from ETH manually\\r\\n/// This contract was intended to be used for simulation purposes only\\r\\ncontract YTCZap {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    struct YTCInputs {\\r\\n        IYieldTokenCompounding ytcContract;\\r\\n        uint8 n;\\r\\n        address trancheAddress;\\r\\n        bytes32 balancerPoolId;\\r\\n        uint256 amount;\\r\\n        uint256 expectedYtOutput;\\r\\n        uint256 expectedBaseTokensSpent;\\r\\n        address baseToken;\\r\\n        address yieldToken;\\r\\n    }\\r\\n\\r\\n    struct SwapInputs {\\r\\n        uint256 deadline;\\r\\n        address payable uniswapContract;\\r\\n        bytes zapperCallData;\\r\\n        address payable zapperContract;\\r\\n    }\\r\\n\\r\\n    function compoundUniswap(\\r\\n        address _ytcContractAddress,\\r\\n        uint8 _n,\\r\\n        address _trancheAddress,\\r\\n        bytes32 _balancerPoolId,\\r\\n        uint256 _amount,\\r\\n        uint256 _expectedYtOutput,\\r\\n        uint256 _expectedBaseTokensSpent,\\r\\n        address _baseToken,\\r\\n        address _yieldToken,\\r\\n        uint256 _deadline,\\r\\n        address payable _uniswapContract\\r\\n    ) external payable returns (uint256, uint256) {\\r\\n        YTCInputs memory ytcInputs = _initYTCInputs(\\r\\n            _ytcContractAddress,\\r\\n            _n,\\r\\n            _trancheAddress,\\r\\n            _balancerPoolId,\\r\\n            _amount,\\r\\n            _expectedYtOutput,\\r\\n            _expectedBaseTokensSpent,\\r\\n            _baseToken,\\r\\n            _yieldToken\\r\\n        );\\r\\n\\r\\n        SwapInputs memory swapInputs;\\r\\n        {\\r\\n            swapInputs.deadline = _deadline;\\r\\n            swapInputs.uniswapContract = _uniswapContract;\\r\\n        }\\r\\n\\r\\n        return _compound(\\r\\n            ytcInputs,\\r\\n            swapInputs,\\r\\n            1\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function compoundZapper(\\r\\n        address _ytcContractAddress,\\r\\n        uint8 _n,\\r\\n        address _trancheAddress,\\r\\n        bytes32 _balancerPoolId,\\r\\n        uint256 _amount,\\r\\n        uint256 _expectedYtOutput,\\r\\n        uint256 _expectedBaseTokensSpent,\\r\\n        address _baseToken,\\r\\n        address _yieldToken,\\r\\n        bytes calldata _zapperCallData,\\r\\n        address payable _zapperContract\\r\\n    ) external payable returns (uint256, uint256) {\\r\\n\\r\\n        YTCInputs memory ytcInputs = _initYTCInputs(\\r\\n            _ytcContractAddress,\\r\\n            _n,\\r\\n            _trancheAddress,\\r\\n            _balancerPoolId,\\r\\n            _amount,\\r\\n            _expectedYtOutput,\\r\\n            _expectedBaseTokensSpent,\\r\\n            _baseToken,\\r\\n            _yieldToken\\r\\n        );\\r\\n\\r\\n        SwapInputs memory swapInputs;\\r\\n        {\\r\\n            swapInputs.zapperCallData = _zapperCallData;\\r\\n            swapInputs.zapperContract = _zapperContract;\\r\\n        }\\r\\n\\r\\n        return _compound(\\r\\n            ytcInputs,\\r\\n            swapInputs,\\r\\n            0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _initYTCInputs(\\r\\n        address _ytcContractAddress,\\r\\n        uint8 _n,\\r\\n        address _trancheAddress,\\r\\n        bytes32 _balancerPoolId,\\r\\n        uint256 _amount,\\r\\n        uint256 _expectedYtOutput,\\r\\n        uint256 _expectedBaseTokensSpent,\\r\\n        address _baseToken,\\r\\n        address _yieldToken\\r\\n    ) internal pure returns (YTCInputs memory){\\r\\n        YTCInputs memory ytcInputs;\\r\\n\\r\\n        // We need to do this in two separate blocks due to local variable limits\\r\\n        {\\r\\n            ytcInputs.ytcContract = IYieldTokenCompounding(_ytcContractAddress);\\r\\n            ytcInputs.n = _n;\\r\\n            ytcInputs.trancheAddress = _trancheAddress;\\r\\n            ytcInputs.balancerPoolId = _balancerPoolId;\\r\\n            ytcInputs.expectedYtOutput = _expectedYtOutput;\\r\\n        }\\r\\n        {\\r\\n            ytcInputs.amount = _amount;\\r\\n            ytcInputs.expectedBaseTokensSpent = _expectedBaseTokensSpent;\\r\\n            ytcInputs.baseToken = _baseToken;\\r\\n            ytcInputs.yieldToken = _yieldToken;\\r\\n        }\\r\\n\\r\\n        return ytcInputs;\\r\\n    }\\r\\n    \\r\\n    // Requires all the same inputs as YieldTokenCompoundingSwap + the address of the base token, the yield token, and the zapper information\\r\\n    function _compound(\\r\\n        YTCInputs memory ytcInputs,\\r\\n        SwapInputs memory swapInputs,\\r\\n        uint256 _type\\r\\n    ) internal returns (uint256, uint256) {\\r\\n\\r\\n\\r\\n        uint256 swappedAmount;\\r\\n        {\\r\\n            // get the initial balance of the base tokens\\r\\n            uint256 initialBalance = _getBalance(ytcInputs.baseToken);\\r\\n\\r\\n            // execute the correct swap based on the type\\r\\n            if (_type == 0){\\r\\n                _executeCurveSwap(msg.value, swapInputs.zapperContract, swapInputs.zapperCallData);\\r\\n            } else if (_type == 1){\\r\\n                _executeUniswapSwap(msg.value, ytcInputs.baseToken, ytcInputs.amount, swapInputs.deadline, swapInputs.uniswapContract);\\r\\n            }\\r\\n\\r\\n            // calculate the amount that was received in the swap\\r\\n            swappedAmount = _getBalance(ytcInputs.baseToken).sub(initialBalance);\\r\\n\\r\\n            // if the swappedAmount isn't greater than 0, something went wrong\\r\\n            require (swappedAmount > 0, \\\"Swapped to Invalid Token\\\"); \\r\\n            // if the swappedAmount isn't greater than the compounding amount, the compounding will fail\\r\\n            require(swappedAmount >= ytcInputs.amount, \\\"Not enough tokens received in swap\\\");\\r\\n        }\\r\\n\\r\\n        // approve the ytc contract to spend the base token\\r\\n        IERC20(ytcInputs.baseToken).approve(address(ytcInputs.ytcContract), ytcInputs.amount);\\r\\n\\r\\n        // Run the ytc contract\\r\\n        uint256 yieldTokensReceived;\\r\\n        uint256 baseTokensSpent;\\r\\n        {\\r\\n            (yieldTokensReceived, baseTokensSpent ) = ytcInputs.ytcContract.compound(ytcInputs.n, ytcInputs.trancheAddress, ytcInputs.balancerPoolId, ytcInputs.amount, ytcInputs.expectedYtOutput, ytcInputs.expectedBaseTokensSpent);\\r\\n        }\\r\\n\\r\\n        // transfer the received yield tokens, and the remaining baseTokens\\r\\n        IERC20(ytcInputs.baseToken).safeTransfer(msg.sender, swappedAmount - baseTokensSpent);\\r\\n        IERC20(ytcInputs.yieldToken).safeTransfer(msg.sender, yieldTokensReceived);\\r\\n\\r\\n        return (yieldTokensReceived, baseTokensSpent);\\r\\n    }\\r\\n    \\r\\n    function _executeCurveSwap(uint256 _value, address payable _zapperContract, bytes memory _zapperCallData) private {\\r\\n        (bool success, ) = _zapperContract.call{value: _value}(_zapperCallData);\\r\\n\\r\\n        require(success, \\\"Zap Failed\\\");\\r\\n    }\\r\\n\\r\\n    function _executeUniswapSwap(uint256 _value, address _baseToken, uint256 _amount, uint256 _deadline, address _uniswapRouterAddress) private{\\r\\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(_uniswapRouterAddress);\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = uniswapRouter.WETH();\\r\\n        path[1] = _baseToken;\\r\\n\\r\\n        uniswapRouter.swapExactETHForTokens{value: _value}(_amount, path, address(this), _deadline);\\r\\n    }\\r\\n\\r\\n    function _getBalance(address token)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 balance)\\r\\n    {\\r\\n        if (token == address(0)) {\\r\\n            balance = address(this).balance;\\r\\n        } else {\\r\\n            balance = IERC20(token).balanceOf(address(this));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"balancer-core-v2/lib/openzeppelin/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce gas costs.\\r\\n// The `safeTransfer` and `safeTransferFrom` functions assume that `token` is a contract (an account with code), and\\r\\n// work differently from the OpenZeppelin version if it is not.\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     *\\r\\n     * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\\r\\n     */\\r\\n    function _callOptionalReturn(address token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves.\\r\\n        (bool success, bytes memory returndata) = token.call(data);\\r\\n\\r\\n        // If the low-level call didn't succeed we return whatever was returned from it.\\r\\n        assembly {\\r\\n            if eq(success, 0) {\\r\\n                returndatacopy(0, 0, returndatasize())\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\\r\\n        _require(returndata.length == 0 || abi.decode(returndata, (bool)), Errors.SAFE_ERC20_CALL_FAILED);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"balancer-core-v2/lib/openzeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, Errors.SUB_OVERFLOW);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, uint256 errorCode) internal pure returns (uint256) {\\r\\n        _require(b <= a, errorCode);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"balancer-core-v2/lib/openzeppelin/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"IYieldTokenCompounding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IYieldTokenCompounding {\\r\\n    function compound(\\r\\n        uint8 _n,\\r\\n        address _trancheAddress,\\r\\n        bytes32 _balancerPoolId,\\r\\n        uint256 _amount,\\r\\n        uint256 _expectedYtOutput,\\r\\n        uint256 _expectedBaseTokensSpent\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    function approveTranchePTOnBalancer(address _trancheAddress) external;\\r\\n\\r\\n    function checkTranchePTAllowanceOnBalancer(address _trancheAddress) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"balancer-core-v2/lib/helpers/BalancerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n// solhint-disable\\r\\n\\r\\n/**\\r\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\r\\n * supported.\\r\\n */\\r\\nfunction _require(bool condition, uint256 errorCode) pure {\\r\\n    if (!condition) _revert(errorCode);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\r\\n */\\r\\nfunction _revert(uint256 errorCode) pure {\\r\\n    // We're going to dynamically create a revert string based on the error code, with the following format:\\r\\n    // 'BAL#{errorCode}'\\r\\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\r\\n    //\\r\\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\r\\n    // number (8 to 16 bits) than the individual string characters.\\r\\n    //\\r\\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\r\\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\r\\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\r\\n    assembly {\\r\\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\r\\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\r\\n        // the '0' character.\\r\\n\\r\\n        let units := add(mod(errorCode, 10), 0x30)\\r\\n\\r\\n        errorCode := div(errorCode, 10)\\r\\n        let tenths := add(mod(errorCode, 10), 0x30)\\r\\n\\r\\n        errorCode := div(errorCode, 10)\\r\\n        let hundreds := add(mod(errorCode, 10), 0x30)\\r\\n\\r\\n        // With the individual characters, we can now construct the full string. The \\\"BAL#\\\" part is a known constant\\r\\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\r\\n        // characters to it, each shifted by a multiple of 8.\\r\\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\r\\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\r\\n        // array).\\r\\n\\r\\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\r\\n\\r\\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\r\\n        // message will have the following layout:\\r\\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\r\\n\\r\\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\r\\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\r\\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\r\\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\r\\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\r\\n        // The string length is fixed: 7 characters.\\r\\n        mstore(0x24, 7)\\r\\n        // Finally, the string itself is stored.\\r\\n        mstore(0x44, revertReason)\\r\\n\\r\\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\r\\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\r\\n        revert(0, 100)\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Errors {\\r\\n    // Math\\r\\n    uint256 internal constant ADD_OVERFLOW = 0;\\r\\n    uint256 internal constant SUB_OVERFLOW = 1;\\r\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\r\\n    uint256 internal constant MUL_OVERFLOW = 3;\\r\\n    uint256 internal constant ZERO_DIVISION = 4;\\r\\n    uint256 internal constant DIV_INTERNAL = 5;\\r\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\r\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\r\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\r\\n    uint256 internal constant INVALID_EXPONENT = 9;\\r\\n\\r\\n    // Input\\r\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\r\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\r\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\r\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\r\\n    uint256 internal constant ZERO_TOKEN = 104;\\r\\n\\r\\n    // Shared pools\\r\\n    uint256 internal constant MIN_TOKENS = 200;\\r\\n    uint256 internal constant MAX_TOKENS = 201;\\r\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\r\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\r\\n    uint256 internal constant MINIMUM_BPT = 204;\\r\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\r\\n    uint256 internal constant UNINITIALIZED = 206;\\r\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\r\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\r\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\r\\n\\r\\n    // Pools\\r\\n    uint256 internal constant MIN_AMP = 300;\\r\\n    uint256 internal constant MAX_AMP = 301;\\r\\n    uint256 internal constant MIN_WEIGHT = 302;\\r\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\r\\n    uint256 internal constant MAX_IN_RATIO = 304;\\r\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\r\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\r\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\r\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\r\\n    uint256 internal constant INVALID_TOKEN = 309;\\r\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\r\\n    uint256 internal constant ZERO_INVARIANT = 311;\\r\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\r\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\r\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\r\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\r\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\r\\n\\r\\n    // Lib\\r\\n    uint256 internal constant REENTRANCY = 400;\\r\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\r\\n    uint256 internal constant PAUSED = 402;\\r\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\r\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\r\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\r\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\r\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\r\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\r\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\r\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\r\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\r\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\r\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\r\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\r\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\r\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\r\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\r\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\r\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\r\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\r\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\r\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\r\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\r\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\r\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\r\\n\\r\\n    // Vault\\r\\n    uint256 internal constant INVALID_POOL_ID = 500;\\r\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\r\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\r\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\r\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\r\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\r\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\r\\n    uint256 internal constant SWAP_LIMIT = 507;\\r\\n    uint256 internal constant SWAP_DEADLINE = 508;\\r\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\r\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\r\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\r\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\r\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\r\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\r\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\r\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\r\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\r\\n    uint256 internal constant ETH_TRANSFER = 518;\\r\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\r\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\r\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\r\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\r\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\r\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\r\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\r\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\r\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\r\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\r\\n\\r\\n    // Fees\\r\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\r\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\r\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ytcContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_n\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_trancheAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_balancerPoolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedYtOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedBaseTokensSpent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_uniswapContract\",\"type\":\"address\"}],\"name\":\"compoundUniswap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ytcContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_n\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_trancheAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_balancerPoolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedYtOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedBaseTokensSpent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_zapperCallData\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"_zapperContract\",\"type\":\"address\"}],\"name\":\"compoundZapper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"YTCZap","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}