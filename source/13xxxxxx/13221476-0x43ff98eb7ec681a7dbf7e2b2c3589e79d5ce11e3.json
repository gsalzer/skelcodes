{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/options/OptionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IOptionBuilder.sol\\\";\\nimport \\\"../interfaces/IPodOption.sol\\\";\\nimport \\\"../lib/Conversion.sol\\\";\\nimport \\\"../interfaces/IOptionFactory.sol\\\";\\n\\n/**\\n * @title OptionFactory\\n * @author Pods Finance\\n * @notice Creates and store new Options Series\\n * @dev Uses IOptionBuilder to create the different types of Options\\n */\\ncontract OptionFactory is IOptionFactory, Conversion {\\n    IConfigurationManager public immutable configurationManager;\\n    IOptionBuilder public podPutBuilder;\\n    IOptionBuilder public wPodPutBuilder;\\n    IOptionBuilder public aavePodPutBuilder;\\n    IOptionBuilder public podCallBuilder;\\n    IOptionBuilder public wPodCallBuilder;\\n    IOptionBuilder public aavePodCallBuilder;\\n\\n    event OptionCreated(\\n        address indexed deployer,\\n        address option,\\n        IPodOption.OptionType _optionType,\\n        IPodOption.ExerciseType _exerciseType,\\n        address underlyingAsset,\\n        address strikeAsset,\\n        uint256 strikePrice,\\n        uint256 expiration,\\n        uint256 exerciseWindowSize\\n    );\\n\\n    constructor(\\n        address PodPutBuilder,\\n        address WPodPutBuilder,\\n        address AavePodPutBuilder,\\n        address PodCallBuilder,\\n        address WPodCallBuilder,\\n        address AavePodCallBuilder,\\n        address ConfigurationManager\\n    ) public {\\n        configurationManager = IConfigurationManager(ConfigurationManager);\\n        podPutBuilder = IOptionBuilder(PodPutBuilder);\\n        wPodPutBuilder = IOptionBuilder(WPodPutBuilder);\\n        aavePodPutBuilder = IOptionBuilder(AavePodPutBuilder);\\n        podCallBuilder = IOptionBuilder(PodCallBuilder);\\n        wPodCallBuilder = IOptionBuilder(WPodCallBuilder);\\n        aavePodCallBuilder = IOptionBuilder(AavePodCallBuilder);\\n    }\\n\\n    /**\\n     * @notice Creates a new Option Series\\n     * @param name The option token name. Eg. \\\"Pods Put WBTC-USDC 5000 2020-02-23\\\"\\n     * @param symbol The option token symbol. Eg. \\\"podWBTC:20AA\\\"\\n     * @param optionType The option type. Eg. \\\"0 for Put / 1 for Calls\\\"\\n     * @param exerciseType The option exercise type. Eg. \\\"0 for European, 1 for American\\\"\\n     * @param underlyingAsset The underlying asset. Eg. \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\"\\n     * @param strikeAsset The strike asset. Eg. \\\"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\\\"\\n     * @param strikePrice The option strike price including decimals. e.g. 5000000000\\n     * @param expiration The Expiration Option date in seconds. e.g. 1600178324\\n     * @param exerciseWindowSize The Expiration Window Size duration in seconds. E.g 24*60*60 (24h)\\n     * @return option The address for the newly created option\\n     */\\n    function createOption(\\n        string memory name,\\n        string memory symbol,\\n        IPodOption.OptionType optionType,\\n        IPodOption.ExerciseType exerciseType,\\n        address underlyingAsset,\\n        address strikeAsset,\\n        uint256 strikePrice,\\n        uint256 expiration,\\n        uint256 exerciseWindowSize,\\n        bool isAave\\n    ) external override returns (address) {\\n        IOptionBuilder builder;\\n        address wrappedNetworkToken = wrappedNetworkTokenAddress();\\n\\n        if (optionType == IPodOption.OptionType.PUT) {\\n            if (underlyingAsset == wrappedNetworkToken) {\\n                builder = wPodPutBuilder;\\n            } else if (isAave) {\\n                builder = aavePodPutBuilder;\\n            } else {\\n                builder = podPutBuilder;\\n            }\\n        } else {\\n            if (underlyingAsset == wrappedNetworkToken) {\\n                builder = wPodCallBuilder;\\n            } else if (isAave) {\\n                builder = aavePodCallBuilder;\\n            } else {\\n                builder = podCallBuilder;\\n            }\\n        }\\n\\n        address option = address(\\n            builder.buildOption(\\n                name,\\n                symbol,\\n                exerciseType,\\n                underlyingAsset,\\n                strikeAsset,\\n                strikePrice,\\n                expiration,\\n                exerciseWindowSize,\\n                configurationManager\\n            )\\n        );\\n\\n        emit OptionCreated(\\n            msg.sender,\\n            option,\\n            optionType,\\n            exerciseType,\\n            underlyingAsset,\\n            strikeAsset,\\n            strikePrice,\\n            expiration,\\n            exerciseWindowSize\\n        );\\n\\n        return option;\\n    }\\n\\n    function wrappedNetworkTokenAddress() public override returns (address) {\\n        return _parseAddressFromUint(configurationManager.getParameter(\\\"WRAPPED_NETWORK_TOKEN\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IPodOption.sol\\\";\\nimport \\\"./IConfigurationManager.sol\\\";\\n\\ninterface IOptionBuilder {\\n    function buildOption(\\n        string memory _name,\\n        string memory _symbol,\\n        IPodOption.ExerciseType _exerciseType,\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiration,\\n        uint256 _exerciseWindowSize,\\n        IConfigurationManager _configurationManager\\n    ) external returns (IPodOption);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPodOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPodOption is IERC20 {\\n    /** Enums */\\n    // @dev 0 for Put, 1 for Call\\n    enum OptionType { PUT, CALL }\\n    // @dev 0 for European, 1 for American\\n    enum ExerciseType { EUROPEAN, AMERICAN }\\n\\n    /** Events */\\n    event Mint(address indexed minter, uint256 amount);\\n    event Unmint(address indexed minter, uint256 optionAmount, uint256 strikeAmount, uint256 underlyingAmount);\\n    event Exercise(address indexed exerciser, uint256 amount);\\n    event Withdraw(address indexed minter, uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    /** Functions */\\n\\n    /**\\n     * @notice Locks collateral and write option tokens.\\n     *\\n     * @dev The issued amount ratio is 1:1, i.e., 1 option token for 1 underlying token.\\n     *\\n     * The collateral could be the strike or the underlying asset depending on the option type: Put or Call,\\n     * respectively\\n     *\\n     * It presumes the caller has already called IERC20.approve() on the\\n     * strike/underlying token contract to move caller funds.\\n     *\\n     * Options can only be minted while the series is NOT expired.\\n     *\\n     * It is also important to notice that options will be sent back\\n     * to `msg.sender` and not the `owner`. This behavior is designed to allow\\n     * proxy contracts to mint on others behalf. The `owner` will be able to remove\\n     * the deposited collateral after series expiration or by calling unmint(), even\\n     * if a third-party minted options on its behalf.\\n     *\\n     * @param amountOfOptions The amount option tokens to be issued\\n     * @param owner Which address will be the owner of the options\\n     */\\n    function mint(uint256 amountOfOptions, address owner) external;\\n\\n    /**\\n     * @notice Allow option token holders to use them to exercise the amount of units\\n     * of the locked tokens for the equivalent amount of the exercisable assets.\\n     *\\n     * @dev It presumes the caller has already called IERC20.approve() exercisable asset\\n     * to move caller funds.\\n     *\\n     * On American options, this function can only called anytime before expiration.\\n     * For European options, this function can only be called during the exerciseWindow.\\n     * Meaning, after expiration and before the end of exercise window.\\n     *\\n     * @param amountOfOptions The amount option tokens to be exercised\\n     */\\n    function exercise(uint256 amountOfOptions) external;\\n\\n    /**\\n     * @notice After series expiration in case of American or after exercise window for European,\\n     * allow minters who have locked their collateral to withdraw them proportionally\\n     * to their minted options.\\n     *\\n     * @dev If assets had been exercised during the option series the minter may withdraw\\n     * the exercised assets or a combination of exercised and collateral.\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Unlocks collateral by burning option tokens.\\n     *\\n     * Options can only be burned while the series is NOT expired.\\n     *\\n     * @param amountOfOptions The amount option tokens to be burned\\n     */\\n    function unmint(uint256 amountOfOptions) external;\\n\\n    function optionType() external view returns (OptionType);\\n\\n    function exerciseType() external view returns (ExerciseType);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function underlyingAssetDecimals() external view returns (uint8);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function strikeAssetDecimals() external view returns (uint8);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function strikePriceDecimals() external view returns (uint8);\\n\\n    function expiration() external view returns (uint256);\\n\\n    function startOfExerciseWindow() external view returns (uint256);\\n\\n    function hasExpired() external view returns (bool);\\n\\n    function isTradeWindow() external view returns (bool);\\n\\n    function isExerciseWindow() external view returns (bool);\\n\\n    function isWithdrawWindow() external view returns (bool);\\n\\n    function strikeToTransfer(uint256 amountOfOptions) external view returns (uint256);\\n\\n    function getSellerWithdrawAmounts(address owner)\\n        external\\n        view\\n        returns (uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    function underlyingReserves() external view returns (uint256);\\n\\n    function strikeReserves() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Conversion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ncontract Conversion {\\n    /**\\n     * @notice Parses the address represented by an uint\\n     */\\n    function _parseAddressFromUint(uint256 x) internal pure returns (address) {\\n        bytes memory data = new bytes(32);\\n        assembly {\\n            mstore(add(data, 32), x)\\n        }\\n        return abi.decode(data, (address));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IPodOption.sol\\\";\\n\\ninterface IOptionFactory {\\n    function createOption(\\n        string memory _name,\\n        string memory _symbol,\\n        IPodOption.OptionType _optionType,\\n        IPodOption.ExerciseType _exerciseType,\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiration,\\n        uint256 _exerciseWindowSize,\\n        bool _isAave\\n    ) external returns (address);\\n\\n    function wrappedNetworkTokenAddress() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfigurationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity >=0.6.12;\\n\\ninterface IConfigurationManager {\\n    function setParameter(bytes32 name, uint256 value) external;\\n\\n    function setEmergencyStop(address emergencyStop) external;\\n\\n    function setPricingMethod(address pricingMethod) external;\\n\\n    function setIVGuesser(address ivGuesser) external;\\n\\n    function setIVProvider(address ivProvider) external;\\n\\n    function setPriceProvider(address priceProvider) external;\\n\\n    function setCapProvider(address capProvider) external;\\n\\n    function setAMMFactory(address ammFactory) external;\\n\\n    function setOptionFactory(address optionFactory) external;\\n\\n    function setOptionHelper(address optionHelper) external;\\n\\n    function setOptionPoolRegistry(address optionPoolRegistry) external;\\n\\n    function getParameter(bytes32 name) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function getEmergencyStop() external view returns (address);\\n\\n    function getPricingMethod() external view returns (address);\\n\\n    function getIVGuesser() external view returns (address);\\n\\n    function getIVProvider() external view returns (address);\\n\\n    function getPriceProvider() external view returns (address);\\n\\n    function getCapProvider() external view returns (address);\\n\\n    function getAMMFactory() external view returns (address);\\n\\n    function getOptionFactory() external view returns (address);\\n\\n    function getOptionHelper() external view returns (address);\\n\\n    function getOptionPoolRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"PodPutBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WPodPutBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AavePodPutBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"PodCallBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WPodCallBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AavePodCallBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ConfigurationManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"option\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IPodOption.OptionType\",\"name\":\"_optionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum IPodOption.ExerciseType\",\"name\":\"_exerciseType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exerciseWindowSize\",\"type\":\"uint256\"}],\"name\":\"OptionCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aavePodCallBuilder\",\"outputs\":[{\"internalType\":\"contract IOptionBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aavePodPutBuilder\",\"outputs\":[{\"internalType\":\"contract IOptionBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationManager\",\"outputs\":[{\"internalType\":\"contract IConfigurationManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"enum IPodOption.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"enum IPodOption.ExerciseType\",\"name\":\"exerciseType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exerciseWindowSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAave\",\"type\":\"bool\"}],\"name\":\"createOption\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podCallBuilder\",\"outputs\":[{\"internalType\":\"contract IOptionBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podPutBuilder\",\"outputs\":[{\"internalType\":\"contract IOptionBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wPodCallBuilder\",\"outputs\":[{\"internalType\":\"contract IOptionBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wPodPutBuilder\",\"outputs\":[{\"internalType\":\"contract IOptionBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNetworkTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OptionFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b494573808f2a1fecab1f40569756ca4593981e00000000000000000000000091e56246f21286c5395800c8681f080c5a63528e000000000000000000000000394484ebee0b45a04b262f82d325694e41b99b33000000000000000000000000699f2144f6fb54e6e9db37306f2e304d662e15a90000000000000000000000005098243a89d446ca4e30f45065744ac108b1f62b000000000000000000000000d2071606c1ac36f71b497f3104fc9df097bc7a8a000000000000000000000000e4da64757b2b29db43429a52caf7ad884c76f8b0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}