{"status":"1","message":"OK","result":[{"SourceCode":"{\"PussyRocket.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\ncontract PussyRocket is IERC20 {\\n   \\n    string public constant name         = \\u0027PussyRocket\\u0027;\\n    string public constant symbol       = \\u0027PROCK\\u0027;\\n    uint8 public constant decimals      = 18;\\n    \\n    mapping(address =\\u003e uint256) balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n    \\n    address public tokenOwner;\\n    address public crowdsale;\\n    \\n    uint256 public totalSupply_                     = 69e27; // 69B tokens\\n    uint256 public constant unlockTime              = 1640008800; //After this date, tokens are no longer locked\\n    uint256 public limitCrowdsale                   = 58e27;    // 84% of token goes for sale\\n    uint256 public tokensDistributedCrowdsale       = 0;    // The amount of tokens already sold to the ICO buyers\\n    bool public remainingTokenBurnt                 = false;  \\n\\n\\n    modifier onlyOwner {\\n    require(msg.sender == tokenOwner);\\n    _;\\n    }\\n    \\n    modifier onlyCrowdsale {\\n    require(msg.sender == crowdsale);\\n    _;\\n    }\\n    \\n    modifier afterCrowdsale {\\n    require(block.timestamp \\u003e unlockTime || msg.sender == crowdsale);\\n    _;\\n    }\\n    \\n    constructor() public {\\n        tokenOwner = msg.sender;\\n        balances[msg.sender] = totalSupply_ - limitCrowdsale;\\n            emit Transfer(address(0), msg.sender, totalSupply_ - limitCrowdsale);\\n    }\\n\\n    function totalSupply() public override view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    function balanceOf(address account) public override view returns (uint256) {\\n        return balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public afterCrowdsale override returns (bool) {\\n        require(recipient != address(0));\\n        require(amount \\u003c= balances[msg.sender]);\\n\\n        balances[msg.sender] = balances[msg.sender] - amount;\\n        balances[recipient] = balances[recipient] + amount;\\n        emit Transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public afterCrowdsale override returns (bool) {\\n        require(recipient != address(0));\\n        require(amount \\u003c= balances[sender]);\\n        require(amount \\u003c= allowed[sender][msg.sender]);\\n\\n        balances[sender] = balances[sender] - amount;\\n        balances[recipient] = balances[recipient] + amount;\\n        allowed[sender][msg.sender] = allowed[sender][msg.sender] - amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount) public afterCrowdsale override returns (bool) {\\n        allowed[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function allowance(address account,address spender) public override view returns (uint256) {\\n        return allowed[account][spender];\\n    }\\n\\n    function increaseApproval(address spender, uint256 amount) public afterCrowdsale returns (bool) {\\n        allowed[msg.sender][spender] = (allowed[msg.sender][spender] + amount);\\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address spender, uint256 amount) public afterCrowdsale returns (bool) {\\n        uint256 oldValue = allowed[msg.sender][spender];\\n        if (amount \\u003e= oldValue) {\\n          allowed[msg.sender][spender] = 0;\\n        } else {\\n          allowed[msg.sender][spender] = oldValue - amount;\\n        }\\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n        return true;\\n    }\\n   \\n   \\n    // Functions to support the Crowdsale\\n    function setCrowdsale(address _crowdsale) external onlyOwner {\\n        require(_crowdsale != address(0));\\n        crowdsale = _crowdsale;\\n    }\\n    \\n    function distribute(address buyer, uint tokens) external onlyCrowdsale {\\n        require(buyer != address(0));\\n        require(tokens \\u003e 0);\\n\\n        // Check that the limit of ICO tokens hasn\\u0027t been met yet\\n        require(tokensDistributedCrowdsale \\u003c limitCrowdsale);\\n        require(tokensDistributedCrowdsale + tokens \\u003c= limitCrowdsale);\\n\\n        tokensDistributedCrowdsale = tokensDistributedCrowdsale + tokens;\\n        balances[buyer] = balances[buyer] + tokens;\\n        emit Transfer(address(0), buyer, tokens);\\n      }\\n   \\n   function airdrop(address recipient, uint amount) external onlyOwner returns (bool){\\n        require(block.timestamp \\u003c unlockTime);\\n        require(recipient != address(0));\\n        require(amount \\u003c= balances[msg.sender]);\\n        balances[msg.sender] = balances[msg.sender] - amount;\\n        balances[recipient] = balances[recipient] + amount;\\n        emit Transfer(msg.sender, recipient, amount);\\n        return true;\\n      }\\n   \\n    function burn() external onlyCrowdsale {\\n        uint256 remainingICOToken = limitCrowdsale - tokensDistributedCrowdsale;\\n        if(remainingICOToken \\u003e 0 \\u0026\\u0026 !remainingTokenBurnt) {\\n            remainingTokenBurnt = true;    \\n            limitCrowdsale = limitCrowdsale - remainingICOToken;  \\n            totalSupply_ = totalSupply_ - remainingICOToken;\\n        }\\n    }\\n\\n    function emergencyExtract() external onlyOwner {\\n        payable(tokenOwner).transfer(address(this).balance);\\n    }\\n}\\n\\n\\n\"},\"PussyRocketCrowdsale.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\u0027./PussyRocket.sol\\u0027;\\n\\ncontract Crowdsale {\\n   \\n    PussyRocket public constant token = PussyRocket(0x263CE9eA0dC46c9A12F3F624396eEe896c270b60);\\n   \\n    uint256 public constant icoEndTime      = 1640008800;\\n    uint256 public constant fundingGoal     = 58e27;\\n   \\n    address public contractOwner;\\n    uint256 public tokensRaised;\\n    uint256 public etherRaised;\\n   \\n    bool public icoCompleted = false;\\n\\n    modifier whenIcoCompleted {\\n        require(icoCompleted);\\n        _;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == contractOwner);\\n        _;\\n    }\\n\\n    constructor() public {\\n        contractOwner = msg.sender;\\n    }\\n    \\n    \\n    receive() external payable { \\n        purchaseTokens(msg.value);\\n        \\n    }\\n    \\n    function time() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    function purchaseTokens(uint256 etherUsedWei) public payable {\\n    assert(1 ether == 1e18);\\n        require(!icoCompleted);\\n        require(block.timestamp \\u003c icoEndTime);\\n    \\n        uint256 tokensToReiceive;\\n        \\n        \\n        if(tokensRaised \\u003c 14.5e27) { // Each tier is 25% of total funding goal\\n          // Tier 1\\n            tokensToReiceive = 45e6 * etherUsedWei; // 80% discount\\n        } else if(tokensRaised \\u003c  29e27) {\\n          // Tier 2\\n            tokensToReiceive = 22.5e6 * etherUsedWei; // 60% discount\\n        } else if(tokensRaised \\u003c 43.5e27) {\\n            // Tier 3\\n            tokensToReiceive = 15e6 * etherUsedWei; // 40% discount\\n        } else{\\n            // Tier 4\\n            tokensToReiceive = 11.25e6 * etherUsedWei; // 20% discount\\n        }\\n    \\n        token.distribute(msg.sender, tokensToReiceive);\\n        tokensRaised += tokensToReiceive;\\n        etherRaised += etherUsedWei;\\n        \\n        if(tokensRaised \\u003e= fundingGoal) {\\n            icoCompleted = true;\\n        }\\n       \\n    }\\n   \\n    function finalizeCrowdsale() public onlyOwner {\\n        require(!icoCompleted);\\n        require(icoEndTime \\u003c block.timestamp);\\n        token.burn();\\n        icoCompleted = true;\\n    }\\n    \\n    function extractEther() public onlyOwner {\\n        payable(contractOwner).transfer(address(this).balance);\\n    }\\n}\\n\\n\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extractEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"etherUsedWei\",\"type\":\"uint256\"}],\"name\":\"purchaseTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract PussyRocket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.8.8+commit.dddeac2f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://063ac12045194a1fbcef897ebf47b21c6b66022db260bd331f37cc03f9699581"}]}