{"status":"1","message":"OK","result":[{"SourceCode":"{\"ApproveAndCallFallBack.sol\":{\"content\":\"    //SPDX-License-Identifier: MIT\\n    pragma solidity 0.8.5;\\n\\n\\n\\n    // ----------------------------------------------------------------------------\\n\\n    // Contract function to receive approval and execute function in one call\\n\\n    // Borrowed from MiniMeToken\\n\\n    // ----------------------------------------------------------------------------\\n\\n    abstract contract ApproveAndCallFallBack {\\n\\n        function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public virtual ;\\n\\n    }\\n\\n\"},\"ERC20.sol\":{\"content\":\"    //SPDX-License-Identifier: MIT\\n    pragma solidity 0.8.5;\\n\\n\\n    // ----------------------------------------------------------------------------\\n\\n    // ERC Token Standard #20 Interface\\n\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n\\n    // ----------------------------------------------------------------------------\\n\\n    abstract contract ERC20Interface {\\n\\n        function totalSupply() public view virtual returns (uint);\\n\\n        function balanceOf(address tokenOwner) public view virtual returns (uint balance);\\n\\n        function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);\\n\\n        function transfer(address to, uint tokens) public virtual returns (bool success);\\n\\n        function approve(address spender, uint tokens) public virtual returns (bool success);\\n\\n        function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\\n\\n\\n        event Transfer(address indexed from, address indexed to, uint tokens);\\n\\n        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n\\n    }\\n\\n\\n\"},\"ERC918.sol\":{\"content\":\"    //SPDX-License-Identifier: MIT\\n    pragma solidity 0.8.5;\\n\\n\\n    // ----------------------------------------------------------------------------\\n\\n    // ERC Token Standard #918 Interface\\n\\n    // https://eips.ethereum.org/EIPS/eip-918\\n\\n    // ----------------------------------------------------------------------------\\n\\n    interface ERC918  {\\n\\n        function mint(uint256 nonce) external returns (bool success);\\n\\n        function getAdjustmentInterval() external view returns (uint);\\n\\n        function getChallengeNumber() external view returns (bytes32);\\n\\n        function getMiningDifficulty() external view returns (uint);\\n\\n        function getMiningTarget() external view returns (uint);\\n\\n        function getMiningReward() external view returns (uint);\\n       \\n        function decimals() external view returns (uint8);\\n\\n\\n        event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);\\n    }\"},\"Owned.sol\":{\"content\":\"    //SPDX-License-Identifier: MIT\\n    pragma solidity 0.8.5;\\n\\n\\n\\n    // ----------------------------------------------------------------------------\\n\\n    // Owned contract\\n\\n    // ----------------------------------------------------------------------------\\n\\n    abstract contract Owned {\\n\\n        address public owner;\\n\\n        address public newOwner;\\n\\n\\n        event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n\\n        constructor() {\\n\\n            owner = msg.sender;\\n\\n        }\\n\\n\\n        modifier onlyOwner {\\n\\n            require(msg.sender == owner);\\n\\n            _;\\n\\n        }\\n\\n\\n        function transferOwnership(address _newOwner) public onlyOwner {\\n\\n            require(_newOwner != address(0), \\\"Invalid address\\\");\\n\\n            newOwner = _newOwner;\\n\\n        }\\n\\n        function acceptOwnership() external {\\n\\n            require(msg.sender == newOwner);\\n\\n            emit OwnershipTransferred(owner, newOwner);\\n\\n            owner = newOwner;\\n\\n            newOwner = address(0);\\n\\n        }\\n\\n    }\\n\\n\"},\"SpringToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC918.sol\\\";\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./ApproveAndCallFallBack.sol\\\";\\n\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n// \\u0027Spring Token\\u0027 contract\\n\\n// ERC20 \\u0026 ERC918 Mineable Token using Proof Of Work\\n\\n// Symbol      : SPRING\\n\\n// Name        : Spring Token\\n\\n// Total supply: 33,112,800.00\\n\\n// Decimals    : 18\\n\\n// Initial mining reward: 168\\n\\n// Fraction of total supply released before first halving: 1/5\\n\\n// ----------------------------------------------------------------------------\\n\\n\\n\\n\\n\\ncontract SpringToken is ERC20Interface, ERC918, Owned {\\n\\n    string private constant SYMBOL = \\\"SPRING\\\";\\n\\n    string private constant NAME = \\\"Spring Token\\\";\\n\\n    uint256 public constant TOKEN_IDENTIFIER = 1;\\n\\n    uint8 public constant DECIMALS = 18;\\n\\n    uint256 public constant TOTAL_SUPPLY = 33112800 * 10**18;\\n\\n    uint256 public constant INITIAL_REWARD = 168 * 10**18;\\n\\n    uint256 public constant MAX_REWARDS_AVAILABLE = 72; // no more than 72 rewards per mint\\n\\n    uint256 public constant REWARD_INTERVAL = 600; // rewards every ten minutes on average\\n\\n    uint256 public constant DURATION_OF_FIRST_ERA = (365 * 24 * 60 * 60 * 3) / 4; // 9 months\\n\\n    uint256 public constant DURATION_OF_ERA = 3 * 365 * 24 * 60 * 60; // three years\\n\\n    uint256 public constant MINIMUM_TARGET = 2**16;\\n\\n    uint256 public constant MAXIMUM_TARGET = 2**234;\\n\\n    uint256 public immutable contractCreationTime;\\n\\n    uint256 public lastRewardBlockTime;\\n\\n    uint256 public maxNumberOfRewardsPerMint;\\n\\n    bytes32 private challengeNumber;\\n        \\n    uint256 private miningTarget;\\n\\n    uint256 public tokensMinted;\\n\\n    mapping(address =\\u003e uint256) internal balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal allowed;\\n\\n\\n    constructor() {\\n\\n        miningTarget = MAXIMUM_TARGET / 2**19;\\n\\n        contractCreationTime = block.timestamp;\\n        lastRewardBlockTime = block.timestamp;\\n\\n        maxNumberOfRewardsPerMint = 1;\\n\\n        challengeNumber = _getNewChallengeNumber(0);\\n\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return NAME;\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return SYMBOL;\\n    }\\n\\n    function mint(uint256 nonce) override public returns (bool success) {\\n\\n        uint256 _lastRewardBlockTime = lastRewardBlockTime;\\n        \\n        uint256 singleRewardAmount = _getMiningReward(_lastRewardBlockTime);\\n\\n        // no more minting when reward reaches zero\\n        if (singleRewardAmount == 0) revert(\\\"Reward has reached zero\\\");\\n\\n        // the PoW must contain work that includes the challenge number and the msg.sender\\u0027s address\\n        bytes32 digest =  keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\\n\\n        uint256 _miningTarget = miningTarget;\\n        // the digest must be smaller than the target\\n        if (uint256(digest) \\u003e _miningTarget) revert(\\\"Digest is larger than mining target\\\");\\n\\n        uint256 _previousMaxNumberOfRewards = maxNumberOfRewardsPerMint;\\n        uint256 numberOfRewardsToGive = _numberOfRewardsToGive(_miningTarget / uint256(digest), \\n                                                               _lastRewardBlockTime,\\n                                                               _previousMaxNumberOfRewards,\\n                                                               block.timestamp);\\n        uint256 totalRewardAmount = singleRewardAmount * numberOfRewardsToGive;\\n\\n        uint256 _tokensMinted = _giveRewards(totalRewardAmount);\\n        \\n        _setNextMaxNumberOfRewards(numberOfRewardsToGive, _previousMaxNumberOfRewards);\\n\\n        miningTarget = _adjustDifficulty(_miningTarget, _lastRewardBlockTime,\\n                                         numberOfRewardsToGive, block.timestamp);\\n\\n        bytes32 newChallengeNumber = _getNewChallengeNumber(_tokensMinted);\\n        challengeNumber = newChallengeNumber;\\n\\n        lastRewardBlockTime = block.timestamp;\\n\\n        emit Mint(msg.sender, totalRewardAmount, _scheduledNumberOfRewards(block.timestamp), \\n                  newChallengeNumber);\\n\\n        return true;\\n    }\\n\\n    function _numberOfRewardsAvailable(uint256 _lastRewardBlockTime, \\n                                       uint256 _previousMaxNumberOfRewards, \\n                                       uint256 currentTime) internal pure returns (uint256) {\\n\\n        uint256 numberAvailable = _previousMaxNumberOfRewards;\\n        uint256 intervalsSinceLastReward = (currentTime - _lastRewardBlockTime) / REWARD_INTERVAL;\\n        \\n        if (intervalsSinceLastReward \\u003e numberAvailable)\\n            numberAvailable = intervalsSinceLastReward;\\n\\n        if (numberAvailable \\u003e MAX_REWARDS_AVAILABLE)\\n            numberAvailable = MAX_REWARDS_AVAILABLE;\\n\\n        return numberAvailable;\\n    }\\n\\n    function _numberOfRewardsToGive(uint256 numberEarned, uint256 _lastRewardBlockTime, \\n                                    uint256 _previousMaxNumberOfRewards,\\n                                    uint256 currentTime) internal pure returns (uint256) {\\n\\n        uint256 numberAvailable = _numberOfRewardsAvailable(_lastRewardBlockTime,\\n                                                         _previousMaxNumberOfRewards,\\n                                                         currentTime);\\n        if (numberEarned \\u003c numberAvailable)\\n            return numberEarned;\\n\\n        return numberAvailable;\\n    }\\n\\n    function _giveRewards(uint256 totalReward) internal returns (uint256) {\\n\\n        balances[msg.sender] += totalReward;\\n        uint256 _tokensMinted = tokensMinted + totalReward;\\n        tokensMinted = _tokensMinted;\\n        return _tokensMinted;\\n    }\\n\\n    function _setNextMaxNumberOfRewards(uint256 numberOfRewardsGivenNow, \\n                                        uint256 _previousMaxNumberOfRewards) internal {\\n\\n        // the value of the rewards given to this miner presumably exceed the gas costs\\n        // for processing the transaction. the next miner can submit a proof of enough work\\n        // to claim up to the same number of rewards immediately, or, if gas costs have increased,\\n        // wait until the maximum number of rewards claimable has increased enough to overcome\\n        // the costs.\\n\\n        if (numberOfRewardsGivenNow != _previousMaxNumberOfRewards)\\n            maxNumberOfRewardsPerMint = numberOfRewardsGivenNow;\\n    }\\n\\n    // backwards compatible mint function\\n    function mint(uint256 _nonce, bytes32 _challengeDigest) external returns (bool) {\\n\\n        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, _nonce));\\n        require(digest == _challengeDigest, \\\"Challenge digest does not match expected digest on token contract\\\");\\n        \\n        return mint(_nonce);\\n    }\\n\\n    function _getNewChallengeNumber(uint256 _tokensMinted) internal view returns (bytes32) {\\n        \\n        // make the latest ethereum block hash a part of the next challenge\\n\\n        // xor with a number unique to this token to avoid merged mining\\n        \\n        // xor with the number of tokens minted to ensure that the challenge changes\\n        // even if there are multiple mints in the same ethereum block\\n        \\n        return bytes32(uint256(blockhash(block.number - 1)) ^ _tokensMinted ^ TOKEN_IDENTIFIER);\\n    }\\n\\n\\n    function _scheduledNumberOfRewards(uint256 currentTime) internal view returns (uint256) {\\n        return (currentTime - contractCreationTime) / REWARD_INTERVAL;\\n    }\\n\\n    function _adjustDifficulty(uint256 _miningTarget, \\n                               uint256 _lastRewardBlockTime, \\n                               uint256 rewardsGivenNow,\\n                               uint256 currentTime) internal pure returns (uint256){\\n\\n        uint256 timeSinceLastReward = currentTime - _lastRewardBlockTime;\\n\\n        // we target a median interval of 10 minutes multiplied by log(2) ~ 61/88 \\n        // this gives a mean interval of 10 minutes per reward\\n\\n        if (timeSinceLastReward * 88 \\u003c rewardsGivenNow * REWARD_INTERVAL * 61)\\n            _miningTarget = (_miningTarget * 99) / 100;   // slow down\\n        else\\n            _miningTarget = (_miningTarget * 100) / 99;   // speed up\\n\\n        if (_miningTarget \\u003c MINIMUM_TARGET)\\n            _miningTarget = MINIMUM_TARGET;\\n        \\n        if (_miningTarget \\u003e MAXIMUM_TARGET) \\n            _miningTarget = MAXIMUM_TARGET;\\n\\n        return _miningTarget;\\n    }\\n\\n\\n    function rewardEra(uint256 _time) public view returns (uint256) {\\n\\n        uint256 timeSinceContractCreation = _time - contractCreationTime;\\n\\n        if (timeSinceContractCreation \\u003c DURATION_OF_FIRST_ERA)\\n            return 0;\\n        else\\n            return 1 + (timeSinceContractCreation - DURATION_OF_FIRST_ERA) / DURATION_OF_ERA;\\n    }\\n\\n    function getAdjustmentInterval() public view override returns (uint256) {\\n        return REWARD_INTERVAL * maxNumberOfRewardsPerMint;\\n    }\\n\\n    function getChallengeNumber() public view override returns (bytes32) {\\n        return challengeNumber;\\n    }\\n\\n    function getMiningDifficulty() public view override returns (uint256) {\\n        // 64 f\\u0027s:         1234567890123456789012345678901234567890123456789012345678901234\\n        uint256 maxInt = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n        return maxInt / miningTarget;\\n    }\\n\\n    function getMiningTarget() public view override returns (uint256) {\\n       return miningTarget;\\n   }\\n\\n    function getMiningReward() public view override returns (uint256) {\\n\\n        // use the timestamp of the ethereum block that gave the last reward\\n        // because ethereum miners can manipulate the value of block.timestamp\\n        return _getMiningReward(lastRewardBlockTime);\\n    }\\n\\n    function _getMiningReward(uint256 _time) internal view returns (uint256) {\\n        return INITIAL_REWARD / 2**rewardEra(_time);\\n    }\\n\\n    function getNumberOfRewardsAvailable(uint256 currentTime) external view returns (uint256) {\\n        return _numberOfRewardsAvailable(lastRewardBlockTime, \\n                                         maxNumberOfRewardsPerMint, \\n                                         currentTime);\\n    }\\n\\n    function getRewardAmountForAchievingTarget(uint256 targetAchieved, uint256 currentTime) external view returns (uint256) {\\n        uint256 numberOfRewardsToGive = _numberOfRewardsToGive(miningTarget / targetAchieved, \\n                                                               lastRewardBlockTime, \\n                                                               maxNumberOfRewardsPerMint, \\n                                                               currentTime);\\n        return _getMiningReward(currentTime) * numberOfRewardsToGive;\\n    }\\n\\n    function decimals() public pure override returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n\\n        return tokensMinted;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Get the token balance for account `tokenOwner`\\n\\n    // ------------------------------------------------------------------------\\n\\n    function balanceOf(address tokenOwner) public view override returns (uint256 balance) {\\n\\n        return balances[tokenOwner];\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\n\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n\\n    // - 0 value transfers are allowed\\n\\n    // ------------------------------------------------------------------------\\n\\n    function transfer(address to, uint256 tokens) public override returns (bool success) {\\n        \\n        require(to != address(0) \\u0026\\u0026 to != address(this), \\\"Invalid address\\\");\\n        \\n        balances[msg.sender] = balances[msg.sender] - tokens;\\n\\n        balances[to] = balances[to] + tokens;\\n\\n        emit Transfer(msg.sender, to, tokens);\\n\\n        return true;\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n\\n    // from the token owner\\u0027s account\\n\\n    //\\n\\n    // Warning: This function is vulnerable to double-spend attacks and is\\n\\n    // included for backwards compatibility. Use safeApprove instead.\\n\\n    // ------------------------------------------------------------------------\\n\\n    function approve(address spender, uint256 tokens) public override returns (bool success) {\\n        \\n        require(spender != address(0) \\u0026\\u0026 spender != address(this), \\\"Invalid address\\\");\\n\\n        allowed[msg.sender][spender] = tokens;\\n\\n        emit Approval(msg.sender, spender, tokens);\\n\\n        return true;\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Allow token owner to cancel the approval if the approved amount changes from its last\\n\\n    // known value before this transaction is processed. This allows the owner to avoid \\n\\n    // unintentionally re-approving funds that have already been spent.\\n\\n    // ------------------------------------------------------------------------\\n\\n    function safeApprove(address spender, uint256 previousAllowance, uint256 newAllowance) external returns (bool success) {\\n\\n        require(allowed[msg.sender][spender] == previousAllowance,\\n                \\\"Current spender allowance does not match specified value\\\");\\n\\n        return approve(spender, newAllowance);\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Transfer `tokens` from the `from` account to the `to` account\\n\\n    //\\n\\n    // The calling account must already have sufficient tokens approve(...)-d\\n\\n    // for spending from the `from` account and\\n\\n    // - From account must have sufficient balance to transfer\\n\\n    // - Spender must have sufficient allowance to transfer\\n\\n    // - 0 value transfers are allowed\\n\\n    // ------------------------------------------------------------------------\\n\\n    function transferFrom(address from, address to, uint256 tokens) public override returns (bool success) {\\n        \\n        require(to != address(0) \\u0026\\u0026 to != address(this), \\\"Invalid address\\\");\\n\\n        balances[from] = balances[from] - tokens;\\n\\n        allowed[from][msg.sender] = allowed[from][msg.sender] - tokens;\\n\\n        balances[to] = balances[to] + tokens;\\n\\n        emit Transfer(from, to, tokens);\\n\\n        return true;\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Returns the amount of tokens approved by the owner that can be\\n\\n    // transferred to the spender\\u0027s account\\n\\n    // ------------------------------------------------------------------------\\n\\n    function allowance(address tokenOwner, address spender) public view override returns (uint256 remaining){\\n\\n        return allowed[tokenOwner][spender];\\n\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n\\n    // from the token owner\\u0027s account. The `spender` contract function\\n\\n    // `receiveApproval(...)` is then executed. This is vulnerable to double-spend attacks\\n\\n    // when called directly, so it is declared internal and called by safeApproveAndCall\\n\\n    // ------------------------------------------------------------------------\\n\\n    function approveAndCall(address spender, uint256 tokens, bytes memory data) internal returns (bool success) {\\n        \\n        require(spender != address(0) \\u0026\\u0026 spender != address(this), \\\"Invalid address\\\");\\n\\n        allowed[msg.sender][spender] = tokens;\\n\\n        emit Approval(msg.sender, spender, tokens);\\n\\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\\n\\n        return true;\\n\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Allow safe approvals with calls to receiving contract\\n\\n    // ------------------------------------------------------------------------\\n\\n    function safeApproveAndCall(address spender, uint256 previousAllowance, \\n                                uint256 newAllowance, bytes memory data) external returns (bool success) {\\n\\n        require(allowed[msg.sender][spender] == previousAllowance,\\n                \\\"Current spender allowance does not match specified value\\\");\\n\\n        return approveAndCall(spender, newAllowance, data);\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n\\n    // ------------------------------------------------------------------------\\n\\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens) external onlyOwner returns (bool success) {\\n\\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\\n\\n    }\\n\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DURATION_OF_ERA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DURATION_OF_FIRST_ERA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REWARDS_AVAILABLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_IDENTIFIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractCreationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdjustmentInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengeNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"name\":\"getNumberOfRewardsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetAchieved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"name\":\"getRewardAmountForAchievingTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNumberOfRewardsPerMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_challengeDigest\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"rewardEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"previousAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAllowance\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"previousAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAllowance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeApproveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SpringToken","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5476e7e04aa724315c45e467f3ffc84b5d3ad82e2543f033e539b4d173b2226d"}]}