{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.1\r\n# */3crv pool where 3crv is _second_, not first\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface CurveCryptoSwap:\r\n    def token() -> address: view\r\n    def coins(i: uint256) -> address: view\r\n    def get_dy(i: uint256, j: uint256, dx: uint256) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS]) -> uint256: view\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256: view\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256: nonpayable\r\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256) -> uint256: nonpayable\r\n    def remove_liquidity(amount: uint256, min_amounts: uint256[N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256) -> uint256: nonpayable\r\n    def price_oracle() -> uint256: view\r\n    def price_scale() -> uint256: view\r\n    def lp_price() -> uint256: view\r\n\r\ninterface StableSwap:\r\n    def coins(i: uint256) -> address: view\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_STABLECOINS], is_deposit: bool) -> uint256: view\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n    def add_liquidity(amounts: uint256[N_STABLECOINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def remove_liquidity(amount: uint256, min_amounts: uint256[N_STABLECOINS]): nonpayable\r\n    def get_virtual_price() -> uint256: view\r\n\r\n\r\nN_COINS: constant(int128) = 2\r\nN_STABLECOINS: constant(int128) = 3\r\nN_UL_COINS: constant(int128) = N_COINS + N_STABLECOINS - 1\r\n\r\n# All the following properties can be replaced with constants for gas efficiency\r\n\r\nCOINS: immutable(address[N_COINS])\r\nUNDERLYING_COINS: immutable(address[N_UL_COINS])\r\nPOOL: immutable(address)\r\nBASE_POOL: immutable(address)\r\nTOKEN: immutable(address)\r\n\r\n\r\n@external\r\ndef __init__(pool: address, base_pool: address):\r\n    coins: address[N_COINS] = empty(address[N_COINS])\r\n    ul_coins: address[N_UL_COINS] = empty(address[N_UL_COINS])\r\n    POOL = pool\r\n    BASE_POOL = base_pool\r\n    TOKEN = CurveCryptoSwap(pool).token()\r\n\r\n    for i in range(N_COINS):\r\n        coins[i] = CurveCryptoSwap(pool).coins(i)\r\n    ul_coins[0] = coins[0]\r\n    for i in range(N_UL_COINS - 1):\r\n        ul_coins[i + 1] = StableSwap(base_pool).coins(i)\r\n\r\n    for coin in ul_coins:\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(base_pool, bytes32),\r\n                convert(MAX_UINT256, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    for coin in coins:\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(pool, bytes32),\r\n                convert(MAX_UINT256, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    COINS = coins\r\n    UNDERLYING_COINS = ul_coins\r\n\r\n\r\n@external\r\n@view\r\ndef coins(i: uint256) -> address:\r\n    _coins: address[N_COINS] = COINS\r\n    return _coins[i]\r\n\r\n\r\n@external\r\n@view\r\ndef underlying_coins(i: uint256) -> address:\r\n    _ucoins: address[N_UL_COINS] = UNDERLYING_COINS\r\n    return _ucoins[i]\r\n\r\n\r\n@external\r\n@view\r\ndef pool() -> address:\r\n    return POOL\r\n\r\n\r\n@external\r\n@view\r\ndef base_pool() -> address:\r\n    return BASE_POOL\r\n\r\n\r\n@external\r\n@view\r\ndef token() -> address:\r\n    return TOKEN\r\n\r\n\r\n@external\r\n@view\r\ndef price_oracle() -> uint256:\r\n    usd_tkn: uint256 = CurveCryptoSwap(POOL).price_oracle()\r\n    vprice: uint256 = StableSwap(BASE_POOL).get_virtual_price()\r\n    return vprice * 10**18 / usd_tkn\r\n\r\n\r\n@external\r\n@view\r\ndef price_scale() -> uint256:\r\n    usd_tkn: uint256 = CurveCryptoSwap(POOL).price_scale()\r\n    vprice: uint256 = StableSwap(BASE_POOL).get_virtual_price()\r\n    return vprice * 10**18 / usd_tkn\r\n\r\n\r\n@external\r\n@view\r\ndef lp_price() -> uint256:\r\n    p: uint256 = CurveCryptoSwap(POOL).lp_price()  # price in tkn\r\n    usd_tkn: uint256 = CurveCryptoSwap(POOL).price_oracle()\r\n    vprice: uint256 = StableSwap(BASE_POOL).get_virtual_price()\r\n    return p * vprice / usd_tkn\r\n\r\n\r\n@external\r\ndef add_liquidity(_amounts: uint256[N_UL_COINS], _min_mint_amount: uint256, _receiver: address = msg.sender):\r\n    base_deposit_amounts: uint256[N_STABLECOINS] = empty(uint256[N_STABLECOINS])\r\n    deposit_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    is_base_deposit: bool = False\r\n    coins: address[N_COINS] = COINS\r\n    underlying_coins: address[N_UL_COINS] = UNDERLYING_COINS\r\n\r\n    # transfer base pool coins from caller and deposit to get LP tokens\r\n    for i in range(N_UL_COINS - N_STABLECOINS, N_UL_COINS):\r\n        amount: uint256 = _amounts[i]\r\n        if amount != 0:\r\n            coin: address = underlying_coins[i]\r\n            # transfer underlying coin from msg.sender to self\r\n            _response: Bytes[32] = raw_call(\r\n                coin,\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(msg.sender, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(amount, bytes32)\r\n                ),\r\n                max_outsize=32\r\n            )\r\n            if len(_response) != 0:\r\n                assert convert(_response, bool)\r\n            base_deposit_amounts[i - (N_COINS - 1)] = ERC20(coin).balanceOf(self)\r\n            is_base_deposit = True\r\n\r\n    if is_base_deposit:\r\n        StableSwap(BASE_POOL).add_liquidity(base_deposit_amounts, 0)\r\n        deposit_amounts[N_COINS - 1] = ERC20(coins[N_COINS-1]).balanceOf(self)\r\n\r\n    # transfer remaining underlying coins\r\n    for i in range(N_COINS - 1):\r\n        amount: uint256 = _amounts[i]\r\n        if amount != 0:\r\n            coin: address = underlying_coins[i]\r\n            # transfer underlying coin from msg.sender to self\r\n            _response: Bytes[32] = raw_call(\r\n                coin,\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(msg.sender, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(amount, bytes32)\r\n                ),\r\n                max_outsize=32\r\n            )\r\n            if len(_response) != 0:\r\n                assert convert(_response, bool)\r\n\r\n            deposit_amounts[i] = amount\r\n\r\n    amount: uint256 = CurveCryptoSwap(POOL).add_liquidity(deposit_amounts, _min_mint_amount)\r\n    ERC20(TOKEN).transfer(_receiver, amount)\r\n\r\n\r\n@external\r\ndef exchange_underlying(i: uint256, j: uint256, _dx: uint256, _min_dy: uint256, _receiver: address = msg.sender) -> uint256:\r\n    assert i != j  # dev: coins must be different\r\n    coins: address[N_COINS] = COINS\r\n    underlying_coins: address[N_UL_COINS] = UNDERLYING_COINS\r\n\r\n    # transfer `i` from caller into the zap\r\n    response: Bytes[32] = raw_call(\r\n        underlying_coins[i],\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(msg.sender, bytes32),\r\n            convert(self, bytes32),\r\n            convert(_dx, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    dx: uint256 = _dx\r\n    outer_i: uint256 = min(i, N_COINS - 1)\r\n    outer_j: uint256 = min(j, N_COINS - 1)\r\n\r\n    if i >= N_COINS - 1:\r\n        # if `i` is in the base pool, deposit to get LP tokens\r\n        base_deposit_amounts: uint256[N_STABLECOINS] = empty(uint256[N_STABLECOINS])\r\n        base_deposit_amounts[i - (N_COINS - 1)] = dx\r\n        StableSwap(BASE_POOL).add_liquidity(base_deposit_amounts, 0)\r\n        dx = ERC20(coins[N_COINS-1]).balanceOf(self)\r\n\r\n    # perform the exchange\r\n    amount: uint256 = dx\r\n    if outer_i != outer_j:\r\n        amount = CurveCryptoSwap(POOL).exchange(outer_i, outer_j, dx, 0)\r\n\r\n    if outer_j == N_COINS - 1:\r\n        # if `j` is in the base pool, withdraw the desired underlying asset and transfer to caller\r\n        StableSwap(BASE_POOL).remove_liquidity_one_coin(amount, convert(j - (N_COINS - 1), int128), _min_dy)\r\n        amount = ERC20(underlying_coins[j]).balanceOf(self)\r\n    else:\r\n        # withdraw `j` underlying from lending pool and transfer to caller\r\n        assert amount >= _min_dy\r\n\r\n    response = raw_call(\r\n        underlying_coins[j],\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_receiver, bytes32),\r\n            convert(amount, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    return amount\r\n\r\n\r\n@external\r\ndef remove_liquidity(_amount: uint256, _min_amounts: uint256[N_UL_COINS], _receiver: address = msg.sender):\r\n    underlying_coins: address[N_UL_COINS] = UNDERLYING_COINS\r\n\r\n    # transfer LP token from caller and remove liquidity\r\n    ERC20(TOKEN).transferFrom(msg.sender, self, _amount)\r\n    min_amounts: uint256[N_COINS] = [_min_amounts[0], 0]\r\n    CurveCryptoSwap(POOL).remove_liquidity(_amount, min_amounts)\r\n\r\n    # withdraw from base pool and transfer underlying assets to receiver\r\n    value: uint256 = ERC20(COINS[1]).balanceOf(self)\r\n    base_min_amounts: uint256[N_STABLECOINS] = [_min_amounts[1], _min_amounts[2], _min_amounts[3]]\r\n    StableSwap(BASE_POOL).remove_liquidity(value, base_min_amounts)\r\n    for i in range(N_UL_COINS):\r\n        value = ERC20(underlying_coins[i]).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            underlying_coins[i],\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(_receiver, bytes32),\r\n                convert(value, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n\r\n@external\r\ndef remove_liquidity_one_coin(_token_amount: uint256, i: uint256, _min_amount: uint256, _receiver: address = msg.sender):\r\n    underlying_coins: address[N_UL_COINS] = UNDERLYING_COINS\r\n\r\n    ERC20(TOKEN).transferFrom(msg.sender, self, _token_amount)\r\n    outer_i: uint256 = min(i, N_COINS - 1)\r\n    value: uint256 = CurveCryptoSwap(POOL).remove_liquidity_one_coin(_token_amount, outer_i, 0)\r\n\r\n    if outer_i == N_COINS - 1:\r\n        StableSwap(BASE_POOL).remove_liquidity_one_coin(value, convert(i - (N_COINS - 1), int128), _min_amount)\r\n        value = ERC20(underlying_coins[i]).balanceOf(self)\r\n    else:\r\n        assert value >= _min_amount\r\n    response: Bytes[32] = raw_call(\r\n        underlying_coins[i],\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_receiver, bytes32),\r\n            convert(value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy_underlying(i: uint256, j: uint256, _dx: uint256) -> uint256:\r\n    if min(i, j) >= N_COINS - 1:\r\n        return StableSwap(BASE_POOL).get_dy(convert(i - (N_COINS-1), int128), convert(j - (N_COINS-1), int128), _dx)\r\n\r\n    dx: uint256 = _dx\r\n    outer_i: uint256 = min(i, N_COINS - 1)\r\n    outer_j: uint256 = min(j, N_COINS - 1)\r\n\r\n    if outer_i == N_COINS-1:\r\n        amounts: uint256[N_STABLECOINS] = empty(uint256[N_STABLECOINS])\r\n        amounts[i - (N_COINS-1)] = dx\r\n        dx = StableSwap(BASE_POOL).calc_token_amount(amounts, True)\r\n\r\n    dy: uint256 = CurveCryptoSwap(POOL).get_dy(outer_i, outer_j, dx)\r\n    if outer_j == N_COINS-1:\r\n        return StableSwap(BASE_POOL).calc_withdraw_one_coin(dy, convert(j - (N_COINS-1), int128))\r\n    else:\r\n        return dy\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(_amounts: uint256[N_UL_COINS]) -> uint256:\r\n    base_amounts: uint256[N_STABLECOINS] = [_amounts[1], _amounts[2], _amounts[3]]\r\n    base_lp: uint256 = 0\r\n    if _amounts[1] + _amounts[2] + _amounts[3] > 0:\r\n        base_lp = StableSwap(BASE_POOL).calc_token_amount(base_amounts, True)\r\n    amounts: uint256[N_COINS] = [_amounts[0], base_lp]\r\n    return CurveCryptoSwap(POOL).calc_token_amount(amounts)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256:\r\n    if i < N_COINS-1:\r\n        return CurveCryptoSwap(POOL).calc_withdraw_one_coin(token_amount, i)\r\n\r\n    base_amount: uint256 = CurveCryptoSwap(POOL).calc_withdraw_one_coin(token_amount, N_COINS-1)\r\n    return StableSwap(BASE_POOL).calc_withdraw_one_coin(base_amount, convert(i - (N_COINS-1), int128))","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\"},{\"name\":\"base_pool\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"underlying_coins\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"base_pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_scale\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[4]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.1","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000adcfcf9894335dc340f6cd182afa45999f45fc44000000000000000000000000bebc44782c7db0a1a60cb6fe97d0b483032ff1c7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}