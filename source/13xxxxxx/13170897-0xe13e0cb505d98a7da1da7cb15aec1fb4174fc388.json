{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC721.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n//SPDX-License-Identifier: UNLICENSED\\n\\n/*\\n\\t_____                       _   _             _____    _\\n\\t|  __ \\\\                     | | | |           |  __ \\\\  (_)\\n\\t| |  | |   ___    __ _    __| | | |  _   _    | |__) |  _   _ __     __ _   ___\\n\\t| |  | |  / _ \\\\  / _` |  / _` | | | | | | |   |  _  /  | | | \\u0027_ \\\\   / _` | / __|\\n\\t| |__| | |  __/ | (_| | | (_| | | | | |_| |   | | \\\\ \\\\  | | | | | | | (_| | \\\\__ \\\\\\n\\t|_____/   \\\\___|  \\\\__,_|  \\\\__,_| |_|  \\\\__, |   |_|  \\\\_\\\\ |_| |_| |_|  \\\\__, | |___/\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  __/ |\\t\\t\\t\\t\\t\\t\\t __/ |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/\\t\\t\\t\\t\\t\\t \\t |___/\\n*/\\n\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address payable) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\n\\tfunction _msgData() internal view virtual returns (bytes memory) {\\n\\t\\tthis;\\n\\t\\treturn msg.data;\\n\\t}\\n}\\n\\nlibrary Base64 {\\n\\tbytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n\\tfunction encode(bytes memory data) internal pure returns (string memory) {\\n\\t\\tuint256 len = data.length;\\n\\t\\tif (len == 0) return \\\"\\\";\\n\\n\\t\\tuint256 encodedLen = 4 * ((len + 2) / 3);\\n\\t\\tbytes memory result = new bytes(encodedLen + 32);\\n\\t\\tbytes memory table = TABLE;\\n\\n\\t\\tassembly {\\n\\t\\t\\tlet tablePtr := add(table, 1)\\n\\t\\t\\tlet resultPtr := add(result, 32)\\n\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tlet i := 0\\n\\t\\t\\t} lt(i, len) {\\n\\n\\t\\t\\t} {\\n\\t\\t\\t\\ti := add(i, 3)\\n\\t\\t\\t\\tlet input := and(mload(add(data, i)), 0xffffff)\\n\\n\\t\\t\\t\\tlet out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(224, out)\\n\\n\\t\\t\\t\\tmstore(resultPtr, out)\\n\\n\\t\\t\\t\\tresultPtr := add(resultPtr, 4)\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch mod(len, 3)\\n\\t\\t\\tcase 1 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n\\t\\t\\t}\\n\\t\\t\\tcase 2 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 1), shl(248, 0x3d))\\n\\t\\t\\t}\\n\\n\\t\\t\\tmstore(result, encodedLen)\\n\\t\\t}\\n\\n\\t\\treturn string(result);\\n\\t}\\n}\\n\\nabstract contract Ownable is Context {\\n\\taddress private _owner;\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\tconstructor () internal {\\n\\t\\taddress msgSender = _msgSender();\\n\\t\\t_owner = msgSender;\\n\\t\\temit OwnershipTransferred(address(0), msgSender);\\n\\t}\\n\\n\\tfunction owner() public view virtual returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\n\\t\\temit OwnershipTransferred(_owner, address(0));\\n\\t\\t_owner = address(0);\\n\\t}\\n\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n\\t\\temit OwnershipTransferred(_owner, newOwner);\\n\\t\\t_owner = newOwner;\\n\\t}\\n}\\n\\nabstract contract ReentrancyGuard {\\n\\tuint256 private constant _NOT_ENTERED = 1;\\n\\tuint256 private constant _ENTERED = 2;\\n\\tuint256 private _status;\\n\\n\\tconstructor() {\\n\\t\\t_status = _NOT_ENTERED;\\n\\t}\\n\\n\\tmodifier nonReentrant() {\\n\\t\\trequire(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\t\\t_status = _ENTERED;\\n\\t\\t_;\\n\\t\\t_status = _NOT_ENTERED;\\n\\t}\\n}\\n\\ninterface IERC721Receiver {\\n\\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\\nlibrary Strings {\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++; // 41\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\tuint256 index = digits - 1;\\n\\t\\ttemp = value;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tbuffer[index--] = bytes1(uint8(48 + temp % 10)); //\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n}\\n\\nlibrary EnumerableMap {\\n\\tstruct MapEntry {\\n\\t\\tbytes32 _key;\\n\\t\\tbytes32 _value;\\n\\t}\\n\\n\\tstruct Map {\\n\\t\\tMapEntry[] _entries;\\n\\t\\tmapping (bytes32 =\\u003e uint256) _indexes;\\n\\t}\\n\\n\\tfunction _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\tif (keyIndex == 0) {\\n\\t\\t\\tmap._entries.push(MapEntry({ _key: key, _value: value }));\\n\\t\\t\\tmap._indexes[key] = map._entries.length; // 3f\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tmap._entries[keyIndex - 1]._value = value;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _remove(Map storage map, bytes32 key) private returns (bool) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\tif (keyIndex != 0) {\\n\\t\\t\\tuint256 toDeleteIndex = keyIndex - 1;\\n\\t\\t\\tuint256 lastIndex = map._entries.length - 1;\\n\\t\\t\\tMapEntry storage lastEntry = map._entries[lastIndex]; //\\n\\t\\t\\tmap._entries[toDeleteIndex] = lastEntry;\\n\\t\\t\\tmap._indexes[lastEntry._key] = toDeleteIndex + 1;\\n\\t\\t\\tmap._entries.pop();\\n\\t\\t\\tdelete map._indexes[key];\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _contains(Map storage map, bytes32 key) private view returns (bool) {\\n\\t\\treturn map._indexes[key] != 0;\\n\\t}\\n\\n\\tfunction _length(Map storage map) private view returns (uint256) {\\n\\t\\treturn map._entries.length;\\n\\t}\\n\\n\\tfunction _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n\\t\\trequire(map._entries.length \\u003e index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n\\t\\tMapEntry storage entry = map._entries[index];\\n\\t\\treturn (entry._key, entry._value);\\n\\t}\\n\\n\\tfunction _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\tif (keyIndex == 0) return (false, 0);\\n\\t\\treturn (true, map._entries[keyIndex - 1]._value);\\n\\t}\\n\\n\\tfunction _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\trequire(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\"); //\\n\\t\\treturn map._entries[keyIndex - 1]._value;\\n\\t}\\n\\n\\tfunction _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\trequire(keyIndex != 0, errorMessage);\\n\\t\\treturn map._entries[keyIndex - 1]._value;\\n\\t}\\n\\n\\tstruct UintToAddressMap {\\n\\t\\tMap _inner;\\n\\t}\\n\\n\\tfunction set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n\\t\\treturn _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n\\t\\treturn _remove(map._inner, bytes32(key));\\n\\t}\\n\\n\\tfunction contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n\\t\\treturn _contains(map._inner, bytes32(key));\\n\\t}\\n\\n\\tfunction length(UintToAddressMap storage map) internal view returns (uint256) {\\n\\t\\treturn _length(map._inner);\\n\\t}\\n\\n\\tfunction at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n\\t\\t(bytes32 key, bytes32 value) = _at(map._inner, index);\\n\\t\\treturn (uint256(key), address(uint160(uint256(value))));\\n\\t}\\n\\n\\tfunction tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n\\t\\t(bool success, bytes32 value) = _tryGet(map._inner, bytes32(key)); //\\n\\t\\treturn (success, address(uint160(uint256(value))));\\n\\t}\\n\\n\\tfunction get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n\\t}\\n\\n\\tfunction get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n\\t}\\n}\\n\\nlibrary EnumerableSet {\\n\\tstruct Set {\\n\\t\\tbytes32[] _values;\\n\\t\\tmapping (bytes32 =\\u003e uint256) _indexes;\\n\\t}\\n\\n\\tfunction _add(Set storage set, bytes32 value) private returns (bool) {\\n\\t\\tif (!_contains(set, value)) {\\n\\t\\t\\tset._values.push(value);\\n\\t\\t\\tset._indexes[value] = set._values.length; //\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _remove(Set storage set, bytes32 value) private returns (bool) {\\n\\t\\tuint256 valueIndex = set._indexes[value];\\n\\t\\tif (valueIndex != 0) {\\n\\t\\t\\tuint256 toDeleteIndex = valueIndex - 1;\\n\\t\\t\\tuint256 lastIndex = set._values.length - 1;\\n\\t\\t\\tbytes32 lastvalue = set._values[lastIndex];\\n\\t\\t\\tset._values[toDeleteIndex] = lastvalue;\\n\\t\\t\\tset._indexes[lastvalue] = toDeleteIndex + 1;\\n\\t\\t\\tset._values.pop();\\n\\t\\t\\tdelete set._indexes[value]; // 6e\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\\n\\t\\treturn set._indexes[value] != 0;\\n\\t}\\n\\n\\tfunction _length(Set storage set) private view returns (uint256) {\\n\\t\\treturn set._values.length;\\n\\t}\\n\\n\\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\\n\\t\\trequire(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\"); //\\n\\t\\treturn set._values[index];\\n\\t}\\n\\n\\tstruct Bytes32Set {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, value);\\n\\t}\\n\\n\\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, value);\\n\\t}\\n\\n\\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, value);\\n\\t}\\n\\n\\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n\\t\\treturn _at(set._inner, index); //\\n\\t}\\n\\n\\tstruct AddressSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction add(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction length(AddressSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_at(set._inner, index)))); // 21\\n\\t}\\n\\n\\tstruct UintSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction length(UintSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n\\t\\treturn uint256(_at(set._inner, index)); //\\n\\t}\\n}\\n\\nlibrary Address {\\n\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\tuint256 size;\\n\\t\\tassembly { size := extcodesize(account) }\\n\\t\\treturn size \\u003e 0;\\n\\t}\\n\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\n\\t\\trequire(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\t\\t(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n\\t\\trequire(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, 0, errorMessage);\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\"); //\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\trequire(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\n\\t\\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n\\t\\treturn functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n\\t}\\n\\n\\tfunction functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\t\\t(bool success, bytes memory returndata) = target.staticcall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n\\t}\\n\\n\\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: delegate call to non-contract\\\"); //\\n\\t\\t(bool success, bytes memory returndata) = target.delegatecall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n\\t\\tif (success) {\\n\\t\\t\\treturn returndata;\\n\\t\\t} else {\\n\\t\\t\\tif (returndata.length \\u003e 0) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(errorMessage);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nlibrary SafeMath {\\n\\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\tif (c \\u003c a) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b \\u003e a) return (false, 0); //\\n\\t\\treturn (true, a - b);\\n\\t}\\n\\n\\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (a == 0) return (true, 0);\\n\\t\\tuint256 c = a * b;\\n\\t\\tif (c / a != b) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a / b);\\n\\t}\\n\\n\\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a % b);\\n\\t}\\n\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tif (a == 0) return 0;\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: division by zero\\\"); //\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n\\t\\treturn a % b;\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, errorMessage);\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\\ninterface IERC165 {\\n\\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n\\tbytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7; // 61\\n\\tmapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n\\tconstructor () internal {\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC165); //\\n\\t}\\n\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n\\t\\treturn _supportedInterfaces[interfaceId];\\n\\t}\\n\\n\\tfunction _registerInterface(bytes4 interfaceId) internal virtual {\\n\\t\\trequire(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\"); // 3b\\n\\t\\t_supportedInterfaces[interfaceId] = true;\\n\\t}\\n}\\n\\ninterface IERC721 is IERC165 {\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint256 balance);\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\tfunction transferFrom(address from, address to, uint256 tokenId) external;\\n\\tfunction approve(address to, uint256 tokenId) external;\\n\\tfunction getApproved(uint256 tokenId) external view returns (address operator);\\n\\tfunction setApprovalForAll(address operator, bool _approved) external;\\n\\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\\ninterface IERC721Enumerable is IERC721 {\\n\\tfunction totalSupply() external view returns (uint256);\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\tfunction tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\\ninterface IERC721Metadata is IERC721 {\\n\\tfunction name() external view returns (string memory);\\n\\tfunction symbol() external view returns (string memory);\\n\\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface RingsContract {\\n\\tfunction NRHM(uint256) external;\\n}\\n\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n\\tusing SafeMath for uint256;\\n\\tusing Address for address;\\n\\tusing EnumerableSet for EnumerableSet.UintSet;\\n\\tusing EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\tusing Strings for uint256;\\n\\n\\tbytes4 private constant _ERC721_RECEIVED = 0x150b7a02; // 72\\n\\tmapping (address =\\u003e EnumerableSet.UintSet) private _holderTokens;\\n\\tEnumerableMap.UintToAddressMap private _tokenOwners;\\n\\tmapping (uint256 =\\u003e address) private _tokenApprovals;\\n\\tmapping (address =\\u003e mapping (address =\\u003e bool)) private _operatorApprovals;\\n\\tstring private _name;\\n\\tstring private _symbol;\\n\\tmapping (uint256 =\\u003e string) private _tokenURIs;\\n\\tstring private _baseURI;\\n\\tbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\tbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\tbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63; // 5e\\n\\tconstructor (string memory name_, string memory symbol_) public {\\n\\t\\t_name = name_;\\n\\t\\t_symbol = symbol_;\\n\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721);\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n\\t}\\n\\n\\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\\n\\t\\trequire(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\t\\treturn _holderTokens[owner].length();\\n\\t}\\n\\n\\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n\\t\\treturn _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\"); //\\n\\t}\\n\\n\\tfunction name() public view virtual override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\tfunction symbol() public view virtual override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\t\\tstring memory _tokenURI = _tokenURIs[tokenId];\\n\\t\\tstring memory base = baseURI();\\n\\t\\tif (bytes(base).length == 0) {\\n\\t\\t\\treturn _tokenURI;\\n\\t\\t}\\n\\t\\tif (bytes(_tokenURI).length \\u003e 0) {\\n\\t\\t\\treturn string(abi.encodePacked(base, _tokenURI));\\n\\t\\t}\\n\\t\\treturn string(abi.encodePacked(base, tokenId.toString()));\\n\\t}\\n\\n\\tfunction baseURI() public view virtual returns (string memory) {\\n\\t\\treturn _baseURI;\\n\\t}\\n\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n\\t\\treturn _holderTokens[owner].at(index);\\n\\t}\\n\\n\\tfunction totalSupply() public view virtual override returns (uint256) {\\n\\t\\treturn _tokenOwners.length();\\n\\t}\\n\\n\\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n\\t\\t(uint256 tokenId, ) = _tokenOwners.at(index);\\n\\t\\treturn tokenId;\\n\\t}\\n\\n\\tfunction approve(address to, uint256 tokenId) public virtual override {\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\trequire(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\t\\trequire(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n\\t\\t\\t\\\"ERC721: approve caller is not owner nor approved for all\\\"\\n\\t\\t);\\n\\t\\t_approve(to, tokenId);\\n\\t}\\n\\n\\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\"); //\\n\\t\\treturn _tokenApprovals[tokenId];\\n\\t}\\n\\n\\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\\n\\t\\trequire(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\t\\t_operatorApprovals[_msgSender()][operator] = approved;\\n\\t\\temit ApprovalForAll(_msgSender(), operator, approved);\\n\\t}\\n\\n\\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n\\t\\treturn _operatorApprovals[owner][operator];\\n\\t}\\n\\n\\tfunction transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\"); //\\n\\t\\t_transfer(from, to, tokenId);\\n\\t}\\n\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n\\t\\tsafeTransferFrom(from, to, tokenId, \\\"\\\");\\n\\t}\\n\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\t\\t_safeTransfer(from, to, tokenId, _data);\\n\\t}\\n\\n\\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n\\t\\t_transfer(from, to, tokenId);\\n\\t\\trequire(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t}\\n\\n\\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\\n\\t\\treturn _tokenOwners.contains(tokenId);\\n\\t}\\n\\n\\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\"); //\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\treturn (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n\\t}\\n\\n\\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\\n\\t\\t_safeMint(to, tokenId, \\\"\\\");\\n\\t}\\n\\n\\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n\\t\\t_mint(to, tokenId);\\n\\t\\trequire(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t}\\n\\n\\tfunction _mint(address to, uint256 tokenId) internal virtual {\\n\\t\\trequire(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n\\t\\trequire(!_exists(tokenId), \\\"ERC721: token already minted\\\"); //\\n\\t\\t_beforeTokenTransfer(address(0), to, tokenId);\\n\\t\\t_holderTokens[to].add(tokenId);\\n\\t\\t_tokenOwners.set(tokenId, to);\\n\\t\\temit Transfer(address(0), to, tokenId);\\n\\t}\\n\\n\\tfunction _burn(uint256 tokenId) internal virtual {\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\t_beforeTokenTransfer(owner, address(0), tokenId);\\n\\t\\t_approve(address(0), tokenId);\\n\\t\\tif (bytes(_tokenURIs[tokenId]).length != 0) {\\n\\t\\t\\tdelete _tokenURIs[tokenId];\\n\\t\\t}\\n\\t\\t_holderTokens[owner].remove(tokenId);\\n\\t\\t_tokenOwners.remove(tokenId);\\n\\t\\temit Transfer(owner, address(0), tokenId);\\n\\t}\\n\\n\\tfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\\n\\t\\trequire(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\"); //\\n\\t\\trequire(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\t\\t_beforeTokenTransfer(from, to, tokenId);\\n\\t\\t_approve(address(0), tokenId);\\n\\t\\t_holderTokens[from].remove(tokenId);\\n\\t\\t_holderTokens[to].add(tokenId);\\n\\t\\t_tokenOwners.set(tokenId, to);\\n\\t\\tRingsContract(address(this)).NRHM(tokenId);\\n\\t\\temit Transfer(from, to, tokenId);\\n\\t}\\n\\n\\tfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n\\t\\t_tokenURIs[tokenId] = _tokenURI;\\n\\t}\\n\\n\\tfunction _setBaseURI(string memory baseURI_) internal virtual {\\n\\t\\t_baseURI = baseURI_;\\n\\t}\\n\\n\\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n\\tprivate returns (bool)\\n\\t{\\n\\t\\tif (!to.isContract()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n\\t\\t\\t\\tIERC721Receiver(to).onERC721Received.selector,\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\ttokenId,\\n\\t\\t\\t\\t_data\\n\\t\\t\\t), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t\\tbytes4 retval = abi.decode(returndata, (bytes4));\\n\\t\\treturn (retval == _ERC721_RECEIVED); // 7a\\n\\t}\\n\\n\\tfunction _approve(address to, uint256 tokenId) internal virtual {\\n\\t\\t_tokenApprovals[tokenId] = to;\\n\\t\\temit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n\\t}\\n\\n\\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\"},\"Rings.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n//SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"./ERC721.sol\\\";\\n\\n/*\\n\\t_____                       _   _             _____    _\\n\\t|  __ \\\\                     | | | |           |  __ \\\\  (_)\\n\\t| |  | |   ___    __ _    __| | | |  _   _    | |__) |  _   _ __     __ _   ___\\n\\t| |  | |  / _ \\\\  / _` |  / _` | | | | | | |   |  _  /  | | | \\u0027_ \\\\   / _` | / __|\\n\\t| |__| | |  __/ | (_| | | (_| | | | | |_| |   | | \\\\ \\\\  | | | | | | | (_| | \\\\__ \\\\\\n\\t|_____/   \\\\___|  \\\\__,_|  \\\\__,_| |_|  \\\\__, |   |_|  \\\\_\\\\ |_| |_| |_|  \\\\__, | |___/\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  __/ |\\t\\t\\t\\t\\t\\t\\t __/ |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/\\t\\t\\t\\t\\t\\t \\t |___/\\n*/\\n\\ncontract DeadlyRings is ERC721, ReentrancyGuard, Ownable {\\n\\tmapping(uint256 =\\u003e Ring) public Rings;\\n\\tconstructor() ERC721(\\\"The Seven Deadly Rings\\\", \\\"Deadly Ring\\\") {\\n\\n\\t/*\\n\\t  _____  _           ___   _       _              ___  _\\n\\t |_   _|| |_   ___  |   \\\\ (_)__ __(_) _ _   ___  | _ \\\\(_) _ _   __ _\\n\\t   | |  | \\u0027 \\\\ / -_) | |) || |\\\\ V /| || \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` |\\n\\t   |_|  |_||_|\\\\___| |___/ |_| \\\\_/ |_||_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   |___/\\n\\t*/\\n\\t\\tRing memory TheDivineRing;\\n\\t\\tTheDivineRing.Name = \\\"Divine Ring\\\";\\n\\t\\tTheDivineRing.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Divine.gif\\\";\\n\\t\\tTheDivineRing.Lore = \\\"The Seven Deadly Rings hold the power of the Great Kings. In my duty to preserve history, I have also resurrected their overwhelming might into this world. To keep those in check, I shall create the Divine Ring, the one to rule them all. This ring is not made out of Adventurer\\u0027s Gold, but from the sacrifice of a Divine being. Only by burning a Divine Robe for eternity can The Divine Ring be created.\\\";\\n\\t\\tTheDivineRing.Active = true;\\n\\t\\tTheDivineRing.Forged = false;\\n\\t\\tTheDivineRing.Holder = \\\"\\\";\\n\\t\\tRings[0] = TheDivineRing;\\n\\n\\t/*\\n\\t  _____  _           ___  _                     __   _              _\\n\\t |_   _|| |_   ___  | _ \\\\(_) _ _   __ _   ___  / _| | |   _  _  ___| |_\\n\\t   | |  | \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` | / _ \\\\|  _| | |__| || |(_-\\u003c|  _|\\n\\t   |_|  |_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, | \\\\___/|_|   |____|\\\\_,_|/__/ \\\\__|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/\\n\\t*/\\n\\t\\tRing memory TheRingOfLust;\\n\\t\\tTheRingOfLust.Name = \\\"Ring of Lust\\\";\\n\\t\\tTheRingOfLust.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Lust.gif\\\";\\n\\t\\tTheRingOfLust.Lore = \\\"Folks should all be aware of the legend of Demon Queen Virgith, Brooding Mother of all the demonkin. A unique being born with the ability to spawn swarms of powerful children by stealing the seeds of other species. It is said that nowadays, every single being in the Demon Realm come from her lineage. But the demons have not always lived secluded in their own plane of existence. Virgith used to wander around the world, gathering the life force of all different species. As she would use it to spawn more children, her army grew more powerful, up to the point where kingdoms could not ignore her anymore. Before she grew too strong, the Coalition banished her and her children to the Demon Realm, where there would be to males to seduce, thwarting her plan to overtake the Chain. Unable to live without sustenance, she withered to her death. Her horns I collected, and out of it, as a memento of her Sin, I shall forge the Ring of Lust.\\\";\\n\\t\\tTheRingOfLust.Active = true;\\n\\t\\tTheRingOfLust.Forged = false;\\n\\t\\tTheRingOfLust.Holder = \\\"\\\";\\n\\t\\tRings[1] = TheRingOfLust;\\n\\n\\t/*\\n\\t  _____  _           ___  _                     __    ___  _        _    _\\n\\t |_   _|| |_   ___  | _ \\\\(_) _ _   __ _   ___  / _|  / __|| | _  _ | |_ | |_  ___  _ _  _  _\\n\\t   | |  | \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` | / _ \\\\|  _| | (_ || || || ||  _||  _|/ _ \\\\| \\u0027 \\\\| || |\\n\\t   |_|  |_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, | \\\\___/|_|    \\\\___||_| \\\\_,_| \\\\__| \\\\__|\\\\___/|_||_|\\\\_, |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/                                                 |__/\\n\\t*/\\n\\t\\tRing memory TheRingOfGluttony;\\n\\t\\tTheRingOfGluttony.Name = \\\"Ring of Gluttony\\\";\\n\\t\\tTheRingOfGluttony.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Gluttony.gif\\\";\\n\\t\\tTheRingOfGluttony.Lore = \\\"The Southern Canal, the Celestial Pillar, the Northen Wall.. as many iconic constructions led by Reinod the Builder, king of the dwarves. A ruler with all the quality of the dwarves: skilled, bold, hard worker, just. But like all dwarves, Reinod has always been incapable of magic. Upset that even mere humans were able to do what he never could, he crossed the Four Seas to put his hand on the forbidden Fruit of the Glyphes. Legends say that eating it would give its owner tremendous magic power, no matter what race they belong to. Little did he know that the fruit came with a terrible curse. At the price of his newly found power, Reinod became unable to swim. On his way back to his expedition, he dived off his ship to save a crewmate who fell overboard. They both drowned. The remains of his last meal I have collected, and out of it, as a memento of his Sin, I shall forge the Ring of Gluttony.\\\";\\n\\t\\tTheRingOfGluttony.Active = true;\\n\\t\\tTheRingOfGluttony.Forged = false;\\n\\t\\tTheRingOfGluttony.Holder = \\\"\\\";\\n\\t\\tRings[2] = TheRingOfGluttony;\\n\\n\\t/*\\n\\t  _____  _           ___  _                     __    ___                    _\\n\\t |_   _|| |_   ___  | _ \\\\(_) _ _   __ _   ___  / _|  / __| _ _  ___  ___  __| |\\n\\t   | |  | \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` | / _ \\\\|  _| | (_ || \\u0027_|/ -_)/ -_)/ _` |\\n\\t   |_|  |_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, | \\\\___/|_|    \\\\___||_|  \\\\___|\\\\___|\\\\__,_|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/\\n\\t*/\\n\\t\\tRing memory TheRingOfGreed;\\n\\t\\tTheRingOfGreed.Name = \\\"Ring of Greed\\\";\\n\\t\\tTheRingOfGreed.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Greed.gif\\\";\\n\\t\\tTheRingOfGreed.Lore = \\\"From the other races\\u0027 perspective, never has the human Kingdom thrived as much as under King Gallien, the Cunning\\u0027s reign. Charisma, military power, and a brilliant mind, as many blessings that allowed him to do what no king ever achieved before: rallying under his banner all of humankind\\u0027s settlements. After years of conquest, his novel a revolutionary monetary policy allowed the newly founded realm to experience economic growth never seen before. Reducing the adventurer\\u0027s gold ratio of the national currency to zero ounces per coin, he found a way to supercharge activity at will: by emitting more coins, he realized that the population\\u0027s response would be to consume and produce more goods almost instantly. After years of prosperity, Gallien would not stop emitting currency. But what he failed to realize was that the prosperity he was creating was, without fail, ultimately ending up in the hands of the long wealthy folks. The inevitable happened: struggling, the commoners lead the Great Revolution. The wealthy and the privileged were beheaded, and King Gallien could not escape his fate. His blood flowing in the gutter I collected, and out of it, as a memento of his Sin, I shall forge the Ring of Greed.\\\";\\n\\t\\tTheRingOfGreed.Active = true;\\n\\t\\tTheRingOfGreed.Forged = false;\\n\\t\\tTheRingOfGreed.Holder = \\\"\\\";\\n\\t\\tRings[3] = TheRingOfGreed;\\n\\n\\t/*\\n\\t  _____  _           ___  _                     __   ___  _       _    _\\n\\t |_   _|| |_   ___  | _ \\\\(_) _ _   __ _   ___  / _| / __|| | ___ | |_ | |_\\n\\t   | |  | \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` | / _ \\\\|  _| \\\\__ \\\\| |/ _ \\\\|  _|| \\u0027 \\\\\\n\\t   |_|  |_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, | \\\\___/|_|   |___/|_|\\\\___/ \\\\__||_||_|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/\\n\\t*/\\n\\t\\tRing memory TheRingOfSloth;\\n\\t\\tTheRingOfSloth.Name = \\\"Ring of Sloth\\\";\\n\\t\\tTheRingOfSloth.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Sloth.gif\\\";\\n\\t\\tTheRingOfSloth.Lore = \\\"It is hard to date exactly the downfall of the elven kingdom of Elred the Gentle. Gifted with a natural talent for powerful time contraction magic, Elred had the power to freeze for eternity any of his enemies. Not a single race would dare trespass in the Elven Forest. But as his power grew stronger, his perception of the flow of the Chain became warped. Seconds, days, years: those concepts became obsolete to him. That is how one day, after waking up from his usual communion with nature, he realized that his entire nation was gone, wiped out by centuries of foreign invasions that he could have easily vanquished. In despair, used his powers to accelerate his own time and turn himself into ashes. From those ashes, as a memento of his Sin, I shall forge the Ring of Sloth.\\\";\\n\\t\\tTheRingOfSloth.Active = true;\\n\\t\\tTheRingOfSloth.Forged = false;\\n\\t\\tTheRingOfSloth.Holder = \\\"\\\";\\n\\t\\tRings[4] = TheRingOfSloth;\\n\\n\\t/*\\n\\t  _____  _           ___  _                     __  __      __           _    _\\n\\t |_   _|| |_   ___  | _ \\\\(_) _ _   __ _   ___  / _| \\\\ \\\\    / /_ _  __ _ | |_ | |_\\n\\t   | |  | \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` | / _ \\\\|  _|  \\\\ \\\\/\\\\/ /| \\u0027_|/ _` ||  _|| \\u0027 \\\\\\n\\t   |_|  |_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, | \\\\___/|_|     \\\\_/\\\\_/ |_|  \\\\__,_| \\\\__||_||_|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/\\n\\t*/\\n\\t\\tRing memory TheRingOfWrath;\\n\\t\\tTheRingOfWrath.Name = \\\"Ring of Wrath\\\";\\n\\t\\tTheRingOfWrath.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Wrath.gif\\\";\\n\\t\\tTheRingOfWrath.Lore = \\\"The giants, while not forming a kingdom strictly speaking, were often considered as a nomad nation that brought devastation in its wake. At the top of their small pack, their leader, Xomohr the Colossus, was the incarnation on strength: his stomp would shake the earth and his first would break mountains. But few knew that the true source of his overwhelming power was in fact his caring heart. The love for his kin and his will to provide for them was what allowed Xomohr to unleash this might comparable to that of the Ancients. One day, after coming early from a hunting expedition, he discovered Calos, his wife, bedding Krobrog, his first lieutenant. As if to protect his own sanity, his consciouness instantly vanished. When he finally gained back clarity, all he found was desolation: his entire tribe stomped, smashed, torn to pieces, and in his hand the lifeless head of his beloved. From his tears were born the Tinted River, and after having cried the last tear out of his body, Xomohr smashed his own skull on the Grand Mountain. From this tear, as a memento of his Sin, I shall forge the Ring of Wrath.\\\";\\n\\t\\tTheRingOfWrath.Active = true;\\n\\t\\tTheRingOfWrath.Forged = false;\\n\\t\\tTheRingOfWrath.Holder = \\\"\\\";\\n\\t\\tRings[5] = TheRingOfWrath;\\n\\n\\t/*\\n\\t  _____  _           ___  _                     __   ___\\n\\t |_   _|| |_   ___  | _ \\\\(_) _ _   __ _   ___  / _| | __| _ _ __ __ _  _\\n\\t   | |  | \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` | / _ \\\\|  _| | _| | \\u0027 \\\\\\\\ V /| || |\\n\\t   |_|  |_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, | \\\\___/|_|   |___||_||_|\\\\_/  \\\\_, |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/                             |__/\\n\\t*/\\n\\t\\tRing memory TheRingOfEnvy;\\n\\t\\tTheRingOfEnvy.Name = \\\"Ring of Envy\\\";\\n\\t\\tTheRingOfEnvy.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Envy.gif\\\";\\n\\t\\tTheRingOfEnvy.Lore = \\\"The Brillance. The forgotten deity. An ethereal presence that is said to descend of the Gods. Adored in a time from before the Genesis, there is not a single relic left in our world of its cult: as such, little is known about it. The only knowledge that we have about it come from the gibberish babbles of folks from all races, who seemingly without any connection all became crazy and started muttering incoherent words about The Brillance around the same time. Legends say that The Brillance, jealous of being forgotten in favor of the new idols, infected the minds of the inhabitants of the Chain. Accused of madness, all the people who got struck were burned, but surprisingly, they all left behind a shining substance that seemingly was impervious to fire. Not even one of these madmen remain today: it is said that if it ever was alive, The Brillance has now been killed. I have crystalized as much of its golden remain as I could, and out of it, as a memento of its sin, I shall forge the Ring of Envy.\\\";\\n\\t\\tTheRingOfEnvy.Active = true;\\n\\t\\tTheRingOfEnvy.Forged = false;\\n\\t\\tTheRingOfEnvy.Holder = \\\"\\\";\\n\\t\\tRings[6] = TheRingOfEnvy;\\n\\n\\t/*\\n\\t  _____  _           ___  _                     __   ___       _     _\\n\\t |_   _|| |_   ___  | _ \\\\(_) _ _   __ _   ___  / _| | _ \\\\ _ _ (_) __| | ___\\n\\t   | |  | \\u0027 \\\\ / -_) |   /| || \\u0027 \\\\ / _` | / _ \\\\|  _| |  _/| \\u0027_|| |/ _` |/ -_)\\n\\t   |_|  |_||_|\\\\___| |_|_\\\\|_||_||_|\\\\__, | \\\\___/|_|   |_|  |_|  |_|\\\\__,_|\\\\___|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  |___/\\n\\t*/\\n\\t\\tRing memory TheRingOfPride;\\n\\t\\tTheRingOfPride.Name = \\\"Ring of Pride\\\";\\n\\t\\tTheRingOfPride.Source = \\\"https://sevendeadlyrings.io/wp-content/uploads/2021/09/Pride.gif\\\";\\n\\t\\tTheRingOfPride.Lore = \\\"No one could have been more suited to claim the title of strongest creature on the Chain than Yrmas the Eternal, Queen of the dragonborn. She was last true Elder Dragon, and some tales claim that her birth precedes the Genesis itself. Her vitriol breath could melt entire cities in an instant, a single flap of her wings could send whirlwinds across entire realms. Unmatched in Heaven and Earth, it was only natural for her that she would attempt to defy the Rules of the Chain, and ascend Godhood. Alongside her people, she tried the taboo: using their extreme intellect, and humongous brute force, they attempted to re-organize the flow of the world itself. But there, she only met darkness. The immutable Rules of the Chain erased her and her kin\\u0027s soul out of existence, leaving only empty carcasses on the physical realm, living but will-less. Her heart still beating I carved out, and out of it, as a memento of her Sin, I shall forge the Ring of Pride.\\\";\\n\\t\\tTheRingOfPride.Active = true;\\n\\t\\tTheRingOfPride.Forged = false;\\n\\t\\tTheRingOfPride.Holder = \\\"\\\";\\n\\t\\tRings[7] = TheRingOfPride;\\n\\n\\t\\t_safeMint(address(this), 0);\\n\\t\\t_safeMint(address(this), 1);\\n\\t\\t_safeMint(address(this), 2);\\n\\t\\t_safeMint(address(this), 3);\\n\\t\\t_safeMint(address(this), 4);\\n\\t\\t_safeMint(address(this), 5);\\n\\t\\t_safeMint(address(this), 6);\\n\\t\\t_safeMint(address(this), 7);\\n\\t}\\n\\n\\tstruct Ring {\\n\\t\\tstring Name;\\n\\t\\tstring Lore;\\n\\t\\tstring Holder;\\n\\t\\tstring Source;\\n\\t\\tbool Forged;\\n\\t\\tbool Active;\\n\\t}\\n\\n\\tuint256 public ForgeOpensAt = 1630944000;\\n\\tfunction IsForgeOpen() public view returns (bool) {\\n\\t\\tif (block.timestamp \\u003e= ForgeOpensAt) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/*\\n\\t\\tThe Divine Ring\\n\\t\\tA Divine Robe must be sacrificed to invoke The Divine Ring\\n\\t*/\\n\\n\\tevent TheDivineRingHasBeenForged(address Holder);\\n\\tfunction ForgeTheDivineRing(uint256 LootID) public {\\n\\t\\trequire(IsForgeOpen(), \\\"The Forge is not yet open.\\\");\\n\\t\\trequire(!IsForged(0), string(abi.encodePacked(\\\"The \\\", NameOf(0), \\\" is already forged.\\\")));\\n\\t\\trequire(IsDivineRobeOwner(LootID, msg.sender), \\\"Requires a Divine Robe sacrifice.\\\");\\n\\t\\tLootContract.safeTransferFrom(msg.sender, BurnAddress, LootID);\\n\\t\\tRings[0].Forged = true;\\n\\t\\t_transfer(address(this), msg.sender, 0);\\n\\t\\temit TheDivineRingHasBeenForged(msg.sender);\\n\\t}\\n\\n\\tfunction TheDivineRingHolder() public view returns (string memory) {\\n\\t\\treturn HolderOf(0);\\n\\t}\\n\\n\\tfunction TheDivineRingLore() public view returns (string memory) {\\n\\t\\treturn LoreOf(0);\\n\\t}\\n\\n\\tfunction NewDivineRingHolderName(string memory Holder) public {\\n\\t\\trequire(ownerOf(0) == msg.sender, string(abi.encodePacked(\\\"You are not the owner of The \\\", NameOf(0), \\\".\\\")));\\n\\t\\tRings[0].Holder = Holder;\\n\\t}\\n\\n\\t/*\\n\\t\\tThe Seven Deadly Rings\\n\\t\\tGold must be melted to forge a Deadly Ring\\n\\t*/\\n\\n\\tuint256 public GoldsForADeadlyRing = 7777000000000000000000; // 7777 AGLD\\n\\taddress public GoldsAddress = 0x32353A6C91143bfd6C7d363B546e62a9A2489A20; // Adventure Gold\\n\\n\\tfunction TheDeadlyRingHolder(uint256 RingID) public view returns (string memory) {\\n\\t\\treturn HolderOf(RingID);\\n\\t}\\n\\n\\tfunction TheDeadlyRingLore(uint256 RingID) public view returns (string memory) {\\n\\t\\treturn LoreOf(RingID);\\n\\t}\\n\\n\\tevent ADeadlyRingHasBeenForged(address Holder, uint256 RingID);\\n\\tfunction ForgeTheDeadlyRing(uint256 RingID) public {\\n\\t\\trequire(IsForgeOpen(), \\\"The Forge is not yet open.\\\");\\n\\t\\trequire(!IsForged(RingID), string(abi.encodePacked(\\\"The \\\", NameOf(RingID), \\\" is already forged.\\\")));\\n\\t\\trequire(ERC20(GoldsAddress).transferFrom(msg.sender, address(this), GoldsForADeadlyRing), \\\"Gold must be melted to forge a Deadly Ring.\\\");\\n\\t\\trequire(ERC20(GoldsAddress).transfer(owner(), GoldsForADeadlyRing), \\\"An error occured while transferring golds.\\\");\\n\\t\\tRings[RingID].Forged = true;\\n\\t\\t_transfer(address(this), msg.sender, RingID);\\n\\t\\temit ADeadlyRingHasBeenForged(msg.sender, RingID);\\n\\t}\\n\\n\\t/*\\n\\t\\tLoot (for Adventurers)\\n\\t*/\\n\\n\\taddress public LootContractAddress = 0xFF9C1b15B16263C61d017ee9F65C50e4AE0113D7;\\n\\taddress BurnAddress = 0x000000000000000000000000000000000000dEaD;\\n\\tLootInterface LootContract = LootInterface(LootContractAddress);\\n\\n\\tfunction IsLootOwner(uint256 ID, address Caller) internal view returns (bool) {\\n\\t\\tif (LootContract.ownerOf(ID) == Caller) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction IsDivineRobeOwner(uint256 ID, address Caller) internal view returns (bool) {\\n\\t\\tif (!IsLootOwner(ID, Caller)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn utils.contains(utils.toSlice(LootContract.getChest(ID)), utils.toSlice(\\\"Divine Robe\\\"));\\n\\t}\\n\\n\\t/*\\n\\t\\tThe Sin Forger\\n\\t*/\\n\\n\\tfunction NewDeadlyRingHolderName(uint256 RingID, string memory Holder, uint256 LootID) public {\\n\\t\\trequire(ownerOf(RingID) == msg.sender, string(abi.encodePacked(\\\"You are not the owner of The \\\", NameOf(RingID), \\\".\\\")));\\n\\t\\trequire(IsLootOwner(LootID, msg.sender), \\\"You are not the owner of this Loot bag.\\\");\\n\\t\\tRings[RingID].Holder = Holder;\\n\\t}\\n\\n\\tfunction ActiveTheRing(uint256 RingID) public {\\n\\t\\trequire(IsForged(RingID), string(abi.encodePacked(\\\"The \\\", NameOf(RingID), \\\" has not been forged yet.\\\")));\\n\\t\\trequire(ownerOf(0) == msg.sender || ownerOf(RingID) == msg.sender, string(abi.encodePacked(\\\"You are not The \\\", NameOf(0), \\\" or The \\\", NameOf(RingID), \\\" owner.\\\")));\\n\\t\\tRings[RingID].Active = true;\\n\\t}\\n\\n\\tfunction HideTheRing(uint256 RingID) public {\\n\\t\\trequire(IsForged(RingID), string(abi.encodePacked(\\\"The \\\", NameOf(RingID), \\\" has not been forged yet.\\\")));\\n\\t\\trequire(ownerOf(0) == msg.sender || ownerOf(RingID) == msg.sender, string(abi.encodePacked(\\\"You are not The \\\", NameOf(0), \\\" or The \\\", NameOf(RingID), \\\" owner.\\\")));\\n\\t\\tRings[RingID].Active = false;\\n\\t}\\n\\n\\tfunction IsForged(uint256 RingID) public view returns (bool) {\\n\\t\\treturn Rings[RingID].Forged;\\n\\t}\\n\\n\\tfunction NRHM(uint256 RingID) public {\\n\\t\\trequire(address(this) == msg.sender, string(abi.encodePacked(\\\"This can only happen if The \\\", NameOf(RingID) ,\\\" changes ownership.\\\")));\\n\\t\\tRings[RingID].Holder = \\\"\\\";\\n\\t}\\n\\n\\tfunction LoreOf(uint256 RingID) internal view returns (string memory) {\\n\\t\\treturn Rings[RingID].Lore;\\n\\t}\\n\\n\\tfunction SourceOf(uint256 RingID) internal view returns (string memory) {\\n\\t\\treturn Rings[RingID].Source;\\n\\t}\\n\\n\\tfunction HolderOf(uint256 RingID) internal view returns (string memory) {\\n\\t\\treturn Rings[RingID].Holder;\\n\\t}\\n\\n\\tfunction IsActive(uint256 RingID) internal view returns (bool) {\\n\\t\\treturn Rings[RingID].Active;\\n\\t}\\n\\n\\tfunction NameOf(uint256 RingID) internal view returns (string memory) {\\n\\t\\treturn Rings[RingID].Name;\\n\\t}\\n\\n\\tfunction tokenURI(uint256 tokenId) override public view returns (string memory) {\\n\\t\\tstring memory Name;\\n\\t\\tstring memory Image;\\n\\t\\tstring memory Description = LoreOf(tokenId);\\n\\t\\tif (!IsForged(tokenId)) {\\n\\t\\t\\tName = string(abi.encodePacked(\\\"Unforged \\\", NameOf(tokenId)));\\n\\t\\t} else if (!utils.compareStrings(HolderOf(tokenId), \\\"\\\")) {\\n\\t\\t\\tName = string(abi.encodePacked(HolderOf(tokenId), \\\"\\u0027s \\\", NameOf(tokenId)));\\n\\t\\t} else {\\n\\t\\t\\tName = string(abi.encodePacked(\\\"The \\\", NameOf(tokenId)));\\n\\t\\t}\\n\\t\\tif (IsActive(tokenId)) {\\n\\t\\t\\tImage = SourceOf(tokenId);\\n\\t\\t} else {\\n\\t\\t\\tstring memory SVG;\\n\\t\\t\\tif (utils.compareStrings(HolderOf(tokenId), \\\"\\\")) {\\n\\t\\t\\t\\tstring[3] memory SVGParts;\\n\\t\\t\\t\\tSVGParts[0] = \\u0027\\u003csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"\\u003e\\u003cstyle\\u003e.base { fill: white; font-family: serif; font-size: 14px; }\\u003c/style\\u003e\\u003crect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\" /\\u003e\\u003ctext x=\\\"10\\\" y=\\\"20\\\" class=\\\"base\\\"\\u003e\\u0027;\\n\\t\\t\\t\\tSVGParts[1] = string(abi.encodePacked(\\\"The \\\", NameOf(tokenId)));\\n\\t\\t\\t\\tSVGParts[2] = \\u0027\\u003c/text\\u003e\\u003c/svg\\u003e\\u0027;\\n\\t\\t\\t\\tSVG = string(abi.encodePacked(SVGParts[0], SVGParts[1], SVGParts[2]));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstring[5] memory SVGParts;\\n\\t\\t\\t\\tSVGParts[0] = \\u0027\\u003csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"\\u003e\\u003cstyle\\u003e.base { fill: white; font-family: serif; font-size: 14px; }\\u003c/style\\u003e\\u003crect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\" /\\u003e\\u003ctext x=\\\"10\\\" y=\\\"20\\\" class=\\\"base\\\"\\u003e\\u0027;\\n\\t\\t\\t\\tSVGParts[1] = string(abi.encodePacked(\\\"The \\\", NameOf(tokenId)));\\n\\t\\t\\t\\tSVGParts[2] = \\u0027\\u003c/text\\u003e\\u003ctext x=\\\"10\\\" y=\\\"40\\\" class=\\\"base\\\"\\u003e\\u0027;\\n\\t\\t\\t\\tSVGParts[3] = string(abi.encodePacked(\\\"Holder : \\\", HolderOf(tokenId)));\\n\\t\\t\\t\\tSVGParts[4] = \\u0027\\u003c/text\\u003e\\u003c/svg\\u003e\\u0027;\\n\\t\\t\\t\\tSVG = string(abi.encodePacked(SVGParts[0], SVGParts[1], SVGParts[2], SVGParts[3], SVGParts[4]));\\n\\t\\t\\t}\\n\\t\\t\\tImage = string(abi.encodePacked(\\\"data:image/svg+xml;base64,\\\", Base64.encode(bytes(SVG))));\\n\\t\\t}\\n\\t\\tstring memory json = Base64.encode(bytes(string(abi.encodePacked(\\u0027{\\\"name\\\": \\\"\\u0027, Name, \\u0027\\\", \\\"description\\\": \\\"\\u0027, Description ,\\u0027\\\", \\\"image\\\": \\\"\\u0027, Image,\\u0027\\\"}\\u0027))));\\n\\t\\tstring memory output = string(abi.encodePacked(\\u0027data:application/json;base64,\\u0027, json));\\n\\t\\treturn output;\\n\\t}\\n\\n\\tfunction ForgerSetSourceOf(uint256 RingID, string memory Source) public onlyOwner {\\n\\t\\tRings[RingID].Source = Source;\\n\\t}\\n\\n\\tfunction ForgerSetLoreOf(uint256 RingID, string memory Lore) public onlyOwner {\\n\\t\\tRings[RingID].Lore = Lore;\\n\\t}\\n\\n\\tfunction WD() public onlyOwner {\\n\\t\\tmsg.sender.transfer(address(this).balance);\\n\\t}\\n\\n\\tfunction AT(address Contract, address Spender, uint256 Amount) public onlyOwner {\\n\\t\\tERC20(Contract).approve(Spender, Amount);\\n\\t}\\n\\n\\tfunction GT(address Contract, uint Amount) public onlyOwner {\\n\\t\\tERC20(Contract).transfer(msg.sender, Amount);\\n\\t}\\n}\\n\\nlibrary utils {\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\twhile (value != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n\\t\\t\\tvalue /= 10;\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n\\t\\treturn (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n\\t}\\n\\n\\tfunction contains(slice memory self, slice memory needle) internal pure returns (bool) {\\n\\t\\treturn rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n\\t}\\n\\n\\tfunction rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n\\t\\tuint ptr;\\n\\n\\t\\tif (needlelen \\u003c= selflen) {\\n\\t\\t\\tif (needlelen \\u003c= 32) {\\n\\t\\t\\t\\tbytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n\\t\\t\\t\\tbytes32 needledata;\\n\\t\\t\\t\\tassembly { needledata := and(mload(needleptr), mask) }\\n\\n\\t\\t\\t\\tptr = selfptr + selflen - needlelen;\\n\\t\\t\\t\\tbytes32 ptrdata;\\n\\t\\t\\t\\tassembly { ptrdata := and(mload(ptr), mask) }\\n\\n\\t\\t\\t\\twhile (ptrdata != needledata) {\\n\\t\\t\\t\\t\\tif (ptr \\u003c= selfptr)\\n\\t\\t\\t\\t\\t\\treturn selfptr;\\n\\t\\t\\t\\t\\tptr--;\\n\\t\\t\\t\\t\\tassembly { ptrdata := and(mload(ptr), mask) }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ptr + needlelen;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// For long needles, use hashing\\n\\t\\t\\t\\tbytes32 hash;\\n\\t\\t\\t\\tassembly { hash := keccak256(needleptr, needlelen) }\\n\\t\\t\\t\\tptr = selfptr + (selflen - needlelen);\\n\\t\\t\\t\\twhile (ptr \\u003e= selfptr) {\\n\\t\\t\\t\\t\\tbytes32 testHash;\\n\\t\\t\\t\\t\\tassembly { testHash := keccak256(ptr, needlelen) }\\n\\t\\t\\t\\t\\tif (hash == testHash)\\n\\t\\t\\t\\t\\t\\treturn ptr + needlelen;\\n\\t\\t\\t\\t\\tptr -= 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn selfptr;\\n\\t}\\n\\n\\tfunction toSlice(string memory self) internal pure returns (slice memory) {\\n\\t\\tuint ptr;\\n\\t\\tassembly {\\n\\t\\t\\tptr := add(self, 0x20)\\n\\t\\t}\\n\\t\\treturn slice(bytes(self).length, ptr);\\n\\t}\\n\\n\\tstruct slice {\\n\\t\\tuint _len;\\n\\t\\tuint _ptr;\\n\\t}\\n}\\n\\ninterface LootInterface {\\n\\tfunction safeTransferFrom(address, address, uint256) external;\\n\\tfunction ownerOf(uint256) external view returns (address);\\n\\tfunction getChest(uint256) external view returns (string memory);\\n}\\n\\ninterface ERC20 {\\n\\tfunction transfer(address, uint256) external returns (bool);\\n\\tfunction approve(address, uint256) external returns (bool);\\n\\tfunction transferFrom(address, address, uint256) external returns (bool);\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"ADeadlyRingHasBeenForged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Holder\",\"type\":\"address\"}],\"name\":\"TheDivineRingHasBeenForged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"AT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"ActiveTheRing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ForgeOpensAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"ForgeTheDeadlyRing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"LootID\",\"type\":\"uint256\"}],\"name\":\"ForgeTheDivineRing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Lore\",\"type\":\"string\"}],\"name\":\"ForgerSetLoreOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Source\",\"type\":\"string\"}],\"name\":\"ForgerSetSourceOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"GT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GoldsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GoldsForADeadlyRing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"HideTheRing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IsForgeOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"IsForged\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LootContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"NRHM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Holder\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"LootID\",\"type\":\"uint256\"}],\"name\":\"NewDeadlyRingHolderName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Holder\",\"type\":\"string\"}],\"name\":\"NewDivineRingHolderName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Rings\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Lore\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Holder\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Source\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"Forged\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"TheDeadlyRingHolder\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"RingID\",\"type\":\"uint256\"}],\"name\":\"TheDeadlyRingLore\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TheDivineRingHolder\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TheDivineRingLore\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DeadlyRings","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://32e8fa282ef7f6c061e315722a52671f1b3b2f247e68d26fb87e29cf0e58387e"}]}