{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ape3D.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport \\\"./safeMath.sol\\\";\\r\\nimport \\\"./NameFilter.sol\\\";\\r\\n\\r\\n// datasets\\r\\nlibrary F3Ddatasets {\\r\\n    //compressedData key\\r\\n    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]\\r\\n        // 0 - new player (bool)\\r\\n        // 1 - joined round (bool)\\r\\n        // 2 - new  leader (bool)\\r\\n        // 3-5 - air drop tracker (uint 0-999)\\r\\n        // 6-16 - round end time\\r\\n        // 17 - winnerTeam\\r\\n        // 18 - 28 timestamp\\r\\n        // 29 - team\\r\\n        // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)\\r\\n    //compressedIDs key\\r\\n    // [77-52][51-26][25-0]\\r\\n        // 0-25 - pID\\r\\n        // 26-51 - winPID\\r\\n        // 52-77 - rID\\r\\n        \\r\\n    struct EventReturns {\\r\\n        uint256 compressedData;\\r\\n        uint256 compressedIDs;\\r\\n        address winnerAddr;         // winner addr\\r\\n        bytes32 winnerName;         // winner name\\r\\n        uint256 amountWon;          \\r\\n        uint256 newPot;\\r\\n        uint256 genAmount;          \\r\\n        uint256 potAmount;          // amount added to the pot\\r\\n    }\\r\\n    struct Player {\\r\\n        address addr;               // player addr\\r\\n        bytes32 name;               \\r\\n        uint256 names;              \\r\\n        uint256 win;                // jackpot won\\r\\n        uint256 gen;                // key reward won\\r\\n        uint256 aff;                // ref reward\\r\\n        uint256 lrnd;               // last round played\\r\\n        uint256 laff;               // last reffer\\r\\n    }\\r\\n    struct PlayerRounds {\\r\\n        uint256 eth;                // Amount of ETH puts into cur round\\r\\n        uint256 keys;               // # of keys\\r\\n        uint256 mask;               \\r\\n    }\\r\\n    struct Round {\\r\\n        uint256 plyr;               // round leader\\u0027s pID\\r\\n        uint256 end;                // ending time timeStamp\\r\\n        bool ended;                 // is ended\\r\\n        uint256 strt;               // starting time\\r\\n        uint256 keys;               // number of keys\\r\\n        uint256 eth;                // total eth in\\r\\n        uint256 pot;                // total jackpot\\r\\n        uint256 mask;               \\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ape3D {\\r\\n\\r\\n    using SafeMath for *;\\r\\n    using NameFilter for string;\\r\\n\\r\\n    string constant public name = \\\"Ape3D long\\\";           \\r\\n    string constant public symbol = \\\"A3D\\\";                      // game symbol\\r\\n\\r\\n    // Game data\\r\\n    address public devs;                                        // dev addr\\r\\n\\r\\n    bool public activated_ = false;                             \\r\\n\\r\\n    uint256 constant private rndInit_ = 24 hours; \\r\\n    uint256 constant private rndInc_ = 60 seconds;             \\r\\n    uint256 constant private rndMax_ = 24 hours;  \\r\\n\\r\\n    uint256 public rID_;                                        // roundID\\r\\n\\r\\n    uint256 public registrationFee_ = 10 finney;                // register fee\\r\\n    \\r\\n    // player data\\r\\n    uint256 public pID_;                                        // Total number of players\\r\\n    mapping(address =\\u003e uint256) public pIDxAddr_;               //（addr =\\u003e pID）addr to pID \\r\\n    mapping(bytes32 =\\u003e uint256) public pIDxName_;               //（name =\\u003e pID）name to pID\\r\\n    mapping(uint256 =\\u003e F3Ddatasets.Player) public plyr_;        //（pID =\\u003e data）pID to player data\\r\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e F3Ddatasets.PlayerRounds)) public plyrRnds_;    //（pID =\\u003e rID =\\u003e data\\r\\n    mapping(uint256 =\\u003e mapping(bytes32 =\\u003e bool)) public plyrNames_;      \\r\\n\\r\\n    // round data\\r\\n    mapping(uint256 =\\u003e F3Ddatasets.Round) public round_;        //（rID =\\u003e data） rID to round data\\r\\n    mapping(uint256 =\\u003e uint256) public rndEth_;    //（rID  =\\u003e data） rID to round total eth\\r\\n\\r\\n    // emit when a player register a name\\r\\n    event onNewName\\r\\n    (\\r\\n        uint256 indexed playerID,\\r\\n        address indexed playerAddress,\\r\\n        bytes32 indexed playerName,\\r\\n        bool isNewPlayer,\\r\\n        uint256 affiliateID,\\r\\n        uint256 amountPaid,\\r\\n        uint256 timeStamp\\r\\n    );\\r\\n\\r\\n    event onBuyAndDistribute\\r\\n    (\\r\\n        address playerAddress,\\r\\n        bytes32 playerName,\\r\\n        uint256 ethIn,\\r\\n        uint256 compressedData,\\r\\n        uint256 compressedIDs,\\r\\n        address winnerAddr,\\r\\n        bytes32 winnerName,\\r\\n        uint256 amountWon,\\r\\n        uint256 genAmount\\r\\n    );\\r\\n\\r\\n    event onEndTx\\r\\n    (\\r\\n        uint256 compressedData,\\r\\n        uint256 compressedIDs,\\r\\n        bytes32 playerName,\\r\\n        address playerAddress,\\r\\n        uint256 ethIn,\\r\\n        uint256 keysBought,\\r\\n        address winnerAddr,\\r\\n        bytes32 winnerName,\\r\\n        uint256 amountWon,\\r\\n        uint256 genAmount,\\r\\n        uint256 potAmount\\r\\n    );\\r\\n\\r\\n    event onAffiliatePayout\\r\\n    (\\r\\n        uint256 indexed affiliateID,\\r\\n        address affiliateAddress,\\r\\n        bytes32 affiliateName,\\r\\n        uint256 indexed roundID,\\r\\n        uint256 indexed buyerID,\\r\\n        uint256 amount,\\r\\n        uint256 timeStamp\\r\\n    );\\r\\n\\r\\n    event onWithdraw\\r\\n    (\\r\\n        uint256 indexed playerID,\\r\\n        address playerAddress,\\r\\n        bytes32 playerName,\\r\\n        uint256 ethOut,\\r\\n        uint256 timeStamp\\r\\n    );\\r\\n\\r\\n    event onWithdrawAndDistribute\\r\\n    (\\r\\n        address playerAddress,\\r\\n        bytes32 playerName,\\r\\n        uint256 ethOut,\\r\\n        uint256 compressedData,\\r\\n        uint256 compressedIDs,\\r\\n        address winnerAddr,\\r\\n        bytes32 winnerName,\\r\\n        uint256 amountWon,\\r\\n        uint256 genAmountf\\r\\n    );\\r\\n\\r\\n    event onReLoadAndDistribute\\r\\n    (\\r\\n        address playerAddress,\\r\\n        bytes32 playerName,\\r\\n        uint256 compressedData,\\r\\n        uint256 compressedIDs,\\r\\n        address winnerAddr,\\r\\n        bytes32 winnerName,\\r\\n        uint256 amountWon,\\r\\n        uint256 genAmount\\r\\n    );\\r\\n\\r\\n    modifier isActivated() {\\r\\n        require(activated_ == true, \\\"its not ready yet.  check ?eta in discord\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // anti-contract\\r\\n    modifier isHuman() {\\r\\n        require(msg.sender == tx.origin);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    \\r\\n    modifier onlyDevs()\\r\\n    {\\r\\n        require(msg.sender == devs, \\\"msg sender is not a dev\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isWithinLimits(uint256 _eth) {\\r\\n        require(_eth \\u003e= 1000000000, \\\"pocket lint: not a valid currency\\\");\\r\\n        require(_eth \\u003c= 100000000000000000000000, \\\"no vitalik, no\\\");\\r\\n        _;    \\r\\n    }\\r\\n\\r\\n    function activate()\\r\\n    public\\r\\n    onlyDevs\\r\\n    {\\r\\n        \\r\\n        require(activated_ == false, \\\"Ape3D already activated\\\");\\r\\n\\r\\n        activated_ = true;\\r\\n\\r\\n        // start the first round\\r\\n        rID_ = 1;\\r\\n        round_[1].strt = now;\\r\\n        round_[1].end = now + rndInit_;\\r\\n    }\\r\\n\\r\\n    constructor()\\r\\n    public\\r\\n    {\\r\\n        devs = msg.sender;\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev emergency buy uses last stored affiliate ID and team snek\\r\\n     */\\r\\n    function()\\r\\n    isActivated()\\r\\n    isHuman()\\r\\n    isWithinLimits(msg.value)\\r\\n    public\\r\\n    payable\\r\\n    {\\r\\n        // set up our tx event data and determine if player is new or not\\r\\n        F3Ddatasets.EventReturns memory _eventData_ = determinePlayer(_eventData_);\\r\\n\\r\\n        // fetch player id\\r\\n        uint256 _pID = pIDxAddr_[msg.sender];\\r\\n\\r\\n        buyCore(_pID, plyr_[_pID].laff, _eventData_);\\r\\n    }\\r\\n\\r\\n    // assigning a new pID to a new player\\r\\n    function determinePlayer(F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    returns (F3Ddatasets.EventReturns)\\r\\n    {\\r\\n        uint256 _pID = pIDxAddr_[msg.sender];\\r\\n\\r\\n        if (_pID == 0)\\r\\n        {\\r\\n            // assigning a new pID.\\r\\n            determinePID(msg.sender);\\r\\n            _pID = pIDxAddr_[msg.sender];\\r\\n            bytes32 _name = plyr_[_pID].name;\\r\\n            uint256 _laff = plyr_[_pID].laff;\\r\\n\\r\\n            pIDxAddr_[msg.sender] = _pID;\\r\\n            plyr_[_pID].addr = msg.sender;\\r\\n\\r\\n            if (_name != \\\"\\\")\\r\\n            {\\r\\n                pIDxName_[_name] = _pID;\\r\\n                plyr_[_pID].name = _name;\\r\\n                plyrNames_[_pID][_name] = true;\\r\\n            }\\r\\n\\r\\n            if (_laff != 0 \\u0026\\u0026 _laff != _pID)\\r\\n                plyr_[_pID].laff = _laff;\\r\\n\\r\\n            // sets \\\"true\\\" for new player\\r\\n            _eventData_.compressedData = _eventData_.compressedData + 1;\\r\\n        }\\r\\n        return (_eventData_);\\r\\n    }\\r\\n\\r\\n    // determine player ID\\r\\n    function determinePID(address _addr)\\r\\n    private\\r\\n    returns (bool)\\r\\n    {\\r\\n        if (pIDxAddr_[_addr] == 0)\\r\\n        {\\r\\n            pID_++;\\r\\n            pIDxAddr_[_addr] = pID_;\\r\\n            plyr_[pID_].addr = _addr;\\r\\n\\r\\n            // return true for new player\\r\\n            return (true);\\r\\n        } else {\\r\\n            return (false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // register name using ref\\u0027s ID\\r\\n    function registerNameXname(string _nameString, bytes32 _affCode)\\r\\n    external\\r\\n    payable\\r\\n    {\\r\\n        require(msg.value \\u003e= registrationFee_, \\\"umm.....  you have to pay the name fee\\\");\\r\\n\\r\\n        address _addr = msg.sender;\\r\\n\\r\\n        bytes32 _name = NameFilter.nameFilter(_nameString);\\r\\n\\r\\n        bool _isNewPlayer = determinePID(_addr);\\r\\n\\r\\n        uint256 _pID = pIDxAddr_[_addr];\\r\\n\\r\\n        uint256 _affID = 0;\\r\\n        if (_affCode != \\\"\\\" \\u0026\\u0026 _affCode != _name)\\r\\n        {\\r\\n            _affID = pIDxName_[_affCode];\\r\\n\\r\\n            if (_affID != plyr_[_pID].laff)\\r\\n            {\\r\\n                plyr_[_pID].laff = _affID;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer);\\r\\n    }\\r\\n\\r\\n    // core function for register name\\r\\n    function registerNameCore(uint256 _pID, address _addr, uint256 _affID, bytes32 _name, bool _isNewPlayer)\\r\\n    private\\r\\n    {\\r\\n        // check if the name is taken\\r\\n        if (pIDxName_[_name] != 0)\\r\\n            require(plyrNames_[_pID][_name] == true, \\\"sorry that names already taken\\\");\\r\\n\\r\\n        // setting up player name and id \\r\\n        plyr_[_pID].name = _name;\\r\\n        pIDxName_[_name] = _pID;\\r\\n        if (plyrNames_[_pID][_name] == false)\\r\\n        {\\r\\n            plyrNames_[_pID][_name] = true;\\r\\n            plyr_[_pID].names++;\\r\\n        }\\r\\n\\r\\n        // register fee sends to dev\\r\\n        address(devs).transfer(10 finney);\\r\\n\\r\\n        emit onNewName(_pID, _addr, _name, _isNewPlayer, _affID, msg.value, now);\\r\\n    }\\r\\n\\r\\n    // buy key using refs name\\r\\n    function buyXname(bytes32 _affCode)\\r\\n    isActivated()\\r\\n    isHuman()\\r\\n    isWithinLimits(msg.value)\\r\\n    external\\r\\n    payable\\r\\n    {\\r\\n        F3Ddatasets.EventReturns memory _eventData_ = determinePlayer(_eventData_);\\r\\n\\r\\n        // getting player\\u0027s ID\\r\\n        uint256 _pID = pIDxAddr_[msg.sender];\\r\\n\\r\\n        uint256 _affID;\\r\\n        if (_affCode == \\u0027\\u0027 || _affCode == plyr_[_pID].name)\\r\\n        {\\r\\n            // use last ref code saved\\r\\n            _affID = plyr_[_pID].laff;\\r\\n        } else {\\r\\n            // getting the ref\\u0027s pID\\r\\n            _affID = pIDxName_[_affCode];\\r\\n\\r\\n            // If the ref\\u0027s pID is new\\r\\n            if (_affID != plyr_[_pID].laff)\\r\\n            {\\r\\n                // Update\\r\\n                plyr_[_pID].laff = _affID;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        buyCore(_pID, _affID, _eventData_);\\r\\n    }\\r\\n\\r\\n    // use vault to rebuy keys, with name as ref \\r\\n    function reLoadXname(bytes32 _affCode, uint256 _eth)\\r\\n    isActivated()\\r\\n    isHuman()\\r\\n    isWithinLimits(_eth)\\r\\n    external\\r\\n    {\\r\\n        F3Ddatasets.EventReturns memory _eventData_;\\r\\n\\r\\n        // get player ID\\r\\n        uint256 _pID = pIDxAddr_[msg.sender];\\r\\n\\r\\n        uint256 _affID;\\r\\n        if (_affCode == \\u0027\\u0027 || _affCode == plyr_[_pID].name)\\r\\n        {\\r\\n            // getting ref pID\\r\\n            _affID = plyr_[_pID].laff;\\r\\n        } else {\\r\\n            // getting ref pID\\r\\n            _affID = pIDxName_[_affCode];\\r\\n\\r\\n            // If the ref\\u0027s pID is new\\r\\n            if (_affID != plyr_[_pID].laff)\\r\\n            {\\r\\n                // Update\\r\\n                plyr_[_pID].laff = _affID;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        reLoadCore(_pID, _affID, _eth, _eventData_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev logic runs whenever a buy order is executed.  determines how to handle \\r\\n     * incoming eth depending on if we are in an active round or not\\r\\n     */\\r\\n    function buyCore(uint256 _pID, uint256 _affID, F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    {\\r\\n        // setup local rID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        // grab time\\r\\n        uint256 _now = now;\\r\\n\\r\\n        // if round is active\\r\\n        if (_now \\u003e round_[_rID].strt  \\u0026\\u0026 (_now \\u003c= round_[_rID].end || (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].plyr == 0)))\\r\\n        {\\r\\n            // call core\\r\\n            core(_rID, _pID, msg.value, _affID, _eventData_);\\r\\n        // if round is not active\\r\\n        } else {\\r\\n            // check to see if end round needs to be ran\\r\\n            if (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].ended == false)\\r\\n            {\\r\\n                // end the round (distributes pot) \\u0026 start new round\\r\\n                round_[_rID].ended = true;\\r\\n                _eventData_ = endRound(_eventData_);\\r\\n\\r\\n                // build event data\\r\\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\\r\\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\\r\\n\\r\\n                // fire buy and distribute event \\r\\n                emit onBuyAndDistribute\\r\\n                (\\r\\n                    msg.sender,\\r\\n                    plyr_[_pID].name,\\r\\n                    msg.value,\\r\\n                    _eventData_.compressedData,\\r\\n                    _eventData_.compressedIDs,\\r\\n                    _eventData_.winnerAddr,\\r\\n                    _eventData_.winnerName,\\r\\n                    _eventData_.amountWon,\\r\\n                    _eventData_.genAmount\\r\\n                );\\r\\n            }\\r\\n\\r\\n            // put eth in players vault \\r\\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev logic runs whenever a reload order is executed.  determines how to handle \\r\\n     * incoming eth depending on if we are in an active round or not \\r\\n     */\\r\\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    {\\r\\n        // setup local rID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        // grab time\\r\\n        uint256 _now = now;\\r\\n\\r\\n        // if round is active\\r\\n        if (_now \\u003e round_[_rID].strt \\u0026\\u0026 (_now \\u003c= round_[_rID].end || (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].plyr == 0)))\\r\\n        {\\r\\n            // get earnings from all vaults and return unused to gen vault\\r\\n            // because we use a custom safemath library.  this will throw if player \\r\\n            // tried to spend more eth than they have.\\r\\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\\r\\n\\r\\n            // call core\\r\\n            core(_rID, _pID, _eth, _affID, _eventData_);\\r\\n\\r\\n        // if round is not active and end round needs to be ran   \\r\\n        } else if (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].ended == false) {\\r\\n            // end the round (distributes pot) \\u0026 start new round\\r\\n            round_[_rID].ended = true;\\r\\n            _eventData_ = endRound(_eventData_);\\r\\n\\r\\n            // build event data\\r\\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\\r\\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\\r\\n\\r\\n            // fire buy and distribute event \\r\\n            emit onReLoadAndDistribute\\r\\n            (\\r\\n                msg.sender,\\r\\n                plyr_[_pID].name,\\r\\n                _eventData_.compressedData,\\r\\n                _eventData_.compressedIDs,\\r\\n                _eventData_.winnerAddr,\\r\\n                _eventData_.winnerName,\\r\\n                _eventData_.amountWon,\\r\\n                _eventData_.genAmount\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev decides if round end needs to be run \\u0026 new round started.  and if \\r\\n     * player unmasked earnings from previously played rounds need to be moved.\\r\\n     */\\r\\n    function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    returns (F3Ddatasets.EventReturns)\\r\\n    {\\r\\n        // if player has played a previous round, move their unmasked earnings\\r\\n        // from that round to gen vault.\\r\\n        if (plyr_[_pID].lrnd != 0)\\r\\n            updateGenVault(_pID, plyr_[_pID].lrnd);\\r\\n\\r\\n        // update player\\u0027s last round played\\r\\n        plyr_[_pID].lrnd = rID_;\\r\\n\\r\\n        // set the joined round bool to true\\r\\n        _eventData_.compressedData = _eventData_.compressedData + 10;\\r\\n\\r\\n        return (_eventData_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\\r\\n     * @return earnings in wei format\\r\\n     */\\r\\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\\r\\n    private\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return ((((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\\r\\n     */\\r\\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\\r\\n    private\\r\\n    {\\r\\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\\r\\n        if (_earnings \\u003e 0)\\r\\n        {\\r\\n            // put in gen vault\\r\\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\\r\\n            // zero out their earnings by updating mask\\r\\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates round timer based on number of whole keys bought.\\r\\n     */\\r\\n    function updateTimer(uint256 _keys, uint256 _rID)\\r\\n    private\\r\\n    {\\r\\n        // grab time\\r\\n        uint256 _now = now;\\r\\n\\r\\n        // calculate time based on number of keys bought\\r\\n        uint256 _newTime;\\r\\n        if (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].plyr == 0)\\r\\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\\r\\n        else\\r\\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\\r\\n\\r\\n        if (_newTime \\u003c (rndMax_).add(_now))\\r\\n            round_[_rID].end = _newTime;\\r\\n        else\\r\\n            round_[_rID].end = rndMax_.add(_now);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev this is the core logic for any buy/reload that happens while a round \\r\\n     * is live.\\r\\n     */\\r\\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    {\\r\\n        // if player is new to round\\r\\n        if (plyrRnds_[_pID][_rID].keys == 0)\\r\\n            _eventData_ = managePlayer(_pID, _eventData_);\\r\\n\\r\\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\\r\\n        if (_eth \\u003e 10000000000) //0.00000001eth\\r\\n        {\\r\\n\\r\\n            // calculate key received\\r\\n            uint256 _keys = keysRec(round_[_rID].eth,_eth);\\r\\n\\r\\n            // at least one key\\r\\n            if (_keys \\u003e= 1000000000000000000)\\r\\n            {\\r\\n                updateTimer(_keys, _rID);\\r\\n\\r\\n                // set new leader\\r\\n                if (round_[_rID].plyr != _pID)\\r\\n                    round_[_rID].plyr = _pID;\\r\\n\\r\\n                // set the new leader bool to true\\r\\n                _eventData_.compressedData = _eventData_.compressedData + 100;\\r\\n            }\\r\\n\\r\\n            // update player\\r\\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\\r\\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\\r\\n\\r\\n            // update round\\r\\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\\r\\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\\r\\n            rndEth_[_rID] = _eth.add(rndEth_[_rID]);\\r\\n\\r\\n            // distribute eth\\r\\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _eventData_);\\r\\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);\\r\\n\\r\\n            // call end tx function to fire end tx event.\\r\\n            endTx(_pID, _eth, _keys, _eventData_);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function endTx(uint256 _pID, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    {\\r\\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000);\\r\\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\\r\\n\\r\\n        emit onEndTx\\r\\n        (\\r\\n            _eventData_.compressedData,\\r\\n            _eventData_.compressedIDs,\\r\\n            plyr_[_pID].name,\\r\\n            msg.sender,\\r\\n            _eth,\\r\\n            _keys,\\r\\n            _eventData_.winnerAddr,\\r\\n            _eventData_.winnerName,\\r\\n            _eventData_.amountWon,\\r\\n            _eventData_.genAmount,\\r\\n            _eventData_.potAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev distributes eth based on fees to dev and aff\\r\\n     */\\r\\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    returns (F3Ddatasets.EventReturns)\\r\\n    {\\r\\n        uint256 _devs = (_eth.mul(3)) / 100;\\r\\n        address(devs).transfer(_devs);\\r\\n        _devs = 0;\\r\\n\\r\\n        // distribute share to affiliate\\r\\n        uint256 _aff = _eth / 10;\\r\\n\\r\\n        if (_affID != _pID \\u0026\\u0026 plyr_[_affID].name != \\u0027\\u0027) {\\r\\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\\r\\n            emit onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\\r\\n        } else {\\r\\n            _devs = _aff;\\r\\n        }\\r\\n\\r\\n        if (_devs \\u003e 0)\\r\\n        {\\r\\n            address(devs).transfer(_devs);\\r\\n            _devs = 0;\\r\\n        }\\r\\n\\r\\n        return (_eventData_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev distributes eth based on fees to gen and pot\\r\\n     */\\r\\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    returns (F3Ddatasets.EventReturns)\\r\\n    {\\r\\n        // calculate gen share\\r\\n        uint256 _gen = (_eth.mul(67)) / 100;\\r\\n\\r\\n        // calculate pot\\r\\n        uint256 _pot = (_eth.mul(20)) / 100;\\r\\n\\r\\n        // distribute gen share (thats what updateMasks() does) and adjust\\r\\n        // balances for dust.\\r\\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\\r\\n        if (_dust \\u003e 0)\\r\\n            _gen = _gen.sub(_dust);\\r\\n\\r\\n        // add eth to pot\\r\\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\\r\\n\\r\\n        // set up event data\\r\\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\\r\\n        _eventData_.potAmount = _pot;\\r\\n\\r\\n        return (_eventData_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates masks for round and player when keys are bought\\r\\n     * @return dust left over \\r\\n     */\\r\\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\\r\\n    private\\r\\n    returns (uint256)\\r\\n    {\\r\\n\\r\\n         /* MASKING NOTES\\r\\n            earnings masks are a tricky thing for people to wrap their minds around.\\r\\n            the basic thing to understand here.  is were going to have a global\\r\\n            tracker based on profit per share for each round, that increases in\\r\\n            relevant proportion to the increase in share supply.\\r\\n            \\r\\n            the player will have an additional mask that basically says \\\"based\\r\\n            on the rounds mask, my shares, and how much i\\u0027ve already withdrawn,\\r\\n            how much is still owed to me?\\\"\\r\\n        */\\r\\n        \\r\\n        // calc profit per key \\u0026 round mask based on this buy:  (dust goes to pot)\\r\\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\\r\\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\\r\\n\\r\\n        // calculate player earning from their own buy (only based on the keys\\r\\n        // they just bought).  \\u0026 update player earnings mask\\r\\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\\r\\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\\r\\n\\r\\n        //calculate \\u0026 return dust\\r\\n        return (_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev ends the round. manages paying out winner/splitting up pot\\r\\n     */\\r\\n    function endRound(F3Ddatasets.EventReturns memory _eventData_)\\r\\n    private\\r\\n    returns (F3Ddatasets.EventReturns)\\r\\n    {\\r\\n        // setup local ID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        // grab our winning player and team id\\u0027s\\r\\n        uint256 _winPID = round_[_rID].plyr;\\r\\n\\r\\n        // grab our pot amount\\r\\n        uint256 _pot = round_[_rID].pot;\\r\\n\\r\\n        // calculate our winner share, community rewards, gen share, \\r\\n        // p3d share, and amount reserved for next pot \\r\\n        uint256 _win = (_pot.mul(80)) / 100;\\r\\n\\r\\n        uint256 _gen = 0;\\r\\n        uint256 _res = _pot.sub(_win);\\r\\n        \\r\\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\\r\\n\\r\\n        // prepare event data\\r\\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\\r\\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000);\\r\\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\\r\\n        _eventData_.winnerName = plyr_[_winPID].name;\\r\\n        _eventData_.amountWon = _win;\\r\\n        _eventData_.genAmount = _gen;\\r\\n        _eventData_.newPot = _res;\\r\\n\\r\\n        // start next round\\r\\n        rID_++;\\r\\n        _rID++;\\r\\n        round_[_rID].strt = now;\\r\\n        round_[_rID].end = now.add(rndInit_);\\r\\n        round_[_rID].pot = _res;\\r\\n\\r\\n        return (_eventData_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns player info based on address.  if no address is given, it will \\r\\n     * use msg.sender \\r\\n     * @param _addr address of the player you want to lookup \\r\\n     * @return player ID \\r\\n     * @return player name\\r\\n     * @return keys owned (current round)\\r\\n     * @return winnings vault\\r\\n     * @return general vault \\r\\n     * @return affiliate vault \\r\\n\\t * @return player round eth\\r\\n     */\\r\\n    function getPlayerInfoByAddress(address _addr)\\r\\n    public\\r\\n    view\\r\\n    returns (uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\\r\\n    {\\r\\n        // setup local rID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        if (_addr == address(0))\\r\\n        {\\r\\n            _addr == msg.sender;\\r\\n        }\\r\\n        uint256 _pID = pIDxAddr_[_addr];\\r\\n\\r\\n        if (now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].ended == false \\u0026\\u0026 round_[_rID].plyr != 0)\\r\\n        {\\r\\n            // if player is a winner\\r\\n            if (round_[_rID].plyr == _pID)\\r\\n            {\\r\\n                return\\r\\n                (\\r\\n                _pID, //0\\r\\n                plyr_[_pID].name, //1\\r\\n                plyrRnds_[_pID][_rID].keys, //2\\r\\n                (plyr_[_pID].win).add(((round_[_rID].pot).mul(80)) / 100), //3\\r\\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), //4\\r\\n                plyr_[_pID].aff, //5\\r\\n                plyrRnds_[_pID][_rID].eth   //6\\r\\n                );\\r\\n            } else {\\r\\n                return\\r\\n                (\\r\\n                _pID, //0\\r\\n                plyr_[_pID].name, //1\\r\\n                plyrRnds_[_pID][_rID].keys, //2\\r\\n                (plyr_[_pID].win), //3\\r\\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), //4\\r\\n                plyr_[_pID].aff, //5\\r\\n                plyrRnds_[_pID][_rID].eth   //6\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        else{\\r\\n            return\\r\\n            (\\r\\n            _pID, //0\\r\\n            plyr_[_pID].name, //1\\r\\n            plyrRnds_[_pID][_rID].keys, //2\\r\\n            plyr_[_pID].win, //3\\r\\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), //4\\r\\n            plyr_[_pID].aff, //5\\r\\n            plyrRnds_[_pID][_rID].eth   //6\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns all current round info needed for front end\\r\\n     * @return eth invested during ICO phase\\r\\n     * @return round id \\r\\n     * @return total keys for round \\r\\n     * @return time round ends\\r\\n     * @return time round started\\r\\n     * @return current pot \\r\\n     * @return current team ID \\u0026 player ID in lead \\r\\n     * @return current player in leads address \\r\\n     * @return current player in leads name\\r\\n     * @return whales eth in for round\\r\\n     * @return bears eth in for round\\r\\n     * @return sneks eth in for round\\r\\n     * @return bulls eth in for round\\r\\n     * @return airdrop tracker # \\u0026 airdrop pot\\r\\n     */\\r\\n    function getCurrentRoundInfo()\\r\\n    public\\r\\n    view\\r\\n    returns (uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256)\\r\\n    {\\r\\n        // setup local rID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        return\\r\\n        (\\r\\n        _rID, //0\\r\\n        round_[_rID].keys, //1\\r\\n        round_[_rID].end, //2\\r\\n        round_[_rID].strt, //3\\r\\n        round_[_rID].pot, //4\\r\\n        round_[_rID].plyr, // 5\\r\\n        plyr_[round_[_rID].plyr].addr, //6\\r\\n        plyr_[round_[_rID].plyr].name, //7\\r\\n        round_[_rID].eth //8\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns time left.  dont spam this, you\\u0027ll ddos yourself from your node\\r\\n     * provider\\r\\n     * @return time left in seconds\\r\\n     */\\r\\n    function getTimeLeft()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256,uint256,uint256)\\r\\n    {\\r\\n        // setup local rID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        // grab time\\r\\n        uint256 _now = now;\\r\\n\\r\\n        if (_now \\u003c round_[_rID].end)\\r\\n            return((round_[_rID].end),_now, (round_[_rID].end).sub(_now));\\r\\n            // return( );\\r\\n        else\\r\\n            return(0,0,0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev withdraws all of your earnings.\\r\\n     */\\r\\n    function withdraw()\\r\\n    isActivated()\\r\\n    isHuman()\\r\\n    external\\r\\n    {\\r\\n        // setup local rID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        // grab time\\r\\n        uint256 _now = now;\\r\\n\\r\\n        // fetch player ID\\r\\n        uint256 _pID = pIDxAddr_[msg.sender];\\r\\n\\r\\n        // setup temp var for player eth\\r\\n        uint256 _eth;\\r\\n\\r\\n        // check to see if round has ended and no one has run round end yet\\r\\n        if (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].ended == false \\u0026\\u0026 round_[_rID].plyr != 0)\\r\\n        {\\r\\n            // set up our tx event data\\r\\n            F3Ddatasets.EventReturns memory _eventData_;\\r\\n\\r\\n            // end the round (distributes pot)\\r\\n            round_[_rID].ended = true;\\r\\n            _eventData_ = endRound(_eventData_);\\r\\n\\r\\n            // get their earnings\\r\\n            _eth = withdrawEarnings(_pID);\\r\\n\\r\\n            // pay the player\\r\\n            if (_eth \\u003e 0)\\r\\n                plyr_[_pID].addr.transfer(_eth);\\r\\n\\r\\n            // build event data\\r\\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\\r\\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\\r\\n\\r\\n            // fire withdraw and distribute event\\r\\n            emit onWithdrawAndDistribute\\r\\n            (\\r\\n                msg.sender,\\r\\n                plyr_[_pID].name,\\r\\n                _eth,\\r\\n                _eventData_.compressedData,\\r\\n                _eventData_.compressedIDs,\\r\\n                _eventData_.winnerAddr,\\r\\n                _eventData_.winnerName,\\r\\n                _eventData_.amountWon,\\r\\n                _eventData_.genAmount\\r\\n            );\\r\\n        } else {\\r\\n            // in any other situation\\r\\n            // get their earnings\\r\\n            _eth = withdrawEarnings(_pID);\\r\\n\\r\\n            // pay the player\\r\\n            if (_eth \\u003e 0)\\r\\n                plyr_[_pID].addr.transfer(_eth);\\r\\n\\r\\n            // fire withdraw event\\r\\n            emit onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds up unmasked earnings, \\u0026 vault earnings, sets them all to 0\\r\\n     * @return earnings in wei format\\r\\n     */\\r\\n    function withdrawEarnings(uint256 _pID)\\r\\n    private\\r\\n    returns (uint256)\\r\\n    {\\r\\n        // update gen vault\\r\\n        updateGenVault(_pID, plyr_[_pID].lrnd);\\r\\n\\r\\n        // from vault\\r\\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\\r\\n        if (_earnings \\u003e 0)\\r\\n        {\\r\\n            plyr_[_pID].win = 0;\\r\\n            plyr_[_pID].gen = 0;\\r\\n            plyr_[_pID].aff = 0;\\r\\n        }\\r\\n\\r\\n        return (_earnings);\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev returns the amount of keys you would get given an amount of eth. \\r\\n     * @param _rID round ID you want price for\\r\\n     * @param _eth amount of eth sent in \\r\\n     * @return keys received \\r\\n     */\\r\\n    function calcKeysReceived(uint256 _rID, uint256 _eth)\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        // grab time\\r\\n        uint256 _now = now;\\r\\n\\r\\n        // are we in a round?\\r\\n        if (_now \\u003e round_[_rID].strt \\u0026\\u0026 (_now \\u003c= round_[_rID].end || (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].plyr == 0))) {\\r\\n            return keysRec(round_[_rID].eth, _eth);\\r\\n        } else {\\r\\n            // rounds over.  need keys for new round\\r\\n            return keys(_eth);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev returns current eth price for X keys.  \\r\\n     * @param _keys number of keys desired (in 18 decimal format)\\r\\n     * @return amount of eth needed to send\\r\\n     */\\r\\n    function iWantXKeys(uint256 _keys)\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        // setup local rID\\r\\n        uint256 _rID = rID_;\\r\\n\\r\\n        // grab time\\r\\n        uint256 _now = now;\\r\\n\\r\\n        // are we in a round?\\r\\n        if (_now \\u003e round_[_rID].strt \\u0026\\u0026 (_now \\u003c= round_[_rID].end || (_now \\u003e round_[_rID].end \\u0026\\u0026 round_[_rID].plyr == 0)))\\r\\n            return ethRec(round_[_rID].keys + _keys,_keys);\\r\\n        else // rounds over. need price for new round\\r\\n            return eth(_keys);\\r\\n    }\\r\\n\\r\\n    function keysRec(uint256 _curEth, uint256 _newEth) \\r\\n    internal \\r\\n    pure \\r\\n    returns (uint256) \\r\\n    { \\r\\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); \\r\\n    } \\r\\n \\r\\n    function keys(uint256 _eth) \\r\\n    internal \\r\\n    pure \\r\\n    returns(uint256) \\r\\n    { \\r\\n        return (10000*((_eth.mul(1000000000000000000)).sqrt()));\\r\\n    }\\r\\n\\r\\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\\r\\n    internal\\r\\n    pure\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\\r\\n    }\\r\\n\\r\\n    function eth(uint256 _keys)\\r\\n    internal\\r\\n    pure\\r\\n    returns(uint256)\\r\\n    {\\r\\n        return ((10000000000).mul(_keys.sq())) / ((1000000000000000000).sq());\\r\\n    }\\r\\n}\"},\"NameFilter.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nlibrary NameFilter {\\r\\n    /**\\r\\n     * @dev filters name strings\\r\\n     * -converts uppercase to lower case.\\r\\n     * -makes sure it does not start/end with a space\\r\\n     * -makes sure it does not contain multiple spaces in a row\\r\\n     * -cannot be only numbers\\r\\n     * -cannot start with 0x\\r\\n     * -restricts characters to A-Z, a-z, 0-9, and space.\\r\\n     * @return reprocessed string in bytes32 format\\r\\n     */\\r\\n    function nameFilter(string _input)\\r\\n        internal\\r\\n        pure\\r\\n        returns(bytes32)\\r\\n    {\\r\\n        bytes memory _temp = bytes(_input);\\r\\n        uint256 _length = _temp.length;\\r\\n\\r\\n        //sorry limited to 32 characters\\r\\n        require (_length \\u003c= 32 \\u0026\\u0026 _length \\u003e 0, \\\"string must be between 1 and 32 characters\\\");\\r\\n        // make sure it doesnt start with or end with space\\r\\n        require(_temp[0] != 0x20 \\u0026\\u0026 _temp[_length-1] != 0x20, \\\"string cannot start or end with space\\\");\\r\\n        // make sure first two characters are not 0x\\r\\n        if (_temp[0] == 0x30)\\r\\n        {\\r\\n            require(_temp[1] != 0x78, \\\"string cannot start with 0x\\\");\\r\\n            require(_temp[1] != 0x58, \\\"string cannot start with 0X\\\");\\r\\n        }\\r\\n\\r\\n        // create a bool to track if we have a non number character\\r\\n        bool _hasNonNumber;\\r\\n\\r\\n        // convert \\u0026 check\\r\\n        for (uint256 i = 0; i \\u003c _length; i++)\\r\\n        {\\r\\n            // if its uppercase A-Z\\r\\n            if (_temp[i] \\u003e 0x40 \\u0026\\u0026 _temp[i] \\u003c 0x5b)\\r\\n            {\\r\\n                // convert to lower case a-z\\r\\n                _temp[i] = byte(uint(_temp[i]) + 32);\\r\\n\\r\\n                // we have a non number\\r\\n                if (_hasNonNumber == false)\\r\\n                    _hasNonNumber = true;\\r\\n            } else {\\r\\n                require\\r\\n                (\\r\\n                    // require character is a space\\r\\n                    _temp[i] == 0x20 ||\\r\\n                    // OR lowercase a-z\\r\\n                    (_temp[i] \\u003e 0x60 \\u0026\\u0026 _temp[i] \\u003c 0x7b) ||\\r\\n                    // or 0-9\\r\\n                    (_temp[i] \\u003e 0x2f \\u0026\\u0026 _temp[i] \\u003c 0x3a),\\r\\n                    \\\"string contains invalid characters\\\"\\r\\n                );\\r\\n                // make sure theres not 2x spaces in a row\\r\\n                if (_temp[i] == 0x20)\\r\\n                    require( _temp[i+1] != 0x20, \\\"string cannot contain consecutive spaces\\\");\\r\\n\\r\\n                // see if we have a character other than a number\\r\\n                if (_hasNonNumber == false \\u0026\\u0026 (_temp[i] \\u003c 0x30 || _temp[i] \\u003e 0x39))\\r\\n                    _hasNonNumber = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(_hasNonNumber == true, \\\"string cannot be only numbers\\\");\\r\\n\\r\\n        bytes32 _ret;\\r\\n        assembly {\\r\\n            _ret := mload(add(_temp, 32))\\r\\n        }\\r\\n        return (_ret);\\r\\n    }\\r\\n}\"},\"safeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n/**\\r\\n * @title SafeMath v0.1.9\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\\r\\n * - added sqrt\\r\\n * - added sq\\r\\n * - added pwr\\r\\n * - changed asserts to requires with error log outputs\\r\\n * - removed div, its useless\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n    /**\\r\\n    * @dev Multiplies two numbers, throws on overflow.\\r\\n    */\\r\\n    function mul(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 c)\\r\\n    {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath mul failed\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n    */\\r\\n    function sub(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(b \\u003c= a, \\\"SafeMath sub failed\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Adds two numbers, throws on overflow.\\r\\n    */\\r\\n    function add(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 c)\\r\\n    {\\r\\n        c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath add failed\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev gives square root of given x.\\r\\n     */\\r\\n    function sqrt(uint256 x)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 y)\\r\\n    {\\r\\n        uint256 z = ((add(x,1)) / 2);\\r\\n        y = x;\\r\\n        while (z \\u003c y)\\r\\n        {\\r\\n            y = z;\\r\\n            z = ((add((x / z),z)) / 2);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev gives square. multiplies x by x\\r\\n     */\\r\\n    function sq(uint256 x)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (mul(x,x));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev x to the power of y\\r\\n     */\\r\\n    function pwr(uint256 x, uint256 y)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (x==0)\\r\\n            return (0);\\r\\n        else if (y==0)\\r\\n            return (1);\\r\\n        else\\r\\n        {\\r\\n            uint256 z = x;\\r\\n            for (uint256 i=1; i \\u003c y; i++)\\r\\n                z = mul(z,x);\\r\\n            return (z);\\r\\n        }\\r\\n    }\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"names\",\"type\":\"uint256\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmountf\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"}]","ContractName":"Ape3D","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"9999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c6bd45e98946d34d9d4ae21b3c273009bb2b4a76488938472d8a5b26cda16ae2"}]}