{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"temp-contracts/controller/ControllerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\ncontract ControllerConstants {\\n  // Minimum number of tokens in an index.\\n  uint256 public constant MIN_INDEX_SIZE = 2;\\n\\n  // Maximum number of tokens in an index.\\n  uint256 public constant MAX_INDEX_SIZE = 10;\\n\\n  // Minimum balance for a token (only applied at initialization)\\n  uint256 public constant MIN_BALANCE = 1e6;\\n\\n  // Identifier for the pool initializer implementation on the proxy manager.\\n  bytes32 public constant INITIALIZER_IMPLEMENTATION_ID = keccak256(\\\"SigmaPoolInitializerV1.sol\\\");\\n\\n  // Identifier for the unbound token seller implementation on the proxy manager.\\n  bytes32 public constant SELLER_IMPLEMENTATION_ID = keccak256(\\\"SigmaUnboundTokenSellerV1.sol\\\");\\n\\n  // Identifier for the index pool implementation on the proxy manager.\\n  bytes32 public constant POOL_IMPLEMENTATION_ID = keccak256(\\\"SigmaIndexPoolV1.sol\\\");\\n\\n  // Time between reweigh/reindex calls.\\n  uint256 public constant POOL_REWEIGH_DELAY = 1 weeks;\\n\\n  // The number of reweighs which occur before a pool is re-indexed.\\n  uint8 public constant REWEIGHS_BEFORE_REINDEX = 3;\\n\\n  // TWAP parameters for assessing current price\\n  uint32 public constant SHORT_TWAP_MIN_TIME_ELAPSED = 20 minutes;\\n  uint32 public constant SHORT_TWAP_MAX_TIME_ELAPSED = 2 days;\\n}\"\r\n    },\r\n    \"temp-contracts/controller/ScoredTokenLists.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n/* ========== Internal Libraries ========== */\\nimport \\\"../lib/ScoreLibrary.sol\\\";\\n\\n/* ========== Internal Interfaces ========== */\\nimport \\\"../interfaces/ICirculatingMarketCapOracle.sol\\\";\\nimport \\\"../interfaces/IScoringStrategy.sol\\\";\\n\\n/* ========== Internal Inheritance ========== */\\nimport \\\"../OwnableProxy.sol\\\";\\n\\n\\n/**\\n * @title ScoredTokenLists\\n * @author d1ll0n\\n *\\n * @dev This contract stores token lists sorted and filtered using arbitrary scoring strategies.\\n *\\n * Each token list contains an array of tokens, a scoring strategy address, minimum and maximum\\n * scores for the list, and a mapping for which tokens are included.\\n *\\n * A scoring strategy is a smart contract which implements the `getTokenScores`, which scores\\n * tokens using an arbitrary methodology.\\n *\\n * Token lists are sorted in descending order by the scores returned by the list's scoring strategy,\\n * and filtered according to the minimum/maximum scores.\\n *\\n * The contract owner can create a new token list with a metadata hash used to query\\n * additional details about its purpose and inclusion criteria from IPFS.\\n *\\n * The owner can add and remove tokens from the lists.\\n */\\ncontract ScoredTokenLists is OwnableProxy {\\n  using ScoreLibrary for address[];\\n  using ScoreLibrary for uint256[];\\n  using ScoreLibrary for uint256;\\n\\n/* ==========  Constants  ========== */\\n  // Maximum number of tokens in a token list\\n  uint256 public constant MAX_LIST_TOKENS = 25;\\n\\n  // Uniswap TWAP oracle\\n  IIndexedUniswapV2Oracle public immutable uniswapOracle;\\n\\n/* ==========  Events  ========== */\\n\\n  /** @dev Emitted when a new token list is created. */\\n  event TokenListAdded(\\n    uint256 listID,\\n    bytes32 metadataHash,\\n    address scoringStrategy,\\n    uint128 minimumScore,\\n    uint128 maximumScore\\n  );\\n\\n  /** @dev Emitted when a token list is sorted and filtered. */\\n  event TokenListSorted(uint256 listID);\\n\\n  /** @dev Emitted when a token is added to a list. */\\n  event TokenAdded(address token, uint256 listID);\\n\\n  /** @dev Emitted when a token is removed from a list. */\\n  event TokenRemoved(address token, uint256 listID);\\n\\n/* ==========  Structs  ========== */\\n\\n  /**\\n   * @dev Token list storage structure.\\n   * @param minimumScore Minimum market cap for included tokens\\n   * @param maximumScore Maximum market cap for included tokens\\n   * @param scoringStrategy Address of the scoring strategy contract used\\n   * @param tokens Array of included tokens\\n   * @param isIncludedToken Mapping of included tokens\\n   */\\n  struct TokenList {\\n    uint128 minimumScore;\\n    uint128 maximumScore;\\n    address scoringStrategy;\\n    address[] tokens;\\n    mapping(address => bool) isIncludedToken;\\n  }\\n\\n/* ==========  Storage  ========== */\\n\\n  // Chainlink or other circulating market cap oracle\\n  ICirculatingMarketCapOracle public circulatingMarketCapOracle;\\n\\n  // Number of categories that exist.\\n  uint256 public tokenListCount;\\n  mapping(uint256 => TokenList) internal _lists;\\n\\n/* ========== Modifiers ========== */\\n\\n  modifier validTokenList(uint256 listID) {\\n    require(listID <= tokenListCount && listID > 0, \\\"ERR_LIST_ID\\\");\\n    _;\\n  }\\n\\n/* ==========  Constructor  ========== */\\n\\n  /**\\n   * @dev Deploy the controller and configure the addresses\\n   * of the related contracts.\\n   */\\n  constructor(IIndexedUniswapV2Oracle _oracle) public OwnableProxy() {\\n    uniswapOracle = _oracle;\\n  }\\n\\n/* ==========  Configuration  ========== */\\n\\n  /**\\n   * @dev Initialize the categories with the owner address.\\n   * This sets up the contract which is deployed as a singleton proxy.\\n   */\\n  function initialize() public virtual {\\n    _initializeOwnership();\\n  }\\n\\n/* ==========  Permissioned List Management  ========== */\\n\\n  /**\\n   * @dev Creates a new token list.\\n   *\\n   * @param metadataHash Hash of metadata about the token list which can\\n   * be distributed on IPFS.\\n   */\\n  function createTokenList(\\n    bytes32 metadataHash,\\n    address scoringStrategy,\\n    uint128 minimumScore,\\n    uint128 maximumScore\\n  )\\n    external\\n    onlyOwner\\n  {\\n    require(minimumScore > 0, \\\"ERR_NULL_MIN_CAP\\\");\\n    require(maximumScore > minimumScore, \\\"ERR_MAX_CAP\\\");\\n    require(scoringStrategy != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    uint256 listID = ++tokenListCount;\\n    TokenList storage list = _lists[listID];\\n    list.scoringStrategy = scoringStrategy;\\n    list.minimumScore = minimumScore;\\n    list.maximumScore = maximumScore;\\n    emit TokenListAdded(listID, metadataHash, scoringStrategy, minimumScore, maximumScore);\\n  }\\n\\n  /**\\n   * @dev Adds a new token to a token list.\\n   *\\n   * @param listID Token list identifier.\\n   * @param token Token to add to the list.\\n   */\\n  function addToken(uint256 listID, address token) external onlyOwner validTokenList(listID) {\\n    TokenList storage list = _lists[listID];\\n    require(\\n      list.tokens.length < MAX_LIST_TOKENS,\\n      \\\"ERR_MAX_LIST_TOKENS\\\"\\n    );\\n    _addToken(list, token);\\n    uniswapOracle.updatePrice(token);\\n    emit TokenAdded(token, listID);\\n  }\\n\\n  /**\\n   * @dev Add tokens to a token list.\\n   *\\n   * @param listID Token list identifier.\\n   * @param tokens Array of tokens to add to the list.\\n   */\\n  function addTokens(uint256 listID, address[] calldata tokens)\\n    external\\n    onlyOwner\\n    validTokenList(listID)\\n  {\\n    TokenList storage list = _lists[listID];\\n    require(\\n      list.tokens.length + tokens.length <= MAX_LIST_TOKENS,\\n      \\\"ERR_MAX_LIST_TOKENS\\\"\\n    );\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tokens[i];\\n      _addToken(list, token);\\n      emit TokenAdded(token, listID);\\n    }\\n    uniswapOracle.updatePrices(tokens);\\n  }\\n\\n  /**\\n   * @dev Remove token from a token list.\\n   *\\n   * @param listID Token list identifier.\\n   * @param token Token to remove from the list.\\n   */\\n  function removeToken(uint256 listID, address token) external onlyOwner validTokenList(listID) {\\n    TokenList storage list = _lists[listID];\\n    uint256 i = 0;\\n    uint256 len = list.tokens.length;\\n    require(len > 0, \\\"ERR_EMPTY_LIST\\\");\\n    require(list.isIncludedToken[token], \\\"ERR_TOKEN_NOT_BOUND\\\");\\n    list.isIncludedToken[token] = false;\\n    for (; i < len; i++) {\\n      if (list.tokens[i] == token) {\\n        uint256 last = len - 1;\\n        if (i != last) {\\n          address lastToken = list.tokens[last];\\n          list.tokens[i] = lastToken;\\n        }\\n        list.tokens.pop();\\n        emit TokenRemoved(token, listID);\\n        return;\\n      }\\n    }\\n  }\\n\\n/* ==========  Public List Updates  ========== */\\n\\n  /**\\n   * @dev Updates the prices on the Uniswap oracle for all the tokens in a token list.\\n   */\\n  function updateTokenPrices(uint256 listID)\\n    external\\n    validTokenList(listID)\\n    returns (bool[] memory pricesUpdated)\\n  {\\n    pricesUpdated = uniswapOracle.updatePrices(_lists[listID].tokens);\\n  }\\n\\n  /**\\n   * @dev Returns the tokens and scores in the token list for `listID` after\\n   * sorting and filtering the tokens according to the list's configuration.\\n   */\\n  function sortAndFilterTokens(uint256 listID)\\n    external\\n    validTokenList(listID)\\n  {\\n    TokenList storage list = _lists[listID];\\n    address[] memory tokens = list.tokens;\\n    uint256[] memory marketCaps = IScoringStrategy(list.scoringStrategy).getTokenScores(tokens);\\n    address[] memory removedTokens = tokens.sortAndFilterReturnRemoved(\\n      marketCaps,\\n      list.minimumScore,\\n      list.maximumScore\\n    );\\n    _lists[listID].tokens = tokens;\\n    for (uint256 i = 0; i < removedTokens.length; i++) {\\n      address token = removedTokens[i];\\n      list.isIncludedToken[token] = false;\\n      emit TokenRemoved(token, listID);\\n    }\\n  }\\n\\n\\n/* ==========  Score Queries  ========== */\\n\\n  /**\\n   * @dev Returns the tokens and market caps for `catego\\n   */\\n  function getSortedAndFilteredTokensAndScores(uint256 listID)\\n    public\\n    view\\n    validTokenList(listID)\\n    returns (\\n      address[] memory tokens,\\n      uint256[] memory scores\\n    )\\n  {\\n    TokenList storage list = _lists[listID];\\n    tokens = list.tokens;\\n    scores = IScoringStrategy(list.scoringStrategy).getTokenScores(tokens);\\n    tokens.sortAndFilter(\\n      scores,\\n      list.minimumScore,\\n      list.maximumScore\\n    );\\n  }\\n\\n/* ==========  Token List Queries  ========== */\\n\\n  /**\\n   * @dev Returns boolean stating whether `token` is a member of the list `listID`.\\n   */\\n  function isTokenInlist(uint256 listID, address token)\\n    external\\n    view\\n    validTokenList(listID)\\n    returns (bool)\\n  {\\n    return _lists[listID].isIncludedToken[token];\\n  }\\n\\n  /**\\n   * @dev Returns the array of tokens in a list.\\n   */\\n  function getTokenList(uint256 listID)\\n    external\\n    view\\n    validTokenList(listID)\\n    returns (address[] memory tokens)\\n  {\\n    tokens = _lists[listID].tokens;\\n  }\\n\\n  /**\\n   * @dev Returns the top `count` tokens and market caps in the list for `listID`\\n   * after sorting and filtering the tokens according to the list's configuration.\\n   */\\n  function getTopTokensAndScores(uint256 listID, uint256 count)\\n    public\\n    view\\n    validTokenList(listID)\\n    returns (\\n      address[] memory tokens,\\n      uint256[] memory scores\\n    )\\n  {\\n    (tokens, scores) = getSortedAndFilteredTokensAndScores(listID);\\n    require(count <= tokens.length, \\\"ERR_LIST_SIZE\\\");\\n    assembly {\\n      mstore(tokens, count)\\n      mstore(scores, count)\\n    }\\n  }\\n\\n  /**\\n   * @dev Query the configuration values for a token list.\\n   *\\n   * @param listID Identifier for the token list\\n   * @return scoringStrategy Address of the scoring strategy contract used\\n   * @return minimumScore Minimum market cap for an included token\\n   * @return maximumScore Maximum market cap for an included token\\n   */\\n  function getTokenListConfig(uint256 listID)\\n    external\\n    view\\n    validTokenList(listID)\\n    returns (\\n      address scoringStrategy,\\n      uint128 minimumScore,\\n      uint128 maximumScore\\n    )\\n  {\\n    TokenList storage list = _lists[listID];\\n    scoringStrategy = list.scoringStrategy;\\n    minimumScore = list.minimumScore;\\n    maximumScore = list.maximumScore;\\n  }\\n\\n  function getTokenScores(uint256 listID, address[] memory tokens)\\n    public\\n    view\\n    validTokenList(listID)\\n    returns (uint256[] memory scores)\\n  {\\n    scores = IScoringStrategy(_lists[listID].scoringStrategy).getTokenScores(tokens);\\n  }\\n\\n/* ==========  Token List Utility Functions  ========== */\\n\\n  /**\\n   * @dev Adds a new token to a list.\\n   */\\n  function _addToken(TokenList storage list, address token) internal {\\n    require(!list.isIncludedToken[token], \\\"ERR_TOKEN_BOUND\\\");\\n    list.isIncludedToken[token] = true;\\n    list.tokens.push(token);\\n  }\\n}\\n\\ninterface IIndexedUniswapV2Oracle {\\n\\n  function updatePrice(address token) external returns (bool);\\n\\n  function updatePrices(address[] calldata tokens) external returns (bool[] memory);\\n\\n  function computeAverageEthForTokens(\\n    address[] calldata tokens,\\n    uint256[] calldata tokenAmounts,\\n    uint256 minTimeElapsed,\\n    uint256 maxTimeElapsed\\n  ) external view returns (uint256[] memory);\\n\\n  function computeAverageEthForTokens(\\n    address token,\\n    uint256 tokenAmount,\\n    uint256 minTimeElapsed,\\n    uint256 maxTimeElapsed\\n  ) external view returns (uint256);\\n\\n  function computeAverageTokensForEth(\\n    address[] calldata tokens,\\n    uint256[] calldata ethAmounts,\\n    uint256 minTimeElapsed,\\n    uint256 maxTimeElapsed\\n  ) external view returns (uint256[] memory);\\n\\n  function computeAverageTokensForEth(\\n    address token,\\n    uint256 ethAmount,\\n    uint256 minTimeElapsed,\\n    uint256 maxTimeElapsed\\n  ) external view returns (uint256);\\n}\"\r\n    },\r\n    \"temp-contracts/lib/ScoreLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n/* ========== External Libraries ========== */\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n\\nlibrary ScoreLibrary {\\n  using SafeMath for uint256;\\n\\n  // Default total weight for a pool.\\n  uint256 internal constant WEIGHT_MULTIPLIER = 25e18;\\n\\n  function computeProportionalAmounts(uint256 total, uint256[] memory scores)\\n    internal\\n    pure\\n    returns(uint256[] memory values)\\n  {\\n    uint256 sum;\\n    uint256 len = scores.length;\\n    values = new uint256[](len);\\n    for (uint256 i = 0; i < len; i++) {\\n      sum = sum.add(scores[i]);\\n    }\\n    uint256 denormalizedSum = sum * 1e18;\\n    uint256 denormalizedTotal = total * 1e18;\\n    for (uint256 i = 0; i < len; i++) {\\n      values[i] = scores[i].mul(denormalizedTotal).div(denormalizedSum);\\n    }\\n  }\\n\\n  function computeDenormalizedWeights(uint256[] memory values)\\n    internal\\n    pure\\n    returns (uint96[] memory weights)\\n  {\\n    uint256 sum;\\n    uint256 len = values.length;\\n    weights = new uint96[](len);\\n    for (uint256 i = 0; i < len; i++) {\\n      sum = sum.add(values[i]);\\n    }\\n    for (uint256 i = 0; i < len; i++) {\\n      weights[i] = _safeUint96(values[i].mul(WEIGHT_MULTIPLIER).div(sum));\\n    }\\n  }\\n\\n  /**\\n   * @dev Given a list of tokens and their scores, sort by scores\\n   * in descending order, and filter out the tokens with scores that\\n   * are not within the min/max bounds provided.\\n   */\\n  function sortAndFilter(\\n    address[] memory tokens,\\n    uint256[] memory scores,\\n    uint256 minimumScore,\\n    uint256 maximumScore\\n  ) internal pure {\\n    uint256 len = tokens.length;\\n    for (uint256 i = 0; i < len; i++) {\\n      uint256 cap = scores[i];\\n      address token = tokens[i];\\n      if (cap > maximumScore || cap < minimumScore) {\\n        token = tokens[--len];\\n        cap = scores[len];\\n        scores[i] = cap;\\n        tokens[i] = token;\\n        i--;\\n        continue;\\n      }\\n      uint256 j = i - 1;\\n      while (int(j) >= 0 && scores[j] < cap) {\\n        scores[j + 1] = scores[j];\\n        tokens[j + 1] = tokens[j];\\n        j--;\\n      }\\n      scores[j + 1] = cap;\\n      tokens[j + 1] = token;\\n    }\\n    if (len != tokens.length) {\\n      assembly {\\n        mstore(tokens, len)\\n        mstore(scores, len)\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Given a list of tokens and their scores, sort by scores\\n   * in descending order, and filter out the tokens with scores that\\n   * are not within the min/max bounds provided.\\n   * This function also returns the list of removed tokens.\\n   */\\n  function sortAndFilterReturnRemoved(\\n    address[] memory tokens,\\n    uint256[] memory scores,\\n    uint256 minimumScore,\\n    uint256 maximumScore\\n  ) internal pure returns (address[] memory removed) {\\n    uint256 removedIndex = 0;\\n    uint256 len = tokens.length;\\n    removed = new address[](len);\\n    for (uint256 i = 0; i < len; i++) {\\n      uint256 cap = scores[i];\\n      address token = tokens[i];\\n      if (cap > maximumScore || cap < minimumScore) {\\n        removed[removedIndex++] = token;\\n        token = tokens[--len];\\n        cap = scores[len];\\n        scores[i] = cap;\\n        tokens[i] = token;\\n        i--;\\n        continue;\\n      }\\n      uint256 j = i - 1;\\n      while (int(j) >= 0 && scores[j] < cap) {\\n        scores[j + 1] = scores[j];\\n        tokens[j + 1] = tokens[j];\\n        j--;\\n      }\\n      scores[j + 1] = cap;\\n      tokens[j + 1] = token;\\n    }\\n    if (len != tokens.length) {\\n      assembly {\\n        mstore(tokens, len)\\n        mstore(scores, len)\\n        mstore(removed, removedIndex)\\n      }\\n    }\\n  }\\n\\n  function _safeUint96(uint256 x) internal pure returns (uint96 y) {\\n    y = uint96(x);\\n    require(y == x, \\\"ERR_MAX_UINT96\\\");\\n  }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/interfaces/ICirculatingMarketCapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n\\ninterface ICirculatingMarketCapOracle {\\n  function getCirculatingMarketCap(address) external view returns (uint256);\\n\\n  function getCirculatingMarketCaps(address[] calldata) external view returns (uint256[] memory);\\n\\n  function updateCirculatingMarketCaps(address[] calldata) external;\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IScoringStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\ninterface IScoringStrategy {\\n  function getTokenScores(address[] calldata tokens) external view returns (uint256[] memory scores);\\n}\"\r\n    },\r\n    \"temp-contracts/OwnableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This is a modified implementation of OpenZeppelin's Ownable.sol.\\n * The modifications allow the contract to be inherited by a proxy's logic contract.\\n * Any owner-only functions on the base implementation will be unusable.\\n *\\n * By default, the owner account will be a null address which can be set by the\\n * first call to {initializeOwner}. This can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner. It also makes the function {initializeOwner} available to be used\\n * in the initialization function for the inherited contract.\\n *\\n * Note: This contract should only be inherited by proxy implementation contracts\\n * where the implementation will only ever be used as the logic address for proxies.\\n * The constructor permanently locks the owner of the implementation contract, but the\\n * owner of the proxies can be configured by the first caller.\\n */\\ncontract OwnableProxy is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  constructor() public {\\n    _owner = address(1);\\n    emit OwnershipTransferred(address(0), address(1));\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    // Modified from OZ contract - sets owner to address(1) to prevent\\n    // _initializeOwnership from being called after ownership is revoked.\\n    emit OwnershipTransferred(_owner, address(1));\\n    _owner = address(1);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n\\n  /**\\n   * @dev Initializes the contract setting the initializer as the initial owner.\\n   * Note: Owner address must be zero.\\n   */\\n  function _initializeOwnership() internal {\\n    require(_owner == address(0), \\\"Ownable: owner has already been initialized\\\");\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  /**\\n   * @dev Initializes the contract setting the owner to an invalid address.\\n   * This ensures that the contract can never be owned, and should only be used\\n   * in the constructor of a proxy's implementation contract.\\n   * Note: Owner address must be zero.\\n   */\\n  function _lockImplementationOwner() internal {\\n    require(_owner == address(0), \\\"Ownable: owner has already been initialized\\\");\\n    emit OwnershipTransferred(address(0), address(1));\\n    _owner = address(1);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/controller/SigmaControllerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n/* ========== External Interfaces ========== */\\nimport \\\"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/* ========== External Libraries ========== */\\nimport \\\"@indexed-finance/proxies/contracts/SaltyLib.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/* ========== Internal Interfaces ========== */\\nimport \\\"../interfaces/IIndexPool.sol\\\";\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"../interfaces/IPoolInitializer.sol\\\";\\nimport \\\"../interfaces/IUnboundTokenSeller.sol\\\";\\n\\n/* ========== Internal Inheritance ========== */\\nimport \\\"./ScoredTokenLists.sol\\\";\\nimport \\\"./ControllerConstants.sol\\\";\\n\\n\\n/**\\n * @title SigmaControllerV1\\n * @author d1ll0n\\n * @dev This contract is used to deploy and manage index pools.\\n * It implements the methodology for rebalancing and asset selection, as well as other\\n * controls such as pausing public swaps and managing fee configuration.\\n *\\n * ===== Pool Configuration =====\\n * When an index pool is deployed, it is assigned a token list and a target size.\\n *\\n * The token list is the set of tokens and configuration used for selecting and weighting\\n * assets, which is detailed in the documentation for the ScoredTokenLists contract.\\n *\\n * The size is the target number of underlying assets held by the pool, it is used to determine\\n * which assets the pool will hold.\\n *\\n * The list's scoring strategy is used to assign weights.\\n *\\n * ===== Asset Selection =====\\n * When the pool is deployed and when it is re-indexed, the top assets from the pool's token list\\n * are selected using the index size. They are selected after sorting the token list in descending\\n * order by the scores of tokens.\\n *\\n * ===== Rebalancing =====\\n * Every week, pools are either re-weighed or re-indexed.\\n * They are re-indexed once for every three re-weighs.\\n * The contract owner can also force a reindex out of the normal schedule.\\n *\\n * Re-indexing involves re-selecting the top tokens from the pool's token list using the pool's index\\n * size, assigning target weights and setting balance targets for new tokens.\\n *\\n * Re-weighing involves assigning target weights to only the tokens already included in the pool.\\n *\\n * ===== Toggling Swaps =====\\n * The contract owner can set a circuitBreaker address which is allowed to toggle public swaps on index pools.\\n * The contract owner also has the ability to toggle swaps.\\n * \\n * ===== Fees =====\\n * The contract owner can change the swap fee on index pools, and can change the premium paid on swaps in the\\n * unbound token seller contracts.\\n */\\ncontract SigmaControllerV1 is ScoredTokenLists, ControllerConstants {\\n  using SafeMath for uint256;\\n\\n/* ==========  Constants  ========== */\\n  // Pool factory contract\\n  IPoolFactory public immutable poolFactory;\\n\\n  // Proxy manager & factory\\n  IDelegateCallProxyManager public immutable proxyManager;\\n\\n  // Governance address\\n  address public immutable governance;\\n\\n/* ==========  Events  ========== */\\n\\n  /** @dev Emitted when a pool is initialized and made public. */\\n  event PoolInitialized(\\n    address pool,\\n    address unboundTokenSeller,\\n    uint256 listID,\\n    uint256 indexSize\\n  );\\n\\n  /** @dev Emitted when a pool and its initializer are deployed. */\\n  event NewPoolInitializer(\\n    address pool,\\n    address initializer,\\n    uint256 listID,\\n    uint256 indexSize\\n  );\\n\\n  /** @dev Emitted when a pool is reweighed. */\\n  event PoolReweighed(address pool);\\n\\n  /** @dev Emitted when a pool is reindexed. */\\n  event PoolReindexed(address pool);\\n\\n/* ==========  Structs  ========== */\\n\\n  /**\\n   * @dev Data structure with metadata about an index pool.\\n   *\\n   * Includes the number of times a pool has been either reweighed\\n   * or re-indexed, as well as the timestamp of the last such action.\\n   *\\n   * To reweigh or re-index, the last update must have occurred at\\n   * least `POOL_REWEIGH_DELAY` seconds ago.\\n   *\\n   * If `++index % REWEIGHS_BEFORE_REINDEX + 1` is 0, the pool will\\n   * re-index, otherwise it will reweigh.\\n   *\\n   * The struct fields are assigned their respective integer sizes so\\n   * that solc can pack the entire struct into a single storage slot.\\n   * `reweighIndex` is intended to overflow, `listID` will never\\n   * reach 2**16, `indexSize` is capped at 10 and it is unlikely that\\n   * this protocol will be in use in the year 292277026596 (unix time\\n   * for 2**64 - 1).\\n   *\\n   * @param initialized Whether the pool has been initialized with the\\n   * starting balances.\\n   * @param listID Token list identifier for the pool.\\n   * @param indexSize Number of tokens the pool should hold.\\n   * @param reweighIndex Number of times the pool has either re-weighed or re-indexed\\n   * @param lastReweigh Timestamp of last pool re-weigh or re-index\\n   */\\n  struct IndexPoolMeta {\\n    bool initialized;\\n    uint16 listID;\\n    uint8 indexSize;\\n    uint8 reweighIndex;\\n    uint64 lastReweigh;\\n  }\\n\\n/* ==========  Storage  ========== */\\n\\n  // Default slippage rate for token seller contracts.\\n  uint8 public defaultSellerPremium;\\n\\n  // Metadata about index pools\\n  mapping(address => IndexPoolMeta) public indexPoolMetadata;\\n\\n  // Address able to halt swaps\\n  address public circuitBreaker;\\n\\n  // Exit fee recipient for the index pools\\n  address public defaultExitFeeRecipient;\\n\\n/* ========== Modifiers ========== */\\n\\n  modifier isInitializedPool(address poolAddress) {\\n    require(\\n      indexPoolMetadata[poolAddress].initialized,\\n      \\\"ERR_POOL_NOT_FOUND\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyInitializer(address poolAddress) {\\n    require(\\n      msg.sender == computeInitializerAddress(poolAddress),\\n      \\\"ERR_NOT_PRE_DEPLOY_POOL\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\\"ERR_NOT_GOVERNANCE\\\");\\n    _;\\n  }\\n\\n/* ==========  Constructor  ========== */\\n\\n  /**\\n   * @dev Deploy the controller and configure the addresses\\n   * of the related accounts.\\n   */\\n  constructor(\\n    IIndexedUniswapV2Oracle uniswapOracle_,\\n    IPoolFactory poolFactory_,\\n    IDelegateCallProxyManager proxyManager_,\\n    address governance_\\n  )\\n    public\\n    ScoredTokenLists(uniswapOracle_)\\n  {\\n    poolFactory = poolFactory_;\\n    proxyManager = proxyManager_;\\n    governance = governance_;\\n  }\\n\\n/* ==========  Initializer  ========== */\\n\\n  /**\\n   * @dev Initialize the controller with the owner address and default seller premium.\\n   * This sets up the controller which is deployed as a singleton proxy.\\n   */\\n  function initialize(address circuitBreaker_) public {\\n    super.initialize();\\n    defaultSellerPremium = 2;\\n    circuitBreaker = circuitBreaker_;\\n  }\\n\\n/* ==========  Configuration  ========== */\\n\\n  /**\\n   * @dev Sets the default premium rate for token seller contracts.\\n   */\\n  function setDefaultSellerPremium(uint8 _defaultSellerPremium) external onlyOwner {\\n    require(_defaultSellerPremium > 0 && _defaultSellerPremium < 20, \\\"ERR_PREMIUM\\\");\\n    defaultSellerPremium = _defaultSellerPremium;\\n  }\\n\\n  /**\\n   * @dev Sets the circuit breaker address allowed to toggle public swaps.\\n   */\\n  function setCircuitBreaker(address circuitBreaker_) external onlyOwner {\\n    circuitBreaker = circuitBreaker_;\\n  }\\n\\n  /**\\n   * @dev Sets the default exit fee recipient for new pools.\\n   */\\n  function setDefaultExitFeeRecipient(address defaultExitFeeRecipient_) external onlyGovernance {\\n    require(defaultExitFeeRecipient_ != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    defaultExitFeeRecipient = defaultExitFeeRecipient_;\\n  }\\n\\n/* ==========  Pool Deployment  ========== */\\n\\n  /**\\n   * @dev Deploys an index pool and a pool initializer.\\n   * The initializer contract is a pool with specific token\\n   * balance targets which gives pool tokens in the finished\\n   * pool to users who provide the underlying tokens needed\\n   * to initialize it.\\n   */\\n  function prepareIndexPool(\\n    uint256 listID,\\n    uint256 indexSize,\\n    uint256 initialWethValue,\\n    string calldata name,\\n    string calldata symbol\\n  )\\n    external\\n    onlyOwner\\n    returns (address poolAddress, address initializerAddress)\\n  {\\n    require(indexSize >= MIN_INDEX_SIZE, \\\"ERR_MIN_INDEX_SIZE\\\");\\n    require(indexSize <= MAX_INDEX_SIZE, \\\"ERR_MAX_INDEX_SIZE\\\");\\n    require(initialWethValue < uint144(-1), \\\"ERR_MAX_UINT144\\\");\\n\\n    poolAddress = poolFactory.deployPool(\\n      POOL_IMPLEMENTATION_ID,\\n      keccak256(abi.encodePacked(listID, indexSize))\\n    );\\n    IIndexPool(poolAddress).configure(address(this), name, symbol);\\n\\n    indexPoolMetadata[poolAddress] = IndexPoolMeta({\\n      initialized: false,\\n      listID: uint16(listID),\\n      indexSize: uint8(indexSize),\\n      lastReweigh: 0,\\n      reweighIndex: 0\\n    });\\n\\n    initializerAddress = proxyManager.deployProxyManyToOne(\\n      INITIALIZER_IMPLEMENTATION_ID,\\n      keccak256(abi.encodePacked(poolAddress))\\n    );\\n\\n    IPoolInitializer initializer = IPoolInitializer(initializerAddress);\\n\\n    // Get the initial tokens and balances for the pool.\\n    (address[] memory tokens, uint256[] memory balances) = getInitialTokensAndBalances(\\n      listID,\\n      indexSize,\\n      uint144(initialWethValue)\\n    );\\n\\n    initializer.initialize(address(this), poolAddress, tokens, balances);\\n\\n    emit NewPoolInitializer(\\n      poolAddress,\\n      initializerAddress,\\n      listID,\\n      indexSize\\n    );\\n  }\\n\\n  /**\\n   * @dev Initializes a pool which has been deployed but not initialized\\n   * and transfers the underlying tokens from the initialization pool to\\n   * the actual pool.\\n   *\\n   * The actual weights assigned to tokens is calculated based on the\\n   * relative values of the acquired balances, rather than the initial\\n   * weights computed from the token scores.\\n   */\\n  function finishPreparedIndexPool(\\n    address poolAddress,\\n    address[] calldata tokens,\\n    uint256[] calldata balances\\n  )\\n    external\\n    onlyInitializer(poolAddress)\\n  {\\n    uint256 len = tokens.length;\\n    require(balances.length == len, \\\"ERR_ARR_LEN\\\");\\n\\n    IndexPoolMeta memory meta = indexPoolMetadata[poolAddress];\\n    require(!meta.initialized, \\\"ERR_INITIALIZED\\\");\\n\\n    uint256[] memory ethValues = uniswapOracle.computeAverageEthForTokens(\\n      tokens,\\n      balances,\\n      SHORT_TWAP_MIN_TIME_ELAPSED,\\n      SHORT_TWAP_MAX_TIME_ELAPSED\\n    );\\n    uint96[] memory denormalizedWeights = ethValues.computeDenormalizedWeights();\\n\\n    address sellerAddress = proxyManager.deployProxyManyToOne(\\n      SELLER_IMPLEMENTATION_ID,\\n      keccak256(abi.encodePacked(poolAddress))\\n    );\\n\\n    IIndexPool(poolAddress).initialize(\\n      tokens,\\n      balances,\\n      denormalizedWeights,\\n      msg.sender,\\n      sellerAddress,\\n      defaultExitFeeRecipient\\n    );\\n\\n    IUnboundTokenSeller(sellerAddress).initialize(\\n      address(this),\\n      poolAddress,\\n      defaultSellerPremium\\n    );\\n\\n    meta.lastReweigh = uint64(now);\\n    meta.initialized = true;\\n    indexPoolMetadata[poolAddress] = meta;\\n\\n    emit PoolInitialized(\\n      poolAddress,\\n      sellerAddress,\\n      meta.listID,\\n      meta.indexSize\\n    );\\n  }\\n\\n/* ==========  Pool Management  ========== */\\n\\n  /**\\n   * @dev Sets the premium rate on `sellerAddress` to the given rate.\\n   */\\n  function updateSellerPremium(address tokenSeller, uint8 premiumPercent) external onlyOwner {\\n    require(premiumPercent > 0 && premiumPercent < 20, \\\"ERR_PREMIUM\\\");\\n    IUnboundTokenSeller(tokenSeller).setPremiumPercent(premiumPercent);\\n  }\\n\\n  /**\\n   * @dev Sets the controller on an index pool.\\n   */\\n  function setController(address poolAddress, address controller) external isInitializedPool(poolAddress) onlyGovernance {\\n    IIndexPool(poolAddress).setController(controller);\\n  }\\n\\n  /**\\n   * @dev Sets the exit fee recipient for an existing pool.\\n   */\\n  function setExitFeeRecipient(address poolAddress, address exitFeeRecipient) external isInitializedPool(poolAddress) onlyGovernance {\\n    IIndexPool(poolAddress).setExitFeeRecipient(exitFeeRecipient);\\n  }\\n\\n  /**\\n   * @dev Sets the exit fee recipient on multiple existing pools.\\n   */\\n  function setExitFeeRecipient(address[] calldata poolAddresses, address exitFeeRecipient) external onlyGovernance {\\n    for (uint256 i = 0; i < poolAddresses.length; i++) {\\n      address poolAddress = poolAddresses[i];\\n      require(indexPoolMetadata[poolAddress].initialized, \\\"ERR_POOL_NOT_FOUND\\\");\\n      // No not-null requirement - already in pool function.\\n      IIndexPool(poolAddress).setExitFeeRecipient(exitFeeRecipient);\\n    }\\n  }\\n\\n  /**\\n   * @dev Sets the swap fee on multiple index pools.\\n   */\\n  function setSwapFee(address poolAddress, uint256 swapFee) external onlyGovernance isInitializedPool(poolAddress) {\\n    IIndexPool(poolAddress).setSwapFee(swapFee);\\n  }\\n\\n  /**\\n   * @dev Sets the swap fee on an index pool.\\n   */\\n  function setSwapFee(address[] calldata poolAddresses, uint256 swapFee) external onlyGovernance {\\n    for (uint256 i = 0; i < poolAddresses.length; i++) {\\n      address poolAddress = poolAddresses[i];\\n      require(indexPoolMetadata[poolAddress].initialized, \\\"ERR_POOL_NOT_FOUND\\\");\\n      // No not-null requirement - already in pool function.\\n      IIndexPool(poolAddress).setSwapFee(swapFee);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the minimum balance of an uninitialized token, which is\\n   * useful when the token's price on the pool is too low relative to\\n   * external prices for people to trade it in.\\n   */\\n  function updateMinimumBalance(address pool, address tokenAddress) external isInitializedPool(address(pool)) {\\n    IIndexPool.Record memory record = IIndexPool(pool).getTokenRecord(tokenAddress);\\n    require(!record.ready, \\\"ERR_TOKEN_READY\\\");\\n    uint256 poolValue = _estimatePoolValue(pool);\\n    uint256 minimumBalance = uniswapOracle.computeAverageTokensForEth(\\n      tokenAddress,\\n      poolValue / 100,\\n      SHORT_TWAP_MIN_TIME_ELAPSED,\\n      SHORT_TWAP_MAX_TIME_ELAPSED\\n    );\\n    IIndexPool(pool).setMinimumBalance(tokenAddress, minimumBalance);\\n  }\\n\\n  /**\\n   * @dev Delegates a comp-like governance token from an index pool to a provided address.\\n   */\\n  function delegateCompLikeTokenFromPool(\\n    address pool,\\n    address token,\\n    address delegatee\\n  )\\n    external\\n    onlyOwner\\n    isInitializedPool(pool)\\n  {\\n    IIndexPool(pool).delegateCompLikeToken(token, delegatee);\\n  }\\n\\n  /**\\n   * @dev Enable/disable public swaps on an index pool.\\n   * Callable by the contract owner and the `circuitBreaker` address.\\n   */\\n  function setPublicSwap(address indexPool_, bool publicSwap) external isInitializedPool(indexPool_) {\\n    require(\\n      msg.sender == circuitBreaker || msg.sender == owner(),\\n      \\\"ERR_NOT_AUTHORIZED\\\"\\n    );\\n    IIndexPool(indexPool_).setPublicSwap(publicSwap);\\n  }\\n\\n/* ==========  Pool Rebalance Actions  ========== */\\n\\n  /**\\n   * @dev Re-indexes a pool by setting the underlying assets to the top\\n   * tokens in its candidates list by score.\\n   */\\n  function reindexPool(address poolAddress) external {\\n    IndexPoolMeta storage meta = indexPoolMetadata[poolAddress];\\n    require(meta.initialized, \\\"ERR_POOL_NOT_FOUND\\\");\\n    require(\\n      now - meta.lastReweigh >= POOL_REWEIGH_DELAY,\\n      \\\"ERR_POOL_REWEIGH_DELAY\\\"\\n    );\\n    require(\\n      (++meta.reweighIndex % (REWEIGHS_BEFORE_REINDEX + 1)) == 0,\\n      \\\"ERR_REWEIGH_INDEX\\\"\\n    );\\n    _reindexPool(meta, poolAddress);\\n  }\\n\\n  function forceReindexPool(address poolAddress) external onlyOwner {\\n    IndexPoolMeta storage meta = indexPoolMetadata[poolAddress];\\n    uint8 divisor = REWEIGHS_BEFORE_REINDEX + 1;\\n    uint8 remainder = ++meta.reweighIndex % divisor;\\n\\n    meta.reweighIndex += divisor - remainder;\\n    _reindexPool(meta, poolAddress);\\n  }\\n\\n  function _reindexPool(IndexPoolMeta storage meta, address poolAddress) internal {\\n    uint256 size = meta.indexSize;\\n    (address[] memory tokens, uint256[] memory scores) = getTopTokensAndScores(meta.listID, size);\\n    uint256 wethValue = _estimatePoolValue(poolAddress);\\n    uint256 minValue = wethValue / 100;\\n    uint256[] memory ethValues = new uint256[](size);\\n    for (uint256 i = 0; i < size; i++){\\n      ethValues[i] = minValue;\\n    }\\n    uint256[] memory minimumBalances = uniswapOracle.computeAverageTokensForEth(\\n      tokens,\\n      ethValues,\\n      SHORT_TWAP_MIN_TIME_ELAPSED,\\n      SHORT_TWAP_MAX_TIME_ELAPSED\\n    );\\n    uint96[] memory denormalizedWeights = scores.computeDenormalizedWeights();\\n\\n    meta.lastReweigh = uint64(now);\\n\\n    IIndexPool(poolAddress).reindexTokens(\\n      tokens,\\n      denormalizedWeights,\\n      minimumBalances\\n    );\\n    emit PoolReindexed(poolAddress);\\n  }\\n\\n  /**\\n   * @dev Reweighs the assets in a pool by their scores and sets the\\n   * desired new weights, which will be adjusted over time.\\n   */\\n  function reweighPool(address poolAddress) external {\\n    IndexPoolMeta memory meta = indexPoolMetadata[poolAddress];\\n    require(meta.initialized, \\\"ERR_POOL_NOT_FOUND\\\");\\n\\n    require(\\n      now - meta.lastReweigh >= POOL_REWEIGH_DELAY,\\n      \\\"ERR_POOL_REWEIGH_DELAY\\\"\\n    );\\n\\n    require(\\n      (++meta.reweighIndex % (REWEIGHS_BEFORE_REINDEX + 1)) != 0,\\n      \\\"ERR_REWEIGH_INDEX\\\"\\n    );\\n\\n    TokenList storage list = _lists[meta.listID];\\n\\n    address[] memory tokens = IIndexPool(poolAddress).getCurrentDesiredTokens();\\n    uint256[] memory scores = IScoringStrategy(list.scoringStrategy).getTokenScores(tokens);\\n    uint96[] memory denormalizedWeights = scores.computeDenormalizedWeights();\\n\\n    meta.lastReweigh = uint64(now);\\n    indexPoolMetadata[poolAddress] = meta;\\n    IIndexPool(poolAddress).reweighTokens(tokens, denormalizedWeights);\\n    emit PoolReweighed(poolAddress);\\n  }\\n\\n/* ==========  Pool Queries  ========== */\\n\\n  /**\\n   * @dev Compute the create2 address for a pool initializer.\\n   */\\n  function computeInitializerAddress(address poolAddress)\\n    public\\n    view\\n    returns (address initializerAddress)\\n  {\\n    initializerAddress = SaltyLib.computeProxyAddressManyToOne(\\n      address(proxyManager),\\n      address(this),\\n      INITIALIZER_IMPLEMENTATION_ID,\\n      keccak256(abi.encodePacked(poolAddress))\\n    );\\n  }\\n\\n  /**\\n   * @dev Compute the create2 address for a pool's unbound token seller.\\n   */\\n  function computeSellerAddress(address poolAddress)\\n    public\\n    view\\n    returns (address sellerAddress)\\n  {\\n    sellerAddress = SaltyLib.computeProxyAddressManyToOne(\\n      address(proxyManager),\\n      address(this),\\n      SELLER_IMPLEMENTATION_ID,\\n      keccak256(abi.encodePacked(poolAddress))\\n    );\\n  }\\n\\n  /**\\n   * @dev Compute the create2 address for a pool.\\n   */\\n  function computePoolAddress(uint256 listID, uint256 indexSize)\\n    public\\n    view\\n    returns (address poolAddress)\\n  {\\n    poolAddress = SaltyLib.computeProxyAddressManyToOne(\\n      address(proxyManager),\\n      address(poolFactory),\\n      POOL_IMPLEMENTATION_ID,\\n      keccak256(abi.encodePacked(\\n        address(this),\\n        keccak256(abi.encodePacked(listID, indexSize))\\n      ))\\n    );\\n  }\\n\\n  /**\\n   * @dev Queries the top `indexSize` tokens in a list from the market oracle,\\n   * computes their relative weights and determines the weighted balance of each\\n   * token to meet a specified total value.\\n   */\\n  function getInitialTokensAndBalances(\\n    uint256 listID,\\n    uint256 indexSize,\\n    uint256 wethValue\\n  )\\n    public\\n    view\\n    returns (\\n      address[] memory tokens,\\n      uint256[] memory balances\\n    )\\n  {\\n    uint256[] memory scores;\\n    (tokens, scores) = getTopTokensAndScores(listID, indexSize);\\n    uint256[] memory relativeEthValues = wethValue.computeProportionalAmounts(scores);\\n    balances = uniswapOracle.computeAverageTokensForEth(\\n      tokens,\\n      relativeEthValues,\\n      SHORT_TWAP_MIN_TIME_ELAPSED,\\n      SHORT_TWAP_MAX_TIME_ELAPSED\\n    );\\n    uint256 len = balances.length;\\n    for (uint256 i = 0; i < len; i++) {\\n      require(balances[i] >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n    }\\n  }\\n\\n/* ==========  Internal Pool Utility Functions  ========== */\\n\\n  /**\\n   * @dev Estimate the total value of a pool by taking the sum of\\n   * TWAP values of the pool's balance in each token it has bound.\\n   */\\n  function _estimatePoolValue(address pool) internal view returns (uint256 totalValue) {\\n    address[] memory tokens = IIndexPool(pool).getCurrentTokens();\\n    uint256 len = tokens.length;\\n    uint256[] memory balances = new uint256[](len);\\n    for (uint256 i; i < len; i++) balances[i] = IERC20(tokens[i]).balanceOf(address(pool));\\n    uint256[] memory ethValues = uniswapOracle.computeAverageEthForTokens(\\n      tokens,\\n      balances,\\n      SHORT_TWAP_MIN_TIME_ELAPSED,\\n      SHORT_TWAP_MAX_TIME_ELAPSED\\n    );\\n    // Safe math is not needed because we are taking the sum of an array of uint144s as a uint256.\\n    for (uint256 i; i < len; i++) totalValue += ethValues[i];\\n  }\\n}\\n\"\r\n    },\r\n    \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\n/**\\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\\n *\\n * An implementation identifier can be created on the proxy manager which is\\n * used to specify the logic address for a particular contract type, and to\\n * upgrade the implementation as needed.\\n *\\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\\n * address.\\n *\\n * A many-to-one proxy is a single upgradeable implementation address that may be\\n * used by many proxy contracts.\\n */\\ninterface IDelegateCallProxyManager {\\n/* ==========  Events  ========== */\\n\\n  event DeploymentApprovalGranted(address deployer);\\n  event DeploymentApprovalRevoked(address deployer);\\n\\n  event ManyToOne_ImplementationCreated(\\n    bytes32 implementationID,\\n    address implementationAddress\\n  );\\n\\n  event ManyToOne_ImplementationUpdated(\\n    bytes32 implementationID,\\n    address implementationAddress\\n  );\\n\\n  event ManyToOne_ProxyDeployed(\\n    bytes32 implementationID,\\n    address proxyAddress\\n  );\\n\\n  event OneToOne_ProxyDeployed(\\n    address proxyAddress,\\n    address implementationAddress\\n  );\\n\\n  event OneToOne_ImplementationUpdated(\\n    address proxyAddress,\\n    address implementationAddress\\n  );\\n\\n/* ==========  Controls  ========== */\\n\\n  /**\\n   * @dev Allows `deployer` to deploy many-to-one proxies.\\n   */\\n  function approveDeployer(address deployer) external;\\n\\n  /**\\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\\n   */\\n  function revokeDeployerApproval(address deployer) external;\\n\\n/* ==========  Implementation Management  ========== */\\n\\n  /**\\n   * @dev Creates a many-to-one proxy relationship.\\n   *\\n   * Deploys an implementation holder contract which stores the\\n   * implementation address for many proxies. The implementation\\n   * address can be updated on the holder to change the runtime\\n   * code used by all its proxies.\\n   *\\n   * @param implementationID ID for the implementation, used to identify the\\n   * proxies that use it. Also used as the salt in the create2 call when\\n   * deploying the implementation holder contract.\\n   * @param implementation Address with the runtime code the proxies\\n   * should use.\\n   */\\n  function createManyToOneProxyRelationship(\\n    bytes32 implementationID,\\n    address implementation\\n  ) external;\\n\\n  /**\\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\\n   */\\n  function lockImplementationManyToOne(bytes32 implementationID) external;\\n\\n  /**\\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\\n   */\\n  function lockImplementationOneToOne(address proxyAddress) external;\\n\\n  /**\\n   * @dev Updates the implementation address for a many-to-one\\n   * proxy relationship.\\n   *\\n   * @param implementationID Identifier for the implementation.\\n   * @param implementation Address with the runtime code the proxies\\n   * should use.\\n   */\\n  function setImplementationAddressManyToOne(\\n    bytes32 implementationID,\\n    address implementation\\n  ) external;\\n\\n  /**\\n   * @dev Updates the implementation address for a one-to-one proxy.\\n   *\\n   * Note: This could work for many-to-one as well if the caller\\n   * provides the implementation holder address in place of the\\n   * proxy address, as they use the same access control and update\\n   * mechanism.\\n   *\\n   * @param proxyAddress Address of the deployed proxy\\n   * @param implementation Address with the runtime code for\\n   * the proxy to use.\\n   */\\n  function setImplementationAddressOneToOne(\\n    address proxyAddress,\\n    address implementation\\n  ) external;\\n\\n/* ==========  Proxy Deployment  ========== */\\n\\n  /**\\n   * @dev Deploy a proxy contract with a one-to-one relationship\\n   * with its implementation.\\n   *\\n   * The proxy will have its own implementation address which can\\n   * be updated by the proxy manager.\\n   *\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n   * @param implementation Address of the contract with the runtime\\n   * code that the proxy should use.\\n   */\\n  function deployProxyOneToOne(\\n    bytes32 suppliedSalt,\\n    address implementation\\n  ) external returns(address proxyAddress);\\n\\n  /**\\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\\n   *\\n   * The proxy will call the implementation holder for every transaction to\\n   * determine the address to use in calls.\\n   *\\n   * @param implementationID Identifier for the proxy's implementation.\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n   */\\n  function deployProxyManyToOne(\\n    bytes32 implementationID,\\n    bytes32 suppliedSalt\\n  ) external returns(address proxyAddress);\\n\\n/* ==========  Queries  ========== */\\n\\n  /**\\n   * @dev Returns a boolean stating whether `implementationID` is locked.\\n   */\\n  function isImplementationLocked(bytes32 implementationID) external view returns (bool);\\n\\n  /**\\n   * @dev Returns a boolean stating whether `proxyAddress` is locked.\\n   */\\n  function isImplementationLocked(address proxyAddress) external view returns (bool);\\n\\n  /**\\n   * @dev Returns a boolean stating whether `deployer` is allowed to deploy many-to-one\\n   * proxies.\\n   */\\n  function isApprovedDeployer(address deployer) external view returns (bool);\\n\\n  /**\\n   * @dev Queries the temporary storage value `_implementationHolder`.\\n   * This is used in the constructor of the many-to-one proxy contract\\n   * so that the create2 address is static (adding constructor arguments\\n   * would change the codehash) and the implementation holder can be\\n   * stored as a constant.\\n   */\\n  function getImplementationHolder() external view returns (address);\\n\\n  /**\\n   * @dev Returns the address of the implementation holder contract\\n   * for `implementationID`.\\n   */\\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\\n\\n  /**\\n   * @dev Computes the create2 address for a one-to-one proxy requested\\n   * by `originator` using `suppliedSalt`.\\n   *\\n   * @param originator Address of the account requesting deployment.\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n   */\\n  function computeProxyAddressOneToOne(\\n    address originator,\\n    bytes32 suppliedSalt\\n  ) external view returns (address);\\n\\n  /**\\n   * @dev Computes the create2 address for a many-to-one proxy for the\\n   * implementation `implementationID` requested by `originator` using\\n   * `suppliedSalt`.\\n   *\\n   * @param originator Address of the account requesting deployment.\\n   * @param implementationID The identifier for the contract implementation.\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n  */\\n  function computeProxyAddressManyToOne(\\n    address originator,\\n    bytes32 implementationID,\\n    bytes32 suppliedSalt\\n  ) external view returns (address);\\n\\n  /**\\n   * @dev Computes the create2 address of the implementation holder\\n   * for `implementationID`.\\n   *\\n   * @param implementationID The identifier for the contract implementation.\\n  */\\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@indexed-finance/proxies/contracts/SaltyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n/* ---  External Libraries  --- */\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\n/* ---  Proxy Contracts  --- */\\nimport { CodeHashes } from \\\"./CodeHashes.sol\\\";\\n\\n\\n/**\\n * @dev Library for computing create2 salts and addresses for proxies\\n * deployed by `DelegateCallProxyManager`.\\n *\\n * Because the proxy factory is meant to be used by multiple contracts,\\n * we use a salt derivation pattern that includes the address of the\\n * contract that requested the proxy deployment, a salt provided by that\\n * contract and the implementation ID used (for many-to-one proxies only).\\n */\\nlibrary SaltyLib {\\n/* ---  Salt Derivation  --- */\\n\\n  /**\\n   * @dev Derives the create2 salt for a many-to-one proxy.\\n   *\\n   * Many different contracts in the Indexed framework may use the\\n   * same implementation contract, and they all use the same init\\n   * code, so we derive the actual create2 salt from a combination\\n   * of the implementation ID, the address of the account requesting\\n   * deployment and the user-supplied salt.\\n   *\\n   * @param originator Address of the account requesting deployment.\\n   * @param implementationID The identifier for the contract implementation.\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n   */\\n  function deriveManyToOneSalt(\\n    address originator,\\n    bytes32 implementationID,\\n    bytes32 suppliedSalt\\n  )\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return keccak256(\\n      abi.encodePacked(\\n        originator,\\n        implementationID,\\n        suppliedSalt\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev Derives the create2 salt for a one-to-one proxy.\\n   *\\n   * @param originator Address of the account requesting deployment.\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n   */\\n  function deriveOneToOneSalt(\\n    address originator,\\n    bytes32 suppliedSalt\\n  )\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return keccak256(abi.encodePacked(originator, suppliedSalt));\\n  }\\n\\n/* ---  Address Derivation  --- */\\n\\n  /**\\n   * @dev Computes the create2 address for a one-to-one proxy deployed\\n   * by `deployer` (the factory) when requested by `originator` using\\n   * `suppliedSalt`.\\n   *\\n   * @param deployer Address of the proxy factory.\\n   * @param originator Address of the account requesting deployment.\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n   */\\n  function computeProxyAddressOneToOne(\\n    address deployer,\\n    address originator,\\n    bytes32 suppliedSalt\\n  )\\n    internal\\n    pure\\n    returns (address)\\n  {\\n    bytes32 salt = deriveOneToOneSalt(originator, suppliedSalt);\\n    return Create2.computeAddress(salt, CodeHashes.ONE_TO_ONE_CODEHASH, deployer);\\n  }\\n\\n  /**\\n   * @dev Computes the create2 address for a many-to-one proxy for the\\n   * implementation `implementationID` deployed by `deployer` (the factory)\\n   * when requested by `originator` using `suppliedSalt`.\\n   *\\n   * @param deployer Address of the proxy factory.\\n   * @param originator Address of the account requesting deployment.\\n   * @param implementationID The identifier for the contract implementation.\\n   * @param suppliedSalt Salt provided by the account requesting deployment.\\n  */\\n  function computeProxyAddressManyToOne(\\n    address deployer,\\n    address originator,\\n    bytes32 implementationID,\\n    bytes32 suppliedSalt\\n  )\\n    internal\\n    pure\\n    returns (address)\\n  {\\n    bytes32 salt = deriveManyToOneSalt(\\n      originator,\\n      implementationID,\\n      suppliedSalt\\n    );\\n    return Create2.computeAddress(salt, CodeHashes.MANY_TO_ONE_CODEHASH, deployer);\\n  }\\n\\n  /**\\n   * @dev Computes the create2 address of the implementation holder\\n   * for `implementationID`.\\n   *\\n   * @param deployer Address of the proxy factory.\\n   * @param implementationID The identifier for the contract implementation.\\n  */\\n  function computeHolderAddressManyToOne(\\n    address deployer,\\n    bytes32 implementationID\\n  )\\n    internal\\n    pure\\n    returns (address)\\n  {\\n    return Create2.computeAddress(\\n      implementationID,\\n      CodeHashes.IMPLEMENTATION_HOLDER_CODEHASH,\\n      deployer\\n    );\\n  }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint256(_data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@indexed-finance/proxies/contracts/CodeHashes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\n/**\\n * @dev Because we use the code hashes of the proxy contracts for proxy address\\n * derivation, it is important that other packages have access to the correct\\n * values when they import the salt library.\\n */\\nlibrary CodeHashes {\\n  bytes32 internal constant ONE_TO_ONE_CODEHASH = 0x63d9f7b5931b69188c8f6b806606f25892f1bb17b7f7e966fe3a32c04493aee4;\\n  bytes32 internal constant MANY_TO_ONE_CODEHASH = 0xa035ad05a1663db5bfd455b99cd7c6ac6bd49269738458eda140e0b78ed53f79;\\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH = 0x11c370493a726a0ffa93d42b399ad046f1b5a543b6e72f1a64f1488dc1c58f2c;\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IIndexPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IIndexPool {\\n  /**\\n   * @dev Token record data structure\\n   * @param bound is token bound to pool\\n   * @param ready has token been initialized\\n   * @param lastDenormUpdate timestamp of last denorm change\\n   * @param denorm denormalized weight\\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\\n   * @param index index of address in tokens array\\n   * @param balance token balance\\n   */\\n  struct Record {\\n    bool bound;\\n    bool ready;\\n    uint40 lastDenormUpdate;\\n    uint96 denorm;\\n    uint96 desiredDenorm;\\n    uint8 index;\\n    uint256 balance;\\n  }\\n\\n/* ==========  EVENTS  ========== */\\n\\n  /** @dev Emitted when tokens are swapped. */\\n  event LOG_SWAP(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 tokenAmountIn,\\n    uint256 tokenAmountOut\\n  );\\n\\n  /** @dev Emitted when underlying tokens are deposited for pool tokens. */\\n  event LOG_JOIN(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    uint256 tokenAmountIn\\n  );\\n\\n  /** @dev Emitted when pool tokens are burned for underlying. */\\n  event LOG_EXIT(\\n    address indexed caller,\\n    address indexed tokenOut,\\n    uint256 tokenAmountOut\\n  );\\n\\n  /** @dev Emitted when a token's weight updates. */\\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\\n\\n  /** @dev Emitted when a token's desired weight is set. */\\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\\n\\n  /** @dev Emitted when a token is unbound from the pool. */\\n  event LOG_TOKEN_REMOVED(address token);\\n\\n  /** @dev Emitted when a token is unbound from the pool. */\\n  event LOG_TOKEN_ADDED(\\n    address indexed token,\\n    uint256 desiredDenorm,\\n    uint256 minimumBalance\\n  );\\n\\n  /** @dev Emitted when a token's minimum balance is updated. */\\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\\n\\n  /** @dev Emitted when a token reaches its minimum balance. */\\n  event LOG_TOKEN_READY(address indexed token);\\n\\n  /** @dev Emitted when public trades are enabled or disabled. */\\n  event LOG_PUBLIC_SWAP_TOGGLED(bool isPublic);\\n\\n  /** @dev Emitted when the swap fee is updated. */\\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\\n\\n  /** @dev Emitted when exit fee recipient is updated. */\\n  event LOG_EXIT_FEE_RECIPIENT_UPDATED(address exitFeeRecipient);\\n\\n  /** @dev Emitted when controller is updated. */\\n  event LOG_CONTROLLER_UPDATED(address exitFeeRecipient);\\n\\n  function configure(\\n    address controller,\\n    string calldata name,\\n    string calldata symbol\\n  ) external;\\n\\n  function initialize(\\n    address[] calldata tokens,\\n    uint256[] calldata balances,\\n    uint96[] calldata denorms,\\n    address tokenProvider,\\n    address unbindHandler,\\n    address exitFeeRecipient\\n  ) external;\\n\\n  function setSwapFee(uint256 swapFee) external;\\n\\n  function setController(address controller) external;\\n\\n  function delegateCompLikeToken(address token, address delegatee) external;\\n\\n  function setExitFeeRecipient(address) external;\\n\\n  function setPublicSwap(bool enabled) external;\\n\\n  function reweighTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms\\n  ) external;\\n\\n  function reindexTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms,\\n    uint256[] calldata minimumBalances\\n  ) external;\\n\\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\\n\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    uint256 minPoolAmountOut\\n  ) external returns (uint256/* poolAmountOut */);\\n\\n  function joinswapPoolAmountOut(\\n    address tokenIn,\\n    uint256 poolAmountOut,\\n    uint256 maxAmountIn\\n  ) external returns (uint256/* tokenAmountIn */);\\n\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n  function exitswapPoolAmountIn(\\n    address tokenOut,\\n    uint256 poolAmountIn,\\n    uint256 minAmountOut\\n  )\\n    external returns (uint256/* tokenAmountOut */);\\n\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPoolAmountIn\\n  ) external returns (uint256/* poolAmountIn */);\\n\\n  function gulp(address token) external;\\n\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\\n\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\\n\\n  function isPublicSwap() external view returns (bool);\\n\\n  function getSwapFee() external view returns (uint256/* swapFee */);\\n\\n  function getExitFee() external view returns (uint256/* exitFee */);\\n\\n  function getController() external view returns (address);\\n\\n  function getExitFeeRecipient() external view returns (address);\\n\\n  function isBound(address t) external view returns (bool);\\n\\n  function getNumTokens() external view returns (uint256);\\n\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\\n\\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\\n\\n  function getTokenRecord(address token) external view returns (Record memory record);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n  function getMinimumBalance(address token) external view returns (uint256);\\n\\n  function getUsedBalance(address token) external view returns (uint256);\\n\\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\\\";\\n\\n\\ninterface IPoolFactory {\\n/* ========== Events ========== */\\n\\n  event NewPool(address pool, address controller, bytes32 implementationID);\\n\\n/* ========== Mutative ========== */\\n\\n  function approvePoolController(address controller) external;\\n\\n  function disapprovePoolController(address controller) external;\\n\\n  function deployPool(bytes32 implementationID, bytes32 controllerSalt) external returns (address);\\n\\n/* ========== Views ========== */\\n\\n  function proxyManager() external view returns (IDelegateCallProxyManager);\\n\\n  function isApprovedController(address) external view returns (bool);\\n\\n  function getPoolImplementationID(address) external view returns (bytes32);\\n\\n  function isRecognizedPool(address pool) external view returns (bool);\\n\\n  function computePoolAddress(\\n    bytes32 implementationID,\\n    address controller,\\n    bytes32 controllerSalt\\n  ) external view returns (address);\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IPoolInitializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\ninterface IPoolInitializer {\\n/* ========== Events ========== */\\n\\n  event TokensContributed(\\n    address from,\\n    address token,\\n    uint256 amount,\\n    uint256 credit\\n  );\\n\\n/* ========== Mutative ========== */\\n\\n  function initialize(\\n    address controller,\\n    address poolAddress,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  function finish() external;\\n\\n  function claimTokens() external;\\n\\n  function claimTokens(address account) external;\\n\\n  function claimTokens(address[] calldata accounts) external;\\n\\n  function contributeTokens(\\n    address token,\\n    uint256 amountIn,\\n    uint256 minimumCredit\\n  ) external returns (uint256);\\n\\n  function contributeTokens(\\n    address[] calldata tokens,\\n    uint256[] calldata amountsIn,\\n    uint256 minimumCredit\\n  ) external returns (uint256);\\n\\n  function updatePrices() external;\\n\\n/* ========== Views ========== */\\n\\n  function isFinished() external view returns (bool);\\n\\n  function getTotalCredit() external view returns (uint256);\\n\\n  function getCreditOf(address account) external view returns (uint256);\\n\\n  function getDesiredTokens() external view returns (address[] memory);\\n\\n  function getDesiredAmount(address token) external view returns (uint256);\\n\\n  function getDesiredAmounts(address[] calldata tokens) external view returns (uint256[] memory);\\n\\n  function getCreditForTokens(address token, uint256 amountIn) external view returns (uint144);\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IUnboundTokenSeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IUnboundTokenSeller {\\n/* ========== Events ========== */\\n\\n  event PremiumPercentSet(uint8 premium);\\n\\n  event NewTokensToSell(address indexed token, uint256 amountReceived);\\n\\n  event SwappedTokens(\\n    address indexed tokenSold,\\n    address indexed tokenBought,\\n    uint256 soldAmount,\\n    uint256 boughtAmount\\n  );\\n\\n/* ========== Mutative ========== */\\n\\n  function initialize(address controller_, address pool, uint8 premiumPercent) external;\\n\\n  function handleUnbindToken(address token, uint256 amount) external;\\n\\n  function setPremiumPercent(uint8 premiumPercent) external;\\n\\n  function executeSwapTokensForExactTokens(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountOut,\\n    address[] calldata path\\n  ) external returns (uint256);\\n\\n  function executeSwapExactTokensForTokens(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountIn,\\n    address[] calldata path\\n  ) external returns (uint256);\\n\\n  function swapExactTokensForTokens(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountIn,\\n    uint256 minAmountOut\\n  ) external returns (uint256);\\n\\n  function swapTokensForExactTokens(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountOut,\\n    uint256 maxAmountIn\\n  ) external returns (uint256);\\n\\n/* ========== Views ========== */\\n\\n  function getPremiumPercent() external view returns (uint8);\\n\\n  function calcInGivenOut(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountOut\\n  ) external view returns (uint256);\\n\\n  function calcOutGivenIn(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountIn\\n  ) external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IIndexedUniswapV2Oracle\",\"name\":\"uniswapOracle_\",\"type\":\"address\"},{\"internalType\":\"contract IPoolFactory\",\"name\":\"poolFactory_\",\"type\":\"address\"},{\"internalType\":\"contract IDelegateCallProxyManager\",\"name\":\"proxyManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initializer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexSize\",\"type\":\"uint256\"}],\"name\":\"NewPoolInitializer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"unboundTokenSeller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexSize\",\"type\":\"uint256\"}],\"name\":\"PoolInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolReindexed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolReweighed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"scoringStrategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"minimumScore\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"maximumScore\",\"type\":\"uint128\"}],\"name\":\"TokenListAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"TokenListSorted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIALIZER_IMPLEMENTATION_ID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_INDEX_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LIST_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_INDEX_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_IMPLEMENTATION_ID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_REWEIGH_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWEIGHS_BEFORE_REINDEX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SELLER_IMPLEMENTATION_ID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHORT_TWAP_MAX_TIME_ELAPSED\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHORT_TWAP_MIN_TIME_ELAPSED\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circuitBreaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingMarketCapOracle\",\"outputs\":[{\"internalType\":\"contract ICirculatingMarketCapOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"computeInitializerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"initializerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexSize\",\"type\":\"uint256\"}],\"name\":\"computePoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"computeSellerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sellerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"scoringStrategy\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"minimumScore\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maximumScore\",\"type\":\"uint128\"}],\"name\":\"createTokenList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultExitFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultSellerPremium\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegateCompLikeTokenFromPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"finishPreparedIndexPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"forceReindexPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethValue\",\"type\":\"uint256\"}],\"name\":\"getInitialTokensAndBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"getSortedAndFilteredTokensAndScores\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"scores\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"getTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"getTokenListConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"scoringStrategy\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"minimumScore\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maximumScore\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getTokenScores\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"scores\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getTopTokensAndScores\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"scores\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexPoolMetadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"listID\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"indexSize\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"reweighIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"lastReweigh\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circuitBreaker_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isTokenInlist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolFactory\",\"outputs\":[{\"internalType\":\"contract IPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialWethValue\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"prepareIndexPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initializerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyManager\",\"outputs\":[{\"internalType\":\"contract IDelegateCallProxyManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"reindexPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"reweighPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circuitBreaker_\",\"type\":\"address\"}],\"name\":\"setCircuitBreaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defaultExitFeeRecipient_\",\"type\":\"address\"}],\"name\":\"setDefaultExitFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_defaultSellerPremium\",\"type\":\"uint8\"}],\"name\":\"setDefaultSellerPremium\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exitFeeRecipient\",\"type\":\"address\"}],\"name\":\"setExitFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"poolAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"exitFeeRecipient\",\"type\":\"address\"}],\"name\":\"setExitFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"indexPool_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"publicSwap\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"poolAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"sortAndFilterTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenListCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapOracle\",\"outputs\":[{\"internalType\":\"contract IIndexedUniswapV2Oracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"updateMinimumBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenSeller\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"premiumPercent\",\"type\":\"uint8\"}],\"name\":\"updateSellerPremium\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listID\",\"type\":\"uint256\"}],\"name\":\"updateTokenPrices\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"pricesUpdated\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SigmaControllerV1","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fa5a44d3ba93d666bf29c8804a36e725ecac659a000000000000000000000000592f70ce43a310d15ff59be1460f38ab6df3fe65000000000000000000000000d23dedc599bd56767e42d48484d6ca96ab01c11500000000000000000000000078a3ef33cf033381feb43ba4212f2af5a5a0a2ea","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}