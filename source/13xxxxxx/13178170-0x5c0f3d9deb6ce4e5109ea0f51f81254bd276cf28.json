{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\npragma abicoder v2;\n\n\ninterface Token {\n\n    /// @return supply total amount of tokens\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Optionally implemented function to show the number of decimals for the token\n    function decimals() external view returns (uint8 decimals);\n}\n\n/// @title Utils\n/// @notice Utils contract for various helpers used by the Raiden Network smart\n/// contracts.\ncontract Utils {\n\n    uint256 constant MAX_SAFE_UINT256 = 2**256 - 1;\n\n    /// @notice Check if a contract exists\n    /// @param contract_address The address to check whether a contract is\n    /// deployed or not\n    /// @return True if a contract exists, false otherwise\n    function contractExists(address contract_address) public view returns (bool) {\n        uint size;\n\n        assembly { // solium-disable-line security/no-inline-assembly\n            size := extcodesize(contract_address)\n        }\n\n        return size > 0;\n    }\n\n    string public constant signature_prefix = \"\\x19Ethereum Signed Message:\\n\";\n\n    function min(uint256 a, uint256 b) public pure returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n\n    function max(uint256 a, uint256 b) public pure returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n\n    /// @dev Special subtraction function that does not fail when underflowing.\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Minimum between the result of the subtraction and 0, the maximum\n    /// subtrahend for which no underflow occurs\n    function failsafe_subtract(uint256 a, uint256 b)\n        public\n        pure\n        returns (uint256, uint256)\n    {\n        unchecked {\n            return a > b ? (a - b, b) : (0, a);\n        }\n    }\n\n    /// @dev Special addition function that does not fail when overflowing.\n    /// @param a Addend\n    /// @param b Addend\n    /// @return Maximum between the result of the addition or the maximum\n    /// uint256 value\n    function failsafe_addition(uint256 a, uint256 b)\n        public\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 sum = a + b;\n            return sum >= a ? sum : MAX_SAFE_UINT256;\n        }\n    }\n}\n\ncontract UserDeposit is Utils {\n    uint constant public withdraw_delay = 100;  // time before withdraw is allowed in blocks\n\n    // Token to be used for the deposit\n    Token public token;\n\n    // Trusted contracts (can execute `transfer`)\n    address public msc_address;\n    address public one_to_n_address;\n\n    // Total amount of tokens that have been deposited. This is monotonous and\n    // doing a transfer or withdrawing tokens will not decrease total_deposit!\n    mapping(address => uint256) public total_deposit;\n    // Current user's balance, ignoring planned withdraws\n    mapping(address => uint256) public balances;\n    mapping(address => WithdrawPlan) public withdraw_plans;\n\n    // The sum of all balances\n    uint256 public whole_balance = 0;\n    // Deposit limit for this whole contract\n    uint256 public whole_balance_limit;\n\n    /*\n     *  Structs\n     */\n    struct WithdrawPlan {\n        uint256 amount;\n        uint256 withdraw_block;  // earliest block at which withdraw is allowed\n    }\n\n    /*\n     *  Events\n     */\n\n    event BalanceReduced(address indexed owner, uint newBalance);\n    event WithdrawPlanned(address indexed withdrawer, uint plannedBalance);\n\n    /*\n     *  Modifiers\n     */\n\n    modifier canTransfer() {\n        require(msg.sender == msc_address || msg.sender == one_to_n_address, \"unknown caller\");\n        _;\n    }\n\n    /*\n     *  Constructor\n     */\n\n    /// @notice Set the default values for the smart contract\n    /// @param _token_address The address of the token to use for rewards\n    constructor(address _token_address, uint256 _whole_balance_limit)\n    {\n        // check token contract\n        require(_token_address != address(0x0), \"token at address zero\");\n        require(contractExists(_token_address), \"token has no code\");\n        token = Token(_token_address);\n        require(token.totalSupply() > 0, \"token has no total supply\"); // Check if the contract is indeed a token contract\n        // check and set the whole balance limit\n        require(_whole_balance_limit > 0, \"whole balance limit is zero\");\n        whole_balance_limit = _whole_balance_limit;\n    }\n\n    /// @notice Specify trusted contracts. This has to be done outside of the\n    /// constructor to avoid cyclic dependencies.\n    /// @param _msc_address Address of the MonitoringService contract\n    /// @param _one_to_n_address Address of the OneToN contract\n    function init(address _msc_address, address _one_to_n_address)\n        external\n    {\n        // prevent changes of trusted contracts after initialization\n        require(msc_address == address(0x0) && one_to_n_address == address(0x0), \"already initialized\");\n\n        // check monitoring service contract\n        require(_msc_address != address(0x0), \"MS contract at address zero\");\n        require(contractExists(_msc_address), \"MS contract has no code\");\n        msc_address = _msc_address;\n\n        // check one to n contract\n        require(_one_to_n_address != address(0x0), \"OneToN at address zero\");\n        require(contractExists(_one_to_n_address), \"OneToN has no code\");\n        one_to_n_address = _one_to_n_address;\n    }\n\n    /// @notice Deposit tokens. The amount of transferred tokens will be\n    /// `new_total_deposit - total_deposit[beneficiary]`. This makes the\n    /// function behavior predictable and idempotent. Can be called several\n    /// times and on behalf of other accounts.\n    /// @param beneficiary The account benefiting from the deposit\n    /// @param new_total_deposit The total sum of tokens that have been\n    /// deposited by the user by calling this function.\n    function deposit(address beneficiary, uint256 new_total_deposit)\n        external\n    {\n        require(new_total_deposit > total_deposit[beneficiary], \"deposit not increasing\");\n\n        // Calculate the actual amount of tokens that will be transferred\n        uint256 added_deposit = new_total_deposit - total_deposit[beneficiary];\n\n        balances[beneficiary] += added_deposit;\n        total_deposit[beneficiary] += added_deposit;\n\n        // Update whole_balance, but take care against overflows.\n        require(whole_balance + added_deposit >= whole_balance, \"overflowing deposit\");\n        whole_balance += added_deposit;\n\n        // Decline deposit if the whole balance is bigger than the limit.\n        require(whole_balance <= whole_balance_limit, \"too much deposit\");\n\n        // Actual transfer.\n        require(token.transferFrom(msg.sender, address(this), added_deposit), \"tokens didn't transfer\");\n    }\n\n    /// @notice Internally transfer deposits between two addresses.\n    /// Sender and receiver must be different or the transaction will fail.\n    /// @param sender Account from which the amount will be deducted\n    /// @param receiver Account to which the amount will be credited\n    /// @param amount Amount of tokens to be transferred\n    /// @return success true if transfer has been done successfully, otherwise false\n    function transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    )\n        external\n        canTransfer()\n        returns (bool success)\n    {\n        require(sender != receiver, \"sender == receiver\");\n        if (balances[sender] >= amount && amount > 0) {\n            balances[sender] -= amount;\n            // This can overflow in theory, but this is checked by solidity since 0.8.0.\n            // In practice, with any reasonable token, where the supply is limited to uint256,\n            // this can never overflow.\n            // See https://github.com/raiden-network/raiden-contracts/pull/448#discussion_r250609178\n            balances[receiver] += amount;\n            emit BalanceReduced(sender, balances[sender]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Announce intention to withdraw tokens.\n    /// Sets the planned withdraw amount and resets the withdraw_block.\n    /// There is only one planned withdrawal at a time, the old one gets overwritten.\n    /// @param amount Maximum amount of tokens to be withdrawn\n    function planWithdraw(uint256 amount)\n        external\n    {\n        require(amount > 0, \"withdrawing zero\");\n        require(balances[msg.sender] >= amount, \"withdrawing too much\");\n\n        withdraw_plans[msg.sender] = WithdrawPlan({\n            amount: amount,\n            withdraw_block: block.number + withdraw_delay\n        });\n        emit WithdrawPlanned(msg.sender, balances[msg.sender] - amount);\n    }\n\n    /// @notice Execute a planned withdrawal\n    /// Will only work after the withdraw_delay has expired.\n    /// An amount lower or equal to the planned amount may be withdrawn.\n    /// Removes the withdraw plan even if not the full amount has been\n    /// withdrawn.\n    /// @param amount Amount of tokens to be withdrawn\n    /// @param beneficiary Address to send withdrawn tokens to\n    function withdrawToBeneficiary(uint256 amount, address beneficiary)\n        external\n    {\n        withdrawHelper(amount, msg.sender, beneficiary);\n    }\n\n    /// @notice Execute a planned withdrawal\n    /// Will only work after the withdraw_delay has expired.\n    /// An amount lower or equal to the planned amount may be withdrawn.\n    /// Removes the withdraw plan even if not the full amount has been\n    /// withdrawn.\n    /// @param amount Amount of tokens to be withdrawn\n    function withdraw(uint256 amount)\n        external\n    {\n        withdrawHelper(amount, msg.sender, msg.sender);\n    }\n\n    /// @notice The owner's balance with planned withdrawals deducted\n    /// @param owner Address for which the balance should be returned\n    /// @return remaining_balance The remaining balance after planned withdrawals\n    function effectiveBalance(address owner)\n        external\n        view\n        returns (uint256 remaining_balance)\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[owner];\n        if (withdraw_plan.amount > balances[owner]) {\n            return 0;\n        }\n        return balances[owner] - withdraw_plan.amount;\n    }\n\n    function withdrawHelper(uint256 amount, address deposit_holder, address beneficiary)\n        internal\n    {\n        require(beneficiary != address(0x0), \"beneficiary is zero\");\n        WithdrawPlan storage withdraw_plan = withdraw_plans[deposit_holder];\n        require(amount <= withdraw_plan.amount, \"withdrawing more than planned\");\n        require(withdraw_plan.withdraw_block <= block.number, \"withdrawing too early\");\n        uint256 withdrawable = min(amount, balances[deposit_holder]);\n        balances[deposit_holder] -= withdrawable;\n\n        // Update whole_balance, but take care against underflows.\n        require(whole_balance - withdrawable <= whole_balance, \"underflow in whole_balance\");\n        whole_balance -= withdrawable;\n\n        emit BalanceReduced(deposit_holder, balances[deposit_holder]);\n        delete withdraw_plans[deposit_holder];\n\n        require(token.transfer(beneficiary, withdrawable), \"tokens didn't transfer\");\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_whole_balance_limit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"BalanceReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plannedBalance\",\"type\":\"uint256\"}],\"name\":\"WithdrawPlanned\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"contractExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"new_total_deposit\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"effectiveBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"failsafe_addition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"failsafe_subtract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_msc_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_one_to_n_address\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"msc_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"one_to_n_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"planWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signature_prefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"total_deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whole_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whole_balance_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawToBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw_delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdraw_plans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw_block\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UserDeposit","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000255aa6df07540cb5d3d297f0d0d4d84cb52bc8e6ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}