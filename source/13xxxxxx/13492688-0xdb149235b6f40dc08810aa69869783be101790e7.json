{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DepositSecurityModule.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.8.9;\\n\\nimport {ECDSA} from \\\"./lib/ECDSA.sol\\\";\\n\\n\\ninterface IDepositContract {\\n    function get_deposit_root() external view returns (bytes32 rootHash);\\n}\\n\\n\\ninterface ILido {\\n    function depositBufferedEther(uint256 maxDeposits) external;\\n}\\n\\n\\ninterface INodeOperatorsRegistry {\\n    function getKeysOpIndex() external view returns (uint256 index);\\n}\\n\\n\\ncontract DepositSecurityModule {\\n    /**\\n     * Short ECDSA signature as defined in https://eips.ethereum.org/EIPS/eip-2098.\\n     */\\n    struct Signature {\\n        bytes32 r;\\n        bytes32 vs;\\n    }\\n\\n    event OwnerChanged(address newValue);\\n    event NodeOperatorsRegistryChanged(address newValue);\\n    event PauseIntentValidityPeriodBlocksChanged(uint256 newValue);\\n    event MaxDepositsChanged(uint256 newValue);\\n    event MinDepositBlockDistanceChanged(uint256 newValue);\\n    event GuardianQuorumChanged(uint256 newValue);\\n    event GuardianAdded(address guardian);\\n    event GuardianRemoved(address guardian);\\n    event DepositsPaused(address guardian);\\n    event DepositsUnpaused();\\n\\n\\n    bytes32 public immutable ATTEST_MESSAGE_PREFIX;\\n    bytes32 public immutable PAUSE_MESSAGE_PREFIX;\\n\\n    address public immutable LIDO;\\n    address public immutable DEPOSIT_CONTRACT;\\n\\n    address internal nodeOperatorsRegistry;\\n    uint256 internal maxDepositsPerBlock;\\n    uint256 internal minDepositBlockDistance;\\n    uint256 internal pauseIntentValidityPeriodBlocks;\\n\\n    address internal owner;\\n\\n    address[] internal guardians;\\n    mapping(address => uint256) internal guardianIndicesOneBased; // 1-based\\n    uint256 internal quorum;\\n\\n    bool internal paused;\\n    uint256 internal lastDepositBlock;\\n\\n\\n    constructor(\\n        address _lido,\\n        address _depositContract,\\n        address _nodeOperatorsRegistry,\\n        uint256 _networkId,\\n        uint256 _maxDepositsPerBlock,\\n        uint256 _minDepositBlockDistance,\\n        uint256 _pauseIntentValidityPeriodBlocks\\n    ) {\\n        LIDO = _lido;\\n        DEPOSIT_CONTRACT = _depositContract;\\n\\n        ATTEST_MESSAGE_PREFIX = keccak256(abi.encodePacked(\\n            // keccak256(\\\"lido.DepositSecurityModule.ATTEST_MESSAGE\\\")\\n            bytes32(0x1085395a994e25b1b3d0ea7937b7395495fb405b31c7d22dbc3976a6bd01f2bf),\\n            _networkId\\n        ));\\n\\n        PAUSE_MESSAGE_PREFIX = keccak256(abi.encodePacked(\\n            // keccak256(\\\"lido.DepositSecurityModule.PAUSE_MESSAGE\\\")\\n            bytes32(0x9c4c40205558f12027f21204d6218b8006985b7a6359bcab15404bcc3e3fa122),\\n            _networkId\\n        ));\\n\\n        _setOwner(msg.sender);\\n        _setNodeOperatorsRegistry(_nodeOperatorsRegistry);\\n        _setMaxDeposits(_maxDepositsPerBlock);\\n        _setMinDepositBlockDistance(_minDepositBlockDistance);\\n        _setPauseIntentValidityPeriodBlocks(_pauseIntentValidityPeriodBlocks);\\n\\n        paused = false;\\n        lastDepositBlock = 0;\\n    }\\n\\n\\n    /**\\n     * Returns the owner address.\\n     */\\n    function getOwner() external view returns (address) {\\n        return owner;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"not an owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Sets new owner. Only callable by the current owner.\\n     */\\n    function setOwner(address newValue) external onlyOwner {\\n        _setOwner(newValue);\\n    }\\n\\n    function _setOwner(address newValue) internal {\\n        require(newValue != address(0), \\\"invalid value for owner: must be different from zero address\\\");\\n        owner = newValue;\\n        emit OwnerChanged(newValue);\\n    }\\n\\n\\n    /**\\n     * Returns NodeOperatorsRegistry contract address.\\n     */\\n    function getNodeOperatorsRegistry() external view returns (address) {\\n        return nodeOperatorsRegistry;\\n    }\\n\\n    /**\\n     * Sets NodeOperatorsRegistry contract address. Only callable by the owner.\\n     */\\n    function setNodeOperatorsRegistry(address newValue) external onlyOwner {\\n        _setNodeOperatorsRegistry(newValue);\\n    }\\n\\n    function _setNodeOperatorsRegistry(address newValue) internal {\\n        nodeOperatorsRegistry = newValue;\\n        emit NodeOperatorsRegistryChanged(newValue);\\n    }\\n\\n\\n    /**\\n     * Returns `PAUSE_INTENT_VALIDITY_PERIOD_BLOCKS` (see `pauseDeposits`).\\n     */\\n    function getPauseIntentValidityPeriodBlocks() external view returns (uint256) {\\n        return pauseIntentValidityPeriodBlocks;\\n    }\\n\\n    /**\\n     * Sets `PAUSE_INTENT_VALIDITY_PERIOD_BLOCKS`. Only callable by the owner.\\n     */\\n    function setPauseIntentValidityPeriodBlocks(uint256 newValue) external onlyOwner {\\n        _setPauseIntentValidityPeriodBlocks(newValue);\\n    }\\n\\n    function _setPauseIntentValidityPeriodBlocks(uint256 newValue) internal {\\n        require(newValue > 0, \\\"invalid value for pauseIntentValidityPeriodBlocks: must be greater then 0\\\");\\n        pauseIntentValidityPeriodBlocks = newValue;\\n        emit PauseIntentValidityPeriodBlocksChanged(newValue);\\n    }\\n\\n\\n    /**\\n     * Returns `MAX_DEPOSITS_PER_BLOCK` (see `depositBufferedEther`).\\n     */\\n    function getMaxDeposits() external view returns (uint256) {\\n        return maxDepositsPerBlock;\\n    }\\n\\n    /**\\n     * Sets `MAX_DEPOSITS_PER_BLOCK`. Only callable by the owner.\\n     */\\n    function setMaxDeposits(uint256 newValue) external onlyOwner {\\n        _setMaxDeposits(newValue);\\n    }\\n\\n    function _setMaxDeposits(uint256 newValue) internal {\\n        maxDepositsPerBlock = newValue;\\n        emit MaxDepositsChanged(newValue);\\n    }\\n\\n\\n    /**\\n     * Returns `MIN_DEPOSIT_BLOCK_DISTANCE`  (see `depositBufferedEther`).\\n     */\\n    function getMinDepositBlockDistance() external view returns (uint256) {\\n        return minDepositBlockDistance;\\n    }\\n\\n    /**\\n     * Sets `MIN_DEPOSIT_BLOCK_DISTANCE`. Only callable by the owner.\\n     */\\n    function setMinDepositBlockDistance(uint256 newValue) external onlyOwner {\\n        _setMinDepositBlockDistance(newValue);\\n    }\\n\\n    function _setMinDepositBlockDistance(uint256 newValue) internal {\\n        require(newValue > 0, \\\"invalid value for minDepositBlockDistance: must be greater then 0\\\");\\n        minDepositBlockDistance = newValue;\\n        emit MinDepositBlockDistanceChanged(newValue);\\n    }\\n\\n\\n    /**\\n     * Returns number of valid guardian signatures required to vet (depositRoot, keysOpIndex) pair.\\n     */\\n    function getGuardianQuorum() external view returns (uint256) {\\n        return quorum;\\n    }\\n\\n    function setGuardianQuorum(uint256 newValue) external onlyOwner {\\n        _setGuardianQuorum(newValue);\\n    }\\n\\n    function _setGuardianQuorum(uint256 newValue) internal {\\n        // we're intentionally allowing setting quorum value higher than the number of quardians\\n        quorum = newValue;\\n        emit GuardianQuorumChanged(newValue);\\n    }\\n\\n\\n    /**\\n     * Returns guardian committee member list.\\n     */\\n    function getGuardians() external view returns (address[] memory) {\\n        return guardians;\\n    }\\n\\n    /**\\n     * Checks whether the given address is a guardian.\\n     */\\n    function isGuardian(address addr) external view returns (bool) {\\n        return _isGuardian(addr);\\n    }\\n\\n    function _isGuardian(address addr) internal view returns (bool) {\\n        return guardianIndicesOneBased[addr] > 0;\\n    }\\n\\n    /**\\n     * Returns index of the guardian, or -1 if the address is not a guardian.\\n     */\\n    function getGuardianIndex(address addr) external view returns (int256) {\\n        return _getGuardianIndex(addr);\\n    }\\n\\n    function _getGuardianIndex(address addr) internal view returns (int256) {\\n        return int256(guardianIndicesOneBased[addr]) - 1;\\n    }\\n\\n    /**\\n     * Adds a guardian address and sets a new quorum value.\\n     * Reverts if the address is already a guardian.\\n     *\\n     * Only callable by the owner.\\n     */\\n    function addGuardian(address addr, uint256 newQuorum) external onlyOwner {\\n        _addGuardian(addr);\\n        _setGuardianQuorum(newQuorum);\\n    }\\n\\n    /**\\n     * Adds a set of guardian addresses and sets a new quorum value.\\n     * Reverts any of them is already a guardian.\\n     *\\n     * Only callable by the owner.\\n     */\\n    function addGuardians(address[] memory addresses, uint256 newQuorum) external onlyOwner {\\n        for (uint256 i = 0; i < addresses.length; ++i) {\\n            _addGuardian(addresses[i]);\\n        }\\n        _setGuardianQuorum(newQuorum);\\n    }\\n\\n    function _addGuardian(address addr) internal {\\n        require(!_isGuardian(addr), \\\"duplicate address\\\");\\n        guardians.push(addr);\\n        guardianIndicesOneBased[addr] = guardians.length;\\n        emit GuardianAdded(addr);\\n    }\\n\\n    /**\\n     * Removes a guardian with the given address and sets a new quorum value.\\n     *\\n     * Only callable by the owner.\\n     */\\n    function removeGuardian(address addr, uint256 newQuorum) external onlyOwner {\\n        uint256 indexOneBased = guardianIndicesOneBased[addr];\\n        require(indexOneBased != 0, \\\"not a guardian\\\");\\n\\n        uint256 totalGuardians = guardians.length;\\n        assert(indexOneBased <= totalGuardians);\\n\\n        if (indexOneBased != totalGuardians) {\\n            address addrToMove = guardians[totalGuardians - 1];\\n            guardians[indexOneBased - 1] = addrToMove;\\n            guardianIndicesOneBased[addrToMove] = indexOneBased;\\n        }\\n\\n        guardianIndicesOneBased[addr] = 0;\\n        guardians.pop();\\n\\n        _setGuardianQuorum(newQuorum);\\n\\n        emit GuardianRemoved(addr);\\n    }\\n\\n\\n    /**\\n     * Returns whether deposits were paused.\\n     */\\n    function isPaused() external view returns (bool) {\\n        return paused;\\n    }\\n\\n    /**\\n     * Pauses deposits given that both conditions are satisfied (reverts otherwise):\\n     *\\n     *   1. The function is called by the guardian with index guardianIndex OR sig\\n     *      is a valid signature by the guardian with index guardianIndex of the data\\n     *      defined below.\\n     *\\n     *   2. block.number - blockNumber <= PAUSE_INTENT_VALIDITY_PERIOD_BLOCKS\\n     *\\n     * The signature, if present, must be produced for keccak256 hash of the following\\n     * message (each component taking 32 bytes):\\n     *\\n     * | PAUSE_MESSAGE_PREFIX | blockNumber\\n     */\\n    function pauseDeposits(uint256 blockNumber, Signature memory sig) external {\\n        if (paused) {\\n            return;\\n        }\\n\\n        address guardianAddr = msg.sender;\\n        int256 guardianIndex = _getGuardianIndex(msg.sender);\\n\\n        if (guardianIndex == -1) {\\n            bytes32 msgHash = keccak256(abi.encodePacked(PAUSE_MESSAGE_PREFIX, blockNumber));\\n            guardianAddr = ECDSA.recover(msgHash, sig.r, sig.vs);\\n            guardianIndex = _getGuardianIndex(guardianAddr);\\n            require(guardianIndex != -1, \\\"invalid signature\\\");\\n        }\\n\\n        require(\\n            block.number - blockNumber <= pauseIntentValidityPeriodBlocks,\\n            \\\"pause intent expired\\\"\\n        );\\n\\n        paused = true;\\n        emit DepositsPaused(guardianAddr);\\n    }\\n\\n    /**\\n     * Unpauses deposits.\\n     *\\n     * Only callable by the owner.\\n     */\\n    function unpauseDeposits() external onlyOwner {\\n        if (paused) {\\n            paused = false;\\n            emit DepositsUnpaused();\\n        }\\n    }\\n\\n\\n    /**\\n     * Returns the last block that contains a deposit performed via this security module.\\n     */\\n    function getLastDepositBlock() external view returns (uint256) {\\n        return lastDepositBlock;\\n    }\\n\\n\\n    /**\\n     * Returns whether depositBufferedEther can be called, given that the caller will provide\\n     * guardian attestations of non-stale deposit root and `keysOpIndex`, and the number of\\n     * such attestations will be enough to reach quorum.\\n     */\\n    function canDeposit() external view returns (bool) {\\n        return !paused && quorum > 0 && block.number - lastDepositBlock >= minDepositBlockDistance;\\n    }\\n\\n\\n    /**\\n     * Calls Lido.depositBufferedEther(MAX_DEPOSITS_PER_BLOCK).\\n     *\\n     * Reverts if any of the following is true:\\n     *   1. IDepositContract.get_deposit_root() != depositRoot.\\n     *   2. INodeOperatorsRegistry.getKeysOpIndex() != keysOpIndex.\\n     *   3. The number of guardian signatures is less than getGuardianQuorum().\\n     *   4. An invalid or non-guardian signature received.\\n     *   5. block.number - getLastDepositBlock() < MIN_DEPOSIT_BLOCK_DISTANCE.\\n     *   6. blockhash(blockNumber) != blockHash.\\n     *\\n     * Signatures must be sorted in ascending order by index of the guardian. Each signature must\\n     * be produced for keccak256 hash of the following message (each component taking 32 bytes):\\n     *\\n     * | ATTEST_MESSAGE_PREFIX | depositRoot | keysOpIndex | blockNumber | blockHash |\\n     */\\n    function depositBufferedEther(\\n        bytes32 depositRoot,\\n        uint256 keysOpIndex,\\n        uint256 blockNumber,\\n        bytes32 blockHash,\\n        Signature[] memory sortedGuardianSignatures\\n    ) external {\\n        bytes32 onchainDepositRoot = IDepositContract(DEPOSIT_CONTRACT).get_deposit_root();\\n        require(depositRoot == onchainDepositRoot, \\\"deposit root changed\\\");\\n\\n        require(!paused, \\\"deposits are paused\\\");\\n        require(quorum > 0 && sortedGuardianSignatures.length >= quorum, \\\"no guardian quorum\\\");\\n\\n        require(block.number - lastDepositBlock >= minDepositBlockDistance, \\\"too frequent deposits\\\");\\n        require(blockHash != bytes32(0) && blockhash(blockNumber) == blockHash, \\\"unexpected block hash\\\");\\n\\n        uint256 onchainKeysOpIndex = INodeOperatorsRegistry(nodeOperatorsRegistry).getKeysOpIndex();\\n        require(keysOpIndex == onchainKeysOpIndex, \\\"keys op index changed\\\");\\n\\n        _verifySignatures(\\n            depositRoot,\\n            keysOpIndex,\\n            blockNumber,\\n            blockHash,\\n            sortedGuardianSignatures\\n        );\\n\\n        ILido(LIDO).depositBufferedEther(maxDepositsPerBlock);\\n        lastDepositBlock = block.number;\\n    }\\n\\n\\n    function _verifySignatures(\\n        bytes32 depositRoot,\\n        uint256 keysOpIndex,\\n        uint256 blockNumber,\\n        bytes32 blockHash,\\n        Signature[] memory sigs\\n    )\\n        internal view\\n    {\\n        bytes32 msgHash = keccak256(abi.encodePacked(\\n            ATTEST_MESSAGE_PREFIX,\\n            depositRoot,\\n            keysOpIndex,\\n            blockNumber,\\n            blockHash\\n        ));\\n\\n        address prevSignerAddr = address(0);\\n\\n        for (uint256 i = 0; i < sigs.length; ++i) {\\n            address signerAddr = ECDSA.recover(msgHash, sigs[i].r, sigs[i].vs);\\n            require(_isGuardian(signerAddr), \\\"invalid signature\\\");\\n            require(signerAddr > prevSignerAddr, \\\"signatures not sorted\\\");\\n            prevSignerAddr = signerAddr;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Extracted from:\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L53\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/541e821/contracts/utils/cryptography/ECDSA.sol#L112\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.8.9;\\n\\n\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`).\\n     * This address can then be used for verification purposes.\\n     * Receives the `v`, `r` and `s` signature fields separately.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address)\\n    {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Overload of `recover` that receives the `r` and `vs` short-signature fields separately.\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return recover(hash, v, r, s);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lido\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nodeOperatorsRegistry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_networkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDepositsPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDepositBlockDistance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pauseIntentValidityPeriodBlocks\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"DepositsPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DepositsUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"GuardianQuorumChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MaxDepositsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MinDepositBlockDistanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"NodeOperatorsRegistryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"PauseIntentValidityPeriodBlocksChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ATTEST_MESSAGE_PREFIX\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIDO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSE_MESSAGE_PREFIX\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"addGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"addGuardians\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"depositRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"keysOpIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vs\",\"type\":\"bytes32\"}],\"internalType\":\"struct DepositSecurityModule.Signature[]\",\"name\":\"sortedGuardianSignatures\",\"type\":\"tuple[]\"}],\"name\":\"depositBufferedEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getGuardianIndex\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuardianQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuardians\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastDepositBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinDepositBlockDistance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeOperatorsRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseIntentValidityPeriodBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isGuardian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vs\",\"type\":\"bytes32\"}],\"internalType\":\"struct DepositSecurityModule.Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"pauseDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"removeGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setGuardianQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMaxDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMinDepositBlockDistance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setNodeOperatorsRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setPauseIntentValidityPeriodBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DepositSecurityModule","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe8400000000000000000000000000000000219ab540356cbb839cbe05303d7705fa00000000000000000000000055032650b14df07b85bf18a3a3ec8e0af2e028d500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000096000000000000000000000000000000000000000000000000000000000000001900000000000000000000000000000000000000000000000000000000000019f6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}