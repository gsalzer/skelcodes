{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/VRFNFTSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.7;\\n\\ninterface IRandomNumberConsumer {\\n  function getRandomNumber() external returns (bytes32 requestId);\\n  function readFulfilledRandomness(bytes32 requestId) external view returns (uint256);\\n  function setRandomnessRequesterApproval(address _requester, bool _approvalStatus) external;\\n}\\n\\ninterface IERC1155 {\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 value, bytes calldata _data) external;\\n    function balanceOf(address _owner, uint256 _id) external view returns(uint256);\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address _who) external returns (uint256);\\n}\\n\\nlibrary Math {\\n    function add(uint a, uint b) internal pure returns (uint c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint a, uint b) internal pure returns (uint c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n    function mul(uint a, uint b) internal pure returns (uint c) {require(a == 0 || (c = a * b)/b == a, \\\"BoringMath: Mul Overflow\\\");}\\n}\\n\\ncontract VRFNFTSaleClonable {\\n    using Math for uint256;\\n\\n    address public controller;\\n    address public hausAddress;\\n    address public stakingSwapContract;\\n    address public vrfProvider;\\n    \\n    IERC1155 public nft;\\n    uint256 public price;\\n    uint256[] public ids;\\n    uint256 public start;\\n    uint256 public end;\\n    uint256 public limitPerOrder;\\n    uint256 public stakingRewardPercentageBasisPoints;\\n\\n    uint256 public ticketId;\\n    mapping(address => uint256[]) public buyerToTicketIds;\\n\\n    bool public isInitialized;\\n    bool public isRandomnessRequested;\\n    bytes32 public randomNumberRequestId;\\n    uint256 public vrfResult;\\n    uint256 public randomOffset;\\n    \\n    event Buy(address buyer, uint256 amount);\\n    event RequestedVRF(bool isRequested, bytes32 randomNumberRequestId);\\n    event CommittedVRF(bytes32 randomNumberRequestId, uint256 vrfResult, uint256 randomOffset);\\n    event ClaimedAssigned(address indexed claimant, uint256 quantity);\\n    \\n    function initialize(\\n        address _hausAddress,\\n        uint256 _startTime,\\n        uint256 _endTime,\\n        address _tokenAddress,\\n        uint256[] memory _tokenIds,\\n        uint256 _priceWei,\\n        uint256 _limitPerOrder,\\n        uint256 _stakingRewardPercentageBasisPoints,\\n        address _stakingSwapContract,\\n        address _vrfProvider,\\n        address _controllerAddress\\n    ) public {\\n        require(isInitialized == false, \\\"Already initialized.\\\");\\n        hausAddress = _hausAddress;\\n        start = _startTime;\\n        end = _endTime;\\n        nft = IERC1155(_tokenAddress);\\n        ids = _tokenIds;\\n        price = _priceWei;\\n        limitPerOrder = _limitPerOrder;\\n        controller = _controllerAddress;\\n        stakingRewardPercentageBasisPoints = _stakingRewardPercentageBasisPoints;\\n        stakingSwapContract = _stakingSwapContract;\\n        ticketId = 0;\\n        vrfProvider = _vrfProvider;\\n        isInitialized = true;\\n    }\\n    \\n    function buy(uint256 amount) public payable {\\n        require(msg.sender == tx.origin, \\\"no contracts\\\");\\n        require(block.timestamp >= start, \\\"early\\\");\\n        require(block.timestamp <= end, \\\"sale has ended\\\");\\n        require(amount > 0, \\\"can't buy zero items\\\");\\n        require((amount <= limitPerOrder) && ((amount + ticketId) <= ids.length), \\\"ordered too many\\\");\\n        require(msg.value == price.mul(amount), \\\"wrong amount\\\");\\n        uint256 stakingReward = (address(this).balance * stakingRewardPercentageBasisPoints) / 10000;\\n        (bool stakingRewardSuccess, ) = stakingSwapContract.call{value: stakingReward}(\\\"\\\");\\n        require(stakingRewardSuccess, \\\"Staking reward transfer failed.\\\");\\n        (bool successMultisig, ) = hausAddress.call{value: address(this).balance}(\\\"\\\");\\n        require(successMultisig, \\\"Multisig transfer failed.\\\");\\n        for(uint256 i = 0; i < amount; i++) {\\n          buyerToTicketIds[msg.sender].push(ticketId);\\n          ticketId++;\\n        }\\n        if(ticketId == (ids.length - 1)) {\\n          end = block.timestamp;\\n        }\\n        emit Buy(msg.sender, amount);\\n    }\\n\\n    function isReservationPeriodOver() public view returns (bool) {\\n      return (block.timestamp > end) || (ticketId == (ids.length - 1));\\n    }\\n\\n    function addressToTicketCount(address _address) public view returns (uint256) {\\n      return buyerToTicketIds[_address].length;\\n    }\\n    \\n    function supply() public view returns(uint256) {\\n        uint256 response = 0;\\n        for(uint256 i = 0; i < ids.length; i++) {\\n          response += nft.balanceOf(address(this), ids[i]);\\n        }\\n        return response;\\n    }\\n\\n    function setTokenAddress(address _tokenAddress) public onlyController {\\n        nft = IERC1155(_tokenAddress);\\n    }\\n\\n    function setTokenIds(uint256[] memory _tokenIds) public onlyController {\\n        ids = _tokenIds;\\n    }\\n\\n    function pull() public onlyController {\\n        for(uint256 i = 0; i < ids.length; i++) {\\n          if(nft.balanceOf(address(this), ids[i]) > 0) {\\n            nft.safeTransferFrom(address(this), controller, ids[i], nft.balanceOf(address(this), ids[i]), new bytes(0x0));\\n          }\\n        }\\n    }\\n\\n    function setEndTime(uint256 _newEndTime) public onlyController {\\n      require(block.timestamp <= _newEndTime, \\\"VRF721NFT::setEndTime: new endTime must be in the future\\\");\\n      end = _newEndTime;\\n    }\\n\\n    modifier onlyController {\\n      require(msg.sender == controller);\\n      _;\\n    }\\n\\n    function initiateRandomDistribution() external {\\n      require(block.timestamp > end, \\\"VRF721NFT::initiateRandomDistribution: minting period has not ended\\\");\\n      require(ticketId > 0, \\\"VRF721NFT::initiateRandomDistribution: ticketId must be more than 0\\\");\\n      require(isRandomnessRequested == false, \\\"VRF721NFT::beginReveal: request for random number has already been initiated\\\");\\n      IRandomNumberConsumer randomNumberConsumer = IRandomNumberConsumer(vrfProvider);\\n      randomNumberRequestId = randomNumberConsumer.getRandomNumber();\\n      isRandomnessRequested = true;\\n      emit RequestedVRF(isRandomnessRequested, randomNumberRequestId);\\n    }\\n\\n    function commitRandomDistribution() external {\\n      require(isRandomnessRequested == true, \\\"VRF721NFT::completeReveal: request for random number has not been initiated\\\");\\n      IRandomNumberConsumer randomNumberConsumer = IRandomNumberConsumer(vrfProvider);\\n      uint256 result = randomNumberConsumer.readFulfilledRandomness(randomNumberRequestId);\\n      require(result > 0, \\\"VRF721NFT::completeReveal: randomResult has not been provided to vrfProvider\\\");\\n      vrfResult = result;\\n      randomOffset = result % ticketId;\\n      emit CommittedVRF(randomNumberRequestId, vrfResult, randomOffset);\\n    }\\n\\n    function claimAssigned() external {\\n      require(vrfResult > 0, \\\"Randomness has not been assigned\\\");\\n      uint256[] memory buyerToTicketIdsMemory = buyerToTicketIds[msg.sender]; // Load into memory to save some gas\\n      uint256 buyerTicketCount = buyerToTicketIdsMemory.length;\\n      require(buyerTicketCount > 0, \\\"buyerTicketCount is not a positive number\\\");\\n      uint256[] memory idsMemory = ids; // Load into memory to save some gas\\n      for(uint256 i = 0; i < buyerTicketCount; i++) {\\n        if((buyerToTicketIdsMemory[i] + randomOffset) <= idsMemory.length - 1) {\\n          uint256 offsetIndex = (buyerToTicketIdsMemory[i] + randomOffset);\\n          nft.safeTransferFrom(address(this), msg.sender, ids[offsetIndex], nft.balanceOf(address(this), ids[offsetIndex]), new bytes(0x0));\\n        } else {\\n          uint256 offsetIndex = randomOffset - (idsMemory.length - buyerToTicketIdsMemory[i]);\\n          nft.safeTransferFrom(address(this), msg.sender, ids[offsetIndex], nft.balanceOf(address(this), ids[offsetIndex]), new bytes(0x0));\\n        }\\n      }\\n      emit ClaimedAssigned(msg.sender, buyerTicketCount);\\n    }\\n    \\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns(bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"ClaimedAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"randomNumberRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vrfResult\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomOffset\",\"type\":\"uint256\"}],\"name\":\"CommittedVRF\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRequested\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"randomNumberRequestId\",\"type\":\"bytes32\"}],\"name\":\"RequestedVRF\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addressToTicketCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buyerToTicketIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAssigned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commitRandomDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hausAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ids\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hausAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_priceWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limitPerOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingRewardPercentageBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_stakingSwapContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vrfProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controllerAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateRandomDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRandomnessRequested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReservationPeriodOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitPerOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomNumberRequestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newEndTime\",\"type\":\"uint256\"}],\"name\":\"setEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"setTokenIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardPercentageBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingSwapContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrfProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrfResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VRFNFTSaleClonable","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}