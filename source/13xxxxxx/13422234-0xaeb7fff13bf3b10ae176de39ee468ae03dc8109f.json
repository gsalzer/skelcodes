{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/Chainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {CBORChainlink} from \\\"./vendor/CBORChainlink.sol\\\";\\nimport {BufferChainlink} from \\\"./vendor/BufferChainlink.sol\\\";\\n\\n/**\\n * @title Library for common Chainlink functions\\n * @dev Uses imported CBOR library for encoding to buffer\\n */\\nlibrary Chainlink {\\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\\n\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  struct Request {\\n    bytes32 id;\\n    address callbackAddress;\\n    bytes4 callbackFunctionId;\\n    uint256 nonce;\\n    BufferChainlink.buffer buf;\\n  }\\n\\n  /**\\n   * @notice Initializes a Chainlink request\\n   * @dev Sets the ID, callback address, and callback function signature on the request\\n   * @param self The uninitialized request\\n   * @param jobId The Job Specification ID\\n   * @param callbackAddr The callback address\\n   * @param callbackFunc The callback function signature\\n   * @return The initialized request\\n   */\\n  function initialize(\\n    Request memory self,\\n    bytes32 jobId,\\n    address callbackAddr,\\n    bytes4 callbackFunc\\n  ) internal pure returns (Chainlink.Request memory) {\\n    BufferChainlink.init(self.buf, defaultBufferSize);\\n    self.id = jobId;\\n    self.callbackAddress = callbackAddr;\\n    self.callbackFunctionId = callbackFunc;\\n    return self;\\n  }\\n\\n  /**\\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\\n   * @param self The initialized request\\n   * @param data The CBOR data\\n   */\\n  function setBuffer(Request memory self, bytes memory data) internal pure {\\n    BufferChainlink.init(self.buf, data.length);\\n    BufferChainlink.append(self.buf, data);\\n  }\\n\\n  /**\\n   * @notice Adds a string value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The string value to add\\n   */\\n  function add(\\n    Request memory self,\\n    string memory key,\\n    string memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeString(value);\\n  }\\n\\n  /**\\n   * @notice Adds a bytes value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The bytes value to add\\n   */\\n  function addBytes(\\n    Request memory self,\\n    string memory key,\\n    bytes memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeBytes(value);\\n  }\\n\\n  /**\\n   * @notice Adds a int256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The int256 value to add\\n   */\\n  function addInt(\\n    Request memory self,\\n    string memory key,\\n    int256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds a uint256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The uint256 value to add\\n   */\\n  function addUint(\\n    Request memory self,\\n    string memory key,\\n    uint256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeUInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds an array of strings to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param values The array of string values to add\\n   */\\n  function addStringArray(\\n    Request memory self,\\n    string memory key,\\n    string[] memory values\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.startArray();\\n    for (uint256 i = 0; i < values.length; i++) {\\n      self.buf.encodeString(values[i]);\\n    }\\n    self.buf.endSequence();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/CBORChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.19;\\n\\nimport {BufferChainlink} from \\\"./BufferChainlink.sol\\\";\\n\\nlibrary CBORChainlink {\\n  using BufferChainlink for BufferChainlink.buffer;\\n\\n  uint8 private constant MAJOR_TYPE_INT = 0;\\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\\n  uint8 private constant MAJOR_TYPE_STRING = 3;\\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n  uint8 private constant MAJOR_TYPE_MAP = 5;\\n  uint8 private constant MAJOR_TYPE_TAG = 6;\\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\\n    if(value <= 23) {\\n      buf.appendUint8(uint8((major << 5) | value));\\n    } else if (value <= 0xFF) {\\n      buf.appendUint8(uint8((major << 5) | 24));\\n      buf.appendInt(value, 1);\\n    } else if (value <= 0xFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 25));\\n      buf.appendInt(value, 2);\\n    } else if (value <= 0xFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 26));\\n      buf.appendInt(value, 4);\\n    } else {\\n      buf.appendUint8(uint8((major << 5) | 27));\\n      buf.appendInt(value, 8);\\n    }\\n  }\\n\\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\\n    buf.appendUint8(uint8((major << 5) | 31));\\n  }\\n\\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, value);\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n    }\\n  }\\n\\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\\n    if(value < -0x10000000000000000) {\\n      encodeSignedBigNum(buf, value);\\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, uint(value));\\n    } else if(value >= 0) {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\\n    }\\n  }\\n\\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n    buf.append(value);\\n  }\\n\\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n    encodeBytes(buf, abi.encode(value));\\n  }\\n\\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\\n  }\\n\\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n    buf.append(bytes(value));\\n  }\\n\\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n  }\\n\\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n  }\\n\\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/BufferChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev A library for working with mutable byte buffers in Solidity.\\n *\\n * Byte buffers are mutable and expandable, and provide a variety of primitives\\n * for writing to them. At any time you can fetch a bytes object containing the\\n * current contents of the buffer. The bytes object should not be stored between\\n * operations, as it may change due to resizing of the buffer.\\n */\\nlibrary BufferChainlink {\\n  /**\\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n   *      a capacity. The capacity may be longer than the current value, in\\n   *      which case it can be extended without the need to allocate more memory.\\n   */\\n  struct buffer {\\n    bytes buf;\\n    uint256 capacity;\\n  }\\n\\n  /**\\n   * @dev Initializes a buffer with an initial capacity.\\n   * @param buf The buffer to initialize.\\n   * @param capacity The number of bytes of space to allocate the buffer.\\n   * @return The buffer, for chaining.\\n   */\\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\\n    if (capacity % 32 != 0) {\\n      capacity += 32 - (capacity % 32);\\n    }\\n    // Allocate space for the buffer data\\n    buf.capacity = capacity;\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(buf, ptr)\\n      mstore(ptr, 0)\\n      mstore(0x40, add(32, add(ptr, capacity)))\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Initializes a new buffer from an existing bytes object.\\n   *      Changes to the buffer may mutate the original value.\\n   * @param b The bytes object to initialize the buffer with.\\n   * @return A new buffer.\\n   */\\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\\n    buffer memory buf;\\n    buf.buf = b;\\n    buf.capacity = b.length;\\n    return buf;\\n  }\\n\\n  function resize(buffer memory buf, uint256 capacity) private pure {\\n    bytes memory oldbuf = buf.buf;\\n    init(buf, capacity);\\n    append(buf, oldbuf);\\n  }\\n\\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\\n    if (a > b) {\\n      return a;\\n    }\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Sets buffer length to 0.\\n   * @param buf The buffer to truncate.\\n   * @return The original buffer, for chaining..\\n   */\\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n    assembly {\\n      let bufptr := mload(buf)\\n      mstore(bufptr, 0)\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The start offset to write to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    require(len <= data.length);\\n\\n    if (off + len > buf.capacity) {\\n      resize(buf, max(buf.capacity, len + off) * 2);\\n    }\\n\\n    uint256 dest;\\n    uint256 src;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Start address = buffer address + offset + sizeof(buffer length)\\n      dest := add(add(bufptr, 32), off)\\n      // Update buffer length if we're extending it\\n      if gt(add(len, off), buflen) {\\n        mstore(bufptr, add(len, off))\\n      }\\n      src := add(data, 32)\\n    }\\n\\n    // Copy word-length chunks while possible\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    // Copy remaining bytes\\n    unchecked {\\n      uint256 mask = (256**(32 - len)) - 1;\\n      assembly {\\n        let srcpart := and(mload(src), not(mask))\\n        let destpart := and(mload(dest), mask)\\n        mstore(dest, or(destpart, srcpart))\\n      }\\n    }\\n\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, len);\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, data.length);\\n  }\\n\\n  /**\\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write the byte at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeUint8(\\n    buffer memory buf,\\n    uint256 off,\\n    uint8 data\\n  ) internal pure returns (buffer memory) {\\n    if (off >= buf.capacity) {\\n      resize(buf, buf.capacity * 2);\\n    }\\n\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Address = buffer address + sizeof(buffer length) + off\\n      let dest := add(add(bufptr, off), 32)\\n      mstore8(dest, data)\\n      // Update buffer length if we extended it\\n      if eq(off, buflen) {\\n        mstore(bufptr, add(buflen, 1))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\\n    return writeUint8(buf, buf.buf.length, data);\\n  }\\n\\n  /**\\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n   *      exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (left-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes32 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    unchecked {\\n      uint256 mask = (256**len) - 1;\\n      // Right-align data\\n      data = data >> (8 * (32 - len));\\n      assembly {\\n        // Memory address of the buffer data\\n        let bufptr := mload(buf)\\n        // Address = buffer address + sizeof(buffer length) + off + len\\n        let dest := add(add(bufptr, off), len)\\n        mstore(dest, or(and(mload(dest), not(mask)), data))\\n        // Update buffer length if we extended it\\n        if gt(add(off, len), mload(bufptr)) {\\n          mstore(bufptr, add(off, len))\\n        }\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeBytes20(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes20 data\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, off, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chhaining.\\n   */\\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, 32);\\n  }\\n\\n  /**\\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (right-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeInt(\\n    buffer memory buf,\\n    uint256 off,\\n    uint256 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint256 mask = (256**len) - 1;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + off + sizeof(buffer length) + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n   * exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer.\\n   */\\n  function appendInt(\\n    buffer memory buf,\\n    uint256 data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return writeInt(buf, buf.buf.length, data, len);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/ChainlinkTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Chainlink.sol\\\";\\nimport \\\"../vendor/CBORChainlink.sol\\\";\\nimport \\\"../vendor/BufferChainlink.sol\\\";\\n\\ncontract ChainlinkTestHelper {\\n  using Chainlink for Chainlink.Request;\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  Chainlink.Request private req;\\n\\n  event RequestData(bytes payload);\\n\\n  function closeEvent() public {\\n    emit RequestData(req.buf.buf);\\n  }\\n\\n  function setBuffer(bytes memory data) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.setBuffer(data);\\n    req = r2;\\n  }\\n\\n  function add(string memory _key, string memory _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.add(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addBytes(string memory _key, bytes memory _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addBytes(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addInt(string memory _key, int256 _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addInt(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addUint(string memory _key, uint256 _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addUint(_key, _value);\\n    req = r2;\\n  }\\n\\n  // Temporarily have method receive bytes32[] memory until experimental\\n  // string[] memory can be invoked from truffle tests.\\n  function addStringArray(string memory _key, string[] memory _values) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addStringArray(_key, _values);\\n    req = r2;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ChainlinkClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Chainlink.sol\\\";\\nimport \\\"./interfaces/ENSInterface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/ChainlinkRequestInterface.sol\\\";\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./interfaces/PointerInterface.sol\\\";\\nimport {ENSResolver as ENSResolver_Chainlink} from \\\"./vendor/ENSResolver.sol\\\";\\n\\n/**\\n * @title The ChainlinkClient contract\\n * @notice Contract writers can inherit this contract in order to create requests for the\\n * Chainlink network\\n */\\nabstract contract ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\\n  uint256 private constant AMOUNT_OVERRIDE = 0;\\n  address private constant SENDER_OVERRIDE = address(0);\\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\\\"link\\\");\\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\\\"oracle\\\");\\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\\n\\n  ENSInterface private s_ens;\\n  bytes32 private s_ensNode;\\n  LinkTokenInterface private s_link;\\n  OperatorInterface private s_oracle;\\n  uint256 private s_requestCount = 1;\\n  mapping(bytes32 => address) private s_pendingRequests;\\n\\n  event ChainlinkRequested(bytes32 indexed id);\\n  event ChainlinkFulfilled(bytes32 indexed id);\\n  event ChainlinkCancelled(bytes32 indexed id);\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackAddr address to operate the callback on\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildChainlinkRequest(\\n    bytes32 specId,\\n    address callbackAddr,\\n    bytes4 callbackFunctionSignature\\n  ) internal pure returns (Chainlink.Request memory) {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\\n    internal\\n    view\\n    returns (Chainlink.Request memory)\\n  {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, address(this), callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      ChainlinkRequestInterface.oracleRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      address(this),\\n      req.callbackFunctionId,\\n      nonce,\\n      ORACLE_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      OperatorInterface.operatorRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      req.callbackFunctionId,\\n      nonce,\\n      OPERATOR_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Make a request to an oracle\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param nonce used to generate the request ID\\n   * @param payment The amount of LINK to send for the request\\n   * @param encodedRequest data encoded for request type specific format\\n   * @return requestId The request ID\\n   */\\n  function _rawRequest(\\n    address oracleAddress,\\n    uint256 nonce,\\n    uint256 payment,\\n    bytes memory encodedRequest\\n  ) private returns (bytes32 requestId) {\\n    requestId = keccak256(abi.encodePacked(this, nonce));\\n    s_pendingRequests[requestId] = oracleAddress;\\n    emit ChainlinkRequested(requestId);\\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \\\"unable to transferAndCall to oracle\\\");\\n  }\\n\\n  /**\\n   * @notice Allows a request to be cancelled if it has not been fulfilled\\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\\n   * Deletes the request from the `pendingRequests` mapping.\\n   * Emits ChainlinkCancelled event.\\n   * @param requestId The request ID\\n   * @param payment The amount of LINK sent for the request\\n   * @param callbackFunc The callback function specified for the request\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelChainlinkRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) internal {\\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkCancelled(requestId);\\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\\n  }\\n\\n  /**\\n   * @notice the next request count to be used in generating a nonce\\n   * @dev starts at 1 in order to ensure consistent gas cost\\n   * @return returns the next request count to be used in a nonce\\n   */\\n  function getNextRequestCount() internal view returns (uint256) {\\n    return s_requestCount;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle address\\n   * @param oracleAddress The address of the oracle contract\\n   */\\n  function setChainlinkOracle(address oracleAddress) internal {\\n    s_oracle = OperatorInterface(oracleAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the LINK token address\\n   * @param linkAddress The address of the LINK token contract\\n   */\\n  function setChainlinkToken(address linkAddress) internal {\\n    s_link = LinkTokenInterface(linkAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the Chainlink token address for the public\\n   * network as given by the Pointer contract\\n   */\\n  function setPublicChainlinkToken() internal {\\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the LINK token\\n   * @return The address of the LINK token\\n   */\\n  function chainlinkTokenAddress() internal view returns (address) {\\n    return address(s_link);\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the oracle contract\\n   * @return The address of the oracle contract\\n   */\\n  function chainlinkOracleAddress() internal view returns (address) {\\n    return address(s_oracle);\\n  }\\n\\n  /**\\n   * @notice Allows for a request which was created on another contract to be fulfilled\\n   * on this contract\\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\\n   * @param requestId The request ID used for the response\\n   */\\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\\n    s_pendingRequests[requestId] = oracleAddress;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\\n   * @dev Accounts for subnodes having different resolvers\\n   * @param ensAddress The address of the ENS contract\\n   * @param node The ENS node hash\\n   */\\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\\n    s_ens = ENSInterface(ensAddress);\\n    s_ensNode = node;\\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\\n    setChainlinkToken(resolver.addr(linkSubnode));\\n    updateChainlinkOracleWithENS();\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle contract with the address resolved by ENS\\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\\n   */\\n  function updateChainlinkOracleWithENS() internal {\\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\\n    setChainlinkOracle(resolver.addr(oracleSubnode));\\n  }\\n\\n  /**\\n   * @notice Ensures that the fulfillment is valid for this contract\\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\\n   * @param requestId The request ID for fulfillment\\n   */\\n  function validateChainlinkCallback(bytes32 requestId)\\n    internal\\n    recordChainlinkFulfillment(requestId)\\n  // solhint-disable-next-line no-empty-blocks\\n  {\\n\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the oracle of the request.\\n   * Emits ChainlinkFulfilled event.\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\\n    require(msg.sender == s_pendingRequests[requestId], \\\"Source must be the oracle of the request\\\");\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkFulfilled(requestId);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the request is already pending\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier notPendingRequest(bytes32 requestId) {\\n    require(s_pendingRequests[requestId] == address(0), \\\"Request is already pending\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/ENSInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ENSInterface {\\n  // Logged when the owner of a node assigns a new owner to a subnode.\\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n  // Logged when the owner of a node transfers ownership to a new account.\\n  event Transfer(bytes32 indexed node, address owner);\\n\\n  // Logged when the resolver for a node changes.\\n  event NewResolver(bytes32 indexed node, address resolver);\\n\\n  // Logged when the TTL of a node changes\\n  event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner\\n  ) external;\\n\\n  function setResolver(bytes32 node, address resolver) external;\\n\\n  function setOwner(bytes32 node, address owner) external;\\n\\n  function setTTL(bytes32 node, uint64 ttl) external;\\n\\n  function owner(bytes32 node) external view returns (address);\\n\\n  function resolver(bytes32 node) external view returns (address);\\n\\n  function ttl(bytes32 node) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/ChainlinkRequestInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ChainlinkRequestInterface {\\n  function oracleRequest(\\n    address sender,\\n    uint256 requestPrice,\\n    bytes32 serviceAgreementID,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OperatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OracleInterface.sol\\\";\\nimport \\\"./ChainlinkRequestInterface.sol\\\";\\n\\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\\n  function operatorRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  ) external returns (bool);\\n\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\\n\\n  function getAuthorizedSenders() external returns (address[] memory);\\n\\n  function setAuthorizedSenders(address[] calldata senders) external;\\n\\n  function getForwarder() external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/PointerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface PointerInterface {\\n  function getAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/ENSResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ENSResolver {\\n  function addr(bytes32 node) public view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OracleInterface {\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  ) external returns (bool);\\n\\n  function isAuthorizedSender(address node) external view returns (bool);\\n\\n  function withdraw(address recipient, uint256 amount) external;\\n\\n  function withdrawable() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/ChainlinkClientTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ChainlinkClient.sol\\\";\\n\\ncontract ChainlinkClientTestHelper is ChainlinkClient {\\n  constructor(address _link, address _oracle) {\\n    setChainlinkToken(_link);\\n    setChainlinkOracle(_oracle);\\n  }\\n\\n  event Request(bytes32 id, address callbackAddress, bytes4 callbackfunctionSelector, bytes data);\\n  event LinkAmount(uint256 amount);\\n\\n  function publicNewRequest(\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature\\n  ) public {\\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    emit Request(req.id, req.callbackAddress, req.callbackFunctionId, req.buf.buf);\\n  }\\n\\n  function publicRequest(\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    sendChainlinkRequest(req, _wei);\\n  }\\n\\n  function publicRequestRunTo(\\n    address _oracle,\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory run = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    sendChainlinkRequestTo(_oracle, run, _wei);\\n  }\\n\\n  function publicRequestOracleData(\\n    bytes32 _id,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory req = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\\n    sendOperatorRequest(req, _wei);\\n  }\\n\\n  function publicRequestOracleDataFrom(\\n    address _oracle,\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory run = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\\n    sendOperatorRequestTo(_oracle, run, _wei);\\n  }\\n\\n  function publicCancelRequest(\\n    bytes32 _requestId,\\n    uint256 _payment,\\n    bytes4 _callbackFunctionId,\\n    uint256 _expiration\\n  ) public {\\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\\n  }\\n\\n  function publicChainlinkToken() public view returns (address) {\\n    return chainlinkTokenAddress();\\n  }\\n\\n  function publicFulfillChainlinkRequest(bytes32 _requestId, bytes32) public {\\n    fulfillRequest(_requestId, bytes32(0));\\n  }\\n\\n  function fulfillRequest(bytes32 _requestId, bytes32) public {\\n    validateChainlinkCallback(_requestId);\\n  }\\n\\n  function publicLINK(uint256 _amount) public {\\n    emit LinkAmount(LINK_DIVISIBILITY * _amount);\\n  }\\n\\n  function publicOracleAddress() public view returns (address) {\\n    return chainlinkOracleAddress();\\n  }\\n\\n  function publicAddExternalRequest(address _oracle, bytes32 _requestId) public {\\n    addChainlinkExternalRequest(_oracle, _requestId);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFSingleConsumerExample.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Example of a single consumer contract which owns the subscription.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFSingleConsumerExample is VRFConsumerBaseV2 {\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n\\n  struct RequestConfig {\\n    uint64 subId;\\n    uint32 callbackGasLimit;\\n    uint16 requestConfirmations;\\n    uint32 numWords;\\n    bytes32 keyHash;\\n  }\\n  RequestConfig public s_requestConfig;\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n\\n  constructor(\\n    address vrfCoordinator,\\n    address link,\\n    uint32 callbackGasLimit,\\n    uint16 requestConfirmations,\\n    uint32 numWords,\\n    bytes32 keyHash\\n  ) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n    s_requestConfig = RequestConfig({\\n      subId: 0, // Unset\\n      callbackGasLimit: callbackGasLimit,\\n      requestConfirmations: requestConfirmations,\\n      numWords: numWords,\\n      keyHash: keyHash\\n    });\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    s_randomWords = randomWords;\\n  }\\n\\n  function requestRandomWords() external {\\n    RequestConfig memory rc = s_requestConfig;\\n    // Will revert if subscription is not set and funded.\\n    s_requestId = COORDINATOR.requestRandomWords(\\n      rc.keyHash,\\n      rc.subId,\\n      rc.requestConfirmations,\\n      rc.callbackGasLimit,\\n      rc.numWords\\n    );\\n  }\\n\\n  // Assumes this contract owns link\\n  function topUpSubscription(uint256 amount) external {\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_requestConfig.subId));\\n  }\\n\\n  function unsubscribe() external {\\n    // Returns funds to this address\\n    COORDINATOR.cancelSubscription(s_requestConfig.subId, address(this));\\n    s_requestConfig.subId = 0;\\n  }\\n\\n  function subscribe() external {\\n    address[] memory consumers = new address[](1);\\n    consumers[0] = address(this);\\n    s_requestConfig.subId = COORDINATOR.createSubscription();\\n    COORDINATOR.addConsumer(s_requestConfig.subId, consumers[0]);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Returns the global config that applies to all VRF requests.\\n   * @return minimumRequestBlockConfirmations - A minimum number of confirmation\\n   * blocks on VRF requests before oracles should respond.\\n   * @return fulfillmentFlatFeeLinkPPM - The charge per request on top of the gas fees.\\n   * Its flat fee specified in millionths of LINK.\\n   * @return maxGasLimit - The maximum gas limit supported for a fulfillRandomWords callback.\\n   * @return stalenessSeconds - How long we wait until we consider the ETH/LINK price\\n   * (used for converting gas costs to LINK) is stale and use `fallbackWeiPerUnitLink`\\n   * @return gasAfterPaymentCalculation - How much gas is used outside of the payment calculation,\\n   * i.e. the gas overhead of actually making the payment to oracles.\\n   * @return minimumSubscriptionBalance - The minimum subscription balance required to make a request. Its set to be about 300%\\n   * of the cost of a single request to handle in ETH/LINK price between request and fulfillment time.\\n   * @return fallbackWeiPerUnitLink - fallback ETH/LINK price in the case of a stale feed.\\n   */\\n  function getConfig()\\n    external\\n    view\\n    returns (\\n      uint16 minimumRequestBlockConfirmations,\\n      uint32 fulfillmentFlatFeeLinkPPM,\\n      uint32 maxGasLimit,\\n      uint32 stalenessSeconds,\\n      uint32 gasAfterPaymentCalculation,\\n      uint96 minimumSubscriptionBalance,\\n      int256 fallbackWeiPerUnitLink\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with at least minimumSubscriptionBalance (see getConfig) LINK\\n   * before making a request.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [5000, maxGasLimit].\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return owner - Owner of the subscription\\n   * @return consumers - List of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Withdraw funds from a VRF subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the withdrawn LINK to\\n   * @param amount - How much to withdraw in juels\\n   */\\n  function defundSubscription(\\n    uint64 subId,\\n    address to,\\n    uint96 amount\\n  ) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFMaliciousConsumerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFMaliciousConsumerV2 is VRFConsumerBaseV2 {\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n  uint64 public s_subId;\\n  uint256 public s_gasAvailable;\\n  bytes32 s_keyHash;\\n\\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n  }\\n\\n  function setKeyHash(bytes32 keyHash) public {\\n    s_keyHash = keyHash;\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    s_gasAvailable = gasleft();\\n    s_randomWords = randomWords;\\n    s_requestId = requestId;\\n    // Should revert\\n    COORDINATOR.requestRandomWords(s_keyHash, s_subId, 1, 200000, 1);\\n  }\\n\\n  function testCreateSubscriptionAndFund(uint96 amount) external {\\n    if (s_subId == 0) {\\n      s_subId = COORDINATOR.createSubscription();\\n      COORDINATOR.addConsumer(s_subId, address(this));\\n    }\\n    // Approve the link transfer.\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\\n  }\\n\\n  function updateSubscription(address[] memory consumers) external {\\n    require(s_subId != 0, \\\"subID not set\\\");\\n    for (uint256 i = 0; i < consumers.length; i++) {\\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\\n    }\\n  }\\n\\n  function testRequestRandomness() external returns (uint256) {\\n    return COORDINATOR.requestRandomWords(s_keyHash, s_subId, 1, 500000, 1);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFConsumerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFConsumerV2 is VRFConsumerBaseV2 {\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n  uint64 public s_subId;\\n  uint256 public s_gasAvailable;\\n\\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    s_gasAvailable = gasleft();\\n    s_randomWords = randomWords;\\n    s_requestId = requestId;\\n  }\\n\\n  function testCreateSubscriptionAndFund(uint96 amount) external {\\n    if (s_subId == 0) {\\n      s_subId = COORDINATOR.createSubscription();\\n      COORDINATOR.addConsumer(s_subId, address(this));\\n    }\\n    // Approve the link transfer.\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\\n  }\\n\\n  function updateSubscription(address[] memory consumers) external {\\n    require(s_subId != 0, \\\"subID not set\\\");\\n    for (uint256 i = 0; i < consumers.length; i++) {\\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\\n    }\\n  }\\n\\n  function testRequestRandomness(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minReqConfs,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256) {\\n    return COORDINATOR.requestRandomWords(keyHash, subId, minReqConfs, callbackGasLimit, numWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFConsumerExternalSubOwnerExample.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFConsumerExternalSubOwnerExample is VRFConsumerBaseV2 {\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n\\n  struct RequestConfig {\\n    uint64 subId;\\n    uint32 callbackGasLimit;\\n    uint16 requestConfirmations;\\n    uint32 numWords;\\n    bytes32 keyHash;\\n  }\\n  RequestConfig s_requestConfig;\\n  uint256[] s_randomWords;\\n  uint256 s_requestId;\\n\\n  constructor(\\n    address vrfCoordinator,\\n    address link,\\n    uint32 callbackGasLimit,\\n    uint16 requestConfirmations,\\n    uint32 numWords,\\n    bytes32 keyHash\\n  ) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n    s_requestConfig = RequestConfig({\\n      subId: 0, // Initially unset\\n      callbackGasLimit: callbackGasLimit,\\n      requestConfirmations: requestConfirmations,\\n      numWords: numWords,\\n      keyHash: keyHash\\n    });\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    s_randomWords = randomWords;\\n  }\\n\\n  function requestRandomWords() external {\\n    RequestConfig memory rc = s_requestConfig;\\n    // Will revert if subscription is not set and funded.\\n    s_requestId = COORDINATOR.requestRandomWords(\\n      rc.keyHash,\\n      rc.subId,\\n      rc.requestConfirmations,\\n      rc.callbackGasLimit,\\n      rc.numWords\\n    );\\n  }\\n\\n  function setSubscriptionID(uint64 subId) public {\\n    s_requestConfig.subId = subId;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/VRFCoordinatorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/BlockhashStoreInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\n\\nimport \\\"./VRF.sol\\\";\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"./VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFCoordinatorV2 is VRF, ConfirmedOwner, TypeAndVersionInterface {\\n  LinkTokenInterface public immutable LINK;\\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\\n  BlockhashStoreInterface public immutable BLOCKHASH_STORE;\\n\\n  // We need to maintain a list of consuming addresses.\\n  // This bound ensures we are able to loop over them as needed.\\n  // Should a user require more consumers, they can use multiple subscriptions.\\n  uint16 public constant MAX_CONSUMERS = 100;\\n  error TooManyConsumers();\\n  error InsufficientBalance();\\n  error InvalidConsumer(uint64 subId, address consumer);\\n  error InvalidSubscription();\\n  error OnlyCallableFromLink();\\n  error InvalidCalldata();\\n  error MustBeSubOwner(address owner);\\n  error MustBeRequestedOwner(address proposedOwner);\\n  error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance); // Should never happen\\n  event FundsRecovered(address to, uint256 amount);\\n  struct Subscription {\\n    // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)\\n    uint96 balance; // Common link balance used for all consumer requests.\\n    address owner; // Owner can fund/withdraw/cancel the sub.\\n    address requestedOwner; // For safely transferring sub ownership.\\n    // Maintains the list of keys in s_consumers.\\n    // We do this for 2 reasons:\\n    // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\\n    // 2. To be able to return the list of all consumers in getSubscription.\\n    // Note that we need the s_consumers map to be able to directly check if a\\n    // consumer is valid without reading all the consumers from storage.\\n    address[] consumers;\\n  }\\n  struct Consumer {\\n    uint64 subId;\\n    uint64 nonce;\\n  }\\n  mapping(address => mapping(uint64 => Consumer)) /* consumer */ /* subId */\\n    private s_consumers;\\n  mapping(uint64 => Subscription) /* subId */ /* subscription */\\n    private s_subscriptions;\\n  uint64 private s_currentSubId;\\n  // s_totalBalance tracks the total link sent to/from\\n  // this contract through onTokenTransfer, defundSubscription, cancelSubscription and oracleWithdraw.\\n  // A discrepancy with this contract's link balance indicates someone\\n  // sent tokens using transfer and so we may need to use recoverFunds.\\n  uint96 public s_totalBalance;\\n  event SubscriptionCreated(uint64 indexed subId, address owner);\\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\\n  event SubscriptionConsumerAdded(uint64 indexed subId, address consumer);\\n  event SubscriptionConsumerRemoved(uint64 indexed subId, address consumer);\\n  event SubscriptionDefunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\\n  event SubscriptionOwnerTransferRequested(uint64 indexed subId, address from, address to);\\n  event SubscriptionOwnerTransferred(uint64 indexed subId, address from, address to);\\n\\n  // Set this maximum to 200 to give us a 56 block window to fulfill\\n  // the request before requiring the block hash feeder.\\n  uint16 public constant MAX_REQUEST_CONFIRMATIONS = 200;\\n  uint32 public constant MAX_NUM_WORDS = 500;\\n  // The minimum gas limit that could be requested for a callback.\\n  // Set to 5k to ensure plenty of room to make the call itself.\\n  uint256 public constant MIN_GAS_LIMIT = 5_000;\\n  error InvalidRequestConfirmations(uint16 have, uint16 min, uint16 max);\\n  error GasLimitTooBig(uint32 have, uint32 want);\\n  error NumWordsTooBig(uint32 have, uint32 want);\\n  error ProvingKeyAlreadyRegistered(bytes32 keyHash);\\n  error NoSuchProvingKey(bytes32 keyHash);\\n  error InvalidLinkWeiPrice(int256 linkWei);\\n  error InsufficientGasForConsumer(uint256 have, uint256 want);\\n  error NoCorrespondingRequest();\\n  error IncorrectCommitment();\\n  error BlockhashNotInStore(uint256 blockNum);\\n  error PaymentTooLarge();\\n  error Reentrant();\\n  struct RequestCommitment {\\n    uint64 blockNum;\\n    uint64 subId;\\n    uint32 callbackGasLimit;\\n    uint32 numWords;\\n    address sender;\\n  }\\n  mapping(bytes32 => address) /* keyHash */ /* oracle */\\n    private s_provingKeys;\\n  mapping(address => uint96) /* oracle */ /* LINK balance */\\n    private s_withdrawableTokens;\\n  mapping(uint256 => bytes32) /* requestID */ /* commitment */\\n    private s_requestCommitments;\\n  event ProvingKeyRegistered(bytes32 keyHash, address indexed oracle);\\n  event ProvingKeyDeregistered(bytes32 keyHash, address indexed oracle);\\n  event RandomWordsRequested(\\n    bytes32 indexed keyHash,\\n    uint256 requestId,\\n    uint256 preSeed,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords,\\n    address indexed sender\\n  );\\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256[] output, bool success);\\n\\n  struct Config {\\n    uint16 minimumRequestConfirmations;\\n    // Flat fee charged per fulfillment in millionths of link\\n    // So fee range is [0, 2^32/10^6].\\n    uint32 fulfillmentFlatFeeLinkPPM;\\n    uint32 maxGasLimit;\\n    // stalenessSeconds is how long before we consider the feed price to be stale\\n    // and fallback to fallbackWeiPerUnitLink.\\n    uint32 stalenessSeconds;\\n    // Gas to cover oracle payment after we calculate the payment.\\n    // We make it configurable in case those operations are repriced.\\n    uint32 gasAfterPaymentCalculation;\\n    uint96 minimumSubscriptionBalance;\\n    // Re-entrancy protection.\\n    bool reentrancyLock;\\n  }\\n  int256 internal s_fallbackWeiPerUnitLink;\\n  Config private s_config;\\n  event ConfigSet(\\n    uint16 minimumRequestConfirmations,\\n    uint32 fulfillmentFlatFeeLinkPPM,\\n    uint32 maxGasLimit,\\n    uint32 stalenessSeconds,\\n    uint32 gasAfterPaymentCalculation,\\n    uint96 minimumSubscriptionBalance,\\n    int256 fallbackWeiPerUnitLink\\n  );\\n\\n  constructor(\\n    address link,\\n    address blockhashStore,\\n    address linkEthFeed\\n  ) ConfirmedOwner(msg.sender) {\\n    LINK = LinkTokenInterface(link);\\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\\n    BLOCKHASH_STORE = BlockhashStoreInterface(blockhashStore);\\n  }\\n\\n  /**\\n   * @notice Registers a proving key to an oracle.\\n   * @param oracle address of the oracle\\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\\n   */\\n  function registerProvingKey(address oracle, uint256[2] calldata publicProvingKey) external onlyOwner {\\n    bytes32 kh = hashOfKey(publicProvingKey);\\n    if (s_provingKeys[kh] != address(0)) {\\n      revert ProvingKeyAlreadyRegistered(kh);\\n    }\\n    s_provingKeys[kh] = oracle;\\n    emit ProvingKeyRegistered(kh, oracle);\\n  }\\n\\n  /**\\n   * @notice Deregisters a proving key to an oracle.\\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\\n   */\\n  function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\\n    bytes32 kh = hashOfKey(publicProvingKey);\\n    address oracle = s_provingKeys[kh];\\n    if (oracle == address(0)) {\\n      revert NoSuchProvingKey(kh);\\n    }\\n    delete s_provingKeys[kh];\\n    emit ProvingKeyDeregistered(kh, oracle);\\n  }\\n\\n  /**\\n   * @notice Returns the serviceAgreements key associated with this public key\\n   * @param publicKey the key to return the address for\\n   */\\n  function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\\n    return keccak256(abi.encode(publicKey));\\n  }\\n\\n  function setConfig(\\n    uint16 minimumRequestConfirmations,\\n    uint32 fulfillmentFlatFeeLinkPPM,\\n    uint32 maxGasLimit,\\n    uint32 stalenessSeconds,\\n    uint32 gasAfterPaymentCalculation,\\n    uint96 minimumSubscriptionBalance,\\n    int256 fallbackWeiPerUnitLink\\n  ) external onlyOwner {\\n    if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\\n      revert InvalidRequestConfirmations(\\n        minimumRequestConfirmations,\\n        minimumRequestConfirmations,\\n        MAX_REQUEST_CONFIRMATIONS\\n      );\\n    }\\n    if (fallbackWeiPerUnitLink <= 0) {\\n      revert InvalidLinkWeiPrice(fallbackWeiPerUnitLink);\\n    }\\n    s_config = Config({\\n      minimumRequestConfirmations: minimumRequestConfirmations,\\n      fulfillmentFlatFeeLinkPPM: fulfillmentFlatFeeLinkPPM,\\n      maxGasLimit: maxGasLimit,\\n      stalenessSeconds: stalenessSeconds,\\n      gasAfterPaymentCalculation: gasAfterPaymentCalculation,\\n      minimumSubscriptionBalance: minimumSubscriptionBalance,\\n      reentrancyLock: false\\n    });\\n    s_fallbackWeiPerUnitLink = fallbackWeiPerUnitLink;\\n    emit ConfigSet(\\n      minimumRequestConfirmations,\\n      fulfillmentFlatFeeLinkPPM,\\n      maxGasLimit,\\n      stalenessSeconds,\\n      gasAfterPaymentCalculation,\\n      minimumSubscriptionBalance,\\n      fallbackWeiPerUnitLink\\n    );\\n  }\\n\\n  /**\\n   * @notice read the current configuration of the coordinator.\\n   */\\n  function getConfig()\\n    external\\n    view\\n    returns (\\n      uint16 minimumRequestConfirmations,\\n      uint32 fulfillmentFlatFeeLinkPPM,\\n      uint32 maxGasLimit,\\n      uint32 stalenessSeconds,\\n      uint32 gasAfterPaymentCalculation,\\n      uint96 minimumSubscriptionBalance,\\n      int256 fallbackWeiPerUnitLink\\n    )\\n  {\\n    Config memory config = s_config;\\n    return (\\n      config.minimumRequestConfirmations,\\n      config.fulfillmentFlatFeeLinkPPM,\\n      config.maxGasLimit,\\n      config.stalenessSeconds,\\n      config.gasAfterPaymentCalculation,\\n      config.minimumSubscriptionBalance,\\n      s_fallbackWeiPerUnitLink\\n    );\\n  }\\n\\n  function recoverFunds(address to) external onlyOwner {\\n    uint256 externalBalance = LINK.balanceOf(address(this));\\n    uint256 internalBalance = uint256(s_totalBalance);\\n    if (internalBalance > externalBalance) {\\n      revert BalanceInvariantViolated(internalBalance, externalBalance);\\n    }\\n    if (internalBalance < externalBalance) {\\n      uint256 amount = externalBalance - internalBalance;\\n      LINK.transfer(to, amount);\\n      emit FundsRecovered(to, amount);\\n    }\\n    // If the balances are equal, nothing to be done.\\n  }\\n\\n  // Want to ensure these arguments can fit inside of 2 words\\n  // so in the worst case where the consuming contract has to read all of them\\n  // from storage, it only has to read 2 words.\\n  function requestRandomWords(\\n    bytes32 keyHash, // Corresponds to a particular offchain job which uses that key for the proofs\\n    uint64 subId,\\n    uint16 requestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords // Desired number of random words\\n  ) external nonReentrant returns (uint256) {\\n    // Input validation using the subscription storage.\\n    if (s_subscriptions[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    // Its important to ensure that the consumer is in fact who they say they\\n    // are, otherwise they could use someone else's subscription balance.\\n    Consumer memory consumer = s_consumers[msg.sender][subId];\\n    if (consumer.subId == 0) {\\n      revert InvalidConsumer(subId, msg.sender);\\n    }\\n    // Input validation using the config storage word.\\n    if (\\n      requestConfirmations < s_config.minimumRequestConfirmations || requestConfirmations > MAX_REQUEST_CONFIRMATIONS\\n    ) {\\n      revert InvalidRequestConfirmations(\\n        requestConfirmations,\\n        s_config.minimumRequestConfirmations,\\n        MAX_REQUEST_CONFIRMATIONS\\n      );\\n    }\\n    if (s_subscriptions[subId].balance < s_config.minimumSubscriptionBalance) {\\n      revert InsufficientBalance();\\n    }\\n    if (callbackGasLimit > s_config.maxGasLimit) {\\n      revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\\n    }\\n    if (numWords > MAX_NUM_WORDS) {\\n      revert NumWordsTooBig(numWords, MAX_NUM_WORDS);\\n    }\\n    // Note we do not check whether the keyHash is valid to save gas.\\n    // The consequence for users is that they can send requests\\n    // for invalid keyHashes which will simply not be fulfilled.\\n    uint64 nonce = consumer.nonce + 1;\\n    uint256 preSeed = uint256(keccak256(abi.encode(keyHash, msg.sender, subId, nonce)));\\n    uint256 requestId = uint256(keccak256(abi.encode(keyHash, preSeed)));\\n\\n    s_requestCommitments[requestId] = keccak256(\\n      abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\\n    );\\n    emit RandomWordsRequested(\\n      keyHash,\\n      requestId,\\n      preSeed,\\n      subId,\\n      requestConfirmations,\\n      callbackGasLimit,\\n      numWords,\\n      msg.sender\\n    );\\n    s_consumers[msg.sender][subId].nonce = nonce;\\n\\n    return requestId;\\n  }\\n\\n  function getCommitment(uint256 requestId) external view returns (bytes32) {\\n    return s_requestCommitments[requestId];\\n  }\\n\\n  /**\\n   * @dev calls target address with exactly gasAmount gas and data as calldata\\n   * or reverts if at least gasAmount gas is not available.\\n   * The maximum amount of gasAmount is all gas available but 1/64th.\\n   * The minimum amount of gasAmount is MIN_GAS_LIMIT.\\n   */\\n  function callWithExactGas(\\n    uint256 gasAmount,\\n    address target,\\n    bytes memory data\\n  ) private returns (bool success) {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      let g := gas()\\n      // Compute g -= MIN_GAS_LIMIT and check for underflow\\n      if lt(g, MIN_GAS_LIMIT) {\\n        revert(0, 0)\\n      }\\n      g := sub(g, MIN_GAS_LIMIT)\\n      // if g - g//64 <= gasAmount, revert\\n      // (we subtract g//64 because of EIP-150)\\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\\n        revert(0, 0)\\n      }\\n      // solidity calls check that a contract actually exists at the destination, so we do the same\\n      if iszero(extcodesize(target)) {\\n        revert(0, 0)\\n      }\\n      // call and return whether we succeeded. ignore return data\\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\\n    }\\n    return success;\\n  }\\n\\n  function getRandomnessFromProof(Proof memory proof, RequestCommitment memory rc)\\n    private\\n    view\\n    returns (\\n      bytes32 keyHash,\\n      uint256 requestId,\\n      uint256 randomness\\n    )\\n  {\\n    keyHash = hashOfKey(proof.pk);\\n    // Only registered proving keys are permitted.\\n    address oracle = s_provingKeys[keyHash];\\n    if (oracle == address(0)) {\\n      revert NoSuchProvingKey(keyHash);\\n    }\\n    requestId = uint256(keccak256(abi.encode(keyHash, proof.seed)));\\n    bytes32 commitment = s_requestCommitments[requestId];\\n    if (commitment == 0) {\\n      revert NoCorrespondingRequest();\\n    }\\n    if (\\n      commitment != keccak256(abi.encode(requestId, rc.blockNum, rc.subId, rc.callbackGasLimit, rc.numWords, rc.sender))\\n    ) {\\n      revert IncorrectCommitment();\\n    }\\n\\n    bytes32 blockHash = blockhash(rc.blockNum);\\n    if (blockHash == bytes32(0)) {\\n      blockHash = BLOCKHASH_STORE.getBlockhash(rc.blockNum);\\n      if (blockHash == bytes32(0)) {\\n        revert BlockhashNotInStore(rc.blockNum);\\n      }\\n    }\\n\\n    // The seed actually used by the VRF machinery, mixing in the blockhash\\n    uint256 actualSeed = uint256(keccak256(abi.encodePacked(proof.seed, blockHash)));\\n    randomness = VRF.randomValueFromVRFProof(proof, actualSeed); // Reverts on failure\\n  }\\n\\n  function fulfillRandomWords(Proof memory proof, RequestCommitment memory rc) external nonReentrant {\\n    uint256 startGas = gasleft();\\n    (bytes32 keyHash, uint256 requestId, uint256 randomness) = getRandomnessFromProof(proof, rc);\\n\\n    uint256[] memory randomWords = new uint256[](rc.numWords);\\n    for (uint256 i = 0; i < rc.numWords; i++) {\\n      randomWords[i] = uint256(keccak256(abi.encode(randomness, i)));\\n    }\\n\\n    delete s_requestCommitments[requestId];\\n    VRFConsumerBaseV2 v;\\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, proof.seed, randomWords);\\n    uint256 gasPreCallback = gasleft();\\n    if (gasPreCallback < rc.callbackGasLimit) {\\n      revert InsufficientGasForConsumer(gasPreCallback, rc.callbackGasLimit);\\n    }\\n    // Call with explicitly the amount of callback gas requested\\n    // Important to not let them exhaust the gas budget and avoid oracle payment.\\n    // Do not allow any non-view/non-pure coordinator functions to be called\\n    // during the consumers callback code via reentrancyLock.\\n    s_config.reentrancyLock = true;\\n    bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\\n    emit RandomWordsFulfilled(requestId, randomWords, success);\\n    s_config.reentrancyLock = false;\\n\\n    // We want to charge users exactly for how much gas they use in their callback.\\n    // The gasAfterPaymentCalculation is meant to cover these additional operations where we\\n    // decrement the subscription balance and increment the oracles withdrawable balance.\\n    // We also add the flat link fee to the payment amount.\\n    // Its specified in millionths of link, if s_config.fulfillmentFlatFeeLinkPPM = 1\\n    // 1 link / 1e6 = 1e18 juels / 1e6 = 1e12 juels.\\n    uint96 payment = calculatePaymentAmount(\\n      startGas,\\n      s_config.gasAfterPaymentCalculation,\\n      s_config.fulfillmentFlatFeeLinkPPM,\\n      tx.gasprice\\n    );\\n    if (s_subscriptions[rc.subId].balance < payment) {\\n      revert InsufficientBalance();\\n    }\\n    s_subscriptions[rc.subId].balance -= payment;\\n    s_withdrawableTokens[s_provingKeys[keyHash]] += payment;\\n  }\\n\\n  // Get the amount of gas used for fulfillment\\n  function calculatePaymentAmount(\\n    uint256 startGas,\\n    uint256 gasAfterPaymentCalculation,\\n    uint32 fulfillmentFlatFeeLinkPPM,\\n    uint256 weiPerUnitGas\\n  ) internal view returns (uint96) {\\n    int256 weiPerUnitLink;\\n    weiPerUnitLink = getFeedData();\\n    if (weiPerUnitLink <= 0) {\\n      revert InvalidLinkWeiPrice(weiPerUnitLink);\\n    }\\n    // (1e18 juels/link) (wei/gas * gas) / (wei/link) = juels\\n    uint256 paymentNoFee = (1e18 * weiPerUnitGas * (gasAfterPaymentCalculation + startGas - gasleft())) /\\n      uint256(weiPerUnitLink);\\n    uint256 fee = 1e12 * uint256(fulfillmentFlatFeeLinkPPM);\\n    if (paymentNoFee > (1e27 - fee)) {\\n      revert PaymentTooLarge(); // Payment + fee cannot be more than all of the link in existence.\\n    }\\n    return uint96(paymentNoFee + fee);\\n  }\\n\\n  function getFeedData() private view returns (int256) {\\n    uint32 stalenessSeconds = s_config.stalenessSeconds;\\n    bool staleFallback = stalenessSeconds > 0;\\n    uint256 timestamp;\\n    int256 weiPerUnitLink;\\n    (, weiPerUnitLink, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\\n    // solhint-disable-next-line not-rely-on-time\\n    if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\\n      weiPerUnitLink = s_fallbackWeiPerUnitLink;\\n    }\\n    return weiPerUnitLink;\\n  }\\n\\n  function oracleWithdraw(address recipient, uint96 amount) external nonReentrant {\\n    if (s_withdrawableTokens[msg.sender] < amount) {\\n      revert InsufficientBalance();\\n    }\\n    s_withdrawableTokens[msg.sender] -= amount;\\n    s_totalBalance -= amount;\\n    if (!LINK.transfer(recipient, amount)) {\\n      revert InsufficientBalance();\\n    }\\n  }\\n\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external nonReentrant {\\n    if (msg.sender != address(LINK)) {\\n      revert OnlyCallableFromLink();\\n    }\\n    if (data.length != 32) {\\n      revert InvalidCalldata();\\n    }\\n    uint64 subId = abi.decode(data, (uint64));\\n    if (s_subscriptions[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    address owner = s_subscriptions[subId].owner;\\n    if (owner != sender) {\\n      revert MustBeSubOwner(owner);\\n    }\\n    uint256 oldBalance = s_subscriptions[subId].balance;\\n    s_subscriptions[subId].balance += uint96(amount);\\n    s_totalBalance += uint96(amount);\\n    emit SubscriptionFunded(subId, oldBalance, oldBalance + amount);\\n  }\\n\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      address owner,\\n      address[] memory consumers\\n    )\\n  {\\n    if (s_subscriptions[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    return (s_subscriptions[subId].balance, s_subscriptions[subId].owner, s_subscriptions[subId].consumers);\\n  }\\n\\n  function createSubscription() external nonReentrant returns (uint64) {\\n    s_currentSubId++;\\n    uint64 currentSubId = s_currentSubId;\\n    address[] memory consumers = new address[](0);\\n    s_subscriptions[currentSubId] = Subscription({\\n      balance: 0,\\n      owner: msg.sender,\\n      requestedOwner: address(0),\\n      consumers: consumers\\n    });\\n\\n    emit SubscriptionCreated(currentSubId, msg.sender);\\n    return currentSubId;\\n  }\\n\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external onlySubOwner(subId) nonReentrant {\\n    // Proposing to address(0) would never be claimable so don't need to check.\\n    if (s_subscriptions[subId].requestedOwner != newOwner) {\\n      s_subscriptions[subId].requestedOwner = newOwner;\\n      emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\\n    }\\n  }\\n\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external nonReentrant {\\n    if (s_subscriptions[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    if (s_subscriptions[subId].requestedOwner != msg.sender) {\\n      revert MustBeRequestedOwner(s_subscriptions[subId].requestedOwner);\\n    }\\n    address oldOwner = s_subscriptions[subId].owner;\\n    s_subscriptions[subId].owner = msg.sender;\\n    s_subscriptions[subId].requestedOwner = address(0);\\n    emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\\n  }\\n\\n  function removeConsumer(uint64 subId, address consumer) external onlySubOwner(subId) nonReentrant {\\n    if (s_consumers[consumer][subId].subId == 0) {\\n      revert InvalidConsumer(subId, consumer);\\n    }\\n    // Note bounded by MAX_CONSUMERS\\n    address[] memory consumers = s_subscriptions[subId].consumers;\\n    uint256 lastConsumerIndex = consumers.length - 1;\\n    for (uint256 i = 0; i < consumers.length; i++) {\\n      if (consumers[i] == consumer) {\\n        address last = consumers[lastConsumerIndex];\\n        // Storage write to preserve last element\\n        s_subscriptions[subId].consumers[i] = last;\\n        // Storage remove last element\\n        s_subscriptions[subId].consumers.pop();\\n        break;\\n      }\\n    }\\n    delete s_consumers[consumer][subId];\\n    emit SubscriptionConsumerRemoved(subId, consumer);\\n  }\\n\\n  function addConsumer(uint64 subId, address consumer) external onlySubOwner(subId) nonReentrant {\\n    // Already maxed, cannot add any more consumers.\\n    if (s_subscriptions[subId].consumers.length == MAX_CONSUMERS) {\\n      revert TooManyConsumers();\\n    }\\n    if (s_consumers[consumer][subId].subId != 0) {\\n      // Idempotence - do nothing if already added.\\n      // Ensures uniqueness in s_subscriptions[subId].consumers.\\n      return;\\n    }\\n    s_consumers[consumer][subId] = Consumer({subId: subId, nonce: 0});\\n    s_subscriptions[subId].consumers.push(consumer);\\n\\n    emit SubscriptionConsumerAdded(subId, consumer);\\n  }\\n\\n  function defundSubscription(\\n    uint64 subId,\\n    address to,\\n    uint96 amount\\n  ) external onlySubOwner(subId) nonReentrant {\\n    if (s_subscriptions[subId].balance < amount) {\\n      revert InsufficientBalance();\\n    }\\n    uint256 oldBalance = s_subscriptions[subId].balance;\\n    s_subscriptions[subId].balance -= amount;\\n    s_totalBalance -= amount;\\n    if (!LINK.transfer(to, amount)) {\\n      revert InsufficientBalance();\\n    }\\n    emit SubscriptionDefunded(subId, oldBalance, s_subscriptions[subId].balance);\\n  }\\n\\n  // Keep this separate from zeroing, perhaps there is a use case where consumers\\n  // want to keep the subId, but withdraw all the link.\\n  function cancelSubscription(uint64 subId, address to) external onlySubOwner(subId) nonReentrant {\\n    Subscription memory sub = s_subscriptions[subId];\\n    uint96 balance = sub.balance;\\n    // Note bounded by MAX_CONSUMERS;\\n    // If no consumers, does nothing.\\n    for (uint256 i = 0; i < sub.consumers.length; i++) {\\n      delete s_consumers[sub.consumers[i]][subId];\\n    }\\n    delete s_subscriptions[subId];\\n    s_totalBalance -= balance;\\n    if (!LINK.transfer(to, uint256(balance))) {\\n      revert InsufficientBalance();\\n    }\\n    emit SubscriptionCanceled(subId, to, balance);\\n  }\\n\\n  modifier onlySubOwner(uint64 subId) {\\n    address owner = s_subscriptions[subId].owner;\\n    if (owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    if (msg.sender != owner) {\\n      revert MustBeSubOwner(owner);\\n    }\\n    _;\\n  }\\n\\n  modifier nonReentrant() {\\n    if (s_config.reentrancyLock) {\\n      revert Reentrant();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"VRFCoordinatorV2 1.0.0\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/BlockhashStoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface BlockhashStoreInterface {\\n  function getBlockhash(uint256 number) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/VRF.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\\n\\n  * @dev Bibliographic references:\\n\\n  * @dev Goldberg, et al., \\\"Verifiable Random Functions (VRFs)\\\", Internet Draft\\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\\n\\n  * @dev Papadopoulos, et al., \\\"Making NSEC5 Practical for DNSSEC\\\", Cryptology\\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\\n  * ****************************************************************************\\n  * @dev USAGE\\n\\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\\n  * ****************************************************************************\\n  * @dev PURPOSE\\n\\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\\n  * @dev Reggie, he gives back a value which is computed completely\\n  * @dev deterministically from the seed and the secret key.\\n\\n  * @dev Reggie provides a proof by which Vera can verify that the output was\\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\\n  * @dev the output is computationally indistinguishable to her from a uniform\\n  * @dev random sample from the output space.\\n\\n  * @dev The purpose of this contract is to perform that verification.\\n  * ****************************************************************************\\n  * @dev DESIGN NOTES\\n\\n  * @dev The VRF algorithm verified here satisfies the full unqiqueness, full\\n  * @dev collision resistance, and full pseudorandomness security properties.\\n  * @dev See \\\"SECURITY PROPERTIES\\\" below, and\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\\n\\n  * @dev An elliptic curve point is generally represented in the solidity code\\n  * @dev as a uint256[2], corresponding to its affine coordinates in\\n  * @dev GF(FIELD_SIZE).\\n\\n  * @dev For the sake of efficiency, this implementation deviates from the spec\\n  * @dev in some minor ways:\\n\\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\\n\\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\\n\\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\\n  * @dev   nonce updated until a valid x-ordinate is found.\\n\\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\\n  * @dev   in the hash message, as recommended in step 5.B of the draft\\n  * @dev   standard. They are unnecessary here because no variation in the\\n  * @dev   cipher suite is allowed.\\n\\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\\n  * @dev   points, not the compressed points as recommended in step 3.\\n\\n  * @dev - In the calculation of the challenge value \\\"c\\\", the \\\"u\\\" value (i.e.\\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\\n  * @dev   generator point, see steps 5 and 7 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\\n  * @dev   keccak hash of the original u. This is because we only verify the\\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\\n  * ****************************************************************************\\n  * @dev   SECURITY PROPERTIES\\n\\n  * @dev Here are the security properties for this VRF:\\n\\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\\n  * @dev   the sense that the proof will pass verifyVRFProof.\\n\\n  * @dev Full collision resistance: It's cryptographically infeasible to find\\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\\n\\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\\n  * @dev   derived from a given seed, the outputs are computationally\\n  * @dev   indistinguishable from randomness.\\n\\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\\n  * @dev for these properties.\\n\\n  * @dev For secp256k1, the key validation described in section\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\\n  * @dev representation of the public key used here (affine x- and y-ordinates\\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\\n  * @dev the point at infinity.\\n  * ****************************************************************************\\n  * @dev OTHER SECURITY CONSIDERATIONS\\n  *\\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\\n  * @dev However, under the Random Oracle Model the probability of choosing a\\n  * @dev point which forces n extra rounds in hashToCurve is 2⁻ⁿ. The base cost\\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\\n  * @dev try, in expectation, about 2¹²⁸ seeds, which is infeasible for any\\n  * @dev foreseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\\n\\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\\n  * @dev this means it is infeasible for an adversary to prevent correct\\n  * @dev operation of this contract by choosing an adverse seed.\\n\\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\\n  * @dev hashToCurve.)\\n\\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\\n  * @dev See notes in hashToCurve docstring.\\n*/\\ncontract VRF {\\n  // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\\n  // Number of points in Secp256k1\\n  uint256 private constant GROUP_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n  // Prime characteristic of the galois field over which Secp256k1 is defined\\n  uint256 private constant FIELD_SIZE =\\n    // solium-disable-next-line indentation\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n  uint256 private constant WORD_LENGTH_BYTES = 0x20;\\n\\n  // (base^exponent) % FIELD_SIZE\\n  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\\n  function bigModExp(uint256 base, uint256 exponent) internal view returns (uint256 exponentiation) {\\n    uint256 callResult;\\n    uint256[6] memory bigModExpContractInputs;\\n    bigModExpContractInputs[0] = WORD_LENGTH_BYTES; // Length of base\\n    bigModExpContractInputs[1] = WORD_LENGTH_BYTES; // Length of exponent\\n    bigModExpContractInputs[2] = WORD_LENGTH_BYTES; // Length of modulus\\n    bigModExpContractInputs[3] = base;\\n    bigModExpContractInputs[4] = exponent;\\n    bigModExpContractInputs[5] = FIELD_SIZE;\\n    uint256[1] memory output;\\n    assembly {\\n      // solhint-disable-line no-inline-assembly\\n      callResult := staticcall(\\n        not(0), // Gas cost: no limit\\n        0x05, // Bigmodexp contract address\\n        bigModExpContractInputs,\\n        0xc0, // Length of input segment: 6*0x20-bytes\\n        output,\\n        0x20 // Length of output segment\\n      )\\n    }\\n    if (callResult == 0) {\\n      revert(\\\"bigModExp failure!\\\");\\n    }\\n    return output[0];\\n  }\\n\\n  // Let q=FIELD_SIZE. q % 4 = 3, ∴ x≡r^2 mod q ⇒ x^SQRT_POWER≡±r mod q.  See\\n  // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\\n  uint256 private constant SQRT_POWER = (FIELD_SIZE + 1) >> 2;\\n\\n  // Computes a s.t. a^2 = x in the field. Assumes a exists\\n  function squareRoot(uint256 x) internal view returns (uint256) {\\n    return bigModExp(x, SQRT_POWER);\\n  }\\n\\n  // The value of y^2 given that (x,y) is on secp256k1.\\n  function ySquared(uint256 x) internal pure returns (uint256) {\\n    // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\\n    uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\\n    return addmod(xCubed, 7, FIELD_SIZE);\\n  }\\n\\n  // True iff p is on secp256k1\\n  function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\\n    // Section 2.3.6. in https://www.secg.org/sec1-v2.pdf\\n    // requires each ordinate to be in [0, ..., FIELD_SIZE-1]\\n    require(p[0] < FIELD_SIZE, \\\"invalid x-ordinate\\\");\\n    require(p[1] < FIELD_SIZE, \\\"invalid y-ordinate\\\");\\n    return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\\n  }\\n\\n  // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\\n  function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\\n    x_ = uint256(keccak256(b));\\n    // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\\n    // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\\n    // string_to_point in the IETF draft\\n    while (x_ >= FIELD_SIZE) {\\n      x_ = uint256(keccak256(abi.encodePacked(x_)));\\n    }\\n  }\\n\\n  // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\\n  // is always even, due to\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n  // step 5.C, which references arbitrary_string_to_point, defined in\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\\n  // returning the point with given x ordinate, and even y ordinate.\\n  function newCandidateSecp256k1Point(bytes memory b) internal view returns (uint256[2] memory p) {\\n    unchecked {\\n      p[0] = fieldHash(b);\\n      p[1] = squareRoot(ySquared(p[0]));\\n      if (p[1] % 2 == 1) {\\n        // Note that 0 <= p[1] < FIELD_SIZE\\n        // so this cannot wrap, we use unchecked to save gas.\\n        p[1] = FIELD_SIZE - p[1];\\n      }\\n    }\\n  }\\n\\n  // Domain-separation tag for initial hash in hashToCurve. Corresponds to\\n  // vrf.go/hashToCurveHashPrefix\\n  uint256 internal constant HASH_TO_CURVE_HASH_PREFIX = 1;\\n\\n  // Cryptographic hash function onto the curve.\\n  //\\n  // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\\n  // DESIGN NOTES above for slight differences.)\\n  //\\n  // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\\n  // \\\"Construction of Rational Points on Elliptic Curves over Finite Fields\\\"\\n  // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\\n  // and suggested by\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\\n  // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\\n  //\\n  // This would greatly simplify the analysis in \\\"OTHER SECURITY CONSIDERATIONS\\\"\\n  // https://www.pivotaltracker.com/story/show/171120900\\n  function hashToCurve(uint256[2] memory pk, uint256 input) internal view returns (uint256[2] memory rv) {\\n    rv = newCandidateSecp256k1Point(abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX, pk, input));\\n    while (!isOnCurve(rv)) {\\n      rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\\n    }\\n  }\\n\\n  /** *********************************************************************\\n   * @notice Check that product==scalar*multiplicand\\n   *\\n   * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\\n   *\\n   * @param multiplicand: secp256k1 point\\n   * @param scalar: non-zero GF(GROUP_ORDER) scalar\\n   * @param product: secp256k1 expected to be multiplier * multiplicand\\n   * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\\n   */\\n  function ecmulVerify(\\n    uint256[2] memory multiplicand,\\n    uint256 scalar,\\n    uint256[2] memory product\\n  ) internal pure returns (bool verifies) {\\n    require(scalar != 0, \\\"zero scalar\\\"); // Rules out an ecrecover failure case\\n    uint256 x = multiplicand[0]; // x ordinate of multiplicand\\n    uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n    // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\\n    // (x⁻¹ mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\\n    // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\\n    bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\\n    address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\\n    // Explicit conversion to address takes bottom 160 bits\\n    address expected = address(uint160(uint256(keccak256(abi.encodePacked(product)))));\\n    return (actual == expected);\\n  }\\n\\n  // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P¹(𝔽ₙ)\\n  function projectiveSub(\\n    uint256 x1,\\n    uint256 z1,\\n    uint256 x2,\\n    uint256 z2\\n  ) internal pure returns (uint256 x3, uint256 z3) {\\n    unchecked {\\n      uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\\n      // Note this cannot wrap since x2 is a point in [0, FIELD_SIZE-1]\\n      // we use unchecked to save gas.\\n      uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\\n      (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n    }\\n  }\\n\\n  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P¹(𝔽ₙ)\\n  function projectiveMul(\\n    uint256 x1,\\n    uint256 z1,\\n    uint256 x2,\\n    uint256 z2\\n  ) internal pure returns (uint256 x3, uint256 z3) {\\n    (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n  }\\n\\n  /** **************************************************************************\\n        @notice Computes elliptic-curve sum, in projective co-ordinates\\n\\n        @dev Using projective coordinates avoids costly divisions\\n\\n        @dev To use this with p and q in affine coordinates, call\\n        @dev projectiveECAdd(px, py, qx, qy). This will return\\n        @dev the addition of (px, py, 1) and (qx, qy, 1), in the\\n        @dev secp256k1 group.\\n\\n        @dev This can be used to calculate the z which is the inverse to zInv\\n        @dev in isValidVRFOutput. But consider using a faster\\n        @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\\n\\n        @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\\n             coordinates of secp256k1 points. That is safe in this contract,\\n             because this method is only used by linearCombination, which checks\\n             points are on the curve via ecrecover.\\n        **************************************************************************\\n        @param px The first affine coordinate of the first summand\\n        @param py The second affine coordinate of the first summand\\n        @param qx The first affine coordinate of the second summand\\n        @param qy The second affine coordinate of the second summand\\n\\n        (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\\n        **************************************************************************\\n        Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\\n        on secp256k1, in P²(𝔽ₙ)\\n        @return sx\\n        @return sy\\n        @return sz\\n    */\\n  function projectiveECAdd(\\n    uint256 px,\\n    uint256 py,\\n    uint256 qx,\\n    uint256 qy\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256 sx,\\n      uint256 sy,\\n      uint256 sz\\n    )\\n  {\\n    unchecked {\\n      // See \\\"Group law for E/K : y^2 = x^3 + ax + b\\\", in section 3.1.2, p. 80,\\n      // \\\"Guide to Elliptic Curve Cryptography\\\" by Hankerson, Menezes and Vanstone\\n      // We take the equations there for (sx,sy), and homogenize them to\\n      // projective coordinates. That way, no inverses are required, here, and we\\n      // only need the one inverse in affineECAdd.\\n\\n      // We only need the \\\"point addition\\\" equations from Hankerson et al. Can\\n      // skip the \\\"point doubling\\\" equations because p1 == p2 is cryptographically\\n      // impossible, and required not to be the case in linearCombination.\\n\\n      // Add extra \\\"projective coordinate\\\" to the two points\\n      (uint256 z1, uint256 z2) = (1, 1);\\n\\n      // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\\n      // Cannot wrap since px and py are in [0, FIELD_SIZE-1]\\n      uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\\n      uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\\n\\n      uint256 dx; // Accumulates denominator from sx calculation\\n      // sx=((qy-py)/(qx-px))^2-px-qx\\n      (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\\n      (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\\n      (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\\n\\n      uint256 dy; // Accumulates denominator from sy calculation\\n      // sy=((qy-py)/(qx-px))(px-sx)-py\\n      (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\\n      (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\\n      (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\\n\\n      if (dx != dy) {\\n        // Cross-multiply to put everything over a common denominator\\n        sx = mulmod(sx, dy, FIELD_SIZE);\\n        sy = mulmod(sy, dx, FIELD_SIZE);\\n        sz = mulmod(dx, dy, FIELD_SIZE);\\n      } else {\\n        // Already over a common denominator, use that for z ordinate\\n        sz = dx;\\n      }\\n    }\\n  }\\n\\n  // p1+p2, as affine points on secp256k1.\\n  //\\n  // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\\n  // It is computed off-chain to save gas.\\n  //\\n  // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\\n  // point doubling.\\n  function affineECAdd(\\n    uint256[2] memory p1,\\n    uint256[2] memory p2,\\n    uint256 invZ\\n  ) internal pure returns (uint256[2] memory) {\\n    uint256 x;\\n    uint256 y;\\n    uint256 z;\\n    (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\\n    require(mulmod(z, invZ, FIELD_SIZE) == 1, \\\"invZ must be inverse of z\\\");\\n    // Clear the z ordinate of the projective representation by dividing through\\n    // by it, to obtain the affine representation\\n    return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\\n  }\\n\\n  // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\\n  // cryptographically high probability.)\\n  function verifyLinearCombinationWithGenerator(\\n    uint256 c,\\n    uint256[2] memory p,\\n    uint256 s,\\n    address lcWitness\\n  ) internal pure returns (bool) {\\n    // Rule out ecrecover failure modes which return address 0.\\n    unchecked {\\n      require(lcWitness != address(0), \\\"bad witness\\\");\\n      uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\\n      // Note this cannot wrap (X - Y % X), but we use unchecked to save\\n      // gas.\\n      bytes32 pseudoHash = bytes32(GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)); // -s*p[0]\\n      bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\\n      // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n      // The point corresponding to the address returned by\\n      // ecrecover(-s*p[0],v,p[0],c*p[0]) is\\n      // (p[0]⁻¹ mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\\n      // See https://crypto.stackexchange.com/a/18106\\n      // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\\n      address computed = ecrecover(pseudoHash, v, bytes32(p[0]), pseudoSignature);\\n      return computed == lcWitness;\\n    }\\n  }\\n\\n  // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\\n  // requires cp1Witness != sp2Witness (which is fine for this application,\\n  // since it is cryptographically impossible for them to be equal. In the\\n  // (cryptographically impossible) case that a prover accidentally derives\\n  // a proof with equal c*p1 and s*p2, they should retry with a different\\n  // proof nonce.) Assumes that all points are on secp256k1\\n  // (which is checked in verifyVRFProof below.)\\n  function linearCombination(\\n    uint256 c,\\n    uint256[2] memory p1,\\n    uint256[2] memory cp1Witness,\\n    uint256 s,\\n    uint256[2] memory p2,\\n    uint256[2] memory sp2Witness,\\n    uint256 zInv\\n  ) internal pure returns (uint256[2] memory) {\\n    unchecked {\\n      // Note we are relying on the wrap around here\\n      require((cp1Witness[0] % FIELD_SIZE) != (sp2Witness[0] % FIELD_SIZE), \\\"points in sum must be distinct\\\");\\n      require(ecmulVerify(p1, c, cp1Witness), \\\"First mul check failed\\\");\\n      require(ecmulVerify(p2, s, sp2Witness), \\\"Second mul check failed\\\");\\n      return affineECAdd(cp1Witness, sp2Witness, zInv);\\n    }\\n  }\\n\\n  // Domain-separation tag for the hash taken in scalarFromCurvePoints.\\n  // Corresponds to scalarFromCurveHashPrefix in vrf.go\\n  uint256 internal constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\\n\\n  // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n  // The draft calls (in step 7, via the definition of string_to_int, in\\n  // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\\n  // first hash without checking that it corresponds to a number less than the\\n  // group order, which will lead to a slight bias in the sample.\\n  //\\n  // TODO(alx): We could save a bit of gas by following the standard here and\\n  // using the compressed representation of the points, if we collated the y\\n  // parities into a single bytes32.\\n  // https://www.pivotaltracker.com/story/show/171120588\\n  function scalarFromCurvePoints(\\n    uint256[2] memory hash,\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    address uWitness,\\n    uint256[2] memory v\\n  ) internal pure returns (uint256 s) {\\n    return uint256(keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX, hash, pk, gamma, v, uWitness)));\\n  }\\n\\n  // True if (gamma, c, s) is a correctly constructed randomness proof from pk\\n  // and seed. zInv must be the inverse of the third ordinate from\\n  // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\\n  // section 5.3 of the IETF draft.\\n  //\\n  // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\\n  // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\\n  // (which I could make a uint256 without using any extra space.) Would save\\n  // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\\n  function verifyVRFProof(\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    uint256 c,\\n    uint256 s,\\n    uint256 seed,\\n    address uWitness,\\n    uint256[2] memory cGammaWitness,\\n    uint256[2] memory sHashWitness,\\n    uint256 zInv\\n  ) internal view {\\n    unchecked {\\n      require(isOnCurve(pk), \\\"public key is not on curve\\\");\\n      require(isOnCurve(gamma), \\\"gamma is not on curve\\\");\\n      require(isOnCurve(cGammaWitness), \\\"cGammaWitness is not on curve\\\");\\n      require(isOnCurve(sHashWitness), \\\"sHashWitness is not on curve\\\");\\n      // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\\n      // we use the address of u instead of u itself. Also, here we add the\\n      // terms instead of taking the difference, and in the proof consruction in\\n      // vrf.GenerateProof, we correspondingly take the difference instead of\\n      // taking the sum as they do in step 7 of section 5.1.)\\n      require(verifyLinearCombinationWithGenerator(c, pk, s, uWitness), \\\"addr(c*pk+s*g)!=_uWitness\\\");\\n      // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\\n      uint256[2] memory hash = hashToCurve(pk, seed);\\n      // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\\n      uint256[2] memory v = linearCombination(c, gamma, cGammaWitness, s, hash, sHashWitness, zInv);\\n      // Steps 7. and 8. of IETF draft section 5.3\\n      uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\\n      require(c == derivedC, \\\"invalid proof\\\");\\n    }\\n  }\\n\\n  // Domain-separation tag for the hash used as the final VRF output.\\n  // Corresponds to vrfRandomOutputHashPrefix in vrf.go\\n  uint256 internal constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\\n\\n  struct Proof {\\n    uint256[2] pk;\\n    uint256[2] gamma;\\n    uint256 c;\\n    uint256 s;\\n    uint256 seed;\\n    address uWitness;\\n    uint256[2] cGammaWitness;\\n    uint256[2] sHashWitness;\\n    uint256 zInv;\\n  }\\n\\n  /* ***************************************************************************\\n     * @notice Returns proof's output, if proof is valid. Otherwise reverts\\n\\n     * @param proof vrf proof components\\n     * @param seed  seed used to generate the vrf output\\n     *\\n     * Throws if proof is invalid, otherwise:\\n     * @return output i.e., the random output implied by the proof\\n     * ***************************************************************************\\n     */\\n  function randomValueFromVRFProof(Proof memory proof, uint256 seed) internal view returns (uint256 output) {\\n    verifyVRFProof(\\n      proof.pk,\\n      proof.gamma,\\n      proof.c,\\n      proof.s,\\n      seed,\\n      proof.uWitness,\\n      proof.cGammaWitness,\\n      proof.sHashWitness,\\n      proof.zInv\\n    );\\n    output = uint256(keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, proof.gamma)));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFCoordinatorV2TestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../dev/VRFCoordinatorV2.sol\\\";\\n\\ncontract VRFCoordinatorV2TestHelper is VRFCoordinatorV2 {\\n  uint96 s_paymentAmount;\\n  uint256 s_gasStart;\\n\\n  constructor(\\n    address link,\\n    address blockhashStore,\\n    address linkEthFeed\\n  )\\n    // solhint-disable-next-line no-empty-blocks\\n    VRFCoordinatorV2(link, blockhashStore, linkEthFeed)\\n  {\\n    /* empty */\\n  }\\n\\n  function calculatePaymentAmountTest(\\n    uint256 gasAfterPaymentCalculation,\\n    uint32 fulfillmentFlatFeeLinkPPM,\\n    uint256 weiPerUnitGas\\n  ) external {\\n    s_paymentAmount = calculatePaymentAmount(\\n      gasleft(),\\n      gasAfterPaymentCalculation,\\n      fulfillmentFlatFeeLinkPPM,\\n      weiPerUnitGas\\n    );\\n  }\\n\\n  function getPaymentAmount() public view returns (uint96) {\\n    return s_paymentAmount;\\n  }\\n\\n  function getGasStart() public view returns (uint256) {\\n    return s_gasStart;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ValidatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"./interfaces/TypeAndVersionInterface.sol\\\";\\n\\ncontract ValidatorProxy is AggregatorValidatorInterface, TypeAndVersionInterface, ConfirmedOwner {\\n  /// @notice Uses a single storage slot to store the current address\\n  struct AggregatorConfiguration {\\n    address target;\\n    bool hasNewProposal;\\n  }\\n\\n  struct ValidatorConfiguration {\\n    AggregatorValidatorInterface target;\\n    bool hasNewProposal;\\n  }\\n\\n  // Configuration for the current aggregator\\n  AggregatorConfiguration private s_currentAggregator;\\n  // Proposed aggregator address\\n  address private s_proposedAggregator;\\n\\n  // Configuration for the current validator\\n  ValidatorConfiguration private s_currentValidator;\\n  // Proposed validator address\\n  AggregatorValidatorInterface private s_proposedValidator;\\n\\n  event AggregatorProposed(address indexed aggregator);\\n  event AggregatorUpgraded(address indexed previous, address indexed current);\\n  event ValidatorProposed(AggregatorValidatorInterface indexed validator);\\n  event ValidatorUpgraded(AggregatorValidatorInterface indexed previous, AggregatorValidatorInterface indexed current);\\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\\n  event ProposedAggregatorValidateCall(\\n    address indexed proposed,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n\\n  /**\\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\\n   * @param aggregator address\\n   * @param validator address\\n   */\\n  constructor(address aggregator, AggregatorValidatorInterface validator) ConfirmedOwner(msg.sender) {\\n    s_currentAggregator = AggregatorConfiguration({target: aggregator, hasNewProposal: false});\\n    s_currentValidator = ValidatorConfiguration({target: validator, hasNewProposal: false});\\n  }\\n\\n  /**\\n   * @notice Validate a transmission\\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\\n   * and the `s_proposedValidator`, if it is set.\\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\\n   * the call was received.\\n   * @dev To guard against external `validate` calls reverting, we use raw calls here.\\n   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly\\n   * set as a non-contract address.\\n   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.\\n   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have\\n   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.\\n   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports\\n   * for the same roundId at different points in time. Validator implementations should be aware of this.\\n   * @param previousRoundId uint256\\n   * @param previousAnswer int256\\n   * @param currentRoundId uint256\\n   * @param currentAnswer int256\\n   * @return bool\\n   */\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external override returns (bool) {\\n    address currentAggregator = s_currentAggregator.target;\\n    if (msg.sender != currentAggregator) {\\n      address proposedAggregator = s_proposedAggregator;\\n      require(msg.sender == proposedAggregator, \\\"Not a configured aggregator\\\");\\n      // If the aggregator is still in proposed state, emit an event and don't push to any validator.\\n      // This is to confirm that `validate` is being called prior to upgrade.\\n      emit ProposedAggregatorValidateCall(\\n        proposedAggregator,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      );\\n      return true;\\n    }\\n\\n    // Send the validate call to the current validator\\n    ValidatorConfiguration memory currentValidator = s_currentValidator;\\n    address currentValidatorAddress = address(currentValidator.target);\\n    require(currentValidatorAddress != address(0), \\\"No validator set\\\");\\n    currentValidatorAddress.call(\\n      abi.encodeWithSelector(\\n        AggregatorValidatorInterface.validate.selector,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      )\\n    );\\n    // If there is a new proposed validator, send the validate call to that validator also\\n    if (currentValidator.hasNewProposal) {\\n      address(s_proposedValidator).call(\\n        abi.encodeWithSelector(\\n          AggregatorValidatorInterface.validate.selector,\\n          previousRoundId,\\n          previousAnswer,\\n          currentRoundId,\\n          currentAnswer\\n        )\\n      );\\n    }\\n    return true;\\n  }\\n\\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an aggregator\\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewAggregator(address proposed) external onlyOwner {\\n    require(s_proposedAggregator != proposed && s_currentAggregator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedAggregator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\\n    emit AggregatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\\n   * @dev Must have a proposed aggregator. Only owner can call.\\n   */\\n  function upgradeAggregator() external onlyOwner {\\n    // Get configuration in memory\\n    AggregatorConfiguration memory current = s_currentAggregator;\\n    address previous = current.target;\\n    address proposed = s_proposedAggregator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentAggregator = AggregatorConfiguration({target: proposed, hasNewProposal: false});\\n    delete s_proposedAggregator;\\n\\n    emit AggregatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get aggregator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getAggregators()\\n    external\\n    view\\n    returns (\\n      address current,\\n      bool hasProposal,\\n      address proposed\\n    )\\n  {\\n    current = s_currentAggregator.target;\\n    hasProposal = s_currentAggregator.hasNewProposal;\\n    proposed = s_proposedAggregator;\\n  }\\n\\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an validator\\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewValidator(AggregatorValidatorInterface proposed) external onlyOwner {\\n    require(s_proposedValidator != proposed && s_currentValidator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedValidator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentValidator.hasNewProposal = (address(proposed) != address(0));\\n    emit ValidatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\\n   * @dev Must have a proposed validator. Only owner can call.\\n   */\\n  function upgradeValidator() external onlyOwner {\\n    // Get configuration in memory\\n    ValidatorConfiguration memory current = s_currentValidator;\\n    AggregatorValidatorInterface previous = current.target;\\n    AggregatorValidatorInterface proposed = s_proposedValidator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentValidator = ValidatorConfiguration({target: proposed, hasNewProposal: false});\\n    delete s_proposedValidator;\\n\\n    emit ValidatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get validator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getValidators()\\n    external\\n    view\\n    returns (\\n      AggregatorValidatorInterface current,\\n      bool hasProposal,\\n      AggregatorValidatorInterface proposed\\n    )\\n  {\\n    current = s_currentValidator.target;\\n    hasProposal = s_currentValidator.hasNewProposal;\\n    proposed = s_proposedValidator;\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"ValidatorProxy 1.0.0\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorValidatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorValidatorInterface {\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/OptimismValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../SimpleWriteAccessController.sol\\\";\\n\\n/* ./dev dependencies - to be moved from ./dev after audit */\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\nimport \\\"./interfaces/ForwarderInterface.sol\\\";\\nimport \\\"./vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title OptimismValidator - makes xDomain L2 Flags contract call (using L2 xDomain Forwarder contract)\\n * @notice Allows to raise and lower Flags on the Optimism L2 network through L1 bridge\\n *  - The internal AccessController controls the access of the validate method\\n */\\ncontract OptimismValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\\n  /// @dev Follows: https://eips.ethereum.org/EIPS/eip-1967\\n  address public constant FLAG_OPTIMISM_SEQ_OFFLINE =\\n    address(bytes20(bytes32(uint256(keccak256(\\\"chainlink.flags.optimism-seq-offline\\\")) - 1)));\\n  // Encode underlying Flags call/s\\n  bytes private constant CALL_RAISE_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.raiseFlag.selector, FLAG_OPTIMISM_SEQ_OFFLINE);\\n  bytes private constant CALL_LOWER_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.lowerFlag.selector, FLAG_OPTIMISM_SEQ_OFFLINE);\\n  uint32 private constant CALL_GAS_LIMIT = 1_200_000;\\n  int256 private constant ANSWER_SEQ_OFFLINE = 1;\\n\\n  address public immutable CROSS_DOMAIN_MESSENGER;\\n  address public immutable L2_CROSS_DOMAIN_FORWARDER;\\n  address public immutable L2_FLAGS;\\n\\n  /**\\n   * @param crossDomainMessengerAddr address the xDomain bridge messenger (Optimism bridge L1) contract address\\n   * @param l2CrossDomainForwarderAddr the L2 Forwarder contract address\\n   * @param l2FlagsAddr the L2 Flags contract address\\n   */\\n  constructor(\\n    address crossDomainMessengerAddr,\\n    address l2CrossDomainForwarderAddr,\\n    address l2FlagsAddr\\n  ) {\\n    require(crossDomainMessengerAddr != address(0), \\\"Invalid xDomain Messenger address\\\");\\n    require(l2CrossDomainForwarderAddr != address(0), \\\"Invalid L2 xDomain Forwarder address\\\");\\n    require(l2FlagsAddr != address(0), \\\"Invalid L2 Flags address\\\");\\n    CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\\n    L2_CROSS_DOMAIN_FORWARDER = l2CrossDomainForwarderAddr;\\n    L2_FLAGS = l2FlagsAddr;\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - OptimismValidator 0.1.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"OptimismValidator 0.1.0\\\";\\n  }\\n\\n  /**\\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\\n   * @dev A message is sent via the Optimism CrossDomainMessenger L1 contract. The \\\"payment\\\" for L2 execution happens on L1,\\n   *   using the gas attached to this tx (some extra gas is burned by the Optimism bridge to avoid DoS attacks).\\n   *   This method is accessed controlled.\\n   * @param previousAnswer previous aggregator answer\\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\\n   */\\n  function validate(\\n    uint256, /* previousRoundId */\\n    int256 previousAnswer,\\n    uint256, /* currentRoundId */\\n    int256 currentAnswer\\n  ) external override checkAccess returns (bool) {\\n    // Avoids resending to L2 the same tx on every call\\n    if (previousAnswer == currentAnswer) {\\n      return true; // noop\\n    }\\n\\n    // Encode the Forwarder call\\n    bytes4 selector = ForwarderInterface.forward.selector;\\n    address target = L2_FLAGS;\\n    // Choose and encode the underlying Flags call\\n    bytes memory data = currentAnswer == ANSWER_SEQ_OFFLINE ? CALL_RAISE_FLAG : CALL_LOWER_FLAG;\\n    bytes memory message = abi.encodeWithSelector(selector, target, data);\\n    // Make the xDomain call\\n    iOVM_CrossDomainMessenger(CROSS_DOMAIN_MESSENGER).sendMessage(L2_CROSS_DOMAIN_FORWARDER, message, CALL_GAS_LIMIT);\\n    // return success\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AccessControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AccessControllerInterface {\\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleWriteAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\n\\n/**\\n * @title SimpleWriteAccessController\\n * @notice Gives access to accounts explicitly added to an access list by the\\n * controller's owner.\\n * @dev does not make any special permissions for externally, see\\n * SimpleReadAccessController for that.\\n */\\ncontract SimpleWriteAccessController is AccessControllerInterface, ConfirmedOwner {\\n  bool public checkEnabled;\\n  mapping(address => bool) internal accessList;\\n\\n  event AddedAccess(address user);\\n  event RemovedAccess(address user);\\n  event CheckAccessEnabled();\\n  event CheckAccessDisabled();\\n\\n  constructor() ConfirmedOwner(msg.sender) {\\n    checkEnabled = true;\\n  }\\n\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory) public view virtual override returns (bool) {\\n    return accessList[_user] || !checkEnabled;\\n  }\\n\\n  /**\\n   * @notice Adds an address to the access list\\n   * @param _user The address to add\\n   */\\n  function addAccess(address _user) external onlyOwner {\\n    if (!accessList[_user]) {\\n      accessList[_user] = true;\\n\\n      emit AddedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice Removes an address from the access list\\n   * @param _user The address to remove\\n   */\\n  function removeAccess(address _user) external onlyOwner {\\n    if (accessList[_user]) {\\n      accessList[_user] = false;\\n\\n      emit RemovedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check enforced\\n   */\\n  function enableAccessCheck() external onlyOwner {\\n    if (!checkEnabled) {\\n      checkEnabled = true;\\n\\n      emit CheckAccessEnabled();\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check unenforced\\n   */\\n  function disableAccessCheck() external onlyOwner {\\n    if (checkEnabled) {\\n      checkEnabled = false;\\n\\n      emit CheckAccessDisabled();\\n    }\\n  }\\n\\n  /**\\n   * @dev reverts if the caller does not have access\\n   */\\n  modifier checkAccess() {\\n    require(hasAccess(msg.sender, msg.data), \\\"No access\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n\\n  function raiseFlag(address) external;\\n\\n  function raiseFlags(address[] calldata) external;\\n\\n  function lowerFlag(address) external;\\n\\n  function lowerFlags(address[] calldata) external;\\n\\n  function setRaisingAccessController(address) external;\\n\\n  function setLoweringAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/ForwarderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ForwarderInterface - forwards a call to a target, under some conditions\\ninterface ForwarderInterface {\\n  /**\\n   * @notice forward calls the `target` with `data`\\n   * @param target contract address to be called\\n   * @param data to send to target contract\\n   */\\n  function forward(address target, bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.6 <0.9.0;\\n\\n/**\\n * @title iOVM_CrossDomainMessenger\\n */\\ninterface iOVM_CrossDomainMessenger {\\n  /**********\\n   * Events *\\n   **********/\\n\\n  event SentMessage(bytes message);\\n  event RelayedMessage(bytes32 msgHash);\\n  event FailedRelayedMessage(bytes32 msgHash);\\n\\n  /*************\\n   * Variables *\\n   *************/\\n\\n  function xDomainMessageSender() external view returns (address);\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Sends a cross domain message to the target messenger.\\n   * @param _target Target contract address.\\n   * @param _message Message to send to the target.\\n   * @param _gasLimit Gas limit for the provided message.\\n   */\\n  function sendMessage(\\n    address _target,\\n    bytes calldata _message,\\n    uint32 _gasLimit\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/OptimismCrossDomainForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\n\\n/* ./dev dependencies - to be moved from ./dev after audit */\\nimport \\\"./CrossDomainForwarder.sol\\\";\\nimport \\\"./vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title OptimismCrossDomainForwarder - L1 xDomain account representation\\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\\n *   can be considered to be owned by the `l1Owner`\\n */\\ncontract OptimismCrossDomainForwarder is TypeAndVersionInterface, CrossDomainForwarder {\\n  // OVM_L2CrossDomainMessenger is a precompile usually deployed to 0x4200000000000000000000000000000000000007\\n  address private immutable OVM_CROSS_DOMAIN_MESSENGER;\\n\\n  /**\\n   * @notice creates a new Optimism xDomain Forwarder contract\\n   * @param crossDomainMessengerAddr the xDomain bridge messenger (Optimism bridge L2) contract address\\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\\n   */\\n  constructor(address crossDomainMessengerAddr, address l1OwnerAddr) CrossDomainForwarder(l1OwnerAddr) {\\n    require(crossDomainMessengerAddr != address(0), \\\"Invalid xDomain Messenger address\\\");\\n    OVM_CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - OptimismCrossDomainForwarder 0.1.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"OptimismCrossDomainForwarder 0.1.0\\\";\\n  }\\n\\n  /**\\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address\\n   * @inheritdoc ForwarderInterface\\n   */\\n  function forward(address target, bytes memory data) external override {\\n    // 1. The call MUST come from the L1 Messenger\\n    require(msg.sender == OVM_CROSS_DOMAIN_MESSENGER, \\\"Sender is not the L2 messenger\\\");\\n    // 2. The L1 Messenger's caller MUST be the L1 Owner\\n    require(\\n      iOVM_CrossDomainMessenger(OVM_CROSS_DOMAIN_MESSENGER).xDomainMessageSender() == l1Owner(),\\n      \\\"xDomain sender is not the L1 owner\\\"\\n    );\\n    // 3. Make the external call\\n    (bool success, bytes memory res) = target.call(data);\\n    require(success, string(abi.encode(\\\"xDomain call failed:\\\", res)));\\n  }\\n\\n  /**\\n   * @notice This is always the address of the OVM_L2CrossDomainMessenger contract\\n   * @inheritdoc CrossDomainForwarder\\n   */\\n  function crossDomainMessenger() public view virtual override returns (address) {\\n    return OVM_CROSS_DOMAIN_MESSENGER;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/CrossDomainForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/ForwarderInterface.sol\\\";\\n\\n/**\\n * @title CrossDomainForwarder - L1 xDomain account representation\\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\\n *   can be considered to be owned by the `l1Owner`\\n */\\nabstract contract CrossDomainForwarder is ForwarderInterface, ConfirmedOwner {\\n  address private s_l1Owner;\\n\\n  event L1OwnershipTransferred(address indexed from, address indexed to);\\n\\n  /**\\n   * @notice creates a new xDomain Forwarder contract\\n   * @dev Forwarding can be disabled by setting the L1 owner as `address(0)`.\\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\\n   */\\n  constructor(address l1OwnerAddr) ConfirmedOwner(msg.sender) {\\n    _setL1Owner(l1OwnerAddr);\\n  }\\n\\n  /// @return xDomain messenger address (L2 `msg.sender`)\\n  function crossDomainMessenger() public view virtual returns (address);\\n\\n  /// @return L1 owner address\\n  function l1Owner() public view virtual returns (address) {\\n    return s_l1Owner;\\n  }\\n\\n  /**\\n   * @notice transfer ownership of this account to a new L1 owner\\n   * @dev Forwarding can be disabled by setting the L1 owner as `address(0)`. Accessible only by owner.\\n   * @param to new L1 owner that will be allowed to call the forward fn\\n   */\\n  function transferL1Ownership(address to) external virtual onlyOwner {\\n    _setL1Owner(to);\\n  }\\n\\n  /// @notice internal method that stores the L1 owner\\n  function _setL1Owner(address to) internal {\\n    address from = s_l1Owner;\\n    if (from != to) {\\n      s_l1Owner = to;\\n      emit L1OwnershipTransferred(from, to);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/ArbitrumValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../SimpleWriteAccessController.sol\\\";\\n\\n/* ./dev dependencies - to be moved from ./dev after audit */\\nimport \\\"./interfaces/ForwarderInterface.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\\\";\\nimport \\\"./vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol\\\";\\nimport \\\"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title ArbitrumValidator - makes xDomain L2 Flags contract call (using L2 xDomain Forwarder contract)\\n * @notice Allows to raise and lower Flags on the Arbitrum L2 network through L1 bridge\\n *  - The internal AccessController controls the access of the validate method\\n *  - Gas configuration is controlled by a configurable external SimpleWriteAccessController\\n *  - Funds on the contract are managed by the owner\\n */\\ncontract ArbitrumValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\\n  enum PaymentStrategy {\\n    L1,\\n    L2\\n  }\\n  // Config for L1 -> L2 Arbitrum retryable ticket message\\n  struct GasConfig {\\n    uint256 maxGas;\\n    uint256 gasPriceBid;\\n    address gasPriceL1FeedAddr;\\n  }\\n\\n  /// @dev Precompiled contract that exists in every Arbitrum chain at address(100). Exposes a variety of system-level functionality.\\n  address constant ARBSYS_ADDR = address(0x0000000000000000000000000000000000000064);\\n\\n  /// @dev Follows: https://eips.ethereum.org/EIPS/eip-1967\\n  address public constant FLAG_ARBITRUM_SEQ_OFFLINE =\\n    address(bytes20(bytes32(uint256(keccak256(\\\"chainlink.flags.arbitrum-seq-offline\\\")) - 1)));\\n  // Encode underlying Flags call/s\\n  bytes private constant CALL_RAISE_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.raiseFlag.selector, FLAG_ARBITRUM_SEQ_OFFLINE);\\n  bytes private constant CALL_LOWER_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.lowerFlag.selector, FLAG_ARBITRUM_SEQ_OFFLINE);\\n  int256 private constant ANSWER_SEQ_OFFLINE = 1;\\n\\n  address public immutable CROSS_DOMAIN_MESSENGER;\\n  address public immutable L2_CROSS_DOMAIN_FORWARDER;\\n  address public immutable L2_FLAGS;\\n  // L2 xDomain alias address of this contract\\n  address public immutable L2_ALIAS = AddressAliasHelper.applyL1ToL2Alias(address(this));\\n\\n  PaymentStrategy private s_paymentStrategy;\\n  GasConfig private s_gasConfig;\\n  AccessControllerInterface private s_configAC;\\n\\n  /**\\n   * @notice emitted when a new payment strategy is set\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  event PaymentStrategySet(PaymentStrategy indexed paymentStrategy);\\n\\n  /**\\n   * @notice emitted when a new gas configuration is set\\n   * @param maxGas gas limit for immediate L2 execution attempt.\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   */\\n  event GasConfigSet(uint256 maxGas, uint256 gasPriceBid, address indexed gasPriceL1FeedAddr);\\n\\n  /**\\n   * @notice emitted when a new gas access-control contract is set\\n   * @param previous the address prior to the current setting\\n   * @param current the address of the new access-control contract\\n   */\\n  event ConfigACSet(address indexed previous, address indexed current);\\n\\n  /**\\n   * @notice emitted when a new ETH withdrawal from L2 was requested\\n   * @param id unique id of the published retryable transaction (keccak256(requestID, uint(0))\\n   * @param amount of funds to withdraw\\n   */\\n  event L2WithdrawalRequested(uint256 indexed id, uint256 amount, address indexed refundAddr);\\n\\n  /**\\n   * @param crossDomainMessengerAddr address the xDomain bridge messenger (Arbitrum Inbox L1) contract address\\n   * @param l2CrossDomainForwarderAddr the L2 Forwarder contract address\\n   * @param l2FlagsAddr the L2 Flags contract address\\n   * @param configACAddr address of the access controller for managing gas price on Arbitrum\\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  constructor(\\n    address crossDomainMessengerAddr,\\n    address l2CrossDomainForwarderAddr,\\n    address l2FlagsAddr,\\n    address configACAddr,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr,\\n    PaymentStrategy paymentStrategy\\n  ) {\\n    require(crossDomainMessengerAddr != address(0), \\\"Invalid xDomain Messenger address\\\");\\n    require(l2CrossDomainForwarderAddr != address(0), \\\"Invalid L2 xDomain Forwarder address\\\");\\n    require(l2FlagsAddr != address(0), \\\"Invalid Flags contract address\\\");\\n    CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\\n    L2_CROSS_DOMAIN_FORWARDER = l2CrossDomainForwarderAddr;\\n    L2_FLAGS = l2FlagsAddr;\\n    // Additional L2 payment configuration\\n    _setConfigAC(configACAddr);\\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n    _setPaymentStrategy(paymentStrategy);\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - ArbitrumValidator 0.1.0: initial release\\n   * - ArbitrumValidator 0.2.0: critical Arbitrum network update\\n   *   - xDomain `msg.sender` backwards incompatible change (now an alias address)\\n   *   - new `withdrawFundsFromL2` fn that withdraws from L2 xDomain alias address\\n   *   - approximation of `maxSubmissionCost` using a L1 gas price feed\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"ArbitrumValidator 0.2.0\\\";\\n  }\\n\\n  /// @return stored PaymentStrategy\\n  function paymentStrategy() external view virtual returns (PaymentStrategy) {\\n    return s_paymentStrategy;\\n  }\\n\\n  /// @return stored GasConfig\\n  function gasConfig() external view virtual returns (GasConfig memory) {\\n    return s_gasConfig;\\n  }\\n\\n  /// @return config AccessControllerInterface contract address\\n  function configAC() external view virtual returns (address) {\\n    return address(s_configAC);\\n  }\\n\\n  /**\\n   * @notice makes this contract payable\\n   * @dev receives funds:\\n   *  - to use them (if configured) to pay for L2 execution on L1\\n   *  - when withdrawing funds from L2 xDomain alias address (pay for L2 execution on L2)\\n   */\\n  receive() external payable {}\\n\\n  /**\\n   * @notice withdraws all funds available in this contract to the msg.sender\\n   * @dev only owner can call this\\n   */\\n  function withdrawFunds() external onlyOwner {\\n    address payable recipient = payable(msg.sender);\\n    uint256 amount = address(this).balance;\\n    Address.sendValue(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice withdraws all funds available in this contract to the address specified\\n   * @dev only owner can call this\\n   * @param recipient address where to send the funds\\n   */\\n  function withdrawFundsTo(address payable recipient) external onlyOwner {\\n    uint256 amount = address(this).balance;\\n    Address.sendValue(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice withdraws funds from L2 xDomain alias address (representing this L1 contract)\\n   * @dev only owner can call this\\n   * @param amount of funds to withdraws\\n   * @param refundAddr address where gas excess on L2 will be sent\\n   *   WARNING: `refundAddr` is not aliased! Make sure you can recover the refunded funds on L2.\\n   * @return id unique id of the published retryable transaction (keccak256(requestID, uint(0))\\n   */\\n  function withdrawFundsFromL2(uint256 amount, address refundAddr) external onlyOwner returns (uint256 id) {\\n    // Build an xDomain message to trigger the ArbSys precompile, which will create a L2 -> L1 tx transferring `amount`\\n    bytes memory message = abi.encodeWithSelector(ArbSys.withdrawEth.selector, address(this));\\n    // Make the xDomain call\\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\\n    uint256 maxGas = 120_000; // static `maxGas` for L2 -> L1 transfer\\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\\n      : 0;\\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\\n    id = IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\\n      ARBSYS_ADDR, // target\\n      amount, // L2 call value (requested)\\n      maxSubmissionCost,\\n      refundAddr, // excessFeeRefundAddress\\n      refundAddr, // callValueRefundAddress\\n      maxGas,\\n      gasPriceBid,\\n      message\\n    );\\n    emit L2WithdrawalRequested(id, amount, refundAddr);\\n  }\\n\\n  /**\\n   * @notice sets config AccessControllerInterface contract\\n   * @dev only owner can call this\\n   * @param accessController new AccessControllerInterface contract address\\n   */\\n  function setConfigAC(address accessController) external onlyOwner {\\n    _setConfigAC(accessController);\\n  }\\n\\n  /**\\n   * @notice sets Arbitrum gas configuration\\n   * @dev access control provided by `configAC`\\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   */\\n  function setGasConfig(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr\\n  ) external onlyOwnerOrConfigAccess {\\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n  }\\n\\n  /**\\n   * @notice sets the payment strategy\\n   * @dev access control provided by `configAC`\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  function setPaymentStrategy(PaymentStrategy paymentStrategy) external onlyOwnerOrConfigAccess {\\n    _setPaymentStrategy(paymentStrategy);\\n  }\\n\\n  /**\\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\\n   * @dev A retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this\\n   *   contract providing a value, or if no L1 value is sent with the xDomain message the gas will be paid by\\n   *   the L2 xDomain alias account (generated from `address(this)`). This method is accessed controlled.\\n   * @param previousAnswer previous aggregator answer\\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\\n   */\\n  function validate(\\n    uint256, /* previousRoundId */\\n    int256 previousAnswer,\\n    uint256, /* currentRoundId */\\n    int256 currentAnswer\\n  ) external override checkAccess returns (bool) {\\n    // Avoids resending to L2 the same tx on every call\\n    if (previousAnswer == currentAnswer) {\\n      return true;\\n    }\\n\\n    // Excess gas on L2 will be sent to the L2 xDomain alias address of this contract\\n    address refundAddr = L2_ALIAS;\\n    // Encode the Forwarder call\\n    bytes4 selector = ForwarderInterface.forward.selector;\\n    address target = L2_FLAGS;\\n    // Choose and encode the underlying Flags call\\n    bytes memory data = currentAnswer == ANSWER_SEQ_OFFLINE ? CALL_RAISE_FLAG : CALL_LOWER_FLAG;\\n    bytes memory message = abi.encodeWithSelector(selector, target, data);\\n    // Make the xDomain call\\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\\n    uint256 maxGas = s_gasConfig.maxGas;\\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\\n      : 0;\\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\\n    // We also ignore the returned msg number, that can be queried via the `InboxMessageDelivered` event.\\n    IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\\n      L2_CROSS_DOMAIN_FORWARDER, // target\\n      0, // L2 call value\\n      maxSubmissionCost,\\n      refundAddr, // excessFeeRefundAddress\\n      refundAddr, // callValueRefundAddress\\n      maxGas,\\n      gasPriceBid,\\n      message\\n    );\\n    // return success\\n    return true;\\n  }\\n\\n  /// @notice internal method that stores the payment strategy\\n  function _setPaymentStrategy(PaymentStrategy paymentStrategy) internal {\\n    s_paymentStrategy = paymentStrategy;\\n    emit PaymentStrategySet(paymentStrategy);\\n  }\\n\\n  /// @notice internal method that stores the gas configuration\\n  function _setGasConfig(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr\\n  ) internal {\\n    require(maxGas > 0, \\\"Max gas is zero\\\");\\n    require(gasPriceBid > 0, \\\"Gas price bid is zero\\\");\\n    require(gasPriceL1FeedAddr != address(0), \\\"Gas price Aggregator is zero address\\\");\\n    s_gasConfig = GasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n    emit GasConfigSet(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n  }\\n\\n  /// @notice Internal method that stores the configuration access controller\\n  function _setConfigAC(address accessController) internal {\\n    address previousAccessController = address(s_configAC);\\n    if (accessController != previousAccessController) {\\n      s_configAC = AccessControllerInterface(accessController);\\n      emit ConfigACSet(previousAccessController, accessController);\\n    }\\n  }\\n\\n  /**\\n   * @notice Internal method that approximates the `maxSubmissionCost` (using the L1 gas price feed)\\n   * @dev On L2 this info is available via `ArbRetryableTx.getSubmissionPrice`.\\n   * @param calldataSizeInBytes xDomain message size in bytes\\n   */\\n  function _approximateMaxSubmissionCost(uint256 calldataSizeInBytes) internal view returns (uint256) {\\n    (, int256 l1GasPriceInWei, , , ) = AggregatorV3Interface(s_gasConfig.gasPriceL1FeedAddr).latestRoundData();\\n    uint256 l1GasPriceEstimate = uint256(l1GasPriceInWei) * 3; // add 200% buffer (price volatility error margin)\\n    return (l1GasPriceEstimate * calldataSizeInBytes) / 256 + l1GasPriceEstimate;\\n  }\\n\\n  /// @notice Internal helper method that calculates the total cost of the xDomain retryable ticket call\\n  function _maxRetryableTicketCost(\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 gasPriceBid\\n  ) internal pure returns (uint256) {\\n    return maxSubmissionCost + maxGas * gasPriceBid;\\n  }\\n\\n  /// @dev reverts if the caller does not have access to change the configuration\\n  modifier onlyOwnerOrConfigAccess() {\\n    require(\\n      msg.sender == owner() || (address(s_configAC) != address(0) && s_configAC.hasAccess(msg.sender, msg.data)),\\n      \\\"No access\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n  function sendUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendL1FundedUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function sendL1FundedContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicketNoRefundAliasRewrite(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicket(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function depositEth(address destAddr) external payable returns (uint256);\\n\\n  function depositEthRetryable(\\n    address destAddr,\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 maxGasPrice\\n  ) external payable returns (uint256);\\n\\n  function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n  uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n  /// address in the L1 that submitted a tx to the inbox\\n  /// @param l1Address L2 address as viewed in msg.sender\\n  /// @return l2Address the address in the L1 that triggered the tx to L2\\n  function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n    unchecked {\\n      l2Address = address(uint160(l1Address) + offset);\\n    }\\n  }\\n\\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n  /// address in the L1 that submitted a tx to the inbox\\n  /// @param l2Address L2 address as viewed in msg.sender\\n  /// @return l1Address the address in the L1 that triggered the tx to L2\\n  function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n    unchecked {\\n      l1Address = address(uint160(l2Address) - offset);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol\": {\r\n      \"content\": \"// NOTICE: pragma change from original (>=0.4.21 <0.7.0)\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/**\\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\n */\\ninterface ArbSys {\\n  /**\\n   * @notice Get internal version number identifying an ArbOS build\\n   * @return version number as int\\n   */\\n  function arbOSVersion() external pure returns (uint256);\\n\\n  function arbChainID() external view returns (uint256);\\n\\n  /**\\n   * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n   * @return block number as int\\n   */\\n  function arbBlockNumber() external view returns (uint256);\\n\\n  /**\\n   * @notice Send given amount of Eth to dest from sender.\\n   * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\n   * @param destination recipient address on L1\\n   * @return unique identifier for this L2-to-L1 transaction.\\n   */\\n  function withdrawEth(address destination) external payable returns (uint256);\\n\\n  /**\\n   * @notice Send a transaction to L1\\n   * @param destination recipient address on L1\\n   * @param calldataForL1 (optional) calldata for L1 contract call\\n   * @return a unique identifier for this L2-to-L1 transaction.\\n   */\\n  function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\\n\\n  /**\\n   * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\n   * @param account target account\\n   * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\n   */\\n  function getTransactionCount(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice get the value of target L2 storage slot\\n   * This function is only callable from address 0 to prevent contracts from being able to call it\\n   * @param account target account\\n   * @param index target index of storage slot\\n   * @return stotage value for the given account at the given index\\n   */\\n  function getStorageAt(address account, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice check if current call is coming from l1\\n   * @return true if the caller of this was called directly from L1\\n   */\\n  function isTopLevelCall() external view returns (bool);\\n\\n  event L2ToL1Transaction(\\n    address caller,\\n    address indexed destination,\\n    uint256 indexed uniqueId,\\n    uint256 indexed batchNumber,\\n    uint256 indexInBatch,\\n    uint256 arbBlockNum,\\n    uint256 ethBlockNum,\\n    uint256 timestamp,\\n    uint256 callvalue,\\n    bytes data\\n  );\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\ninterface IBridge {\\n  event MessageDelivered(\\n    uint256 indexed messageIndex,\\n    bytes32 indexed beforeInboxAcc,\\n    address inbox,\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  );\\n\\n  function deliverMessageToInbox(\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  ) external payable returns (uint256);\\n\\n  function executeCall(\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (bool success, bytes memory returnData);\\n\\n  // These are only callable by the admin\\n  function setInbox(address inbox, bool enabled) external;\\n\\n  function setOutbox(address inbox, bool enabled) external;\\n\\n  // View functions\\n\\n  function activeOutbox() external view returns (address);\\n\\n  function allowedInboxes(address inbox) external view returns (bool);\\n\\n  function allowedOutboxes(address outbox) external view returns (bool);\\n\\n  function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n  function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\ninterface IMessageProvider {\\n  event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n  event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/ArbitrumCrossDomainForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\\\";\\nimport \\\"./CrossDomainForwarder.sol\\\";\\n\\n/**\\n * @title ArbitrumCrossDomainForwarder - L1 xDomain account representation\\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\\n *   can be considered to be owned by the `l1Owner`\\n */\\ncontract ArbitrumCrossDomainForwarder is TypeAndVersionInterface, CrossDomainForwarder {\\n  /**\\n   * @notice creates a new Arbitrum xDomain Forwarder contract\\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\\n   */\\n  constructor(address l1OwnerAddr) CrossDomainForwarder(l1OwnerAddr) {\\n    // noop\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - ArbitrumCrossDomainForwarder 0.1.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"ArbitrumCrossDomainForwarder 0.1.0\\\";\\n  }\\n\\n  /**\\n   * @notice The L2 xDomain `msg.sender`, generated from L1 sender address\\n   * @inheritdoc CrossDomainForwarder\\n   */\\n  function crossDomainMessenger() public view virtual override returns (address) {\\n    return AddressAliasHelper.applyL1ToL2Alias(l1Owner());\\n  }\\n\\n  /**\\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address\\n   * @inheritdoc ForwarderInterface\\n   */\\n  function forward(address target, bytes memory data) external override {\\n    // 1. The call MUST come from the L2 Messenger (deterministically generated from the L1 xDomain sender address)\\n    require(msg.sender == crossDomainMessenger(), \\\"Sender is not the L2 messenger\\\");\\n    // 2. Make the external call\\n    (bool success, bytes memory res) = target.call(data);\\n    require(success, string(abi.encode(\\\"xDomain call failed:\\\", res)));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"../SimpleReadAccessController.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\n\\n/* dev dependencies - to be re/moved after audit */\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n/**\\n * @title The Flags contract\\n * @notice Allows flags to signal to any reader on the access control list.\\n * The owner can set flags, or designate other addresses to set flags.\\n * Raise flag actions are controlled by its own access controller.\\n * Lower flag actions are controlled by its own access controller.\\n * An expected pattern is to allow addresses to raise flags on themselves, so if you are subscribing to\\n * FlagOn events you should filter for addresses you care about.\\n */\\ncontract Flags is TypeAndVersionInterface, FlagsInterface, SimpleReadAccessController {\\n  AccessControllerInterface public raisingAccessController;\\n  AccessControllerInterface public loweringAccessController;\\n\\n  mapping(address => bool) private flags;\\n\\n  event FlagRaised(address indexed subject);\\n  event FlagLowered(address indexed subject);\\n  event RaisingAccessControllerUpdated(address indexed previous, address indexed current);\\n  event LoweringAccessControllerUpdated(address indexed previous, address indexed current);\\n\\n  /**\\n   * @param racAddress address for the raising access controller.\\n   * @param lacAddress address for the lowering access controller.\\n   */\\n  constructor(address racAddress, address lacAddress) {\\n    setRaisingAccessController(racAddress);\\n    setLoweringAccessController(lacAddress);\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller\\n   * - Flags 1.0.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"Flags 1.1.0\\\";\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subject The contract address being checked for a flag.\\n   * @return A true value indicates that a flag was raised and a\\n   * false value indicates that no flag was raised.\\n   */\\n  function getFlag(address subject) external view override checkAccess returns (bool) {\\n    return flags[subject];\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subjects An array of addresses being checked for a flag.\\n   * @return An array of bools where a true value for any flag indicates that\\n   * a flag was raised and a false value indicates that no flag was raised.\\n   */\\n  function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\\n    bool[] memory responses = new bool[](subjects.length);\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      responses[i] = flags[subjects[i]];\\n    }\\n    return responses;\\n  }\\n\\n  /**\\n   * @notice enable the warning flag for an address.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being raised\\n   */\\n  function raiseFlag(address subject) external override {\\n    require(_allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    _tryToRaiseFlag(subject);\\n  }\\n\\n  /**\\n   * @notice enable the warning flags for multiple addresses.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being raised\\n   */\\n  function raiseFlags(address[] calldata subjects) external override {\\n    require(_allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      _tryToRaiseFlag(subjects[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for an addresses.\\n   * Access is controlled by loweringAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being lowered\\n   */\\n  function lowerFlag(address subject) external override {\\n    require(_allowedToLowerFlags(), \\\"Not allowed to lower flags\\\");\\n\\n    _tryToLowerFlag(subject);\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for multiple addresses.\\n   * Access is controlled by loweringAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being lowered\\n   */\\n  function lowerFlags(address[] calldata subjects) external override {\\n    require(_allowedToLowerFlags(), \\\"Not allowed to lower flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      address subject = subjects[i];\\n\\n      _tryToLowerFlag(subject);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to change the access controller for raising flags.\\n   * @param racAddress new address for the raising access controller.\\n   */\\n  function setRaisingAccessController(address racAddress) public override onlyOwner {\\n    address previous = address(raisingAccessController);\\n\\n    if (previous != racAddress) {\\n      raisingAccessController = AccessControllerInterface(racAddress);\\n\\n      emit RaisingAccessControllerUpdated(previous, racAddress);\\n    }\\n  }\\n\\n  function setLoweringAccessController(address lacAddress) public override onlyOwner {\\n    address previous = address(loweringAccessController);\\n\\n    if (previous != lacAddress) {\\n      loweringAccessController = AccessControllerInterface(lacAddress);\\n\\n      emit LoweringAccessControllerUpdated(previous, lacAddress);\\n    }\\n  }\\n\\n  // PRIVATE\\n  function _allowedToRaiseFlags() private view returns (bool) {\\n    return msg.sender == owner() || raisingAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function _allowedToLowerFlags() private view returns (bool) {\\n    return msg.sender == owner() || loweringAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function _tryToRaiseFlag(address subject) private {\\n    if (!flags[subject]) {\\n      flags[subject] = true;\\n      emit FlagRaised(subject);\\n    }\\n  }\\n\\n  function _tryToLowerFlag(address subject) private {\\n    if (flags[subject]) {\\n      flags[subject] = false;\\n      emit FlagLowered(subject);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleReadAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleWriteAccessController.sol\\\";\\n\\n/**\\n * @title SimpleReadAccessController\\n * @notice Gives access to:\\n * - any externally owned account (note that offchain actors can always read\\n * any contract storage regardless of onchain access control measures, so this\\n * does not weaken the access control while improving usability)\\n * - accounts explicitly added to an access list\\n * @dev SimpleReadAccessController is not suitable for access controlling writes\\n * since it grants any externally owned account access! See\\n * SimpleWriteAccessController for that.\\n */\\ncontract SimpleReadAccessController is SimpleWriteAccessController {\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {\\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleReadAccessController.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n/**\\n * @title The Flags contract\\n * @notice Allows flags to signal to any reader on the access control list.\\n * The owner can set flags, or designate other addresses to set flags. The\\n * owner must turn the flags off, other setters cannot. An expected pattern is\\n * to allow addresses to raise flags on themselves, so if you are subscribing to\\n * FlagOn events you should filter for addresses you care about.\\n */\\ncontract Flags is FlagsInterface, SimpleReadAccessController {\\n  AccessControllerInterface public raisingAccessController;\\n\\n  mapping(address => bool) private flags;\\n\\n  event FlagRaised(address indexed subject);\\n  event FlagLowered(address indexed subject);\\n  event RaisingAccessControllerUpdated(address indexed previous, address indexed current);\\n\\n  /**\\n   * @param racAddress address for the raising access controller.\\n   */\\n  constructor(address racAddress) {\\n    setRaisingAccessController(racAddress);\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subject The contract address being checked for a flag.\\n   * @return A true value indicates that a flag was raised and a\\n   * false value indicates that no flag was raised.\\n   */\\n  function getFlag(address subject) external view override checkAccess returns (bool) {\\n    return flags[subject];\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subjects An array of addresses being checked for a flag.\\n   * @return An array of bools where a true value for any flag indicates that\\n   * a flag was raised and a false value indicates that no flag was raised.\\n   */\\n  function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\\n    bool[] memory responses = new bool[](subjects.length);\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      responses[i] = flags[subjects[i]];\\n    }\\n    return responses;\\n  }\\n\\n  /**\\n   * @notice enable the warning flag for an address.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being raised\\n   */\\n  function raiseFlag(address subject) external override {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    tryToRaiseFlag(subject);\\n  }\\n\\n  /**\\n   * @notice enable the warning flags for multiple addresses.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being raised\\n   */\\n  function raiseFlags(address[] calldata subjects) external override {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      tryToRaiseFlag(subjects[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for multiple addresses.\\n   * @param subjects List of the contract addresses whose flag is being lowered\\n   */\\n  function lowerFlags(address[] calldata subjects) external override onlyOwner {\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      address subject = subjects[i];\\n\\n      if (flags[subject]) {\\n        flags[subject] = false;\\n        emit FlagLowered(subject);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to change the access controller for raising flags.\\n   * @param racAddress new address for the raising access controller.\\n   */\\n  function setRaisingAccessController(address racAddress) public override onlyOwner {\\n    address previous = address(raisingAccessController);\\n\\n    if (previous != racAddress) {\\n      raisingAccessController = AccessControllerInterface(racAddress);\\n\\n      emit RaisingAccessControllerUpdated(previous, racAddress);\\n    }\\n  }\\n\\n  // PRIVATE\\n\\n  function allowedToRaiseFlags() private view returns (bool) {\\n    return msg.sender == owner() || raisingAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function tryToRaiseFlag(address subject) private {\\n    if (!flags[subject]) {\\n      flags[subject] = true;\\n      emit FlagRaised(subject);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n\\n  function raiseFlag(address) external;\\n\\n  function raiseFlags(address[] calldata) external;\\n\\n  function lowerFlags(address[] calldata) external;\\n\\n  function setRaisingAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/FlagsTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Flags.sol\\\";\\n\\ncontract FlagsTestHelper {\\n  Flags public flags;\\n\\n  constructor(address flagsContract) {\\n    flags = Flags(flagsContract);\\n  }\\n\\n  function getFlag(address subject) external view returns (bool) {\\n    return flags.getFlag(subject);\\n  }\\n\\n  function getFlags(address[] calldata subjects) external view returns (bool[] memory) {\\n    return flags.getFlags(subjects);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/FeedRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./AggregatorV2V3Interface.sol\\\";\\n\\ninterface FeedRegistryInterface {\\n  struct Phase {\\n    uint16 phaseId;\\n    uint80 startingAggregatorRoundId;\\n    uint80 endingAggregatorRoundId;\\n  }\\n\\n  event FeedProposed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed proposedAggregator,\\n    address currentAggregator,\\n    address sender\\n  );\\n  event FeedConfirmed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed latestAggregator,\\n    address previousAggregator,\\n    uint16 nextPhaseId,\\n    address sender\\n  );\\n\\n  // V3 AggregatorV3Interface\\n\\n  function decimals(address base, address quote) external view returns (uint8);\\n\\n  function description(address base, address quote) external view returns (string memory);\\n\\n  function version(address base, address quote) external view returns (uint256);\\n\\n  function latestRoundData(address base, address quote)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function getRoundData(\\n    address base,\\n    address quote,\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // V2 AggregatorInterface\\n\\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\\n\\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\\n\\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\\n\\n  function getAnswer(\\n    address base,\\n    address quote,\\n    uint256 roundId\\n  ) external view returns (int256 answer);\\n\\n  function getTimestamp(\\n    address base,\\n    address quote,\\n    uint256 roundId\\n  ) external view returns (uint256 timestamp);\\n\\n  // Registry getters\\n\\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function getPhaseFeed(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function isFeedEnabled(address aggregator) external view returns (bool);\\n\\n  function getPhase(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (Phase memory phase);\\n\\n  // Round helpers\\n\\n  function getRoundFeed(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function getPhaseRange(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\\n\\n  function getPreviousRoundId(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (uint80 previousRoundId);\\n\\n  function getNextRoundId(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (uint80 nextRoundId);\\n\\n  // Feed management\\n\\n  function proposeFeed(\\n    address base,\\n    address quote,\\n    address aggregator\\n  ) external;\\n\\n  function confirmFeed(\\n    address base,\\n    address quote,\\n    address aggregator\\n  ) external;\\n\\n  // Proposed aggregator\\n\\n  function getProposedFeed(address base, address quote)\\n    external\\n    view\\n    returns (AggregatorV2V3Interface proposedAggregator);\\n\\n  function proposedGetRoundData(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function proposedLatestRoundData(address base, address quote)\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // Phases\\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/mocks/MockAggregatorValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\n\\ncontract MockAggregatorValidator is AggregatorValidatorInterface {\\n  uint8 immutable id;\\n\\n  constructor(uint8 id_) {\\n    id = id_;\\n  }\\n\\n  event ValidateCalled(\\n    uint8 id,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external override returns (bool) {\\n    emit ValidateCalled(id, previousRoundId, previousAnswer, currentRoundId, currentAnswer);\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../dev/VRF.sol\\\";\\n\\n/** ***********************************************************************\\n    @notice Testing harness for VRF.sol, exposing its internal methods. Not to\\n    @notice be used for production.\\n*/\\ncontract VRFTestHelper is VRF {\\n  function bigModExp_(uint256 base, uint256 exponent) public view returns (uint256) {\\n    return super.bigModExp(base, exponent);\\n  }\\n\\n  function squareRoot_(uint256 x) public view returns (uint256) {\\n    return super.squareRoot(x);\\n  }\\n\\n  function ySquared_(uint256 x) public pure returns (uint256) {\\n    return super.ySquared(x);\\n  }\\n\\n  function fieldHash_(bytes memory b) public pure returns (uint256) {\\n    return super.fieldHash(b);\\n  }\\n\\n  function hashToCurve_(uint256[2] memory pk, uint256 x) public view returns (uint256[2] memory) {\\n    return super.hashToCurve(pk, x);\\n  }\\n\\n  function ecmulVerify_(\\n    uint256[2] memory x,\\n    uint256 scalar,\\n    uint256[2] memory q\\n  ) public pure returns (bool) {\\n    return super.ecmulVerify(x, scalar, q);\\n  }\\n\\n  function projectiveECAdd_(\\n    uint256 px,\\n    uint256 py,\\n    uint256 qx,\\n    uint256 qy\\n  )\\n    public\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return super.projectiveECAdd(px, py, qx, qy);\\n  }\\n\\n  function affineECAdd_(\\n    uint256[2] memory p1,\\n    uint256[2] memory p2,\\n    uint256 invZ\\n  ) public pure returns (uint256[2] memory) {\\n    return super.affineECAdd(p1, p2, invZ);\\n  }\\n\\n  function verifyLinearCombinationWithGenerator_(\\n    uint256 c,\\n    uint256[2] memory p,\\n    uint256 s,\\n    address lcWitness\\n  ) public pure returns (bool) {\\n    return super.verifyLinearCombinationWithGenerator(c, p, s, lcWitness);\\n  }\\n\\n  function linearCombination_(\\n    uint256 c,\\n    uint256[2] memory p1,\\n    uint256[2] memory cp1Witness,\\n    uint256 s,\\n    uint256[2] memory p2,\\n    uint256[2] memory sp2Witness,\\n    uint256 zInv\\n  ) public pure returns (uint256[2] memory) {\\n    return super.linearCombination(c, p1, cp1Witness, s, p2, sp2Witness, zInv);\\n  }\\n\\n  function scalarFromCurvePoints_(\\n    uint256[2] memory hash,\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    address uWitness,\\n    uint256[2] memory v\\n  ) public pure returns (uint256) {\\n    return super.scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\\n  }\\n\\n  function isOnCurve_(uint256[2] memory p) public pure returns (bool) {\\n    return super.isOnCurve(p);\\n  }\\n\\n  function verifyVRFProof_(\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    uint256 c,\\n    uint256 s,\\n    uint256 seed,\\n    address uWitness,\\n    uint256[2] memory cGammaWitness,\\n    uint256[2] memory sHashWitness,\\n    uint256 zInv\\n  ) public view {\\n    super.verifyVRFProof(pk, gamma, c, s, seed, uWitness, cGammaWitness, sHashWitness, zInv);\\n  }\\n\\n  function randomValueFromVRFProof_(Proof memory proof, uint256 seed) public view returns (uint256 output) {\\n    return super.randomValueFromVRFProof(proof, seed);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface internal immutable LINK;\\n  address private immutable vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(address _vrfCoordinator, address _link) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFRequestIDBaseTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../VRFRequestIDBase.sol\\\";\\n\\ncontract VRFRequestIDBaseTestHelper is VRFRequestIDBase {\\n  function makeVRFInputSeed_(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) public pure returns (uint256) {\\n    return makeVRFInputSeed(_keyHash, _userSeed, _requester, _nonce);\\n  }\\n\\n  function makeRequestId_(bytes32 _keyHash, uint256 _vRFInputSeed) public pure returns (bytes32) {\\n    return makeRequestId(_keyHash, _vRFInputSeed);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../VRFConsumerBase.sol\\\";\\n\\ncontract VRFConsumer is VRFConsumerBase {\\n  uint256 public randomnessOutput;\\n  bytes32 public requestId;\\n\\n  constructor(address vrfCoordinator, address link)\\n    // solhint-disable-next-line no-empty-blocks\\n    VRFConsumerBase(vrfCoordinator, link)\\n  {\\n    /* empty */\\n  }\\n\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\n    randomnessOutput = randomness;\\n    requestId = requestId;\\n  }\\n\\n  function testRequestRandomness(bytes32 keyHash, uint256 fee) external returns (bytes32) {\\n    return requestRandomness(keyHash, fee);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crossDomainMessengerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2CrossDomainForwarderAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2FlagsAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"configACAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"},{\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"paymentStrategy\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"ConfigACSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"}],\"name\":\"GasConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundAddr\",\"type\":\"address\"}],\"name\":\"L2WithdrawalRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"paymentStrategy\",\"type\":\"uint8\"}],\"name\":\"PaymentStrategySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovedAccess\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CROSS_DOMAIN_MESSENGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLAG_ARBITRUM_SEQ_OFFLINE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_ALIAS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_CROSS_DOMAIN_FORWARDER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_FLAGS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configAC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"}],\"internalType\":\"struct ArbitrumValidator.GasConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentStrategy\",\"outputs\":[{\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessController\",\"type\":\"address\"}],\"name\":\"setConfigAC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"}],\"name\":\"setGasConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"paymentStrategy\",\"type\":\"uint8\"}],\"name\":\"setPaymentStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refundAddr\",\"type\":\"address\"}],\"name\":\"withdrawFundsFromL2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawFundsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ArbitrumValidator","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000004dbd4fc535ac27206064b68ffcf827b0a60bab3f000000000000000000000000350a791bfc2c21f9ed5d10980dad2e2638ffa7f60000000000000000000000003c14e07edd0dc67442fa96f1ec6999c57e810a830000000000000000000000002be843e2a5907fff0b7c9337b5058617bfec2bfe0000000000000000000000000000000000000000000000000000000001312d0000000000000000000000000000000000000000000000000000000000b2d05e00000000000000000000000000169e633a2d1e6c10dd91238ba11c4a708dfef37c0000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}