{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Migration_Kaus.sol\": {\r\n      \"content\": \"/*\\n   ____            __   __        __   _\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\n     /___/\\n\\n* Synthetix: migrations/Migration_Kaus.sol\\n*\\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Kaus.sol\\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Kaus\\n*\\n* Contract Dependencies: \\n*\\t- BaseMigration\\n*\\t- IAddressResolver\\n*\\t- IIssuer\\n*\\t- ISynthetixState\\n*\\t- MixinResolver\\n*\\t- MixinSystemSettings\\n*\\t- Owned\\n*\\t- State\\n* Libraries: \\n*\\t- SafeCast\\n*\\t- SafeDecimalMath\\n*\\t- SafeMath\\n*\\t- VestingEntries\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\n\\n\\n\\npragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\\n\\ncontract BaseMigration is Owned {\\n    address public deployer;\\n\\n    constructor(address _owner) internal Owned(_owner) {\\n        deployer = msg.sender;\\n    }\\n\\n    // safety value to return ownership (anyone can invoke)\\n    function returnOwnership(address forContract) public {\\n        bytes memory payload = abi.encodeWithSignature(\\\"nominateNewOwner(address)\\\", owner);\\n\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, ) = forContract.call(payload);\\n\\n        if (!success) {\\n            // then try legacy way\\n            bytes memory legacyPayload = abi.encodeWithSignature(\\\"nominateOwner(address)\\\", owner);\\n\\n            // solhint-disable avoid-low-level-calls\\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\\n\\n            require(legacySuccess, \\\"Legacy nomination failed\\\");\\n        }\\n    }\\n\\n    function _requireDeployer() private view {\\n        require(msg.sender == deployer, \\\"Only the deployer can invoke this\\\");\\n    }\\n\\n    modifier onlyDeployer() {\\n        _requireDeployer();\\n        _;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getSynth(bytes32 key) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\\ninterface ISynth {\\n    // Views\\n    function currencyKey() external view returns (bytes32);\\n\\n    function transferableSynths(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function transferAndSettle(address to, uint value) external returns (bool);\\n\\n    function transferFromAndSettle(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Restricted: used internally to Synthetix\\n    function burn(address account, uint amount) external;\\n\\n    function issue(address account, uint amount) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\\ninterface IIssuer {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function canBurnSynths(address account) external view returns (bool);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\\n        external\\n        view\\n        returns (uint cratio, bool anyRateIsInvalid);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\\n\\n    function issuanceRatio() external view returns (uint);\\n\\n    function lastIssueEvent(address account) external view returns (uint);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function minimumStakeTime() external view returns (uint);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\\n\\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\\n        external\\n        view\\n        returns (uint transferable, bool anyRateIsInvalid);\\n\\n    // Restricted: used internally to Synthetix\\n    function issueSynths(address from, uint amount) external;\\n\\n    function issueSynthsOnBehalf(\\n        address issueFor,\\n        address from,\\n        uint amount\\n    ) external;\\n\\n    function issueMaxSynths(address from) external;\\n\\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\\n\\n    function burnSynths(address from, uint amount) external;\\n\\n    function burnSynthsOnBehalf(\\n        address burnForAddress,\\n        address from,\\n        uint amount\\n    ) external;\\n\\n    function burnSynthsToTarget(address from) external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\\n\\n    function burnForRedemption(\\n        address deprecatedSynthProxy,\\n        address account,\\n        uint balance\\n    ) external;\\n\\n    function liquidateDelinquentAccount(\\n        address account,\\n        uint susdAmount,\\n        address liquidator\\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\\n}\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\\ncontract MixinResolver {\\n    AddressResolver public resolver;\\n\\n    mapping(bytes32 => address) private addressCache;\\n\\n    constructor(address _resolver) internal {\\n        resolver = AddressResolver(_resolver);\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\\n        internal\\n        pure\\n        returns (bytes32[] memory combination)\\n    {\\n        combination = new bytes32[](first.length + second.length);\\n\\n        for (uint i = 0; i < first.length; i++) {\\n            combination[i] = first[i];\\n        }\\n\\n        for (uint j = 0; j < second.length; j++) {\\n            combination[first.length + j] = second[j];\\n        }\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\\n\\n    function rebuildCache() public {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        // The resolver must call this function whenver it updates its state\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            address destination =\\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\\\"Resolver missing target: \\\", name)));\\n            addressCache[name] = destination;\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\\n        address _foundAddress = addressCache[name];\\n        require(_foundAddress != address(0), string(abi.encodePacked(\\\"Missing address: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event CacheUpdated(bytes32 name, address destination);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\\ncontract AddressResolver is Owned, IAddressResolver {\\n    mapping(bytes32 => address) public repository;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\\n        require(names.length == destinations.length, \\\"Input lengths must match\\\");\\n\\n        for (uint i = 0; i < names.length; i++) {\\n            bytes32 name = names[i];\\n            address destination = destinations[i];\\n            repository[name] = destination;\\n            emit AddressImported(name, destination);\\n        }\\n    }\\n\\n    /* ========= PUBLIC FUNCTIONS ========== */\\n\\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\\n        for (uint i = 0; i < destinations.length; i++) {\\n            destinations[i].rebuildCache();\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\\n        for (uint i = 0; i < names.length; i++) {\\n            if (repository[names[i]] != destinations[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function getAddress(bytes32 name) external view returns (address) {\\n        return repository[name];\\n    }\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\\n        address _foundAddress = repository[name];\\n        require(_foundAddress != address(0), reason);\\n        return _foundAddress;\\n    }\\n\\n    function getSynth(bytes32 key) external view returns (address) {\\n        IIssuer issuer = IIssuer(repository[\\\"Issuer\\\"]);\\n        require(address(issuer) != address(0), \\\"Cannot find Issuer address\\\");\\n        return address(issuer.synths(key));\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AddressImported(bytes32 name, address destination);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/state\\ncontract State is Owned {\\n    // the address of the contract that can modify variables\\n    // this can only be changed by the owner of this contract\\n    address public associatedContract;\\n\\n    constructor(address _associatedContract) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    // Change the associated contract to a new address\\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyAssociatedContract {\\n        require(msg.sender == associatedContract, \\\"Only the associated contract can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AssociatedContractUpdated(address associatedContract);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixstate\\ninterface ISynthetixState {\\n    // Views\\n    function debtLedger(uint index) external view returns (uint);\\n\\n    function issuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\\n\\n    function debtLedgerLength() external view returns (uint);\\n\\n    function hasIssued(address account) external view returns (bool);\\n\\n    function lastDebtLedgerEntry() external view returns (uint);\\n\\n    // Mutative functions\\n    function incrementTotalIssuerCount() external;\\n\\n    function decrementTotalIssuerCount() external;\\n\\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\\n\\n    function appendDebtLedgerValue(uint value) external;\\n\\n    function clearIssuanceData(address account) external;\\n}\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\\n\\n// Libraries\\n\\n\\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\nlibrary SafeDecimalMath {\\n    using SafeMath for uint;\\n\\n    /* Number of decimal places in the representations. */\\n    uint8 public constant decimals = 18;\\n    uint8 public constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint public constant UNIT = 10**uint(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return Provides an interface to UNIT.\\n     */\\n    function unit() external pure returns (uint) {\\n        return UNIT;\\n    }\\n\\n    /**\\n     * @return Provides an interface to PRECISE_UNIT.\\n     */\\n    function preciseUnit() external pure returns (uint) {\\n        return PRECISE_UNIT;\\n    }\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y) / UNIT;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of the specified precision unit.\\n     *\\n     * @dev The operands should be in the form of a the specified unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function _multiplyDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a precise unit.\\n     *\\n     * @dev The operands should be in the precise unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a standard unit.\\n     *\\n     * @dev The operands should be in the standard unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * decimal in the precision unit specified in the parameter.\\n     *\\n     * @dev y is divided after the product of x and the specified precision unit\\n     * is evaluated, so the product of x and the specified precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function _divideDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n        if (resultTimesTen % 10 >= 5) {\\n            resultTimesTen += 10;\\n        }\\n\\n        return resultTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * standard precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and the standard precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * high precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the high precision unit\\n     * is evaluated, so the product of x and the high precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    // Computes `a - b`, setting the value to 0 if b > a.\\n    function floorsub(uint a, uint b) internal pure returns (uint) {\\n        return b >= a ? 0 : a - b;\\n    }\\n\\n    /* ---------- Utilities ---------- */\\n    /*\\n     * Absolute value of the input, returned as a signed number.\\n     */\\n    function signedAbs(int x) internal pure returns (int) {\\n        return x < 0 ? -x : x;\\n    }\\n\\n    /*\\n     * Absolute value of the input, returned as an unsigned number.\\n     */\\n    function abs(int x) internal pure returns (uint) {\\n        return uint(signedAbs(x));\\n    }\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/synthetixstate\\ncontract SynthetixState is Owned, State, ISynthetixState {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    // A struct for handing values associated with an individual user's debt position\\n    struct IssuanceData {\\n        // Percentage of the total debt owned at the time\\n        // of issuance. This number is modified by the global debt\\n        // delta array. You can figure out a user's exit price and\\n        // collateralisation ratio using a combination of their initial\\n        // debt and the slice of global debt delta which applies to them.\\n        uint initialDebtOwnership;\\n        // This lets us know when (in relative terms) the user entered\\n        // the debt pool so we can calculate their exit price and\\n        // collateralistion ratio\\n        uint debtEntryIndex;\\n    }\\n\\n    // Issued synth balances for individual fee entitlements and exit price calculations\\n    mapping(address => IssuanceData) public issuanceData;\\n\\n    // The total count of people that have outstanding issued synths in any flavour\\n    uint public totalIssuerCount;\\n\\n    // Global debt pool tracking\\n    uint[] public debtLedger;\\n\\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n     * @notice Set issuance data for an address\\n     * @dev Only the associated contract may call this.\\n     * @param account The address to set the data for.\\n     * @param initialDebtOwnership The initial debt ownership for this address.\\n     */\\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external onlyAssociatedContract {\\n        issuanceData[account].initialDebtOwnership = initialDebtOwnership;\\n        issuanceData[account].debtEntryIndex = debtLedger.length;\\n    }\\n\\n    /**\\n     * @notice Clear issuance data for an address\\n     * @dev Only the associated contract may call this.\\n     * @param account The address to clear the data for.\\n     */\\n    function clearIssuanceData(address account) external onlyAssociatedContract {\\n        delete issuanceData[account];\\n    }\\n\\n    /**\\n     * @notice Increment the total issuer count\\n     * @dev Only the associated contract may call this.\\n     */\\n    function incrementTotalIssuerCount() external onlyAssociatedContract {\\n        totalIssuerCount = totalIssuerCount.add(1);\\n    }\\n\\n    /**\\n     * @notice Decrement the total issuer count\\n     * @dev Only the associated contract may call this.\\n     */\\n    function decrementTotalIssuerCount() external onlyAssociatedContract {\\n        totalIssuerCount = totalIssuerCount.sub(1);\\n    }\\n\\n    /**\\n     * @notice Append a value to the debt ledger\\n     * @dev Only the associated contract may call this.\\n     * @param value The new value to be added to the debt ledger.\\n     */\\n    function appendDebtLedgerValue(uint value) external onlyAssociatedContract {\\n        debtLedger.push(value);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    /**\\n     * @notice Retrieve the length of the debt ledger array\\n     */\\n    function debtLedgerLength() external view returns (uint) {\\n        return debtLedger.length;\\n    }\\n\\n    /**\\n     * @notice Retrieve the most recent entry from the debt ledger\\n     */\\n    function lastDebtLedgerEntry() external view returns (uint) {\\n        return debtLedger[debtLedger.length - 1];\\n    }\\n\\n    /**\\n     * @notice Query whether an account has issued and has an outstanding debt balance\\n     * @param account The address to query for\\n     */\\n    function hasIssued(address account) external view returns (bool) {\\n        return issuanceData[account].initialDebtOwnership > 0;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\\ninterface IFlexibleStorage {\\n    // Views\\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\\n\\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\\n\\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\\n\\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\\n\\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\\n\\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\\n\\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\\n\\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\\n\\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\\n\\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\\n\\n    // Mutative functions\\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\\n\\n    function setUIntValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        uint value\\n    ) external;\\n\\n    function setUIntValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        uint[] calldata values\\n    ) external;\\n\\n    function setIntValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        int value\\n    ) external;\\n\\n    function setIntValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        int[] calldata values\\n    ) external;\\n\\n    function setAddressValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        address value\\n    ) external;\\n\\n    function setAddressValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        address[] calldata values\\n    ) external;\\n\\n    function setBoolValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        bool value\\n    ) external;\\n\\n    function setBoolValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        bool[] calldata values\\n    ) external;\\n\\n    function setBytes32Value(\\n        bytes32 contractName,\\n        bytes32 record,\\n        bytes32 value\\n    ) external;\\n\\n    function setBytes32Values(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        bytes32[] calldata values\\n    ) external;\\n}\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\\ncontract MixinSystemSettings is MixinResolver {\\n    bytes32 internal constant SETTING_CONTRACT_NAME = \\\"SystemSettings\\\";\\n\\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \\\"waitingPeriodSecs\\\";\\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \\\"priceDeviationThresholdFactor\\\";\\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \\\"issuanceRatio\\\";\\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \\\"feePeriodDuration\\\";\\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \\\"targetThreshold\\\";\\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \\\"liquidationDelay\\\";\\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \\\"liquidationRatio\\\";\\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \\\"liquidationPenalty\\\";\\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \\\"rateStalePeriod\\\";\\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \\\"exchangeFeeRate\\\";\\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \\\"minimumStakeTime\\\";\\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \\\"aggregatorWarningFlags\\\";\\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \\\"tradingRewardsEnabled\\\";\\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \\\"debtSnapshotStaleTime\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \\\"crossDomainDepositGasLimit\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \\\"crossDomainEscrowGasLimit\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \\\"crossDomainRewardGasLimit\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \\\"crossDomainWithdrawalGasLimit\\\";\\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \\\"etherWrapperMaxETH\\\";\\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \\\"etherWrapperMintFeeRate\\\";\\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \\\"etherWrapperBurnFeeRate\\\";\\n    bytes32 internal constant SETTING_MIN_CRATIO = \\\"minCratio\\\";\\n    bytes32 internal constant SETTING_NEW_COLLATERAL_MANAGER = \\\"newCollateralManager\\\";\\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \\\"interactionDelay\\\";\\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \\\"collapseFeeRate\\\";\\n\\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \\\"FlexibleStorage\\\";\\n\\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal}\\n\\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\\n\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\\n        addresses = new bytes32[](1);\\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\\n    }\\n\\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\\n    }\\n\\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\\n        } else {\\n            revert(\\\"Unknown gas limit type\\\");\\n        }\\n    }\\n\\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\\n    }\\n\\n    function getTradingRewardsEnabled() internal view returns (bool) {\\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\\n    }\\n\\n    function getWaitingPeriodSecs() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\\n    }\\n\\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\\n    }\\n\\n    function getIssuanceRatio() internal view returns (uint) {\\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\\n    }\\n\\n    function getFeePeriodDuration() internal view returns (uint) {\\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\\n    }\\n\\n    function getTargetThreshold() internal view returns (uint) {\\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\\n    }\\n\\n    function getLiquidationDelay() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\\n    }\\n\\n    function getLiquidationRatio() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\\n    }\\n\\n    function getLiquidationPenalty() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\\n    }\\n\\n    function getRateStalePeriod() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\\n    }\\n\\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\\n        return\\n            flexibleStorage().getUIntValue(\\n                SETTING_CONTRACT_NAME,\\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\\n            );\\n    }\\n\\n    function getMinimumStakeTime() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\\n    }\\n\\n    function getAggregatorWarningFlags() internal view returns (address) {\\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\\n    }\\n\\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\\n    }\\n\\n    function getEtherWrapperMaxETH() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\\n    }\\n\\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\\n    }\\n\\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\\n    }\\n\\n    function getMinCratio(address collateral) internal view returns (uint) {\\n        return\\n            flexibleStorage().getUIntValue(\\n                SETTING_CONTRACT_NAME,\\n                keccak256(abi.encodePacked(SETTING_MIN_CRATIO, collateral))\\n            );\\n    }\\n\\n    function getNewCollateralManager(address collateral) internal view returns (address) {\\n        return\\n            flexibleStorage().getAddressValue(\\n                SETTING_CONTRACT_NAME,\\n                keccak256(abi.encodePacked(SETTING_NEW_COLLATERAL_MANAGER, collateral))\\n            );\\n    }\\n\\n    function getInteractionDelay(address collateral) internal view returns (uint) {\\n        return\\n            flexibleStorage().getUIntValue(\\n                SETTING_CONTRACT_NAME,\\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\\n            );\\n    }\\n\\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\\n        return\\n            flexibleStorage().getUIntValue(\\n                SETTING_CONTRACT_NAME,\\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\\n            );\\n    }\\n}\\n\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\\n\\ninterface IVirtualSynth {\\n    // Views\\n    function balanceOfUnderlying(address account) external view returns (uint);\\n\\n    function rate() external view returns (uint);\\n\\n    function readyToSettle() external view returns (bool);\\n\\n    function secsLeftInWaitingPeriod() external view returns (uint);\\n\\n    function settled() external view returns (bool);\\n\\n    function synth() external view returns (ISynth);\\n\\n    // Mutative functions\\n    function settle(address account) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\\ninterface ISynthetix {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\\n\\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\\n\\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\\n\\n    function transferableSynthetix(address account) external view returns (uint transferable);\\n\\n    // Mutative Functions\\n    function burnSynths(uint amount) external;\\n\\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\\n\\n    function burnSynthsToTarget() external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\\n\\n    function exchange(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalf(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTracking(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTrackingForInitiator(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalfWithTracking(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithVirtual(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\\n\\n    function issueMaxSynths() external;\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\\n\\n    function issueSynths(uint amount) external;\\n\\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\\n\\n    function mint() external returns (bool);\\n\\n    function settle(bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    // Liquidations\\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\\n\\n    // Restricted Functions\\n\\n    function mintSecondary(address account, uint amount) external;\\n\\n    function mintSecondaryRewards(uint amount) external;\\n\\n    function burnSecondary(address account, uint amount) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\\ninterface IFeePool {\\n    // Views\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function FEE_ADDRESS() external view returns (address);\\n\\n    function feesAvailable(address account) external view returns (uint, uint);\\n\\n    function feePeriodDuration() external view returns (uint);\\n\\n    function isFeesClaimable(address account) external view returns (bool);\\n\\n    function targetThreshold() external view returns (uint);\\n\\n    function totalFeesAvailable() external view returns (uint);\\n\\n    function totalRewardsAvailable() external view returns (uint);\\n\\n    // Mutative Functions\\n    function claimFees() external returns (bool);\\n\\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\\n\\n    function closeCurrentFeePeriod() external;\\n\\n    // Restricted: used internally to Synthetix\\n    function appendAccountIssuanceRecord(\\n        address account,\\n        uint lockedAmount,\\n        uint debtEntryIndex\\n    ) external;\\n\\n    function recordFeePaid(uint sUSDAmount) external;\\n\\n    function setRewardsToDistribute(uint amount) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\\ninterface IExchanger {\\n    // Views\\n    function calculateAmountAfterSettlement(\\n        address from,\\n        bytes32 currencyKey,\\n        uint amount,\\n        uint refunded\\n    ) external view returns (uint amountAfterSettlement);\\n\\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\\n\\n    function settlementOwing(address account, bytes32 currencyKey)\\n        external\\n        view\\n        returns (\\n            uint reclaimAmount,\\n            uint rebateAmount,\\n            uint numEntries\\n        );\\n\\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\\n\\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\\n        external\\n        view\\n        returns (uint exchangeFeeRate);\\n\\n    function getAmountsForExchange(\\n        uint sourceAmount,\\n        bytes32 sourceCurrencyKey,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint amountReceived,\\n            uint fee,\\n            uint exchangeFeeRate\\n        );\\n\\n    function priceDeviationThresholdFactor() external view returns (uint);\\n\\n    function waitingPeriodSecs() external view returns (uint);\\n\\n    // Mutative functions\\n    function exchange(\\n        address exchangeForAddress,\\n        address from,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address destinationAddress,\\n        bool virtualSynth,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\\n\\n    function settle(address from, bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    function setLastExchangeRateForSynth(bytes32 currencyKey, uint rate) external;\\n\\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\\n\\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\\ninterface IDelegateApprovals {\\n    // Views\\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\\n\\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\\n\\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\\n\\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\\n\\n    // Mutative\\n    function approveAllDelegatePowers(address delegate) external;\\n\\n    function removeAllDelegatePowers(address delegate) external;\\n\\n    function approveBurnOnBehalf(address delegate) external;\\n\\n    function removeBurnOnBehalf(address delegate) external;\\n\\n    function approveIssueOnBehalf(address delegate) external;\\n\\n    function removeIssueOnBehalf(address delegate) external;\\n\\n    function approveClaimOnBehalf(address delegate) external;\\n\\n    function removeClaimOnBehalf(address delegate) external;\\n\\n    function approveExchangeOnBehalf(address delegate) external;\\n\\n    function removeExchangeOnBehalf(address delegate) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\\ninterface IExchangeRates {\\n    // Structs\\n    struct RateAndUpdatedTime {\\n        uint216 rate;\\n        uint40 time;\\n    }\\n\\n    struct InversePricing {\\n        uint entryPoint;\\n        uint upperLimit;\\n        uint lowerLimit;\\n        bool frozenAtUpperLimit;\\n        bool frozenAtLowerLimit;\\n    }\\n\\n    // Views\\n    function aggregators(bytes32 currencyKey) external view returns (address);\\n\\n    function aggregatorWarningFlags() external view returns (address);\\n\\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\\n\\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\\n\\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\\n\\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\\n\\n    function effectiveValue(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external view returns (uint value);\\n\\n    function effectiveValueAndRates(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint value,\\n            uint sourceRate,\\n            uint destinationRate\\n        );\\n\\n    function effectiveValueAtRound(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external view returns (uint value);\\n\\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\\n\\n    function getLastRoundIdBeforeElapsedSecs(\\n        bytes32 currencyKey,\\n        uint startingRoundId,\\n        uint startingTimestamp,\\n        uint timediff\\n    ) external view returns (uint);\\n\\n    function inversePricing(bytes32 currencyKey)\\n        external\\n        view\\n        returns (\\n            uint entryPoint,\\n            uint upperLimit,\\n            uint lowerLimit,\\n            bool frozenAtUpperLimit,\\n            bool frozenAtLowerLimit\\n        );\\n\\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\\n\\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\\n\\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\\n\\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\\n\\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateStalePeriod() external view returns (uint);\\n\\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\\n        external\\n        view\\n        returns (uint[] memory rates, uint[] memory times);\\n\\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\\n        external\\n        view\\n        returns (uint[] memory rates, bool anyRateInvalid);\\n\\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\\n\\n    // Mutative functions\\n    function freezeRate(bytes32 currencyKey) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ihasbalance\\ninterface IHasBalance {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\\ninterface IERC20 {\\n    // ERC20 Optional Views\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    // Views\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // Mutative functions\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Events\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iliquidations\\ninterface ILiquidations {\\n    // Views\\n    function isOpenForLiquidation(address account) external view returns (bool);\\n\\n    function getLiquidationDeadlineForAccount(address account) external view returns (uint);\\n\\n    function isLiquidationDeadlinePassed(address account) external view returns (bool);\\n\\n    function liquidationDelay() external view returns (uint);\\n\\n    function liquidationRatio() external view returns (uint);\\n\\n    function liquidationPenalty() external view returns (uint);\\n\\n    function calculateAmountToFixCollateral(uint debtBalance, uint collateral) external view returns (uint);\\n\\n    // Mutative Functions\\n    function flagAccountForLiquidation(address account) external;\\n\\n    // Restricted: used internally to Synthetix\\n    function removeAccountInLiquidation(address account) external;\\n\\n    function checkAndRemoveAccountInLiquidation(address account) external;\\n}\\n\\n\\ninterface ICollateralManager {\\n    // Manager information\\n    function hasCollateral(address collateral) external view returns (bool);\\n\\n    function isSynthManaged(bytes32 currencyKey) external view returns (bool);\\n\\n    // State information\\n    function long(bytes32 synth) external view returns (uint amount);\\n\\n    function short(bytes32 synth) external view returns (uint amount);\\n\\n    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid);\\n\\n    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid);\\n\\n    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid);\\n\\n    function getShortRate(bytes32 synth) external view returns (uint shortRate, bool rateIsInvalid);\\n\\n    function getRatesAndTime(uint index)\\n        external\\n        view\\n        returns (\\n            uint entryRate,\\n            uint lastRate,\\n            uint lastUpdated,\\n            uint newIndex\\n        );\\n\\n    function getShortRatesAndTime(bytes32 currency, uint index)\\n        external\\n        view\\n        returns (\\n            uint entryRate,\\n            uint lastRate,\\n            uint lastUpdated,\\n            uint newIndex\\n        );\\n\\n    function exceedsDebtLimit(uint amount, bytes32 currency) external view returns (bool canIssue, bool anyRateIsInvalid);\\n\\n    function areSynthsAndCurrenciesSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\\n        external\\n        view\\n        returns (bool);\\n\\n    function areShortableSynthsSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\\n        external\\n        view\\n        returns (bool);\\n\\n    // Loans\\n    function getNewLoanId() external returns (uint id);\\n\\n    // Manager mutative\\n    function addCollaterals(address[] calldata collaterals) external;\\n\\n    function removeCollaterals(address[] calldata collaterals) external;\\n\\n    function addSynths(bytes32[] calldata synthNamesInResolver, bytes32[] calldata synthKeys) external;\\n\\n    function removeSynths(bytes32[] calldata synths, bytes32[] calldata synthKeys) external;\\n\\n    function addShortableSynths(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys) external;\\n\\n    function removeShortableSynths(bytes32[] calldata synths) external;\\n\\n    // State mutative\\n\\n    function incrementLongs(bytes32 synth, uint amount) external;\\n\\n    function decrementLongs(bytes32 synth, uint amount) external;\\n\\n    function incrementShorts(bytes32 synth, uint amount) external;\\n\\n    function decrementShorts(bytes32 synth, uint amount) external;\\n\\n    function accrueInterest(\\n        uint interestIndex,\\n        bytes32 currency,\\n        bool isShort\\n    ) external returns (uint difference, uint index);\\n\\n    function updateBorrowRatesCollateral(uint rate) external;\\n\\n    function updateShortRatesCollateral(bytes32 currency, uint rate) external;\\n}\\n\\n\\npragma experimental ABIEncoderV2;\\n\\nlibrary VestingEntries {\\n    struct VestingEntry {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n    }\\n    struct VestingEntryWithID {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n        uint256 entryID;\\n    }\\n}\\n\\ninterface IRewardEscrowV2 {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function numVestingEntries(address account) external view returns (uint);\\n\\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\\n\\n    function totalVestedAccountBalance(address account) external view returns (uint);\\n\\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\\n\\n    function getVestingSchedules(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\\n\\n    function getAccountVestingEntryIDs(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (uint256[] memory);\\n\\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\\n\\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\\n\\n    // Mutative functions\\n    function vest(uint256[] calldata entryIDs) external;\\n\\n    function createEscrowEntry(\\n        address beneficiary,\\n        uint256 deposit,\\n        uint256 duration\\n    ) external;\\n\\n    function appendVestingEntry(\\n        address account,\\n        uint256 quantity,\\n        uint256 duration\\n    ) external;\\n\\n    function migrateVestingSchedule(address _addressToMigrate) external;\\n\\n    function migrateAccountEscrowBalances(\\n        address[] calldata accounts,\\n        uint256[] calldata escrowBalances,\\n        uint256[] calldata vestedBalances\\n    ) external;\\n\\n    // Account Merging\\n    function startMergingWindow() external;\\n\\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\\n\\n    function nominateAccountToMerge(address account) external;\\n\\n    function accountMergingIsOpen() external view returns (bool);\\n\\n    // L2 Migration\\n    function importVestingEntries(\\n        address account,\\n        uint256 escrowedAmount,\\n        VestingEntries.VestingEntry[] calldata vestingEntries\\n    ) external;\\n\\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\\n    function burnForMigration(address account, uint256[] calldata entryIDs)\\n        external\\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\\n}\\n\\n\\ninterface ISynthRedeemer {\\n    // Rate of redemption - 0 for none\\n    function redemptions(address synthProxy) external view returns (uint redeemRate);\\n\\n    // sUSD balance of deprecated token holder\\n    function balanceOf(IERC20 synthProxy, address account) external view returns (uint balanceOfInsUSD);\\n\\n    // Full sUSD supply of token\\n    function totalSupply(IERC20 synthProxy) external view returns (uint totalSupplyInsUSD);\\n\\n    function redeem(IERC20 synthProxy) external;\\n\\n    function redeemAll(IERC20[] calldata synthProxies) external;\\n\\n    function redeemPartial(IERC20 synthProxy, uint amountOfSynth) external;\\n\\n    // Restricted to Issuer\\n    function deprecate(IERC20 synthProxy, uint rateToRedeem) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxy\\ncontract Proxy is Owned {\\n    Proxyable public target;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    function setTarget(Proxyable _target) external onlyOwner {\\n        target = _target;\\n        emit TargetUpdated(_target);\\n    }\\n\\n    function _emit(\\n        bytes calldata callData,\\n        uint numTopics,\\n        bytes32 topic1,\\n        bytes32 topic2,\\n        bytes32 topic3,\\n        bytes32 topic4\\n    ) external onlyTarget {\\n        uint size = callData.length;\\n        bytes memory _callData = callData;\\n\\n        assembly {\\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\\n             * This means moving call_data across 32 bytes guarantees we correctly access\\n             * the data itself. */\\n            switch numTopics\\n                case 0 {\\n                    log0(add(_callData, 32), size)\\n                }\\n                case 1 {\\n                    log1(add(_callData, 32), size, topic1)\\n                }\\n                case 2 {\\n                    log2(add(_callData, 32), size, topic1, topic2)\\n                }\\n                case 3 {\\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\\n                }\\n                case 4 {\\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\\n                }\\n        }\\n    }\\n\\n    // solhint-disable no-complex-fallback\\n    function() external payable {\\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\\n        target.setMessageSender(msg.sender);\\n\\n        assembly {\\n            let free_ptr := mload(0x40)\\n            calldatacopy(free_ptr, 0, calldatasize)\\n\\n            /* We must explicitly forward ether to the underlying contract as well. */\\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\\n            returndatacopy(free_ptr, 0, returndatasize)\\n\\n            if iszero(result) {\\n                revert(free_ptr, returndatasize)\\n            }\\n            return(free_ptr, returndatasize)\\n        }\\n    }\\n\\n    modifier onlyTarget {\\n        require(Proxyable(msg.sender) == target, \\\"Must be proxy target\\\");\\n        _;\\n    }\\n\\n    event TargetUpdated(Proxyable newTarget);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\\ncontract Proxyable is Owned {\\n    // This contract should be treated like an abstract contract\\n\\n    /* The proxy this contract exists behind. */\\n    Proxy public proxy;\\n\\n    /* The caller of the proxy, passed through to this contract.\\n     * Note that every function using this member must apply the onlyProxy or\\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\\n    address public messageSender;\\n\\n    constructor(address payable _proxy) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setProxy(address payable _proxy) external onlyOwner {\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setMessageSender(address sender) external onlyProxy {\\n        messageSender = sender;\\n    }\\n\\n    modifier onlyProxy {\\n        _onlyProxy();\\n        _;\\n    }\\n\\n    function _onlyProxy() private view {\\n        require(Proxy(msg.sender) == proxy, \\\"Only the proxy can call\\\");\\n    }\\n\\n    modifier optionalProxy {\\n        _optionalProxy();\\n        _;\\n    }\\n\\n    function _optionalProxy() private {\\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n    }\\n\\n    modifier optionalProxy_onlyOwner {\\n        _optionalProxy_onlyOwner();\\n        _;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _optionalProxy_onlyOwner() private {\\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n        require(messageSender == owner, \\\"Owner only function\\\");\\n    }\\n\\n    event ProxyUpdated(address proxyAddress);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// Internal references\\n\\n\\ninterface IProxy {\\n    function target() external view returns (address);\\n}\\n\\ninterface IIssuerInternalDebtCache {\\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external;\\n\\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\\n\\n    function updateDebtCacheValidity(bool currentlyInvalid) external;\\n\\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid);\\n\\n    function cacheInfo()\\n        external\\n        view\\n        returns (\\n            uint cachedDebt,\\n            uint timestamp,\\n            bool isInvalid,\\n            bool isStale\\n        );\\n\\n    function updateCachedsUSDDebt(int amount) external;\\n}\\n\\n// https://docs.synthetix.io/contracts/source/contracts/issuer\\ncontract Issuer is Owned, MixinSystemSettings, IIssuer {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    bytes32 public constant CONTRACT_NAME = \\\"Issuer\\\";\\n\\n    // Available Synths which can be used with the system\\n    ISynth[] public availableSynths;\\n    mapping(bytes32 => ISynth) public synths;\\n    mapping(address => bytes32) public synthsByAddress;\\n\\n    /* ========== ENCODED NAMES ========== */\\n\\n    bytes32 internal constant sUSD = \\\"sUSD\\\";\\n    bytes32 internal constant sETH = \\\"sETH\\\";\\n    bytes32 internal constant SNX = \\\"SNX\\\";\\n\\n    // Flexible storage names\\n\\n    bytes32 internal constant LAST_ISSUE_EVENT = \\\"lastIssueEvent\\\";\\n\\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\\n\\n    bytes32 private constant CONTRACT_SYNTHETIX = \\\"Synthetix\\\";\\n    bytes32 private constant CONTRACT_EXCHANGER = \\\"Exchanger\\\";\\n    bytes32 private constant CONTRACT_EXRATES = \\\"ExchangeRates\\\";\\n    bytes32 private constant CONTRACT_SYNTHETIXSTATE = \\\"SynthetixState\\\";\\n    bytes32 private constant CONTRACT_FEEPOOL = \\\"FeePool\\\";\\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \\\"DelegateApprovals\\\";\\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \\\"CollateralManager\\\";\\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \\\"RewardEscrowV2\\\";\\n    bytes32 private constant CONTRACT_SYNTHETIXESCROW = \\\"SynthetixEscrow\\\";\\n    bytes32 private constant CONTRACT_LIQUIDATIONS = \\\"Liquidations\\\";\\n    bytes32 private constant CONTRACT_DEBTCACHE = \\\"DebtCache\\\";\\n    bytes32 private constant CONTRACT_SYNTHREDEEMER = \\\"SynthRedeemer\\\";\\n\\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\\n\\n    /* ========== VIEWS ========== */\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\\n        bytes32[] memory newAddresses = new bytes32[](12);\\n        newAddresses[0] = CONTRACT_SYNTHETIX;\\n        newAddresses[1] = CONTRACT_EXCHANGER;\\n        newAddresses[2] = CONTRACT_EXRATES;\\n        newAddresses[3] = CONTRACT_SYNTHETIXSTATE;\\n        newAddresses[4] = CONTRACT_FEEPOOL;\\n        newAddresses[5] = CONTRACT_DELEGATEAPPROVALS;\\n        newAddresses[6] = CONTRACT_REWARDESCROW_V2;\\n        newAddresses[7] = CONTRACT_SYNTHETIXESCROW;\\n        newAddresses[8] = CONTRACT_LIQUIDATIONS;\\n        newAddresses[9] = CONTRACT_DEBTCACHE;\\n        newAddresses[10] = CONTRACT_COLLATERALMANAGER;\\n        newAddresses[11] = CONTRACT_SYNTHREDEEMER;\\n        return combineArrays(existingAddresses, newAddresses);\\n    }\\n\\n    function synthetix() internal view returns (ISynthetix) {\\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\\n    }\\n\\n    function exchanger() internal view returns (IExchanger) {\\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\\n    }\\n\\n    function exchangeRates() internal view returns (IExchangeRates) {\\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\\n    }\\n\\n    function synthetixState() internal view returns (ISynthetixState) {\\n        return ISynthetixState(requireAndGetAddress(CONTRACT_SYNTHETIXSTATE));\\n    }\\n\\n    function feePool() internal view returns (IFeePool) {\\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\\n    }\\n\\n    function liquidations() internal view returns (ILiquidations) {\\n        return ILiquidations(requireAndGetAddress(CONTRACT_LIQUIDATIONS));\\n    }\\n\\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\\n    }\\n\\n    function collateralManager() internal view returns (ICollateralManager) {\\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\\n    }\\n\\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\\n    }\\n\\n    function synthetixEscrow() internal view returns (IHasBalance) {\\n        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));\\n    }\\n\\n    function debtCache() internal view returns (IIssuerInternalDebtCache) {\\n        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));\\n    }\\n\\n    function synthRedeemer() internal view returns (ISynthRedeemer) {\\n        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));\\n    }\\n\\n    function issuanceRatio() external view returns (uint) {\\n        return getIssuanceRatio();\\n    }\\n\\n    function _availableCurrencyKeysWithOptionalSNX(bool withSNX) internal view returns (bytes32[] memory) {\\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length + (withSNX ? 1 : 0));\\n\\n        for (uint i = 0; i < availableSynths.length; i++) {\\n            currencyKeys[i] = synthsByAddress[address(availableSynths[i])];\\n        }\\n\\n        if (withSNX) {\\n            currencyKeys[availableSynths.length] = SNX;\\n        }\\n\\n        return currencyKeys;\\n    }\\n\\n    // Returns the total value of the debt pool in currency specified by `currencyKey`.\\n    // To return only the SNX-backed debt, set `excludeCollateral` to true.\\n    function _totalIssuedSynths(bytes32 currencyKey, bool excludeCollateral)\\n        internal\\n        view\\n        returns (uint totalIssued, bool anyRateIsInvalid)\\n    {\\n        (uint debt, , bool cacheIsInvalid, bool cacheIsStale) = debtCache().cacheInfo();\\n        anyRateIsInvalid = cacheIsInvalid || cacheIsStale;\\n\\n        IExchangeRates exRates = exchangeRates();\\n\\n        // Add total issued synths from non snx collateral back into the total if not excluded\\n        if (!excludeCollateral) {\\n            (uint nonSnxDebt, bool invalid) = debtCache().totalNonSnxBackedDebt();\\n            debt = debt.add(nonSnxDebt);\\n            anyRateIsInvalid = anyRateIsInvalid || invalid;\\n        }\\n\\n        if (currencyKey == sUSD) {\\n            return (debt, anyRateIsInvalid);\\n        }\\n\\n        (uint currencyRate, bool currencyRateInvalid) = exRates.rateAndInvalid(currencyKey);\\n        return (debt.divideDecimalRound(currencyRate), anyRateIsInvalid || currencyRateInvalid);\\n    }\\n\\n    function _debtBalanceOfAndTotalDebt(address _issuer, bytes32 currencyKey)\\n        internal\\n        view\\n        returns (\\n            uint debtBalance,\\n            uint totalSystemValue,\\n            bool anyRateIsInvalid\\n        )\\n    {\\n        ISynthetixState state = synthetixState();\\n\\n        // What was their initial debt ownership?\\n        (uint initialDebtOwnership, uint debtEntryIndex) = state.issuanceData(_issuer);\\n\\n        // What's the total value of the system excluding ETH backed synths in their requested currency?\\n        (totalSystemValue, anyRateIsInvalid) = _totalIssuedSynths(currencyKey, true);\\n\\n        // If it's zero, they haven't issued, and they have no debt.\\n        // Note: it's more gas intensive to put this check here rather than before _totalIssuedSynths\\n        // if they have 0 SNX, but it's a necessary trade-off\\n        if (initialDebtOwnership == 0) return (0, totalSystemValue, anyRateIsInvalid);\\n\\n        // Figure out the global debt percentage delta from when they entered the system.\\n        // This is a high precision integer of 27 (1e27) decimals.\\n        uint currentDebtOwnership =\\n            state\\n                .lastDebtLedgerEntry()\\n                .divideDecimalRoundPrecise(state.debtLedger(debtEntryIndex))\\n                .multiplyDecimalRoundPrecise(initialDebtOwnership);\\n\\n        // Their debt balance is their portion of the total system value.\\n        uint highPrecisionBalance =\\n            totalSystemValue.decimalToPreciseDecimal().multiplyDecimalRoundPrecise(currentDebtOwnership);\\n\\n        // Convert back into 18 decimals (1e18)\\n        debtBalance = highPrecisionBalance.preciseDecimalToDecimal();\\n    }\\n\\n    function _canBurnSynths(address account) internal view returns (bool) {\\n        return now >= _lastIssueEvent(account).add(getMinimumStakeTime());\\n    }\\n\\n    function _lastIssueEvent(address account) internal view returns (uint) {\\n        //  Get the timestamp of the last issue this account made\\n        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));\\n    }\\n\\n    function _remainingIssuableSynths(address _issuer)\\n        internal\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt,\\n            bool anyRateIsInvalid\\n        )\\n    {\\n        (alreadyIssued, totalSystemDebt, anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_issuer, sUSD);\\n        (uint issuable, bool isInvalid) = _maxIssuableSynths(_issuer);\\n        maxIssuable = issuable;\\n        anyRateIsInvalid = anyRateIsInvalid || isInvalid;\\n\\n        if (alreadyIssued >= maxIssuable) {\\n            maxIssuable = 0;\\n        } else {\\n            maxIssuable = maxIssuable.sub(alreadyIssued);\\n        }\\n    }\\n\\n    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {\\n        return amount.multiplyDecimalRound(snxRate);\\n    }\\n\\n    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {\\n        return amount.divideDecimalRound(snxRate);\\n    }\\n\\n    function _maxIssuableSynths(address _issuer) internal view returns (uint, bool) {\\n        // What is the value of their SNX balance in sUSD\\n        (uint snxRate, bool isInvalid) = exchangeRates().rateAndInvalid(SNX);\\n        uint destinationValue = _snxToUSD(_collateral(_issuer), snxRate);\\n\\n        // They're allowed to issue up to issuanceRatio of that value\\n        return (destinationValue.multiplyDecimal(getIssuanceRatio()), isInvalid);\\n    }\\n\\n    function _collateralisationRatio(address _issuer) internal view returns (uint, bool) {\\n        uint totalOwnedSynthetix = _collateral(_issuer);\\n\\n        (uint debtBalance, , bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_issuer, SNX);\\n\\n        // it's more gas intensive to put this check here if they have 0 SNX, but it complies with the interface\\n        if (totalOwnedSynthetix == 0) return (0, anyRateIsInvalid);\\n\\n        return (debtBalance.divideDecimalRound(totalOwnedSynthetix), anyRateIsInvalid);\\n    }\\n\\n    function _collateral(address account) internal view returns (uint) {\\n        uint balance = IERC20(address(synthetix())).balanceOf(account);\\n\\n        if (address(synthetixEscrow()) != address(0)) {\\n            balance = balance.add(synthetixEscrow().balanceOf(account));\\n        }\\n\\n        if (address(rewardEscrowV2()) != address(0)) {\\n            balance = balance.add(rewardEscrowV2().balanceOf(account));\\n        }\\n\\n        return balance;\\n    }\\n\\n    function minimumStakeTime() external view returns (uint) {\\n        return getMinimumStakeTime();\\n    }\\n\\n    function canBurnSynths(address account) external view returns (bool) {\\n        return _canBurnSynths(account);\\n    }\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory) {\\n        return _availableCurrencyKeysWithOptionalSNX(false);\\n    }\\n\\n    function availableSynthCount() external view returns (uint) {\\n        return availableSynths.length;\\n    }\\n\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid) {\\n        (, anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(_availableCurrencyKeysWithOptionalSNX(true));\\n    }\\n\\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint totalIssued) {\\n        (totalIssued, ) = _totalIssuedSynths(currencyKey, excludeOtherCollateral);\\n    }\\n\\n    function lastIssueEvent(address account) external view returns (uint) {\\n        return _lastIssueEvent(account);\\n    }\\n\\n    function collateralisationRatio(address _issuer) external view returns (uint cratio) {\\n        (cratio, ) = _collateralisationRatio(_issuer);\\n    }\\n\\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\\n        external\\n        view\\n        returns (uint cratio, bool anyRateIsInvalid)\\n    {\\n        return _collateralisationRatio(_issuer);\\n    }\\n\\n    function collateral(address account) external view returns (uint) {\\n        return _collateral(account);\\n    }\\n\\n    function debtBalanceOf(address _issuer, bytes32 currencyKey) external view returns (uint debtBalance) {\\n        ISynthetixState state = synthetixState();\\n\\n        // What was their initial debt ownership?\\n        (uint initialDebtOwnership, ) = state.issuanceData(_issuer);\\n\\n        // If it's zero, they haven't issued, and they have no debt.\\n        if (initialDebtOwnership == 0) return 0;\\n\\n        (debtBalance, , ) = _debtBalanceOfAndTotalDebt(_issuer, currencyKey);\\n    }\\n\\n    function remainingIssuableSynths(address _issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        )\\n    {\\n        (maxIssuable, alreadyIssued, totalSystemDebt, ) = _remainingIssuableSynths(_issuer);\\n    }\\n\\n    function maxIssuableSynths(address _issuer) external view returns (uint) {\\n        (uint maxIssuable, ) = _maxIssuableSynths(_issuer);\\n        return maxIssuable;\\n    }\\n\\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\\n        external\\n        view\\n        returns (uint transferable, bool anyRateIsInvalid)\\n    {\\n        // How many SNX do they have, excluding escrow?\\n        // Note: We're excluding escrow here because we're interested in their transferable amount\\n        // and escrowed SNX are not transferable.\\n\\n        // How many of those will be locked by the amount they've issued?\\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\\n        // The locked synthetix value can exceed their balance.\\n        uint debtBalance;\\n        (debtBalance, , anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(account, SNX);\\n        uint lockedSynthetixValue = debtBalance.divideDecimalRound(getIssuanceRatio());\\n\\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\\n        if (lockedSynthetixValue >= balance) {\\n            transferable = 0;\\n        } else {\\n            transferable = balance.sub(lockedSynthetixValue);\\n        }\\n    }\\n\\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory) {\\n        uint numKeys = currencyKeys.length;\\n        ISynth[] memory addresses = new ISynth[](numKeys);\\n\\n        for (uint i = 0; i < numKeys; i++) {\\n            addresses[i] = synths[currencyKeys[i]];\\n        }\\n\\n        return addresses;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function _addSynth(ISynth synth) internal {\\n        bytes32 currencyKey = synth.currencyKey();\\n        require(synths[currencyKey] == ISynth(0), \\\"Synth exists\\\");\\n        require(synthsByAddress[address(synth)] == bytes32(0), \\\"Synth address already exists\\\");\\n\\n        availableSynths.push(synth);\\n        synths[currencyKey] = synth;\\n        synthsByAddress[address(synth)] = currencyKey;\\n\\n        emit SynthAdded(currencyKey, address(synth));\\n    }\\n\\n    function addSynth(ISynth synth) external onlyOwner {\\n        _addSynth(synth);\\n        // Invalidate the cache to force a snapshot to be recomputed. If a synth were to be added\\n        // back to the system and it still somehow had cached debt, this would force the value to be\\n        // updated.\\n        debtCache().updateDebtCacheValidity(true);\\n    }\\n\\n    function addSynths(ISynth[] calldata synthsToAdd) external onlyOwner {\\n        uint numSynths = synthsToAdd.length;\\n        for (uint i = 0; i < numSynths; i++) {\\n            _addSynth(synthsToAdd[i]);\\n        }\\n\\n        // Invalidate the cache to force a snapshot to be recomputed.\\n        debtCache().updateDebtCacheValidity(true);\\n    }\\n\\n    function _removeSynth(bytes32 currencyKey) internal {\\n        address synthToRemove = address(synths[currencyKey]);\\n        require(synthToRemove != address(0), \\\"Synth does not exist\\\");\\n        require(currencyKey != sUSD, \\\"Cannot remove synth\\\");\\n\\n        uint synthSupply = IERC20(synthToRemove).totalSupply();\\n\\n        if (synthSupply > 0) {\\n            (uint amountOfsUSD, uint rateToRedeem, ) =\\n                exchangeRates().effectiveValueAndRates(currencyKey, synthSupply, \\\"sUSD\\\");\\n            require(rateToRedeem > 0, \\\"Cannot remove synth to redeem without rate\\\");\\n            ISynthRedeemer _synthRedeemer = synthRedeemer();\\n            synths[sUSD].issue(address(_synthRedeemer), amountOfsUSD);\\n            // ensure the debt cache is aware of the new sUSD issued\\n            debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amountOfsUSD));\\n            _synthRedeemer.deprecate(IERC20(address(Proxyable(address(synthToRemove)).proxy())), rateToRedeem);\\n        }\\n\\n        // Remove the synth from the availableSynths array.\\n        for (uint i = 0; i < availableSynths.length; i++) {\\n            if (address(availableSynths[i]) == synthToRemove) {\\n                delete availableSynths[i];\\n\\n                // Copy the last synth into the place of the one we just deleted\\n                // If there's only one synth, this is synths[0] = synths[0].\\n                // If we're deleting the last one, it's also a NOOP in the same way.\\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\\n\\n                // Decrease the size of the array by one.\\n                availableSynths.length--;\\n\\n                break;\\n            }\\n        }\\n\\n        // And remove it from the synths mapping\\n        delete synthsByAddress[synthToRemove];\\n        delete synths[currencyKey];\\n\\n        emit SynthRemoved(currencyKey, synthToRemove);\\n    }\\n\\n    function removeSynth(bytes32 currencyKey) external onlyOwner {\\n        // Remove its contribution from the debt pool snapshot, and\\n        // invalidate the cache to force a new snapshot.\\n        IIssuerInternalDebtCache cache = debtCache();\\n        cache.updateCachedSynthDebtWithRate(currencyKey, 0);\\n        cache.updateDebtCacheValidity(true);\\n\\n        _removeSynth(currencyKey);\\n    }\\n\\n    function removeSynths(bytes32[] calldata currencyKeys) external onlyOwner {\\n        uint numKeys = currencyKeys.length;\\n\\n        // Remove their contributions from the debt pool snapshot, and\\n        // invalidate the cache to force a new snapshot.\\n        IIssuerInternalDebtCache cache = debtCache();\\n        uint[] memory zeroRates = new uint[](numKeys);\\n        cache.updateCachedSynthDebtsWithRates(currencyKeys, zeroRates);\\n        cache.updateDebtCacheValidity(true);\\n\\n        for (uint i = 0; i < numKeys; i++) {\\n            _removeSynth(currencyKeys[i]);\\n        }\\n    }\\n\\n    function issueSynths(address from, uint amount) external onlySynthetix {\\n        _issueSynths(from, amount, false);\\n    }\\n\\n    function issueMaxSynths(address from) external onlySynthetix {\\n        _issueSynths(from, 0, true);\\n    }\\n\\n    function issueSynthsOnBehalf(\\n        address issueForAddress,\\n        address from,\\n        uint amount\\n    ) external onlySynthetix {\\n        _requireCanIssueOnBehalf(issueForAddress, from);\\n        _issueSynths(issueForAddress, amount, false);\\n    }\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {\\n        _requireCanIssueOnBehalf(issueForAddress, from);\\n        _issueSynths(issueForAddress, 0, true);\\n    }\\n\\n    function burnSynths(address from, uint amount) external onlySynthetix {\\n        _voluntaryBurnSynths(from, amount, false);\\n    }\\n\\n    function burnSynthsOnBehalf(\\n        address burnForAddress,\\n        address from,\\n        uint amount\\n    ) external onlySynthetix {\\n        _requireCanBurnOnBehalf(burnForAddress, from);\\n        _voluntaryBurnSynths(burnForAddress, amount, false);\\n    }\\n\\n    function burnSynthsToTarget(address from) external onlySynthetix {\\n        _voluntaryBurnSynths(from, 0, true);\\n    }\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {\\n        _requireCanBurnOnBehalf(burnForAddress, from);\\n        _voluntaryBurnSynths(burnForAddress, 0, true);\\n    }\\n\\n    function burnForRedemption(\\n        address deprecatedSynthProxy,\\n        address account,\\n        uint balance\\n    ) external onlySynthRedeemer {\\n        ISynth(IProxy(deprecatedSynthProxy).target()).burn(account, balance);\\n    }\\n\\n    function liquidateDelinquentAccount(\\n        address account,\\n        uint susdAmount,\\n        address liquidator\\n    ) external onlySynthetix returns (uint totalRedeemed, uint amountToLiquidate) {\\n        // Ensure waitingPeriod and sUSD balance is settled as burning impacts the size of debt pool\\n        require(!exchanger().hasWaitingPeriodOrSettlementOwing(liquidator, sUSD), \\\"sUSD needs to be settled\\\");\\n\\n        // Check account is liquidation open\\n        require(liquidations().isOpenForLiquidation(account), \\\"Account not open for liquidation\\\");\\n\\n        // require liquidator has enough sUSD\\n        require(IERC20(address(synths[sUSD])).balanceOf(liquidator) >= susdAmount, \\\"Not enough sUSD\\\");\\n\\n        uint liquidationPenalty = liquidations().liquidationPenalty();\\n\\n        // What is their debt in sUSD?\\n        (uint debtBalance, uint totalDebtIssued, bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(account, sUSD);\\n        (uint snxRate, bool snxRateInvalid) = exchangeRates().rateAndInvalid(SNX);\\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\\n\\n        uint collateralForAccount = _collateral(account);\\n        uint amountToFixRatio =\\n            liquidations().calculateAmountToFixCollateral(debtBalance, _snxToUSD(collateralForAccount, snxRate));\\n\\n        // Cap amount to liquidate to repair collateral ratio based on issuance ratio\\n        amountToLiquidate = amountToFixRatio < susdAmount ? amountToFixRatio : susdAmount;\\n\\n        // what's the equivalent amount of snx for the amountToLiquidate?\\n        uint snxRedeemed = _usdToSnx(amountToLiquidate, snxRate);\\n\\n        // Add penalty\\n        totalRedeemed = snxRedeemed.multiplyDecimal(SafeDecimalMath.unit().add(liquidationPenalty));\\n\\n        // if total SNX to redeem is greater than account's collateral\\n        // account is under collateralised, liquidate all collateral and reduce sUSD to burn\\n        if (totalRedeemed > collateralForAccount) {\\n            // set totalRedeemed to all transferable collateral\\n            totalRedeemed = collateralForAccount;\\n\\n            // whats the equivalent sUSD to burn for all collateral less penalty\\n            amountToLiquidate = _snxToUSD(\\n                collateralForAccount.divideDecimal(SafeDecimalMath.unit().add(liquidationPenalty)),\\n                snxRate\\n            );\\n        }\\n\\n        // burn sUSD from messageSender (liquidator) and reduce account's debt\\n        _burnSynths(account, liquidator, amountToLiquidate, debtBalance, totalDebtIssued);\\n\\n        // Remove liquidation flag if amount liquidated fixes ratio\\n        if (amountToLiquidate == amountToFixRatio) {\\n            // Remove liquidation\\n            liquidations().removeAccountInLiquidation(account);\\n        }\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function _requireRatesNotInvalid(bool anyRateIsInvalid) internal pure {\\n        require(!anyRateIsInvalid, \\\"A synth or SNX rate is invalid\\\");\\n    }\\n\\n    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {\\n        require(delegateApprovals().canIssueFor(issueForAddress, from), \\\"Not approved to act on behalf\\\");\\n    }\\n\\n    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {\\n        require(delegateApprovals().canBurnFor(burnForAddress, from), \\\"Not approved to act on behalf\\\");\\n    }\\n\\n    function _issueSynths(\\n        address from,\\n        uint amount,\\n        bool issueMax\\n    ) internal {\\n        (uint maxIssuable, uint existingDebt, uint totalSystemDebt, bool anyRateIsInvalid) = _remainingIssuableSynths(from);\\n        _requireRatesNotInvalid(anyRateIsInvalid);\\n\\n        if (!issueMax) {\\n            require(amount <= maxIssuable, \\\"Amount too large\\\");\\n        } else {\\n            amount = maxIssuable;\\n        }\\n\\n        // Keep track of the debt they're about to create\\n        _addToDebtRegister(from, amount, existingDebt, totalSystemDebt);\\n\\n        // record issue timestamp\\n        _setLastIssueEvent(from);\\n\\n        // Create their synths\\n        synths[sUSD].issue(from, amount);\\n\\n        // Account for the issued debt in the cache\\n        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount));\\n\\n        // Store their locked SNX amount to determine their fee % for the period\\n        _appendAccountIssuanceRecord(from);\\n    }\\n\\n    function _burnSynths(\\n        address debtAccount,\\n        address burnAccount,\\n        uint amount,\\n        uint existingDebt,\\n        uint totalDebtIssued\\n    ) internal returns (uint amountBurnt) {\\n        // liquidation requires sUSD to be already settled / not in waiting period\\n\\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\\n        // clear their debt and leave them be.\\n        amountBurnt = existingDebt < amount ? existingDebt : amount;\\n\\n        // Remove liquidated debt from the ledger\\n        _removeFromDebtRegister(debtAccount, amountBurnt, existingDebt, totalDebtIssued);\\n\\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\\n        synths[sUSD].burn(burnAccount, amountBurnt);\\n\\n        // Account for the burnt debt in the cache.\\n        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amountBurnt));\\n\\n        // Store their debtRatio against a fee period to determine their fee/rewards % for the period\\n        _appendAccountIssuanceRecord(debtAccount);\\n    }\\n\\n    // If burning to target, `amount` is ignored, and the correct quantity of sUSD is burnt to reach the target\\n    // c-ratio, allowing fees to be claimed. In this case, pending settlements will be skipped as the user\\n    // will still have debt remaining after reaching their target.\\n    function _voluntaryBurnSynths(\\n        address from,\\n        uint amount,\\n        bool burnToTarget\\n    ) internal {\\n        if (!burnToTarget) {\\n            // If not burning to target, then burning requires that the minimum stake time has elapsed.\\n            require(_canBurnSynths(from), \\\"Minimum stake time not reached\\\");\\n            // First settle anything pending into sUSD as burning or issuing impacts the size of the debt pool\\n            (, uint refunded, uint numEntriesSettled) = exchanger().settle(from, sUSD);\\n            if (numEntriesSettled > 0) {\\n                amount = exchanger().calculateAmountAfterSettlement(from, sUSD, amount, refunded);\\n            }\\n        }\\n\\n        (uint existingDebt, uint totalSystemValue, bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(from, sUSD);\\n        (uint maxIssuableSynthsForAccount, bool snxRateInvalid) = _maxIssuableSynths(from);\\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\\n        require(existingDebt > 0, \\\"No debt to forgive\\\");\\n\\n        if (burnToTarget) {\\n            amount = existingDebt.sub(maxIssuableSynthsForAccount);\\n        }\\n\\n        uint amountBurnt = _burnSynths(from, from, amount, existingDebt, totalSystemValue);\\n\\n        // Check and remove liquidation if existingDebt after burning is <= maxIssuableSynths\\n        // Issuance ratio is fixed so should remove any liquidations\\n        if (existingDebt.sub(amountBurnt) <= maxIssuableSynthsForAccount) {\\n            liquidations().removeAccountInLiquidation(from);\\n        }\\n    }\\n\\n    function _setLastIssueEvent(address account) internal {\\n        // Set the timestamp of the last issueSynths\\n        flexibleStorage().setUIntValue(\\n            CONTRACT_NAME,\\n            keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _appendAccountIssuanceRecord(address from) internal {\\n        uint initialDebtOwnership;\\n        uint debtEntryIndex;\\n        (initialDebtOwnership, debtEntryIndex) = synthetixState().issuanceData(from);\\n        feePool().appendAccountIssuanceRecord(from, initialDebtOwnership, debtEntryIndex);\\n    }\\n\\n    function _addToDebtRegister(\\n        address from,\\n        uint amount,\\n        uint existingDebt,\\n        uint totalDebtIssued\\n    ) internal {\\n        ISynthetixState state = synthetixState();\\n\\n        // What will the new total be including the new value?\\n        uint newTotalDebtIssued = amount.add(totalDebtIssued);\\n\\n        // What is their percentage (as a high precision int) of the total debt?\\n        uint debtPercentage = amount.divideDecimalRoundPrecise(newTotalDebtIssued);\\n\\n        // And what effect does this percentage change have on the global debt holding of other issuers?\\n        // The delta specifically needs to not take into account any existing debt as it's already\\n        // accounted for in the delta from when they issued previously.\\n        // The delta is a high precision integer.\\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\\n\\n        // And what does their debt ownership look like including this previous stake?\\n        if (existingDebt > 0) {\\n            debtPercentage = amount.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\\n        } else {\\n            // If they have no debt, they're a new issuer; record this.\\n            state.incrementTotalIssuerCount();\\n        }\\n\\n        // Save the debt entry parameters\\n        state.setCurrentIssuanceData(from, debtPercentage);\\n\\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\\n        if (state.debtLedgerLength() > 0) {\\n            state.appendDebtLedgerValue(state.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));\\n        } else {\\n            state.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());\\n        }\\n    }\\n\\n    function _removeFromDebtRegister(\\n        address from,\\n        uint debtToRemove,\\n        uint existingDebt,\\n        uint totalDebtIssued\\n    ) internal {\\n        ISynthetixState state = synthetixState();\\n\\n        // What will the new total after taking out the withdrawn amount\\n        uint newTotalDebtIssued = totalDebtIssued.sub(debtToRemove);\\n\\n        uint delta = 0;\\n\\n        // What will the debt delta be if there is any debt left?\\n        // Set delta to 0 if no more debt left in system after user\\n        if (newTotalDebtIssued > 0) {\\n            // What is the percentage of the withdrawn debt (as a high precision int) of the total debt after?\\n            uint debtPercentage = debtToRemove.divideDecimalRoundPrecise(newTotalDebtIssued);\\n\\n            // And what effect does this percentage change have on the global debt holding of other issuers?\\n            // The delta specifically needs to not take into account any existing debt as it's already\\n            // accounted for in the delta from when they issued previously.\\n            delta = SafeDecimalMath.preciseUnit().add(debtPercentage);\\n        }\\n\\n        // Are they exiting the system, or are they just decreasing their debt position?\\n        if (debtToRemove == existingDebt) {\\n            state.setCurrentIssuanceData(from, 0);\\n            state.decrementTotalIssuerCount();\\n        } else {\\n            // What percentage of the debt will they be left with?\\n            uint newDebt = existingDebt.sub(debtToRemove);\\n            uint newDebtPercentage = newDebt.divideDecimalRoundPrecise(newTotalDebtIssued);\\n\\n            // Store the debt percentage and debt ledger as high precision integers\\n            state.setCurrentIssuanceData(from, newDebtPercentage);\\n        }\\n\\n        // Update our cumulative ledger. This is also a high precision integer.\\n        state.appendDebtLedgerValue(state.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    function _onlySynthetix() internal view {\\n        require(msg.sender == address(synthetix()), \\\"Issuer: Only the synthetix contract can perform this action\\\");\\n    }\\n\\n    modifier onlySynthetix() {\\n        _onlySynthetix(); // Use an internal function to save code size.\\n        _;\\n    }\\n\\n    function _onlySynthRedeemer() internal view {\\n        require(msg.sender == address(synthRedeemer()), \\\"Issuer: Only the SynthRedeemer contract can perform this action\\\");\\n    }\\n\\n    modifier onlySynthRedeemer() {\\n        _onlySynthRedeemer();\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event SynthAdded(bytes32 currencyKey, address synth);\\n    event SynthRemoved(bytes32 currencyKey, address synth);\\n}\\n\\n\\ninterface ISynthetixNamedContract {\\n    // solhint-disable func-name-mixedcase\\n    function CONTRACT_NAME() external view returns (bytes32);\\n}\\n\\n// solhint-disable contract-name-camelcase\\ncontract Migration_Kaus is BaseMigration {\\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\\n\\n    // ----------------------------\\n    // EXISTING SYNTHETIX CONTRACTS\\n    // ----------------------------\\n\\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\\n    // https://etherscan.io/address/0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82\\n    SynthetixState public constant synthetixstate_i = SynthetixState(0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82);\\n    // https://etherscan.io/address/0xF67998902EBc37d885ad310C2430C822Ca981E1E\\n    Issuer public constant issuer_i = Issuer(0xF67998902EBc37d885ad310C2430C822Ca981E1E);\\n\\n    // ----------------------------------\\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\\n    // ----------------------------------\\n\\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\\n    address public constant new_ProxySynthetix_contract = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\\n    // https://etherscan.io/address/0x08118E04F58d7863b4fCF1de0e07c83a2541b89e\\n    address public constant new_DebtCache_contract = 0x08118E04F58d7863b4fCF1de0e07c83a2541b89e;\\n    // https://etherscan.io/address/0xF67998902EBc37d885ad310C2430C822Ca981E1E\\n    address public constant new_Issuer_contract = 0xF67998902EBc37d885ad310C2430C822Ca981E1E;\\n    // https://etherscan.io/address/0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\\n    address public constant new_ProxysUSD_contract = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n\\n    constructor() public BaseMigration(OWNER) {}\\n\\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\\n        contracts = new address[](3);\\n        contracts[0] = address(addressresolver_i);\\n        contracts[1] = address(synthetixstate_i);\\n        contracts[2] = address(issuer_i);\\n    }\\n\\n    function migrate(address currentOwner) external onlyDeployer {\\n        require(owner == currentOwner, \\\"Only the assigned owner can be re-assigned when complete\\\");\\n\\n        require(\\n            ISynthetixNamedContract(new_DebtCache_contract).CONTRACT_NAME() == \\\"DebtCache\\\",\\n            \\\"Invalid contract supplied for DebtCache\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == \\\"Issuer\\\",\\n            \\\"Invalid contract supplied for Issuer\\\"\\n        );\\n\\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\\n        acceptAll();\\n\\n        // MIGRATION\\n        // Import all new contracts into the address resolver;\\n        addressresolver_importAddresses_0();\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\\n        addressresolver_rebuildCaches_1();\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\\n        addressresolver_rebuildCaches_2();\\n        // Ensure that Synthetix can write to its State contract;\\n        synthetixstate_i.setAssociatedContract(new_Issuer_contract);\\n        // Add synths to the Issuer contract - batch 1;\\n        issuer_addSynths_6();\\n\\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\\n        nominateAll();\\n    }\\n\\n    function acceptAll() internal {\\n        address[] memory contracts = contractsRequiringOwnership();\\n        for (uint i = 0; i < contracts.length; i++) {\\n            Owned(contracts[i]).acceptOwnership();\\n        }\\n    }\\n\\n    function nominateAll() internal {\\n        address[] memory contracts = contractsRequiringOwnership();\\n        for (uint i = 0; i < contracts.length; i++) {\\n            returnOwnership(contracts[i]);\\n        }\\n    }\\n\\n    function addressresolver_importAddresses_0() internal {\\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);\\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\\\"ProxySynthetix\\\");\\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\\\"DebtCache\\\");\\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\\\"Issuer\\\");\\n        addressresolver_importAddresses_names_0_0[3] = bytes32(\\\"ProxysUSD\\\");\\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);\\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_ProxySynthetix_contract);\\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_DebtCache_contract);\\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_Issuer_contract);\\n        addressresolver_importAddresses_destinations_0_1[3] = address(new_ProxysUSD_contract);\\n        addressresolver_i.importAddresses(\\n            addressresolver_importAddresses_names_0_0,\\n            addressresolver_importAddresses_destinations_0_1\\n        );\\n    }\\n\\n    function addressresolver_rebuildCaches_1() internal {\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0x7634F2A1741a683ccda37Dce864c187F990D7B4b);\\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(new_Issuer_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);\\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(0x510adfDF6E7554C571b7Cd9305Ce91473610015e);\\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0x54f25546260C7539088982bcF4b7dC8EDEF19f21);\\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(new_DebtCache_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0xCd9D4988C0AE61887B075bA77f08cbFAd2b65068);\\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0xe533139Af961c9747356D947838c98451015e234);\\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b);\\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0xC61b352fCc311Ae6B0301459A970150005e74b3E);\\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0x388fD1A8a7d36e03eFA1ab100a1c5159a3A3d427);\\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(0x37B648a07476F4941D3D647f81118AFd55fa8a04);\\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(0xEF285D339c91aDf1dD7DE0aEAa6250805FD68258);\\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(0xcf9bB94b5d65589039607BA66e3DAC686d3eFf01);\\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(0xCeC4e038371d32212C6Dcdf36Fdbcb6F8a34C6d8);\\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9);\\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6);\\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(0xcd980Fc5CcdAe62B18A52b83eC64200121A929db);\\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(0xC22e51FA362654ea453B4018B616ef6f6ab3b779);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\\n    }\\n\\n    function addressresolver_rebuildCaches_2() internal {\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](5);\\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0xaB38249f4f56Ef868F6b5E01D9cFa26B952c1270);\\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(0xfD0435A588BF5c5a6974BA19Fa627b772833d4eb);\\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0x46A7Af405093B27DA6DeF193C508Bd9240A255FA);\\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\\n    }\\n\\n    function issuer_addSynths_6() internal {\\n        ISynth[] memory issuer_addSynths_synthsToAdd_6_0 = new ISynth[](14);\\n        issuer_addSynths_synthsToAdd_6_0[0] = ISynth(0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b);\\n        issuer_addSynths_synthsToAdd_6_0[1] = ISynth(0xC61b352fCc311Ae6B0301459A970150005e74b3E);\\n        issuer_addSynths_synthsToAdd_6_0[2] = ISynth(0x388fD1A8a7d36e03eFA1ab100a1c5159a3A3d427);\\n        issuer_addSynths_synthsToAdd_6_0[3] = ISynth(0x37B648a07476F4941D3D647f81118AFd55fa8a04);\\n        issuer_addSynths_synthsToAdd_6_0[4] = ISynth(0xEF285D339c91aDf1dD7DE0aEAa6250805FD68258);\\n        issuer_addSynths_synthsToAdd_6_0[5] = ISynth(0xcf9bB94b5d65589039607BA66e3DAC686d3eFf01);\\n        issuer_addSynths_synthsToAdd_6_0[6] = ISynth(0xCeC4e038371d32212C6Dcdf36Fdbcb6F8a34C6d8);\\n        issuer_addSynths_synthsToAdd_6_0[7] = ISynth(0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9);\\n        issuer_addSynths_synthsToAdd_6_0[8] = ISynth(0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6);\\n        issuer_addSynths_synthsToAdd_6_0[9] = ISynth(0xcd980Fc5CcdAe62B18A52b83eC64200121A929db);\\n        issuer_addSynths_synthsToAdd_6_0[10] = ISynth(0xC22e51FA362654ea453B4018B616ef6f6ab3b779);\\n        issuer_addSynths_synthsToAdd_6_0[11] = ISynth(0xaB38249f4f56Ef868F6b5E01D9cFa26B952c1270);\\n        issuer_addSynths_synthsToAdd_6_0[12] = ISynth(0xfD0435A588BF5c5a6974BA19Fa627b772833d4eb);\\n        issuer_addSynths_synthsToAdd_6_0[13] = ISynth(0x46A7Af405093B27DA6DeF193C508Bd9240A255FA);\\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_6_0);\\n    }\\n}\\n\\n    \"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer_i\",\"outputs\":[{\"internalType\":\"contract Issuer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_DebtCache_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Issuer_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_ProxySynthetix_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_ProxysUSD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthetixstate_i\",\"outputs\":[{\"internalType\":\"contract SynthetixState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Migration_Kaus","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}