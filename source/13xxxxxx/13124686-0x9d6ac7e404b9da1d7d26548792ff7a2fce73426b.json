{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.0;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    mapping(uint256 => address) private _owners;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        return \"\";\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n    uint256[] private _allTokens;\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract FriendlyFractals is Ownable, ERC721(\"Friendly Fractals\", \"FRFRAC\"), ERC721Enumerable, ReentrancyGuard {\r\n\tuint256 public curId = 0;\r\n\tuint256 public mintPrice = 0;\r\n\tmapping(uint256 => uint256) public tokenSeed;\r\n\r\n\tbytes private uriHead1 = \"data:application/json;charset=utf-8,%7B%22name%22%3A%20%22Friendly%20Fractals%22%2C%22description%22%3A%20%22Fully%20on-chain%20generative%20fractal%20patterns%20based%20on%20the%20dragon%20curve.%22%2C%22image%22%3A%20%22data%3Aimage%2Fsvg%2Bxml%3Bcharset%3Dutf-8%2C%3Csvg%20width%3D'100%25'%20height%3D'100%25'%20viewBox%3D'0%200%20100000%20100000'%20style%3D'stroke-width%3A400%3B%20\";\r\n\tbytes private uriHead2 = \"%20background-color%3Argb(50%2C50%2C50)'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E\";\r\n\tbytes private uriTail = \"%3C%2Fsvg%3E%22%7D\";\r\n\r\n    constructor() {\r\n        mint(); // tokenId 0 for deployer\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal override(ERC721, ERC721Enumerable) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC721, ERC721Enumerable)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function mint() payable public nonReentrant {\r\n    \trequire(curId < 300, \"FriendlyFractals: Max 300 tokens\");\r\n    \trequire(msg.value >= mintPrice, \"FriendlyFractals: Insufficient value to mint\");\r\n\r\n    \t_safeMint(_msgSender(), curId);\r\n    \t// generate random seed\r\n    \ttokenSeed[curId] = uint256(keccak256(abi.encodePacked(curId, block.timestamp, blockhash(block.number - 1))));\r\n    \tcurId += 1;\r\n\r\n    \t// refund value above mint price\r\n    \tif (msg.value > mintPrice) {\r\n\t    \taddress payable refundee = payable(_msgSender());\r\n\t    \trefundee.transfer(msg.value - mintPrice);\r\n    \t}\r\n\r\n    \tmintPrice += 1e16;\r\n    }\r\n\r\n    function claim() public onlyOwner {\r\n    \taddress payable sendee = payable(owner());\r\n    \tsendee.transfer(address(this).balance);\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return tokenURI(0);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        return tokenSVGFromSeed(tokenSeed[tokenId]);\r\n    }\r\n\r\n    function tokenSVGFromSeed(uint256 seed) internal view returns (string memory) {\r\n        uint256 numIterations = 8;\r\n\r\n        // space to store the string format of x1, y1, x2, y2\r\n        string[4] memory vars = [\"1000000\", \"1000000\", \"1000000\", \"1000000\"];\r\n\r\n        // constants which affect the final outcome\t\r\n        seed = uint256(keccak256(abi.encodePacked(seed)));\r\n        uint256 min_subiteration = 1 + seed % 2;\r\n\r\n        // space for all the data to compute the fractal\r\n        uint256[] memory data = new uint256[](2**(numIterations+1)-1);\r\n\r\n        data[0]= compact(seed, 0, 0, 35000, 35000, 30000, 30000);\r\n        for (uint256 i=0; i<2**numIterations-1; i++) {\r\n            //generate both children\r\n            data[2*i+1] = getChildData(data[i], true, min_subiteration);\r\n            data[2*i+2] = getChildData(data[i], false, min_subiteration);\r\n        }\r\n\r\n        // generate result string\r\n        // each line takes up to 84 characters.\r\n        bytes memory result = new bytes(84*(2**numIterations)+550);\r\n        bytes memory cur;\r\n        assembly {\r\n        \tcur := add(result, 32) //offset length header\r\n        } \r\n        uint256 totallen = 0;\r\n    \tuint256 linelen;\r\n\r\n\r\n        // add head\r\n    \t(linelen, cur) = copyString(cur, uriHead1);\r\n    \ttotallen += linelen;\r\n\r\n        (linelen, cur) = copyString(cur, getColorString(seed));\r\n    \ttotallen += linelen;\r\n\r\n    \t(linelen, cur) = copyString(cur, uriHead2);\r\n    \ttotallen += linelen;\r\n\r\n    \t// add body\r\n        for (uint256 i=2**numIterations-1; i<data.length; i++) {\r\n        \tbytes memory curLine = getCurLine(data, i, vars);\r\n        \t(linelen, cur) = copyString(cur, curLine);\r\n        \ttotallen += linelen;\r\n        }\r\n\r\n        // add tail\r\n    \t(linelen, cur) = copyString(cur, uriTail);\r\n    \ttotallen += linelen;\r\n\r\n        // reassign total length\r\n        assembly {\r\n        \tmstore(result, totallen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n\r\n    function getChildData(uint256 data, bool leftChild, uint256 min_subiteration) internal view returns (uint256) {\r\n    \tuint256 seed;\r\n    \tuint256 subiteration;\r\n    \tuint256 curtype;\r\n    \tint256 x;\r\n        int256 y;\r\n        int256 dx;\r\n        int256 dy;\r\n\r\n        (seed, curtype, subiteration, x, y, dx, dy) = expand(data);\r\n        // if subiteration 0, update type and subiteration\r\n        if (subiteration == 0) {\r\n        \tseed = uint256(keccak256(abi.encodePacked(seed)));\r\n        \tsubiteration = min_subiteration + seed % 4;\r\n\r\n\t\t\tseed = uint256(keccak256(abi.encodePacked(seed)));\r\n        \tcurtype = seed % 9;\r\n        }\r\n\r\n\t\tint256 sqrt2a = 14142;\r\n\t\tint256 sqrt2b = 10000;\r\n\r\n\t\t// rotate 45 degrees and scale by 1/sqrt(2). dx1,dy1 is for one direction of rotation, dx2,dy2 for the other\r\n        // int256 dx1 = (dx * sqrt2b / sqrt2a - dy * sqrt2b / sqrt2a ) * sqrt2b / sqrt2a;\r\n        // int256 dy1 = (dx * sqrt2b / sqrt2a + dy * sqrt2b / sqrt2a ) * sqrt2b / sqrt2a;\r\n        // int256 dx2 = (dx * sqrt2b / sqrt2a + dy * sqrt2b / sqrt2a ) * sqrt2b / sqrt2a;\r\n        // int256 dy2 =  (-dx * sqrt2b / sqrt2a + dy * sqrt2b / sqrt2a) * sqrt2b / sqrt2a;\r\n        int256 dx1;\r\n        int256 dy1;\r\n        int256 dx2;\r\n        int256 dy2;\r\n\r\n        assembly {\r\n        \tdx1 := sdiv(mul(sub(sdiv(mul(dx, sqrt2b), sqrt2a),sdiv(mul(dy, sqrt2b),sqrt2a)),sqrt2b),sqrt2a)\r\n        \tdy1 := sdiv(mul(add(sdiv(mul(dx, sqrt2b), sqrt2a),sdiv(mul(dy, sqrt2b),sqrt2a)),sqrt2b),sqrt2a)\r\n        \tdx2 := sdiv(mul(add(sdiv(mul(dx, sqrt2b), sqrt2a),sdiv(mul(dy, sqrt2b),sqrt2a)),sqrt2b),sqrt2a)\r\n        \tdy2 := sdiv(mul(add(sdiv(mul(add(1,not(dx)), sqrt2b), sqrt2a),sdiv(mul(dy, sqrt2b),sqrt2a)),sqrt2b),sqrt2a)\r\n        }\r\n\r\n\r\n        // reuse x,y,dx,dy for return. Not enough local variables\r\n        if (leftChild && (curtype == 3) || \r\n            !leftChild && (curtype == 0 || curtype == 4 || curtype == 8)) {\r\n        \tassembly {\r\n        \t\tx := add(x, dx)\r\n        \t\ty := add(y, dy)\r\n        \t}\r\n        } else if (curtype == 6 || \r\n        \t\t  !leftChild && (curtype == 1 || curtype == 3)) {\r\n        \tassembly {\r\n        \t\tx := add(x, dx1)\r\n        \t\ty := add(y, dy1)\r\n        \t}\r\n        } else if (!leftChild && (curtype == 2 || curtype == 5 || curtype == 7)) {\r\n        \tassembly {\r\n        \t\tx := add(x, dx2)\r\n        \t\ty := add(y, dy2)\r\n        \t}\r\n        }\r\n\r\n        if (leftChild && (curtype == 0 || curtype == 1 || curtype == 4 || curtype == 5 || curtype == 7) ||\r\n        \t!leftChild && (curtype == 2 || curtype == 5)) {\r\n        \tdx = dx1;\r\n        \tdy = dy1;\r\n\r\n        }  else if (leftChild && (curtype == 6) ||\r\n        \t\t\t!leftChild && (curtype == 3 || curtype == 4)) {\r\n        \tassembly {\r\n        \t\tdx := add(1, not(dx1))\r\n        \t\tdy := add(1, not(dy1))\r\n        \t}\r\n\r\n        } else if (leftChild && (curtype == 2 || curtype == 8) || \r\n        \t\t  !leftChild && (curtype == 1 || curtype == 6)) {\r\n    \t\tdx = dx2;\r\n    \t\tdy = dy2;\r\n\r\n        } else if (leftChild && (curtype == 3) || \r\n        \t\t\t!leftChild && (curtype == 0 || curtype == 7 || curtype == 8)) {\r\n        \tassembly {\r\n        \t\tdx := add(1, not(dx2))\r\n        \t\tdy := add(1, not(dy2))\r\n        \t}\r\n        } \r\n\r\n    \treturn compact(seed, curtype, subiteration-1, x, y, dx, dy);\r\n    }\r\n\r\n    // compact variables into uint256\r\n    function compact(uint256 seed, uint256 curtype, uint256 subiteration, int256 x, int256 y, int256 dx, int256 dy) internal pure returns (uint256) {\r\n    \tuint256 result = 0;\r\n    \tresult |= uint256(dy & 0xffffffff);\r\n    \tresult = result << 32;\r\n    \tresult |= uint256(dx & 0xffffffff);\r\n    \tresult = result << 32;\r\n    \tresult |= uint256(y & 0xffffffff);\r\n    \tresult = result << 32;\r\n    \tresult |= uint256(x & 0xffffffff);\r\n    \tresult = result << 32;\r\n    \tresult |= uint256(subiteration & 0xffffffff);\r\n    \tresult = result << 32;\r\n    \tresult |= uint256(curtype & 0xffffffff);\r\n    \tresult = result << 64;\r\n    \tresult |= uint256(seed & 0xffffffffffffffff);\r\n\r\n    \treturn result;\r\n    }\r\n\r\n    // expand variables from uint256\r\n    function expand(uint256 vars) internal pure returns (uint256 seed, uint256 curtype, uint256 subiteration, int256 x, int256 y, int256 dx, int256 dy) {\r\n    \tseed = uint256(vars & 0xffffffffffffffff);\r\n    \tvars = vars >> 64;\r\n    \tcurtype = uint256(vars & 0xffffffff);\r\n    \tvars = vars >> 32;\r\n    \tsubiteration = uint256(vars & 0xffffffff);\r\n    \tvars = vars >> 32;\r\n    \tx = int256(int32(uint32(vars)));\r\n    \tvars = vars >> 32;\r\n    \ty = int256(int32(uint32(vars)));\r\n    \tvars = vars >> 32;\r\n    \tdx = int256(int32(uint32(vars)));\r\n    \tvars = vars >> 32;\r\n    \tdy = int256(int32(uint32(vars)));\r\n    }\r\n\r\n    function uintToString(uint v) public pure returns (string memory) {\r\n        uint maxlength = 8;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n            uint remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = bytes1(uint8(48 + remainder));\r\n        }\r\n        bytes memory s = new bytes(i); // i + 1 is inefficient\r\n        for (uint j = 0; j < i; j++) {\r\n            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\r\n        }\r\n        string memory str = string(s);  // memory isn't implicitly convertible to storage\r\n        return str;\r\n    }\r\n\r\n    function getColorString(uint256 seed) internal view returns (bytes memory) {\r\n    \tseed = uint256(keccak256(abi.encodePacked(seed)));\r\n        uint256 color_h = 1 + seed % 359;\r\n    \tseed = uint256(keccak256(abi.encodePacked(seed)));\r\n        uint256 color_s = 65 + seed % 22;\r\n    \tseed = uint256(keccak256(abi.encodePacked(seed)));\r\n        uint256 color_l = 65 + seed % 22;\r\n\r\n        return abi.encodePacked(\"stroke%3Ahsl(\", uintToString(color_h), \"%2C\", uintToString(color_s), \"%25%2C\", uintToString(color_l), \"%25)%3B\");\r\n    }\r\n\r\n    // returns length of string copied and current position of pointer\r\n    function copyString(bytes memory curPosition, bytes memory strToCopy) internal view returns (uint256 linelen, bytes memory resPosition) {\r\n    \tuint256 numloops = (strToCopy.length + 31) / 32;\r\n    \tlinelen = strToCopy.length;\r\n    \tresPosition = curPosition;\r\n\r\n    \t// copy curLine into result\r\n    \tassembly {\r\n\t        for {  let j := 0 } lt(j, numloops) { j := add(1, j) } { mstore(add(resPosition, mul(32, j)), mload(add(strToCopy, mul(32, add(1, j))))) }\r\n\t        resPosition := add(resPosition, linelen)\r\n\t    }\r\n    }\r\n\r\n    // get svg line output from data\r\n    function getCurLine(uint256[] memory data, uint256 index, string[4] memory vars) internal view returns (bytes memory) {      \r\n      \tuint256 remainder;\r\n        int256 x;\r\n        int256 y;\r\n        int256 dx;\r\n        int256 dy;\r\n        (,,, x, y, dx, dy) = expand(data[index]);\r\n\r\n    \tuint256 curdigit;\r\n    \tuint256 numdigits;\r\n    \tstring memory stringStart;\r\n\r\n    \tfor (uint256 i=0; i<4; i++) {\r\n    \t\tcurdigit = 0;\r\n    \t\tnumdigits = 0;\r\n\t    \tuint256 num;\r\n\t    \tif (i == 0) {\r\n\t    \t\tnum = uint256(x);\r\n\t    \t} else if (i == 1) {\r\n\t    \t\tnum = uint256(y);\r\n\t    \t}  else if (i == 2) {\r\n\t    \t\tnum = uint256(x+dx);\r\n\t    \t} else {\r\n\t    \t\tnum = uint256(y+dy);\r\n\t    \t}\r\n\r\n\t    \tassembly {\r\n\t    \t\tstringStart := mload(add(vars, mul(32, i)))\r\n\t    \t}\r\n\r\n\t    \tuint256 numcopy = num;\r\n\r\n\t    \t// count number of digits\r\n\t    \t\r\n\t    \t// while (numcopy > 0) {\r\n\t    \t// \tnumdigits += 1;\r\n\t    \t// \tnumcopy /= 10;\r\n\t    \t// }\r\n\t    \tassembly {\r\n\t    \t\tfor { } gt(numcopy, 0) { numcopy := div(numcopy, 10) } { numdigits := add(numdigits, 1) }\r\n\t\t\t}\r\n\r\n\t\t\t// convert integer into string format\r\n\r\n\t\t\t// assume number won't be 0, so only handle above 0 case\r\n\t        // while (num > 0) {\r\n\t        // \tremainder = ((num % 10) + 48);\r\n\t        // \tassembly {\r\n\t        // \t\tmstore8(add(stringStart, add(31, sub(numdigits,curdigit))), remainder)\r\n\t        // \t}\r\n\t        // \tnum /= 10;\r\n\t        // \tcurdigit += 1;\r\n\t        // }\r\n\t        assembly {\r\n\t        \tfor {} gt(num, 0) {num := div(num, 10)} {\r\n\t        \t\tremainder := add(mod(num, 10),  48)\r\n\t        \t\tmstore8(add(stringStart, add(31, sub(numdigits,curdigit))), remainder)\r\n\t        \t\tcurdigit := add(curdigit, 1)\r\n\t        \t}\r\n\t        }\r\n\r\n\t        assembly {\r\n\t    \t\tmstore(stringStart, curdigit)\r\n\t    \t}\r\n    \t}\r\n\r\n        return abi.encodePacked(\"%3Cline%20x1%3D'\", vars[0] ,\"'%20y1%3D'\", vars[1], \"'%20x2%3D'\", vars[2], \"'%20y2%3D'\", vars[3], \"'%20%2F%3E\");\r\n\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"name\":\"uintToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"FriendlyFractals","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://799284b389ca3ea803faff9564ff43f7baca5901e2b5feab5435e39f5a7732f9"}]}