{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// This is a special \"passive\" migration contract of MTM. \r\n// Every single method is modified and has custom \"passive\" migration proxy logic.\r\n\r\nabstract contract Ownable {\r\n    address public owner;\r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner { require(owner == msg.sender, \"Ownable: NO\"); _; }\r\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\r\n        owner = newOwner_; \r\n    }\r\n}\r\n\r\ninterface iCM {\r\n    // Views\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function totalSupply() external view returns (uint256);\r\n    function ownerOf(uint256 tokenId_) external view returns (address);\r\n    function balanceOf(address address_) external view returns (uint256);\r\n    function getApproved(uint256 tokenId_) external view returns (address);\r\n    function isApprovedForAll(address owner_, address operator_) external view returns (bool);\r\n}\r\n\r\n// ERC721I Functions, but we modified it for passive migration method\r\n// ERC721IMigrator uses local state storage for gas savings.\r\n// It is like ERC721IStorage and ERC721IOperator combined into one.\r\ncontract ERC721IMigrator is Ownable {\r\n\r\n    // Interface the MTM Characters Main V1\r\n    iCM public CM;\r\n    function setCM(address address_) external onlyOwner {\r\n        CM = iCM(address_);\r\n    }\r\n\r\n    // Name and Symbol Stuff\r\n    string public name; string public symbol;\r\n    constructor(string memory name_, string memory symbol_) {\r\n        name = name_; symbol = symbol_;\r\n    }\r\n\r\n    // We turned these to _ prefix so we can use a override function\r\n    // To display custom proxy and passive migration logic\r\n    uint256 public totalSupply;\r\n    mapping(uint256 => address) public _ownerOf;\r\n    mapping(address => uint256) public _balanceOf;\r\n\r\n    // Here we have to keep track of a initialized balanceOf to prevent any view issues\r\n    mapping(address => bool) public _balanceOfInitialized;\r\n\r\n    \r\n    // We disregard the previous contract's approvals\r\n    mapping(uint256 => address) public getApproved;\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    // // TotalSupply Setter\r\n    // Here, we set the totalSupply to equal the previous\r\n    function setTotalSupply(uint256 totalSupply_) external onlyOwner {\r\n        totalSupply = totalSupply_; \r\n    }\r\n\r\n    // // Initializer\r\n    // This is a custom Transfer emitter for the initialize of this contract only\r\n    function initialize(uint256[] calldata tokenIds_, address[] calldata owners_) external onlyOwner {\r\n        require(tokenIds_.length == owners_.length,\r\n            \"initialize(): array length mismatch!\");\r\n        \r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            emit Transfer(address(0x0), owners_[i], tokenIds_[i]);\r\n        }\r\n    }\r\n\r\n    // OwnerOf (Proxy View)\r\n    function ownerOf(uint256 tokenId_) public view returns (address) {\r\n        // Find out of the _ownerOf slot has been initialized.\r\n        // We hardcode the tokenId_ to save gas.\r\n        if (tokenId_ <= 3259 && _ownerOf[tokenId_] == address(0x0)) {\r\n            // _ownerOf[tokenId_] is not initialized yet, so return the CM V1 value.\r\n            return CM.ownerOf(tokenId_);\r\n        } else {\r\n            // If it is already initialized, or is higher than migration Id\r\n            // return local state storage instead.\r\n            return _ownerOf[tokenId_];\r\n        }\r\n    }\r\n\r\n    // BalanceOf (Proxy View)\r\n    function balanceOf(address address_) public view returns (uint256) {\r\n        // Proxy the balance function\r\n        // We have a tracker of initialization of _balanceOf to track the differences\r\n        // If initialized, we use the state storage. Otherwise, we use CM V1 storage.\r\n        if (_balanceOfInitialized[address_]) {\r\n            return _balanceOf[address_]; \r\n        } else {\r\n            return CM.balanceOf(address_);\r\n        }\r\n    }\r\n\r\n    // Events! L[o_o]â…ƒ \r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Mint(address indexed to, uint256 tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    // Functions\r\n    function _mint(address to_, uint256 tokenId_) internal virtual {\r\n        require(to_ != address(0x0), \"ERC721IMigrator: _mint() Mint to Zero Address!\");\r\n        require(ownerOf(tokenId_) == address(0x0), \"ERC721IMigrator: _mint() Token already Exists!\");\r\n\r\n        // // ERC721I Logic\r\n\r\n        // We set _ownerOf in a normal way\r\n        _ownerOf[tokenId_] = to_;\r\n\r\n        // We rebalance the _balanceOf on initialization, otherwise follow normal ERC721I logic\r\n        if (_balanceOfInitialized[to_]) {\r\n            // If we are already initialized\r\n            _balanceOf[to_]++;\r\n        } else {\r\n            _balanceOf[to_] = (CM.balanceOf(to_) + 1);\r\n            _balanceOfInitialized[to_] = true;\r\n        }\r\n\r\n        // Increment TotalSupply as normal\r\n        totalSupply++;\r\n\r\n        // // ERC721I Logic End\r\n\r\n        // Emit Events\r\n        emit Transfer(address(0x0), to_, tokenId_);\r\n        emit Mint(to_, tokenId_);\r\n    }\r\n\r\n    function _transfer(address from_, address to_, uint256 tokenId_) internal virtual {\r\n        require(from_ == ownerOf(tokenId_), \"ERC721IMigrator: _transfer() Transfer from_ != ownerOf(tokenId_)\");\r\n        require(to_ != address(0x0), \"ERC721IMigrator: _transfer() Transfer to Zero Address!\");\r\n\r\n        // // ERC721I Transfer Logic\r\n\r\n        // If token has an approval\r\n        if (getApproved[tokenId_] != address(0x0)) {\r\n            // Remove the outstanding approval\r\n            getApproved[tokenId_] = address(0x0);\r\n        }\r\n\r\n        // Set the _ownerOf to the receiver\r\n        _ownerOf[tokenId_] = to_;\r\n\r\n        // // Initialize and Rebalance _balanceOf \r\n        if (_balanceOfInitialized[from_]) {\r\n            // If from_ is initialized, do normal balance change\r\n            _balanceOf[from_]--;\r\n        } else {\r\n            // If from_ is NOT initialized, follow rebalance flow\r\n            _balanceOf[from_] = (CM.balanceOf(from_) - 1);\r\n            // Set from_ as initialized\r\n            _balanceOfInitialized[from_] = true;\r\n        }\r\n\r\n        if (_balanceOfInitialized[to_]) {\r\n            // If to_ is initialized, do normal balance change\r\n            _balanceOf[to_]++;\r\n        } else {\r\n            // If to_ is NOT initialized, follow rebalance flow\r\n            _balanceOf[to_] = (CM.balanceOf(to_) + 1);\r\n            // Set to_ as initialized;\r\n            _balanceOfInitialized[to_] = true;\r\n        }\r\n\r\n        // // ERC721I Transfer Logic End\r\n\r\n        emit Transfer(from_, to_, tokenId_);\r\n    }\r\n\r\n    // Approvals\r\n    function _approve(address to_, uint256 tokenId_) internal virtual {\r\n        if (getApproved[tokenId_] != to_) {\r\n            getApproved[tokenId_] = to_;\r\n            emit Approval(ownerOf(tokenId_), to_, tokenId_);\r\n        }\r\n    }\r\n    function _setApprovalForAll(address owner_, address operator_, bool approved_) internal virtual {\r\n        require(owner_ != operator_, \"ERC721IMigrator: _setApprovalForAll() Owner must not be the Operator!\");\r\n        isApprovedForAll[owner_][operator_] = approved_;\r\n        emit ApprovalForAll(owner_, operator_, approved_);\r\n    }\r\n\r\n    // // Functional Internal Views\r\n    function _isApprovedOrOwner(address spender_, uint256 tokenId_) internal view returns (bool) {\r\n        address _owner = ownerOf(tokenId_);\r\n        require(_owner != address(0x0), \"ERC721IMigrator: _isApprovedOrOwner() Owner is Zero Address!\");\r\n        return (spender_ == _owner // is the owner OR\r\n            || spender_ == getApproved[tokenId_] // is approved for token OR\r\n            || isApprovedForAll[_owner][spender_] // isApprovedForAll spender \r\n        );\r\n    }\r\n\r\n    // Exists\r\n    function _exists(uint256 tokenId_) internal view virtual returns (bool) {\r\n        // We hardcode tokenId_ for gas savings\r\n        if (tokenId_ <= 3259) { return true; }\r\n        return _ownerOf[tokenId_] != address(0x0);\r\n    }\r\n\r\n    // Public Write Functions \r\n    function approve(address to_, uint256 tokenId_) public virtual {\r\n        address _owner = ownerOf(tokenId_);\r\n        require(to_ != _owner, \"ERC721IMigrator: approve() cannot approve owner!\");\r\n        require(msg.sender == _owner // sender is the owner of the token\r\n            || isApprovedForAll[_owner][msg.sender], // or isApprovedForAll for the owner\r\n            \"ERC721IMigrator: approve() Caller is not owner of isApprovedForAll!\");\r\n        _approve(to_, tokenId_);\r\n    }\r\n    // SetApprovalForAll - the msg.sender is always the subject of approval\r\n    function setApprovalForAll(address operator_, bool approved_) public virtual {\r\n        _setApprovalForAll(msg.sender, operator_, approved_);\r\n    }\r\n\r\n    // Transfers\r\n    function transferFrom(address from_, address to_, uint256 tokenId_) public virtual {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId_), \r\n            \"ERC721IMigrator: transferFrom() _isApprovedOrOwner = false!\");\r\n        _transfer(from_, to_, tokenId_);\r\n    }\r\n    function safeTransferFrom(address from_, address to_, uint256 tokenId_, bytes memory data_) public virtual {\r\n        transferFrom(from_, to_, tokenId_);\r\n        if (to_.code.length != 0) {\r\n            (, bytes memory _returned) = to_.staticcall(abi.encodeWithSelector(0x150b7a02, msg.sender, from_, tokenId_, data_));\r\n            bytes4 _selector = abi.decode(_returned, (bytes4));\r\n            require(_selector == 0x150b7a02, \"ERC721IMigrator: safeTransferFrom() to_ not ERC721Receivable!\");\r\n        }\r\n    }\r\n    function safeTransferFrom(address from_, address to_, uint256 tokenId_) public virtual {\r\n        safeTransferFrom(from_, to_, tokenId_, \"\");\r\n    }\r\n\r\n    // Native Multi-Transfers by 0xInuarashi\r\n    function multiTransferFrom(address from_, address to_, uint256[] memory tokenIds_) public virtual {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            transferFrom(from_, to_, tokenIds_[i]);\r\n        }\r\n    }\r\n    function multiSafeTransferFrom(address from_, address to_, uint256[] memory tokenIds_, bytes memory data_) public virtual {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++ ){\r\n            safeTransferFrom(from_, to_, tokenIds_[i], data_);\r\n        }\r\n    }\r\n\r\n    // OZ Standard Stuff\r\n    function supportsInterface(bytes4 interfaceId_) public pure returns (bool) {\r\n        return (interfaceId_ == 0x80ac58cd || interfaceId_ == 0x5b5e139f);\r\n    }\r\n\r\n    // High Gas Loop View Functions\r\n    function walletOfOwner(address address_) public virtual view returns (uint256[] memory) {\r\n        uint256 _balance = balanceOf(address_);\r\n        uint256[] memory _tokens = new uint256[](_balance);\r\n        uint256 _index;\r\n        uint256 _loopThrough = totalSupply;\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            // Add another loop through for each 0x0 until array is filled\r\n            if (ownerOf(i) == address(0x0) && _tokens[_balance - 1] == 0) {\r\n                _loopThrough++;\r\n            }\r\n            // Fill the array on each token found\r\n            if (ownerOf(i) == address_) {\r\n                // Record the ID in the index \r\n                _tokens[_index] = i;\r\n                // Increment the index\r\n                _index++;\r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n\r\n    // TokenURIs Functions Omitted //\r\n\r\n}\r\n\r\ninterface IERC721 {\r\n    function ownerOf(uint256 tokenId_) external view returns (address);\r\n    function transferFrom(address from_, address to_, uint256 tokenId_) external;\r\n}\r\n\r\ninterface iCS {\r\n    struct Character {\r\n        uint8  race_;\r\n        uint8  renderType_;\r\n        uint16 transponderId_;\r\n        uint16 spaceCapsuleId_;\r\n        uint8  augments_;\r\n        uint16 basePoints_;\r\n        uint16 totalEquipmentBonus_;\r\n    }\r\n    struct Stats {\r\n        uint8 strength_; \r\n        uint8 agility_; \r\n        uint8 constitution_; \r\n        uint8 intelligence_; \r\n        uint8 spirit_; \r\n    }\r\n    struct Equipment {\r\n        uint8 weaponUpgrades_;\r\n        uint8 chestUpgrades_;\r\n        uint8 headUpgrades_;\r\n        uint8 legsUpgrades_;\r\n        uint8 vehicleUpgrades_;\r\n        uint8 armsUpgrades_;\r\n        uint8 artifactUpgrades_;\r\n        uint8 ringUpgrades_;\r\n    }\r\n\r\n    // Create Character\r\n    function createCharacter(uint tokenId_, Character memory Character_) external;\r\n    // Characters\r\n    function setName(uint256 tokenId_, string memory name_) external;\r\n    function setRace(uint256 tokenId_, string memory race_) external;\r\n    function setRenderType(uint256 tokenId_, uint8 renderType_) external;\r\n    function setTransponderId(uint256 tokenId_, uint16 transponderId_) external;\r\n    function setSpaceCapsuleId(uint256 tokenId_, uint16 spaceCapsuleId_) external;\r\n    function setAugments(uint256 tokenId_, uint8 augments_) external;\r\n    function setBasePoints(uint256 tokenId_, uint16 basePoints_) external;\r\n    function setBaseEquipmentBonus(uint256 tokenId_, uint16 baseEquipmentBonus_) external;\r\n    function setTotalEquipmentBonus(uint256 tokenId_, uint16 totalEquipmentBonus) external;\r\n    // Stats\r\n    function setStrength(uint256 tokenId_, uint8 strength_) external;\r\n    function setAgility(uint256 tokenId_, uint8 agility_) external;\r\n    function setConstitution(uint256 tokenId_, uint8 constitution_) external;\r\n    function setIntelligence(uint256 tokenId_, uint8 intelligence_) external;\r\n    function setSpirit(uint256 tokenId_, uint8 spirit_) external;\r\n    // Equipment\r\n    function setWeaponUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    function setChestUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    function setHeadUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    function setLegsUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    function setVehicleUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    function setArmsUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    function setArtifactUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    function setRingUpgrades(uint256 tokenId_, uint8 upgrade_) external;\r\n    // Structs and Mappings\r\n    function names(uint256 tokenId_) external view returns (string memory);\r\n    function characters(uint256 tokenId_) external view returns (Character memory);\r\n    function stats(uint256 tokenId_) external view returns (Stats memory);\r\n    function equipments(uint256 tokenId_) external view returns (Equipment memory);\r\n    function contractToRace(address contractAddress_) external view returns (uint8);\r\n}\r\n\r\ninterface iCC {\r\n    function queryCharacterYieldRate(uint8 augments_, uint16 basePoints_, uint16 totalEquipmentBonus_) external view returns (uint256);\r\n    function getEquipmentBaseBonus(uint16 spaceCapsuleId_) external view returns (uint16); \r\n}\r\n\r\ninterface iMES {\r\n    // View Functions\r\n    function balanceOf(address address_) external view returns (uint256);\r\n    function pendingRewards(address address_) external view returns (uint256); \r\n    // Administration\r\n    function setYieldRate(address address_, uint256 yieldRate_) external;\r\n    function addYieldRate(address address_, uint256 yieldRateAdd_) external;\r\n    function subYieldRate(address address_, uint256 yieldRateSub_) external;\r\n    // Credits System\r\n    function deductCredits(address address_, uint256 amount_) external;\r\n    function addCredits(address address_, uint256 amount_) external;\r\n    // Claiming\r\n    function updateReward(address address_) external;\r\n    function burn(address from, uint256 amount_) external;\r\n}\r\n\r\ninterface iMetadata {\r\n    function renderMetadata(uint256 tokenId_) external view returns (string memory);\r\n}\r\n\r\ncontract MTMCharacters is ERC721IMigrator {\r\n    constructor() ERC721IMigrator(\"MTM Characters\", \"CHARACTERS\") {}\r\n\r\n    // Interfaces\r\n    iCS public CS; iCC public CC; iMES public MES; iMetadata public Metadata;\r\n    IERC721 public TP; IERC721 public SC;\r\n    function setContracts(address metadata_, address cc_, address cs_, address mes_, address tp_, address sc_) external onlyOwner {\r\n        CS = iCS(cs_); CC = iCC(cc_); MES = iMES(mes_); Metadata = iMetadata(metadata_);\r\n        TP = IERC721(tp_); SC = IERC721(sc_);\r\n    }\r\n\r\n    // Mappings\r\n    mapping(address => mapping(uint256 => bool)) public contractAddressToTokenUploaded;\r\n\r\n    // Internal Write Functions\r\n    function __yieldMintHook(address to_, uint256 tokenId_) internal {\r\n        // First, we update the reward. \r\n        MES.updateReward(to_);\r\n\r\n        // Then, we query the token yield rate.\r\n        iCS.Character memory _Character = CS.characters(tokenId_);\r\n        uint256 _tokenYieldRate = CC.queryCharacterYieldRate(_Character.augments_, _Character.basePoints_, _Character.totalEquipmentBonus_);\r\n\r\n        // Lastly, we adjust the yield rate of the address.\r\n        MES.addYieldRate(to_, _tokenYieldRate);\r\n    }\r\n    function __yieldTransferHook(address from_, address to_, uint256 tokenId_) internal {\r\n        // First, we update the reward. \r\n        MES.updateReward(from_); MES.updateReward(to_);\r\n\r\n        // Then, we query the token yield rate.\r\n        iCS.Character memory _Character = CS.characters(tokenId_);\r\n        uint256 _tokenYieldRate = CC.queryCharacterYieldRate(_Character.augments_, _Character.basePoints_, _Character.totalEquipmentBonus_);\r\n\r\n        // Lastly, we adjust the yield rate of the addresses.\r\n        MES.subYieldRate(from_, _tokenYieldRate); MES.addYieldRate(to_, _tokenYieldRate);\r\n    }\r\n\r\n    // Public Write Functions\r\n    mapping(uint8 => bool) public renderTypeAllowed;\r\n    function setRenderTypeAllowed(uint8 renderType_, bool bool_) external onlyOwner {\r\n        renderTypeAllowed[renderType_] = bool_;\r\n    }\r\n\r\n    function beamCharacter(uint256 transponderId_, uint256 spaceCapsuleId_, uint8 renderType_) public {\r\n        require(msg.sender == TP.ownerOf(transponderId_) && msg.sender == SC.ownerOf(spaceCapsuleId_), \"Unowned pair!\");\r\n        require(renderTypeAllowed[renderType_], \"This render type is not allowed!\");\r\n\r\n        // Burn the Transponder and Space Capsule.\r\n        TP.transferFrom(msg.sender, address(this), transponderId_);\r\n        SC.transferFrom(msg.sender, address(this), spaceCapsuleId_);\r\n\r\n        uint8 _race = uint8( (uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty, transponderId_, spaceCapsuleId_))) % 10) + 1 ); // RNG (1-10) \r\n        uint16 _equipmentBonus = CC.getEquipmentBaseBonus((uint16(spaceCapsuleId_)));\r\n\r\n        iCS.Character memory _Character = iCS.Character(\r\n            _race,\r\n            renderType_,\r\n            uint16(transponderId_),\r\n            uint16(spaceCapsuleId_),\r\n            0,\r\n            0,\r\n            _equipmentBonus\r\n        );\r\n\r\n        CS.createCharacter(totalSupply, _Character);\r\n        \r\n        __yieldMintHook(msg.sender, totalSupply);\r\n        _mint(msg.sender, totalSupply);\r\n    }\r\n    function uploadCharacter(uint256 transponderId_, uint256 spaceCapsuleId_, uint8 renderType_, address contractAddress_, uint256 uploadId_) public {\r\n        require(msg.sender == TP.ownerOf(transponderId_) && msg.sender == SC.ownerOf(spaceCapsuleId_), \"Unowned pair!\");\r\n        require(msg.sender == IERC721(contractAddress_).ownerOf(uploadId_), \"You don't own this character!\");\r\n        require(!contractAddressToTokenUploaded[contractAddress_][uploadId_], \"This character has already been uploaded!\");\r\n        require(renderTypeAllowed[renderType_], \"This render type is not allowed!\");\r\n\r\n        // Burn the Transponder and Space Capsule. Then, set the character as uploaded.\r\n        TP.transferFrom(msg.sender, address(this), transponderId_);\r\n        SC.transferFrom(msg.sender, address(this), spaceCapsuleId_);\r\n        contractAddressToTokenUploaded[contractAddress_][uploadId_] = true;\r\n\r\n        uint8 _race = CS.contractToRace(contractAddress_);\r\n        uint16 _equipmentBonus = CC.getEquipmentBaseBonus((uint16(spaceCapsuleId_)));\r\n        \r\n        iCS.Character memory _Character = iCS.Character(\r\n            _race,\r\n            renderType_,\r\n            uint16(transponderId_),\r\n            uint16(spaceCapsuleId_),\r\n            0,\r\n            0,\r\n            _equipmentBonus\r\n        );\r\n\r\n        CS.createCharacter(totalSupply, _Character); \r\n\r\n        __yieldMintHook(msg.sender, totalSupply);\r\n        _mint(msg.sender, totalSupply); \r\n    }\r\n\r\n    // Public Write Multi-Functions\r\n    function multiBeamCharacter(uint256[] memory transponderIds_, uint256[] memory spaceCapsuleIds_, uint8[] memory renderTypes_) public {\r\n        require(transponderIds_.length == spaceCapsuleIds_.length, \"Missing pairs!\");\r\n        require(transponderIds_.length == renderTypes_.length, \"Missing render type!\");\r\n        for (uint256 i = 0; i < transponderIds_.length; i++) {\r\n            beamCharacter(transponderIds_[i], spaceCapsuleIds_[i], renderTypes_[i]);\r\n        }\r\n    }\r\n    function multiUploadCharacter(uint256[] memory transponderIds_, uint256[] memory spaceCapsuleIds_, uint8[] memory renderTypes_, address contractAddress_, uint256[] memory uploadIds_) public {\r\n        require(transponderIds_.length == spaceCapsuleIds_.length, \"Missing pairs!\");\r\n        require(transponderIds_.length == renderTypes_.length, \"Missing render type!\");\r\n        require(transponderIds_.length == uploadIds_.length, \"Upload IDs mismatched length!\");\r\n        for (uint256 i = 0; i < transponderIds_.length; i++) {\r\n            uploadCharacter(transponderIds_[i], spaceCapsuleIds_[i], renderTypes_[i], contractAddress_, uploadIds_[i]);\r\n        }\r\n    }\r\n\r\n    // Transfer Hooks\r\n    function transferFrom(address from_, address to_, uint256 tokenId_) public override {\r\n        __yieldTransferHook(from_, to_, tokenId_);\r\n        ERC721IMigrator.transferFrom(from_, to_, tokenId_);\r\n    }\r\n    function safeTransferFrom(address from_, address to_, uint256 tokenId_, bytes memory bytes_) public override {\r\n        __yieldTransferHook(from_, to_, tokenId_);\r\n        ERC721IMigrator.safeTransferFrom(from_, to_, tokenId_, bytes_);\r\n    }\r\n\r\n    // Public View Functions\r\n    function tokenURI(uint256 tokenId_) public view returns (string memory) {\r\n        require(_exists(tokenId_), \"Character does not exist!\");\r\n        return Metadata.renderMetadata(tokenId_);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CC\",\"outputs\":[{\"internalType\":\"contract iCC\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CM\",\"outputs\":[{\"internalType\":\"contract iCM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CS\",\"outputs\":[{\"internalType\":\"contract iCS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MES\",\"outputs\":[{\"internalType\":\"contract iMES\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Metadata\",\"outputs\":[{\"internalType\":\"contract iMetadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SC\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TP\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balanceOfInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transponderId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spaceCapsuleId_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"renderType_\",\"type\":\"uint8\"}],\"name\":\"beamCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contractAddressToTokenUploaded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"owners_\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"transponderIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"spaceCapsuleIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"renderTypes_\",\"type\":\"uint8[]\"}],\"name\":\"multiBeamCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"multiSafeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"multiTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"transponderIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"spaceCapsuleIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"renderTypes_\",\"type\":\"uint8[]\"},{\"internalType\":\"address\",\"name\":\"contractAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"uploadIds_\",\"type\":\"uint256[]\"}],\"name\":\"multiUploadCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"renderTypeAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytes_\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setCM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metadata_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cc_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cs_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mes_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tp_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sc_\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"renderType_\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"}],\"name\":\"setRenderTypeAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"name\":\"setTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transponderId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spaceCapsuleId_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"renderType_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"contractAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uploadId_\",\"type\":\"uint256\"}],\"name\":\"uploadCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MTMCharacters","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://323cfbb290e1c0b14ace1c62038d9b505209f2fa97089a21d233bf611a9d3fe7"}]}