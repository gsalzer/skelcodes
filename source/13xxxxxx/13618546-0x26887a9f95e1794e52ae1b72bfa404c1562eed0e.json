{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/HyperVIBES.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\n/*\\n\\n\\n    ██╗  ██╗██╗   ██╗██████╗ ███████╗██████╗ ██╗   ██╗██╗██████╗ ███████╗███████╗\\n    ██║  ██║╚██╗ ██╔╝██╔══██╗██╔════╝██╔══██╗██║   ██║██║██╔══██╗██╔════╝██╔════╝\\n    ███████║ ╚████╔╝ ██████╔╝█████╗  ██████╔╝██║   ██║██║██████╔╝█████╗  ███████╗\\n    ██╔══██║  ╚██╔╝  ██╔═══╝ ██╔══╝  ██╔══██╗╚██╗ ██╔╝██║██╔══██╗██╔══╝  ╚════██║\\n    ██║  ██║   ██║   ██║     ███████╗██║  ██║ ╚████╔╝ ██║██████╔╝███████╗███████║\\n    ╚═╝  ╚═╝   ╚═╝   ╚═╝     ╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚═╝╚═════╝ ╚══════╝╚══════╝\\n\\n\\n    The possibilities are endless in the realms of your imagination.\\n    What would you do with that power?\\n\\n                            Dreamt up & built at\\n                                Rarible DAO\\n\\n                                  * * * *\\n\\n    HyperVIBES is a public and free protocol from Rarible DAO that lets you\\n    infuse any ERC-20 token into ERC-721 NFTs from any minting platform.\\n\\n    Infused tokens can be mined and claimed by the NFT owner over time.\\n\\n    Create a fully isolated and independently configured HyperVIBES realm to run\\n    your own experiments or protocols without having to deploy a smart contract.\\n\\n    HyperVIBES is:\\n    - 🎁 Open Source\\n    - 🥳 Massively Multiplayer\\n    - 🌈 Public Infrastructure\\n    - 🚀 Unstoppable and Censor-Proof\\n    - 🌎 Multi-chain\\n    - 💖 Free Forever\\n\\n    Feel free to use HyperVIBES in any way you want.\\n\\n    https://hypervibes.xyz\\n    https://app.hypervibes.xyz\\n    https://docs.hypervibes.xyz\\n\\n*/\\n\\nimport \\\"./IHyperVIBES.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ncontract HyperVIBES is IHyperVIBES, ReentrancyGuard {\\n    bool constant public FEEL_FREE_TO_USE_HYPERVIBES_IN_ANY_WAY_YOU_WANT = true;\\n\\n    // ---\\n    // storage\\n    // ---\\n\\n    // realm ID -> realm data\\n    mapping(uint256 => RealmConfig) public realmConfig;\\n\\n    // realm ID -> address -> (is admin flag)\\n    mapping(uint256 => mapping(address => bool)) public isAdmin;\\n\\n    // realm ID -> address -> (is infuser flag)\\n    mapping(uint256 => mapping(address => bool)) public isInfuser;\\n\\n    // realm ID -> address -> (is claimer flag)\\n    mapping(uint256 => mapping(address => bool)) public isClaimer;\\n\\n    // realm ID -> erc721 -> (is allowed collection flag)\\n    mapping(uint256 => mapping(IERC721 => bool)) public isCollection;\\n\\n    // realm ID -> nft -> token ID -> token data\\n    mapping(uint256 => mapping(IERC721 => mapping(uint256 => TokenData)))\\n        public tokenData;\\n\\n    // realm ID -> operator -> infuser -> (is allowed proxy flag)\\n    mapping(uint256 => mapping(address => mapping(address => bool))) public isProxy;\\n\\n    uint256 public nextRealmId = 1;\\n\\n    // ---\\n    // admin mutations\\n    // ---\\n\\n    // setup a new realm\\n    function createRealm(CreateRealmInput memory create) override external returns (uint256) {\\n        require(create.config.token != IERC20(address(0)), \\\"invalid token\\\");\\n        require(create.config.constraints.maxTokenBalance > 0, \\\"invalid max token balance\\\");\\n        require(\\n            create.config.constraints.minClaimAmount <= create.config.constraints.maxTokenBalance,\\n            \\\"invalid min claim amount\\\");\\n\\n        uint256 realmId = nextRealmId++;\\n        realmConfig[realmId] = create.config;\\n\\n        emit RealmCreated(realmId, create.name, create.description);\\n\\n        for (uint256 i = 0; i < create.admins.length; i++) {\\n            _addAdmin(realmId, create.admins[i]);\\n        }\\n\\n        for (uint256 i = 0; i < create.infusers.length; i++) {\\n            _addInfuser(realmId, create.infusers[i]);\\n        }\\n\\n        for (uint256 i = 0; i < create.claimers.length; i++) {\\n            _addClaimer(realmId, create.claimers[i]);\\n        }\\n\\n        for (uint256 i = 0; i < create.collections.length; i++) {\\n            _addCollection(realmId, create.collections[i]);\\n        }\\n\\n        return realmId;\\n    }\\n\\n    // update mutable configuration for a realm\\n    function modifyRealm(ModifyRealmInput memory input) override external {\\n        require(_realmExists(input.realmId), \\\"invalid realm\\\");\\n        require(isAdmin[input.realmId][msg.sender], \\\"not realm admin\\\");\\n\\n        // adds\\n\\n        for (uint256 i = 0; i < input.adminsToAdd.length; i++) {\\n            _addAdmin(input.realmId, input.adminsToAdd[i]);\\n        }\\n\\n        for (uint256 i = 0; i < input.infusersToAdd.length; i++) {\\n            _addInfuser(input.realmId, input.infusersToAdd[i]);\\n        }\\n\\n        for (uint256 i = 0; i < input.claimersToAdd.length; i++) {\\n            _addClaimer(input.realmId, input.claimersToAdd[i]);\\n        }\\n\\n        for (uint256 i = 0; i < input.collectionsToAdd.length; i++) {\\n            _addCollection(input.realmId, input.collectionsToAdd[i]);\\n        }\\n\\n        // removes\\n\\n        for (uint256 i = 0; i < input.adminsToRemove.length; i++) {\\n            _removeAdmin(input.realmId, input.adminsToRemove[i]);\\n        }\\n\\n        for (uint256 i = 0; i < input.infusersToRemove.length; i++) {\\n            _removeInfuser(input.realmId, input.infusersToRemove[i]);\\n        }\\n\\n        for (uint256 i = 0; i < input.claimersToRemove.length; i++) {\\n            _removeClaimer(input.realmId, input.claimersToRemove[i]);\\n        }\\n\\n        for (uint256 i = 0; i < input.collectionsToRemove.length; i++) {\\n            _removeCollection(input.realmId, input.collectionsToRemove[i]);\\n        }\\n    }\\n\\n    function _addAdmin(uint256 realmId, address admin) internal {\\n        require(admin != address(0), \\\"invalid admin\\\");\\n        isAdmin[realmId][admin] = true;\\n        emit AdminAdded(realmId, admin);\\n    }\\n\\n    function _removeAdmin(uint256 realmId, address admin) internal {\\n        require(admin != address(0), \\\"invalid admin\\\");\\n        delete isAdmin[realmId][admin];\\n        emit AdminRemoved(realmId, admin);\\n    }\\n\\n    function _addInfuser(uint256 realmId, address infuser) internal {\\n        require(infuser != address(0), \\\"invalid infuser\\\");\\n        isInfuser[realmId][infuser] = true;\\n        emit InfuserAdded(realmId, infuser);\\n    }\\n\\n    function _removeInfuser(uint256 realmId, address infuser) internal {\\n        require(infuser != address(0), \\\"invalid infuser\\\");\\n        delete isInfuser[realmId][infuser];\\n        emit InfuserRemoved(realmId, infuser);\\n    }\\n\\n    function _addClaimer(uint256 realmId, address claimer) internal {\\n        require(claimer != address(0), \\\"invalid claimer\\\");\\n        isClaimer[realmId][claimer] = true;\\n        emit ClaimerAdded(realmId, claimer);\\n    }\\n\\n    function _removeClaimer(uint256 realmId, address claimer) internal {\\n        require(claimer != address(0), \\\"invalid claimer\\\");\\n        delete isClaimer[realmId][claimer];\\n        emit ClaimerRemoved(realmId, claimer);\\n    }\\n\\n    function _addCollection(uint256 realmId, IERC721 collection) internal {\\n        require(collection != IERC721(address(0)), \\\"invalid collection\\\");\\n        isCollection[realmId][collection] = true;\\n        emit CollectionAdded(realmId, collection);\\n    }\\n\\n    function _removeCollection(uint256 realmId, IERC721 collection) internal {\\n        require(collection != IERC721(address(0)), \\\"invalid collection\\\");\\n        delete isCollection[realmId][collection];\\n        emit CollectionRemoved(realmId, collection);\\n    }\\n\\n    // ---\\n    // infuser mutations\\n    // ---\\n\\n    // nonReentrant wrapper\\n    function infuse(InfuseInput memory input) override external nonReentrant returns (uint256) {\\n        return _infuse(input);\\n    }\\n\\n    function _infuse(InfuseInput memory input) private returns (uint256) {\\n        TokenData storage data = tokenData[input.realmId][input.collection][input.tokenId];\\n        RealmConfig memory realm = realmConfig[input.realmId];\\n\\n        _validateInfusion(input, data, realm);\\n\\n        // initialize token storage if first infusion\\n        if (data.lastClaimAt == 0) {\\n            data.lastClaimAt = block.timestamp;\\n        }\\n        // re-set last claim to now if this is empty, else it will pre-mine the\\n        // time since the last claim\\n        else if (data.balance == 0) {\\n            data.lastClaimAt = block.timestamp;\\n        }\\n\\n        // determine if we need to clamp the amount based on maxTokenBalance\\n        uint256 nextBalance = data.balance + input.amount;\\n        uint256 clampedBalance = nextBalance > realm.constraints.maxTokenBalance\\n            ? realm.constraints.maxTokenBalance\\n            : nextBalance;\\n        uint256 amountToTransfer = clampedBalance - data.balance;\\n\\n        // jit assert that this amount is valid within constraints\\n        require(amountToTransfer > 0, \\\"nothing to transfer\\\");\\n        require(amountToTransfer >= realm.constraints.minInfusionAmount, \\\"amount too low\\\");\\n\\n        // pull tokens from msg sender into the contract\\n        data.balance += amountToTransfer;\\n        realm.token.transferFrom(msg.sender, address(this), amountToTransfer);\\n\\n        emit Infused(\\n            input.realmId,\\n            input.collection,\\n            input.tokenId,\\n            input.infuser,\\n            input.amount,\\n            input.comment\\n        );\\n\\n        return amountToTransfer;\\n    }\\n\\n    function _validateInfusion(InfuseInput memory input, TokenData memory data, RealmConfig memory realm) internal view {\\n        require(_isTokenValid(input.collection, input.tokenId), \\\"invalid token\\\");\\n        require(_realmExists(input.realmId), \\\"invalid realm\\\");\\n\\n        bool isOwnedByInfuser = input.collection.ownerOf(input.tokenId) == input.infuser;\\n        bool isOnInfuserAllowlist = isInfuser[input.realmId][msg.sender];\\n        bool isOnCollectionAllowlist = isCollection[input.realmId][input.collection];\\n        bool isValidProxy = isProxy[input.realmId][msg.sender][input.infuser];\\n\\n        require(isOwnedByInfuser || !realm.constraints.requireNftIsOwned, \\\"nft not owned by infuser\\\");\\n        require(isOnInfuserAllowlist || realm.constraints.allowPublicInfusion, \\\"invalid infuser\\\");\\n        require(isOnCollectionAllowlist || realm.constraints.allowAllCollections, \\\"invalid collection\\\");\\n        require(isValidProxy || msg.sender == input.infuser, \\\"invalid proxy\\\");\\n\\n        // if already infused...\\n        if (data.lastClaimAt != 0) {\\n            require(realm.constraints.allowMultiInfuse, \\\"multi infuse disabled\\\");\\n        }\\n    }\\n\\n    // ---\\n    // proxy mutations\\n    // ---\\n\\n    // allower operator to infuse or claim on behalf of msg.sender for a specific realm\\n    function allowProxy(uint256 realmId, address proxy) override external {\\n        require(_realmExists(realmId), \\\"invalid realm\\\");\\n        isProxy[realmId][proxy][msg.sender] = true;\\n        emit ProxyAdded(realmId, proxy);\\n    }\\n\\n    // deny operator the ability to infuse or claim on behalf of msg.sender for a specific realm\\n    function denyProxy(uint256 realmId, address proxy) override external {\\n        require(_realmExists(realmId), \\\"invalid realm\\\");\\n        delete isProxy[realmId][proxy][msg.sender];\\n        emit ProxyRemoved(realmId, proxy);\\n    }\\n\\n    // ---\\n    // claimer mutations\\n    // ---\\n\\n    // nonReentrant wrapper\\n    function claim(ClaimInput memory input) override external nonReentrant returns (uint256) {\\n        return _claim(input);\\n    }\\n\\n    function _claim(ClaimInput memory input) private returns (uint256) {\\n        require(_isTokenValid(input.collection, input.tokenId), \\\"invalid token\\\");\\n        require(_isValidClaimer(input.realmId, input.collection, input.tokenId), \\\"invalid claimer\\\");\\n\\n        TokenData storage data = tokenData[input.realmId][input.collection][input.tokenId];\\n        require(data.lastClaimAt != 0, \\\"token not infused\\\");\\n\\n        // compute mined / claimable\\n        uint256 secondsToClaim = block.timestamp - data.lastClaimAt;\\n        uint256 mined = (secondsToClaim * realmConfig[input.realmId].dailyRate) / 1 days;\\n        uint256 availableToClaim = mined > data.balance ? data.balance : mined;\\n\\n        // only pay attention to amount if its less than available\\n        uint256 toClaim = input.amount < availableToClaim ? input.amount : availableToClaim;\\n        require(toClaim >= realmConfig[input.realmId].constraints.minClaimAmount, \\\"amount too low\\\");\\n        require(toClaim > 0, \\\"nothing to claim\\\");\\n\\n        // claim only as far up as we need to get our amount... basically \\\"advances\\\"\\n        // the lastClaim timestamp the exact amount needed to provide the amount\\n        // claim at = last + (to claim / rate) * 1 day, rewritten for div last\\n        uint256 claimAt = data.lastClaimAt + (toClaim * 1 days) / realmConfig[input.realmId].dailyRate;\\n\\n        // update balances and execute ERC-20 transfer\\n        data.balance -= toClaim;\\n        data.lastClaimAt = claimAt;\\n        realmConfig[input.realmId].token.transfer(msg.sender, toClaim);\\n\\n        emit Claimed(input.realmId, input.collection, input.tokenId, toClaim);\\n\\n        return toClaim;\\n    }\\n\\n    // returns true if msg.sender can claim for a given (realm/collection/tokenId) tuple\\n    function _isValidClaimer(uint256 realmId, IERC721 collection, uint256 tokenId) internal view returns (bool) {\\n        address owner = collection.ownerOf(tokenId);\\n\\n        bool isOwned = owner == msg.sender;\\n        bool isValidProxy = isProxy[realmId][msg.sender][owner];\\n\\n        // no matter what, msg sender must be owner or have authorized a proxy.\\n        // ensures that claiming can never happen without owner approval of some\\n        // sort\\n        if (!isOwned && !isValidProxy) {\\n            return false;\\n        }\\n\\n        // if public claim is valid, we're good to go\\n        if (realmConfig[realmId].constraints.allowPublicClaiming) {\\n            return true;\\n        }\\n\\n        // otherwise, must be on claimer list\\n        return isClaimer[realmId][msg.sender];\\n    }\\n\\n\\n    // ---\\n    // batch utils\\n    // ---\\n\\n    function batchClaim(ClaimInput[] memory batch)\\n        override external nonReentrant\\n        returns (uint256)\\n    {\\n        uint256 totalClaimed = 0;\\n        for (uint256 i = 0; i < batch.length; i++) {\\n            totalClaimed += _claim(batch[i]);\\n        }\\n        return totalClaimed;\\n    }\\n\\n    function batchInfuse(InfuseInput[] memory batch)\\n        override external nonReentrant\\n        returns (uint256)\\n    {\\n        uint256 totalInfused = 0;\\n        for (uint256 i; i < batch.length; i++) {\\n            totalInfused += _infuse(batch[i]);\\n        }\\n        return totalInfused;\\n    }\\n\\n\\n    // ---\\n    // views\\n    // ---\\n\\n    function name() override external pure returns (string memory) {\\n        return \\\"HyperVIBES\\\";\\n    }\\n\\n\\n    // total amount of mined tokens\\n    // will return 0 if the token is not infused instead of reverting\\n    // will return 0 if the does not exist (burned, invalid contract or id)\\n    // will return amount mined even if not claimable (minClaimAmount constraint)\\n    function currentMinedTokens(uint256 realmId, IERC721 collection, uint256 tokenId)\\n        override external view returns (uint256)\\n    {\\n        require(_realmExists(realmId), \\\"invalid realm\\\");\\n\\n        TokenData memory data = tokenData[realmId][collection][tokenId];\\n\\n        // if non-existing token\\n        if (!_isTokenValid(collection, tokenId)) {\\n            return 0;\\n        }\\n\\n        // not infused\\n        if (data.lastClaimAt == 0) {\\n            return 0;\\n        }\\n\\n        uint256 miningTime = block.timestamp - data.lastClaimAt;\\n        uint256 mined = (miningTime * realmConfig[realmId].dailyRate) / 1 days;\\n        uint256 clamped = mined > data.balance ? data.balance : mined;\\n        return clamped;\\n    }\\n\\n    // ---\\n    // utils\\n    // ---\\n\\n    // returns true if a realm has been setup\\n    function _realmExists(uint256 realmId) internal view returns (bool) {\\n        return realmConfig[realmId].token != IERC20(address(0));\\n    }\\n\\n    // returns true if token exists (and is not burnt)\\n    function _isTokenValid(IERC721 collection, uint256 tokenId)\\n        internal view returns (bool)\\n    {\\n        try collection.ownerOf(tokenId) returns (address) {\\n            return true;\\n        } catch {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IHyperVIBES.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n// data stored for-each infused token\\nstruct TokenData {\\n    // total staked tokens for this NFT\\n    uint256 balance;\\n\\n    // timestamp of last executed claim, determines claimable tokens\\n    uint256 lastClaimAt;\\n}\\n\\n// per-realm configuration\\nstruct RealmConfig {\\n    // ERC-20 for the realm\\n    IERC20 token;\\n\\n    // daily token mining rate -- constant for the entire realm\\n    uint256 dailyRate;\\n\\n    // configured constraints for the realm\\n    RealmConstraints constraints;\\n}\\n\\n// constraint parameters for a realm\\nstruct RealmConstraints {\\n    // An NFT must be infused with at least this amount of the token every time\\n    // it's infused.\\n    uint256 minInfusionAmount;\\n\\n    // An NFT's infused balance cannot exceed this amount. If an infusion would\\n    // result in exceeding the max token balance, amount transferred is clamped\\n    // to the max.\\n    uint256 maxTokenBalance;\\n\\n    // When claiming mined tokens, at least this much must be claimed at a time.\\n    uint256 minClaimAmount;\\n\\n    // If true, the infuser must own the NFT at time of infusion.\\n    bool requireNftIsOwned;\\n\\n    // If true, an NFT can be infused more than once in the same realm.\\n    bool allowMultiInfuse;\\n\\n    // If true, anybody with enough tokens may infuse an NFT. If false, they\\n    // must be on the infusers list.\\n    bool allowPublicInfusion;\\n\\n    // If true, anybody who owns an infused NFT may claim the mined tokens. If\\n    // false, they must be on the claimers list\\n    bool allowPublicClaiming;\\n\\n    // If true, NFTs from any ERC-721 contract can be infused. If false, the\\n    // contract address must be on the collections list.\\n    bool allowAllCollections;\\n}\\n\\n// data provided when creating a realm\\nstruct CreateRealmInput {\\n    // Display name for the realm. Does not have to be unique across HyperVIBES.\\n    string name;\\n\\n    // Description for the realm.\\n    string description;\\n\\n    // token, mining rate, an constraint data\\n    RealmConfig config;\\n\\n    // Addresses that are allowed to add or remove admins, infusers, claimers,\\n    // or collections to the realm.\\n    address[] admins;\\n\\n    // Addresses that are allowed to infuse NFTs. Ignored if the allow public\\n    // infusion constraint is true.\\n    address[] infusers;\\n\\n    // Addresses that are allowed to claim mined tokens from an NFT. Ignored if\\n    // the allow public claiming constraint is true.\\n    address[] claimers;\\n\\n    // NFT contract addresses that can be infused. Ignore if the allow all\\n    // collections constraint is true.\\n    IERC721[] collections;\\n}\\n\\n// data provided when modifying a realm -- constraints, token, etc are not\\n// modifiable, but admins/infusers/claimers/collections can be added and removed\\n// by an admin\\nstruct ModifyRealmInput {\\n    uint256 realmId;\\n    address[] adminsToAdd;\\n    address[] adminsToRemove;\\n    address[] infusersToAdd;\\n    address[] infusersToRemove;\\n    address[] claimersToAdd;\\n    address[] claimersToRemove;\\n    IERC721[] collectionsToAdd;\\n    IERC721[] collectionsToRemove;\\n}\\n\\n// data provided when infusing an nft\\nstruct InfuseInput {\\n    uint256 realmId;\\n\\n    // NFT contract address\\n    IERC721 collection;\\n\\n    // NFT token ID\\n    uint256 tokenId;\\n\\n    // Infuser is manually specified, in the case of proxy infusions, msg.sender\\n    // might not be the infuser. Proxy infusions require msg.sender to be an\\n    // approved proxy by the credited infuser\\n    address infuser;\\n\\n    // total amount of tokens to infuse. Actual infusion amount may be less\\n    // based on maxTokenBalance realm constraint\\n    uint256 amount;\\n\\n    // emitted with event\\n    string comment;\\n}\\n\\n// data provided when claiming from an infused nft\\nstruct ClaimInput {\\n    uint256 realmId;\\n\\n    // NFT contract address\\n    IERC721 collection;\\n\\n    // NFT token ID\\n    uint256 tokenId;\\n\\n    // amount to claim. If this is greater than total claimable, only the max\\n    // will be claimed (use a huge number here to \\\"claim all\\\" effectively)\\n    uint256 amount;\\n}\\n\\ninterface IHyperVIBES {\\n    event RealmCreated(uint256 indexed realmId, string name, string description);\\n\\n    event AdminAdded(uint256 indexed realmId, address indexed admin);\\n\\n    event AdminRemoved(uint256 indexed realmId, address indexed admin);\\n\\n    event InfuserAdded(uint256 indexed realmId, address indexed infuser);\\n\\n    event InfuserRemoved(uint256 indexed realmId, address indexed infuser);\\n\\n    event CollectionAdded(uint256 indexed realmId, IERC721 indexed collection);\\n\\n    event CollectionRemoved(uint256 indexed realmId, IERC721 indexed collection);\\n\\n    event ClaimerAdded(uint256 indexed realmId, address indexed claimer);\\n\\n    event ClaimerRemoved(uint256 indexed realmId, address indexed claimer);\\n\\n    event ProxyAdded(uint256 indexed realmId, address indexed proxy);\\n\\n    event ProxyRemoved(uint256 indexed realmId, address indexed proxy);\\n\\n    event Infused(\\n        uint256 indexed realmId,\\n        IERC721 indexed collection,\\n        uint256 indexed tokenId,\\n        address infuser,\\n        uint256 amount,\\n        string comment\\n    );\\n\\n    event Claimed(\\n        uint256 indexed realmId,\\n        IERC721 indexed collection,\\n        uint256 indexed tokenId,\\n        uint256 amount\\n    );\\n\\n    // setup a new realm, returns the ID\\n    function createRealm(CreateRealmInput memory create) external returns (uint256);\\n\\n    // update admins, infusers, claimers, or collections for a realm\\n    function modifyRealm(ModifyRealmInput memory input) external;\\n\\n    // infuse an nft\\n    function infuse(InfuseInput memory input) external returns (uint256);\\n\\n    // allower operator to infuse or claim on behalf of msg.sender for a specific realm\\n    function allowProxy(uint256 realmId, address proxy) external;\\n\\n    // deny operator the ability to infuse or claim on behalf of msg.sender for a specific realm\\n    function denyProxy(uint256 realmId, address proxy) external;\\n\\n    // claim infused tokens\\n    function claim(ClaimInput memory input) external returns (uint256);\\n\\n    // execute a batch of claims\\n    function batchClaim(ClaimInput[] memory batch) external returns (uint256);\\n\\n    // execute a batch of infusions\\n    function batchInfuse(InfuseInput[] memory batch) external returns (uint256);\\n\\n    // HyperVIBES\\n    function name() external pure returns (string memory);\\n\\n    // total amount of mined tokens\\n    function currentMinedTokens(uint256 realmId, IERC721 collection, uint256 tokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"ClaimerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"ClaimerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"CollectionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"CollectionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"infuser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"comment\",\"type\":\"string\"}],\"name\":\"Infused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"infuser\",\"type\":\"address\"}],\"name\":\"InfuserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"infuser\",\"type\":\"address\"}],\"name\":\"InfuserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"RealmCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEEL_FREE_TO_USE_HYPERVIBES_IN_ANY_WAY_YOU_WANT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"allowProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ClaimInput[]\",\"name\":\"batch\",\"type\":\"tuple[]\"}],\"name\":\"batchClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"infuser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"comment\",\"type\":\"string\"}],\"internalType\":\"struct InfuseInput[]\",\"name\":\"batch\",\"type\":\"tuple[]\"}],\"name\":\"batchInfuse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ClaimInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dailyRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minInfusionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireNftIsOwned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowMultiInfuse\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowPublicInfusion\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowPublicClaiming\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAllCollections\",\"type\":\"bool\"}],\"internalType\":\"struct RealmConstraints\",\"name\":\"constraints\",\"type\":\"tuple\"}],\"internalType\":\"struct RealmConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"infusers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"claimers\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"collections\",\"type\":\"address[]\"}],\"internalType\":\"struct CreateRealmInput\",\"name\":\"create\",\"type\":\"tuple\"}],\"name\":\"createRealm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"currentMinedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"denyProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"infuser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"comment\",\"type\":\"string\"}],\"internalType\":\"struct InfuseInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"infuse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isClaimer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCollection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isInfuser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realmId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"adminsToAdd\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adminsToRemove\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"infusersToAdd\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"infusersToRemove\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"claimersToAdd\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"claimersToRemove\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"collectionsToAdd\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"collectionsToRemove\",\"type\":\"address[]\"}],\"internalType\":\"struct ModifyRealmInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"modifyRealm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextRealmId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"realmConfig\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dailyRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minInfusionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireNftIsOwned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowMultiInfuse\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowPublicInfusion\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowPublicClaiming\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAllCollections\",\"type\":\"bool\"}],\"internalType\":\"struct RealmConstraints\",\"name\":\"constraints\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"HyperVIBES","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}