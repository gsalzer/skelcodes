{"status":"1","message":"OK","result":[{"SourceCode":"{\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.7;\\n\\ninterface IERC20Like {\\n\\n    function balanceOf(address account_) external view returns (uint256 balance_);\\n\\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\n\\n    function allowance(address owner_, address spender_) external view returns (uint256 allowance_);\\n\\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\\n\\n    function transferFrom(address sender_, address recipient_, uint256 amount_) external returns (bool success_);\\n\\n}\\n\"},\"ITokenVesting.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.7;\\n\\ninterface ITokenVesting {\\n\\n    /**************************/\\n    /*** Contract Ownership ***/\\n    /**************************/\\n\\n    event OwnershipTransferPending(address indexed owner, address indexed pendingOwner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() external view returns (address owner_);\\n\\n    /// @dev Returns the pending owner of the contract.\\n    function pendingOwner() external view returns (address pendingOwner_);\\n\\n    /// @dev Leaves the contract without owner, and clears the pendingOwner, if any.\\n    function renounceOwnership() external;\\n\\n    /// @dev Allows a new account to take ownership of the contract.\\n    function transferOwnership(address newOwner_) external;\\n\\n    /// @dev Takes ownership of the contract.\\n    function acceptOwnership() external;\\n\\n    /*********************/\\n    /*** Token Vesting ***/\\n    /*********************/\\n\\n    /**\\n     * @dev   Is emitted when a token vesting schedule is set for a receiver.\\n     * @param receiver_ The receiver of a token vesting schedule.\\n     */\\n    event VestingScheduleSet(address indexed receiver_);\\n\\n    /**\\n     * @dev   Is emitted when the contract is funded for vesting.\\n     * @param totalTokens_ The total amount of tokens to be vested.\\n     */\\n    event VestingFunded(uint256 totalTokens_);\\n\\n    /**\\n     * @dev   Is emitted when the receiver of a token vesting schedule is changed.\\n     * @param oldReceiver The old receiver of the token vesting schedule.\\n     * @param newReceiver The new receiver of the token vesting schedule.\\n     */\\n    event ReceiverChanged(address indexed oldReceiver, address indexed newReceiver);\\n\\n    /**\\n     * @dev   Is emitted when the token vesting schedule for a receiver is killed.\\n     * @param receiver_      The receiver that had its token vesting schedule killed.\\n     * @param tokensClaimed_ The amount of tokens claimed.\\n     * @param destination_   The destination the token have been sent to.\\n     */\\n    event VestingKilled(address indexed receiver_, uint256 tokensClaimed_, address indexed destination_);\\n\\n    /**\\n     * @dev   Is emitted when a receiver claims tokens from its vesting schedule.\\n     * @param receiver_      The receiver of a token vesting schedule.\\n     * @param tokensClaimed_ The amount of tokens claimed.\\n     * @param destination_   The destination the claimed tokens have been sent to.\\n     */\\n    event TokensClaimed(address indexed receiver_, uint256 tokensClaimed_, address indexed destination_);\\n\\n    struct VestingSchedule {\\n        uint256 startTime;\\n        uint256 cliff;\\n        uint256 totalPeriods;\\n        uint256 timePerPeriod;\\n        uint256 totalTokens;\\n        uint256 tokensClaimed;\\n    }\\n\\n    /// @dev The vesting token.\\n    function token() external returns (address token_);\\n\\n    /// @dev The total amount of tokens being vested.\\n    function totalVestingsTokens() external returns (uint256 totalVestingsTokens_);\\n\\n    /**\\n     * @dev   Returns the vesting schedule of a receiver.\\n     * @param receiver_      The receiver of a vesting schedule.\\n     */\\n    function vestingScheduleOf(address receiver_) external returns (\\n        uint256 startTime_,\\n        uint256 cliff_,\\n        uint256 totalPeriods_,\\n        uint256 timePerPeriod_,\\n        uint256 totalTokens_,\\n        uint256 tokensClaimed_\\n    );\\n\\n    /**\\n     * @dev   Set the vesting schedules for some receivers, respectively.\\n     * @param receivers_ An array of receivers of vesting schedules.\\n     * @param vestings_  An array of vesting schedules.\\n     */\\n    function setVestingSchedules(address[] calldata receivers_, VestingSchedule[] calldata vestings_) external;\\n\\n    /**\\n     * @dev   Fund the contact with tokens that will be vested.\\n     * @param totalTokens_ The amount of tokens that will be supplied to this contract.\\n     */\\n    function fundVesting(uint256 totalTokens_) external;\\n\\n    /**\\n     * @dev   Change the receiver of an existing vesting schedule.\\n     * @param oldReceiver_ The old receiver address.\\n     * @param newReceiver_ The new receiver address.\\n     */\\n    function changeReceiver(address oldReceiver_, address newReceiver_) external;\\n\\n    /**\\n     * @dev    Returns the amount of claimable tokens for a receiver of a vesting schedule.\\n     * @param  receiver_        The receiver address.\\n     * @return claimableTokens_ The amount of claimable tokens.\\n     */\\n    function claimableTokens(address receiver_) external view returns (uint256 claimableTokens_);\\n\\n    /**\\n     * @dev   Claim the callers tokens of a vesting schedule.\\n     * @param destination_ The destination to send the tokens.\\n     */\\n    function claimTokens(address destination_) external;\\n\\n    /**\\n     * @dev   Kill the vesting schedule for a receiver.\\n     * @param receiver_    The receiver address.\\n     * @param destination_ The destination to send the tokens.\\n     */\\n    function killVesting(address receiver_, address destination_) external;\\n\\n    /*********************/\\n    /*** Miscellaneous ***/\\n    /*********************/\\n\\n    /**\\n     * @dev   Is emitted when some ERC20 token is recovered from the contract.\\n     * @param token       The address of the token.\\n     * @param amount      The amount of token recovered.\\n     * @param destination The destination the token was sent to.\\n     */\\n    event RecoveredToken(address indexed token, uint256 amount, address indexed destination);\\n\\n    /**\\n     * @dev   Recover tokens owned by the contract.\\n     * @param token_       The token address.\\n     * @param destination_ The destination to send the ETH.\\n     */\\n    function recoverToken(address token_, address destination_) external;\\n\\n}\\n\"},\"MockERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.7;\\n\\ncontract MockERC20 {\\n\\n    string public name;\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n        name     = name_;\\n        symbol   = symbol_;\\n        decimals = decimals_;\\n    }\\n\\n    function approve(address spender_, uint256 amount_) external returns (bool success_) {\\n        _approve(msg.sender, spender_, amount_);\\n        return true;\\n    }\\n\\n    function transfer(address to_, uint256 amount_) external returns (bool success_) {\\n        _transfer(msg.sender, to_, amount_);\\n        return true;\\n    }\\n\\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool success_) {\\n        _approve(owner_, msg.sender, allowance[owner_][msg.sender] - amount_);\\n        _transfer(owner_, recipient_, amount_);\\n        return true;\\n    }\\n\\n    function mint(address recipient_, uint256 amount_) external returns (bool success_) {\\n        _mint(recipient_, amount_);\\n        return true;\\n    }\\n\\n    function burn(address owner_, uint256 amount_) internal returns (bool success_) {\\n        _burn(owner_, amount_);\\n        return true;\\n    }\\n\\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\\n        allowance[owner_][spender_] = amount_;\\n    }\\n\\n    function _transfer(address owner_, address recipient_, uint256 amount_) internal {\\n        balanceOf[owner_] -= amount_;\\n        balanceOf[recipient_] += amount_;\\n    }\\n\\n    function _mint(address recipient_, uint256 amount_) internal {\\n        totalSupply += amount_;\\n        balanceOf[recipient_] += amount_;\\n    }\\n\\n    function _burn(address owner_, uint256 amount_) internal {\\n        balanceOf[owner_] -= amount_;\\n        totalSupply -= amount_;\\n    }\\n\\n}\\n\"},\"TokenVesting.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.7;\\n\\n// TODO: There is an issue where the sum of all vestingSchedule totalTokens is less than totalVestingsTokens.\\n// NOTE: Excess of totalVestingsTokens, after paying out all totalTokens, requires awkward immediate vesting schedule to withdraw.\\n\\nimport { IERC20Like } from \\\"./Interfaces.sol\\\";\\nimport { ITokenVesting } from \\\"./ITokenVesting.sol\\\";\\n\\ncontract TokenVesting is ITokenVesting {\\n\\n    address public override owner;\\n    address public override pendingOwner;\\n\\n    address public override token;\\n    uint256 public override totalVestingsTokens;\\n\\n    mapping(address =\\u003e VestingSchedule) public override vestingScheduleOf;\\n\\n    /**\\n     * @dev   Constructor.\\n     * @param token_ The address of an erc20 token.\\n     */\\n    constructor(address token_) {\\n        owner = msg.sender;\\n        token = token_;\\n    }\\n\\n    /**************************/\\n    /*** Contract Ownership ***/\\n    /**************************/\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"TV:NOT_OWNER\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() external override onlyOwner {\\n        pendingOwner = owner = address(0);\\n\\n        emit OwnershipTransferred(msg.sender, address(0));\\n    }\\n\\n    function transferOwnership(address newOwner_) external override onlyOwner {\\n        pendingOwner = newOwner_;\\n\\n        emit OwnershipTransferPending(msg.sender, newOwner_);\\n    }\\n\\n    function acceptOwnership() external override {\\n        require(pendingOwner == msg.sender, \\\"TV:NOT_PENDING_OWNER\\\");\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n\\n        owner = msg.sender;\\n        pendingOwner = address(0);\\n    }\\n\\n    /*********************/\\n    /*** Token Vesting ***/\\n    /*********************/\\n\\n    function setVestingSchedules(address[] calldata receivers_, VestingSchedule[] calldata vestingSchedules_) external override onlyOwner {\\n        for (uint256 i; i \\u003c vestingSchedules_.length; ++i) {\\n            address receiver = receivers_[i];\\n\\n            vestingScheduleOf[receiver] = vestingSchedules_[i];\\n\\n            emit VestingScheduleSet(receiver);\\n        }\\n    }\\n\\n    function fundVesting(uint256 totalTokens_) external override onlyOwner {\\n        require(totalVestingsTokens == uint256(0), \\\"TV:ALREADY_FUNDED\\\");\\n\\n        _safeTransferFrom(token, msg.sender, address(this), totalTokens_);\\n\\n        totalVestingsTokens = totalTokens_;\\n\\n        emit VestingFunded(totalTokens_);\\n    }\\n\\n    function changeReceiver(address oldReceiver_, address newReceiver_) external override onlyOwner {\\n        // Swap old and new receivers\\u0027 vesting schedule, using address(0) as a scratch space.\\n        // This is done to not overwrite an active vesting schedule.\\n        vestingScheduleOf[address(0)] = vestingScheduleOf[oldReceiver_];\\n        vestingScheduleOf[oldReceiver_] = vestingScheduleOf[newReceiver_];\\n        vestingScheduleOf[newReceiver_] = vestingScheduleOf[address(0)];\\n\\n        delete vestingScheduleOf[address(0)];\\n\\n        emit ReceiverChanged(oldReceiver_, newReceiver_);\\n    }\\n\\n    function claimableTokens(address receiver_) public view override returns (uint256 claimableTokens_) {\\n        VestingSchedule storage vestingSchedule = vestingScheduleOf[receiver_];\\n\\n        uint256 totalPeriods = vestingSchedule.totalPeriods;\\n\\n        if (totalPeriods == uint256(0)) return uint256(0);\\n\\n        uint256 timePassed = block.timestamp - vestingSchedule.startTime;\\n        uint256 cliff = vestingSchedule.cliff;\\n\\n        if (timePassed \\u003c= cliff) return uint256(0);\\n\\n        uint256 multiplier = (timePassed - cliff) / vestingSchedule.timePerPeriod;\\n\\n        return\\n            (\\n                (\\n                    (\\n                        multiplier \\u003e totalPeriods ? totalPeriods : multiplier\\n                    )\\n                    * vestingSchedule.totalTokens\\n                )\\n                / totalPeriods\\n            )\\n            - vestingSchedule.tokensClaimed;\\n    }\\n\\n    function claimTokens(address destination_) external override {\\n        require(totalVestingsTokens \\u003e uint256(0), \\\"TV:NOT_FUNDED\\\");\\n\\n        VestingSchedule storage vestingSchedule = vestingScheduleOf[msg.sender];\\n\\n        uint256 tokensToClaim = claimableTokens(msg.sender);\\n\\n        require(tokensToClaim \\u003e uint256(0), \\\"TV:NO_CLAIMABLE\\\");\\n\\n        // NOTE: Setting tokensClaimed before transfer will result in no additional transfer on a reentrance.\\n        vestingSchedule.tokensClaimed += tokensToClaim;\\n\\n        _safeTransfer(token, destination_, tokensToClaim);\\n\\n        emit TokensClaimed(msg.sender, tokensToClaim, destination_);\\n    }\\n\\n    function killVesting(address receiver_, address destination_) external override onlyOwner {\\n        VestingSchedule storage vestingSchedule = vestingScheduleOf[receiver_];\\n\\n        uint256 totalTokens = vestingSchedule.totalTokens;\\n        uint256 tokensToClaim = totalTokens - vestingSchedule.tokensClaimed;\\n\\n        // NOTE: Setting tokensClaimed before transfer will result in no additional transfer on a reentrance.\\n        vestingScheduleOf[receiver_].tokensClaimed = totalTokens;\\n\\n        _safeTransfer(token, destination_, tokensToClaim);\\n\\n        emit VestingKilled(receiver_, tokensToClaim, destination_);\\n    }\\n\\n    /*********************/\\n    /*** Miscellaneous ***/\\n    /*********************/\\n\\n    function recoverToken(address token_, address destination_) external override onlyOwner {\\n        require(token_ != token, \\\"TV:CANNOT_RECOVER_VESTING_TOKEN\\\");\\n\\n        uint256 amount = IERC20Like(token_).balanceOf(address(this));\\n\\n        require(amount \\u003e uint256(0), \\\"TV:NO_TOKEN\\\");\\n\\n        _safeTransfer(token_, destination_, amount);\\n\\n        emit RecoveredToken(token_, amount, destination_);\\n    }\\n\\n    /******************/\\n    /*** Safe ERC20 ***/\\n    /******************/\\n\\n    function _safeTransfer(address token_, address to_, uint256 amount_) internal {\\n        ( bool success, bytes memory data ) = token_.call(abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\\n\\n        require(success \\u0026\\u0026 (data.length == uint256(0) || abi.decode(data, (bool))), \\u0027TV:SAFE_TRANSFER_FAILED\\u0027);\\n    }\\n\\n    function _safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\\n        ( bool success, bytes memory data ) = token_.call(abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\\n\\n        require(success \\u0026\\u0026 (data.length == uint256(0) || abi.decode(data, (bool))), \\u0027TV:SAFE_TRANSFER_FROM_FAILED\\u0027);\\n    }\\n\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldReceiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"ReceiverChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"RecoveredToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensClaimed_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTokens_\",\"type\":\"uint256\"}],\"name\":\"VestingFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensClaimed_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"name\":\"VestingKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"}],\"name\":\"VestingScheduleSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldReceiver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newReceiver_\",\"type\":\"address\"}],\"name\":\"changeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"}],\"name\":\"claimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimableTokens_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTokens_\",\"type\":\"uint256\"}],\"name\":\"fundVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"name\":\"killVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"receivers_\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPeriods\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePerPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensClaimed\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenVesting.VestingSchedule[]\",\"name\":\"vestingSchedules_\",\"type\":\"tuple[]\"}],\"name\":\"setVestingSchedules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVestingsTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestingScheduleOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPeriods\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePerPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenVesting","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000072b886d09c117654ab7da13a14d603001de0b777","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0a7e41f1fad3425402689cc124e4aa986f30dace2948c3a804f2a0491906c017"}]}