{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        uint256 currentAllowance = allowance(account, _msgSender());\r\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(account, _msgSender(), currentAllowance - amount);\r\n        }\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/Rng.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title A pseudo random number generator\r\n *\r\n * @dev This is not a true random number generator because smart contracts must be deterministic (every node a transaction goes to must produce the same result).\r\n *      True randomness requires an oracle which is both expensive in terms of gas and would take a critical part of the project off the chain.\r\n */\r\nstruct Rng {\r\n    bytes32 state;\r\n}\r\n\r\n/**\r\n * @title A library for working with the Rng struct.\r\n *\r\n * @dev Rng cannot be a contract because then anyone could manipulate it by generating random numbers.\r\n */\r\nlibrary RngLibrary {\r\n    /**\r\n     * Creates a new Rng.\r\n     */\r\n    function newRng() internal view returns (Rng memory) {\r\n        return Rng(getEntropy());\r\n    }\r\n\r\n    /**\r\n     * Creates a pseudo-random value from the current block miner's address and sender.\r\n     */\r\n    function getEntropy() internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(block.coinbase, msg.sender));\r\n    }\r\n\r\n    /**\r\n     * Generates a random uint256.\r\n     */\r\n    function generate(Rng memory self) internal view returns (uint256) {\r\n        self.state = keccak256(abi.encodePacked(getEntropy(), self.state));\r\n        return uint256(self.state);\r\n    }\r\n\r\n    /**\r\n     * Generates a random uint256 from min to max inclusive.\r\n     *\r\n     * @dev This function is not subject to modulo bias.\r\n     *      The chance that this function has to reroll is astronomically unlikely, but it can theoretically reroll forever.\r\n     */\r\n    function generate(Rng memory self, uint min, uint max) internal view returns (uint256) {\r\n        require(min <= max, \"min > max\");\r\n\r\n        uint delta = max - min;\r\n\r\n        if (delta == 0) {\r\n            return min;\r\n        }\r\n\r\n        return generate(self) % (delta + 1) + min;\r\n    }\r\n}\r\n\r\n// File: contracts/Rarities.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Rarities {\r\n    function dominant() internal pure returns (uint16[8] memory ret) {\r\n        ret = [\r\n            2500,\r\n            2200,\r\n            1900,\r\n            1300,\r\n            800,\r\n            600,\r\n            400,\r\n            300\r\n        ];\r\n    }\r\n    \r\n    function recessive() internal pure returns (uint16[6] memory ret) {\r\n        ret = [\r\n            4000,\r\n            2500,\r\n            1500,\r\n            1000,\r\n            600,\r\n            400\r\n        ];\r\n    }\r\n    \r\n    function outfit() internal pure returns (uint16[27] memory ret) {\r\n        ret = [\r\n            700,\r\n            700,\r\n            700,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            500,\r\n            500,\r\n            400,\r\n            400,\r\n            300,\r\n            200,\r\n            200,\r\n            100,\r\n            100,\r\n            100,\r\n            75,\r\n            50,\r\n            50,\r\n            50,\r\n            50,\r\n            25\r\n        ];\r\n    }\r\n    \r\n    function handaccessory() internal pure returns (uint16[16] memory ret) {\r\n        ret = [\r\n            5000,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            510,\r\n            500,\r\n            500,\r\n            300,\r\n            300,\r\n            150,\r\n            100,\r\n            100,\r\n            75,\r\n            40,\r\n            25\r\n        ];\r\n    }\r\n    \r\n    function mouth() internal pure returns (uint16[22] memory ret) {\r\n        ret = [\r\n            2000,\r\n            1000,\r\n            1000,\r\n            1000,\r\n            700,\r\n            700,\r\n            700,\r\n            700,\r\n            400,\r\n            300,\r\n            300,\r\n            300,\r\n            175,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            75,\r\n            75,\r\n            50,\r\n            25\r\n        ];\r\n    }\r\n    \r\n    function eyes() internal pure returns (uint16[24] memory ret) {\r\n        ret = [\r\n            2500,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            600,\r\n            400,\r\n            400,\r\n            400,\r\n            400,\r\n            400,\r\n            400,\r\n            400,\r\n            400,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            75,\r\n            75,\r\n            75,\r\n            50,\r\n            25\r\n        ];\r\n    }\r\n    \r\n    function headaccessory() internal pure returns (uint16[29] memory ret) {\r\n        ret = [\r\n            3000,\r\n            500,\r\n            500,\r\n            500,\r\n            500,\r\n            500,\r\n            500,\r\n            500,\r\n            500,\r\n            400,\r\n            300,\r\n            300,\r\n            200,\r\n            200,\r\n            200,\r\n            200,\r\n            200,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            100,\r\n            75,\r\n            50,\r\n            50,\r\n            25\r\n        ];\r\n    }\r\n}\r\n// File: contracts/Enums.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nenum RerollTrait {\r\n    BgColor,\r\n    Outfit,\r\n    HandAccessory,\r\n    Mouth,\r\n    Eyes,\r\n    HeadAccessory\r\n}\r\n\r\nenum Special {\r\n    NONE,\r\n    DEVIL,\r\n    GHOST,\r\n    HIPPIE,\r\n    JOKER,\r\n    PRISONER,\r\n    SQUID_GAME,\r\n    WHERES_WALDO,\r\n    HAZMAT,\r\n    ASTRONAUT\r\n}\r\n\r\nenum Dominant {\r\n    SKELETON,\r\n    VAMPIRE,\r\n    MUMMY,\r\n    GHOST,\r\n    WITCH,\r\n    FRANKENSTEIN,\r\n    WEREWOLF,\r\n    PUMPKINHEAD\r\n}\r\n\r\nenum Recessive {\r\n    SKELETON,\r\n    VAMPIRE,\r\n    MUMMY,\r\n    GHOST,\r\n    DEVIL,\r\n    KONG\r\n}\r\n\r\nenum BgColor {\r\n    DARK_BLUE,\r\n    GRAY,\r\n    LIGHT_BLUE,\r\n    ORANGE,\r\n    PINK,\r\n    PURPLE,\r\n    RED,\r\n    TAN,\r\n    TEAL,\r\n    GREEN,\r\n    RAINBOW\r\n}\r\n\r\nenum Outfit {\r\n    WHITE_SHORTS,\r\n    PINK_SHORTS,\r\n    GRAY_PANTS,\r\n    WHITE_AND_BLUE,\r\n    PURPLE_SHORTS,\r\n    PINK_AND_PURPLE,\r\n    BROWN_AND_WHITE,\r\n    BROWN_AND_BLUE,\r\n    BLUE_SHORTS,\r\n    BLUE_AND_WHITE,\r\n    UNDERGARMENTS,\r\n    LOUNGEWEAR,\r\n    HOBO,\r\n    SPORTS_JERSEY,\r\n    GOLD_CHAIN,\r\n    PAJAMAS,\r\n    OVERALLS,\r\n    SPEEDO,\r\n    NINJA_SUIT,\r\n    KARATE_UNIFORM,\r\n    NONE,\r\n    LUMBERJACK,\r\n    PRIEST,\r\n    TUX,\r\n    SKELETON,\r\n    CAMO,\r\n    ARMOR\r\n}\r\n\r\nenum HandAccessory {\r\n    NONE,\r\n    BLOODY_KNIFE,\r\n    BOW_AND_ARROW,\r\n    SWORD,\r\n    PITCHFORK,\r\n    WAND,\r\n    SPIKED_BASEBALL_BAT,\r\n    ENERGY_DRINK,\r\n    NINJA_STARS,\r\n    NUNCHUCKS,\r\n    POOP,\r\n    FLAMETHROWER,\r\n    HOOKS,\r\n    WEIGHTS,\r\n    SKULL,\r\n    BRAIN\r\n}\r\n\r\nenum Mouth {\r\n    NONE,\r\n    HAPPY,\r\n    MAD,\r\n    SMILE,\r\n    FANGS,\r\n    HAPPY_FANGS,\r\n    MAD_FANGS,\r\n    SMILE_FANGS,\r\n    SINGLE_TOOTH,\r\n    DIRTY_TEETH,\r\n    SMILE_DIRTY_TEETH,\r\n    MAD_DIRTY_TEETH,\r\n    BLOODY_FANGS,\r\n    BLACK_MASK,\r\n    HAPPY_BUCK_TEETH,\r\n    HAPPY_SINGLE_TOOTH,\r\n    MAD_SINGLE_TOOTH,\r\n    SMILE_SINGLE_TOOTH,\r\n    BREATHING_FIRE,\r\n    GOLD_GRILLS,\r\n    KISS,\r\n    SMOKING_JOINT\r\n}\r\n\r\nenum Eyes {\r\n    NONE,\r\n    BLACK_EYE,\r\n    BLACKOUT,\r\n    BLEEDING,\r\n    BLOODSHOT,\r\n    WATERY,\r\n    WHITE,\r\n    BIGGER_BLACK_EYES,\r\n    BIGGER_BLEEDING,\r\n    BIGGER_WATERY,\r\n    SMALLER_BLACK_EYES,\r\n    SMALLER_BLEEDING,\r\n    SMALLER_BLOODSHOT,\r\n    SMALLER_WATERY,\r\n    SMALLER,\r\n    SUNGLASSES,\r\n    EYE_PATCH,\r\n    VR_HEADSET,\r\n    DEAD,\r\n    _3D_GLASSES,\r\n    HEART_EYES,\r\n    LASER_GLASSES,\r\n    NINJA_MASK,\r\n    LASER_EYES\r\n}\r\n\r\nenum HeadAccessory {\r\n    NONE,\r\n    BUCKET_HAT,\r\n    FLOWER,\r\n    SPORTS_HEADBAND,\r\n    CHEF_HAT,\r\n    BLUE_DURAG,\r\n    RED_DURAG,\r\n    SPIKY_HAIR,\r\n    BONES,\r\n    RICE_HAT,\r\n    BEANIE_CAP,\r\n    SANTA_HAT,\r\n    HEAD_WOUND,\r\n    HEADPHONES,\r\n    GOLD_STUDS,\r\n    WIZARD_HAT,\r\n    LONG_HAIR,\r\n    AIR_PODS,\r\n    WHITE_PARTY_HAT,\r\n    BLUE_PARTY_HAT,\r\n    RED_PARTY_HAT,\r\n    GREEN_PARTY_HAT,\r\n    YELLOW_PARTY_HAT,\r\n    PURPLE_PARTY_HAT,\r\n    PIRATE_HAT,\r\n    KING_CROWN,\r\n    JOKER_HAT,\r\n    DEVIL_HORNS,\r\n    BRAINS\r\n}\r\n\r\nlibrary Enums {\r\n    function toString(Special v) external pure returns (string memory) {\r\n        if (v == Special.NONE) {\r\n            return \"\";\r\n        }\r\n    \r\n        if (v == Special.DEVIL) {\r\n            return \"Devil\";\r\n        }\r\n    \r\n        if (v == Special.GHOST) {\r\n            return \"Ghost\";\r\n        }\r\n    \r\n        if (v == Special.HIPPIE) {\r\n            return \"Hippie\";\r\n        }\r\n    \r\n        if (v == Special.JOKER) {\r\n            return \"Society\";\r\n        }\r\n    \r\n        if (v == Special.PRISONER) {\r\n            return \"Prisoner\";\r\n        }\r\n    \r\n        if (v == Special.SQUID_GAME) {\r\n            return \"Squid Girl\";\r\n        }\r\n    \r\n        if (v == Special.WHERES_WALDO) {\r\n            return \"Where's Waldo?\";\r\n        }\r\n    \r\n        if (v == Special.HAZMAT) {\r\n            return \"Hazmat\";\r\n        }\r\n    \r\n        if (v == Special.ASTRONAUT) {\r\n            return \"Astronaut\";\r\n        }\r\n        revert(\"invalid special\");\r\n    }\r\n    \r\n    function toString(Dominant v) external pure returns (string memory) {\r\n        if (v == Dominant.SKELETON) {\r\n            return \"Skeleton\";\r\n        }\r\n    \r\n        if (v == Dominant.VAMPIRE) {\r\n            return \"Vampire\";\r\n        }\r\n    \r\n        if (v == Dominant.MUMMY) {\r\n            return \"Mummy\";\r\n        }\r\n    \r\n        if (v == Dominant.GHOST) {\r\n            return \"Ghost\";\r\n        }\r\n    \r\n        if (v == Dominant.WITCH) {\r\n            return \"Witch\";\r\n        }\r\n    \r\n        if (v == Dominant.FRANKENSTEIN) {\r\n            return \"Frankenstein\";\r\n        }\r\n    \r\n        if (v == Dominant.WEREWOLF) {\r\n            return \"Werewolf\";\r\n        }\r\n    \r\n        if (v == Dominant.PUMPKINHEAD) {\r\n            return \"Pumpkinhead\";\r\n        }\r\n        revert(\"invalid dominant\");\r\n    }\r\n    \r\n    function toString(Recessive v) external pure returns (string memory) {\r\n        if (v == Recessive.SKELETON) {\r\n            return \"Skeleton\";\r\n        }\r\n    \r\n        if (v == Recessive.VAMPIRE) {\r\n            return \"Vampire\";\r\n        }\r\n    \r\n        if (v == Recessive.MUMMY) {\r\n            return \"Mummy\";\r\n        }\r\n    \r\n        if (v == Recessive.GHOST) {\r\n            return \"Ghost\";\r\n        }\r\n    \r\n        if (v == Recessive.DEVIL) {\r\n            return \"Devil\";\r\n        }\r\n    \r\n        if (v == Recessive.KONG) {\r\n            return \"Kong\";\r\n        }\r\n        revert(\"invalid recessive\");\r\n    }\r\n    \r\n    function toString(BgColor v) external pure returns (string memory) {\r\n        if (v == BgColor.DARK_BLUE) {\r\n            return \"Dark Blue\";\r\n        }\r\n    \r\n        if (v == BgColor.GRAY) {\r\n            return \"Gray\";\r\n        }\r\n    \r\n        if (v == BgColor.LIGHT_BLUE) {\r\n            return \"Light Blue\";\r\n        }\r\n    \r\n        if (v == BgColor.ORANGE) {\r\n            return \"Orange\";\r\n        }\r\n    \r\n        if (v == BgColor.PINK) {\r\n            return \"Pink\";\r\n        }\r\n    \r\n        if (v == BgColor.PURPLE) {\r\n            return \"Purple\";\r\n        }\r\n    \r\n        if (v == BgColor.RED) {\r\n            return \"Red\";\r\n        }\r\n    \r\n        if (v == BgColor.TAN) {\r\n            return \"Tan\";\r\n        }\r\n    \r\n        if (v == BgColor.TEAL) {\r\n            return \"Teal\";\r\n        }\r\n    \r\n        if (v == BgColor.GREEN) {\r\n            return \"Green\";\r\n        }\r\n    \r\n        if (v == BgColor.RAINBOW) {\r\n            return \"Rainbow\";\r\n        }\r\n        revert(\"invalid bgcolor\");\r\n    }\r\n    \r\n    function toString(Outfit v) external pure returns (string memory) {\r\n        if (v == Outfit.WHITE_SHORTS) {\r\n            return \"White Shorts\";\r\n        }\r\n    \r\n        if (v == Outfit.PINK_SHORTS) {\r\n            return \"Pink Shorts\";\r\n        }\r\n    \r\n        if (v == Outfit.GRAY_PANTS) {\r\n            return \"Gray Pants\";\r\n        }\r\n    \r\n        if (v == Outfit.WHITE_AND_BLUE) {\r\n            return \"White and Blue\";\r\n        }\r\n    \r\n        if (v == Outfit.PURPLE_SHORTS) {\r\n            return \"Purple Shorts\";\r\n        }\r\n    \r\n        if (v == Outfit.PINK_AND_PURPLE) {\r\n            return \"Pink and Purple\";\r\n        }\r\n    \r\n        if (v == Outfit.BROWN_AND_WHITE) {\r\n            return \"Brown and White\";\r\n        }\r\n    \r\n        if (v == Outfit.BROWN_AND_BLUE) {\r\n            return \"Brown and Blue\";\r\n        }\r\n    \r\n        if (v == Outfit.BLUE_SHORTS) {\r\n            return \"Blue Shorts\";\r\n        }\r\n    \r\n        if (v == Outfit.BLUE_AND_WHITE) {\r\n            return \"Blue and White\";\r\n        }\r\n    \r\n        if (v == Outfit.UNDERGARMENTS) {\r\n            return \"Undergarments\";\r\n        }\r\n    \r\n        if (v == Outfit.LOUNGEWEAR) {\r\n            return \"Loungewear\";\r\n        }\r\n    \r\n        if (v == Outfit.HOBO) {\r\n            return \"Hobo\";\r\n        }\r\n    \r\n        if (v == Outfit.SPORTS_JERSEY) {\r\n            return \"Sports Jersey\";\r\n        }\r\n    \r\n        if (v == Outfit.GOLD_CHAIN) {\r\n            return \"Gold Chain\";\r\n        }\r\n    \r\n        if (v == Outfit.PAJAMAS) {\r\n            return \"Pajamas\";\r\n        }\r\n    \r\n        if (v == Outfit.OVERALLS) {\r\n            return \"Overalls\";\r\n        }\r\n    \r\n        if (v == Outfit.SPEEDO) {\r\n            return \"Speedo\";\r\n        }\r\n    \r\n        if (v == Outfit.NINJA_SUIT) {\r\n            return \"Ninja Suit\";\r\n        }\r\n    \r\n        if (v == Outfit.KARATE_UNIFORM) {\r\n            return \"Karate Uniform\";\r\n        }\r\n    \r\n        if (v == Outfit.NONE) {\r\n            return \"\";\r\n        }\r\n    \r\n        if (v == Outfit.LUMBERJACK) {\r\n            return \"Lumberjack\";\r\n        }\r\n    \r\n        if (v == Outfit.PRIEST) {\r\n            return \"Priest\";\r\n        }\r\n    \r\n        if (v == Outfit.TUX) {\r\n            return \"Tux\";\r\n        }\r\n    \r\n        if (v == Outfit.SKELETON) {\r\n            return \"Skeleton\";\r\n        }\r\n    \r\n        if (v == Outfit.CAMO) {\r\n            return \"Camo\";\r\n        }\r\n    \r\n        if (v == Outfit.ARMOR) {\r\n            return \"Armor\";\r\n        }\r\n        revert(\"invalid outfit\");\r\n    }\r\n    \r\n    function toString(HandAccessory v) external pure returns (string memory) {\r\n        if (v == HandAccessory.NONE) {\r\n            return \"\";\r\n        }\r\n    \r\n        if (v == HandAccessory.BLOODY_KNIFE) {\r\n            return \"Bloody Knife\";\r\n        }\r\n    \r\n        if (v == HandAccessory.BOW_AND_ARROW) {\r\n            return \"Bow and Arrow\";\r\n        }\r\n    \r\n        if (v == HandAccessory.SWORD) {\r\n            return \"Sword\";\r\n        }\r\n    \r\n        if (v == HandAccessory.PITCHFORK) {\r\n            return \"Pitchfork\";\r\n        }\r\n    \r\n        if (v == HandAccessory.WAND) {\r\n            return \"Wand\";\r\n        }\r\n    \r\n        if (v == HandAccessory.SPIKED_BASEBALL_BAT) {\r\n            return \"Spiked Baseball Bat\";\r\n        }\r\n    \r\n        if (v == HandAccessory.ENERGY_DRINK) {\r\n            return \"Energy Drink\";\r\n        }\r\n    \r\n        if (v == HandAccessory.NINJA_STARS) {\r\n            return \"Ninja Stars\";\r\n        }\r\n    \r\n        if (v == HandAccessory.NUNCHUCKS) {\r\n            return \"Nunchucks\";\r\n        }\r\n    \r\n        if (v == HandAccessory.POOP) {\r\n            return \"Poop\";\r\n        }\r\n    \r\n        if (v == HandAccessory.FLAMETHROWER) {\r\n            return \"Flamethrower\";\r\n        }\r\n    \r\n        if (v == HandAccessory.HOOKS) {\r\n            return \"Hooks\";\r\n        }\r\n    \r\n        if (v == HandAccessory.WEIGHTS) {\r\n            return \"Weights\";\r\n        }\r\n    \r\n        if (v == HandAccessory.SKULL) {\r\n            return \"Skull\";\r\n        }\r\n    \r\n        if (v == HandAccessory.BRAIN) {\r\n            return \"Brain\";\r\n        }\r\n        revert(\"invalid handaccessory\");\r\n    }\r\n    \r\n    function toString(Mouth v) external pure returns (string memory) {\r\n        if (v == Mouth.NONE) {\r\n            return \"\";\r\n        }\r\n    \r\n        if (v == Mouth.HAPPY) {\r\n            return \"Happy\";\r\n        }\r\n    \r\n        if (v == Mouth.MAD) {\r\n            return \"Mad\";\r\n        }\r\n    \r\n        if (v == Mouth.SMILE) {\r\n            return \"Smile\";\r\n        }\r\n    \r\n        if (v == Mouth.FANGS) {\r\n            return \"Fangs\";\r\n        }\r\n    \r\n        if (v == Mouth.HAPPY_FANGS) {\r\n            return \"Happy Fangs\";\r\n        }\r\n    \r\n        if (v == Mouth.MAD_FANGS) {\r\n            return \"Mad Fangs\";\r\n        }\r\n    \r\n        if (v == Mouth.SMILE_FANGS) {\r\n            return \"Smile Fangs\";\r\n        }\r\n    \r\n        if (v == Mouth.SINGLE_TOOTH) {\r\n            return \"Single Tooth\";\r\n        }\r\n    \r\n        if (v == Mouth.DIRTY_TEETH) {\r\n            return \"Dirty Teeth\";\r\n        }\r\n    \r\n        if (v == Mouth.SMILE_DIRTY_TEETH) {\r\n            return \"Smile Dirty Teeth\";\r\n        }\r\n    \r\n        if (v == Mouth.MAD_DIRTY_TEETH) {\r\n            return \"Mad Dirty Teeth\";\r\n        }\r\n    \r\n        if (v == Mouth.BLOODY_FANGS) {\r\n            return \"Bloody Fangs\";\r\n        }\r\n    \r\n        if (v == Mouth.BLACK_MASK) {\r\n            return \"Black Mask\";\r\n        }\r\n    \r\n        if (v == Mouth.HAPPY_BUCK_TEETH) {\r\n            return \"Happy Buck Teeth\";\r\n        }\r\n    \r\n        if (v == Mouth.HAPPY_SINGLE_TOOTH) {\r\n            return \"Happy Single Tooth\";\r\n        }\r\n    \r\n        if (v == Mouth.MAD_SINGLE_TOOTH) {\r\n            return \"Mad Single Tooth\";\r\n        }\r\n    \r\n        if (v == Mouth.SMILE_SINGLE_TOOTH) {\r\n            return \"Smile Single Tooth\";\r\n        }\r\n    \r\n        if (v == Mouth.BREATHING_FIRE) {\r\n            return \"Breathing Fire\";\r\n        }\r\n    \r\n        if (v == Mouth.GOLD_GRILLS) {\r\n            return \"Gold Grills\";\r\n        }\r\n    \r\n        if (v == Mouth.KISS) {\r\n            return \"Kiss\";\r\n        }\r\n    \r\n        if (v == Mouth.SMOKING_JOINT) {\r\n            return \"Smoking Joint\";\r\n        }\r\n        revert(\"invalid mouth\");\r\n    }\r\n    \r\n    function toString(Eyes v) external pure returns (string memory) {\r\n        if (v == Eyes.NONE) {\r\n            return \"\";\r\n        }\r\n    \r\n        if (v == Eyes.BLACK_EYE) {\r\n            return \"Black Eye\";\r\n        }\r\n    \r\n        if (v == Eyes.BLACKOUT) {\r\n            return \"Blackout\";\r\n        }\r\n    \r\n        if (v == Eyes.BLEEDING) {\r\n            return \"Bleeding\";\r\n        }\r\n    \r\n        if (v == Eyes.BLOODSHOT) {\r\n            return \"Bloodshot\";\r\n        }\r\n    \r\n        if (v == Eyes.WATERY) {\r\n            return \"Watery\";\r\n        }\r\n    \r\n        if (v == Eyes.WHITE) {\r\n            return \"White\";\r\n        }\r\n    \r\n        if (v == Eyes.BIGGER_BLACK_EYES) {\r\n            return \"Bigger Black Eyes\";\r\n        }\r\n    \r\n        if (v == Eyes.BIGGER_BLEEDING) {\r\n            return \"Bigger Bleeding\";\r\n        }\r\n    \r\n        if (v == Eyes.BIGGER_WATERY) {\r\n            return \"Bigger Watery\";\r\n        }\r\n    \r\n        if (v == Eyes.SMALLER_BLACK_EYES) {\r\n            return \"Smaller Black Eyes\";\r\n        }\r\n    \r\n        if (v == Eyes.SMALLER_BLEEDING) {\r\n            return \"Smaller Bleeding\";\r\n        }\r\n    \r\n        if (v == Eyes.SMALLER_BLOODSHOT) {\r\n            return \"Smaller Bloodshot\";\r\n        }\r\n    \r\n        if (v == Eyes.SMALLER_WATERY) {\r\n            return \"Smaller Watery\";\r\n        }\r\n    \r\n        if (v == Eyes.SMALLER) {\r\n            return \"Smaller\";\r\n        }\r\n    \r\n        if (v == Eyes.SUNGLASSES) {\r\n            return \"Sunglasses\";\r\n        }\r\n    \r\n        if (v == Eyes.EYE_PATCH) {\r\n            return \"Eye Patch\";\r\n        }\r\n    \r\n        if (v == Eyes.VR_HEADSET) {\r\n            return \"VR Headset\";\r\n        }\r\n    \r\n        if (v == Eyes.DEAD) {\r\n            return \"Dead\";\r\n        }\r\n    \r\n        if (v == Eyes._3D_GLASSES) {\r\n            return \"3D Glasses\";\r\n        }\r\n    \r\n        if (v == Eyes.HEART_EYES) {\r\n            return \"Heart Eyes\";\r\n        }\r\n    \r\n        if (v == Eyes.LASER_GLASSES) {\r\n            return \"Laser Glasses\";\r\n        }\r\n    \r\n        if (v == Eyes.NINJA_MASK) {\r\n            return \"Ninja Mask\";\r\n        }\r\n    \r\n        if (v == Eyes.LASER_EYES) {\r\n            return \"Laser Eyes\";\r\n        }\r\n        revert(\"invalid eyes\");\r\n    }\r\n    \r\n    function toString(HeadAccessory v) external pure returns (string memory) {\r\n        if (v == HeadAccessory.NONE) {\r\n            return \"\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.BUCKET_HAT) {\r\n            return \"Bucket Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.FLOWER) {\r\n            return \"Flower\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.SPORTS_HEADBAND) {\r\n            return \"Sports Headband\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.CHEF_HAT) {\r\n            return \"Chef Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.BLUE_DURAG) {\r\n            return \"Blue Durag\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.RED_DURAG) {\r\n            return \"Red Durag\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.SPIKY_HAIR) {\r\n            return \"Spiky Hair\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.BONES) {\r\n            return \"Bones\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.RICE_HAT) {\r\n            return \"Rice Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.BEANIE_CAP) {\r\n            return \"Beanie Cap\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.SANTA_HAT) {\r\n            return \"Santa Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.HEAD_WOUND) {\r\n            return \"Head Wound\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.HEADPHONES) {\r\n            return \"Headphones\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.GOLD_STUDS) {\r\n            return \"Gold Studs\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.WIZARD_HAT) {\r\n            return \"Wizard Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.LONG_HAIR) {\r\n            return \"Long Hair\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.AIR_PODS) {\r\n            return \"Air Pods\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.WHITE_PARTY_HAT) {\r\n            return \"White Party Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.BLUE_PARTY_HAT) {\r\n            return \"Blue Party Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.RED_PARTY_HAT) {\r\n            return \"Red Party Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.GREEN_PARTY_HAT) {\r\n            return \"Green Party Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.YELLOW_PARTY_HAT) {\r\n            return \"Yellow Party Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.PURPLE_PARTY_HAT) {\r\n            return \"Purple Party Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.PIRATE_HAT) {\r\n            return \"Pirate Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.KING_CROWN) {\r\n            return \"King Crown\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.JOKER_HAT) {\r\n            return \"Joker Hat\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.DEVIL_HORNS) {\r\n            return \"Devil Horns\";\r\n        }\r\n    \r\n        if (v == HeadAccessory.BRAINS) {\r\n            return \"Brains\";\r\n        }\r\n        revert(\"invalid headaccessory\");\r\n    }\r\n}\r\n\r\n// File: contracts/BitMonster.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nstruct BitMonster {\r\n    bool genesis;\r\n    bool superYield;\r\n    Special special;\r\n    Dominant dominant;\r\n    Recessive recessive;\r\n    BgColor bgColor;\r\n    Outfit outfit;\r\n    HandAccessory handAccessory;\r\n    Mouth mouth;\r\n    Eyes eyes;\r\n    HeadAccessory headAccessory;\r\n}\r\n\r\n// File: contracts/IBitMonsters.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface IBitMonsters is IERC721Enumerable {\r\n    function getBitMonster(uint256 tokenId) external view returns (BitMonster memory);\r\n    function setBitMonster(uint256 tokenId, BitMonster memory bm) external;\r\n    function createBitMonster(BitMonster memory bm, address owner) external;\r\n    function isAdmin(address addr) external view returns (bool);\r\n}\r\n// File: contracts/BitMonstersAddon.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title A contract should inherit this if it provides functionality for the Bit Monsters contract.\r\n */\r\nabstract contract BitMonstersAddon is Ownable {\r\n    IBitMonsters internal bitMonsters;\r\n\r\n    modifier onlyAdmin() {\r\n        require(bitMonsters.isAdmin(msg.sender), \"admins only\");\r\n        _;\r\n    }\r\n\r\n    modifier ownsToken(uint tokenId) {\r\n        require(bitMonsters.ownerOf(tokenId) == msg.sender, \"you don't own this shit\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This must be called before the Brainz contract can be used.\r\n     *\r\n     * @dev Within the BitMonsters contract, call initializeBrainz().\r\n     */\r\n    function setBitMonstersContract(IBitMonsters _contract) external onlyOwner {\r\n        bitMonsters = _contract;\r\n    }\r\n}\r\n\r\n// File: contracts/Brainz.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// shamelessly \"inspired by\" the anonymice cheeth contract\r\n\r\n/**\r\n * @title The contract for the Brainz token and staking. At the moment, these can only be obtained by staking Bit Monsters.\r\n */\r\ncontract Brainz is ERC20Burnable, BitMonstersAddon {\r\n    using RngLibrary for Rng;\r\n\r\n    mapping (uint => uint) public tokenIdToTimestamp;\r\n    Rng private rng = RngLibrary.newRng();\r\n\r\n    constructor() ERC20(\"Brainz\", \"BRAINZ\") {\r\n    }\r\n\r\n    function adminMint(address addr, uint256 count) external onlyAdmin {\r\n        _mint(addr, count * 1 ether);\r\n    }\r\n\r\n    function adminBurn(address addr, uint256 count) external onlyAdmin {\r\n        _burn(addr, count * 1 ether);\r\n    }\r\n\r\n    /**\r\n     * Claims all Brainz from all staked Bit Monsters the caller owns.\r\n     */\r\n    function claimBrainz() external {\r\n        uint count = bitMonsters.balanceOf(msg.sender);\r\n        uint total = 0;\r\n\r\n        for (uint i = 0; i < count; ++i) {\r\n            uint tokenId = bitMonsters.tokenOfOwnerByIndex(msg.sender, i);\r\n            uint rewards = calculateRewards(tokenId);\r\n            if (rewards > 0) {\r\n                tokenIdToTimestamp[tokenId] = block.timestamp - ((block.timestamp - tokenIdToTimestamp[tokenId]) % 86400);\r\n            }\r\n            total += rewards;\r\n        }\r\n\r\n        _mint(msg.sender, total);\r\n    }\r\n\r\n    function rewardRate(BitMonster memory m) public pure returns (uint) {\r\n        return ((m.genesis ? 2 : 1) * (m.special != Special.NONE ? 2 : 1) + (m.superYield ? 1 : 0)) * 1 ether;\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of pending Brainz the caller can currently claim.\r\n     */\r\n    function calculateRewards(uint tokenId) public view returns (uint) {\r\n        BitMonster memory m = bitMonsters.getBitMonster(tokenId);\r\n        uint nDays = (block.timestamp - tokenIdToTimestamp[tokenId]) / 86400;\r\n\r\n        return rewardRate(m) * nDays;\r\n    }\r\n\r\n    /**\r\n     * Tracks the Bit Monster with the given tokenId for reward calculation.\r\n     */\r\n    function register(uint tokenId) external onlyAdmin {\r\n        require(tokenIdToTimestamp[tokenId] == 0, \"already staked\");\r\n        tokenIdToTimestamp[tokenId] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * Stake your Brainz a-la OSRS Duel Arena.\r\n     *\r\n     * 50% chance of multiplying your Brainz by 1.9x rounded up.\r\n     * 50% chance of losing everything you stake.\r\n     */\r\n    function stake(uint count) external returns (bool won) {\r\n        require(count > 0, \"Must stake at least one BRAINZ\");\r\n        require(balanceOf(msg.sender) >= count, \"You don't have that many tokens\");\r\n\r\n        Rng memory rn = rng;\r\n\r\n        if (rn.generate(0, 1) == 0) {\r\n            _mint(msg.sender, (count - count / 10) * 1 ether);\r\n            won = true;\r\n        }\r\n        else {\r\n            _burn(msg.sender, count * 1 ether);\r\n            won = false;\r\n        }\r\n\r\n        rng = rn;\r\n    }\r\n}\r\n\r\n// File: contracts/BitMonsterGen.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\nlibrary BitMonsterGen {\r\n    using RngLibrary for Rng;\r\n\r\n    function getRandomBgColor(Rng memory rng) internal view returns (BgColor) {\r\n        if (rng.generate(1, 1000) == 1) {\r\n            return BgColor.RAINBOW;\r\n        }\r\n        return BgColor(rng.generate(0, 9));\r\n    }\r\n\r\n    function getRandomDominant(Rng memory rng) internal view returns (Dominant) {\r\n        // all rarities are out of 10000\r\n        uint rn = rng.generate(0, 9999);\r\n        uint16[8] memory rarities = Rarities.dominant();\r\n    \r\n        for (uint i = 0; i < rarities.length; ++i) {\r\n            if (rarities[i] > rn) {\r\n                return Dominant(i);\r\n            }\r\n            rn -= rarities[i];\r\n        }\r\n        revert(\"getRandomDominant() is fucked\");\r\n    } \r\n    \r\n    function getRandomRecessive(Rng memory rng) internal view returns (Recessive) {\r\n        // all rarities are out of 10000\r\n        uint rn = rng.generate(0, 9999);\r\n        uint16[6] memory rarities = Rarities.recessive();\r\n    \r\n        for (uint i = 0; i < rarities.length; ++i) {\r\n            if (rarities[i] > rn) {\r\n                return Recessive(i);\r\n            }\r\n            rn -= rarities[i];\r\n        }\r\n        revert(\"getRandomRecessive() is fucked\");\r\n    } \r\n    \r\n    function getRandomOutfit(Rng memory rng) internal view returns (Outfit) {\r\n        // all rarities are out of 10000\r\n        uint rn = rng.generate(0, 9999);\r\n        uint16[27] memory rarities = Rarities.outfit();\r\n    \r\n        for (uint i = 0; i < rarities.length; ++i) {\r\n            if (rarities[i] > rn) {\r\n                return Outfit(i);\r\n            }\r\n            rn -= rarities[i];\r\n        }\r\n        revert(\"getRandomOutfit() is fucked\");\r\n    } \r\n    \r\n    function getRandomHandAccessory(Rng memory rng) internal view returns (HandAccessory) {\r\n        // all rarities are out of 10000\r\n        uint rn = rng.generate(0, 9999);\r\n        uint16[16] memory rarities = Rarities.handaccessory();\r\n    \r\n        for (uint i = 0; i < rarities.length; ++i) {\r\n            if (rarities[i] > rn) {\r\n                return HandAccessory(i);\r\n            }\r\n            rn -= rarities[i];\r\n        }\r\n        revert(\"getRandomHandAccessory() is fucked\");\r\n    } \r\n    \r\n    function getRandomMouth(Rng memory rng) internal view returns (Mouth) {\r\n        // all rarities are out of 10000\r\n        uint rn = rng.generate(0, 9999);\r\n        uint16[22] memory rarities = Rarities.mouth();\r\n    \r\n        for (uint i = 0; i < rarities.length; ++i) {\r\n            if (rarities[i] > rn) {\r\n                return Mouth(i);\r\n            }\r\n            rn -= rarities[i];\r\n        }\r\n        revert(\"getRandomMouth() is fucked\");\r\n    } \r\n    \r\n    function getRandomEyes(Rng memory rng) internal view returns (Eyes) {\r\n        // all rarities are out of 10000\r\n        uint rn = rng.generate(0, 9999);\r\n        uint16[24] memory rarities = Rarities.eyes();\r\n    \r\n        for (uint i = 0; i < rarities.length; ++i) {\r\n            if (rarities[i] > rn) {\r\n                return Eyes(i);\r\n            }\r\n            rn -= rarities[i];\r\n        }\r\n        revert(\"getRandomEyes() is fucked\");\r\n    } \r\n    \r\n    function getRandomHeadAccessory(Rng memory rng) internal view returns (HeadAccessory) {\r\n        // all rarities are out of 10000\r\n        uint rn = rng.generate(0, 9999);\r\n        uint16[29] memory rarities = Rarities.headaccessory();\r\n    \r\n        for (uint i = 0; i < rarities.length; ++i) {\r\n            if (rarities[i] > rn) {\r\n                return HeadAccessory(i);\r\n            }\r\n            rn -= rarities[i];\r\n        }\r\n        revert(\"getRandomHeadAccessory() is fucked\");\r\n    } \r\n\r\n    function generateUnspecialBitMonster(Rng memory rng) internal view returns (BitMonster memory) {\r\n        BitMonster memory ret = BitMonster({\r\n            genesis:       true,\r\n            superYield:    rng.generate(0, 99) == 0,\r\n            special:       Special.NONE,\r\n            dominant:      getRandomDominant(rng),\r\n            recessive:     getRandomRecessive(rng),\r\n            bgColor:       getRandomBgColor(rng),\r\n            outfit:        getRandomOutfit(rng),\r\n            handAccessory: getRandomHandAccessory(rng),\r\n            mouth:         getRandomMouth(rng),\r\n            eyes:          getRandomEyes(rng),\r\n            headAccessory: getRandomHeadAccessory(rng)\r\n        });\r\n\r\n        return ret;\r\n    }\r\n\r\n    function generateSpecialBitMonster(Rng memory rng, bool[9] memory mintedSpecials) internal view returns (BitMonster memory) {\r\n        uint available = mintedSpecials.length;\r\n        for (uint i = 0; i < mintedSpecials.length; ++i) {\r\n            if (mintedSpecials[i]) {\r\n                available--;\r\n            }\r\n        }\r\n\r\n        if (available == 0) {\r\n            return generateUnspecialBitMonster(rng);\r\n        }\r\n\r\n        uint rn = rng.generate(0, available - 1);\r\n        uint special;\r\n\r\n        // generate a random special index, skipping specials that do not exist\r\n        for (special = 0; special < 9; ++special) {\r\n            if (mintedSpecials[special]) {\r\n                continue;\r\n            }\r\n            if (rn == 0) {\r\n                break;\r\n            }\r\n            rn -= 1;\r\n        }\r\n\r\n        require(!mintedSpecials[special]);\r\n        mintedSpecials[special] = true;\r\n\r\n        return BitMonster({\r\n            genesis:       true,\r\n            superYield:    rng.generate(0, 4) == 0,\r\n            // + 1 because 0 is None\r\n            special:       Special(special + 1),\r\n            dominant:      getRandomDominant(rng),\r\n            recessive:     getRandomRecessive(rng),\r\n            bgColor:       BgColor.DARK_BLUE,\r\n            outfit:        Outfit.NONE,\r\n            handAccessory: HandAccessory.NONE,\r\n            mouth:         Mouth.NONE,\r\n            eyes:          Eyes.NONE,\r\n            headAccessory: HeadAccessory.NONE\r\n        });\r\n    }\r\n\r\n    function rerollTrait(Rng memory rng, BitMonster memory bm, RerollTrait trait) internal view {\r\n        bm.genesis = false;\r\n        if (trait == RerollTrait.BgColor) {\r\n            BgColor existing = bm.bgColor;\r\n            while (bm.bgColor == existing) {\r\n                bm.bgColor = getRandomBgColor(rng);\r\n            }\r\n        }\r\n        else if (trait == RerollTrait.Outfit) {\r\n            Outfit existing = bm.outfit;\r\n            while (bm.outfit == existing) {\r\n                bm.outfit = getRandomOutfit(rng);\r\n            }\r\n        }\r\n        else if (trait == RerollTrait.HandAccessory) {\r\n            HandAccessory existing = bm.handAccessory;\r\n            while (bm.handAccessory == existing) {\r\n                bm.handAccessory = getRandomHandAccessory(rng);\r\n            }\r\n        }\r\n        else if (trait == RerollTrait.Mouth) {\r\n            Mouth existing = bm.mouth;\r\n            while (bm.mouth == existing) {\r\n                bm.mouth = getRandomMouth(rng);\r\n            }\r\n        }\r\n        else if (trait == RerollTrait.Eyes) {\r\n            Eyes existing = bm.eyes;\r\n            while (bm.eyes == existing) {\r\n                bm.eyes = getRandomEyes(rng);\r\n            }\r\n        }\r\n        else if (trait == RerollTrait.HeadAccessory) {\r\n            HeadAccessory existing = bm.headAccessory;\r\n            while (bm.headAccessory == existing) {\r\n                bm.headAccessory = getRandomHeadAccessory(rng);\r\n            }\r\n        }\r\n        else {\r\n            revert(\"Invalid reroll trait\");\r\n        }\r\n    }\r\n\r\n    function rerollAll(Rng memory rng, BitMonster memory bm) internal view {\r\n        bm.genesis = false;\r\n        bm.bgColor = getRandomBgColor(rng);\r\n        bm.outfit = getRandomOutfit(rng);\r\n        bm.handAccessory = getRandomHandAccessory(rng);\r\n        bm.mouth = getRandomMouth(rng);\r\n        bm.eyes = getRandomEyes(rng);\r\n        bm.headAccessory = getRandomHeadAccessory(rng);\r\n    }\r\n}\r\n\r\n// File: contracts/Mutator.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Mutator is BitMonstersAddon {\r\n    using RngLibrary for Rng;\r\n\r\n    Brainz private brainz;\r\n    Rng private rng = RngLibrary.newRng();\r\n\r\n    constructor(Brainz _brainz) {\r\n        brainz = _brainz;\r\n    }\r\n\r\n    function rerollTrait(uint256 tokenId, RerollTrait trait) external ownsToken(tokenId) {\r\n        BitMonster memory bm = bitMonsters.getBitMonster(tokenId);\r\n        require(bm.special == Special.NONE, \"Specials cannot be rerolled\");\r\n\r\n        Rng memory rn = rng;\r\n\r\n        uint brainzCount;\r\n        if (trait == RerollTrait.BgColor) {\r\n            brainzCount = 4;\r\n        }\r\n        else if (trait == RerollTrait.HandAccessory) {\r\n            brainzCount = 10;\r\n        }\r\n        else {\r\n            brainzCount = 8;\r\n        }\r\n\r\n        brainz.adminBurn(msg.sender, brainzCount);\r\n\r\n        BitMonsterGen.rerollTrait(rn, bm, trait);\r\n\r\n        bitMonsters.setBitMonster(tokenId, bm);\r\n        rng = rn;\r\n    }\r\n\r\n    function rerollAll(uint256 tokenId) external ownsToken(tokenId) {\r\n        BitMonster memory bm = bitMonsters.getBitMonster(tokenId);\r\n        require(bm.special == Special.NONE, \"Specials cannot be rerolled\");\r\n\r\n        Rng memory rn = rng;\r\n\r\n        brainz.adminBurn(msg.sender, 10);\r\n\r\n        BitMonsterGen.rerollAll(rn, bm);\r\n\r\n        bitMonsters.setBitMonster(tokenId, bm);\r\n        rng = rn;\r\n    }\r\n\r\n    function mutate(uint256 donorId, uint256 recipientId, RerollTrait trait, uint256 brainzCount) external ownsToken(donorId) ownsToken(recipientId) returns (bool donorBurnt, bool recipientSuccess) {\r\n        require(bitMonsters.ownerOf(donorId) == msg.sender, \"you don't own the donor\");\r\n        require(bitMonsters.ownerOf(recipientId) == msg.sender, \"you don't own the recipient\");\r\n        require(donorId != recipientId, \"the donor and recipient are the same\");\r\n        require(brainzCount > 0, \"must use at least one brainz\");\r\n\r\n        brainz.adminBurn(msg.sender, brainzCount);\r\n\r\n        BitMonster memory donor = bitMonsters.getBitMonster(donorId);\r\n        BitMonster memory recipient = bitMonsters.getBitMonster(recipientId);\r\n\r\n        require(donor.special == Special.NONE && recipient.special == Special.NONE, \"can't mutate special\");\r\n        require(trait != RerollTrait.BgColor || donor.bgColor != BgColor.RAINBOW, \"rainbow bg cannot be mutated\");\r\n\r\n        Rng memory rn = rng;\r\n\r\n        // success rate of mutation = brainz / (brainz + 3)\r\n        if (rn.generate(1, brainzCount + 3) <= brainzCount) {\r\n            recipientSuccess = true;\r\n            recipient.genesis = false;\r\n            if (trait == RerollTrait.BgColor) {\r\n                recipient.bgColor = donor.bgColor;\r\n            }\r\n            else if (trait == RerollTrait.Outfit) {\r\n                recipient.outfit = donor.outfit;\r\n            }\r\n            else if (trait == RerollTrait.HandAccessory) {\r\n                recipient.handAccessory = donor.handAccessory;\r\n            }\r\n            else if (trait == RerollTrait.Mouth) {\r\n                recipient.mouth = donor.mouth;\r\n            }\r\n            else if (trait == RerollTrait.Eyes) {\r\n                recipient.eyes = donor.eyes;\r\n            }\r\n            else if (trait == RerollTrait.HeadAccessory) {\r\n                recipient.headAccessory = donor.headAccessory;\r\n            }\r\n            else {\r\n                revert(\"Invalid trait\");\r\n            }\r\n        }\r\n        // chance of burning the donor trait is a flat 1/3\r\n        if (rn.generate(1, 3) == 1) {\r\n            donorBurnt = true;\r\n            donor.genesis = false;\r\n\r\n            // background color can't be burned\r\n            if (trait == RerollTrait.Outfit) {\r\n                donor.outfit = Outfit.NONE;\r\n            }\r\n            else if (trait == RerollTrait.HandAccessory) {\r\n                donor.handAccessory = HandAccessory.NONE;\r\n            }\r\n            else if (trait == RerollTrait.Mouth) {\r\n                donor.mouth = Mouth.NONE;\r\n            }\r\n            else if (trait == RerollTrait.Eyes) {\r\n                donor.eyes = Eyes.NONE;\r\n            }\r\n            else if (trait == RerollTrait.HeadAccessory) {\r\n                donor.headAccessory = HeadAccessory.NONE;\r\n            }\r\n        }\r\n\r\n        bitMonsters.setBitMonster(donorId, donor);\r\n        bitMonsters.setBitMonster(recipientId, recipient);\r\n\r\n        rng = rn;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Brainz\",\"name\":\"_brainz\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"donorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientId\",\"type\":\"uint256\"},{\"internalType\":\"enum RerollTrait\",\"name\":\"trait\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"brainzCount\",\"type\":\"uint256\"}],\"name\":\"mutate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"donorBurnt\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"recipientSuccess\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"rerollAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum RerollTrait\",\"name\":\"trait\",\"type\":\"uint8\"}],\"name\":\"rerollTrait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBitMonsters\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setBitMonstersContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Mutator","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002ca1803b5eb52c2aff90cb2801dda3ccad49f64c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ca06ec82b47b33bc080f3a86c4158b58e882be7bb7124859c796b193fd2b7940"}]}