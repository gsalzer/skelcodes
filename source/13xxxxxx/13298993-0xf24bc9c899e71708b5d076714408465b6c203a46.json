{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/POWDrops.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IAtomReader.sol\\\";\\r\\nimport \\\"./interfaces/IPOWNFTPartial.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Partial.sol\\\";\\r\\n\\r\\n\\r\\n//interface IERC721TokenReceiver {\\r\\n//  //note: the national treasure is buried under parliament house\\r\\n//  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\r\\n//}\\r\\n\\r\\n\\r\\ncontract POWDrops {\\r\\n\\r\\n  event RegisterDrop(address indexed tokenAddress, uint dropTokenId, uint atomicNumber, int8 ionCharge, bool isIon, uint tokenId, uint blockNumber);\\r\\n  event ClaimDrop(address indexed tokenAddress, uint dropTokenId,uint tokenId, address indexed claimer);\\r\\n    event CleanupDrop(address indexed tokenAddress, uint dropTokenId);\\r\\n\\r\\n\\r\\n  IPOWNFTPartial powNFT;\\r\\n  IAtomReader atomReader;\\r\\n\\r\\n  constructor(address _powNFT, address _atomReader){\\r\\n      powNFT = IPOWNFTPartial(_powNFT);\\r\\n      atomReader = IAtomReader(_atomReader);\\r\\n  }\\r\\n\\r\\n  struct Drop{\\r\\n      uint8 atomicNumber;\\r\\n      int8 ionCharge;\\r\\n      uint minTokenId;\\r\\n      bool isIon;\\r\\n  }\\r\\n\\r\\n  mapping(address => mapping(uint => Drop)) drops;\\r\\n\\r\\n    function getDrop(address tokenAddress, uint dropTokenId) public view returns(uint8 atomicNumber, int8 ionCharge, uint minTokenId, bool isIon){\\r\\n        Drop memory drop = drops[tokenAddress][dropTokenId];\\r\\n\\r\\n        require(drop.minTokenId != 0,\\\"no_drop\\\");\\r\\n\\r\\n        return (drop.atomicNumber, drop.ionCharge, drop.minTokenId, drop.isIon);\\r\\n    }\\r\\n\\r\\n  function registerDrop(address tokenAddress, uint dropTokenId, uint atomicNumber, int8 ionCharge, bool isIon, uint tokenId) public{\\r\\n//      require(atomicNumber > 0,\\\"atomicNumber_min\\\");\\r\\n      require(atomicNumber <= 118,\\\"atomicNumber_max\\\");\\r\\n      uint currentId = powNFT.totalSupply() + powNFT.UNMIGRATED();\\r\\n\\r\\n      if(tokenId > 0){\\r\\n          require(tokenId > currentId && tokenId < currentId + 100,\\\"tokenId\\\");\\r\\n          require(ionCharge == 0,\\\"ionCharge_forbidden\\\");\\r\\n          require(isIon == false,\\\"isIon_forbidden\\\");\\r\\n          require(atomicNumber == 0,\\\"atomicNumber_forbidden\\\");\\r\\n      }else if(ionCharge != 0){\\r\\n          if(atomicNumber != 0){\\r\\n              require(atomReader.isValidIonCharge(atomicNumber,ionCharge),\\\"invalid_charge\\\");\\r\\n          }else{\\r\\n              require(ionCharge >= -3 && ionCharge <= 7,\\\"invalid_charge_range\\\");\\r\\n          }\\r\\n          require(isIon == false,\\\"isIon_forbidden\\\");\\r\\n//      isIon = false;\\r\\n      }\\r\\n      else if(isIon && atomicNumber > 0){\\r\\n          revert(\\\"isIon_specific\\\");\\r\\n//          require(atomReader.canIonise(atomicNumber),\\\"no_ions\\\");\\r\\n      }\\r\\n      else if(!isIon){\\r\\n          //Else just the atomicNumber\\r\\n        require(atomicNumber > 0,\\\"no_atomicNumber\\\");\\r\\n      }\\r\\n          //else isIon with no atomic number\\r\\n\\r\\n\\r\\n\\r\\n      if(tokenId > 0){\\r\\n          drops[tokenAddress][dropTokenId] =\\r\\n              Drop(\\r\\n                  0,\\r\\n                  0,\\r\\n                  tokenId,\\r\\n                  false\\r\\n              );\\r\\n          emit RegisterDrop(tokenAddress, dropTokenId, 0, 0, false, tokenId, block.number);\\r\\n      }else if(!isIon){\\r\\n          tokenId = currentId + 1;\\r\\n          drops[tokenAddress][dropTokenId] =\\r\\n              Drop(\\r\\n                uint8(atomicNumber),\\r\\n                ionCharge,\\r\\n                tokenId,\\r\\n                false\\r\\n              );\\r\\n          emit RegisterDrop(tokenAddress, dropTokenId, atomicNumber, ionCharge, false, tokenId, block.number);\\r\\n      }else{\\r\\n          tokenId = currentId + 1;\\r\\n          drops[tokenAddress][dropTokenId] =\\r\\n              Drop(\\r\\n                  uint8(atomicNumber),\\r\\n                  0,\\r\\n                  tokenId,\\r\\n                  true\\r\\n              );\\r\\n          emit RegisterDrop(tokenAddress, dropTokenId, atomicNumber, 0, true, tokenId, block.number);\\r\\n      }\\r\\n      IERC721Partial(tokenAddress).transferFrom(msg.sender,address(this),dropTokenId);\\r\\n  }\\r\\n  function claimDrop(address tokenAddress, uint dropTokenId, uint tokenId) public{\\r\\n      require(powNFT.ownerOf(tokenId) == msg.sender,'owner');\\r\\n\\r\\n\\r\\n      Drop memory drop = drops[tokenAddress][dropTokenId];\\r\\n\\r\\n      require(drop.minTokenId != 0,\\\"no_drop\\\");\\r\\n      require(tokenId >= drop.minTokenId,\\\"tokenId\\\");\\r\\n\\r\\n      (uint atomicNumber, int8 ionCharge) = atomReader.getAtomData(tokenId);\\r\\n\\r\\n\\r\\n      if(drop.atomicNumber != 0){\\r\\n          require(uint8(atomicNumber) == drop.atomicNumber,\\\"atomicNumber\\\");\\r\\n      }\\r\\n      if(drop.ionCharge != 0){\\r\\n          require(ionCharge == drop.ionCharge,\\\"ionCharge\\\");\\r\\n      }\\r\\n      if(drop.isIon){\\r\\n          require(ionCharge != 0,\\\"isIon\\\");\\r\\n      }\\r\\n\\r\\n      delete drops[tokenAddress][dropTokenId];\\r\\n\\r\\n      emit ClaimDrop(tokenAddress, dropTokenId,tokenId,msg.sender);\\r\\n\\r\\n      IERC721Partial(tokenAddress).transferFrom(address(this),msg.sender,dropTokenId);\\r\\n  }\\r\\n\\r\\n    function cleanupDrop(address tokenAddress, uint dropTokenId) public{\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(tokenAddress)\\r\\n        }\\r\\n        if(size == 0){\\r\\n            delete drops[tokenAddress][dropTokenId];\\r\\n            emit CleanupDrop(tokenAddress,dropTokenId);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        try IERC721Partial(tokenAddress).transferFrom(address(this),msg.sender,dropTokenId){\\r\\n            revert(\\\"okay\\\");\\r\\n        }catch{\\r\\n            delete drops[tokenAddress][dropTokenId];\\r\\n            emit CleanupDrop(tokenAddress,dropTokenId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAtomReader.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Licence to thrill\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title POWNFT Atom Reader\\r\\n/// @author AnAllergyToAnalogy\\r\\n/// @notice On-chain calculation atomic number and ionisation data about POWNFT Atoms. Replicates functionality done off-chain for metadata.\\r\\ninterface IAtomReader{\\r\\n\\r\\n    /// @notice Get atomic number and ionic charge of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return atomicNumber Atomic number of the Atom\\r\\n    /// @return ionCharge Ionic charge of the Atom\\r\\n    function getAtomData(uint _tokenId) external view returns(uint atomicNumber, int8 ionCharge);\\r\\n\\r\\n    /// @notice Get atomic number of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return Atomic number of the Atom\\r\\n    function getAtomicNumber(uint _tokenId) external view returns(uint);\\r\\n\\r\\n    /// @notice Get ionic charge of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return ionic charge of the Atom\\r\\n    function getIonCharge(uint _tokenId) external view returns(int8);\\r\\n\\r\\n    /// @notice Get array of all possible ions for a specified element\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @return Array of possible ionic charges\\r\\n    function getIons(uint atomicNumber) external pure returns(int8[] memory);\\r\\n\\r\\n    /// @notice Check if a given element can have a particular ionic charge\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @param ionCharge Ionic charge to check\\r\\n    /// @return True if this element can have this ion, false otherwise.\\r\\n    function isValidIonCharge(uint atomicNumber, int8 ionCharge) external pure returns(bool);\\r\\n\\r\\n    /// @notice Check if a given element has any potential ions\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @return True if this element can ionise, false otherwise.\\r\\n    function canIonise(uint atomicNumber) external pure returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPOWNFTPartial.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPOWNFTPartial{\\r\\n    function UNMIGRATED() external view returns(uint);\\r\\n    function hashOf(uint _tokenId) external view returns(bytes32);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function ownerOf(uint256 _tokenId) external view returns(address);\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721Partial.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC721Partial{\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_powNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_atomReader\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"ClaimDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropTokenId\",\"type\":\"uint256\"}],\"name\":\"CleanupDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atomicNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"ionCharge\",\"type\":\"int8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isIon\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"RegisterDrop\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dropTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dropTokenId\",\"type\":\"uint256\"}],\"name\":\"cleanupDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dropTokenId\",\"type\":\"uint256\"}],\"name\":\"getDrop\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"atomicNumber\",\"type\":\"uint8\"},{\"internalType\":\"int8\",\"name\":\"ionCharge\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"minTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isIon\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dropTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"atomicNumber\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"ionCharge\",\"type\":\"int8\"},{\"internalType\":\"bool\",\"name\":\"isIon\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"registerDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"POWDrops","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009abb7bddc43fa67c76a62d8c016513827f59be1b00000000000000000000000041d44e1cd2b335dc7662380d58eb03c5539b907f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}