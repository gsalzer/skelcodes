{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": false,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 256\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/rollup/contracts/ERC20BaseToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport '../../token/contracts/Utilities.sol';\\n\\n/// @notice ERC-20 contract with support for EIP-2612 and other niceties.\\n/// Deriving contracts should implement `DOMAIN_SEPARATOR`, `totalSupply`, `decimals`, `symbol`, `name`.\\ncontract ERC20BaseToken is Utilities {\\n  mapping (address => uint256) _balances;\\n  mapping (address => mapping (address => uint256)) _allowances;\\n  mapping (address => uint256) _nonces;\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n   /// @notice Returns the DOMAIN_SEPARATOR. See EIP-2612.\\n  function DOMAIN_SEPARATOR () public virtual view returns (bytes32 ret) {\\n  }\\n\\n  /// @notice Returns the balance of `account`.\\n  function balanceOf (address account) public virtual view returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /// @notice Returns the allowance for `spender` of `account`.\\n  function allowance (address account, address spender) public virtual view returns (uint256) {\\n    return _allowances[account][spender];\\n  }\\n\\n  /// @notice Returns the nonce of `account`. Used in `permit`. See EIP-2612.\\n  function nonces (address account) public virtual view returns (uint256) {\\n    return _nonces[account];\\n  }\\n\\n  /// @notice Approves `amount` from sender to be spend by `spender`.\\n  /// @param spender Address of the party that can draw from msg.sender's account.\\n  /// @param amount The maximum collective amount that `spender` can draw.\\n  /// @return (bool) Returns True if approved.\\n  function approve (address spender, uint256 amount) public virtual returns (bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  /// @dev The concrete implementation of `approve`.\\n  function _approve (address owner, address spender, uint256 value) internal virtual {\\n    _allowances[owner][spender] = value;\\n    emit Approval(owner, spender, value);\\n  }\\n\\n  /// @dev The concrete implementation of `transfer` and `transferFrom`.\\n  function _transferFrom (address from, address to, uint256 value) internal virtual returns (bool) {\\n    uint256 balance = _balances[from];\\n    require(balance >= value, 'BALANCE');\\n\\n    _balances[from] = balance - value;\\n    balance = _balances[to];\\n    uint256 newBalance = balance + value;\\n    // overflow check, also reverts if `value` is zero\\n    require(newBalance > balance, 'OVERFLOW');\\n    _balances[to] = newBalance;\\n\\n    emit Transfer(from, to, value);\\n\\n    return true;\\n  }\\n\\n  /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\\n  /// @param to The address to move the tokens.\\n  /// @param amount of the tokens to move.\\n  /// @return (bool) Returns True if succeeded.\\n  function transfer (address to, uint256 amount) public virtual returns (bool) {\\n    return _transferFrom(msg.sender, to, amount);\\n  }\\n\\n  /// @notice Transfers `amount` tokens from `from` to `to`. Caller may need approval if `from` is not `msg.sender`.\\n  /// @param from Address to draw tokens from.\\n  /// @param to The address to move the tokens.\\n  /// @param amount The token amount to move.\\n  /// @return (bool) Returns True if succeeded.\\n  function transferFrom (address from, address to, uint256 amount) public virtual returns (bool) {\\n    uint256 _allowance = _allowances[from][msg.sender];\\n    require(_allowance >= amount, 'ALLOWANCE');\\n\\n    if (_allowance != uint256(-1)) {\\n      _allowances[from][msg.sender] = _allowance - amount;\\n    }\\n\\n    return _transferFrom(from, to, amount);\\n  }\\n\\n  /// @notice Approves `value` from `owner` to be spend by `spender`.\\n  /// @param owner Address of the owner.\\n  /// @param spender The address of the spender that gets approved to draw from `owner`.\\n  /// @param value The maximum collective amount that `spender` can draw.\\n  /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\\n  function permit (\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    require(owner != address(0), 'OWNER');\\n    require(block.timestamp < deadline, 'EXPIRED');\\n\\n    uint256 nonce = _nonces[owner]++;\\n    bytes32 domainSeparator = DOMAIN_SEPARATOR();\\n    bytes32 digest;\\n    assembly {\\n      // ptr to free memory\\n      let ptr := mload(64)\\n      // keep a copy to calculate the length later\\n      let start := ptr\\n\\n      // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\\n      mstore(ptr, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)\\n      ptr := add(ptr, 32)\\n\\n      // copy (owner, spender, value) from calldata in one go\\n      calldatacopy(ptr, 4, 96)\\n      ptr := add(ptr, 96)\\n\\n      // store nonce\\n      mstore(ptr, nonce)\\n      ptr := add(ptr, 32)\\n      // store deadline\\n      mstore(ptr, deadline)\\n      ptr := add(ptr, 32)\\n\\n      // Permit struct hash\\n      let permitStructHash := keccak256(start, sub(ptr, start))\\n      // reset ptr\\n      ptr := start\\n      // add 30 bytes to align correctly (0x1901)\\n      start := add(ptr, 30)\\n\\n      // preamble\\n      mstore(ptr, 0x1901)\\n      ptr := add(ptr, 32)\\n\\n      // DOMAIN_SEPARATOR\\n      mstore(ptr, domainSeparator)\\n      ptr := add(ptr, 32)\\n\\n      // from above\\n      mstore(ptr, permitStructHash)\\n      ptr := add(ptr, 32)\\n\\n      // hash it\\n      digest := keccak256(start, sub(ptr, start))\\n    }\\n\\n    require(ecrecover(digest, v, r, s) == owner, 'SIG');\\n    _approve(owner, spender, value);\\n  }\\n\\n  /// @dev Helper function for wrapping calls. Reverts on a call to 'self'.\\n  function _callWrapper (address to, bytes calldata data) internal returns (bytes memory) {\\n    require(to != address(this));\\n    (bool success, bytes memory ret) = to.call(data);\\n    require(success);\\n    return ret;\\n  }\\n\\n  /// @notice Transfers `amount` from `msg.sender` to `to` and calls `to` with `data` as input.\\n  /// Reverts if not succesful. Otherwise returns any data from the call.\\n  function transferAndCall (address to, uint256 amount, bytes calldata data) external returns (bytes memory) {\\n    _transferFrom(msg.sender, to, amount);\\n    return _callWrapper(to, data);\\n  }\\n\\n  /// @notice Approves `amount` from `msg.sender` to be spend by `to` and calls `to` with `data` as input.\\n  /// Reverts if not succesful. Otherwise returns any data from the call.\\n  function approveAndCall (address to, uint256 amount, bytes calldata data) external returns (bytes memory) {\\n    _approve(msg.sender, to, amount);\\n    return _callWrapper(to, data);\\n  }\\n\\n  /// @notice Redeems a permit for this contract (`permitData`) and calls `to` with `data` as input.\\n  /// Reverts if not succesful. Otherwise returns any data from the call.\\n  function redeemPermitAndCall (address to, bytes calldata permitData, bytes calldata data) external returns (bytes memory) {\\n    Utilities._maybeRedeemPermit(address(this), permitData);\\n    return _callWrapper(to, data);\\n  }\\n\\n  /// @notice Allows to recover `token`.\\n  /// Transfers `token` to `msg.sender`.\\n  /// @param token The address of the ERC-20 token to recover.\\n  function recoverLostTokens (address token) external {\\n    Utilities._safeTransfer(token, msg.sender, Utilities._safeBalance(token, address(this)));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/VERCHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\ncontract VERCHelper {\\n  /// @dev Returns the deployment bytecode (EIP-3448).\\n  /// Warning: writes to memory but does not advance the solidity memory pointer\\n  function _getInitCodeForVERC (address target, uint256 calldataStart, uint256 size) internal returns (bytes memory retVal) {\\n    // the following assembly code (init code + contract code) constructs a metaproxy.\\n    assembly {\\n      // load free memory pointer as per solidity convention\\n      retVal := mload(64)\\n\\n      // skip 32 bytes\\n      let start := add(retVal, 32)\\n      // copy\\n      let ptr := start\\n\\n      // deploy code (11 bytes) + first part of the proxy (21 bytes)\\n      mstore(ptr, 0x600b380380600b3d393df3363d3d373d3d3d3d60368038038091363936013d73)\\n      ptr := add(ptr, 32)\\n\\n      // store the address of the contract to be called\\n      mstore(ptr, shl(96, target))\\n      // 20 bytes\\n      ptr := add(ptr, 20)\\n\\n      // the remaining proxy code...\\n      mstore(ptr, 0x5af43d3d93803e603457fd5bf300000000000000000000000000000000000000)\\n      // ...13 bytes\\n      ptr := add(ptr, 13)\\n\\n      // copy the metadata\\n      calldatacopy(ptr, calldataStart, size)\\n      ptr := add(ptr, size)\\n\\n      // store the size of the metadata at the end of the bytecode\\n      mstore(ptr, size)\\n      ptr := add(ptr, 32)\\n\\n\\n      // store the total size of the data\\n      mstore(retVal, sub(ptr, start))\\n    }\\n  }\\n\\n  /// @dev Calculates the VERC-20 address (via CREATE2) given `factoryAddress` and `args`.\\n  function _getAddressForVERC (address factoryAddress, bytes calldata args) internal returns (address retVal) {\\n    uint256 offset;\\n    assembly {\\n      offset := args.offset\\n    }\\n    bytes memory initCode = _getInitCodeForVERC(factoryAddress, offset, args.length);\\n\\n    assembly {\\n      let initCodeHash := keccak256(add(initCode, 32), mload(initCode))\\n      let backupPtr := mload(64)\\n\\n      mstore(84, initCodeHash)\\n      // salt\\n      mstore(52, 0)\\n      mstore(20, factoryAddress)\\n      mstore(0, 0xff)\\n\\n      retVal := and(keccak256(31, 85), 0xffffffffffffffffffffffffffffffffffffffff)\\n\\n      // restore important memory slots\\n      mstore(64, backupPtr)\\n      mstore(96, 0)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/VirtualERC20Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './ERC20BaseToken.sol';\\nimport './VERCHelper.sol';\\n\\n/// @notice This contract implements deteministic ERC-20 deployements. Used for Habitat V(irtual) ERC-20.\\ncontract VirtualERC20Factory is ERC20BaseToken, VERCHelper {\\n  event Erc20Created(address indexed proxy);\\n\\n  bool _initialized;\\n\\n  /// @notice Returns the metadata of this (MetaProxy) contract.\\n  /// Only relevant with contracts created via the MetaProxy.\\n  /// @dev This function is aimed to be invoked with- & without a call.\\n  function getMetadata () public pure returns (\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals,\\n    uint256 _totalSupply,\\n    bytes32 _domainSeparator\\n  ) {\\n    assembly {\\n      function stringcopy (_calldataPtr) -> calldataPtr, memPtr {\\n        calldataPtr := _calldataPtr\\n\\n        let paddedLen := add(\\n          // len of bytes\\n          32,\\n          // roundup\\n          mul(\\n            div(\\n              add(calldataload(calldataPtr), 31),\\n              32\\n            ),\\n            32\\n          )\\n        )\\n        memPtr := mload(64)\\n        mstore(64, add(memPtr, paddedLen))\\n        calldatacopy(memPtr, calldataPtr, paddedLen)\\n        calldataPtr := add(calldataPtr, paddedLen)\\n      }\\n\\n      // calldata layout:\\n      // [ arbitrary data... ] [ metadata... ] [ size of metadata 32 bytes ]\\n      let sizeOfPos := sub(calldatasize(), 32)\\n      let calldataPtr := sub(sizeOfPos, calldataload(sizeOfPos))\\n      // skip the first 64 bytes (abi encoded stuff)\\n      calldataPtr := add(calldataPtr, 64)\\n\\n      _decimals := calldataload(calldataPtr)\\n      calldataPtr := add(calldataPtr, 32)\\n\\n      _totalSupply := calldataload(calldataPtr)\\n      calldataPtr := add(calldataPtr, 32)\\n\\n      _domainSeparator := calldataload(calldataPtr)\\n      calldataPtr := add(calldataPtr, 32)\\n\\n      // copy token name to memory\\n      calldataPtr, _name := stringcopy(calldataPtr)\\n      // copy token symbol to memory\\n      calldataPtr, _symbol := stringcopy(calldataPtr)\\n    }\\n  }\\n\\n  /// @notice VERC MetaProxy construction via calldata.\\n  function createProxy (\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals,\\n    uint256 _totalSupply,\\n    bytes32 _domainSeparator\\n  ) external returns (address addr) {\\n\\n    // create the proxy first\\n    addr = _metaProxyFromCalldata();\\n    require(addr != address(0), 'CP1');\\n    emit Erc20Created(addr);\\n\\n    bytes32 tokenNameHash = keccak256(bytes(_name));\\n    bytes32 ret;\\n    assembly {\\n      // load free memory ptr\\n      let ptr := mload(64)\\n      // keep a copy to calculate the length later\\n      let start := ptr\\n\\n      // we can't include `address verifyingContract`\\n      // keccak256('EIP712Domain(string name,uint256 chainId)')\\n      mstore(ptr, 0xcc85e4a69ca54da41cc4383bb845cbd1e15ef8a13557a6bed09b8bea2a0d92ff)\\n      ptr := add(ptr, 32)\\n\\n      // see tokenNameHash\\n      mstore(ptr, tokenNameHash)\\n      ptr := add(ptr, 32)\\n\\n      // store chainid\\n      mstore(ptr, chainid())\\n      ptr := add(ptr, 32)\\n\\n      // hash\\n      ret := keccak256(start, sub(ptr, start))\\n    }\\n    // verify DOMAIN_SEPARATOR\\n    require(ret == _domainSeparator, 'CP2');\\n\\n    VirtualERC20Factory(addr).init(_INITIAL_OWNER());\\n  }\\n\\n  /// @notice Based on EIP-3448\\n  /// @dev Creates a child with metadata from calldata.\\n  /// Copies everything from calldata except the first 4 bytes.\\n  /// @return addr address(0) on error, else the address of the new contract (proxy)\\n  function _metaProxyFromCalldata () internal returns (address addr) {\\n    uint256 metadataSize;\\n    assembly {\\n      metadataSize := sub(calldatasize(), 4)\\n    }\\n    bytes memory initCode = VERCHelper._getInitCodeForVERC(address(this), 4, metadataSize);\\n    assembly {\\n      let start := add(initCode, 32)\\n      let size := mload(initCode)\\n      addr := create2(0, start, size, 0)\\n    }\\n  }\\n\\n  /// @dev The address who receives the `totalSupply` on `init`.\\n  function _INITIAL_OWNER () internal view virtual returns (address) {\\n  }\\n\\n  /// @notice Initializes and mints the total supply to the `_initialOwner`.\\n  function init (address _initialOwner) external {\\n    require(_initialized == false, 'S1');\\n\\n    _initialized = true;\\n\\n    (,,,uint256 _totalSupply,) = getMetadata();\\n    _balances[_initialOwner] = _totalSupply;\\n\\n    emit Transfer(address(0), _initialOwner, _totalSupply);\\n  }\\n\\n  /// @notice Returns the name of token.\\n  function name () public virtual view returns (string memory) {\\n    (string memory _name,,,,) = getMetadata();\\n    return _name;\\n  }\\n\\n  /// @notice Returns the symbol of the token.\\n  function symbol () public virtual view returns (string memory) {\\n    (,string memory _symbol,,,) = getMetadata();\\n    return _symbol;\\n  }\\n\\n  /// @notice Returns the decimal place of the token.\\n  function decimals () public virtual view returns (uint8) {\\n    (,,uint8 _decimals,,) = getMetadata();\\n    return _decimals;\\n  }\\n\\n  /// @notice Returns the DOMAIN_SEPARATOR. See EIP-2612.\\n  function DOMAIN_SEPARATOR () public virtual override view returns (bytes32) {\\n    (,,,,bytes32 _domainSeparator) = getMetadata();\\n    return _domainSeparator;\\n  }\\n\\n  /// @notice Returns the total supply of this token.\\n  function totalSupply () public virtual view returns (uint256) {\\n    (,,,uint256 _totalSupply,) = getMetadata();\\n    return _totalSupply;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/mocks/VirtualERC20FactoryMainnet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport '../VirtualERC20Factory.sol';\\n\\ncontract VirtualERC20FactoryMainnet is VirtualERC20Factory {\\n  /// @dev Initial owner is the habitat rollup bridge.\\n  function _INITIAL_OWNER () internal view virtual override returns (address) {\\n    return 0x96E471B5945373dE238963B4E032D3574be4d195;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/token/contracts/Utilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IWETH {\\n  function deposit() external payable;\\n  function transfer(address to, uint value) external returns (bool);\\n  function withdraw(uint) external;\\n}\\n\\ninterface IUniswapV2Pair {\\n  function factory() external view returns (address);\\n  function token0() external view returns (address);\\n  function token1() external view returns (address);\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n  function price0CumulativeLast() external view returns (uint);\\n  function price1CumulativeLast() external view returns (uint);\\n  function kLast() external view returns (uint);\\n\\n  function mint(address to) external returns (uint liquidity);\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n  function skim(address to) external;\\n  function sync() external;\\n}\\n\\ninterface IDroplet {\\n  function drip () external;\\n}\\n\\nlibrary SafeMath {\\n  function add(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x + y) >= x, 'ADD_OVERFLOW');\\n  }\\n\\n  function sub(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x - y) <= x, 'SUB_OVERFLOW');\\n  }\\n\\n  function mul(uint x, uint y) internal pure returns (uint z) {\\n    require(y == 0 || (z = x * y) / y == x, 'MUL_OVERFLOW');\\n  }\\n}\\n\\nlibrary UniswapV2Library {\\n  using SafeMath for uint;\\n\\n  // fetches and sorts the reserves for a pair\\n  function getReserves (uint256 pair) internal view returns (uint reserveA, uint reserveB) {\\n    address addr = address(pair >> 1);\\n    uint direction = pair & 1;\\n    (uint reserve0, uint reserve1,) = IUniswapV2Pair(addr).getReserves();\\n    (reserveA, reserveB) = direction == 0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n  }\\n\\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n  function getAmountOut (uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n    require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\\n    require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\\n    uint amountInWithFee = amountIn.mul(997);\\n    uint numerator = amountInWithFee.mul(reserveOut);\\n    uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n    amountOut = numerator / denominator;\\n  }\\n\\n  // performs chained getAmountOut calculations on any number of pairs\\n  function getAmountsOut (uint amountIn, uint256[] memory pairs) internal view returns (uint[] memory amounts) {\\n    amounts = new uint[](pairs.length);\\n    amounts[0] = amountIn;\\n    for (uint i = 1; i < pairs.length; i++) {\\n      (uint reserveIn, uint reserveOut) = getReserves(pairs[i]);\\n      amounts[i] = getAmountOut(amounts[i - 1], reserveIn, reserveOut);\\n    }\\n  }\\n}\\n\\ncontract Utilities {\\n  bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\\n  bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\\n  bytes4 private constant SIG_APPROVE = 0x095ea7b3; // approve(address,uint256)\\n  bytes4 private constant SIG_BALANCE = 0x70a08231; // balanceOf(address)\\n\\n  /// @dev Provides a safe ERC-20.transfer version for different ERC-20 implementations.\\n  /// Reverts on a failed transfer.\\n  /// @param token The address of the ERC-20 token.\\n  /// @param to Transfer tokens to.\\n  /// @param amount The token amount.\\n  function _safeTransfer (address token, address to, uint256 amount) internal {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER');\\n  }\\n\\n  /// @dev Provides a safe ERC-20.transferFrom version for different ERC-20 implementations.\\n  /// Reverts on a failed transfer.\\n  /// @param token The address of the ERC-20 token.\\n  /// @param from Transfer tokens from.\\n  /// @param to Transfer tokens to.\\n  /// @param amount The token amount.\\n  function _safeTransferFrom (address token, address from, address to, uint256 amount) internal {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FROM');\\n  }\\n\\n  /// @dev Provides a ETH transfer wrapper.\\n  /// Reverts on a failed transfer.\\n  /// @param to Transfer ETH to.\\n  /// @param amount The ETH amount.\\n  function _safeTransferETH (address to, uint256 amount) internal {\\n    (bool success,) = to.call{value:amount}(\\\"\\\");\\n    require(success, 'TRANSFER_ETH');\\n  }\\n\\n  /// @dev Provides a safe ERC-20.approve version for different ERC-20 implementations.\\n  /// Reverts if failed.\\n  /// @param token The address of the ERC-20 token.\\n  /// @param spender of tokens.\\n  /// @param amount Allowance amount.\\n  function _safeApprove (address token, address spender, uint256 amount) internal {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SIG_APPROVE, spender, amount));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'APPROVE');\\n  }\\n\\n  /// @dev Provides a wrapper for ERC-20.balanceOf.\\n  /// Reverts if failed.\\n  /// @param token The address of the ERC-20 token.\\n  /// @param account Address of the account to query.\\n  function _safeBalance (address token, address account) internal returns (uint256) {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SIG_BALANCE, account));\\n    require(success, 'BALANCE');\\n    return abi.decode(data, (uint256));\\n  }\\n\\n  /// @dev Wrapper for `_safeTransfer` or `_safeTransferFrom` depending on `from`.\\n  function _safeTransferWrapper (address token, address from, address to, uint256 amount) internal {\\n    if (from == address(this)) {\\n      _safeTransfer(token, to, amount);\\n    } else {\\n      _safeTransferFrom(token, from, to, amount);\\n    }\\n  }\\n\\n  /// @dev Helper function for redeeming EIP-2612 and DAI-style permits.\\n  function _maybeRedeemPermit (address token, bytes memory permitData) internal {\\n    if (permitData.length > 0) {\\n      bool success;\\n      assembly {\\n        let dataPtr := add(permitData, 32)\\n        let functionSig := shr(224, mload(dataPtr))\\n\\n        {\\n          // check if permit.owner is address(this). Yes, paranoia.\\n          // offset is <functionSig 4 bytes> + 12 bytes left-side part of permit.owner.\\n          // shift it to the right by 12 bytes so that we can *safely* compare\\n          let _owner := shr(96, mload(add(dataPtr, 16)))\\n          if eq(_owner, address()) {\\n            // even if a correct signature for this contract is just possible in theory,\\n            // attempting this deserves no error message\\n            revert(0, 0)\\n          }\\n        }\\n\\n        // EIP-2612 = 0xd505accf || dai-like (old) permit = 0x8fcbaf0c\\n        if or( eq(functionSig, 0xd505accf), eq(functionSig, 0x8fcbaf0c) ) {\\n          let size := mload(permitData)\\n          success := call(gas(), token, 0, dataPtr, size, 0, 0)\\n        }\\n      }\\n      require(success, 'PERMIT');\\n    }\\n  }\\n\\n  /// @dev Requires the initial amount to have already been sent to the first pair.\\n  function _swap (uint[] memory amounts, uint256[] memory path, address _to) internal {\\n    for (uint i = 1; i < path.length; i++) {\\n      uint amountOut = amounts[i];\\n\\n      address pair = address(path[i] >> 1);\\n      uint direction = path[i] & 1;\\n      (uint amount0Out, uint amount1Out) = direction == 0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n      address to = i < path.length - 1 ? address(path[i + 1] >> 1) : _to;\\n\\n      IUniswapV2Pair(pair).swap(\\n        amount0Out, amount1Out, to, \\\"\\\"\\n      );\\n    }\\n  }\\n\\n  function _swapExactTokensForTokens (\\n    uint256[] memory path,\\n    uint amountIn,\\n    address from,\\n    address to\\n  ) internal returns (uint[] memory amounts)\\n  {\\n    amounts = UniswapV2Library.getAmountsOut(amountIn, path);\\n\\n    _safeTransferWrapper(address(path[0]), from, address(path[1] >> 1), amounts[0]);\\n    _swap(amounts, path, to);\\n  }\\n\\n  function _swapExactETHForTokens (\\n    uint256[] memory path,\\n    uint amountIn,\\n    address to\\n  ) internal returns (uint[] memory amounts)\\n  {\\n    amounts = UniswapV2Library.getAmountsOut(amountIn, path);\\n\\n    IWETH(path[0]).deposit{value: amounts[0]}();\\n    _safeTransferWrapper(address(path[0]), address(this), address(path[1] >> 1), amounts[0]);\\n\\n    _swap(amounts, path, to);\\n  }\\n\\n  function _swapExactTokensForETH (\\n    uint256[] memory path,\\n    uint amountIn,\\n    address from,\\n    address to,\\n    address weth\\n  ) internal returns (uint[] memory amounts)\\n  {\\n    amounts = UniswapV2Library.getAmountsOut(amountIn, path);\\n\\n    _safeTransferWrapper(address(path[0]), from, address(path[1] >> 1), amounts[0]);\\n    _swap(amounts, path, address(this));\\n\\n    uint256 finalOutputAmount = amounts[amounts.length - 1];\\n    IWETH(weth).withdraw(finalOutputAmount);\\n    _safeTransferETH(to, finalOutputAmount);\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"Erc20Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_domainSeparator\",\"type\":\"bytes32\"}],\"name\":\"createProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_domainSeparator\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemPermitAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"VirtualERC20FactoryMainnet","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"256","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"none"}]}