{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant LENDINGPOOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\\naddress constant LENDINGPOOL_ADDRESSES_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\\naddress constant PROTOCOL_DATA_PROVIDER = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;\\n\"\r\n    },\r\n    \"contracts/constants/CAaveServices.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant GELATO = 0x3CACa7b48D0573D793d3b0279b5F0029180E83b6;\\nstring constant OK = \\\"OK\\\";\\n\"\r\n    },\r\n    \"contracts/constants/CProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nuint256 constant DISCREPANCY_BPS_CAP = 500; // 5%\\nuint256 constant SLIPPAGE_BPS_CAP = 500; // 5%\\nuint256 constant TEN_THOUSAND_BPS = 1e4; // 100%\\n\"\r\n    },\r\n    \"contracts/functions/FProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {ILendingPool} from \\\"../interfaces/aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    IProtocolDataProvider\\n} from \\\"../interfaces/aave/IProtocolDataProvider.sol\\\";\\nimport {IPriceOracle} from \\\"../interfaces/aave/IPriceOracle.sol\\\";\\nimport {\\n    IProtectionAction\\n} from \\\"../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {PROTOCOL_DATA_PROVIDER} from \\\"../constants/CAave.sol\\\";\\nimport {TEN_THOUSAND_BPS} from \\\"../constants/CProtectionAction.sol\\\";\\nimport {\\n    ProtectionDataCompute,\\n    RepayAndFlashBorrowData,\\n    RepayAndFlashBorrowResult\\n} from \\\"../structs/SProtection.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {_qmul, _wdiv, _wmul} from \\\"../vendor/DSMath.sol\\\";\\n\\nfunction _getRepayAndFlashBorrowAmt(\\n    RepayAndFlashBorrowData memory _rAndWAmtData,\\n    ILendingPool _lendingPool,\\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider\\n) view returns (RepayAndFlashBorrowResult memory) {\\n    ProtectionDataCompute memory protectionDataCompute;\\n\\n    protectionDataCompute.onBehalfOf = _rAndWAmtData.user;\\n    protectionDataCompute.colToken = _rAndWAmtData.colToken;\\n    protectionDataCompute.debtToken = _rAndWAmtData.debtToken;\\n    protectionDataCompute.wantedHealthFactor = _rAndWAmtData.wantedHealthFactor;\\n\\n    (\\n        protectionDataCompute.totalCollateralETH,\\n        protectionDataCompute.totalBorrowsETH,\\n        ,\\n        protectionDataCompute.currentLiquidationThreshold,\\n        ,\\n\\n    ) = _lendingPool.getUserAccountData(_rAndWAmtData.user);\\n\\n    uint256[] memory pricesInETH;\\n    {\\n        address[] memory assets = new address[](2);\\n        assets[0] = _rAndWAmtData.colToken;\\n        assets[1] = _rAndWAmtData.debtToken;\\n        // index 0 is colToken to Eth price, and index 1 is debtToken to Eth price\\n        pricesInETH = IPriceOracle(\\n            _lendingPoolAddressesProvider.getPriceOracle()\\n        ).getAssetsPrices(assets);\\n\\n        protectionDataCompute.colPrice = pricesInETH[0];\\n        protectionDataCompute.debtPrice = pricesInETH[1];\\n    }\\n\\n    (\\n        ,\\n        ,\\n        protectionDataCompute.colLiquidationThreshold,\\n        ,\\n        ,\\n        ,\\n        ,\\n        ,\\n        ,\\n\\n    ) = IProtocolDataProvider(PROTOCOL_DATA_PROVIDER)\\n        .getReserveConfigurationData(_rAndWAmtData.colToken);\\n\\n    protectionDataCompute.protectionFeeInETH = _rAndWAmtData.protectionFeeInETH;\\n    protectionDataCompute.flashloanPremiumBps = _lendingPool\\n        .FLASHLOAN_PREMIUM_TOTAL();\\n\\n    return\\n        _amountToPaybackAndFlashBorrow(_rAndWAmtData.id, protectionDataCompute);\\n}\\n\\nfunction _amountToPaybackAndFlashBorrow(\\n    bytes32 _id,\\n    ProtectionDataCompute memory _protectionDataCompute\\n) view returns (RepayAndFlashBorrowResult memory) {\\n    uint256 intermediateValue = _wdiv(\\n        ((_wmul(\\n            _protectionDataCompute.wantedHealthFactor,\\n            _protectionDataCompute.totalBorrowsETH\\n        ) -\\n            (\\n                _qmul(\\n                    _protectionDataCompute.totalCollateralETH,\\n                    _protectionDataCompute.currentLiquidationThreshold\\n                )\\n            )) +\\n            _qmul(\\n                _protectionDataCompute.protectionFeeInETH,\\n                _protectionDataCompute.colLiquidationThreshold\\n            )),\\n        _protectionDataCompute.wantedHealthFactor -\\n            _qmul(\\n                _protectionDataCompute.colLiquidationThreshold,\\n                (TEN_THOUSAND_BPS + _protectionDataCompute.flashloanPremiumBps)\\n            ) *\\n            1e14\\n    );\\n\\n    uint256 colTokenDecimals = ERC20(_protectionDataCompute.colToken)\\n        .decimals();\\n    uint256 debtTokenDecimals = ERC20(_protectionDataCompute.debtToken)\\n        .decimals();\\n\\n    return\\n        RepayAndFlashBorrowResult(\\n            _id,\\n            _tokenToTokenPrecision(\\n                _wdiv(intermediateValue, _protectionDataCompute.colPrice),\\n                18,\\n                colTokenDecimals\\n            ),\\n            _tokenToTokenPrecision(\\n                _wdiv(intermediateValue, _protectionDataCompute.debtPrice),\\n                18,\\n                debtTokenDecimals\\n            ),\\n            \\\"OK\\\"\\n        );\\n}\\n\\nfunction _tokenToTokenPrecision(\\n    uint256 _amount,\\n    uint256 _oldPrecision,\\n    uint256 _newPrecision\\n) pure returns (uint256) {\\n    return\\n        _oldPrecision > _newPrecision\\n            ? _amount / (10**(_oldPrecision - _newPrecision))\\n            : _amount * (10**(_newPrecision - _oldPrecision));\\n}\\n\\nfunction _convertEthToToken(\\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider,\\n    address _token,\\n    uint256 _amount\\n) view returns (uint256) {\\n    address[] memory assets = new address[](1);\\n    assets[0] = _token;\\n    return\\n        _tokenToTokenPrecision(\\n            _wdiv(\\n                _amount,\\n                (\\n                    IPriceOracle(_lendingPoolAddressesProvider.getPriceOracle())\\n                        .getAssetsPrices(assets)\\n                )[0]\\n            ),\\n            18,\\n            ERC20(_token).decimals()\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/FProtectionResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ILendingPool} from \\\"../interfaces/aave/ILendingPool.sol\\\";\\nimport {LENDINGPOOL} from \\\"../constants/CAave.sol\\\";\\nimport {_wdiv, _wmul} from \\\"../vendor/DSMath.sol\\\";\\n\\n// Formula to get slippage from HealthFactor\\n/// @dev _currentHealthFactor current health factor\\n/// @dev _totalNormalizedCollateralInEth current total amount of Col x liquidation threshold\\n/// @dev _expectedTotalBorrowInEth expected total amount of Debt in Eth after protection\\nfunction getSlippageInETH(\\n    uint256 _currentHealthFactor,\\n    uint256 _totalNormalizedCollateralInEth,\\n    uint256 _expectedTotalBorrowInEth\\n) pure returns (uint256) {\\n    return\\n        _wdiv(\\n            _totalNormalizedCollateralInEth -\\n                _wmul(_currentHealthFactor, _expectedTotalBorrowInEth),\\n            _currentHealthFactor\\n        );\\n}\\n\\nfunction _isPositionUnsafe(address _user, uint256 _minimumHF)\\n    view\\n    returns (bool)\\n{\\n    (, , , , , uint256 currenthealthFactor) = ILendingPool(LENDINGPOOL)\\n        .getUserAccountData(_user);\\n    return currenthealthFactor < _minimumHF;\\n}\\n\\nfunction _isAllowed(\\n    address _aToken,\\n    address _user,\\n    address _spender,\\n    uint256 _allowedAmt\\n) view returns (bool) {\\n    return\\n        IERC20(_aToken).balanceOf(_user) >= _allowedAmt &&\\n        IERC20(_aToken).allowance(_user, _spender) >= _allowedAmt;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"./ILendingPoolAddressesProvider.sol\\\";\\nimport {DataTypes} from \\\"../../structs/SAave.sol\\\";\\n\\ninterface ILendingPool {\\n    /**\\n     * @dev Emitted on deposit()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address initiating the deposit\\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\n     * @param amount The amount deposited\\n     * @param referral The referral code used\\n     **/\\n    event Deposit(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint16 indexed referral\\n    );\\n\\n    /**\\n     * @dev Emitted on withdraw()\\n     * @param reserve The address of the underlyng asset being withdrawn\\n     * @param user The address initiating the withdrawal, owner of aTokens\\n     * @param to Address that will receive the underlying\\n     * @param amount The amount to be withdrawn\\n     **/\\n    event Withdraw(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n     * @param reserve The address of the underlying asset being borrowed\\n     * @param user The address of the user initiating the borrow(),\\n     * receiving the funds on borrow() or just\\n     * initiator of the transaction on flashLoan()\\n     * @param onBehalfOf The address that will be getting the debt\\n     * @param amount The amount borrowed out\\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\n     * @param borrowRate The numeric rate at which the user has borrowed\\n     * @param referral The referral code used\\n     **/\\n    event Borrow(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 borrowRateMode,\\n        uint256 borrowRate,\\n        uint16 indexed referral\\n    );\\n\\n    /**\\n     * @dev Emitted on repay()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The beneficiary of the repayment, getting his debt reduced\\n     * @param repayer The address of the user initiating the repay(), providing the funds\\n     * @param amount The amount repaid\\n     **/\\n    event Repay(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed repayer,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on swapBorrowRateMode()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user swapping his rate mode\\n     * @param rateMode The rate mode that the user wants to swap to\\n     **/\\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     **/\\n    event ReserveUsedAsCollateralEnabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     **/\\n    event ReserveUsedAsCollateralDisabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on rebalanceStableBorrowRate()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user for which the rebalance has been executed\\n     **/\\n    event RebalanceStableBorrowRate(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on flashLoan()\\n     * @param target The address of the flash loan receiver contract\\n     * @param initiator The address initiating the flash loan\\n     * @param asset The address of the asset being flash borrowed\\n     * @param amount The amount flash borrowed\\n     * @param premium The fee flash borrowed\\n     * @param referralCode The referral code used\\n     **/\\n    event FlashLoan(\\n        address indexed target,\\n        address indexed initiator,\\n        address indexed asset,\\n        uint256 amount,\\n        uint256 premium,\\n        uint16 referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted when the pause is triggered.\\n     */\\n    event Paused();\\n\\n    /**\\n     * @dev Emitted when the pause is lifted.\\n     */\\n    event Unpaused();\\n\\n    /**\\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\n     * LendingPoolCollateral manager using a DELEGATECALL\\n     * This allows to have the events in the generated ABI for LendingPool.\\n     * @param collateralAsset The address of the underlying asset used as collateral,\\n     * to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the\\n     * liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\n     * @param liquidator The address of the liquidator\\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens,\\n     * `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     **/\\n    event LiquidationCall(\\n        address indexed collateralAsset,\\n        address indexed debtAsset,\\n        address indexed user,\\n        uint256 debtToCover,\\n        uint256 liquidatedCollateralAmount,\\n        address liquidator,\\n        bool receiveAToken\\n    );\\n\\n    /**\\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\n     * in the ReserveLogic library and emitted in the updateInterestRates() function.\\n     * Since the function is internal, the event will actually be fired by the LendingPool contract.\\n     * The event is therefore replicated here so it\\n     * gets added to the LendingPool ABI\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param liquidityRate The new liquidity rate\\n     * @param stableBorrowRate The new stable borrow rate\\n     * @param variableBorrowRate The new variable borrow rate\\n     * @param liquidityIndex The new liquidity index\\n     * @param variableBorrowIndex The new variable borrow index\\n     **/\\n    event ReserveDataUpdated(\\n        address indexed reserve,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n\\n    /**\\n     * @dev Deposits an `amount` of underlying asset into the reserve,\\n     * receiving in return overlying aTokens.\\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to deposit\\n     * @param amount The amount to be deposited\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     * wants to receive them on his own wallet,\\n     * or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws an `amount` of underlying asset from the reserve,\\n     * burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to Address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     **/\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset,\\n     * provided that the borrower\\n     * already deposited enough collateral, or he was given enough allowance by a credit\\n     * delegator on the\\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address,\\n     * receiving the 100 USDC in his wallet\\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n     * @param asset The address of the underlying asset to borrow\\n     * @param amount The amount to be borrowed\\n     * @param interestRateMode The interest rate mode at which the user wants to borrow:\\n     * - 1 for Stable,\\n     * - 2 for Variable\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param onBehalfOf Address of the user who will receive the debt.\\n     * Should be the address of the borrower itself\\n     * calling the function if he wants to borrow against his own collateral,\\n     * or the address of the credit delegator\\n     * if he has been given credit delegation allowance\\n     **/\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve,\\n     * burning the equivalent debt tokens owned\\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt\\n     * tokens of the `onBehalfOf` address\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt\\n     * for `asset` on the specific `debtMode`\\n     * @param rateMode The interest rate mode at of the debt the user wants to repay:\\n     * - 1 for Stable,\\n     * - 2 for Variable\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed.\\n     * Should be the address of the user calling the function\\n     * if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @return The final amount repaid\\n     **/\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 rateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\n     * @param asset The address of the underlying asset borrowed\\n     * @param rateMode The rate mode that the user wants to swap to\\n     **/\\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\\n\\n    /**\\n     * @dev Rebalances the stable interest rate of a user to\\n     * the current stable rate defined on the reserve.\\n     * - Users can be rebalanced if the following conditions are satisfied:\\n     *     1. Usage ratio is above 95%\\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate,\\n     *        which means that too much has been\\n     *        borrowed at a stable rate and depositors are not earning enough\\n     * @param asset The address of the underlying asset borrowed\\n     * @param user The address of the user to be rebalanced\\n     **/\\n    function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n    /**\\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n     * @param asset The address of the underlying asset deposited\\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral,\\n     * `false` otherwise\\n     **/\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\\n        external;\\n\\n    /**\\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n     * - The caller (liquidator) covers `debtToCover` amount of debt\\n     * of the user getting liquidated, and receives\\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n     * @param collateralAsset The address of the underlying asset used as collateral,\\n     * to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset\\n     * to be repaid with the liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens,\\n     * `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     **/\\n    function liquidationCall(\\n        address collateralAsset,\\n        address debtAsset,\\n        address user,\\n        uint256 debtToCover,\\n        bool receiveAToken\\n    ) external;\\n\\n    /**\\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * IMPORTANT There are security concerns for developers\\n     * of flashloan receiver contracts that must be kept into consideration.\\n     * For further details please visit https://developers.aave.com\\n     * @param receiverAddress The address of the contract receiving the funds,\\n     * implementing the IFlashLoanReceiver interface\\n     * @param assets The addresses of the assets being flash-borrowed\\n     * @param amounts The amounts amounts being flash-borrowed\\n     * @param modes Types of the debt to open if the flash loan is not returned:\\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n     *   1 -> Open debt at stable rate for the value of the amount\\n     *        flash-borrowed to the `onBehalfOf` address\\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed\\n     *        to the `onBehalfOf` address\\n     * @param onBehalfOf The address  that will receive the debt in\\n     * the case of using on `modes` 1 or 2\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata modes,\\n        address onBehalfOf,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Returns the user account data across all the reserves\\n     * @param user The address of the user\\n     * @return totalCollateralETH the total collateral in ETH of the user\\n     * @return totalDebtETH the total debt in ETH of the user\\n     * @return availableBorrowsETH the borrowing power left of the user\\n     * @return currentLiquidationThreshold the liquidation threshold of the user\\n     * @return ltv the loan to value of the user\\n     * @return healthFactor the current health factor of the user\\n     **/\\n    function getUserAccountData(address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralETH,\\n            uint256 totalDebtETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    function initReserve(\\n        address reserve,\\n        address aTokenAddress,\\n        address stableDebtAddress,\\n        address variableDebtAddress,\\n        address interestRateStrategyAddress\\n    ) external;\\n\\n    function setReserveInterestRateStrategyAddress(\\n        address reserve,\\n        address rateStrategyAddress\\n    ) external;\\n\\n    function setConfiguration(address reserve, uint256 configuration) external;\\n\\n    /**\\n     * @dev Returns the configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The configuration of the reserve\\n     **/\\n    function getConfiguration(address asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory);\\n\\n    /**\\n     * @dev Returns the configuration of the user across all the reserves\\n     * @param user The user address\\n     * @return The configuration of the user\\n     **/\\n    function getUserConfiguration(address user)\\n        external\\n        view\\n        returns (DataTypes.UserConfigurationMap memory);\\n\\n    /**\\n     * @dev Returns the normalized income normalized income of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve's normalized income\\n     */\\n    function getReserveNormalizedIncome(address asset)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized variable debt per unit of asset\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve normalized variable debt\\n     */\\n    function getReserveNormalizedVariableDebt(address asset)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns the state and configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The state of the reserve\\n     **/\\n    function getReserveData(address asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory);\\n\\n    function finalizeTransfer(\\n        address asset,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 balanceFromAfter,\\n        uint256 balanceToBefore\\n    ) external;\\n\\n    function getReservesList() external view returns (address[] memory);\\n\\n    function getAddressesProvider()\\n        external\\n        view\\n        returns (ILendingPoolAddressesProvider);\\n\\n    function setPause(bool val) external;\\n\\n    function paused() external view returns (bool);\\n\\n    /// solhint-disable-next-line func-name-mixedcase\\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol,\\n * including permissioned roles\\n * - Acting also as factory of proxies and admin of those,\\n *   so with right to change its implementations\\n * - Owned by the Aave Governance\\n * @author Aave\\n **/\\ninterface ILendingPoolAddressesProvider {\\n    event MarketIdSet(string newMarketId);\\n    event LendingPoolUpdated(address indexed newAddress);\\n    event ConfigurationAdminUpdated(address indexed newAddress);\\n    event EmergencyAdminUpdated(address indexed newAddress);\\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\n    event PriceOracleUpdated(address indexed newAddress);\\n    event LendingRateOracleUpdated(address indexed newAddress);\\n    event ProxyCreated(bytes32 id, address indexed newAddress);\\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\n\\n    function getMarketId() external view returns (string memory);\\n\\n    function setMarketId(string calldata marketId) external;\\n\\n    function setAddress(bytes32 id, address newAddress) external;\\n\\n    function setAddressAsProxy(bytes32 id, address impl) external;\\n\\n    function getAddress(bytes32 id) external view returns (address);\\n\\n    function getLendingPool() external view returns (address);\\n\\n    function setLendingPoolImpl(address pool) external;\\n\\n    function getLendingPoolConfigurator() external view returns (address);\\n\\n    function setLendingPoolConfiguratorImpl(address configurator) external;\\n\\n    function getLendingPoolCollateralManager() external view returns (address);\\n\\n    function setLendingPoolCollateralManager(address manager) external;\\n\\n    function getPoolAdmin() external view returns (address);\\n\\n    function setPoolAdmin(address admin) external;\\n\\n    function getEmergencyAdmin() external view returns (address);\\n\\n    function setEmergencyAdmin(address admin) external;\\n\\n    function getPriceOracle() external view returns (address);\\n\\n    function setPriceOracle(address priceOracle) external;\\n\\n    function getLendingRateOracle() external view returns (address);\\n\\n    function setLendingRateOracle(address lendingRateOracle) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IPriceOracle {\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n\\n    function getAssetsPrices(address[] calldata _assets)\\n        external\\n        view\\n        returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IProtocolDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IProtocolDataProvider {\\n    function getReserveConfigurationData(address asset)\\n        external\\n        view\\n        returns (\\n            uint256 decimals,\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            uint256 reserveFactor,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive,\\n            bool isFrozen\\n        );\\n\\n    function getUserReserveData(address asset, address user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentStableDebt,\\n            uint256 currentVariableDebt,\\n            uint256 principalStableDebt,\\n            uint256 scaledVariableDebt,\\n            uint256 stableBorrowRate,\\n            uint256 liquidityRate,\\n            uint40 stableRateLastUpdated,\\n            bool usageAsCollateralEnabled\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/actions/IAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IAction {\\n    function exec(\\n        bytes32 _taskHash,\\n        bytes memory _data,\\n        bytes memory _offChainData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/actions/IProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {IAction} from \\\"./IAction.sol\\\";\\n\\ninterface IProtectionAction is IAction {\\n    /// sohint-disable-next-line func-name-mixedcase\\n    function slippageInBps() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/actions/IProtectionActionV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {IAction} from \\\"./IAction.sol\\\";\\nimport {ILendingPool} from \\\"../../aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../aave/ILendingPoolAddressesProvider.sol\\\";\\n\\ninterface IProtectionActionV2 is IAction {\\n    /// sohint-disable-next-line func-name-mixedcase\\n    function slippageInBps() external view returns (uint256);\\n\\n    /// sohint-disable-next-line func-name-mixedcase\\n    function LENDING_POOL() external view returns (ILendingPool);\\n\\n    /// sohint-disable-next-line func-name-mixedcase\\n    function ADDRESSES_PROVIDER()\\n        external\\n        view\\n        returns (ILendingPoolAddressesProvider);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoString.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.8.7;\\n\\nlibrary GelatoString {\\n    function startsWithOK(string memory _str) internal pure returns (bool) {\\n        if (\\n            bytes(_str).length >= 2 &&\\n            bytes(_str)[0] == \\\"O\\\" &&\\n            bytes(_str)[1] == \\\"K\\\"\\n        ) return true;\\n        return false;\\n    }\\n\\n    function revertWithInfo(string memory _error, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        revert(string(abi.encodePacked(_tracingInfo, _error)));\\n    }\\n\\n    function prefix(string memory _second, string memory _first)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n\\n    function suffix(string memory _first, string memory _second)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/services/aave/resolver/ProtectionResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {GelatoString} from \\\"../../../lib/GelatoString.sol\\\";\\nimport {ILendingPool} from \\\"../../../interfaces/aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    IProtocolDataProvider\\n} from \\\"../../../interfaces/aave/IProtocolDataProvider.sol\\\";\\nimport {\\n    IProtectionAction\\n} from \\\"../../../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {\\n    LENDINGPOOL,\\n    LENDINGPOOL_ADDRESSES_PROVIDER,\\n    PROTOCOL_DATA_PROVIDER\\n} from \\\"../../../constants/CAave.sol\\\";\\nimport {OK} from \\\"../../../constants/CAaveServices.sol\\\";\\nimport {\\n    RepayAndFlashBorrowData,\\n    RepayAndFlashBorrowResult,\\n    CanExecResult,\\n    CanExecData\\n} from \\\"../../../structs/SProtection.sol\\\";\\nimport {_getRepayAndFlashBorrowAmt} from \\\"../../../functions/FProtection.sol\\\";\\nimport {\\n    _isPositionUnsafe,\\n    _isAllowed\\n} from \\\"../../../functions/FProtectionResolver.sol\\\";\\n\\ncontract ProtectionResolver {\\n    using GelatoString for string;\\n    IProtectionAction public immutable protectionAction;\\n\\n    constructor(IProtectionAction _protectionAction) {\\n        protectionAction = _protectionAction;\\n    }\\n\\n    function multiRepayAndFlashBorrowAmt(\\n        RepayAndFlashBorrowData[] calldata _listRAndWAmt\\n    ) external view returns (RepayAndFlashBorrowResult[] memory) {\\n        RepayAndFlashBorrowResult[]\\n            memory results = new RepayAndFlashBorrowResult[](\\n                _listRAndWAmt.length\\n            );\\n\\n        for (uint256 i = 0; i < _listRAndWAmt.length; i++) {\\n            try this.getRepayAndFlashBorrowAmt(_listRAndWAmt[i]) returns (\\n                RepayAndFlashBorrowResult memory rAndWResult\\n            ) {\\n                results[i] = rAndWResult;\\n            } catch Error(string memory error) {\\n                results[i] = RepayAndFlashBorrowResult({\\n                    id: _listRAndWAmt[i].id,\\n                    amtToFlashBorrow: 0,\\n                    amtOfDebtToRepay: 0,\\n                    message: error.prefix(\\n                        \\\"ProtectionResolver.getRepayAndFlashBorrowAmt failed:\\\"\\n                    )\\n                });\\n            } catch {\\n                results[i] = RepayAndFlashBorrowResult({\\n                    id: _listRAndWAmt[i].id,\\n                    amtToFlashBorrow: 0,\\n                    amtOfDebtToRepay: 0,\\n                    message: \\\"ProtectionResolver.getRepayAndFlashBorrowAmt failed:undefined\\\"\\n                });\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    // solhint-disable-next-line function-max-lines\\n    function getRepayAndFlashBorrowAmt(\\n        RepayAndFlashBorrowData calldata _rAndWAmtData\\n    ) external view returns (RepayAndFlashBorrowResult memory) {\\n        return\\n            _getRepayAndFlashBorrowAmt(\\n                _rAndWAmtData,\\n                ILendingPool(LENDINGPOOL),\\n                ILendingPoolAddressesProvider(LENDINGPOOL_ADDRESSES_PROVIDER)\\n            );\\n    }\\n\\n    function multiCanExecute(CanExecData[] calldata _canExecDatas)\\n        external\\n        view\\n        returns (CanExecResult[] memory)\\n    {\\n        CanExecResult[] memory results = new CanExecResult[](\\n            _canExecDatas.length\\n        );\\n\\n        for (uint256 i = 0; i < _canExecDatas.length; i++) {\\n            try this.canExecute(_canExecDatas[i]) returns (\\n                CanExecResult memory canExecResult\\n            ) {\\n                results[i] = canExecResult;\\n            } catch Error(string memory error) {\\n                results[i] = CanExecResult({\\n                    id: _canExecDatas[i].id,\\n                    isPositionUnSafe: false,\\n                    isATokenAllowed: false,\\n                    message: error.prefix(\\n                        \\\"ProtectionResolver.canExecute failed:\\\"\\n                    )\\n                });\\n            } catch {\\n                results[i] = CanExecResult({\\n                    id: _canExecDatas[i].id,\\n                    isPositionUnSafe: false,\\n                    isATokenAllowed: false,\\n                    message: \\\"ProtectionResolver.canExecute failed:undefined\\\"\\n                });\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    function canExecute(CanExecData calldata _canExecData)\\n        external\\n        view\\n        returns (CanExecResult memory result)\\n    {\\n        (uint256 currentATokenBalance, , , , , , , , ) = IProtocolDataProvider(\\n            PROTOCOL_DATA_PROVIDER\\n        ).getUserReserveData(_canExecData.colToken, _canExecData.user);\\n\\n        result.id = _canExecData.id;\\n        result.isPositionUnSafe = _isPositionUnsafe(\\n            _canExecData.user,\\n            _canExecData.minimumHF\\n        );\\n        result.isATokenAllowed = _isAllowed(\\n            ILendingPool(LENDINGPOOL)\\n                .getReserveData(_canExecData.colToken)\\n                .aTokenAddress,\\n            _canExecData.user,\\n            _canExecData.spender,\\n            currentATokenBalance\\n        );\\n        result.message = OK;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/services/aave/resolver/ProtectionResolverV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {DataTypes} from \\\"../../../structs/SAave.sol\\\";\\nimport {UserConfiguration} from \\\"../../../vendor/aave/UserConfiguration.sol\\\";\\nimport {\\n    ReserveConfiguration\\n} from \\\"../../../vendor/aave/ReserveConfiguration.sol\\\";\\nimport {GelatoString} from \\\"../../../lib/GelatoString.sol\\\";\\nimport {ILendingPool} from \\\"../../../interfaces/aave/ILendingPool.sol\\\";\\nimport {IPriceOracle} from \\\"../../../interfaces/aave/IPriceOracle.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {\\n    IProtectionActionV2\\n} from \\\"../../../interfaces/services/actions/IProtectionActionV2.sol\\\";\\nimport {\\n    IProtectionAction\\n} from \\\"../../../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {\\n    CollateralAndLT,\\n    CalculateUserAccountDataVars,\\n    BestColAndDebtDataResult,\\n    DebtTknData,\\n    BestColAndDebtDataInput\\n} from \\\"../../../structs/SProtectionV2.sol\\\";\\nimport {ProtectionResolver} from \\\"./ProtectionResolver.sol\\\";\\n\\ncontract ProtectionResolverV2 is ProtectionResolver {\\n    using GelatoString for string;\\n    using UserConfiguration for DataTypes.UserConfigurationMap;\\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n\\n    constructor(IProtectionAction _protectionAction)\\n        ProtectionResolver(_protectionAction)\\n    {} // solhint-disable-line no-empty-blocks\\n\\n    /* solhint-disable function-max-lines */\\n    function multiGetBestColAndDebtData(\\n        BestColAndDebtDataInput[] memory _bestColAndDebtDataInputs\\n    ) external view returns (BestColAndDebtDataResult[] memory) {\\n        BestColAndDebtDataResult[]\\n            memory results = new BestColAndDebtDataResult[](\\n                _bestColAndDebtDataInputs.length\\n            );\\n\\n        for (uint256 i = 0; i < _bestColAndDebtDataInputs.length; i++) {\\n            try\\n                this.getBestColAndDebtData(_bestColAndDebtDataInputs[i])\\n            returns (BestColAndDebtDataResult memory bCAndDResult) {\\n                results[i] = bCAndDResult;\\n            } catch Error(string memory error) {\\n                results[i] = BestColAndDebtDataResult({\\n                    id: _bestColAndDebtDataInputs[i].id,\\n                    debtToken: DebtTknData({\\n                        reserve: address(0),\\n                        debtBalanceInETH: 0,\\n                        rateMode: 0\\n                    }),\\n                    colAndLTs: new CollateralAndLT[](0),\\n                    totalCollateralETH: 0,\\n                    totalDebtETH: 0,\\n                    currentLiquidationThreshold: 0,\\n                    flashloanPremiumBps: 0,\\n                    message: error.prefix(\\n                        \\\"ProtectionResolverV2.getBestColAndDebtData failed :\\\"\\n                    )\\n                });\\n            } catch {\\n                results[i] = BestColAndDebtDataResult({\\n                    id: _bestColAndDebtDataInputs[i].id,\\n                    debtToken: DebtTknData({\\n                        reserve: address(0),\\n                        debtBalanceInETH: 0,\\n                        rateMode: 0\\n                    }),\\n                    colAndLTs: new CollateralAndLT[](0),\\n                    totalCollateralETH: 0,\\n                    totalDebtETH: 0,\\n                    currentLiquidationThreshold: 0,\\n                    flashloanPremiumBps: 0,\\n                    message: \\\"ProtectionResolverV2.getBestColAndDebtData failed :undefined\\\"\\n                });\\n            }\\n        }\\n        return results;\\n    }\\n\\n    /* solhint-disable function-max-lines, code-complexity */\\n    function getBestColAndDebtData(\\n        BestColAndDebtDataInput memory _bestColAndDebtDataInput\\n    ) public view returns (BestColAndDebtDataResult memory result) {\\n        result.id = _bestColAndDebtDataInput.id;\\n        IProtectionActionV2 protectionActionV2 = IProtectionActionV2(\\n            address(protectionAction)\\n        );\\n\\n        ILendingPool lendingPool = protectionActionV2.LENDING_POOL();\\n\\n        DataTypes.UserConfigurationMap memory userConfig = lendingPool\\n            .getUserConfiguration(_bestColAndDebtDataInput.user);\\n        if (userConfig.isEmpty()) {\\n            return result;\\n        }\\n\\n        address[] memory reserveList = lendingPool.getReservesList();\\n        uint256[] memory pricesInETH = IPriceOracle(\\n            protectionActionV2.ADDRESSES_PROVIDER().getPriceOracle()\\n        ).getAssetsPrices(reserveList);\\n\\n        result.colAndLTs = new CollateralAndLT[](reserveList.length);\\n\\n        for (uint256 i = 0; i < reserveList.length; i++) {\\n            if (!userConfig.isUsingAsCollateralOrBorrowing(i)) continue;\\n            {\\n                CalculateUserAccountDataVars memory vars;\\n\\n                DataTypes.ReserveData memory reserveData = lendingPool\\n                    .getReserveData(reserveList[i]);\\n\\n                (, vars.liquidationThreshold, , vars.decimals, ) = reserveData\\n                    .configuration\\n                    .getParams();\\n\\n                vars.priceInETH = pricesInETH[i];\\n\\n                vars.collateralBalanceInETH =\\n                    (vars.priceInETH *\\n                        IERC20(reserveData.aTokenAddress).balanceOf(\\n                            _bestColAndDebtDataInput.user\\n                        )) /\\n                    10**vars.decimals;\\n\\n                if (userConfig.isBorrowing(i)) {\\n                    vars.stableDebtTokenBalanceInETH =\\n                        (vars.priceInETH *\\n                            IERC20(reserveData.stableDebtTokenAddress)\\n                                .balanceOf(_bestColAndDebtDataInput.user)) /\\n                        10**vars.decimals;\\n                    vars.variableDebtTokenBalanceInETH =\\n                        (vars.priceInETH *\\n                            IERC20(reserveData.variableDebtTokenAddress)\\n                                .balanceOf(_bestColAndDebtDataInput.user)) /\\n                        10**vars.decimals;\\n                }\\n\\n                result.colAndLTs[i] = CollateralAndLT(\\n                    reserveList[i],\\n                    vars.collateralBalanceInETH,\\n                    vars.liquidationThreshold\\n                );\\n\\n                if (\\n                    vars.variableDebtTokenBalanceInETH >\\n                    result.debtToken.debtBalanceInETH\\n                ) {\\n                    result.debtToken.reserve = reserveList[i];\\n                    result.debtToken.debtBalanceInETH = vars\\n                        .variableDebtTokenBalanceInETH;\\n                    result.debtToken.rateMode = 2;\\n                }\\n                if (\\n                    vars.stableDebtTokenBalanceInETH >\\n                    result.debtToken.debtBalanceInETH\\n                ) {\\n                    result.debtToken.reserve = reserveList[i];\\n                    result.debtToken.debtBalanceInETH = vars\\n                        .stableDebtTokenBalanceInETH;\\n                    result.debtToken.rateMode = 1;\\n                }\\n            }\\n        }\\n\\n        (\\n            result.totalCollateralETH,\\n            result.totalDebtETH,\\n            ,\\n            result.currentLiquidationThreshold,\\n            ,\\n\\n        ) = lendingPool.getUserAccountData(_bestColAndDebtDataInput.user);\\n\\n        result.flashloanPremiumBps = lendingPool.FLASHLOAN_PREMIUM_TOTAL();\\n        result.message = \\\"OK\\\";\\n    }\\n    /* solhint-enable function-max-lines, code-complexity */\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nlibrary DataTypes {\\n    // refer to the whitepaper,\\n    // section 1.1 basic concepts for a formal description of these properties.\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        //variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        //the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        uint40 lastUpdateTimestamp;\\n        //tokens addresses\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint8 id;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: LTV\\n        //bit 16-31: Liq. threshold\\n        //bit 32-47: Liq. bonus\\n        //bit 48-55: Decimals\\n        //bit 56: Reserve is active\\n        //bit 57: reserve is frozen\\n        //bit 58: borrowing is enabled\\n        //bit 59: stable rate borrowing enabled\\n        //bit 60-63: reserved\\n        //bit 64-79: reserve factor\\n        uint256 data;\\n    }\\n\\n    struct UserConfigurationMap {\\n        uint256 data;\\n    }\\n\\n    enum InterestRateMode {\\n        NONE,\\n        STABLE,\\n        VARIABLE\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nstruct ProtectionPayload {\\n    bytes32 taskHash;\\n    address colToken;\\n    address debtToken;\\n    uint256 rateMode;\\n    uint256 amtToFlashBorrow;\\n    uint256 amtOfDebtToRepay;\\n    uint256 minimumHealthFactor;\\n    uint256 wantedHealthFactor;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    address[] swapActions;\\n    bytes[] swapDatas;\\n    uint256 subBlockNumber;\\n    bool isPermanent;\\n}\\n\\nstruct ExecutionData {\\n    address user;\\n    address action;\\n    uint256 subBlockNumber;\\n    bytes data;\\n    bytes offChainData;\\n    bool isPermanent;\\n}\\n\\nstruct ProtectionDataCompute {\\n    address colToken;\\n    address debtToken;\\n    uint256 totalCollateralETH;\\n    uint256 totalBorrowsETH;\\n    uint256 currentLiquidationThreshold;\\n    uint256 colLiquidationThreshold;\\n    uint256 wantedHealthFactor;\\n    uint256 colPrice;\\n    uint256 debtPrice;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    uint256 flashloanPremiumBps;\\n}\\n\\nstruct FlashLoanData {\\n    address[] assets;\\n    uint256[] amounts;\\n    uint256[] premiums;\\n    bytes params;\\n}\\n\\nstruct FlashLoanParamsData {\\n    uint256 minimumHealthFactor;\\n    bytes32 taskHash;\\n    address debtToken;\\n    uint256 amtOfDebtToRepay;\\n    uint256 rateMode;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    address[] swapActions;\\n    bytes[] swapDatas;\\n}\\n\\nstruct RepayAndFlashBorrowData {\\n    bytes32 id;\\n    address user;\\n    address colToken;\\n    address debtToken;\\n    uint256 wantedHealthFactor;\\n    uint256 protectionFeeInETH;\\n}\\n\\nstruct RepayAndFlashBorrowResult {\\n    bytes32 id;\\n    uint256 amtToFlashBorrow;\\n    uint256 amtOfDebtToRepay;\\n    string message;\\n}\\n\\nstruct CanExecData {\\n    bytes32 id;\\n    address user;\\n    uint256 minimumHF;\\n    address colToken;\\n    address spender;\\n}\\n\\nstruct CanExecResult {\\n    bytes32 id;\\n    bool isPositionUnSafe;\\n    bool isATokenAllowed;\\n    string message;\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SProtectionV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nstruct CollateralAndLT {\\n    address reserve;\\n    uint256 collateralInETH;\\n    uint256 liquidationThreshold;\\n}\\n\\nstruct DebtTknData {\\n    address reserve;\\n    uint256 debtBalanceInETH;\\n    uint256 rateMode;\\n}\\n\\nstruct CalculateUserAccountDataVars {\\n    uint256 liquidationThreshold;\\n    uint256 decimals;\\n    uint256 priceInETH;\\n    uint256 collateralBalanceInETH;\\n    uint256 stableDebtTokenBalanceInETH;\\n    uint256 variableDebtTokenBalanceInETH;\\n}\\n\\nstruct BestColAndDebtDataInput {\\n    bytes32 id;\\n    address user;\\n}\\n\\nstruct BestColAndDebtDataResult {\\n    bytes32 id;\\n    DebtTknData debtToken;\\n    CollateralAndLT[] colAndLTs;\\n    uint256 totalCollateralETH;\\n    uint256 totalDebtETH;\\n    uint256 currentLiquidationThreshold;\\n    uint256 flashloanPremiumBps;\\n    string message;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n// solhint-disable\\nfunction _add(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\n\\nfunction _sub(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\n\\nfunction _mul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction _min(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction _max(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nfunction _imin(int256 x, int256 y) pure returns (int256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction _imax(int256 x, int256 y) pure returns (int256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint256 constant WAD = 10**18;\\nuint256 constant RAY = 10**27;\\nuint256 constant QUA = 10**4;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _wmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), WAD / 2) / WAD;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _rmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), RAY / 2) / RAY;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, WAD), y / 2) / y;\\n}\\n\\n//rounds to zero if x*y < RAY / 2\\nfunction _rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction _rpow(uint256 x, uint256 n) pure returns (uint256 z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = _rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = _rmul(z, x);\\n        }\\n    }\\n}\\n\\n//rounds to zero if x*y < QUA / 2\\nfunction _qmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), QUA / 2) / QUA;\\n}\\n\\n//rounds to zero if x*y < QUA / 2\\nfunction _qdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, QUA), y / 2) / y;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/aave/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\n/**\\n * @title Errors library\\n * @author Aave\\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - MATH = Math libraries\\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\\n *  - AT = AToken\\n *  - SDT = StableDebtToken\\n *  - VDT = VariableDebtToken\\n *  - LP = LendingPool\\n *  - LPAPR = LendingPoolAddressesProviderRegistry\\n *  - LPC = LendingPoolConfiguration\\n *  - RL = ReserveLogic\\n *  - LPCM = LendingPoolCollateralManager\\n *  - P = Pausable\\n */\\nlibrary Errors {\\n    //common errors\\n    string public constant CALLER_NOT_POOL_ADMIN = \\\"33\\\"; // 'The caller must be the pool admin'\\n    string public constant BORROW_ALLOWANCE_NOT_ENOUGH = \\\"59\\\"; // User borrows on behalf, but allowance are too small\\n\\n    //contract specific errors\\n    string public constant VL_INVALID_AMOUNT = \\\"1\\\"; // 'Amount must be greater than 0'\\n    string public constant VL_NO_ACTIVE_RESERVE = \\\"2\\\"; // 'Action requires an active reserve'\\n    string public constant VL_RESERVE_FROZEN = \\\"3\\\"; // 'Action cannot be performed because the reserve is frozen'\\n    string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = \\\"4\\\"; // 'The current liquidity is not enough'\\n    string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \\\"5\\\"; // 'User cannot withdraw more than the available balance'\\n    string public constant VL_TRANSFER_NOT_ALLOWED = \\\"6\\\"; // 'Transfer cannot be allowed.'\\n    string public constant VL_BORROWING_NOT_ENABLED = \\\"7\\\"; // 'Borrowing is not enabled'\\n    string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = \\\"8\\\"; // 'Invalid interest rate mode selected'\\n    string public constant VL_COLLATERAL_BALANCE_IS_0 = \\\"9\\\"; // 'The collateral balance is 0'\\n    string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD =\\n        \\\"10\\\"; // 'Health factor is lesser than the liquidation threshold'\\n    string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \\\"11\\\"; // 'There is not enough collateral to cover a new borrow'\\n    string public constant VL_STABLE_BORROWING_NOT_ENABLED = \\\"12\\\"; // stable borrowing not enabled\\n    string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = \\\"13\\\"; // collateral is (mostly) the same currency that is being borrowed\\n    string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \\\"14\\\"; // 'The requested amount is greater than the max loan size in stable rate mode\\n    string public constant VL_NO_DEBT_OF_SELECTED_TYPE = \\\"15\\\"; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\\n    string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \\\"16\\\"; // 'To repay on behalf of an user an explicit amount to repay is needed'\\n    string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = \\\"17\\\"; // 'User does not have a stable rate loan in progress on this reserve'\\n    string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = \\\"18\\\"; // 'User does not have a variable rate loan in progress on this reserve'\\n    string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = \\\"19\\\"; // 'The underlying balance needs to be greater than 0'\\n    string public constant VL_DEPOSIT_ALREADY_IN_USE = \\\"20\\\"; // 'User deposit is already being used as collateral'\\n    string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = \\\"21\\\"; // 'User does not have any stable rate loan for this reserve'\\n    string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \\\"22\\\"; // 'Interest rate rebalance conditions were not met'\\n    string public constant LP_LIQUIDATION_CALL_FAILED = \\\"23\\\"; // 'Liquidation call failed'\\n    string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = \\\"24\\\"; // 'There is not enough liquidity available to borrow'\\n    string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = \\\"25\\\"; // 'The requested amount is too small for a FlashLoan.'\\n    string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = \\\"26\\\"; // 'The actual balance of the protocol is inconsistent'\\n    string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = \\\"27\\\"; // 'The caller of the function is not the lending pool configurator'\\n    string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = \\\"28\\\";\\n    string public constant CT_CALLER_MUST_BE_LENDING_POOL = \\\"29\\\"; // 'The caller of this function must be a lending pool'\\n    string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = \\\"30\\\"; // 'User cannot give allowance to himself'\\n    string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = \\\"31\\\"; // 'Transferred amount needs to be greater than zero'\\n    string public constant RL_RESERVE_ALREADY_INITIALIZED = \\\"32\\\"; // 'Reserve has already been initialized'\\n    string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = \\\"34\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = \\\"35\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = \\\"36\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = \\\"37\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS =\\n        \\\"38\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS =\\n        \\\"39\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = \\\"40\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant LPC_INVALID_CONFIGURATION = \\\"75\\\"; // 'Invalid risk parameters for the reserve'\\n    string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = \\\"76\\\"; // 'The caller must be the emergency admin'\\n    string public constant LPAPR_PROVIDER_NOT_REGISTERED = \\\"41\\\"; // 'Provider is not registered'\\n    string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \\\"42\\\"; // 'Health factor is not below the threshold'\\n    string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = \\\"43\\\"; // 'The collateral chosen cannot be liquidated'\\n    string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \\\"44\\\"; // 'User did not borrow the specified currency'\\n    string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = \\\"45\\\"; // \\\"There isn't enough liquidity available to liquidate\\\"\\n    string public constant LPCM_NO_ERRORS = \\\"46\\\"; // 'No errors'\\n    string public constant LP_INVALID_FLASHLOAN_MODE = \\\"47\\\"; //Invalid flashloan mode selected\\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"48\\\";\\n    string public constant MATH_ADDITION_OVERFLOW = \\\"49\\\";\\n    string public constant MATH_DIVISION_BY_ZERO = \\\"50\\\";\\n    string public constant RL_LIQUIDITY_INDEX_OVERFLOW = \\\"51\\\"; //  Liquidity index overflows uint128\\n    string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \\\"52\\\"; //  Variable borrow index overflows uint128\\n    string public constant RL_LIQUIDITY_RATE_OVERFLOW = \\\"53\\\"; //  Liquidity rate overflows uint128\\n    string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \\\"54\\\"; //  Variable borrow rate overflows uint128\\n    string public constant RL_STABLE_BORROW_RATE_OVERFLOW = \\\"55\\\"; //  Stable borrow rate overflows uint128\\n    string public constant CT_INVALID_MINT_AMOUNT = \\\"56\\\"; //invalid amount to mint\\n    string public constant LP_FAILED_REPAY_WITH_COLLATERAL = \\\"57\\\";\\n    string public constant CT_INVALID_BURN_AMOUNT = \\\"58\\\"; //invalid amount to burn\\n    string public constant LP_FAILED_COLLATERAL_SWAP = \\\"60\\\";\\n    string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = \\\"61\\\";\\n    string public constant LP_REENTRANCY_NOT_ALLOWED = \\\"62\\\";\\n    string public constant LP_CALLER_MUST_BE_AN_ATOKEN = \\\"63\\\";\\n    string public constant LP_IS_PAUSED = \\\"64\\\"; // 'Pool is paused'\\n    string public constant LP_NO_MORE_RESERVES_ALLOWED = \\\"65\\\";\\n    string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = \\\"66\\\";\\n    string public constant RC_INVALID_LTV = \\\"67\\\";\\n    string public constant RC_INVALID_LIQ_THRESHOLD = \\\"68\\\";\\n    string public constant RC_INVALID_LIQ_BONUS = \\\"69\\\";\\n    string public constant RC_INVALID_DECIMALS = \\\"70\\\";\\n    string public constant RC_INVALID_RESERVE_FACTOR = \\\"71\\\";\\n    string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = \\\"72\\\";\\n    string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = \\\"73\\\";\\n    string public constant LP_INCONSISTENT_PARAMS_LENGTH = \\\"74\\\";\\n    string public constant UL_INVALID_INDEX = \\\"77\\\";\\n    string public constant LP_NOT_CONTRACT = \\\"78\\\";\\n    string public constant SDT_STABLE_DEBT_OVERFLOW = \\\"79\\\";\\n    string public constant SDT_BURN_EXCEEDS_BALANCE = \\\"80\\\";\\n\\n    enum CollateralManagerErrors {\\n        NO_ERROR,\\n        NO_COLLATERAL_AVAILABLE,\\n        COLLATERAL_CANNOT_BE_LIQUIDATED,\\n        CURRRENCY_NOT_BORROWED,\\n        HEALTH_FACTOR_ABOVE_THRESHOLD,\\n        NOT_ENOUGH_LIQUIDITY,\\n        NO_ACTIVE_RESERVE,\\n        HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\\n        INVALID_EQUAL_ASSETS_TO_SWAP,\\n        FROZEN_RESERVE\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/aave/ReserveConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\nimport {DataTypes} from \\\"../../structs/SAave.sol\\\";\\n\\n/**\\n * @title ReserveConfiguration library\\n * @author Aave\\n * @notice Implements the bitmap logic to handle the reserve configuration\\n */\\nlibrary ReserveConfiguration {\\n    uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n    uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n    uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n    uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n    /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n    uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n    uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n    uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\\n    uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\\n    uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\\n    uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\\n    uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\\n    uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\n\\n    uint256 constant MAX_VALID_LTV = 65535;\\n    uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n    uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\n    uint256 constant MAX_VALID_DECIMALS = 255;\\n    uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\\n\\n    /**\\n     * @dev Sets the Loan to Value of the reserve\\n     * @param self The reserve configuration\\n     * @param ltv the new ltv\\n     **/\\n    function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv)\\n        internal\\n        pure\\n    {\\n        require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\n\\n        self.data = (self.data & LTV_MASK) | ltv;\\n    }\\n\\n    /**\\n     * @dev Gets the Loan to Value of the reserve\\n     * @param self The reserve configuration\\n     * @return The loan to value\\n     **/\\n    function getLtv(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.data & ~LTV_MASK;\\n    }\\n\\n    /**\\n     * @dev Sets the liquidation threshold of the reserve\\n     * @param self The reserve configuration\\n     * @param threshold The new liquidation threshold\\n     **/\\n    function setLiquidationThreshold(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 threshold\\n    ) internal pure {\\n        require(\\n            threshold <= MAX_VALID_LIQUIDATION_THRESHOLD,\\n            Errors.RC_INVALID_LIQ_THRESHOLD\\n        );\\n\\n        self.data =\\n            (self.data & LIQUIDATION_THRESHOLD_MASK) |\\n            (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the liquidation threshold of the reserve\\n     * @param self The reserve configuration\\n     * @return The liquidation threshold\\n     **/\\n    function getLiquidationThreshold(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return\\n            (self.data & ~LIQUIDATION_THRESHOLD_MASK) >>\\n            LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the liquidation bonus of the reserve\\n     * @param self The reserve configuration\\n     * @param bonus The new liquidation bonus\\n     **/\\n    function setLiquidationBonus(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 bonus\\n    ) internal pure {\\n        require(\\n            bonus <= MAX_VALID_LIQUIDATION_BONUS,\\n            Errors.RC_INVALID_LIQ_BONUS\\n        );\\n\\n        self.data =\\n            (self.data & LIQUIDATION_BONUS_MASK) |\\n            (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the liquidation bonus of the reserve\\n     * @param self The reserve configuration\\n     * @return The liquidation bonus\\n     **/\\n    function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            (self.data & ~LIQUIDATION_BONUS_MASK) >>\\n            LIQUIDATION_BONUS_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the decimals of the underlying asset of the reserve\\n     * @param self The reserve configuration\\n     * @param decimals The decimals\\n     **/\\n    function setDecimals(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 decimals\\n    ) internal pure {\\n        require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\\n\\n        self.data =\\n            (self.data & DECIMALS_MASK) |\\n            (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the decimals of the underlying asset of the reserve\\n     * @param self The reserve configuration\\n     * @return The decimals of the asset\\n     **/\\n    function getDecimals(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the active state of the reserve\\n     * @param self The reserve configuration\\n     * @param active The active state\\n     **/\\n    function setActive(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool active\\n    ) internal pure {\\n        self.data =\\n            (self.data & ACTIVE_MASK) |\\n            (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the active state of the reserve\\n     * @param self The reserve configuration\\n     * @return The active state\\n     **/\\n    function getActive(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return (self.data & ~ACTIVE_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the frozen state of the reserve\\n     * @param self The reserve configuration\\n     * @param frozen The frozen state\\n     **/\\n    function setFrozen(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool frozen\\n    ) internal pure {\\n        self.data =\\n            (self.data & FROZEN_MASK) |\\n            (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the frozen state of the reserve\\n     * @param self The reserve configuration\\n     * @return The frozen state\\n     **/\\n    function getFrozen(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return (self.data & ~FROZEN_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Enables or disables borrowing on the reserve\\n     * @param self The reserve configuration\\n     * @param enabled True if the borrowing needs to be enabled, false otherwise\\n     **/\\n    function setBorrowingEnabled(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool enabled\\n    ) internal pure {\\n        self.data =\\n            (self.data & BORROWING_MASK) |\\n            (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the borrowing state of the reserve\\n     * @param self The reserve configuration\\n     * @return The borrowing state\\n     **/\\n    function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return (self.data & ~BORROWING_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Enables or disables stable rate borrowing on the reserve\\n     * @param self The reserve configuration\\n     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\\n     **/\\n    function setStableRateBorrowingEnabled(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool enabled\\n    ) internal pure {\\n        self.data =\\n            (self.data & STABLE_BORROWING_MASK) |\\n            (uint256(enabled ? 1 : 0) <<\\n                STABLE_BORROWING_ENABLED_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the stable rate borrowing state of the reserve\\n     * @param self The reserve configuration\\n     * @return The stable rate borrowing state\\n     **/\\n    function getStableRateBorrowingEnabled(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (bool) {\\n        return (self.data & ~STABLE_BORROWING_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the reserve factor of the reserve\\n     * @param self The reserve configuration\\n     * @param reserveFactor The reserve factor\\n     **/\\n    function setReserveFactor(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 reserveFactor\\n    ) internal pure {\\n        require(\\n            reserveFactor <= MAX_VALID_RESERVE_FACTOR,\\n            Errors.RC_INVALID_RESERVE_FACTOR\\n        );\\n\\n        self.data =\\n            (self.data & RESERVE_FACTOR_MASK) |\\n            (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the reserve factor of the reserve\\n     * @param self The reserve configuration\\n     * @return The reserve factor\\n     **/\\n    function getReserveFactor(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            (self.data & ~RESERVE_FACTOR_MASK) >>\\n            RESERVE_FACTOR_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Gets the configuration flags of the reserve\\n     * @param self The reserve configuration\\n     * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n     **/\\n    function getFlags(DataTypes.ReserveConfigurationMap storage self)\\n        internal\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        uint256 dataLocal = self.data;\\n\\n        return (\\n            (dataLocal & ~ACTIVE_MASK) != 0,\\n            (dataLocal & ~FROZEN_MASK) != 0,\\n            (dataLocal & ~BORROWING_MASK) != 0,\\n            (dataLocal & ~STABLE_BORROWING_MASK) != 0\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the configuration paramters of the reserve\\n     * @param self The reserve configuration\\n     * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n     **/\\n    function getParams(DataTypes.ReserveConfigurationMap memory self)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 dataLocal = self.data;\\n\\n        return (\\n            dataLocal & ~LTV_MASK,\\n            (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\\n                LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n            (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\\n                LIQUIDATION_BONUS_START_BIT_POSITION,\\n            (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n            (dataLocal & ~RESERVE_FACTOR_MASK) >>\\n                RESERVE_FACTOR_START_BIT_POSITION\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the configuration paramters of the reserve from a memory object\\n     * @param self The reserve configuration\\n     * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n     **/\\n    function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            self.data & ~LTV_MASK,\\n            (self.data & ~LIQUIDATION_THRESHOLD_MASK) >>\\n                LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n            (self.data & ~LIQUIDATION_BONUS_MASK) >>\\n                LIQUIDATION_BONUS_START_BIT_POSITION,\\n            (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n            (self.data & ~RESERVE_FACTOR_MASK) >>\\n                RESERVE_FACTOR_START_BIT_POSITION\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the configuration flags of the reserve from a memory object\\n     * @param self The reserve configuration\\n     * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n     **/\\n    function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        return (\\n            (self.data & ~ACTIVE_MASK) != 0,\\n            (self.data & ~FROZEN_MASK) != 0,\\n            (self.data & ~BORROWING_MASK) != 0,\\n            (self.data & ~STABLE_BORROWING_MASK) != 0\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/aave/UserConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\nimport {DataTypes} from \\\"../../structs/SAave.sol\\\";\\n\\n/**\\n * @title UserConfiguration library\\n * @author Aave\\n * @notice Implements the bitmap logic to handle the user configuration\\n */\\nlibrary UserConfiguration {\\n    uint256 internal constant BORROWING_MASK =\\n        0x5555555555555555555555555555555555555555555555555555555555555555;\\n\\n    /**\\n     * @dev Sets if the user is borrowing the reserve identified by reserveIndex\\n     * @param self The configuration object\\n     * @param reserveIndex The index of the reserve in the bitmap\\n     * @param borrowing True if the user is borrowing the reserve, false otherwise\\n     **/\\n    function setBorrowing(\\n        DataTypes.UserConfigurationMap storage self,\\n        uint256 reserveIndex,\\n        bool borrowing\\n    ) internal {\\n        require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\\n        self.data =\\n            (self.data & ~(1 << (reserveIndex * 2))) |\\n            (uint256(borrowing ? 1 : 0) << (reserveIndex * 2));\\n    }\\n\\n    /**\\n     * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\\n     * @param self The configuration object\\n     * @param reserveIndex The index of the reserve in the bitmap\\n     * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\\n     **/\\n    function setUsingAsCollateral(\\n        DataTypes.UserConfigurationMap storage self,\\n        uint256 reserveIndex,\\n        bool usingAsCollateral\\n    ) internal {\\n        require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\\n        self.data =\\n            (self.data & ~(1 << (reserveIndex * 2 + 1))) |\\n            (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1));\\n    }\\n\\n    /**\\n     * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\\n     * @param self The configuration object\\n     * @param reserveIndex The index of the reserve in the bitmap\\n     * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\\n     **/\\n    function isUsingAsCollateralOrBorrowing(\\n        DataTypes.UserConfigurationMap memory self,\\n        uint256 reserveIndex\\n    ) internal pure returns (bool) {\\n        require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\\n        return (self.data >> (reserveIndex * 2)) & 3 != 0;\\n    }\\n\\n    /**\\n     * @dev Used to validate if a user has been using the reserve for borrowing\\n     * @param self The configuration object\\n     * @param reserveIndex The index of the reserve in the bitmap\\n     * @return True if the user has been using a reserve for borrowing, false otherwise\\n     **/\\n    function isBorrowing(\\n        DataTypes.UserConfigurationMap memory self,\\n        uint256 reserveIndex\\n    ) internal pure returns (bool) {\\n        require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\\n        return (self.data >> (reserveIndex * 2)) & 1 != 0;\\n    }\\n\\n    /**\\n     * @dev Used to validate if a user has been using the reserve as collateral\\n     * @param self The configuration object\\n     * @param reserveIndex The index of the reserve in the bitmap\\n     * @return True if the user has been using a reserve as collateral, false otherwise\\n     **/\\n    function isUsingAsCollateral(\\n        DataTypes.UserConfigurationMap memory self,\\n        uint256 reserveIndex\\n    ) internal pure returns (bool) {\\n        require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\\n        return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0;\\n    }\\n\\n    /**\\n     * @dev Used to validate if a user has been borrowing from any reserve\\n     * @param self The configuration object\\n     * @return True if the user has been borrowing any reserve, false otherwise\\n     **/\\n    function isBorrowingAny(DataTypes.UserConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return self.data & BORROWING_MASK != 0;\\n    }\\n\\n    /**\\n     * @dev Used to validate if a user has not been using any reserve\\n     * @param self The configuration object\\n     * @return True if the user has been borrowing any reserve, false otherwise\\n     **/\\n    function isEmpty(DataTypes.UserConfigurationMap memory self)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return self.data == 0;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IProtectionAction\",\"name\":\"_protectionAction\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumHF\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"internalType\":\"struct CanExecData\",\"name\":\"_canExecData\",\"type\":\"tuple\"}],\"name\":\"canExecute\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isPositionUnSafe\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isATokenAllowed\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct CanExecResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct BestColAndDebtDataInput\",\"name\":\"_bestColAndDebtDataInput\",\"type\":\"tuple\"}],\"name\":\"getBestColAndDebtData\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtBalanceInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"}],\"internalType\":\"struct DebtTknData\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationThreshold\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralAndLT[]\",\"name\":\"colAndLTs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLiquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashloanPremiumBps\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct BestColAndDebtDataResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantedHealthFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protectionFeeInETH\",\"type\":\"uint256\"}],\"internalType\":\"struct RepayAndFlashBorrowData\",\"name\":\"_rAndWAmtData\",\"type\":\"tuple\"}],\"name\":\"getRepayAndFlashBorrowAmt\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amtToFlashBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amtOfDebtToRepay\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct RepayAndFlashBorrowResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumHF\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"internalType\":\"struct CanExecData[]\",\"name\":\"_canExecDatas\",\"type\":\"tuple[]\"}],\"name\":\"multiCanExecute\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isPositionUnSafe\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isATokenAllowed\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct CanExecResult[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct BestColAndDebtDataInput[]\",\"name\":\"_bestColAndDebtDataInputs\",\"type\":\"tuple[]\"}],\"name\":\"multiGetBestColAndDebtData\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtBalanceInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"}],\"internalType\":\"struct DebtTknData\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationThreshold\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralAndLT[]\",\"name\":\"colAndLTs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLiquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashloanPremiumBps\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct BestColAndDebtDataResult[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantedHealthFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protectionFeeInETH\",\"type\":\"uint256\"}],\"internalType\":\"struct RepayAndFlashBorrowData[]\",\"name\":\"_listRAndWAmt\",\"type\":\"tuple[]\"}],\"name\":\"multiRepayAndFlashBorrowAmt\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amtToFlashBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amtOfDebtToRepay\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct RepayAndFlashBorrowResult[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protectionAction\",\"outputs\":[{\"internalType\":\"contract IProtectionAction\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProtectionResolverV2","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000d2579361f3c402938841774ecc1acdd51d3a4345","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}