{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/adapter/wsOHMAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/ICSSRAdapter.sol\\\";\\nimport \\\"../interfaces/ICSSRRouter.sol\\\";\\nimport \\\"../interfaces/wsOHM/IWSOHM.sol\\\";\\n\\ncontract wsOHMAdapter is ICSSRAdapter {\\n    ICSSRRouter public immutable cssrRouter;\\n    address public immutable ohm;\\n    IWSOHM public immutable wsOHM;\\n\\n    constructor(address _cssr, address _ohm, address _wsOHM) {\\n        cssrRouter = ICSSRRouter(_cssr);\\n        ohm = _ohm;\\n        wsOHM = IWSOHM(_wsOHM);\\n    }\\n\\n    function update(address _asset, bytes calldata _data)\\n        external\\n        override\\n        returns (float memory)\\n    {\\n        return getPrice(_asset);\\n    }\\n    \\n    function support(address _asset) external view override returns (bool) {\\n        return _asset == address(wsOHM);\\n    }\\n\\n    function getPrice(address _asset) public view override returns(float memory) {\\n        require(_asset == address(wsOHM), \\\"!support\\\");\\n        float memory ohmPrice = cssrRouter.getPrice(ohm);\\n        return float({\\n            numerator: wsOHM.wOHMTosOHM(ohmPrice.numerator),\\n            denominator: ohmPrice.denominator\\n        });\\n    }\\n\\n    function getLiquidity(address _asset)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        revert(\\\"chainlink adapter does not support liquidity\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICSSRAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\ninterface ICSSRAdapter {\\n    function update(address _asset, bytes memory _data)\\n        external\\n        returns (float memory price);\\n\\n    function support(address _asset) external view returns (bool);\\n\\n    function getPrice(address _asset)\\n        external\\n        view\\n        returns (float memory price);\\n\\n    function getLiquidity(address _asset)\\n        external\\n        view\\n        returns (uint256 _liquidity);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICSSRRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\ninterface ICSSRRouter {\\n    function update(address _asset, bytes memory _data)\\n        external\\n        returns (float memory);\\n\\n    function getPrice(address _asset) external view returns (float memory);\\n\\n    function getLiquidity(address _asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/wsOHM/IWSOHM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWSOHM {\\n    function wOHMTosOHM(uint256 wohm) external view returns(uint256);\\n    function sOHMTowOHM(uint256 wsohm) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"@mochifi/library/contracts/Float.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nstruct float {\\n    uint256 numerator;\\n    uint256 denominator;\\n}\\n\\nlibrary Float {\\n    function multiply(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.numerator / f.denominator;\\n    }\\n\\n    function inverse(float memory f) internal pure returns(float memory) {\\n        require(f.numerator != 0 && f.denominator != 0, \\\"div 0\\\");\\n        return float({\\n            numerator: f.denominator,\\n            denominator: f.numerator\\n        });\\n    }\\n\\n    function divide(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.denominator / f.numerator;\\n    }\\n\\n    function add(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator + a.denominator*b.numerator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n    \\n    function sub(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator - b.numerator*a.denominator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function mul(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator * b.numerator,\\n            denominator : a.denominator * b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function gt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator > a.denominator * b.numerator;\\n    }\\n\\n    function lt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator < a.denominator * b.numerator;\\n    }\\n\\n    function gte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator >= a.denominator * b.numerator;\\n    }\\n\\n    function lte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator <= a.denominator * b.numerator;\\n    }\\n\\n    function equals(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator == b.numerator * a.denominator;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cssr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ohm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wsOHM\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"cssrRouter\",\"outputs\":[{\"internalType\":\"contract ICSSRRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct float\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ohm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"support\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"update\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct float\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wsOHM\",\"outputs\":[{\"internalType\":\"contract IWSOHM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"wsOHMAdapter","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000766f7f7e249dbd0003916f52b2efe1ac44dad836000000000000000000000000383518188c0c6d7730d91b2c03a03c837814a899000000000000000000000000ca76543cf381ebbb277be79574059e32108e3e65","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}