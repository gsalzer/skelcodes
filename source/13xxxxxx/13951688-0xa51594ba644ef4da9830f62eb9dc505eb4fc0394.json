{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.11;\r\n\r\n/// @title AvsBGame\r\n/// @notice A Liar's Game: Vote by putting ETH behind A or B ... the side with the least votes gets all the ETH\r\n/// @author AvsB Team\r\n/// @dev Built using a Commit-Reveal scheme\r\ncontract AvsBGame {\r\n    /// ============ Types ============\r\n\r\n    // Possible votes (and Hidden before votes are revealed)\r\n    enum Choice {\r\n        Hidden,\r\n        A,\r\n        B\r\n    }\r\n\r\n    // A cryptographic committment to a certain vote\r\n    struct VoteCommit {\r\n        bytes32 commitment;\r\n        uint256 amount;\r\n        Choice choice;\r\n    }\r\n\r\n    /// ============ Immutable storage ============\r\n\r\n    uint256 public immutable voteDeadline = 1642233600; // Vote phase ends Jan 15, 2022\r\n    uint256 public immutable revealDeadline = 1642665600; // Reveal phase ends Jan 20, 2022\r\n    uint256 public immutable minVoteIncrement = 1e16; // 0.01 ETH\r\n    uint256 public immutable maxVoteAmount = 1e18; // 1 ETH\r\n    uint256 public immutable fee = 20; // 5% fee (1/20th), paid out at reveal\r\n    address public immutable feeAddress =\r\n        0x7B91649D893B2e4Feef78b6891dE383d5a8491eE;\r\n\r\n    /// ============ Mutable storage ============\r\n\r\n    // Tracks vote commitments\r\n    mapping(address => VoteCommit) public votes;\r\n\r\n    // Tracks revealed votes, updated every reveal\r\n    // We need to track these because some votes may remain unrevealed\r\n    uint256 public revealedA = 0;\r\n    uint256 public revealedB = 0;\r\n\r\n    // Stores total prize pool (only updated during payout phase)\r\n    uint256 public prizePool = 0;\r\n\r\n    /// ============ Events ============\r\n\r\n    event Vote(address indexed player, uint256 amount);\r\n    event Reveal(address indexed player, Choice choice);\r\n    event Payout(address indexed player, uint256 amount);\r\n\r\n    constructor() {}\r\n\r\n    /// ============ Functions ============\r\n\r\n    /// @notice Cast a vote without revealing the vote by posting a commitment\r\n    /// @param commitment Commitment to A or B, by commit-reveal scheme\r\n    function castHiddenVote(bytes32 commitment) external payable {\r\n        // Ensure vote is placed before vote deadline\r\n        require(\r\n            block.timestamp <= voteDeadline,\r\n            \"Cannot vote past vote deadline.\"\r\n        );\r\n\r\n        // Ensure vote is greater than and a multiple of min vote increment\r\n        require(\r\n            (msg.value >= minVoteIncrement) &&\r\n                (msg.value % minVoteIncrement == 0),\r\n            \"Vote value must be greater than and multiple of min vote amount.\"\r\n        );\r\n\r\n        // Ensure vote is less than max vote amount\r\n        require(\r\n            msg.value <= maxVoteAmount,\r\n            \"Vote value must be less than max vote amount.\"\r\n        );\r\n\r\n        // Ensure player has not voted before\r\n        require(votes[msg.sender].amount == 0, \"Cannot vote twice.\");\r\n\r\n        // Store the commitment for the commit-reveal scheme\r\n        votes[msg.sender] = VoteCommit(commitment, msg.value, Choice.Hidden);\r\n\r\n        // Emit Vote event\r\n        emit Vote(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Reveal a vote that was previously commited to\r\n    /// @param choice Choice that is being revealed by sender\r\n    /// @param blindingFactor Salt used by the voter in their previous vote commitment\r\n    function reveal(Choice choice, bytes32 blindingFactor) external {\r\n        // Ensure reveal is before reveal deadline (\"early\" reveals during voting period are technically permitted)\r\n        require(\r\n            block.timestamp <= revealDeadline,\r\n            \"Cannot reveal past reveal deadline.\"\r\n        );\r\n\r\n        // Ensure reveal is either for choice A or B\r\n        require(\r\n            (choice == Choice.A) || (choice == Choice.B),\r\n            \"Invalid choice, must reveal A or B.\"\r\n        );\r\n\r\n        // Ensure sender has voted\r\n        require(\r\n            (votes[msg.sender].amount >= minVoteIncrement) &&\r\n                (votes[msg.sender].amount <= maxVoteAmount),\r\n            \"Cannot reveal before voting.\"\r\n        );\r\n\r\n        // Ensure sender has not already revealed\r\n        require(\r\n            votes[msg.sender].choice == Choice.Hidden,\r\n            \"Cannot reveal more than once.\"\r\n        );\r\n\r\n        // Check hash and reveal if correct\r\n        VoteCommit storage vote = votes[msg.sender];\r\n        require(\r\n            keccak256(abi.encodePacked(msg.sender, choice, blindingFactor)) ==\r\n                vote.commitment,\r\n            \"Invalid reveal, hash does not match committment.\"\r\n        );\r\n        vote.choice = choice;\r\n\r\n        // Update revealed vote counts\r\n        if (choice == Choice.A) {\r\n            revealedA += vote.amount;\r\n        } else {\r\n            revealedB += vote.amount;\r\n        }\r\n\r\n        // Emit reveal event\r\n        emit Reveal(msg.sender, choice);\r\n    }\r\n\r\n    /// @notice Claim payout at game end\r\n    function claimPayout() external {\r\n        // Ensure reveal deadline has passed before claiming payout\r\n        require(\r\n            block.timestamp > revealDeadline,\r\n            \"Cannot claim payout before reveal deadline has passed.\"\r\n        );\r\n\r\n        // Ensure that sender has revealed a vote\r\n        VoteCommit memory senderVote = votes[msg.sender];\r\n        require(\r\n            (senderVote.choice == Choice.A) || (senderVote.choice == Choice.B),\r\n            \"Cannot claim payout without revealed vote.\"\r\n        );\r\n\r\n        // Get winner\r\n        // If first time being called, take founder fee and set prizePool\r\n        // If a tie, winner is returned as Choice.Hidden\r\n        Choice winner = getWinner();\r\n\r\n        // Require that sender is winner to claim funds\r\n        require(\r\n            (senderVote.choice == winner) || (winner == Choice.Hidden),\r\n            \"Cannot claim payout since did not win game.\"\r\n        );\r\n\r\n        // Calc share of winnings\r\n        uint256 denominator;\r\n        if (winner == Choice.A) {\r\n            denominator = revealedA;\r\n        } else if (winner == Choice.B) {\r\n            denominator = revealedB;\r\n        } else {\r\n            // Everybody wins\r\n            require(winner == Choice.Hidden, \"Invalid winner.\");\r\n            denominator = revealedA + revealedB;\r\n        }\r\n        uint256 winnings = (prizePool * senderVote.amount) / denominator;\r\n\r\n        // Remove vote data to prevent double claim\r\n        delete votes[msg.sender];\r\n\r\n        // Transfer funds\r\n        payable(msg.sender).transfer(winnings);\r\n\r\n        // Emit payout event\r\n        emit Payout(msg.sender, winnings);\r\n    }\r\n\r\n    /// @notice Returns winner, if first time pays founder's fee and sets prizePool\r\n    function getWinner() private returns (Choice) {\r\n        // Collect founder's fee if first time\r\n        if (prizePool == 0) {\r\n            collectFee();\r\n            // Set prize pool to be remaining funds in the contract\r\n            prizePool = address(this).balance;\r\n        }\r\n\r\n        // Choose winner\r\n        // In case one side did not reveal any votes, the other side wins\r\n        // One side must have revealed votes as required in claimPayout\r\n        if (revealedA == 0) {\r\n            return Choice.B;\r\n        } else if (revealedB == 0) {\r\n            return Choice.A;\r\n        } else if (revealedA < revealedB) {\r\n            return Choice.A;\r\n        } else if (revealedB < revealedA) {\r\n            return Choice.B;\r\n        } else {\r\n            // Tie\r\n            return Choice.Hidden;\r\n        }\r\n    }\r\n\r\n    /// @notice Collects the founder's fee, is only be called once\r\n    function collectFee() private {\r\n        // Collect fee\r\n        uint256 feeAmount = address(this).balance / fee;\r\n        payable(feeAddress).transfer(feeAmount);\r\n\r\n        // Emit payout event\r\n        emit Payout(feeAddress, feeAmount);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum AvsBGame.Choice\",\"name\":\"choice\",\"type\":\"uint8\"}],\"name\":\"Reveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"castHiddenVote\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxVoteAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minVoteIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prizePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum AvsBGame.Choice\",\"name\":\"choice\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"blindingFactor\",\"type\":\"bytes32\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealedA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealedB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AvsBGame.Choice\",\"name\":\"choice\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AvsBGame","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1603be5c91d8db1e2441a3efb8891714c452f5854f5828bf1b076b430044da88"}]}