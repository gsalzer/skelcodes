{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/Swap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseLogic.sol\\\";\\nimport \\\"../vendor/ISwapRouter.sol\\\";\\n\\n/// @notice Trading assets on Uniswap V3 and 1Inch V4 DEXs\\ncontract Swap is BaseLogic {\\n    address immutable public uniswapRouter;\\n    address immutable public oneInch;\\n\\n    /// @notice Params for Uniswap V3 exact input trade on a single pool\\n    /// @param subAccountIdIn subaccount id to trade from\\n    /// @param subAccountIdOut subaccount id to trade to\\n    /// @param underlyingIn sold token address\\n    /// @param underlyingOut bought token address\\n    /// @param amountIn amount of token to sell\\n    /// @param amountOutMinimum minimum amount of bought token\\n    /// @param deadline trade must complete before this timestamp\\n    /// @param fee uniswap pool fee to use\\n    /// @param sqrtPriceLimitX96 maximum acceptable price\\n    struct SwapUniExactInputSingleParams {\\n        uint subAccountIdIn;\\n        uint subAccountIdOut;\\n        address underlyingIn;\\n        address underlyingOut;\\n        uint amountIn;\\n        uint amountOutMinimum;\\n        uint deadline;\\n        uint24 fee;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Params for Uniswap V3 exact input trade routed through multiple pools\\n    /// @param subAccountIdIn subaccount id to trade from\\n    /// @param subAccountIdOut subaccount id to trade to\\n    /// @param underlyingIn sold token address\\n    /// @param underlyingOut bought token address\\n    /// @param amountIn amount of token to sell\\n    /// @param amountOutMinimum minimum amount of bought token\\n    /// @param deadline trade must complete before this timestamp\\n    /// @param path list of pools to use for the trade\\n    struct SwapUniExactInputParams {\\n        uint subAccountIdIn;\\n        uint subAccountIdOut;\\n        uint amountIn;\\n        uint amountOutMinimum;\\n        uint deadline;\\n        bytes path; // list of pools to hop - constructed with uni SDK \\n    }\\n\\n    /// @notice Params for Uniswap V3 exact output trade on a single pool\\n    /// @param subAccountIdIn subaccount id to trade from\\n    /// @param subAccountIdOut subaccount id to trade to\\n    /// @param underlyingIn sold token address\\n    /// @param underlyingOut bought token address\\n    /// @param amountOut amount of token to buy\\n    /// @param amountInMaximum maximum amount of sold token\\n    /// @param deadline trade must complete before this timestamp\\n    /// @param fee uniswap pool fee to use\\n    /// @param sqrtPriceLimitX96 maximum acceptable price\\n    struct SwapUniExactOutputSingleParams {\\n        uint subAccountIdIn;\\n        uint subAccountIdOut;\\n        address underlyingIn;\\n        address underlyingOut;\\n        uint amountOut;\\n        uint amountInMaximum;\\n        uint deadline;\\n        uint24 fee;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Params for Uniswap V3 exact output trade routed through multiple pools\\n    /// @param subAccountIdIn subaccount id to trade from\\n    /// @param subAccountIdOut subaccount id to trade to\\n    /// @param underlyingIn sold token address\\n    /// @param underlyingOut bought token address\\n    /// @param amountOut amount of token to buy\\n    /// @param amountInMaximum maximum amount of sold token\\n    /// @param deadline trade must complete before this timestamp\\n    /// @param path list of pools to use for the trade\\n    struct SwapUniExactOutputParams {\\n        uint subAccountIdIn;\\n        uint subAccountIdOut;\\n        uint amountOut;\\n        uint amountInMaximum;\\n        uint deadline;\\n        bytes path;\\n    }\\n\\n    /// @notice Params for 1Inch trade\\n    /// @param subAccountIdIn subaccount id to trade from\\n    /// @param subAccountIdOut subaccount id to trade to\\n    /// @param underlyingIn sold token address\\n    /// @param underlyingOut bought token address\\n    /// @param amount amount of token to sell\\n    /// @param amountOutMinimum minimum amount of bought token\\n    /// @param payload call data passed to 1Inch contract\\n    struct Swap1InchParams {\\n        uint subAccountIdIn;\\n        uint subAccountIdOut;\\n        address underlyingIn;\\n        address underlyingOut;\\n        uint amount;\\n        uint amountOutMinimum;\\n        bytes payload;\\n    }\\n\\n    struct SwapCache {\\n        address accountIn;\\n        address accountOut;\\n        address eTokenIn;\\n        address eTokenOut;\\n        AssetCache assetCacheIn;\\n        AssetCache assetCacheOut;\\n        uint balanceIn;\\n        uint balanceOut;\\n        uint amountIn;\\n        uint amountOut;\\n        uint amountInternalIn;\\n    }\\n\\n    constructor(bytes32 moduleGitCommit_, address uniswapRouter_, address oneInch_) BaseLogic(MODULEID__SWAP, moduleGitCommit_) {\\n        uniswapRouter = uniswapRouter_;\\n        oneInch = oneInch_;\\n    }\\n\\n    /// @notice Execute Uniswap V3 exact input trade on a single pool\\n    /// @param params struct defining trade parameters\\n    function swapUniExactInputSingle(SwapUniExactInputSingleParams memory params) external nonReentrant {\\n        SwapCache memory swap = initSwap(\\n            params.underlyingIn,\\n            params.underlyingOut,\\n            params.amountIn,\\n            params.subAccountIdIn,\\n            params.subAccountIdOut,\\n            SWAP_TYPE__UNI_EXACT_INPUT_SINGLE\\n        );\\n\\n        setWithdrawAmounts(swap, params.amountIn);\\n\\n        Utils.safeApprove(params.underlyingIn, uniswapRouter, swap.amountIn);\\n\\n        swap.amountOut = ISwapRouter(uniswapRouter).exactInputSingle(\\n            ISwapRouter.ExactInputSingleParams({\\n                tokenIn: params.underlyingIn,\\n                tokenOut: params.underlyingOut,\\n                fee: params.fee,\\n                recipient: address(this),\\n                deadline: params.deadline > 0 ? params.deadline : block.timestamp,\\n                amountIn: swap.amountIn,\\n                amountOutMinimum: params.amountOutMinimum,\\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\\n            })\\n        );\\n\\n        finalizeSwap(swap);\\n    }\\n\\n    /// @notice Execute Uniswap V3 exact input trade routed through multiple pools\\n    /// @param params struct defining trade parameters\\n    function swapUniExactInput(SwapUniExactInputParams memory params) external nonReentrant {\\n        (address underlyingIn, address underlyingOut) = decodeUniPath(params.path, false);\\n\\n        SwapCache memory swap = initSwap(\\n            underlyingIn,\\n            underlyingOut,\\n            params.amountIn,\\n            params.subAccountIdIn,\\n            params.subAccountIdOut,\\n            SWAP_TYPE__UNI_EXACT_INPUT\\n        );\\n\\n        setWithdrawAmounts(swap, params.amountIn);\\n\\n        Utils.safeApprove(underlyingIn, uniswapRouter, swap.amountIn);\\n\\n        swap.amountOut = ISwapRouter(uniswapRouter).exactInput(\\n            ISwapRouter.ExactInputParams({\\n                path: params.path,\\n                recipient: address(this),\\n                deadline: params.deadline > 0 ? params.deadline : block.timestamp,\\n                amountIn: swap.amountIn,\\n                amountOutMinimum: params.amountOutMinimum\\n            })\\n        );\\n\\n        finalizeSwap(swap);\\n    }\\n\\n    /// @notice Execute Uniswap V3 exact output trade on a single pool\\n    /// @param params struct defining trade parameters\\n    function swapUniExactOutputSingle(SwapUniExactOutputSingleParams memory params) external nonReentrant {\\n        SwapCache memory swap = initSwap(\\n            params.underlyingIn,\\n            params.underlyingOut,\\n            params.amountOut,\\n            params.subAccountIdIn,\\n            params.subAccountIdOut,\\n            SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE\\n        );\\n\\n        swap.amountOut = params.amountOut;\\n\\n        doSwapUniExactOutputSingle(swap, params);\\n\\n        finalizeSwap(swap);\\n    }\\n\\n    /// @notice Execute Uniswap V3 exact output trade routed through multiple pools\\n    /// @param params struct defining trade parameters\\n    function swapUniExactOutput(SwapUniExactOutputParams memory params) external nonReentrant {\\n        (address underlyingIn, address underlyingOut) = decodeUniPath(params.path, true);\\n\\n        SwapCache memory swap = initSwap(\\n            underlyingIn,\\n            underlyingOut,\\n            params.amountOut,\\n            params.subAccountIdIn,\\n            params.subAccountIdOut,\\n            SWAP_TYPE__UNI_EXACT_OUTPUT\\n        );\\n\\n        swap.amountOut = params.amountOut;\\n\\n        doSwapUniExactOutput(swap, params, underlyingIn);\\n\\n        finalizeSwap(swap);\\n    }\\n\\n    /// @notice Trade on Uniswap V3 single pool and repay debt with bought asset\\n    /// @param params struct defining trade parameters (amountOut is ignored)\\n    /// @param targetDebt amount of debt that is expected to remain after trade and repay (0 to repay full debt)\\n    function swapAndRepayUniSingle(SwapUniExactOutputSingleParams memory params, uint targetDebt) external nonReentrant {\\n        SwapCache memory swap = initSwap(\\n            params.underlyingIn,\\n            params.underlyingOut,\\n            targetDebt,\\n            params.subAccountIdIn,\\n            params.subAccountIdOut,\\n            SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE_REPAY\\n        );\\n\\n        swap.amountOut = getRepayAmount(swap, targetDebt);\\n\\n        doSwapUniExactOutputSingle(swap, params);\\n\\n        finalizeSwapAndRepay(swap);\\n    }\\n\\n    /// @notice Trade on Uniswap V3 through multiple pools pool and repay debt with bought asset\\n    /// @param params struct defining trade parameters (amountOut is ignored)\\n    /// @param targetDebt amount of debt that is expected to remain after trade and repay (0 to repay full debt)\\n    function swapAndRepayUni(SwapUniExactOutputParams memory params, uint targetDebt) external nonReentrant {\\n        (address underlyingIn, address underlyingOut) = decodeUniPath(params.path, true);\\n\\n        SwapCache memory swap = initSwap(\\n            underlyingIn,\\n            underlyingOut,\\n            targetDebt,\\n            params.subAccountIdIn,\\n            params.subAccountIdOut,\\n            SWAP_TYPE__UNI_EXACT_OUTPUT_REPAY\\n        );\\n\\n        swap.amountOut = getRepayAmount(swap, targetDebt);\\n\\n        doSwapUniExactOutput(swap, params, underlyingIn);\\n\\n        finalizeSwapAndRepay(swap);\\n    }\\n\\n    /// @notice Execute 1Inch V4 trade\\n    /// @param params struct defining trade parameters\\n    function swap1Inch(Swap1InchParams memory params) external nonReentrant {\\n        SwapCache memory swap = initSwap(\\n            params.underlyingIn,\\n            params.underlyingOut,\\n            params.amount,\\n            params.subAccountIdIn,\\n            params.subAccountIdOut,\\n            SWAP_TYPE__1INCH\\n        );\\n\\n        setWithdrawAmounts(swap, params.amount);\\n\\n        Utils.safeApprove(params.underlyingIn, oneInch, swap.amountIn);\\n\\n        (bool success, bytes memory result) = oneInch.call(params.payload);\\n        if (!success) revertBytes(result);\\n\\n        swap.amountOut = abi.decode(result, (uint));\\n        require(swap.amountOut >= params.amountOutMinimum, \\\"e/swap/min-amount-out\\\");\\n\\n        finalizeSwap(swap);\\n    }\\n\\n    function initSwap(\\n        address underlyingIn,\\n        address underlyingOut,\\n        uint amount,\\n        uint subAccountIdIn,\\n        uint subAccountIdOut,\\n        uint swapType\\n    ) private returns (SwapCache memory swap) {\\n        require(underlyingIn != underlyingOut, \\\"e/swap/same\\\");\\n\\n        address msgSender = unpackTrailingParamMsgSender();\\n        swap.accountIn = getSubAccount(msgSender, subAccountIdIn);\\n        swap.accountOut = getSubAccount(msgSender, subAccountIdOut);\\n\\n        updateAverageLiquidity(swap.accountIn);\\n        if (swap.accountIn != swap.accountOut)\\n            updateAverageLiquidity(swap.accountOut);\\n\\n        emit RequestSwap(\\n            swap.accountIn,\\n            swap.accountOut,\\n            underlyingIn,\\n            underlyingOut,\\n            amount,\\n            swapType\\n        );\\n\\n        swap.eTokenIn = underlyingLookup[underlyingIn].eTokenAddress;\\n        swap.eTokenOut = underlyingLookup[underlyingOut].eTokenAddress;\\n\\n        AssetStorage storage assetStorageIn = eTokenLookup[swap.eTokenIn];\\n        AssetStorage storage assetStorageOut = eTokenLookup[swap.eTokenOut];\\n\\n        require(swap.eTokenIn != address(0), \\\"e/swap/in-market-not-activated\\\");\\n        require(swap.eTokenOut != address(0), \\\"e/swap/out-market-not-activated\\\");\\n\\n        swap.assetCacheIn = loadAssetCache(underlyingIn, assetStorageIn);\\n        swap.assetCacheOut = loadAssetCache(underlyingOut, assetStorageOut);\\n\\n        swap.balanceIn = callBalanceOf(swap.assetCacheIn, address(this)) ;\\n        swap.balanceOut = callBalanceOf(swap.assetCacheOut, address(this));\\n    }\\n\\n    function doSwapUniExactOutputSingle(SwapCache memory swap, SwapUniExactOutputSingleParams memory params) private {\\n        Utils.safeApprove(params.underlyingIn, uniswapRouter, params.amountInMaximum);\\n\\n        uint pulledAmountIn = ISwapRouter(uniswapRouter).exactOutputSingle(\\n            ISwapRouter.ExactOutputSingleParams({\\n                tokenIn: params.underlyingIn,\\n                tokenOut: params.underlyingOut,\\n                fee: params.fee,\\n                recipient: address(this),\\n                deadline: params.deadline > 0 ? params.deadline : block.timestamp,\\n                amountOut: swap.amountOut,\\n                amountInMaximum: params.amountInMaximum,\\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\\n            })\\n        );\\n        require(pulledAmountIn != type(uint).max, \\\"e/swap/exact-out-amount-in\\\");\\n\\n        setWithdrawAmounts(swap, pulledAmountIn);\\n\\n        if (swap.amountIn < params.amountInMaximum) {\\n            Utils.safeApprove(params.underlyingIn, uniswapRouter, 0);\\n        }\\n    }\\n\\n    function doSwapUniExactOutput(SwapCache memory swap, SwapUniExactOutputParams memory params, address underlyingIn) private {\\n        Utils.safeApprove(underlyingIn, uniswapRouter, params.amountInMaximum);\\n\\n        uint pulledAmountIn = ISwapRouter(uniswapRouter).exactOutput(\\n            ISwapRouter.ExactOutputParams({\\n                path: params.path,\\n                recipient: address(this),\\n                deadline: params.deadline > 0 ? params.deadline : block.timestamp,\\n                amountOut: swap.amountOut,\\n                amountInMaximum: params.amountInMaximum\\n            })\\n        );\\n        require(pulledAmountIn != type(uint).max, \\\"e/swap/exact-out-amount-in\\\");\\n\\n        setWithdrawAmounts(swap, pulledAmountIn);\\n\\n        if (swap.amountIn < params.amountInMaximum) {\\n            Utils.safeApprove(underlyingIn, uniswapRouter, 0);\\n        }\\n    }\\n\\n    function setWithdrawAmounts(SwapCache memory swap, uint amount) private view {\\n        (amount, swap.amountInternalIn) = withdrawAmounts(eTokenLookup[swap.eTokenIn], swap.assetCacheIn, swap.accountIn, amount);\\n        require(swap.assetCacheIn.poolSize >= amount, \\\"e/swap/insufficient-pool-size\\\");\\n\\n        swap.amountIn = amount / swap.assetCacheIn.underlyingDecimalsScaler;\\n    }\\n\\n    function finalizeSwap(SwapCache memory swap) private {\\n        uint balanceIn = checkBalances(swap);\\n\\n        processWithdraw(eTokenLookup[swap.eTokenIn], swap.assetCacheIn, swap.eTokenIn, swap.accountIn, swap.amountInternalIn, balanceIn);\\n\\n        processDeposit(eTokenLookup[swap.eTokenOut], swap.assetCacheOut, swap.eTokenOut, swap.accountOut, swap.amountOut);\\n\\n        // only checking outgoing account, deposit can't lower health score\\n        checkLiquidity(swap.accountIn);\\n    }\\n\\n    function finalizeSwapAndRepay(SwapCache memory swap) private {\\n        uint balanceIn = checkBalances(swap);\\n\\n        processWithdraw(eTokenLookup[swap.eTokenIn], swap.assetCacheIn, swap.eTokenIn, swap.accountIn, swap.amountInternalIn, balanceIn);\\n\\n        processRepay(eTokenLookup[swap.eTokenOut], swap.assetCacheOut, swap.accountOut, swap.amountOut);\\n\\n        // only checking outgoing account, repay can't lower health score\\n        checkLiquidity(swap.accountIn);\\n    }\\n\\n    function processWithdraw(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amountInternal, uint balanceIn) private {\\n        assetCache.poolSize = decodeExternalAmount(assetCache, balanceIn);\\n\\n        decreaseBalance(assetStorage, assetCache, eTokenAddress, account, amountInternal);\\n\\n        logAssetStatus(assetCache);\\n    }\\n\\n    function processDeposit(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) private {\\n        uint amountInternal;\\n\\n        amountInternal = underlyingAmountToBalance(assetCache, decodeExternalAmount(assetCache, amount));\\n        assetCache.poolSize += amount;\\n\\n        increaseBalance(assetStorage, assetCache, eTokenAddress, account, amountInternal);\\n\\n        logAssetStatus(assetCache);\\n    }\\n\\n    function processRepay(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint amount) private {\\n        decreaseBorrow(assetStorage, assetCache, assetStorage.dTokenAddress, account, decodeExternalAmount(assetCache, amount));\\n\\n        logAssetStatus(assetCache);\\n    }\\n\\n    function checkBalances(SwapCache memory swap) private view returns (uint) {\\n        uint balanceIn = callBalanceOf(swap.assetCacheIn, address(this));\\n\\n        require(balanceIn == swap.balanceIn - swap.amountIn, \\\"e/swap/balance-in\\\");\\n        require(callBalanceOf(swap.assetCacheOut, address(this)) == swap.balanceOut + swap.amountOut, \\\"e/swap/balance-out\\\");\\n\\n        return balanceIn;\\n    }\\n\\n    function decodeUniPath(bytes memory path, bool isExactOutput) private pure returns (address, address) {\\n        require(path.length >= 20 + 3 + 20, \\\"e/swap/uni-path-length\\\");\\n        require((path.length - 20) % 23 == 0, \\\"e/swap/uni-path-format\\\");\\n\\n        address token0 = toAddress(path, 0);\\n        address token1 = toAddress(path, path.length - 20);\\n\\n        return isExactOutput ? (token1, token0) : (token0, token1);\\n    }\\n\\n    function getRepayAmount(SwapCache memory swap, uint targetDebt) private view returns (uint) {\\n        uint owed = getCurrentOwed(eTokenLookup[swap.eTokenOut], swap.assetCacheOut, swap.accountOut) / swap.assetCacheOut.underlyingDecimalsScaler;\\n        require (owed > targetDebt, \\\"e/swap/target-debt\\\");\\n        return owed - targetDebt;\\n    }\\n\\n    function toAddress(bytes memory data, uint start) private pure returns (address result) {\\n        // assuming data length is already validated\\n        assembly {\\n            // borrowed from BytesLib https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n            result := div(mload(add(add(data, 0x20), start)), 0x1000000000000000000000000)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BaseLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseModule.sol\\\";\\nimport \\\"./BaseIRM.sol\\\";\\nimport \\\"./Interfaces.sol\\\";\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./vendor/RPow.sol\\\";\\nimport \\\"./IRiskManager.sol\\\";\\n\\n\\nabstract contract BaseLogic is BaseModule {\\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}\\n\\n\\n    // Account auth\\n\\n    function getSubAccount(address primary, uint subAccountId) internal pure returns (address) {\\n        require(subAccountId < 256, \\\"e/sub-account-id-too-big\\\");\\n        return address(uint160(primary) ^ uint160(subAccountId));\\n    }\\n\\n    function isSubAccountOf(address primary, address subAccount) internal pure returns (bool) {\\n        return (uint160(primary) | 0xFF) == (uint160(subAccount) | 0xFF);\\n    }\\n\\n\\n\\n    // Entered markets array\\n\\n    function getEnteredMarketsArray(address account) internal view returns (address[] memory) {\\n        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;\\n        address firstMarketEntered = accountLookup[account].firstMarketEntered;\\n\\n        address[] memory output = new address[](numMarketsEntered);\\n        if (numMarketsEntered == 0) return output;\\n\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n\\n        output[0] = firstMarketEntered;\\n\\n        for (uint i = 1; i < numMarketsEntered; ++i) {\\n            output[i] = markets[i];\\n        }\\n\\n        return output;\\n    }\\n\\n    function isEnteredInMarket(address account, address underlying) internal view returns (bool) {\\n        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;\\n        address firstMarketEntered = accountLookup[account].firstMarketEntered;\\n\\n        if (numMarketsEntered == 0) return false;\\n        if (firstMarketEntered == underlying) return true;\\n\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n\\n        for (uint i = 1; i < numMarketsEntered; ++i) {\\n            if (markets[i] == underlying) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function doEnterMarket(address account, address underlying) internal {\\n        AccountStorage storage accountStorage = accountLookup[account];\\n\\n        uint32 numMarketsEntered = accountStorage.numMarketsEntered;\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n\\n        if (numMarketsEntered != 0) {\\n            if (accountStorage.firstMarketEntered == underlying) return; // already entered\\n            for (uint i = 1; i < numMarketsEntered; i++) {\\n                if (markets[i] == underlying) return; // already entered\\n            }\\n        }\\n\\n        require(numMarketsEntered < MAX_ENTERED_MARKETS, \\\"e/too-many-entered-markets\\\");\\n\\n        if (numMarketsEntered == 0) accountStorage.firstMarketEntered = underlying;\\n        else markets[numMarketsEntered] = underlying;\\n\\n        accountStorage.numMarketsEntered = numMarketsEntered + 1;\\n\\n        emit EnterMarket(underlying, account);\\n    }\\n\\n    // Liquidity check must be done by caller after calling this\\n\\n    function doExitMarket(address account, address underlying) internal {\\n        AccountStorage storage accountStorage = accountLookup[account];\\n\\n        uint32 numMarketsEntered = accountStorage.numMarketsEntered;\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n        uint searchIndex = type(uint).max;\\n\\n        if (numMarketsEntered == 0) return; // already exited\\n\\n        if (accountStorage.firstMarketEntered == underlying) {\\n            searchIndex = 0;\\n        } else {\\n            for (uint i = 1; i < numMarketsEntered; i++) {\\n                if (markets[i] == underlying) {\\n                    searchIndex = i;\\n                    break;\\n                }\\n            }\\n\\n            if (searchIndex == type(uint).max) return; // already exited\\n        }\\n\\n        uint lastMarketIndex = numMarketsEntered - 1;\\n\\n        if (searchIndex != lastMarketIndex) {\\n            if (searchIndex == 0) accountStorage.firstMarketEntered = markets[lastMarketIndex];\\n            else markets[searchIndex] = markets[lastMarketIndex];\\n        }\\n\\n        accountStorage.numMarketsEntered = uint32(lastMarketIndex);\\n\\n        if (lastMarketIndex != 0) markets[lastMarketIndex] = address(0); // zero out for storage refund\\n\\n        emit ExitMarket(underlying, account);\\n    }\\n\\n\\n\\n    // AssetConfig\\n\\n    function resolveAssetConfig(address underlying) internal view returns (AssetConfig memory) {\\n        AssetConfig memory config = underlyingLookup[underlying];\\n        require(config.eTokenAddress != address(0), \\\"e/market-not-activated\\\");\\n\\n        if (config.borrowFactor == type(uint32).max) config.borrowFactor = DEFAULT_BORROW_FACTOR;\\n        if (config.twapWindow == type(uint24).max) config.twapWindow = DEFAULT_TWAP_WINDOW_SECONDS;\\n\\n        return config;\\n    }\\n\\n\\n    // AssetCache\\n\\n    struct AssetCache {\\n        address underlying;\\n\\n        uint112 totalBalances;\\n        uint144 totalBorrows;\\n\\n        uint96 reserveBalance;\\n\\n        uint interestAccumulator;\\n\\n        uint40 lastInterestAccumulatorUpdate;\\n        uint8 underlyingDecimals;\\n        uint32 interestRateModel;\\n        int96 interestRate;\\n        uint32 reserveFee;\\n        uint16 pricingType;\\n        uint32 pricingParameters;\\n\\n        uint poolSize; // result of calling balanceOf on underlying (in external units)\\n\\n        uint underlyingDecimalsScaler;\\n        uint maxExternalAmount;\\n    }\\n\\n    function initAssetCache(address underlying, AssetStorage storage assetStorage, AssetCache memory assetCache) internal view returns (bool dirty) {\\n        dirty = false;\\n\\n        assetCache.underlying = underlying;\\n\\n        // Storage loads\\n\\n        assetCache.lastInterestAccumulatorUpdate = assetStorage.lastInterestAccumulatorUpdate;\\n        uint8 underlyingDecimals = assetCache.underlyingDecimals = assetStorage.underlyingDecimals;\\n        assetCache.interestRateModel = assetStorage.interestRateModel;\\n        assetCache.interestRate = assetStorage.interestRate;\\n        assetCache.reserveFee = assetStorage.reserveFee;\\n        assetCache.pricingType = assetStorage.pricingType;\\n        assetCache.pricingParameters = assetStorage.pricingParameters;\\n\\n        assetCache.reserveBalance = assetStorage.reserveBalance;\\n\\n        assetCache.totalBalances = assetStorage.totalBalances;\\n        assetCache.totalBorrows = assetStorage.totalBorrows;\\n\\n        assetCache.interestAccumulator = assetStorage.interestAccumulator;\\n\\n        // Derived state\\n\\n        unchecked {\\n            assetCache.underlyingDecimalsScaler = 10**(18 - underlyingDecimals);\\n            assetCache.maxExternalAmount = MAX_SANE_AMOUNT / assetCache.underlyingDecimalsScaler;\\n        }\\n\\n        uint poolSize = callBalanceOf(assetCache, address(this));\\n        if (poolSize <= assetCache.maxExternalAmount) {\\n            unchecked { assetCache.poolSize = poolSize * assetCache.underlyingDecimalsScaler; }\\n        } else {\\n            assetCache.poolSize = 0;\\n        }\\n\\n        // Update interest accumulator and reserves\\n\\n        if (block.timestamp != assetCache.lastInterestAccumulatorUpdate) {\\n            dirty = true;\\n\\n            uint deltaT = block.timestamp - assetCache.lastInterestAccumulatorUpdate;\\n\\n            // Compute new values\\n\\n            uint newInterestAccumulator = (RPow.rpow(uint(int(assetCache.interestRate) + 1e27), deltaT, 1e27) * assetCache.interestAccumulator) / 1e27;\\n\\n            uint newTotalBorrows = assetCache.totalBorrows * newInterestAccumulator / assetCache.interestAccumulator;\\n\\n            uint newReserveBalance = assetCache.reserveBalance;\\n            uint newTotalBalances = assetCache.totalBalances;\\n\\n            uint feeAmount = (newTotalBorrows - assetCache.totalBorrows)\\n                               * (assetCache.reserveFee == type(uint32).max ? DEFAULT_RESERVE_FEE : assetCache.reserveFee)\\n                               / (RESERVE_FEE_SCALE * INTERNAL_DEBT_PRECISION);\\n\\n            if (feeAmount != 0) {\\n                uint poolAssets = assetCache.poolSize + (newTotalBorrows / INTERNAL_DEBT_PRECISION);\\n                newTotalBalances = poolAssets * newTotalBalances / (poolAssets - feeAmount);\\n                newReserveBalance += newTotalBalances - assetCache.totalBalances;\\n            }\\n\\n            // Store new values in assetCache, only if no overflows will occur\\n\\n            if (newTotalBalances <= MAX_SANE_AMOUNT && newTotalBorrows <= MAX_SANE_DEBT_AMOUNT) {\\n                assetCache.totalBorrows = encodeDebtAmount(newTotalBorrows);\\n                assetCache.interestAccumulator = newInterestAccumulator;\\n                assetCache.lastInterestAccumulatorUpdate = uint40(block.timestamp);\\n\\n                if (newTotalBalances != assetCache.totalBalances) {\\n                    assetCache.reserveBalance = encodeSmallAmount(newReserveBalance);\\n                    assetCache.totalBalances = encodeAmount(newTotalBalances);\\n                }\\n            }\\n        }\\n    }\\n\\n    function loadAssetCache(address underlying, AssetStorage storage assetStorage) internal returns (AssetCache memory assetCache) {\\n        if (initAssetCache(underlying, assetStorage, assetCache)) {\\n            assetStorage.lastInterestAccumulatorUpdate = assetCache.lastInterestAccumulatorUpdate;\\n\\n            assetStorage.underlying = assetCache.underlying; // avoid an SLOAD of this slot\\n            assetStorage.reserveBalance = assetCache.reserveBalance;\\n\\n            assetStorage.totalBalances = assetCache.totalBalances;\\n            assetStorage.totalBorrows = assetCache.totalBorrows;\\n\\n            assetStorage.interestAccumulator = assetCache.interestAccumulator;\\n        }\\n    }\\n\\n    function loadAssetCacheRO(address underlying, AssetStorage storage assetStorage) internal view returns (AssetCache memory assetCache) {\\n        initAssetCache(underlying, assetStorage, assetCache);\\n    }\\n\\n\\n\\n    // Utils\\n\\n    function decodeExternalAmount(AssetCache memory assetCache, uint externalAmount) internal pure returns (uint scaledAmount) {\\n        require(externalAmount <= assetCache.maxExternalAmount, \\\"e/amount-too-large\\\");\\n        unchecked { scaledAmount = externalAmount * assetCache.underlyingDecimalsScaler; }\\n    }\\n\\n    function encodeAmount(uint amount) internal pure returns (uint112) {\\n        require(amount <= MAX_SANE_AMOUNT, \\\"e/amount-too-large-to-encode\\\");\\n        return uint112(amount);\\n    }\\n\\n    function encodeSmallAmount(uint amount) internal pure returns (uint96) {\\n        require(amount <= MAX_SANE_SMALL_AMOUNT, \\\"e/small-amount-too-large-to-encode\\\");\\n        return uint96(amount);\\n    }\\n\\n    function encodeDebtAmount(uint amount) internal pure returns (uint144) {\\n        require(amount <= MAX_SANE_DEBT_AMOUNT, \\\"e/debt-amount-too-large-to-encode\\\");\\n        return uint144(amount);\\n    }\\n\\n    function computeExchangeRate(AssetCache memory assetCache) private pure returns (uint) {\\n        if (assetCache.totalBalances == 0) return 1e18;\\n        return (assetCache.poolSize + (assetCache.totalBorrows / INTERNAL_DEBT_PRECISION)) * 1e18 / assetCache.totalBalances;\\n    }\\n\\n    function underlyingAmountToBalance(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\\n        uint exchangeRate = computeExchangeRate(assetCache);\\n        return amount * 1e18 / exchangeRate;\\n    }\\n\\n    function underlyingAmountToBalanceRoundUp(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\\n        uint exchangeRate = computeExchangeRate(assetCache);\\n        return (amount * 1e18 + (exchangeRate - 1)) / exchangeRate;\\n    }\\n\\n    function balanceToUnderlyingAmount(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\\n        uint exchangeRate = computeExchangeRate(assetCache);\\n        return amount * exchangeRate / 1e18;\\n    }\\n\\n    function callBalanceOf(AssetCache memory assetCache, address account) internal view FREEMEM returns (uint) {\\n        // We set a gas limit so that a malicious token can't eat up all gas and cause a liquidity check to fail.\\n\\n        (bool success, bytes memory data) = assetCache.underlying.staticcall{gas: 20000}(abi.encodeWithSelector(IERC20.balanceOf.selector, account));\\n\\n        // If token's balanceOf() call fails for any reason, return 0. This prevents malicious tokens from causing liquidity checks to fail.\\n        // If the contract doesn't exist (maybe because selfdestructed), then data.length will be 0 and we will return 0.\\n        // Data length > 32 is allowed because some legitimate tokens append extra data that can be safely ignored.\\n\\n        if (!success || data.length < 32) return 0;\\n\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    function updateInterestRate(AssetStorage storage assetStorage, AssetCache memory assetCache) internal {\\n        uint32 utilisation;\\n\\n        {\\n            uint totalBorrows = assetCache.totalBorrows / INTERNAL_DEBT_PRECISION;\\n            uint poolAssets = assetCache.poolSize + totalBorrows;\\n            if (poolAssets == 0) utilisation = 0; // empty pool arbitrarily given utilisation of 0\\n            else utilisation = uint32(totalBorrows * (uint(type(uint32).max) * 1e18) / poolAssets / 1e18);\\n        }\\n\\n        bytes memory result = callInternalModule(assetCache.interestRateModel,\\n                                                 abi.encodeWithSelector(BaseIRM.computeInterestRate.selector, assetCache.underlying, utilisation));\\n\\n        (int96 newInterestRate) = abi.decode(result, (int96));\\n\\n        assetStorage.interestRate = assetCache.interestRate = newInterestRate;\\n    }\\n\\n    function logAssetStatus(AssetCache memory a) internal {\\n        emit AssetStatus(a.underlying, a.totalBalances, a.totalBorrows / INTERNAL_DEBT_PRECISION, a.reserveBalance, a.poolSize, a.interestAccumulator, a.interestRate, block.timestamp);\\n    }\\n\\n\\n\\n    // Balances\\n\\n    function increaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {\\n        assetStorage.users[account].balance = encodeAmount(assetStorage.users[account].balance + amount);\\n\\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(uint(assetCache.totalBalances) + amount);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        emit Deposit(assetCache.underlying, account, amount);\\n        emitViaProxy_Transfer(eTokenAddress, address(0), account, amount);\\n    }\\n\\n    function decreaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {\\n        uint origBalance = assetStorage.users[account].balance;\\n        require(origBalance >= amount, \\\"e/insufficient-balance\\\");\\n        assetStorage.users[account].balance = encodeAmount(origBalance - amount);\\n\\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(assetCache.totalBalances - amount);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        emit Withdraw(assetCache.underlying, account, amount);\\n        emitViaProxy_Transfer(eTokenAddress, account, address(0), amount);\\n    }\\n\\n    function transferBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address from, address to, uint amount) internal {\\n        uint origFromBalance = assetStorage.users[from].balance;\\n        require(origFromBalance >= amount, \\\"e/insufficient-balance\\\");\\n        uint newFromBalance;\\n        unchecked { newFromBalance = origFromBalance - amount; }\\n\\n        assetStorage.users[from].balance = encodeAmount(newFromBalance);\\n        assetStorage.users[to].balance = encodeAmount(assetStorage.users[to].balance + amount);\\n\\n        emit Withdraw(assetCache.underlying, from, amount);\\n        emit Deposit(assetCache.underlying, to, amount);\\n        emitViaProxy_Transfer(eTokenAddress, from, to, amount);\\n    }\\n\\n    function withdrawAmounts(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint amount) internal view returns (uint, uint) {\\n        uint amountInternal;\\n        if (amount == type(uint).max) {\\n            amountInternal = assetStorage.users[account].balance;\\n            amount = balanceToUnderlyingAmount(assetCache, amountInternal);\\n        } else {\\n            amount = decodeExternalAmount(assetCache, amount);\\n            amountInternal = underlyingAmountToBalanceRoundUp(assetCache, amount);\\n        }\\n\\n        return (amount, amountInternal);\\n    }\\n\\n    // Borrows\\n\\n    // Returns internal precision\\n\\n    function getCurrentOwedExact(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint owed) internal view returns (uint) {\\n        // Don't bother loading the user's accumulator\\n        if (owed == 0) return 0;\\n\\n        // Can't divide by 0 here: If owed is non-zero, we must've initialised the user's interestAccumulator\\n        return owed * assetCache.interestAccumulator / assetStorage.users[account].interestAccumulator;\\n    }\\n\\n    // When non-zero, we round *up* to the smallest external unit so that outstanding dust in a loan can be repaid.\\n    // unchecked is OK here since owed is always loaded from storage, so we know it fits into a uint144 (pre-interest accural)\\n    // Takes and returns 27 decimals precision.\\n\\n    function roundUpOwed(AssetCache memory assetCache, uint owed) private pure returns (uint) {\\n        if (owed == 0) return 0;\\n\\n        unchecked {\\n            uint scale = INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler;\\n            return (owed + scale - 1) / scale * scale;\\n        }\\n    }\\n\\n    // Returns 18-decimals precision (debt amount is rounded up)\\n\\n    function getCurrentOwed(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) internal view returns (uint) {\\n        return roundUpOwed(assetCache, getCurrentOwedExact(assetStorage, assetCache, account, assetStorage.users[account].owed)) / INTERNAL_DEBT_PRECISION;\\n    }\\n\\n    function updateUserBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) private returns (uint newOwedExact, uint prevOwedExact) {\\n        prevOwedExact = assetStorage.users[account].owed;\\n\\n        newOwedExact = getCurrentOwedExact(assetStorage, assetCache, account, prevOwedExact);\\n\\n        assetStorage.users[account].owed = encodeDebtAmount(newOwedExact);\\n        assetStorage.users[account].interestAccumulator = assetCache.interestAccumulator;\\n    }\\n\\n    function logBorrowChange(AssetCache memory assetCache, address dTokenAddress, address account, uint prevOwed, uint owed) private {\\n        prevOwed = roundUpOwed(assetCache, prevOwed) / INTERNAL_DEBT_PRECISION;\\n        owed = roundUpOwed(assetCache, owed) / INTERNAL_DEBT_PRECISION;\\n\\n        if (owed > prevOwed) {\\n            uint change = owed - prevOwed;\\n            emit Borrow(assetCache.underlying, account, change);\\n            emitViaProxy_Transfer(dTokenAddress, address(0), account, change);\\n        } else if (prevOwed > owed) {\\n            uint change = prevOwed - owed;\\n            emit Repay(assetCache.underlying, account, change);\\n            emitViaProxy_Transfer(dTokenAddress, account, address(0), change);\\n        }\\n    }\\n\\n    function increaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint amount) internal {\\n        amount *= INTERNAL_DEBT_PRECISION;\\n\\n        require(assetCache.pricingType != PRICINGTYPE__FORWARDED || pTokenLookup[assetCache.underlying] == address(0), \\\"e/borrow-not-supported\\\");\\n\\n        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);\\n\\n        if (owed == 0) doEnterMarket(account, assetCache.underlying);\\n\\n        owed += amount;\\n\\n        assetStorage.users[account].owed = encodeDebtAmount(owed);\\n        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows + amount);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owed);\\n    }\\n\\n    function decreaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint origAmount) internal {\\n        uint amount = origAmount * INTERNAL_DEBT_PRECISION;\\n\\n        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);\\n        uint owedRoundedUp = roundUpOwed(assetCache, owed);\\n\\n        require(amount <= owedRoundedUp, \\\"e/repay-too-much\\\");\\n        uint owedRemaining;\\n        unchecked { owedRemaining = owedRoundedUp - amount; }\\n\\n        if (owed > assetCache.totalBorrows) owed = assetCache.totalBorrows;\\n\\n        assetStorage.users[account].owed = encodeDebtAmount(owedRemaining);\\n        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows - owed + owedRemaining);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owedRemaining);\\n    }\\n\\n    function transferBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address from, address to, uint origAmount) internal {\\n        uint amount = origAmount * INTERNAL_DEBT_PRECISION;\\n\\n        (uint fromOwed, uint fromOwedPrev) = updateUserBorrow(assetStorage, assetCache, from);\\n        (uint toOwed, uint toOwedPrev) = updateUserBorrow(assetStorage, assetCache, to);\\n\\n        if (toOwed == 0) doEnterMarket(to, assetCache.underlying);\\n\\n        // If amount was rounded up, transfer exact amount owed\\n        if (amount > fromOwed && amount - fromOwed < INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler) amount = fromOwed;\\n\\n        require(fromOwed >= amount, \\\"e/insufficient-balance\\\");\\n        unchecked { fromOwed -= amount; }\\n\\n        // Transfer any residual dust\\n        if (fromOwed < INTERNAL_DEBT_PRECISION) {\\n            amount += fromOwed;\\n            fromOwed = 0;\\n        }\\n\\n        toOwed += amount;\\n\\n        assetStorage.users[from].owed = encodeDebtAmount(fromOwed);\\n        assetStorage.users[to].owed = encodeDebtAmount(toOwed);\\n\\n        logBorrowChange(assetCache, dTokenAddress, from, fromOwedPrev, fromOwed);\\n        logBorrowChange(assetCache, dTokenAddress, to, toOwedPrev, toOwed);\\n    }\\n\\n\\n\\n    // Reserves\\n\\n    function increaseReserves(AssetStorage storage assetStorage, AssetCache memory assetCache, uint amount) internal {\\n        assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(assetCache.reserveBalance + amount);\\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(assetCache.totalBalances + amount);\\n    }\\n\\n\\n\\n    // Token asset transfers\\n\\n    // amounts are in underlying units\\n\\n    function pullTokens(AssetCache memory assetCache, address from, uint amount) internal returns (uint amountTransferred) {\\n        uint poolSizeBefore = assetCache.poolSize;\\n\\n        Utils.safeTransferFrom(assetCache.underlying, from, address(this), amount / assetCache.underlyingDecimalsScaler);\\n        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));\\n\\n        require(poolSizeAfter >= poolSizeBefore, \\\"e/negative-transfer-amount\\\");\\n        unchecked { amountTransferred = poolSizeAfter - poolSizeBefore; }\\n    }\\n\\n    function pushTokens(AssetCache memory assetCache, address to, uint amount) internal returns (uint amountTransferred) {\\n        uint poolSizeBefore = assetCache.poolSize;\\n\\n        Utils.safeTransfer(assetCache.underlying, to, amount / assetCache.underlyingDecimalsScaler);\\n        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));\\n\\n        require(poolSizeBefore >= poolSizeAfter, \\\"e/negative-transfer-amount\\\");\\n        unchecked { amountTransferred = poolSizeBefore - poolSizeAfter; }\\n    }\\n\\n\\n\\n\\n    // Liquidity\\n\\n    function getAssetPrice(address asset) internal returns (uint) {\\n        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.getPrice.selector, asset));\\n        return abi.decode(result, (uint));\\n    }\\n\\n    function getAccountLiquidity(address account) internal returns (uint collateralValue, uint liabilityValue) {\\n        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.computeLiquidity.selector, account));\\n        (IRiskManager.LiquidityStatus memory status) = abi.decode(result, (IRiskManager.LiquidityStatus));\\n\\n        collateralValue = status.collateralValue;\\n        liabilityValue = status.liabilityValue;\\n    }\\n\\n    function checkLiquidity(address account) internal {\\n        uint8 status = accountLookup[account].deferLiquidityStatus;\\n\\n        if (status == DEFERLIQUIDITY__NONE) {\\n            callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.requireLiquidity.selector, account));\\n        } else if (status == DEFERLIQUIDITY__CLEAN) {\\n            accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__DIRTY;\\n        }\\n    }\\n\\n\\n\\n    // Optional average liquidity tracking\\n\\n    function computeNewAverageLiquidity(address account, uint deltaT) private returns (uint) {\\n        uint currDuration = deltaT >= AVERAGE_LIQUIDITY_PERIOD ? AVERAGE_LIQUIDITY_PERIOD : deltaT;\\n        uint prevDuration = AVERAGE_LIQUIDITY_PERIOD - currDuration;\\n\\n        uint currAverageLiquidity;\\n\\n        {\\n            (uint collateralValue, uint liabilityValue) = getAccountLiquidity(account);\\n            currAverageLiquidity = collateralValue > liabilityValue ? collateralValue - liabilityValue : 0;\\n        }\\n\\n        return (accountLookup[account].averageLiquidity * prevDuration / AVERAGE_LIQUIDITY_PERIOD) +\\n               (currAverageLiquidity * currDuration / AVERAGE_LIQUIDITY_PERIOD);\\n    }\\n\\n    function getUpdatedAverageLiquidity(address account) internal returns (uint) {\\n        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;\\n        if (lastAverageLiquidityUpdate == 0) return 0;\\n\\n        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;\\n        if (deltaT == 0) return accountLookup[account].averageLiquidity;\\n\\n        return computeNewAverageLiquidity(account, deltaT);\\n    }\\n\\n    function getUpdatedAverageLiquidityWithDelegate(address account) internal returns (uint) {\\n        address delegate = accountLookup[account].averageLiquidityDelegate;\\n\\n        return delegate != address(0) && accountLookup[delegate].averageLiquidityDelegate == account\\n            ? getUpdatedAverageLiquidity(delegate)\\n            : getUpdatedAverageLiquidity(account);\\n    }\\n\\n    function updateAverageLiquidity(address account) internal {\\n        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;\\n        if (lastAverageLiquidityUpdate == 0) return;\\n\\n        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;\\n        if (deltaT == 0) return;\\n\\n        accountLookup[account].lastAverageLiquidityUpdate = uint40(block.timestamp);\\n        accountLookup[account].averageLiquidity = computeNewAverageLiquidity(account, deltaT);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport './IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/BaseModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Base.sol\\\";\\n\\n\\nabstract contract BaseModule is Base {\\n    // Construction\\n\\n    // public accessors common to all modules\\n\\n    uint immutable public moduleId;\\n    bytes32 immutable public moduleGitCommit;\\n\\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) {\\n        moduleId = moduleId_;\\n        moduleGitCommit = moduleGitCommit_;\\n    }\\n\\n\\n    // Accessing parameters\\n\\n    function unpackTrailingParamMsgSender() internal pure returns (address msgSender) {\\n        assembly {\\n            msgSender := shr(96, calldataload(sub(calldatasize(), 40)))\\n        }\\n    }\\n\\n    function unpackTrailingParams() internal pure returns (address msgSender, address proxyAddr) {\\n        assembly {\\n            msgSender := shr(96, calldataload(sub(calldatasize(), 40)))\\n            proxyAddr := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n\\n    // Emit logs via proxies\\n\\n    function emitViaProxy_Transfer(address proxyAddr, address from, address to, uint value) internal FREEMEM {\\n        (bool success,) = proxyAddr.call(abi.encodePacked(\\n                               uint8(3),\\n                               keccak256(bytes('Transfer(address,address,uint256)')),\\n                               bytes32(uint(uint160(from))),\\n                               bytes32(uint(uint160(to))),\\n                               value\\n                          ));\\n        require(success, \\\"e/log-proxy-fail\\\");\\n    }\\n\\n    function emitViaProxy_Approval(address proxyAddr, address owner, address spender, uint value) internal FREEMEM {\\n        (bool success,) = proxyAddr.call(abi.encodePacked(\\n                               uint8(3),\\n                               keccak256(bytes('Approval(address,address,uint256)')),\\n                               bytes32(uint(uint160(owner))),\\n                               bytes32(uint(uint160(spender))),\\n                               value\\n                          ));\\n        require(success, \\\"e/log-proxy-fail\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BaseIRM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseModule.sol\\\";\\n\\nabstract contract BaseIRM is BaseModule {\\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}\\n\\n    int96 internal constant MAX_ALLOWED_INTEREST_RATE = int96(int(uint(5 * 1e27) / SECONDS_PER_YEAR)); // 500% APR\\n    int96 internal constant MIN_ALLOWED_INTEREST_RATE = 0;\\n\\n    function computeInterestRateImpl(address, uint32) internal virtual returns (int96);\\n\\n    function computeInterestRate(address underlying, uint32 utilisation) external returns (int96) {\\n        int96 rate = computeInterestRateImpl(underlying, utilisation);\\n\\n        if (rate > MAX_ALLOWED_INTEREST_RATE) rate = MAX_ALLOWED_INTEREST_RATE;\\n        else if (rate < MIN_ALLOWED_INTEREST_RATE) rate = MIN_ALLOWED_INTEREST_RATE;\\n\\n        return rate;\\n    }\\n\\n    function reset(address underlying, bytes calldata resetParams) external virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\\ninterface IERC3156FlashBorrower {\\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32);\\n}\\n\\ninterface IERC3156FlashLender {\\n    function maxFlashLoan(address token) external view returns (uint256);\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Interfaces.sol\\\";\\n\\nlibrary Utils {\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\\n    }\\n\\n    function safeApprove(address token, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/RPow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\n// From MakerDAO DSS\\n\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary RPow {\\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\\n        assembly {\\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\\n            default {\\n                switch mod(n, 2) case 0 { z := base } default { z := x }\\n                let half := div(base, 2)  // for rounding.\\n                for { n := div(n, 2) } n { n := div(n,2) } {\\n                    let xx := mul(x, x)\\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\\n                    let xxRound := add(xx, half)\\n                    if lt(xxRound, xx) { revert(0,0) }\\n                    x := div(xxRound, base)\\n                    if mod(n,2) {\\n                        let zx := mul(z, x)\\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\\n                        let zxRound := add(zx, half)\\n                        if lt(zxRound, zx) { revert(0,0) }\\n                        z := div(zxRound, base)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IRiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Storage.sol\\\";\\n\\n// This interface is used to avoid a circular dependency between BaseLogic and RiskManager\\n\\ninterface IRiskManager {\\n    struct NewMarketParameters {\\n        uint16 pricingType;\\n        uint32 pricingParameters;\\n\\n        Storage.AssetConfig config;\\n    }\\n\\n    struct LiquidityStatus {\\n        uint collateralValue;\\n        uint liabilityValue;\\n        uint numBorrows;\\n        bool borrowIsolated;\\n    }\\n\\n    struct AssetLiquidity {\\n        address underlying;\\n        LiquidityStatus status;\\n    }\\n\\n    function getNewMarketParameters(address underlying) external returns (NewMarketParameters memory);\\n\\n    function requireLiquidity(address account) external;\\n    function computeLiquidity(address account) external returns (LiquidityStatus memory status);\\n    function computeAssetLiquidities(address account) external returns (AssetLiquidity[] memory assets);\\n\\n    function getPrice(address underlying) external returns (uint twap, uint twapPeriod);\\n    function getPriceFull(address underlying) external returns (uint twap, uint twapPeriod, uint currPrice);\\n}\\n\"\r\n    },\r\n    \"contracts/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n//import \\\"hardhat/console.sol\\\"; // DEV_MODE\\n\\nimport \\\"./Storage.sol\\\";\\nimport \\\"./Events.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\n\\nabstract contract Base is Storage, Events {\\n    // Modules\\n\\n    function _createProxy(uint proxyModuleId) internal returns (address) {\\n        require(proxyModuleId != 0, \\\"e/create-proxy/invalid-module\\\");\\n        require(proxyModuleId <= MAX_EXTERNAL_MODULEID, \\\"e/create-proxy/internal-module\\\");\\n\\n        // If we've already created a proxy for a single-proxy module, just return it:\\n\\n        if (proxyLookup[proxyModuleId] != address(0)) return proxyLookup[proxyModuleId];\\n\\n        // Otherwise create a proxy:\\n\\n        address proxyAddr = address(new Proxy());\\n\\n        if (proxyModuleId <= MAX_EXTERNAL_SINGLE_PROXY_MODULEID) proxyLookup[proxyModuleId] = proxyAddr;\\n\\n        trustedSenders[proxyAddr] = TrustedSenderInfo({ moduleId: uint32(proxyModuleId), moduleImpl: address(0) });\\n\\n        emit ProxyCreated(proxyAddr, proxyModuleId);\\n\\n        return proxyAddr;\\n    }\\n\\n    function callInternalModule(uint moduleId, bytes memory input) internal returns (bytes memory) {\\n        (bool success, bytes memory result) = moduleLookup[moduleId].delegatecall(input);\\n        if (!success) revertBytes(result);\\n        return result;\\n    }\\n\\n\\n\\n    // Modifiers\\n\\n    modifier nonReentrant() {\\n        require(reentrancyLock == REENTRANCYLOCK__UNLOCKED, \\\"e/reentrancy\\\");\\n\\n        reentrancyLock = REENTRANCYLOCK__LOCKED;\\n        _;\\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\\n    }\\n\\n    modifier reentrantOK() { // documentation only\\n        _;\\n    }\\n\\n    // WARNING: Must be very careful with this modifier. It resets the free memory pointer\\n    // to the value it was when the function started. This saves gas if more memory will\\n    // be allocated in the future. However, if the memory will be later referenced\\n    // (for example because the function has returned a pointer to it) then you cannot\\n    // use this modifier.\\n\\n    modifier FREEMEM() {\\n        uint origFreeMemPtr;\\n\\n        assembly {\\n            origFreeMemPtr := mload(0x40)\\n        }\\n\\n        _;\\n\\n        /*\\n        assembly { // DEV_MODE: overwrite the freed memory with garbage to detect bugs\\n            let garbage := 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF\\n            for { let i := origFreeMemPtr } lt(i, mload(0x40)) { i := add(i, 32) } { mstore(i, garbage) }\\n        }\\n        */\\n\\n        assembly {\\n            mstore(0x40, origFreeMemPtr)\\n        }\\n    }\\n\\n\\n\\n    // Error handling\\n\\n    function revertBytes(bytes memory errMsg) internal pure {\\n        if (errMsg.length > 0) {\\n            assembly {\\n                revert(add(32, errMsg), mload(errMsg))\\n            }\\n        }\\n\\n        revert(\\\"e/empty-error\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Constants.sol\\\";\\n\\nabstract contract Storage is Constants {\\n    // Dispatcher and upgrades\\n\\n    uint reentrancyLock;\\n\\n    address upgradeAdmin;\\n    address governorAdmin;\\n\\n    mapping(uint => address) moduleLookup; // moduleId => module implementation\\n    mapping(uint => address) proxyLookup; // moduleId => proxy address (only for single-proxy modules)\\n\\n    struct TrustedSenderInfo {\\n        uint32 moduleId; // 0 = un-trusted\\n        address moduleImpl; // only non-zero for external single-proxy modules\\n    }\\n\\n    mapping(address => TrustedSenderInfo) trustedSenders; // sender address => moduleId (0 = un-trusted)\\n\\n\\n\\n    // Account-level state\\n    // Sub-accounts are considered distinct accounts\\n\\n    struct AccountStorage {\\n        // Packed slot: 1 + 5 + 4 + 20 = 30\\n        uint8 deferLiquidityStatus;\\n        uint40 lastAverageLiquidityUpdate;\\n        uint32 numMarketsEntered;\\n        address firstMarketEntered;\\n\\n        uint averageLiquidity;\\n        address averageLiquidityDelegate;\\n    }\\n\\n    mapping(address => AccountStorage) accountLookup;\\n    mapping(address => address[MAX_POSSIBLE_ENTERED_MARKETS]) marketsEntered;\\n\\n\\n\\n    // Markets and assets\\n\\n    struct AssetConfig {\\n        // Packed slot: 20 + 1 + 4 + 4 + 3 = 32\\n        address eTokenAddress;\\n        bool borrowIsolated;\\n        uint32 collateralFactor;\\n        uint32 borrowFactor;\\n        uint24 twapWindow;\\n    }\\n\\n    struct UserAsset {\\n        uint112 balance;\\n        uint144 owed;\\n\\n        uint interestAccumulator;\\n    }\\n\\n    struct AssetStorage {\\n        // Packed slot: 5 + 1 + 4 + 12 + 4 + 2 + 4 = 32\\n        uint40 lastInterestAccumulatorUpdate;\\n        uint8 underlyingDecimals; // Not dynamic, but put here to live in same storage slot\\n        uint32 interestRateModel;\\n        int96 interestRate;\\n        uint32 reserveFee;\\n        uint16 pricingType;\\n        uint32 pricingParameters;\\n\\n        address underlying;\\n        uint96 reserveBalance;\\n\\n        address dTokenAddress;\\n\\n        uint112 totalBalances;\\n        uint144 totalBorrows;\\n\\n        uint interestAccumulator;\\n\\n        mapping(address => UserAsset) users;\\n\\n        mapping(address => mapping(address => uint)) eTokenAllowance;\\n        mapping(address => mapping(address => uint)) dTokenAllowance;\\n    }\\n\\n    mapping(address => AssetConfig) internal underlyingLookup; // underlying => AssetConfig\\n    mapping(address => AssetStorage) internal eTokenLookup; // EToken => AssetStorage\\n    mapping(address => address) internal dTokenLookup; // DToken => EToken\\n    mapping(address => address) internal pTokenLookup; // PToken => underlying\\n    mapping(address => address) internal reversePTokenLookup; // underlying => PToken\\n}\\n\"\r\n    },\r\n    \"contracts/Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Storage.sol\\\";\\n\\nabstract contract Events {\\n    event Genesis();\\n\\n\\n    event ProxyCreated(address indexed proxy, uint moduleId);\\n    event MarketActivated(address indexed underlying, address indexed eToken, address indexed dToken);\\n    event PTokenActivated(address indexed underlying, address indexed pToken);\\n\\n    event EnterMarket(address indexed underlying, address indexed account);\\n    event ExitMarket(address indexed underlying, address indexed account);\\n\\n    event Deposit(address indexed underlying, address indexed account, uint amount);\\n    event Withdraw(address indexed underlying, address indexed account, uint amount);\\n    event Borrow(address indexed underlying, address indexed account, uint amount);\\n    event Repay(address indexed underlying, address indexed account, uint amount);\\n\\n    event Liquidation(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint yield, uint healthScore, uint baseDiscount, uint discount);\\n\\n    event TrackAverageLiquidity(address indexed account);\\n    event UnTrackAverageLiquidity(address indexed account);\\n    event DelegateAverageLiquidity(address indexed account, address indexed delegate);\\n\\n    event PTokenWrap(address indexed underlying, address indexed account, uint amount);\\n    event PTokenUnWrap(address indexed underlying, address indexed account, uint amount);\\n\\n    event AssetStatus(address indexed underlying, uint totalBalances, uint totalBorrows, uint96 reserveBalance, uint poolSize, uint interestAccumulator, int96 interestRate, uint timestamp);\\n\\n\\n    event RequestDeposit(address indexed account, uint amount);\\n    event RequestWithdraw(address indexed account, uint amount);\\n    event RequestMint(address indexed account, uint amount);\\n    event RequestBurn(address indexed account, uint amount);\\n    event RequestTransferEToken(address indexed from, address indexed to, uint amount);\\n\\n    event RequestBorrow(address indexed account, uint amount);\\n    event RequestRepay(address indexed account, uint amount);\\n    event RequestTransferDToken(address indexed from, address indexed to, uint amount);\\n\\n    event RequestLiquidate(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint minYield);\\n\\n\\n    event InstallerSetUpgradeAdmin(address indexed newUpgradeAdmin);\\n    event InstallerSetGovernorAdmin(address indexed newGovernorAdmin);\\n    event InstallerInstallModule(uint indexed moduleId, address indexed moduleImpl, bytes32 moduleGitCommit);\\n\\n\\n    event GovSetAssetConfig(address indexed underlying, Storage.AssetConfig newConfig);\\n    event GovSetIRM(address indexed underlying, uint interestRateModel, bytes resetParams);\\n    event GovSetPricingConfig(address indexed underlying, uint16 newPricingType, uint32 newPricingParameter);\\n    event GovSetReserveFee(address indexed underlying, uint32 newReserveFee);\\n    event GovConvertReserves(address indexed underlying, address indexed recipient, uint amount);\\n\\n    event RequestSwap(address indexed accountIn, address indexed accountOut, address indexed underlyingIn, address underlyingOut, uint amount, uint swapType);\\n}\\n\"\r\n    },\r\n    \"contracts/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ncontract Proxy {\\n    address immutable creator;\\n\\n    constructor() {\\n        creator = msg.sender;\\n    }\\n\\n    // External interface\\n\\n    fallback() external {\\n        address creator_ = creator;\\n\\n        if (msg.sender == creator_) {\\n            assembly {\\n                mstore(0, 0)\\n                calldatacopy(31, 0, calldatasize())\\n\\n                switch mload(0) // numTopics\\n                    case 0 { log0(32,  sub(calldatasize(), 1)) }\\n                    case 1 { log1(64,  sub(calldatasize(), 33),  mload(32)) }\\n                    case 2 { log2(96,  sub(calldatasize(), 65),  mload(32), mload(64)) }\\n                    case 3 { log3(128, sub(calldatasize(), 97),  mload(32), mload(64), mload(96)) }\\n                    case 4 { log4(160, sub(calldatasize(), 129), mload(32), mload(64), mload(96), mload(128)) }\\n                    default { revert(0, 0) }\\n\\n                return(0, 0)\\n            }\\n        } else {\\n            assembly {\\n                mstore(0, 0xe9c4a3ac00000000000000000000000000000000000000000000000000000000) // dispatch() selector\\n                calldatacopy(4, 0, calldatasize())\\n                mstore(add(4, calldatasize()), shl(96, caller()))\\n\\n                let result := call(gas(), creator_, 0, 0, add(24, calldatasize()), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n\\n                switch result\\n                    case 0 { revert(0, returndatasize()) }\\n                    default { return(0, returndatasize()) }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract Constants {\\n    // Universal\\n\\n    uint internal constant SECONDS_PER_YEAR = 365.2425 * 86400; // Gregorian calendar\\n\\n\\n    // Protocol parameters\\n\\n    uint internal constant MAX_SANE_AMOUNT = type(uint112).max;\\n    uint internal constant MAX_SANE_SMALL_AMOUNT = type(uint96).max;\\n    uint internal constant MAX_SANE_DEBT_AMOUNT = type(uint144).max;\\n    uint internal constant INTERNAL_DEBT_PRECISION = 1e9;\\n    uint internal constant MAX_ENTERED_MARKETS = 10; // per sub-account\\n    uint internal constant MAX_POSSIBLE_ENTERED_MARKETS = 2**32; // limited by size of AccountStorage.numMarketsEntered\\n    uint internal constant CONFIG_FACTOR_SCALE = 4_000_000_000; // must fit into a uint32\\n    uint internal constant RESERVE_FEE_SCALE = 4_000_000_000; // must fit into a uint32\\n    uint32 internal constant DEFAULT_RESERVE_FEE = uint32(0.23 * 4_000_000_000);\\n    uint internal constant INITIAL_INTEREST_ACCUMULATOR = 1e27;\\n    uint internal constant AVERAGE_LIQUIDITY_PERIOD = 24 * 60 * 60;\\n    uint16 internal constant MIN_UNISWAP3_OBSERVATION_CARDINALITY = 10;\\n    uint24 internal constant DEFAULT_TWAP_WINDOW_SECONDS = 30 * 60;\\n    uint32 internal constant DEFAULT_BORROW_FACTOR = uint32(0.28 * 4_000_000_000);\\n\\n\\n    // Implementation internals\\n\\n    uint internal constant REENTRANCYLOCK__UNLOCKED = 1;\\n    uint internal constant REENTRANCYLOCK__LOCKED = 2;\\n\\n    uint8 internal constant DEFERLIQUIDITY__NONE = 0;\\n    uint8 internal constant DEFERLIQUIDITY__CLEAN = 1;\\n    uint8 internal constant DEFERLIQUIDITY__DIRTY = 2;\\n\\n\\n    // Pricing types\\n\\n    uint16 internal constant PRICINGTYPE__PEGGED = 1;\\n    uint16 internal constant PRICINGTYPE__UNISWAP3_TWAP = 2;\\n    uint16 internal constant PRICINGTYPE__FORWARDED = 3;\\n\\n\\n    // Modules\\n\\n    // Public single-proxy modules\\n    uint internal constant MODULEID__INSTALLER = 1;\\n    uint internal constant MODULEID__MARKETS = 2;\\n    uint internal constant MODULEID__LIQUIDATION = 3;\\n    uint internal constant MODULEID__GOVERNANCE = 4;\\n    uint internal constant MODULEID__EXEC = 5;\\n    uint internal constant MODULEID__SWAP = 6;\\n\\n    uint internal constant MAX_EXTERNAL_SINGLE_PROXY_MODULEID = 499_999;\\n\\n    // Public multi-proxy modules\\n    uint internal constant MODULEID__ETOKEN = 500_000;\\n    uint internal constant MODULEID__DTOKEN = 500_001;\\n\\n    uint internal constant MAX_EXTERNAL_MODULEID = 999_999;\\n\\n    // Internal modules\\n    uint internal constant MODULEID__RISK_MANAGER = 1_000_000;\\n\\n    // Interest rate models\\n    //   Default for new markets\\n    uint internal constant MODULEID__IRM_DEFAULT = 2_000_000;\\n    //   Testing-only\\n    uint internal constant MODULEID__IRM_ZERO = 2_000_001;\\n    uint internal constant MODULEID__IRM_FIXED = 2_000_002;\\n    uint internal constant MODULEID__IRM_LINEAR = 2_000_100;\\n    //   Classes\\n    uint internal constant MODULEID__IRM_CLASS__STABLE = 2_000_500;\\n    uint internal constant MODULEID__IRM_CLASS__MAJOR = 2_000_501;\\n    uint internal constant MODULEID__IRM_CLASS__MIDCAP = 2_000_502;\\n\\n    // Swap types\\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT_SINGLE = 1;\\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT = 2;\\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE = 3;\\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT = 4;\\n    uint internal constant SWAP_TYPE__1INCH = 5;\\n\\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE_REPAY = 6;\\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_REPAY = 7;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleGitCommit_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"uniswapRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oneInch_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalances\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"reserveBalance\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"interestRate\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AssetStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"DelegateAverageLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"EnterMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExitMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Genesis\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GovConvertReserves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"eTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowIsolated\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"collateralFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"borrowFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"twapWindow\",\"type\":\"uint24\"}],\"indexed\":false,\"internalType\":\"struct Storage.AssetConfig\",\"name\":\"newConfig\",\"type\":\"tuple\"}],\"name\":\"GovSetAssetConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRateModel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"resetParams\",\"type\":\"bytes\"}],\"name\":\"GovSetIRM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newPricingType\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newPricingParameter\",\"type\":\"uint32\"}],\"name\":\"GovSetPricingConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newReserveFee\",\"type\":\"uint32\"}],\"name\":\"GovSetReserveFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"moduleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"moduleImpl\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleGitCommit\",\"type\":\"bytes32\"}],\"name\":\"InstallerInstallModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernorAdmin\",\"type\":\"address\"}],\"name\":\"InstallerSetGovernorAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newUpgradeAdmin\",\"type\":\"address\"}],\"name\":\"InstallerSetUpgradeAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"violator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yield\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"healthScore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseDiscount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"eToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dToken\",\"type\":\"address\"}],\"name\":\"MarketActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"PTokenActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PTokenUnWrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PTokenWrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moduleId\",\"type\":\"uint256\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"violator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minYield\",\"type\":\"uint256\"}],\"name\":\"RequestLiquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountOut\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapType\",\"type\":\"uint256\"}],\"name\":\"RequestSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestTransferDToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestTransferEToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TrackAverageLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnTrackAverageLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"moduleGitCommit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneInch\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subAccountIdIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subAccountIdOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Swap.Swap1InchParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swap1Inch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subAccountIdIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subAccountIdOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct Swap.SwapUniExactOutputParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"targetDebt\",\"type\":\"uint256\"}],\"name\":\"swapAndRepayUni\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subAccountIdIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subAccountIdOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct Swap.SwapUniExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"targetDebt\",\"type\":\"uint256\"}],\"name\":\"swapAndRepayUniSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subAccountIdIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subAccountIdOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct Swap.SwapUniExactInputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapUniExactInput\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subAccountIdIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subAccountIdOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct Swap.SwapUniExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapUniExactInputSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subAccountIdIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subAccountIdOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct Swap.SwapUniExactOutputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapUniExactOutput\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subAccountIdIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subAccountIdOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct Swap.SwapUniExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapUniExactOutputSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Swap","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000000fc4e9ae2cb92db6bcd5e5cece13b5597f9fc937000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000001111111254fb6c44bac0bed2854e76f90643097d","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bfdfa2c468d853dffbcbf2057eeaec130a8ee39de7d518a7c7c82445160c1e08"}]}