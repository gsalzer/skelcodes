{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ncontract Context {\\n    /**\\n     * @return Address of the transaction message sender {msg.sender}\\n     * Returns the msg.sender\\n     */\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address public _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @param tokenOwner address of the token owner\\n     * Transfers ownership to tokenOwner\\n     */\\n    constructor(address tokenOwner) {\\n        _transferOwnership(tokenOwner);\\n    }\\n\\n    /**\\n     * @return Address of the owner of the contract\\n     * Returns the owner address\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * Modifier that checks if the msg.sender is the owner\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @return Boolean value true if flow was successful\\n     * Only owner can call the function\\n     * Releases ownership to address 0x0\\n     */\\n    function renounceOwnership() public onlyOwner returns(bool) {\\n        _transferOwnership(address(0));\\n        return true;\\n    }\\n    \\n    /**\\n     * @return Boolean value true if flow was successful\\n     * Only owner can call the function\\n     * Releases ownership to address newOwner\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner returns(bool){\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n        return true;\\n    }\\n\\n    /**\\n     * Sets newOwner as the owner and emits the OwnershipTransferred event\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"},\"Token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\npragma solidity ^0.8.9;\\n\\ncontract Token is IERC20, Ownable {\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    uint8 private _decimals;\\n    uint8 constant MAX_TAX_FEE_RATE = 6;\\n    uint8[4] private taxPercentages;\\n    uint8 public taxFee;\\n    uint256 public _totalSupply;\\n    uint256 public whaleAmount;\\n    uint256 public totalVestings;\\n\\n\\n    bool public antiWhale;\\n    bool public _enableTax;\\n\\n    address[4] public taxAddresses;\\n\\n    mapping(address =\\u003e uint256) private _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n    mapping(address =\\u003e bool) private _isExcludedFromFee;\\n    mapping(uint256 =\\u003e VestingDetails) public vestingID;\\n    mapping(address =\\u003e uint256[]) receiverIDs;\\n    mapping(address =\\u003e bool) isWhitelistedFromWhaleAmount;\\n\\n    enum taxAddressType {\\n        taxAddressNewMovies,\\n        taxAddressProfit,\\n        taxAddressDevelopment,\\n        taxAddressUserCredit\\n    }\\n\\n    event whaleAmountUpdated(\\n        uint256 oldAmount,\\n        uint256 newAmount,\\n        uint256 time\\n    );\\n    event antiWhaleUpdated(bool status, uint256 time);\\n    event taxAddressUpdated(address taxAddress, uint256 time, string info);\\n    event UpdatedWhitelistedAddress(address _address, bool isWhitelisted);\\n    event TaxTransfer(\\n        address indexed from,\\n        address[4] indexed to,\\n        uint256[4] indexed value\\n    );\\n\\n    struct VestingDetails {\\n        address receiver;\\n        uint256 amount;\\n        uint256 release;\\n        bool expired;\\n    }\\n\\n    /**\\n     * @dev Constructor.\\n     * @param __name name of the token\\n     * @param __symbol symbol of the token, 3-4 chars is recommended\\n     * @param __decimals number of decimal places of one token unit, 18 is widely used\\n     * @param _taxPercent will be the tax percentage, example: 6%\\n     * @param __totalSupply total supply of tokens in lowest units (depending on decimals)\\n     * @param _antiWhale to enable the antiwhale feature on/off, by default value is false.\\n     * @param _whaleAmount whale amount of tokens in lowest units (depending on decimals)\\n     * @param owner address that gets 100% of token supply\\n     * @param _taxAddresses will be the 4 addresses to which the tax fees will be sent in each token transfer when tax is applicable\\n     * @param _taxPercentages are the ratios of the tax percentage divided between the 4 _taxAddresses for example =\\u003e [ 10%, 20%, 30%, 40% ]\\n     */\\n    constructor(\\n        string memory __name,\\n        string memory __symbol,\\n        uint8 __decimals,\\n        uint8 _taxPercent,\\n        uint256 __totalSupply,\\n        bool _antiWhale,\\n        uint256 _whaleAmount,\\n        address owner,\\n        address[4] memory _taxAddresses,\\n        uint8[4] memory _taxPercentages\\n    ) Ownable(owner) {\\n        require(owner != address(0), \\\"Owner can\\u0027t be zero address\\\");\\n        require(\\n            _taxAddresses[0] != address(0) \\u0026\\u0026\\n                _taxAddresses[1] != address(0) \\u0026\\u0026\\n                _taxAddresses[2] != address(0) \\u0026\\u0026\\n                _taxAddresses[3] != address(0),\\n            \\\"Tax addresses cannot be zero address\\\"\\n        );\\n        require(_taxPercent \\u003c= MAX_TAX_FEE_RATE, \\\"Exceeded max tax rate limit\\\");\\n        require(\\n            _taxPercentages[0] +\\n                _taxPercentages[1] +\\n                _taxPercentages[2] +\\n                _taxPercentages[3] ==\\n                100,\\n            \\\"Total percentages must equal 100\\\"\\n        );\\n        require(_whaleAmount \\u003c __totalSupply, \\\"Whale amount must be lower than total supply\\\");\\n\\n        _name = __name;\\n        _symbol = __symbol;\\n        _decimals = __decimals;\\n        _owner = owner;\\n        whaleAmount = _whaleAmount * 10**__decimals;\\n        antiWhale = _antiWhale;\\n        _totalSupply = __totalSupply * 10**__decimals;\\n        taxFee = _taxPercent;\\n        _enableTax = true;\\n\\n        // set tokenOwnerAddress as owner of all tokens and the owner has the control of antiWhale feature if enabled.\\n        _balances[_owner] = _totalSupply;\\n\\n        // Mapping tax address\\n        taxAddresses[uint256(taxAddressType.taxAddressDevelopment)] = _taxAddresses[uint256(taxAddressType.taxAddressDevelopment)];\\n        taxAddresses[uint256(taxAddressType.taxAddressNewMovies)] = _taxAddresses[uint256(taxAddressType.taxAddressNewMovies)];\\n        taxAddresses[uint256(taxAddressType.taxAddressProfit)] = _taxAddresses[uint256(taxAddressType.taxAddressProfit)];\\n        taxAddresses[uint256(taxAddressType.taxAddressUserCredit)] = _taxAddresses[uint256(taxAddressType.taxAddressUserCredit)];\\n\\n        // Mapping tax percentages\\n        taxPercentages[uint256(taxAddressType.taxAddressDevelopment)] = _taxPercentages[uint256(taxAddressType.taxAddressDevelopment)];\\n        taxPercentages[uint256(taxAddressType.taxAddressNewMovies)] = _taxPercentages[uint256(taxAddressType.taxAddressNewMovies)];\\n        taxPercentages[uint256(taxAddressType.taxAddressProfit)] = _taxPercentages[uint256(taxAddressType.taxAddressProfit)];\\n        taxPercentages[uint256(taxAddressType.taxAddressUserCredit)] = _taxPercentages[uint256(taxAddressType.taxAddressUserCredit)];\\n\\n        // Owner and taxAddresses are excluded from transfer tax fees\\n        _isExcludedFromFee[_owner] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressDevelopment)]] = true;\\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressNewMovies)]] = true;\\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressProfit)]] = true;\\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressUserCredit)]] = true;\\n\\n        isWhitelistedFromWhaleAmount[_owner] = true;\\n        isWhitelistedFromWhaleAmount[address(this)] = true;\\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressDevelopment)]] = true;\\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressNewMovies)]] = true;\\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressProfit)]] = true;\\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressUserCredit)]] = true;\\n\\n\\n    }\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @return the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @return the number of decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @return the total supply of tokens\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Allows the owner to change the whale amount per transaction\\n     * @param _amount The amount of lowest token units to be set as whaleAmount\\n     * @return _success true (bool) if the flow was successful\\n     */\\n    function updateWhaleAmount(uint256 _amount)\\n        external\\n        onlyOwner\\n        returns (bool _success)\\n    {\\n        require(antiWhale, \\\"Anti whale is turned off\\\");\\n        uint256 oldAmount = whaleAmount;\\n        whaleAmount = _amount;\\n        emit whaleAmountUpdated(oldAmount, whaleAmount, block.timestamp);\\n        return true;    \\n    }\\n\\n    /**\\n     * @dev Allows the owner to turn the anti whale feature on/off.\\n     * @param status disable (false) / enable (enable) bool value\\n     * @return _success true (bool) if the flow was successful\\n     */\\n    function updateAntiWhale(bool status) external onlyOwner returns (bool _success) {\\n        antiWhale = status;\\n        emit antiWhaleUpdated(antiWhale, block.timestamp);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * @param spender Address of spender\\n     * @param value uint amount that spender is approved by msg.sender to spend\\n     * @return _success bool (true) if flow was successful\\n     *\\n     * Approves spender to spend value tokens from msg.sender\\n     */\\n    function approve(address spender, uint256 value) public returns (bool _success) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n        /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * @param owner Address of owner of token who sets allowance for spender to use the owner\\u0027s tokens\\n     * @param spender Address of spender whose allowance is being set by msg.sender\\n     * @param value Value by which spender\\u0027s allowance is being reduced\\n     * @return _success bool value =\\u003e true if flow was successful\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal returns (bool _success) {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n        return true;\\n    }\\n\\n        /**\\n     * @dev See `IERC20.allowance`.\\n     * @param owner Address of the owner of the tokens\\n     * @param spender Address of the spender of the owners\\u0027s tokens\\n     * @return the amount of token set by owner for spender to spend\\n     */\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n        /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * @param spender Address of spender whose allowance is being increased by msg.sender\\n     * @param addedValue Value by which spender\\u0027s allowance is being increased\\n     * @return _success bool value =\\u003e true if flow was successful\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        returns (bool _success)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * @param spender Address of spender whose allowance is being increased by msg.sender\\n     * @param subtractedValue Value by which spender\\u0027s allowance is being reduced\\n     * @return _success bool value =\\u003e true if flow was successful \\n     *   \\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        external\\n        returns (bool _success)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender] - subtractedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @param _address Address of the user\\n     * @param _isWhitelisted boolean (true or false), whether the address must be enabled/disabled from whitelist\\n     * @return success Boolean value =\\u003e true if flow was successful\\n     * Updates an account\\u0027s status in the whitelistFromWhaleAmount (enable/disable)\\n     */\\n    function updateWhitelistedAddressFromWhale(address _address, bool _isWhitelisted) public onlyOwner\\n    returns(bool success){\\n        isWhitelistedFromWhaleAmount[_address] = _isWhitelisted;\\n        emit UpdatedWhitelistedAddress(_address, _isWhitelisted);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * @param sender Address of sender whose is transferring amount to the recipient\\n     * @param recipient Address of the receiver of tokens from the sender\\n     * @param amount Amount of tokens being transferred by sender to the recipient\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     *\\n     *Transfers {amount} token from sender to recipient\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool _success) {\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     * @param recipient Address of the receiver of tokens from the sender\\n     * @param amount Amount of tokens being transferred by sender to the recipient\\n     * @return _success Boolean value true if the flow is successful\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool _success) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n        /**\\n     * @dev Allows the caller to airdrop tokens.\\n     * @param users Addresses of the users.\\n     * @param amounts Token values to the corresponding users.\\n     * @param totalSum Total sum of the tokens to be airdropped to all users.\\n     * @return _success true (bool) if the flow was successful\\n     */\\n    function multiSend(\\n        address[] memory users,\\n        uint256[] memory amounts,\\n        uint256 totalSum\\n    ) external returns (bool _success) {\\n        require(users.length == amounts.length, \\\"Length mismatch\\\");\\n        require(totalSum \\u003c= balanceOf(msg.sender), \\\"Not enough balance\\\");\\n\\n        for (uint256 i = 0; i \\u003c users.length; i++) {\\n            _transfer(msg.sender, users[i], amounts[i]);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @param from Address of sender whose is transferring amount to the recipient\\n     * @param to Address of the receiver of tokens from the sender\\n     * @param amount Amount of tokens being transferred by sender to the recipient\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Transfers amount from {from} to {to}\\n     * Checks for antiWhale\\n     * Checks for tax applicability\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool _success) {\\n        \\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\n\\n        // Transfer will be taxed if both sender and receiver are not excluded from fee\\n        bool isTaxed = _enableTax \\u0026\\u0026\\n            (!(_isExcludedFromFee[from] || _isExcludedFromFee[to]));\\n\\n        // Checking for anti-whale\\n        if (antiWhale) {\\n            uint256 tax_amount = 0;\\n            if (isTaxed) tax_amount = (amount * taxFee) / 10**2;\\n            require(\\n                (amount - tax_amount) \\u003c= whaleAmount,\\n                \\\"Transfer amount exceeds max amount\\\"\\n            );\\n            //If account is not whitelisted from whale amount, then checking if total balance will be greater than whale amount \\n            if(!isWhitelistedFromWhaleAmount[to]){\\n                require(\\n                    balanceOf(to) + amount - tax_amount \\u003c= whaleAmount,\\n                    \\\"Recipient amount exceeds max amount\\\"\\n                );\\n            }\\n        }\\n        unchecked {\\n            require(balanceOf(from) \\u003e= amount, \\\"Amount exceeds balance\\\");\\n            _balances[from] = _balances[from] - amount;\\n        }\\n\\n        // If any account belongs to _isExcludedFromFee account then no tax will be applied\\n        if (!isTaxed) {\\n            // No tax\\n            // SafeMath for addition overflow built-in\\n            _balances[to] += amount;\\n            emit Transfer(from, to, amount);\\n        } else {\\n            // Calculation of Tax amount\\n            uint256 tax_amount = (amount * taxFee) / (10**2);\\n\\n            _transferFee(tax_amount);\\n\\n            // Subtracting tax from transfer amount to receiver\\n            _balances[to] += amount - tax_amount;\\n            emit Transfer(from, to, amount - tax_amount);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @param tax Amount of tokens to be divided between the 4 tax addresses\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Transfers the tax fee to the tax addresses divided between them in the ratio provided in taxRatios\\n     */\\n    function _transferFee(uint256 tax) private returns (bool _success) {\\n        uint8[4] storage taxRatios = taxPercentages;\\n        address[4] storage _taxAddresses = taxAddresses;\\n        // Transfers the tax fee to the tax addresses : taxAddressDevelopment, taxAddressNewMovies, taxAddressProfit\\n        uint256 taxAmountDevelopment = (tax * taxRatios[uint256(taxAddressType.taxAddressDevelopment)]) / (100);\\n        uint256 taxAmountNewMovies = (tax * taxRatios[uint256(taxAddressType.taxAddressNewMovies)]) / (100);\\n        uint256 taxAmountProfit = (tax * taxRatios[uint256(taxAddressType.taxAddressProfit)]) / (100);\\n        uint256 taxAmountUserCredit = (tax * taxRatios[uint256(taxAddressType.taxAddressUserCredit)]) / (100);\\n\\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressDevelopment)]] += taxAmountDevelopment ;\\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressNewMovies)]] += taxAmountNewMovies;\\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressProfit)]] += taxAmountProfit;\\n\\n        uint256 totalDivided = taxAmountDevelopment + taxAmountNewMovies + taxAmountProfit + taxAmountUserCredit;\\n\\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressUserCredit)]] += taxAmountUserCredit + tax - (totalDivided);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @param account Address of the account to be checked if its excluded from tax fees\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Checks if account is excluded from tax fee\\n     */\\n    function isExcludedFromFee(address account) public view returns (bool _success) {\\n        return _isExcludedFromFee[account];\\n    }\\n\\n        /** \\n    * @param applicable Boolean to set the tax applicability as true or false\\n    * @return _success boolean (true) if flow was successful\\n    Changes the tax applicability as provided in the input\\n    */\\n    function isTaxApplicable(bool applicable)\\n        external\\n        onlyOwner\\n        returns (bool _success)\\n    {\\n        if (_enableTax != applicable) {\\n            _enableTax = applicable;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @param newAddress Address of the new taxAddress of type {_type}\\n     * @param _type Tax address type, one of the 4 types : \\n        taxAddressNewMovies,\\n        taxAddressProfit,\\n        taxAddressDevelopment,\\n        taxAddressUserCredit\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Changes tax address of type {_type}\\n     * Includes the previous address in tax fee\\n     * Excludes the new address from tax fee\\n     * Exclude old address from whitelist, and includes the new address\\n     */\\n    function changeTaxAddress(address newAddress, taxAddressType _type)\\n        external\\n        onlyOwner\\n        returns (bool _success)\\n    {   \\n        includeInFee(taxAddresses[uint256(_type)]);\\n        updateWhitelistedAddressFromWhale(taxAddresses[uint256(_type)], false);\\n        updateWhitelistedAddressFromWhale(newAddress, true);\\n        excludeFromFee(newAddress);\\n        taxAddresses[uint256(_type)] = newAddress;\\n        \\n        return true;\\n\\n    }\\n\\n    /**\\n     * @param _taxPercentages The ratios of the division of the tax fees between the 4 tax addresses\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Changes the ratio of tax division between the 4 tax addresses: \\n        taxAddressNewMovies,\\n        taxAddressProfit,\\n        taxAddressDevelopment,\\n        taxAddressUserCredit\\n     */\\n    function changeTaxPercentages(uint8[4] calldata _taxPercentages)\\n        external\\n        onlyOwner\\n        returns (bool _success)\\n    {\\n        require(\\n            _taxPercentages[0] +\\n                _taxPercentages[1] +\\n                _taxPercentages[2] +\\n                _taxPercentages[3] ==\\n                100,\\n            \\\"Total percentages must equal 100\\\"\\n        );\\n        taxPercentages[uint256(taxAddressType.taxAddressDevelopment)] = _taxPercentages[uint256(taxAddressType.taxAddressDevelopment)];\\n        taxPercentages[uint256(taxAddressType.taxAddressNewMovies)] = _taxPercentages[uint256(taxAddressType.taxAddressNewMovies)];\\n        taxPercentages[uint256(taxAddressType.taxAddressProfit)] = _taxPercentages[uint256(taxAddressType.taxAddressProfit)];\\n        taxPercentages[uint256(taxAddressType.taxAddressUserCredit)] = _taxPercentages[uint256(taxAddressType.taxAddressUserCredit)];\\n        return true;\\n    }\\n\\n    /**\\n     * @param _taxFee Tax rate in percentage to be set by owner\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Owner can set the tax rate, maximum upto 6%\\n     */\\n    function changeTaxFeePercent(uint8 _taxFee) external onlyOwner returns (bool _success) {\\n        require(_taxFee \\u003c= MAX_TAX_FEE_RATE, \\\"Exceeded max tax rate\\\");\\n        taxFee = _taxFee;\\n        return true;\\n    }\\n\\n    /**\\n     * @param account Address of account to be evicted from taxes during each transfer\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Account will be evicted from taxes for each transfer\\n     */\\n    function excludeFromFee(address account) public onlyOwner returns (bool _success) {\\n        _isExcludedFromFee[account] = true;\\n        return true;\\n    }\\n\\n    /**\\n     * @param account Address of account to be applicable to pay taxes during each transfer\\n     * @return _success Boolean value =\\u003e true if flow was successful\\n     * Account will be applicable to pay taxes for each transfer\\n     */\\n    function includeInFee(address account) public onlyOwner returns (bool _success) {\\n        _isExcludedFromFee[account] = false;\\n        return true;\\n    }\\n\\n    /**\\n     * @param account Address of account\\n     * @return Number of tokens owned by the account\\n     * Returns the balance of tokens of the account\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n    * @param _receiver Address of the receiver of the vesting\\n    * @param _amount Amount of tokens to be locked up for vesting\\n    * @param _release Timestamp of the release time\\n    * @return _success Boolean value true if flow is successful\\n    * Creates a new vesting\\n    */\\n    function createVesting(\\n        address _receiver,\\n        uint256 _amount,\\n        uint256 _release\\n    ) public returns (bool _success) {\\n        require(_receiver != address(0), \\\"Zero receiver address\\\");\\n        require(_amount \\u003e 0, \\\"Zero amount\\\");\\n        require(_release \\u003e block.timestamp, \\\"Incorrect release time\\\");\\n\\n        totalVestings++;\\n        vestingID[totalVestings] = VestingDetails(\\n            _receiver,\\n            _amount,\\n            _release,\\n            false\\n        );\\n        // Adds the vesting id corresponding to the receiver\\n        receiverIDs[_receiver].push(totalVestings);\\n        require(_transfer(msg.sender, address(this), _amount));\\n        return true;\\n    }\\n\\n        /**\\n    * @param _receivers Arrays of address of receiver of vesting amount\\n    * @param _amounts Array of amounts corresponding to each vesting\\n    * @param _releases Array of release timestamps corresponding to each vesting\\n    * @return _success Boolean value true if flow is successful\\n    * Creates multiple vesting, calls createVesting for each corresponding entry in {_receivers} {_amounts} {_releases}\\n    */\\n    function createMultipleVesting(\\n        address[] memory _receivers,\\n        uint256[] memory _amounts,\\n        uint256[] memory _releases\\n    ) external returns (bool _success) {\\n        require(\\n            _receivers.length == _amounts.length \\u0026\\u0026\\n                _amounts.length == _releases.length,\\n            \\\"Invalid data\\\"\\n        );\\n        for (uint256 i = 0; i \\u003c _receivers.length; i++) {\\n            bool success = createVesting(\\n                _receivers[i],\\n                _amounts[i],\\n                _releases[i]\\n            );\\n            require(success, \\\"Creation of vesting failed\\\");\\n        }\\n        return true;\\n    }\\n\\n        /**\\n    * @param id Id of the vesting\\n    * @return Boolean value true if flow is successful\\n    * Returns the release timestamp of the the vesting\\n    */\\n    function getReleaseTime(uint256 id) public view returns(uint256){\\n        require(id \\u003e 0 \\u0026\\u0026 id \\u003c= totalVestings, \\\"Id out of bounds\\\");\\n        VestingDetails storage vestingDetail = vestingID[id];\\n        require(!vestingDetail.expired, \\\"ID expired\\\");\\n        return vestingDetail.release;\\n    }\\n\\n    /**\\n    * @param id Id of the vesting\\n    * @return _success Boolean value true if flow is successful\\n    * The receiver of the vesting can claim their vesting if the vesting ID corresponds to their address \\n    * and hasn\\u0027t expired\\n    */\\n    function claim(uint256 id) external returns (bool _success) {\\n        require(id \\u003e 0 \\u0026\\u0026 id \\u003c= totalVestings, \\\"Id out of bounds\\\");\\n        VestingDetails storage vestingDetail = vestingID[id];\\n        require(msg.sender == vestingDetail.receiver, \\\"Caller is not the receiver\\\");\\n        require(!vestingDetail.expired, \\\"ID expired\\\");\\n        require(\\n            block.timestamp \\u003e= vestingDetail.release,\\n            \\\"Release time not reached\\\"\\n        );\\n        vestingID[id].expired = true;\\n        require(_transfer(\\n            address(this),\\n            vestingDetail.receiver,\\n            vestingDetail.amount\\n        ));\\n        return true;\\n    }\\n\\n    /**\\n    * @param user Address of receiver of vesting amount\\n    * @return Array of IDs corresponding to vesting assigned to the user\\n    * Returns the IDs of the vestings , the user corresponds to\\n    */\\n    function getReceiverIDs(address user)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return receiverIDs[user];\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"__name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"__symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"__decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_taxPercent\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"__totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_antiWhale\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_whaleAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[4]\",\"name\":\"_taxAddresses\",\"type\":\"address[4]\"},{\"internalType\":\"uint8[4]\",\"name\":\"_taxPercentages\",\"type\":\"uint8[4]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[4]\",\"name\":\"to\",\"type\":\"address[4]\"},{\"indexed\":true,\"internalType\":\"uint256[4]\",\"name\":\"value\",\"type\":\"uint256[4]\"}],\"name\":\"TaxTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"UpdatedWhitelistedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"antiWhaleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taxAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"name\":\"taxAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"whaleAmountUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_enableTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiWhale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"internalType\":\"enum Token.taxAddressType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"changeTaxAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_taxFee\",\"type\":\"uint8\"}],\"name\":\"changeTaxFeePercent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[4]\",\"name\":\"_taxPercentages\",\"type\":\"uint8[4]\"}],\"name\":\"changeTaxPercentages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_releases\",\"type\":\"uint256[]\"}],\"name\":\"createMultipleVesting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_release\",\"type\":\"uint256\"}],\"name\":\"createVesting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getReceiverIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getReleaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"applicable\",\"type\":\"bool\"}],\"name\":\"isTaxApplicable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSum\",\"type\":\"uint256\"}],\"name\":\"multiSend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"taxAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVestings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"updateAntiWhale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateWhaleAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"updateWhitelistedAddressFromWhale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"release\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"expired\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Token","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000005f5e10000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000002faf080000000000000000000000000d9b12d1afc4399f19c06d9e818e2728f310f81d7000000000000000000000000086a0f48d78ff25852b45e5e29d30c544aff8457000000000000000000000000ea829ff57089b446226d11f0dc75d9ad592d3f78000000000000000000000000ef1ea3289cffc7c09ce3a352efa6a5d6bc88989c00000000000000000000000080145e4a1d077d6659b876781260315a8343a8c5000000000000000000000000000000000000000000000000000000000000001900000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000001900000000000000000000000000000000000000000000000000000000000000094d4f564945434f494e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d4f564945000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://838be08989e4e3ee37466b88fd260d9c18539ecb7295f6cdd18b777af3e9afa9"}]}