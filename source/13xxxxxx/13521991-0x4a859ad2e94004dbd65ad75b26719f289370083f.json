{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.9;\r\n\r\ninterface IReverseResolver {\r\n    function claim(address owner) external returns (bytes32);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\ninterface IDepositRaffleValidator {\r\n    function validate (address account, bytes calldata metadata) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title DepositRaffle\r\n * @dev Provides gas-war-free registration and distribution\r\n */\r\ncontract DepositRaffle {\r\n\r\n    ///// Validator links /////\r\n    IDepositRaffleValidator Validator;\r\n    bool validatorActive = false;\r\n\r\n    event TicketIssued(uint256 ticketId, address holder, bytes32 metadataHash);\r\n\r\n    address payable public owner;\r\n\r\n    ///// Pricing information /////\r\n    uint256 immutable public deposit;\r\n    uint256 immutable public price;\r\n\r\n    uint256 immutable public quantity; // Number of winners to draw\r\n\r\n    uint256 public startBlockNumber; // First block tickets are allowed to be bought in\r\n    uint256 public endBlockNumber; // Final block tickets are allowed to be bought in\r\n\r\n    bytes32 seedHash;\r\n    uint256 seedBlock;\r\n    uint256 offset = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 increment;\r\n\r\n    bool incomeClaimed = false;\r\n\r\n    address[] public holderByTicketId;\r\n\r\n    uint256[8] internal Primes = [81918643972203779099,\r\n                                  72729269248899238429,\r\n                                  19314683338901247061,\r\n                                  38707402401747623009,\r\n                                  54451314435228525599,\r\n                                  16972551169207064863,\r\n                                  44527956848616763003,\r\n                                  51240633499522341181];\r\n\r\n\r\n    ///// Modifiers /////\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        _;\r\n    }\r\n\r\n    modifier issuanceOpen () {\r\n        require(block.number <= endBlockNumber && startBlockNumber > 0, \"Issuance Closed\");\r\n        _;\r\n    }\r\n\r\n    modifier issuanceClosed () {\r\n        require(block.number > endBlockNumber, \"Issuance Open\");\r\n        _;\r\n    }\r\n\r\n    modifier refundsReady () {\r\n        // After ~30 days, if shuffle has not been performed, refunds become available;\r\n        require(increment > 0 || (increment == 0 && block.number > (endBlockNumber + 200_000)), \"Refunds Not Ready\");\r\n        _;\r\n    }\r\n\r\n    bool private notEntered = true;\r\n\r\n    modifier nonReentrant() {\r\n        require(notEntered, \"Reentrant call\");\r\n        notEntered = false;\r\n        _;\r\n        notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev How many tickets have been issued currently?\r\n     */\r\n    function ticketsIssued () public view returns (uint256) {\r\n        return holderByTicketId.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Purchase a ticket for this raffle.\r\n     * Allows purchasing a ticket \"in the name of\" another address.\r\n     */\r\n    function issueTicket (address holder, bytes calldata metadata) public payable issuanceOpen nonReentrant returns (uint256) {\r\n        require(msg.value >= deposit, \"Insufficient Deposit\");\r\n        require(!validatorActive || Validator.validate(holder, metadata), \"Invalid\");\r\n        uint256 ticketId = holderByTicketId.length;\r\n        holderByTicketId.push(holder);\r\n\r\n        emit TicketIssued(ticketId, holder, keccak256(metadata));\r\n        if (msg.value > deposit) {\r\n            (bool success,) = payable(msg.sender).call{value: (msg.value - deposit)}(\"\");\r\n            require(success, \"Overpay Refund Transfer Failed\");\r\n        }\r\n        return ticketId;\r\n    }\r\n\r\n    /**\r\n     * @dev Purchase a ticket in the name of the transaction sender.\r\n     */\r\n    function issueTicket(bytes calldata metadata) public payable returns (uint256) {\r\n        return issueTicket(msg.sender, metadata);\r\n    }\r\n\r\n    /**\r\n     * @dev Start a shuffle action.\r\n     * The hash submitted here must be the keccak256 hash of a secret number that will be submitted to the next function\r\n     */\r\n    function prepareShuffleWinners (bytes32 _seedHash) public issuanceClosed onlyOwner {\r\n        require(_seedHash != 0 && seedHash != _seedHash, \"Invalid Seed Hash\");\r\n        require(seedBlock == 0 || block.number > seedBlock + 255, \"Seed Already Set\");\r\n        seedHash = _seedHash;\r\n        seedBlock = block.number;\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize the shuffle action.\r\n     * Should be called after `prepareShuffleWinners`, after at leas two blocks have passed.\r\n     */\r\n    function shuffleWinners (uint256 seed) public issuanceClosed {\r\n        require(increment == 0, \"Already Shuffled\");\r\n        require(block.number <= (endBlockNumber + 170_000), \"Shuffle Window Closed\");\r\n\r\n        if (holderByTicketId.length <= quantity) {\r\n            increment = 1;\r\n            return;\r\n        }\r\n\r\n        require(keccak256(abi.encodePacked(seed)) == seedHash, \"Invalid Seed\");\r\n        require(block.number > seedBlock + 2 && block.number < seedBlock + 255, \"Seed Block Error\");\r\n\r\n        uint256 randomSeed = uint256(keccak256(abi.encodePacked(seed, blockhash(seedBlock + 1), blockhash(seedBlock + 2))));\r\n\r\n        offset = randomSeed % holderByTicketId.length;\r\n\r\n        increment = Primes[uint256(keccak256(abi.encodePacked(randomSeed, randomSeed))) % 8];\r\n    }\r\n\r\n    /**\r\n     * @dev What 'order' is a given ticket in, in the winning shuffle?\r\n     * If all the tickets were to be put into a separate array in the \"shuffled\" order, what index would a given ticketID be at?\r\n     */\r\n    function drawIndex (uint256 ticketId) public view refundsReady returns (uint256) {\r\n        return (increment * ticketId + offset) % holderByTicketId.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Is the given ticketId a winning ticket?\r\n     */\r\n    function isWinner (uint256 ticketId) public view refundsReady returns (bool) {\r\n        if (increment == 0) {\r\n            return false;\r\n        } else if (holderByTicketId.length <= quantity) {\r\n            require(ticketId < holderByTicketId.length, \"Out of Range\");\r\n            return true;\r\n        } else {\r\n            return (increment * ticketId + offset) % holderByTicketId.length < quantity;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Are non-winners able to withdraw their deposits yet?\r\n     */\r\n    function availableRefund (address holder, uint256[] calldata ticketIds) public view refundsReady returns (uint256) {\r\n        uint256 refund = 0;\r\n        for (uint i = 0; i < ticketIds.length; i++) {\r\n            uint256 ticketId = ticketIds[i];\r\n            if (holder == holderByTicketId[ticketId]) {\r\n                refund += deposit;\r\n                if (isWinner(ticketId)) {\r\n                    refund -= price;\r\n                }\r\n           }\r\n        }\r\n        return refund;\r\n    }\r\n\r\n    /**\r\n     * @dev Claim deposited funds after raffle is over.\r\n     * For non-winning tickets, their entire deposit is refunded.\r\n     * For winning tickets, the difference between the deposit price and the actual price is refunded.\r\n     * In either case the ticket is destroyed after refunding. This refunds some gas to the ticket owner, making this operation less costly.\r\n     */\r\n    function claimRefund (uint256[] calldata ticketIds) public refundsReady {\r\n        uint256 refund = 0;\r\n        for (uint i = 0; i < ticketIds.length; i++) {\r\n            uint256 ticketId = ticketIds[i];\r\n            if (msg.sender == holderByTicketId[ticketId]) {\r\n                refund += deposit;\r\n                if (isWinner(ticketId)) {\r\n                    refund -= price;\r\n                }\r\n                delete holderByTicketId[ticketId];\r\n            }\r\n        }\r\n        if (refund > 0) {\r\n            (bool success,) = payable(msg.sender).call{value: refund}(\"\");\r\n            require(success, \"Refund Transfer Failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allow `owner` to claim remaining funds.\r\n     * Losing raffle tickets have 90 days to claim their refunds. After that time the owner of the raffle is entitled to sweep the rest of the ETH.\r\n     */\r\n    function claimBalance () public onlyOwner {\r\n        // After ~90 days, contract owner can claim all funds\r\n        require (block.number > (endBlockNumber + 600_000));\r\n        (bool success,) = owner.call{value: address(this).balance}(\"\");\r\n        require(success, \"Claim Failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Allow `owner` to withdraw income from winning tickets after winners have been picked.\r\n     */\r\n    function claimIncome () public onlyOwner {\r\n        require(increment > 0, \"Not Shuffled\");\r\n        require(!incomeClaimed, \"Income Claimed\");\r\n        incomeClaimed = true;\r\n        uint256 balance;\r\n        if (holderByTicketId.length <= quantity) {\r\n            balance = holderByTicketId.length * price;\r\n        } else {\r\n            balance = quantity * price;\r\n        }\r\n        (bool success,) = owner.call{value: balance}(\"\");\r\n        require(success, \"Claim Failed\");\r\n    }\r\n\r\n    ///// Administration /////\r\n\r\n    /**\r\n     * @dev Start the raffle.\r\n     */\r\n    function openMinting (uint256 durationInBlocks) public onlyOwner {\r\n        require(startBlockNumber == 0, \"Minting Started\");\r\n        endBlockNumber = block.number + durationInBlocks;\r\n        startBlockNumber = block.number;\r\n    }\r\n\r\n    /**\r\n     * @dev Specify a contract to be used as a Validator of all ticket entries.\r\n     */\r\n    function activateValidation (address validatorContractAddress) public onlyOwner {\r\n        validatorActive = true;\r\n        Validator = IDepositRaffleValidator(validatorContractAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Disable any Validator for this raffle.\r\n     */\r\n    function deactivateValidation () public onlyOwner {\r\n        validatorActive = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow current `owner` to transfer ownership to another address\r\n     */\r\n    function transferOwnership (address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC20 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC20 (address tokenContract) public onlyOwner {\r\n        IERC20 token = IERC20(tokenContract);\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC721 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC721 (address tokenContract, uint256 tokenId) public onlyOwner {\r\n        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);\r\n    }\r\n\r\n    constructor (uint256 depositWei, uint256 priceWei, uint256 totalQuantity) {\r\n        require (depositWei >= priceWei, \"Price > Deposit\");\r\n        deposit = depositWei;\r\n        price = priceWei;\r\n        quantity = totalQuantity;\r\n        owner = payable(msg.sender);\r\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\r\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148).claim(msg.sender);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"}],\"name\":\"TicketIssued\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validatorContractAddress\",\"type\":\"address\"}],\"name\":\"activateValidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"}],\"name\":\"availableRefund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"}],\"name\":\"claimRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateValidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"drawIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holderByTicketId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"isWinner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"issueTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"issueTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationInBlocks\",\"type\":\"uint256\"}],\"name\":\"openMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_seedHash\",\"type\":\"bytes32\"}],\"name\":\"prepareShuffleWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"shuffleWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketsIssued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawForeignERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DepositRaffle","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000c7d713b49da00000000000000000000000000000000000000000000000000000c7d713b49da000000000000000000000000000000000000000000000000000000000000000000fa","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e477ab1b1d8955757e195ce88d37111e74638f8e7ee25c6edbc236be1eaa2d52"}]}