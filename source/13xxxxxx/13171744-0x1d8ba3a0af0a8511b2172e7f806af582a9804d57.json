{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-10-26\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract LPStaker {\r\n    \r\n    struct StakeState {\r\n        uint128 balance;\r\n        uint64 lockedUntil;\r\n        uint64 reward;\r\n    }\r\n    \r\n\r\n    // TODO: DEPLOYMENT-SPECIFIC PARAMETERS\r\n    IERC20 private constant depositToken = IERC20(0x510C9b3FE162f463DAC2F8c6dDd3d8ED5F49e360); // HGET/CHR\r\n    IERC20 private constant rewardToken1 = IERC20(0x7968bc6a03017eA2de509AAA816F163Db0f35148); // HGET\r\n    IERC20 private constant rewardToken2 = IERC20(0x8A2279d4A90B6fe1C4B30fa660cC9f926797bAA2); // CHR\r\n\r\n    uint64 constant lockTime = 4 weeks;\r\n    uint64 constant depositDeadline = 1632085200; // 2021-09-20\r\n\r\n    // TODO: these are highly volatile parameters, update right before deployment\r\n    uint128 constant chrPerHGET = 9; // affects only reward\r\n    uint128 constant hgetPerLPToken = 348762938230; // TODO. Expressed in aomout of HGET per 1 LP token\r\n    // e.g. suppose 0.00000003464 LP tokens contain 22896.3 HGET\r\n    // then 1 LP token has 22896.3 / 0.00000003464\r\n    // 660,978,637,413 HGET \r\n    \r\n    // these paramters affect yield\r\n    uint128 constant initialDepositedTokens = 2500 * 1000000; // an offset\r\n    uint128 constant initialAllocatedReward = 485 * 1000000; // an offset\r\n    uint128 constant maxAllocatedReward = 25000 * 1000000; \r\n    \r\n    uint128 totalDepositedTokens = initialDepositedTokens; \r\n    uint128 totalAllocatedReward = initialAllocatedReward;\r\n    uint128 public totalBonusDeposits = 0;\r\n    \r\n    function sumDepositedTokens() external view returns (uint128) { return totalDepositedTokens - initialDepositedTokens; }\r\n    function sumAllocatedReward() external view returns (uint128) { return totalAllocatedReward - initialAllocatedReward; }\r\n    \r\n    event Deposit(address indexed from, uint128 balance, uint64 until, uint64 reward);\r\n    \r\n    mapping(address => StakeState) private _states;\r\n    \r\n    \r\n    // note that depositedTokens must be in the same tokens as initialDepositedTokens\r\n    // (i.e. 6 decimals, 1000M tokens represent 1000 HGET worth of liquidity)\r\n    function calculateReward (uint128 depositedTokens) internal view returns (uint256) {\r\n        // calculate amount of bought reward tokens (i.e. reward for deposit) using Bancor formula\r\n        // Exact formula: boughtTokens = tokenSupply * ( (1 + x) ^ F - 1)\r\n        //    where F is reserve ratio\r\n        //      and x = depositedTokens/totalDepositedTokens\r\n        // We have an approximation which is precise for 0 <= x <= 1.\r\n        // So to handle values above totalDepositedTokens, we simulate\r\n        // multi-step buy process. totalDepositedTokens doubles on each iteration.\r\n        \r\n        uint256 tDepositedTokens = totalDepositedTokens;\r\n        uint256 tAllocatedReward = totalAllocatedReward;\r\n        uint256 remainingDeposit = depositedTokens;\r\n        uint256 totalBoughtTokens = 0;\r\n\r\n        while (remainingDeposit >= tDepositedTokens) {\r\n            // buy tDepositedTokens worth of tokens. in this case x = 1, thus we\r\n            // have formula boughtTokens = tokenSupply * ( 2^F - 1)\r\n            // 2^F - 1 = 0.741101126592248\r\n\r\n            uint256 boughtTokens = (741101126592248 * tAllocatedReward) / (1000000000000000);\r\n\r\n            totalBoughtTokens += boughtTokens;\r\n            tAllocatedReward += boughtTokens;\r\n            remainingDeposit -= tDepositedTokens;\r\n            tDepositedTokens += tDepositedTokens;\r\n        }\r\n        if (remainingDeposit > 0) {\r\n            // third degree polynomial which approximates the exact value\r\n            // obtained using Lagrange interpolation\r\n            // boughtTokens = TS*(0.017042*(x/ER)^3 - 0.075513*(x/ER)^2 + 0.799572*(x/ER))\r\n            // (TS = tAllocatedReward, ER=tDepositedTokens)\r\n            // coefficients are truncated to millionths\r\n\r\n            // we assume that tAllocatedReward, remainingDeposit and tDepositedTokens do not exceed 80 bits, thus\r\n            // we can multiply three of them within int256 without getting overflow\r\n            int256 rd = int256(remainingDeposit);\r\n            int256 tDepositedTokensSquared = int256(tDepositedTokens*tDepositedTokens);\r\n            int256 temp1 = int256(tAllocatedReward) * rd;\r\n            int256 x1 = (799572 * temp1)/int256(tDepositedTokens);\r\n            int256 x2 = (75513 * temp1 * rd)/tDepositedTokensSquared;\r\n            int256 x3 = (((17042 * temp1 * rd)/tDepositedTokensSquared) * rd)/int256(tDepositedTokens);\r\n            int256 res = (x1 - x2 + x3)/1000000;\r\n            if (res > 0)  totalBoughtTokens += uint256(res);\r\n        }\r\n        return totalBoughtTokens;\r\n    }\r\n    \r\n    constructor () public {}\r\n\r\n    function getStakeState(address account) external view returns (uint256, uint64, uint64) {\r\n        StakeState storage ss = _states[account];\r\n        return (ss.balance, ss.lockedUntil, ss.reward);\r\n    }\r\n\r\n    function deposit(uint128 amount) public {\r\n        require(block.timestamp < depositDeadline, \"deposits no longer accepted\");\r\n        uint64 until = uint64(block.timestamp + lockTime);\r\n        \r\n        uint128 adjustedAmount = uint128((hgetPerLPToken * uint256(amount)) / (10 ** (18-6)));\r\n        uint64 reward = uint64(calculateReward(adjustedAmount)); \r\n        totalAllocatedReward += reward;\r\n        \r\n        require(totalAllocatedReward <= initialAllocatedReward + maxAllocatedReward, \"reward pool exhausted\");\r\n        \r\n        totalDepositedTokens += adjustedAmount;\r\n        \r\n        StakeState storage ss = _states[msg.sender];\r\n        ss.balance += amount;\r\n        ss.reward += reward;\r\n        ss.lockedUntil = until;\r\n        \r\n        emit Deposit(msg.sender, amount, until, reward);\r\n        require(depositToken.transferFrom(msg.sender, address(this), amount), \"transfer unsuccessful\");\r\n    }\r\n\r\n    function withdraw(address to) external {\r\n        StakeState storage ss = _states[msg.sender];\r\n        require(ss.lockedUntil < block.timestamp, \"still locked\");\r\n        require(ss.balance > 0, \"must have tokens to withdraw\");\r\n        uint128 balance = ss.balance;\r\n        uint64 reward = ss.reward;\r\n        ss.balance = 0;\r\n        ss.lockedUntil = 0;\r\n        ss.reward = 0;\r\n\r\n        require(depositToken.transfer(to, balance), \"transfer unsuccessful\");\r\n        require(rewardToken1.transfer(to, reward), \"transfer unsuccessful\");\r\n        require(rewardToken2.transfer(to, reward * chrPerHGET), \"transfer unsuccessful\");\r\n    }\r\n    \r\n    \r\n    function dispose(IERC20 token) external {\r\n        require(msg.sender == 0xEBdDe0641202ea77Af5edaA105ae6A6c006C6551);\r\n        require(block.timestamp >= depositDeadline + lockTime + 4 weeks);\r\n        require(token != depositToken);\r\n        token.transfer(0xEBdDe0641202ea77Af5edaA105ae6A6c006C6551, token.balanceOf(address(this)));\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"until\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"reward\",\"type\":\"uint64\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"dispose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStakeState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumAllocatedReward\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumDepositedTokens\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBonusDeposits\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LPStaker","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fe4f954810ee5ac0809f2a62b49ff831ce77354be5e4ee6c0b0d16456800f742"}]}