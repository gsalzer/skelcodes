/*
                              ▓▓█
                            ▒██▒▒█ 
                           █▓▓▓░▒▓▓     
                         ▒█▓▒█░▒▒▒█     
                        ▒█▒▒▒█▒▒▒▒▓▒    
 ▓▓▒░                  ▓█▒▒▒▓██▓▒░▒█    
 █▓▓██▓░              ▓█▒▒▒▒████▒▒▒█    
 ▓█▓▒▒▓██▓░          ▒█▒▒▒▒▒██▓█▓░░▓▒   
 ▓▒▓▒▒▒▒▒▓█▓░  ░▒▒▓▓██▒▒▒▒▒▒█████▒▒▒▓   
 ▓░█▒▒▒▒▒▒▒▓▓█▓█▓▓▓▓▒▒▒▒▒▒▒▒██▓██▒░▒█   
 ▓░▓█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓████▒▒▒█   
 ▓░▓██▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▓██░░░█   
 ▓░▓███▒▒▒▒▒▒▒▒▒▒▒▓█▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▒▓▓  
 ▒▒▒██▓▒▓█▓▒▒▒▒▒▒▒▓▒▒▒▒▒▒▓▓▓▒▒▒▒▒▒▒▓▒█  
  ▓▒█▓▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒▓█▓▓▓▓█▓▒▒▒▒▒▒▒▓▒ 
  ▓▒█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓      ▓█▓▒▒▒▒▒▓█ 
  ▒▒▓▒▒▒▓▓▓▒▒▒▒▒▒▒▒▒▓▓   ░▓▓   █▓▒▒▒▒▒█ 
   █▒▒▓▓▓▒▒▓▓▒▒▒▒▒▒▓▓   █████▓  █▓▒▒▒▒▓▒
   ▓▓█▒     ▒▓▒▒▒▒▒█   ░██████  ░█▒▒▒▒▓▓
   ▓█▒  ▒███ ▒▓▒▒▒▒█    ██████   ▓▒▒▒▒▒▓
   ██   █████ █▒▒▒▒█     ███▓    ▓▓▒▒▒▒▓
   █▓   █████ ▒▓▒▒▒█             █▓▓▓▒▒▓
   █▓   ░███  ░▓▒▒▒▓█          ░█▓▒▒▒▓▒▓
   ██         ▒▓▒▒▒▒▓▓      ░▒▓█▓    ░▓▓
   ▓█░        █▓██▓▒▒▓█▓▓▓▓██▓▓▒▓▒░░▒▓▒▓
   ▒██░      ▓▒███▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▓▓▓▓▒▓ 
    █▓█▓▓▒▒▓█▓▒░██▒▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓█▒
    ▓ ░▓▓▓▓▓▒▓▓▓▓▒▓▓▓▒▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓
    ▒▒▒▓▒▒▒▒▒▒▓█░ ░░░ ▓▓▒▒▒▒▒▒▒▒▒▒▒▓██▓▒
     █▓▒▒▒▒▒▒▒▒▓▓ ░░░ ▓▓▒▒▒▒▒▒▒▒▒▓▓▓▒▒▓▒
      ██▓▓▒▒▒▒▒▒█▒░░░░█▒▒▒▒▒▒▒▒▓█▓▓▒▒▒▒▒
       ▒██▓▓▒▒▒▒▒█▓▒▒▓▒▒▒▒▒▒▓███▓▒▒▒▒▒▓▓
          ░▒▓▓▓▓▒▒▓▓▓▓▓▓████▓▓█▒▒▒▒▒▓▓█░
████████████████████████████████████████████████████████████████████████
█▄─▄▄─█▄─██─▄█▄─▄▄▀█▄─▄▄▀█▄─▀█▄─▄█▄─▄▄─█▄─▄███─▄▄─█▄─▄▄─█▄─▄▄─█─▄▄▄▄████
██─▄▄▄██─██─███─▄─▄██─▄─▄██─█▄▀─███─▄█▀██─██▀█─██─██─▄▄▄██─▄█▀█▄▄▄▄─████
█▄▄▄████▄▄▄▄██▄▄█▄▄█▄▄█▄▄█▄▄▄██▄▄█▄▄▄▄▄█▄▄▄▄▄█▄▄▄▄█▄▄▄███▄▄▄▄▄█▄▄▄▄▄████
████████████████████████████████████████████████████████████████████████
█─▄▄▄─█─▄▄─█▄─██─▄█▄─▀█▄─▄█─▄─▄─█▄─▄▄▀█▄─█─▄███─▄▄▄─█▄─▄███▄─██─▄█▄─▄─▀█
█─███▀█─██─██─██─███─█▄▀─████─████─▄─▄██▄─▄████─███▀██─██▀██─██─███─▄─▀█
█▄▄▄▄▄█▄▄▄▄██▄▄▄▄██▄▄▄██▄▄██▄▄▄██▄▄█▄▄██▄▄▄████▄▄▄▄▄█▄▄▄▄▄██▄▄▄▄██▄▄▄▄██*/

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface Iminter {
    function mint(address recipient, uint256 quantity) external;   
}

contract PurrnelopesKittens is ERC721, Ownable, ERC721Enumerable, Iminter, ReentrancyGuard {
    using Counters for Counters.Counter;
    using SafeMath for uint256;
    using Strings for uint256;

    Counters.Counter private CurrentTokenId;
    address public AllowedAddress = 0xDa7D42B6167f1497346D7B2336a6D7A603026Db1;
    uint256 public MaxMintCount = 50;
    uint256 public MaxSupplyCount = 10000;
    string public BaseURI;
    uint256[10000] private Ids;
    IERC20 public FractionsContract;
    address public BurnAddress = 0x000000000000000000000000000000000000dEaD;
    string public BurnUri;
    bool public RedeemOpen = false;
    uint256 public FractionsPerNFT;
    uint256 public UnitPrice = 0.1 ether;
    bool public PublicMintingOpen = false;

    constructor() ERC721("Purrnelopes Kittens", "PK"){
        devMint(20, 0x112E62d5906F9239D9fabAb7D0237A328F128e22);
    }

    function updateMaxMintCount(uint256 _maxMintCount) public onlyOwner{
        MaxMintCount = _maxMintCount;
    }

    function updateBurnUri(string memory _uri) public onlyOwner{
        BurnUri = _uri;
    }

    function updateUnitPrice(uint256 _unitPrice) public onlyOwner{
        UnitPrice = _unitPrice;
    }

    function togglePublicMinting() public onlyOwner{
        PublicMintingOpen = !PublicMintingOpen;
    }

    function updateAllowedAddress(address _allowedAddress) public onlyOwner{
        AllowedAddress = _allowedAddress;
    }

    function updateFractionsContract(IERC20 _fractionsContract) public onlyOwner{
        FractionsContract = _fractionsContract;
    }

    function toggleRedeemOpen() public onlyOwner{
        RedeemOpen = !RedeemOpen;
    }

    function updateFractionsPerNFT(uint256 _fractions) public onlyOwner{
        FractionsPerNFT = _fractions;
    }

    function devMint(uint256 _quantity, address _to) private {
        
        uint256 remaining = MaxSupplyCount - CurrentTokenId.current();
        for(uint256 i; i < _quantity; i++){
            CurrentTokenId.increment();              
            remaining--;                    
            _safeMint(_to, CurrentTokenId.current());               
            Ids[i] = Ids[remaining] == 0 ? remaining : Ids[remaining];
         
        }
    }

    function mintKittens(uint256 _quantity) payable public nonReentrant {
        require(msg.value == _quantity.mul(UnitPrice), "Incorrect ETH amount");
        require(PublicMintingOpen, "Public minting is not currently open");

        internalMint(msg.sender, _quantity);
    }

    function mint(address _to, uint256 _quantity) override public {
        require(msg.sender == AllowedAddress || msg.sender == owner(), "Not allowed minting address");
        internalMint(_to, _quantity);
    }

    function internalMint(address _to, uint256 _quantity) private {
        require(_quantity <= MaxMintCount && _quantity > 0, "Incorrect mint quantity");
        require(_quantity.add(CurrentTokenId.current()) <= MaxSupplyCount, "Cannot exceed max supply");
        
        uint256 remaining = MaxSupplyCount - CurrentTokenId.current();
        
        for(uint256 i; i < _quantity; i++){
            
            remaining--;                    
            uint256 tokenId = CurrentTokenId.current();
            uint256 index = getRandomNumber(remaining, i * tokenId);

            _safeMint(_to, ((Ids[index] == 0) ? index : Ids[index]) + 1);
                 
            Ids[index] = Ids[remaining] == 0 ? remaining : Ids[remaining];
            CurrentTokenId.increment();            
        }
    }

    function redeemKittyBankFractions(uint256[] calldata ids) public {
        require(RedeemOpen, "ERC-20 redeem is not currently open");
        require(FractionsPerNFT > 0, "Fractions per NFT currently not set");
        uint256 amount = FractionsPerNFT.mul(ids.length);
        require(FractionsContract.balanceOf(address(this)) >= amount, "Not enough balance of tokens to redeem");

        for(uint256 i; i < ids.length; i++){
            //we don't need to check the owner of the tokens because this is checked in transferFrom method
            this.transferFrom(msg.sender, BurnAddress, ids[i]);
        }

        FractionsContract.transfer(msg.sender, amount);
    }

    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {     
        return (operator == address(this)) || super.isApprovedForAll(account, operator);   
    }

	function withdrawTokens(IERC20 token) public onlyOwner {
    	require(address(token) != address(0));
    	uint256 balance = token.balanceOf(address(this));
    	token.transfer(msg.sender, balance);
	}
	
	function withdraw() public onlyOwner {
		uint256 balance = address(this).balance;
		payable(msg.sender).transfer(balance);
	}

    function _baseURI() internal view override returns(string memory) {
        return BaseURI;
    }
    function setBaseURI(string calldata _uri) public onlyOwner{
        BaseURI = _uri;
    }

    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(_exists(_tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory baseURI = _baseURI();
        string memory uri = bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, _tokenId.toString())) : "";
        return (ownerOf(_tokenId) == BurnAddress) ? BurnUri : uri;
    }

    //"random" number.... using chainlink for VRF seems overkill
    function getRandomNumber(uint256 maxValue, uint256 salt) private view returns(uint256) {
        if (maxValue == 0)
            return 0;
            
        uint256 seed =
			uint256(
				keccak256(
					abi.encodePacked(
							block.difficulty +	
							((uint256(keccak256(abi.encodePacked(tx.origin, msg.sig)))) / (block.timestamp)) +
							block.number +
							salt
					)
				)
			);
		return seed.mod(maxValue);
    }

function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {
    return super.supportsInterface(interfaceId);
}
}
