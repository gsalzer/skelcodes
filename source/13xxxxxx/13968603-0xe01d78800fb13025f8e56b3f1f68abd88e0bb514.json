{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DoomsdayViewer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: A hedgehog wrote this contract\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./Doomsday.sol\\\";\\r\\n\\r\\ncontract DoomsdayViewer{\\r\\n\\r\\n    Doomsday doomsday;\\r\\n\\r\\n    uint constant IMPACT_BLOCK_INTERVAL = 120;\\r\\n\\r\\n    constructor(address _doomsday){\\r\\n        doomsday = Doomsday(_doomsday);\\r\\n    }\\r\\n\\r\\n    function isEarlyAccess() public view returns(bool){\\r\\n        return doomsday.stage() == Doomsday.Stage.PreApocalypse && block.timestamp < doomsday.startTime() + 1 days;\\r\\n    }\\r\\n\\r\\n    function nextImpactIn() public view returns(uint){\\r\\n        uint nextEliminationBlock = block.number - (block.number % IMPACT_BLOCK_INTERVAL) - 5 + IMPACT_BLOCK_INTERVAL;\\r\\n        return nextEliminationBlock - block.number;\\r\\n    }\\r\\n\\r\\n\\r\\n    function contractState() public view returns(\\r\\n            uint totalSupply,\\r\\n            uint destroyed,\\r\\n            uint evacuatedFunds,\\r\\n            Doomsday.Stage stage,\\r\\n            uint currentPrize,\\r\\n            bool _isEarlyAccess,\\r\\n            uint countdown,\\r\\n            uint _nextImpactIn,\\r\\n            uint blockNumber\\r\\n    ){\\r\\n        stage = doomsday.stage();\\r\\n\\r\\n        _isEarlyAccess = isEarlyAccess();\\r\\n\\r\\n        if(_isEarlyAccess){\\r\\n            countdown = doomsday.startTime() + 1 days - block.timestamp;\\r\\n        }else if(stage == Doomsday.Stage.PreApocalypse){\\r\\n            countdown = doomsday.startTime() + 7 days - block.timestamp;\\r\\n        }\\r\\n\\r\\n        return (\\r\\n            doomsday.totalSupply(),\\r\\n            doomsday.destroyed(),\\r\\n            doomsday.evacuatedFunds(),\\r\\n            stage,\\r\\n            doomsday.currentPrize(),\\r\\n            _isEarlyAccess,\\r\\n            countdown,\\r\\n            nextImpactIn(),\\r\\n            block.number\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function vulnerableCities(uint startId, uint limit)  public view returns(uint[] memory){\\r\\n        uint _totalSupply = doomsday.totalSupply();\\r\\n        uint _maxId = _totalSupply + doomsday.destroyed();\\r\\n        if(_totalSupply == 0){\\r\\n            uint[] memory _none;\\r\\n            return _none;\\r\\n        }\\r\\n        require(startId < _maxId + 1,\\\"Invalid start ID\\\");\\r\\n        uint sampleSize = _maxId - startId;\\r\\n\\r\\n        if(limit != 0 && sampleSize > limit){\\r\\n            sampleSize = limit;\\r\\n        }\\r\\n        uint[] memory _tokenIds = new uint256[](sampleSize);\\r\\n        uint _tokenId = startId;\\r\\n        for(uint i = 0; i < sampleSize; i++){\\r\\n            try doomsday.ownerOf(_tokenId) returns (address _owner) {\\r\\n                _owner;\\r\\n                try doomsday.isVulnerable(_tokenId) returns (bool _isVulnerable) {\\r\\n                    if(_isVulnerable){\\r\\n                        _tokenIds[i] = _tokenId;\\r\\n                    }\\r\\n                } catch {\\r\\n\\r\\n                }\\r\\n            } catch {\\r\\n\\r\\n            }\\r\\n            _tokenId++;\\r\\n        }\\r\\n        return _tokenIds;\\r\\n    }\\r\\n\\r\\n    function cityData(uint startId, uint limit) public view returns(uint[] memory _tokenIds, uint[] memory _cityIds, uint[] memory _reinforcement, uint[] memory _damage, uint blockNumber ){\\r\\n        uint _totalSupply = doomsday.totalSupply();\\r\\n        uint _maxId = _totalSupply + doomsday.destroyed();\\r\\n        if(_totalSupply == 0){\\r\\n            uint[] memory _none;\\r\\n            return (_none,_none,_none,_none, block.number);\\r\\n        }\\r\\n        require(startId < _maxId + 1,\\\"Invalid start ID\\\");\\r\\n        uint sampleSize = _maxId - startId + 1;\\r\\n\\r\\n        if(limit != 0 && sampleSize > limit){\\r\\n            sampleSize = limit;\\r\\n        }\\r\\n\\r\\n        _tokenIds     = new uint256[](sampleSize);\\r\\n        _cityIds      = new uint256[](sampleSize);\\r\\n        _reinforcement = new uint256[](sampleSize);\\r\\n        _damage        = new uint256[](sampleSize);\\r\\n\\r\\n\\r\\n        uint _tokenId = startId;\\r\\n        uint8 reinforcement; uint8 damage; bytes32 lastImpact;\\r\\n\\r\\n        for(uint i = 0; i < sampleSize; i++){\\r\\n            try doomsday.ownerOf(_tokenId) returns (address owner) {\\r\\n                owner;\\r\\n                _tokenIds[i] = _tokenId;\\r\\n\\r\\n                (reinforcement, damage, lastImpact) = doomsday.getStructuralData(_tokenId);\\r\\n\\r\\n                _cityIds[i]         = doomsday.tokenToCity(_tokenId);\\r\\n                _reinforcement[i]    = reinforcement;\\r\\n                _damage[i]           = damage;\\r\\n\\r\\n            } catch {\\r\\n\\r\\n            }\\r\\n            _tokenId++;\\r\\n        }\\r\\n        return (_tokenIds, _cityIds, _reinforcement, _damage, block.number);\\r\\n    }\\r\\n\\r\\n    function cities(uint startId, uint limit)  public view returns(uint[] memory){\\r\\n        uint _totalSupply = doomsday.totalSupply();\\r\\n        uint _maxId = _totalSupply + doomsday.destroyed();\\r\\n        if(_totalSupply == 0){\\r\\n            uint[] memory _none;\\r\\n            return _none;\\r\\n        }\\r\\n        require(startId < _maxId + 1,\\\"Invalid start ID\\\");\\r\\n        uint sampleSize = _maxId - startId + 1;\\r\\n\\r\\n        if(limit != 0 && sampleSize > limit){\\r\\n            sampleSize = limit;\\r\\n        }\\r\\n        uint[] memory _tokenIds = new uint256[](sampleSize);\\r\\n        uint _tokenId = startId;\\r\\n        for(uint i = 0; i < sampleSize; i++){\\r\\n            try doomsday.ownerOf(_tokenId) returns (address owner) {\\r\\n                owner;\\r\\n                _tokenIds[i] = _tokenId;\\r\\n            } catch {\\r\\n\\r\\n            }\\r\\n            _tokenId++;\\r\\n        }\\r\\n        return _tokenIds;\\r\\n    }\\r\\n\\r\\n    function bunker(uint16 _cityId) public view returns(uint _tokenId, address _owner, uint8 _reinforcement, uint8 _damage, bool _isVulnerable, bool _isUninhabited){\\r\\n        _tokenId = doomsday.cityToToken(_cityId);\\r\\n        _isUninhabited = doomsday.isUninhabited(_cityId);\\r\\n\\r\\n        if(_tokenId == 0){\\r\\n            return (0,address(0),uint8(0),uint8(0),false,_isUninhabited);\\r\\n        }else{\\r\\n            try doomsday.ownerOf(_tokenId) returns ( address __owner) {\\r\\n                _owner = __owner;\\r\\n            } catch {\\r\\n\\r\\n            }\\r\\n            bytes32 _lastImpact;\\r\\n            (_reinforcement, _damage, _lastImpact) = doomsday.getStructuralData(_tokenId);\\r\\n            _isVulnerable = doomsday.isVulnerable(_tokenId);\\r\\n\\r\\n            return (_tokenId,_owner,_reinforcement, _damage,_isVulnerable,false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function myCities(uint startId, uint limit)  public view returns(uint[] memory){\\r\\n        uint _totalSupply = doomsday.totalSupply();\\r\\n        uint _myBalance = doomsday.balanceOf(msg.sender);\\r\\n        uint _maxId = _totalSupply + doomsday.destroyed();\\r\\n        if(_totalSupply == 0 || _myBalance == 0){\\r\\n            uint[] memory _none;\\r\\n            return _none;\\r\\n        }\\r\\n        require(startId < _maxId + 1,\\\"Invalid start ID\\\");\\r\\n        uint sampleSize = _maxId - startId + 1;\\r\\n\\r\\n        if(limit != 0 && sampleSize > limit){\\r\\n            sampleSize = limit;\\r\\n        }\\r\\n\\r\\n        uint[] memory _tokenIds = new uint256[](sampleSize);\\r\\n\\r\\n        uint _tokenId = startId;\\r\\n        uint found = 0;\\r\\n        for(uint i = 0; i < sampleSize; i++){\\r\\n            try doomsday.ownerOf(_tokenId) returns (address owner) {\\r\\n                if(msg.sender == owner){\\r\\n                    _tokenIds[found++] = _tokenId;\\r\\n                }\\r\\n            } catch {\\r\\n\\r\\n            }\\r\\n            _tokenId++;\\r\\n        }\\r\\n        return _tokenIds;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// Like the food not the animal\"\r\n    },\r\n    \"contracts/Doomsday.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Cool kids only\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\nimport \\\"./interfaces/IERC165.sol\\\";\\r\\nimport \\\"./interfaces/IERC721.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Metadata.sol\\\";\\r\\nimport \\\"./interfaces/IERC721TokenReceiver.sol\\\";\\r\\n\\r\\ncontract Doomsday is IERC721, IERC165, IERC721Metadata{\\r\\n\\r\\n\\r\\n    constructor(bytes32 _cityRoot, address _earlyAccessHolders){\\r\\n        supportedInterfaces[0x80ac58cd] = true; //ERC721\\r\\n        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\\r\\n        //        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable\\r\\n        supportedInterfaces[0x01ffc9a7] = true; //ERC165\\r\\n\\r\\n        owner = msg.sender;\\r\\n        cityRoot = _cityRoot;\\r\\n\\r\\n        earlyAccessHolders = _earlyAccessHolders;\\r\\n    }\\r\\n\\r\\n    address public owner;\\r\\n    address earlyAccessHolders;\\r\\n\\r\\n    //////===721 Implementation\\r\\n    mapping(address => uint256) internal balances;\\r\\n    mapping (uint256 => address) internal allowance;\\r\\n    mapping (address => mapping (address => bool)) internal authorised;\\r\\n\\r\\n    uint16[] tokenIndexToCity;  //Array of all tokens [cityId,cityId,...]\\r\\n    mapping(uint256 => address) owners;  //Mapping of owners\\r\\n    //  keep owners mapping\\r\\n    //  use tokenIndexToCity for isValidToken\\r\\n\\r\\n    //    METADATA VARS\\r\\n    string private __name = \\\"Doomsday NFT\\\";\\r\\n    string private __symbol = \\\"BUNKER\\\";\\r\\n    bytes private __uriBase = bytes(\\\"https://gateway.pinata.cloud/ipfs/QmUwPH9PmTQrT67M633AJRXACsecmRTihf4DUbJZb9y83M/\\\");\\r\\n    bytes private __uriSuffix = bytes(\\\".json\\\");\\r\\n\\r\\n    //  Game vars\\r\\n    uint constant MAX_CITIES = 38611;       //from table\\r\\n\\r\\n    int64 constant MAP_WIDTH         = 4320000;   //map units\\r\\n    int64 constant MAP_HEIGHT        = 2588795;   //map units\\r\\n    int64 constant BASE_BLAST_RADIUS = 100000;   //map units\\r\\n\\r\\n    uint constant MINT_COST = 0.04 ether;\\r\\n\\r\\n    uint constant MINT_PERCENT_WINNER       = 50;\\r\\n    uint constant MINT_PERCENT_CALLER       = 25;\\r\\n    uint constant MINT_PERCENT_CREATOR      = 25;\\r\\n\\r\\n    uint constant REINFORCE_PERCENT_WINNER  = 90;\\r\\n    uint constant REINFORCE_PERCENT_CREATOR = 10;\\r\\n\\r\\n\\r\\n    uint constant IMPACT_BLOCK_INTERVAL = 120;\\r\\n\\r\\n    mapping(uint16 => uint) public cityToToken;\\r\\n    mapping(uint16 => int64[2]) coordinates;\\r\\n    bytes32 cityRoot;\\r\\n\\r\\n    event Inhabit(uint16 indexed _cityId, uint256 indexed _tokenId);\\r\\n    event Reinforce(uint256 indexed _tokenId);\\r\\n    event Impact(uint256 indexed _tokenId);\\r\\n\\r\\n    mapping(uint => bytes32) structuralData;\\r\\n\\r\\n    function getStructuralData(uint _tokenId) public view returns (uint8 reinforcement, uint8 damage, bytes32 lastImpact){\\r\\n        bytes32 _data = structuralData[_tokenId];\\r\\n\\r\\n        reinforcement = uint8(uint(((_data << 248) >> 248)));\\r\\n        damage = uint8(uint(((_data << 240) >> 240) >> 8));\\r\\n        lastImpact = (_data >> 16);\\r\\n\\r\\n        return (reinforcement, damage, lastImpact);\\r\\n    }\\r\\n    function setStructuralData(uint _tokenId, uint8 reinforcement, uint8 damage, bytes32 lastImpact) internal{\\r\\n        bytes32 _reinforcement = bytes32(uint(reinforcement));\\r\\n        bytes32 _damage = bytes32(uint(damage)) << 8;\\r\\n        bytes32 _lastImpact = encodeImpact(lastImpact) << 16;\\r\\n\\r\\n        structuralData[_tokenId] = _reinforcement ^ _damage ^ _lastImpact;\\r\\n    }\\r\\n    function encodeImpact(bytes32 _impact) internal pure returns(bytes32){\\r\\n        return (_impact << 16) >> 16;\\r\\n    }\\r\\n\\r\\n\\r\\n    uint public reinforcements;\\r\\n    uint public destroyed;\\r\\n    uint public evacuatedFunds;\\r\\n\\r\\n    uint ownerWithdrawn;\\r\\n    bool winnerWithdrawn;\\r\\n\\r\\n    function tokenToCity(uint _tokenId) public view returns(uint16){\\r\\n        return tokenIndexToCity[_tokenId - 1];\\r\\n    }\\r\\n\\r\\n    uint public startTime;\\r\\n    uint SALE_TIME = 7 days;\\r\\n    uint EARLY_ACCESS_TIME = 1 days;\\r\\n\\r\\n    function startPreApocalypse() public{\\r\\n        require(msg.sender == owner,\\\"owner\\\");\\r\\n\\r\\n        require(startTime == 0,\\\"started\\\");\\r\\n        startTime = block.timestamp;\\r\\n    }\\r\\n    enum Stage {Initial,PreApocalypse,Apocalypse,PostApocalypse}\\r\\n    function stage() public view returns(Stage){\\r\\n        if(startTime == 0){\\r\\n            return Stage.Initial;\\r\\n        }else if(block.timestamp < startTime + SALE_TIME && tokenIndexToCity.length < MAX_CITIES){\\r\\n            return Stage.PreApocalypse;\\r\\n        }else if(destroyed < tokenIndexToCity.length - 1){\\r\\n            return Stage.Apocalypse;\\r\\n        }else{\\r\\n            return Stage.PostApocalypse;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function inhabit(uint16 _cityId, int64[2] calldata _coordinates, bytes32[] memory proof) public payable{\\r\\n        require(stage() == Stage.PreApocalypse,\\\"stage\\\");\\r\\n        if(block.timestamp < startTime + EARLY_ACCESS_TIME){\\r\\n            //First day is insiders list\\r\\n            require(IERC721(earlyAccessHolders).balanceOf(msg.sender) > 0,\\\"early\\\");\\r\\n        }\\r\\n\\r\\n\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(_cityId,_coordinates[0],_coordinates[1]));\\r\\n\\r\\n        require(MerkleProof.verify(proof, cityRoot, leaf),\\\"proof\\\");\\r\\n\\r\\n        require(cityToToken[_cityId] == 0 && coordinates[_cityId][0] == 0 && coordinates[_cityId][1] == 0,\\\"inhabited\\\");\\r\\n\\r\\n        require(\\r\\n            _coordinates[0] >= -MAP_WIDTH/2 &&\\r\\n            _coordinates[0] <= MAP_WIDTH/2 &&\\r\\n\\r\\n            _coordinates[1] >= -MAP_HEIGHT/2 &&\\r\\n            _coordinates[1] <= MAP_HEIGHT/2,\\r\\n            \\\"off map\\\"\\r\\n        );  //Not strictly necessary but proves the whitelist hasnt been fucked with\\r\\n\\r\\n\\r\\n        require(msg.value == MINT_COST,\\\"cost\\\");\\r\\n\\r\\n        coordinates[_cityId] = _coordinates;\\r\\n\\r\\n        tokenIndexToCity.push(_cityId);\\r\\n\\r\\n        uint _tokenId = tokenIndexToCity.length;\\r\\n\\r\\n        balances[msg.sender]++;\\r\\n        owners[_tokenId] = msg.sender;\\r\\n        cityToToken[_cityId] = _tokenId;\\r\\n\\r\\n        emit Inhabit(_cityId, _tokenId);\\r\\n        emit Transfer(address(0),msg.sender,_tokenId);\\r\\n    }\\r\\n\\r\\n    function isUninhabited(uint16 _cityId) public view returns(bool){\\r\\n        return coordinates[_cityId][0] == 0 && coordinates[_cityId][1] == 0;\\r\\n    }\\r\\n\\r\\n    function reinforce(uint _tokenId) public payable{\\r\\n\\r\\n        Stage _stage = stage();\\r\\n\\r\\n        require(_stage == Stage.PreApocalypse || _stage == Stage.Apocalypse,\\\"stage\\\");\\r\\n\\r\\n        require(ownerOf(_tokenId) == msg.sender,\\\"owner\\\");\\r\\n\\r\\n        //Covered by ownerOf\\r\\n//        require(isValidToken(_tokenId),\\\"invalid\\\");\\r\\n\\r\\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\\r\\n\\r\\n        if(_stage == Stage.Apocalypse){\\r\\n            require(!checkVulnerable(_tokenId,_lastImpact),\\\"vulnerable\\\");\\r\\n        }\\r\\n\\r\\n        //   covered by isValidToken\\r\\n            //require(_damage <= _reinforcement,\\\"eliminated\\\" );\\r\\n\\r\\n        require(msg.value == (2 ** _reinforcement) *  MINT_COST,\\\"cost\\\");\\r\\n\\r\\n\\r\\n        setStructuralData(_tokenId,_reinforcement+1,_damage,_lastImpact);\\r\\n\\r\\n        reinforcements += msg.value - (MINT_COST * MINT_PERCENT_CALLER / 100);\\r\\n\\r\\n        emit Reinforce(_tokenId);\\r\\n    }\\r\\n    function evacuate(uint _tokenId) public{\\r\\n        Stage _stage = stage();\\r\\n        require(_stage == Stage.PreApocalypse || _stage == Stage.Apocalypse,\\\"stage\\\");\\r\\n\\r\\n        require(ownerOf(_tokenId) == msg.sender,\\\"owner\\\");\\r\\n\\r\\n        // covered by isValidToken in ownerOf\\r\\n//        require(_damage <= _reinforcement,\\\"eliminated\\\" );\\r\\n\\r\\n        if(_stage == Stage.Apocalypse){\\r\\n            require(!isVulnerable(_tokenId),\\\"vulnerable\\\");\\r\\n        }\\r\\n\\r\\n        uint cityCount = tokenIndexToCity.length;\\r\\n\\r\\n\\r\\n        uint fromPool =\\r\\n            //Winner fee from mints less evacuated funds\\r\\n                ((MINT_COST * cityCount * MINT_PERCENT_WINNER / 100 - evacuatedFunds)\\r\\n            //Divided by remaining tokens\\r\\n                / totalSupply())\\r\\n            //Divided by two\\r\\n               / 2;\\r\\n\\r\\n\\r\\n        //Also give them the admin fee\\r\\n        uint toWithdraw = fromPool + getEvacuationRebate(_tokenId);\\r\\n\\r\\n        balances[owners[_tokenId]]--;\\r\\n        delete cityToToken[tokenToCity(_tokenId)];\\r\\n        destroyed++;\\r\\n\\r\\n        //Doesnt' include admin fees in evacedFunds\\r\\n        evacuatedFunds += fromPool;\\r\\n\\r\\n        emit Transfer(owners[_tokenId],address(0),_tokenId);\\r\\n\\r\\n\\r\\n        payable(msg.sender).send(\\r\\n            toWithdraw\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n    function getEvacuationRebate(uint _tokenId) public view returns(uint) {\\r\\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\\r\\n        _lastImpact;\\r\\n        return MINT_COST * (1 + _reinforcement - _damage) *  MINT_PERCENT_CALLER / 100;\\r\\n    }\\r\\n\\r\\n    function confirmHit(uint _tokenId) public{\\r\\n        require(stage() == Stage.Apocalypse,\\\"stage\\\");\\r\\n        require(isValidToken(_tokenId),\\\"invalid\\\");\\r\\n\\r\\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\\r\\n\\r\\n        //  covered by isValidToken\\r\\n        //      require(_damage <= _reinforcement,\\\"eliminated\\\" );\\r\\n\\r\\n        require(checkVulnerable(_tokenId,_lastImpact),\\\"vulnerable\\\");\\r\\n\\r\\n        (int64[2] memory _coordinates, int64 _radius, bytes32 _impactId) = currentImpact();\\r\\n        _coordinates;_radius;\\r\\n\\r\\n        _impactId = encodeImpact(_impactId);\\r\\n\\r\\n        emit Impact(_tokenId);\\r\\n\\r\\n\\r\\n        if(_damage < _reinforcement){\\r\\n            _damage++;\\r\\n            setStructuralData(_tokenId,_reinforcement,_damage,_impactId);\\r\\n        }else{\\r\\n            balances[owners[_tokenId]]--;\\r\\n            delete cityToToken[tokenToCity(_tokenId)];\\r\\n            destroyed++;\\r\\n\\r\\n            emit Transfer(owners[_tokenId],address(0),_tokenId);\\r\\n        }\\r\\n\\r\\n        payable(msg.sender).send(MINT_COST * MINT_PERCENT_CALLER / 100);\\r\\n    }\\r\\n\\r\\n\\r\\n    function winnerWithdraw(uint _winnerTokenId) public{\\r\\n        require(stage() == Stage.PostApocalypse,\\\"stage\\\");\\r\\n        require(isValidToken(_winnerTokenId),\\\"invalid\\\");\\r\\n\\r\\n        // Implicitly makes sure its the right token since all others don't exist\\r\\n        require(msg.sender == ownerOf(_winnerTokenId),\\\"ownerOf\\\");\\r\\n        require(!winnerWithdrawn,\\\"withdrawn\\\");\\r\\n\\r\\n        winnerWithdrawn = true;\\r\\n\\r\\n        uint toWithdraw = winnerPrize(_winnerTokenId);\\r\\n        if(toWithdraw > address(this).balance){\\r\\n            //Catch rounding errors\\r\\n            toWithdraw = address(this).balance;\\r\\n        }\\r\\n\\r\\n        payable(msg.sender).send(toWithdraw);\\r\\n\\r\\n    }\\r\\n\\r\\n    function ownerWithdraw() public{\\r\\n        require(msg.sender == owner,\\\"owner\\\");\\r\\n\\r\\n        uint cityCount = tokenIndexToCity.length;\\r\\n\\r\\n        // Dev and creator portion of all mint fees collected\\r\\n        uint toWithdraw = MINT_COST * cityCount * (MINT_PERCENT_CREATOR) / 100\\r\\n            //plus reinforcement for creator\\r\\n            + reinforcements * REINFORCE_PERCENT_CREATOR / 100\\r\\n            //less what has already been withdrawn;\\r\\n            - ownerWithdrawn;\\r\\n\\r\\n        require(toWithdraw > 0,\\\"empty\\\");\\r\\n\\r\\n        if(toWithdraw > address(this).balance){\\r\\n            //Catch rounding errors\\r\\n            toWithdraw = address(this).balance;\\r\\n        }\\r\\n        ownerWithdrawn += toWithdraw;\\r\\n\\r\\n        payable(msg.sender).send(toWithdraw);\\r\\n    }\\r\\n\\r\\n\\r\\n    function currentImpact() public view returns (int64[2] memory _coordinates, int64 _radius, bytes32 impactId){\\r\\n        uint eliminationBlock = block.number - (block.number % IMPACT_BLOCK_INTERVAL) - 5;\\r\\n        int hash = int(uint(blockhash(eliminationBlock))%uint(type(int).max) );\\r\\n\\r\\n\\r\\n        //Min radius is half map height divided by num\\r\\n        int o = MAP_HEIGHT/2/int(totalSupply()+1);\\r\\n\\r\\n        //Limited in smallness to about 8% of map height\\r\\n        if(o < BASE_BLAST_RADIUS){\\r\\n            o = BASE_BLAST_RADIUS;\\r\\n        }\\r\\n        //Max radius is twice this\\r\\n        _coordinates[0] = int64(hash%MAP_WIDTH - MAP_WIDTH/2);\\r\\n        _coordinates[1] = int64((hash/MAP_WIDTH)%MAP_HEIGHT - MAP_HEIGHT/2);\\r\\n        _radius = int64((hash/MAP_WIDTH/MAP_HEIGHT)%o + o);\\r\\n\\r\\n        return(_coordinates,_radius, keccak256(abi.encodePacked(_coordinates,_radius)));\\r\\n    }\\r\\n\\r\\n    function checkVulnerable(uint _tokenId, bytes32 _lastImpact) internal view returns(bool){\\r\\n        (int64[2] memory _coordinates, int64 _radius, bytes32 _impactId) = currentImpact();\\r\\n\\r\\n        if(_lastImpact == encodeImpact(_impactId)) return false;\\r\\n\\r\\n        uint16 _cityId = tokenToCity(_tokenId);\\r\\n\\r\\n        int64 dx = coordinates[_cityId][0] - _coordinates[0];\\r\\n        int64 dy = coordinates[_cityId][1] - _coordinates[1];\\r\\n\\r\\n        return (dx**2 + dy**2 < _radius**2) ||\\r\\n        ((dx + MAP_WIDTH )**2 + dy**2 < _radius**2) ||\\r\\n        ((dx - MAP_WIDTH )**2 + dy**2 < _radius**2);\\r\\n    }\\r\\n\\r\\n    function isVulnerable(uint _tokenId) public  view returns(bool){\\r\\n\\r\\n        (uint8 _reinforcement, uint8 _damage, bytes32 _lastImpact) = getStructuralData(_tokenId);\\r\\n        _reinforcement;_damage;\\r\\n\\r\\n        return checkVulnerable(_tokenId,_lastImpact);\\r\\n    }\\r\\n\\r\\n\\r\\n    function getFallen(uint _tokenId) public view returns(uint16 _cityId, address _owner){\\r\\n        _cityId = tokenToCity(_tokenId);\\r\\n        _owner = owners[_tokenId];\\r\\n        require(cityToToken[_cityId] == 0 && _owner != address(0),\\\"survives\\\");\\r\\n        return (_cityId,owners[_tokenId]);\\r\\n    }\\r\\n\\r\\n    function currentPrize() public view returns(uint){\\r\\n        uint cityCount = tokenIndexToCity.length;\\r\\n            // 50% of all mint fees collected\\r\\n            return MINT_COST * cityCount * MINT_PERCENT_WINNER / 100\\r\\n            //minus fees removed\\r\\n            - evacuatedFunds\\r\\n            //plus reinforcement * 90%\\r\\n            + reinforcements * REINFORCE_PERCENT_WINNER / 100;\\r\\n    }\\r\\n\\r\\n    function winnerPrize(uint _tokenId) public view returns(uint){\\r\\n        return currentPrize() + getEvacuationRebate(_tokenId);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    ///ERC 721:\\r\\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\\r\\n        if(_tokenId == 0) return false;\\r\\n        return cityToToken[tokenToCity(_tokenId)] != 0;\\r\\n    }\\r\\n\\r\\n\\r\\n    function balanceOf(address _owner) external override view returns (uint256){\\r\\n        return balances[_owner];\\r\\n    }\\r\\n\\r\\n    function ownerOf(uint256 _tokenId) public override view returns(address){\\r\\n        require(isValidToken(_tokenId),\\\"invalid\\\");\\r\\n        return owners[_tokenId];\\r\\n    }\\r\\n\\r\\n\\r\\n    function approve(address _approved, uint256 _tokenId) external override {\\r\\n        address _owner = ownerOf(_tokenId);\\r\\n        require( _owner == msg.sender                    //Require Sender Owns Token\\r\\n            || authorised[_owner][msg.sender]                //  or is approved for all.\\r\\n        ,\\\"permission\\\");\\r\\n        emit Approval(_owner, _approved, _tokenId);\\r\\n        allowance[_tokenId] = _approved;\\r\\n    }\\r\\n\\r\\n    function getApproved(uint256 _tokenId) external override view returns (address) {\\r\\n        require(isValidToken(_tokenId),\\\"invalid\\\");\\r\\n        return allowance[_tokenId];\\r\\n    }\\r\\n\\r\\n    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {\\r\\n        return authorised[_owner][_operator];\\r\\n    }\\r\\n\\r\\n\\r\\n    function setApprovalForAll(address _operator, bool _approved) external override {\\r\\n        emit ApprovalForAll(msg.sender,_operator, _approved);\\r\\n        authorised[msg.sender][_operator] = _approved;\\r\\n    }\\r\\n\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) public override {\\r\\n\\r\\n        //Check Transferable\\r\\n        //There is a token validity check in ownerOf\\r\\n        address _owner = ownerOf(_tokenId);\\r\\n\\r\\n        require ( _owner == msg.sender             //Require sender owns token\\r\\n        //Doing the two below manually instead of referring to the external methods saves gas\\r\\n        || allowance[_tokenId] == msg.sender      //or is approved for this token\\r\\n            || authorised[_owner][msg.sender]          //or is approved for all\\r\\n        ,\\\"permission\\\");\\r\\n        require(_owner == _from,\\\"owner\\\");\\r\\n        require(_to != address(0),\\\"zero\\\");\\r\\n\\r\\n        require(!isVulnerable(_tokenId),\\\"vulnerable\\\");\\r\\n\\r\\n        emit Transfer(_from, _to, _tokenId);\\r\\n\\r\\n\\r\\n        owners[_tokenId] =_to;\\r\\n\\r\\n        balances[_from]--;\\r\\n        balances[_to]++;\\r\\n\\r\\n        //Reset approved if there is one\\r\\n        if(allowance[_tokenId] != address(0)){\\r\\n            delete allowance[_tokenId];\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public override {\\r\\n        transferFrom(_from, _to, _tokenId);\\r\\n\\r\\n        //Get size of \\\"_to\\\" address, if 0 it's a wallet\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_to)\\r\\n        }\\r\\n        if(size > 0){\\r\\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\\r\\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\")),\\\"receiver\\\");\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\\r\\n        safeTransferFrom(_from,_to,_tokenId,\\\"\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    // METADATA FUNCTIONS\\r\\n    function tokenURI(uint256 _tokenId) public override view returns (string memory){\\r\\n        //Note: changed visibility to public\\r\\n        require(isValidToken(_tokenId),'tokenId');\\r\\n\\r\\n        uint _cityId = tokenToCity(_tokenId);\\r\\n\\r\\n        uint _i = _cityId;\\r\\n        uint j = _i;\\r\\n        uint len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint k = len;\\r\\n        while (_i != 0) {\\r\\n            k = k-1;\\r\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\r\\n            bytes1 b1 = bytes1(temp);\\r\\n            bstr[k] = b1;\\r\\n            _i /= 10;\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        return string(abi.encodePacked(__uriBase,bstr,__uriSuffix));\\r\\n\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function name() external override view returns (string memory _name){\\r\\n        return __name;\\r\\n    }\\r\\n\\r\\n    function symbol() external override view returns (string memory _symbol){\\r\\n        return __symbol;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ENUMERABLE FUNCTIONS\\r\\n    function totalSupply() public view returns (uint256){\\r\\n        return tokenIndexToCity.length - destroyed;\\r\\n    }\\r\\n    // End 721 Implementation\\r\\n\\r\\n    ///////===165 Implementation\\r\\n    mapping (bytes4 => bool) internal supportedInterfaces;\\r\\n    function supportsInterface(bytes4 interfaceID) external override view returns (bool){\\r\\n        return supportedInterfaces[interfaceID];\\r\\n    }\\r\\n    ///==End 165\\r\\n\\r\\n\\r\\n    //Admin\\r\\n    function setOwner(address newOwner) public{\\r\\n        require(msg.sender == owner,\\\"owner\\\");\\r\\n        owner = newOwner;\\r\\n    }\\r\\n    function setUriComponents(string calldata _newBase, string calldata _newSuffix) public{\\r\\n        require(msg.sender == owner,\\\"owner\\\");\\r\\n\\r\\n        __uriBase   = bytes(_newBase);\\r\\n        __uriSuffix = bytes(_newSuffix);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\r\\ninterface IERC721 /* is ERC165 */ {\\r\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n    ///  may be created and assigned without emitting Transfer. At the time of\\r\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when the approved address for an NFT is changed or\\r\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\r\\n    ///  When a Transfer event emits, this also indicates that the approved\\r\\n    ///  address for that NFT (if any) is reset to none.\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n    ///  The operator can manage all NFTs of the owner.\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n    /// @notice Count all NFTs assigned to an owner\\r\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n    ///  function throws for queries about the zero address.\\r\\n    /// @param _owner An address for whom to query the balance\\r\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n    /// @notice Find the owner of an NFT\\r\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n    ///  about them do throw.\\r\\n    /// @param _tokenId The identifier for an NFT\\r\\n    /// @return The address of the owner of the NFT\\r\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev This works identically to the other function with an extra data parameter,\\r\\n    ///  except this function just sets data to \\\"\\\".\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n    ///  THEY MAY BE PERMANENTLY LOST\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Change or reaffirm the approved address for an NFT\\r\\n    /// @dev The zero address indicates there is no approved address.\\r\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n    ///  operator of the current owner.\\r\\n    /// @param _approved The new approved NFT controller\\r\\n    /// @param _tokenId The NFT to approve\\r\\n    function approve(address _approved, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n    ///  all of `msg.sender`'s assets\\r\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n    ///  multiple operators per owner.\\r\\n    /// @param _operator Address to add to the set of authorized operators\\r\\n    /// @param _approved True if the operator is approved, false to revoke approval\\r\\n    function setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n    /// @notice Get the approved address for a single NFT\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n    /// @param _tokenId The NFT to find the approved address for\\r\\n    /// @return The approved address for this NFT, or the zero address if there is none\\r\\n    function getApproved(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Query if an address is an authorized operator for another address\\r\\n    /// @param _owner The address that owns the NFTs\\r\\n    /// @param _operator The address that acts on behalf of the owner\\r\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\r\\ninterface IERC721Metadata /* is ERC721 */ {\\r\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\r\\n    function name() external view returns (string memory _name);\\r\\n\\r\\n    /// @notice An abbreviated name for NFTs in this contract\\r\\n    function symbol() external view returns (string memory _symbol);\\r\\n\\r\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\r\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\r\\n    ///  Metadata JSON Schema\\\".\\r\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\r\\ninterface IERC721TokenReceiver {\\r\\n    /// @notice Handle the receipt of an NFT\\r\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\r\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\r\\n    ///  transfer. Return of other than the magic value MUST result in the\\r\\n    ///  transaction being reverted.\\r\\n    ///  Note: the contract address is always the message sender.\\r\\n    /// @param _operator The address which called `safeTransferFrom` function\\r\\n    /// @param _from The address which previously owned the token\\r\\n    /// @param _tokenId The NFT identifier which is being transferred\\r\\n    /// @param _data Additional data with no specified format\\r\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n    ///  unless throwing\\r\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_doomsday\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_cityId\",\"type\":\"uint16\"}],\"name\":\"bunker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_reinforcement\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_damage\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_isVulnerable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isUninhabited\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"cities\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"cityData\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_cityIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_reinforcement\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_damage\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destroyed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"evacuatedFunds\",\"type\":\"uint256\"},{\"internalType\":\"enum Doomsday.Stage\",\"name\":\"stage\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"currentPrize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isEarlyAccess\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"countdown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextImpactIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEarlyAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"myCities\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextImpactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"vulnerableCities\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DoomsdayViewer","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d6e382aa7a09fc4a09c2fb99cfce6a429985e65d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}