{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary DataTypes {\r\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        uint40 lastUpdateTimestamp;\r\n        //tokens addresses\r\n        address aTokenAddress;\r\n        address stableDebtTokenAddress;\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint8 id;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        //bit 0-15: LTV\r\n        //bit 16-31: Liq. threshold\r\n        //bit 32-47: Liq. bonus\r\n        //bit 48-55: Decimals\r\n        //bit 56: Reserve is active\r\n        //bit 57: reserve is frozen\r\n        //bit 58: borrowing is enabled\r\n        //bit 59: stable rate borrowing enabled\r\n        //bit 60-63: reserved\r\n        //bit 64-79: reserve factor\r\n        uint256 data;\r\n    }\r\n\r\n    struct UserConfigurationMap {\r\n        uint256 data;\r\n    }\r\n\r\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n\r\n// Global Enums and Structs\r\nstruct StrategyParams {\r\n    uint256 performanceFee;\r\n    uint256 activation;\r\n    uint256 debtRatio;\r\n    uint256 minDebtPerHarvest;\r\n    uint256 maxDebtPerHarvest;\r\n    uint256 lastReport;\r\n    uint256 totalDebt;\r\n    uint256 totalGain;\r\n    uint256 totalLoss;\r\n}\r\n\r\n// Part: IAaveIncentivesController\r\n\r\ninterface IAaveIncentivesController {\r\n    /**\r\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n     * @param user The address of the user\r\n     * @return The rewards\r\n     **/\r\n    function getRewardsBalance(address[] calldata assets, address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n     * @param amount Amount of rewards to claim\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewards(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n     * @param amount Amount of rewards to claim\r\n     * @param user Address to check and claim rewards\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewardsOnBehalf(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address user,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev returns the unclaimed rewards of the user\r\n     * @param user the address of the user\r\n     * @return the unclaimed user rewards\r\n     */\r\n    function getUserUnclaimedRewards(address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev for backward compatibility with previous implementation of the Incentives controller\r\n     */\r\n    function REWARD_TOKEN() external view returns (address);\r\n\r\n    function getDistributionEnd() external view returns (uint256);\r\n\r\n    function getAssetData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n\r\n// Part: ILendingPoolAddressesProvider\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n    event MarketIdSet(string newMarketId);\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event ConfigurationAdminUpdated(address indexed newAddress);\r\n    event EmergencyAdminUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n    function getMarketId() external view returns (string memory);\r\n\r\n    function setMarketId(string calldata marketId) external;\r\n\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    function getLendingPool() external view returns (address);\r\n\r\n    function setLendingPoolImpl(address pool) external;\r\n\r\n    function getLendingPoolConfigurator() external view returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n    function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n    function setLendingPoolCollateralManager(address manager) external;\r\n\r\n    function getPoolAdmin() external view returns (address);\r\n\r\n    function setPoolAdmin(address admin) external;\r\n\r\n    function getEmergencyAdmin() external view returns (address);\r\n\r\n    function setEmergencyAdmin(address admin) external;\r\n\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    function setPriceOracle(address priceOracle) external;\r\n\r\n    function getLendingRateOracle() external view returns (address);\r\n\r\n    function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n\r\n// Part: IOptionalERC20\r\n\r\ninterface IOptionalERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// Part: IPriceOracle\r\n\r\ninterface IPriceOracle {\r\n    function getAssetPrice(address _asset) external view returns (uint256);\r\n\r\n    function getAssetsPrices(address[] calldata _assets)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getSourceOfAsset(address _asset) external view returns (address);\r\n\r\n    function getFallbackOracle() external view returns (address);\r\n}\r\n\r\n// Part: IReserveInterestRateStrategy\r\n\r\n/**\r\n * @title IReserveInterestRateStrategyInterface interface\r\n * @dev Interface for the calculation of the interest rates\r\n * @author Aave\r\n */\r\ninterface IReserveInterestRateStrategy {\r\n    function OPTIMAL_UTILIZATION_RATE() external view returns (uint256);\r\n\r\n    function EXCESS_UTILIZATION_RATE() external view returns (uint256);\r\n\r\n    function variableRateSlope1() external view returns (uint256);\r\n\r\n    function variableRateSlope2() external view returns (uint256);\r\n\r\n    function baseVariableBorrowRate() external view returns (uint256);\r\n\r\n    function getMaxVariableBorrowRate() external view returns (uint256);\r\n\r\n    function calculateInterestRates(\r\n        address reserve,\r\n        uint256 utilizationRate,\r\n        uint256 totalStableDebt,\r\n        uint256 totalVariableDebt,\r\n        uint256 averageStableBorrowRate,\r\n        uint256 reserveFactor\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 liquidityRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 variableBorrowRate\r\n        );\r\n}\r\n\r\n// Part: IScaledBalanceToken\r\n\r\ninterface IScaledBalanceToken {\r\n    /**\r\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n     * @param user The user whose balance is calculated\r\n     * @return The scaled balance of the user\r\n     **/\r\n    function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the scaled balance of the user and the scaled total supply.\r\n     * @param user The address of the user\r\n     * @return The scaled balance of the user\r\n     * @return The scaled balance and the scaled total supply\r\n     **/\r\n    function getScaledUserBalanceAndSupply(address user)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    /**\r\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n     * @return The scaled total supply\r\n     **/\r\n    function scaledTotalSupply() external view returns (uint256);\r\n}\r\n\r\n// Part: IStakedAave\r\n\r\ninterface IStakedAave {\r\n    function stake(address to, uint256 amount) external;\r\n\r\n    function redeem(address to, uint256 amount) external;\r\n\r\n    function cooldown() external;\r\n\r\n    function claimRewards(address to, uint256 amount) external;\r\n\r\n    function getTotalRewardsBalance(address) external view returns (uint256);\r\n\r\n    function COOLDOWN_SECONDS() external view returns (uint256);\r\n\r\n    function stakersCooldowns(address) external view returns (uint256);\r\n\r\n    function UNSTAKE_WINDOW() external view returns (uint256);\r\n}\r\n\r\n// Part: ISwap\r\n\r\ninterface ISwap {\r\n    function swapExactTokensForTokens(\r\n        uint256,\r\n        uint256,\r\n        address[] calldata,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256,\r\n        uint256,\r\n        address[] calldata,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/Address\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/IERC20\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/Math\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeMath\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Part: WadRayMath\r\n\r\n/**\r\n * @title WadRayMath library\r\n * @author Aave\r\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n **/\r\n\r\nlibrary WadRayMath {\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant halfWAD = WAD / 2;\r\n\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant halfRAY = RAY / 2;\r\n\r\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n    /**\r\n     * @return One ray, 1e27\r\n     **/\r\n    function ray() internal pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    /**\r\n     * @return One wad, 1e18\r\n     **/\r\n\r\n    function wad() internal pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    /**\r\n     * @return Half ray, 1e27/2\r\n     **/\r\n    function halfRay() internal pure returns (uint256) {\r\n        return halfRAY;\r\n    }\r\n\r\n    /**\r\n     * @return Half ray, 1e18/2\r\n     **/\r\n    function halfWad() internal pure returns (uint256) {\r\n        return halfWAD;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two wad, rounding half up to the nearest wad\r\n     * @param a Wad\r\n     * @param b Wad\r\n     * @return The result of a*b, in wad\r\n     **/\r\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(a <= (type(uint256).max - halfWAD) / b);\r\n\r\n        return (a * b + halfWAD) / WAD;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two wad, rounding half up to the nearest wad\r\n     * @param a Wad\r\n     * @param b Wad\r\n     * @return The result of a/b, in wad\r\n     **/\r\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        uint256 halfB = b / 2;\r\n\r\n        require(a <= (type(uint256).max - halfB) / WAD);\r\n\r\n        return (a * WAD + halfB) / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two ray, rounding half up to the nearest ray\r\n     * @param a Ray\r\n     * @param b Ray\r\n     * @return The result of a*b, in ray\r\n     **/\r\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(a <= (type(uint256).max - halfRAY) / b);\r\n\r\n        return (a * b + halfRAY) / RAY;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two ray, rounding half up to the nearest ray\r\n     * @param a Ray\r\n     * @param b Ray\r\n     * @return The result of a/b, in ray\r\n     **/\r\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        uint256 halfB = b / 2;\r\n\r\n        require(a <= (type(uint256).max - halfB) / RAY);\r\n\r\n        return (a * RAY + halfB) / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Casts ray down to wad\r\n     * @param a Ray\r\n     * @return a casted to wad, rounded half up to the nearest wad\r\n     **/\r\n    function rayToWad(uint256 a) internal pure returns (uint256) {\r\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n        uint256 result = halfRatio + a;\r\n        require(result >= halfRatio);\r\n\r\n        return result / WAD_RAY_RATIO;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts wad up to ray\r\n     * @param a Wad\r\n     * @return a converted in ray\r\n     **/\r\n    function wadToRay(uint256 a) internal pure returns (uint256) {\r\n        uint256 result = a * WAD_RAY_RATIO;\r\n        require(result / WAD_RAY_RATIO == a);\r\n        return result;\r\n    }\r\n}\r\n\r\n// Part: iearn-finance/yearn-vaults@0.4.3/HealthCheck\r\n\r\ninterface HealthCheck {\r\n    function check(\r\n        uint256 profit,\r\n        uint256 loss,\r\n        uint256 debtPayment,\r\n        uint256 debtOutstanding,\r\n        uint256 totalDebt\r\n    ) external view returns (bool);\r\n}\r\n\r\n// Part: ILendingPool\r\n\r\ninterface ILendingPool {\r\n    /**\r\n     * @dev Emitted on deposit()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the deposit\r\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n     * @param amount The amount deposited\r\n     * @param referral The referral code used\r\n     **/\r\n    event Deposit(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on withdraw()\r\n     * @param reserve The address of the underlyng asset being withdrawn\r\n     * @param user The address initiating the withdrawal, owner of aTokens\r\n     * @param to Address that will receive the underlying\r\n     * @param amount The amount to be withdrawn\r\n     **/\r\n    event Withdraw(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n     * @param reserve The address of the underlying asset being borrowed\r\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n     * initiator of the transaction on flashLoan()\r\n     * @param onBehalfOf The address that will be getting the debt\r\n     * @param amount The amount borrowed out\r\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n     * @param borrowRate The numeric rate at which the user has borrowed\r\n     * @param referral The referral code used\r\n     **/\r\n    event Borrow(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint256 borrowRateMode,\r\n        uint256 borrowRate,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on repay()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The beneficiary of the repayment, getting his debt reduced\r\n     * @param repayer The address of the user initiating the repay(), providing the funds\r\n     * @param amount The amount repaid\r\n     **/\r\n    event Repay(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed repayer,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on swapBorrowRateMode()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user swapping his rate mode\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralEnabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralDisabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on rebalanceStableBorrowRate()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user for which the rebalance has been executed\r\n     **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on flashLoan()\r\n     * @param target The address of the flash loan receiver contract\r\n     * @param initiator The address initiating the flash loan\r\n     * @param asset The address of the asset being flash borrowed\r\n     * @param amount The amount flash borrowed\r\n     * @param premium The fee flash borrowed\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event FlashLoan(\r\n        address indexed target,\r\n        address indexed initiator,\r\n        address indexed asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        uint16 referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered.\r\n     */\r\n    event Paused();\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted.\r\n     */\r\n    event Unpaused();\r\n\r\n    /**\r\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n     * LendingPoolCollateral manager using a DELEGATECALL\r\n     * This allows to have the events in the generated ABI for LendingPool.\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n     * @param liquidator The address of the liquidator\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    event LiquidationCall(\r\n        address indexed collateralAsset,\r\n        address indexed debtAsset,\r\n        address indexed user,\r\n        uint256 debtToCover,\r\n        uint256 liquidatedCollateralAmount,\r\n        address liquidator,\r\n        bool receiveAToken\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n     * gets added to the LendingPool ABI\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param liquidityRate The new liquidity rate\r\n     * @param stableBorrowRate The new stable borrow rate\r\n     * @param variableBorrowRate The new variable borrow rate\r\n     * @param liquidityIndex The new liquidity index\r\n     * @param variableBorrowIndex The new variable borrow index\r\n     **/\r\n    event ReserveDataUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @return The final amount repaid\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 rateMode,\r\n        address onBehalfOf\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n    /**\r\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n     *        borrowed at a stable rate and depositors are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n     * @param asset The address of the underlying asset deposited\r\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n     * For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts amounts being flash-borrowed\r\n     * @param modes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata modes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralETH the total collateral in ETH of the user\r\n     * @return totalDebtETH the total debt in ETH of the user\r\n     * @return availableBorrowsETH the borrowing power left of the user\r\n     * @return currentLiquidationThreshold the liquidation threshold of the user\r\n     * @return ltv the loan to value of the user\r\n     * @return healthFactor the current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function initReserve(\r\n        address reserve,\r\n        address aTokenAddress,\r\n        address stableDebtAddress,\r\n        address variableDebtAddress,\r\n        address interestRateStrategyAddress\r\n    ) external;\r\n\r\n    function setReserveInterestRateStrategyAddress(\r\n        address reserve,\r\n        address rateStrategyAddress\r\n    ) external;\r\n\r\n    function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n    /**\r\n     * @dev Returns the configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The configuration of the reserve\r\n     **/\r\n    function getConfiguration(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the configuration of the user across all the reserves\r\n     * @param user The user address\r\n     * @return The configuration of the user\r\n     **/\r\n    function getUserConfiguration(address user)\r\n        external\r\n        view\r\n        returns (DataTypes.UserConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the normalized income normalized income of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve's normalized income\r\n     */\r\n    function getReserveNormalizedIncome(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the normalized variable debt per unit of asset\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve normalized variable debt\r\n     */\r\n    function getReserveNormalizedVariableDebt(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the state and configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The state of the reserve\r\n     **/\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveData memory);\r\n\r\n    function finalizeTransfer(\r\n        address asset,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 balanceFromAfter,\r\n        uint256 balanceToBefore\r\n    ) external;\r\n\r\n    function getReservesList() external view returns (address[] memory);\r\n\r\n    function getAddressesProvider()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function setPause(bool val) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n\r\n// Part: IProtocolDataProvider\r\n\r\ninterface IProtocolDataProvider {\r\n    struct TokenData {\r\n        string symbol;\r\n        address tokenAddress;\r\n    }\r\n\r\n    function ADDRESSES_PROVIDER()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function getAllReservesTokens() external view returns (TokenData[] memory);\r\n\r\n    function getAllATokens() external view returns (TokenData[] memory);\r\n\r\n    function getReserveConfigurationData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 decimals,\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            uint256 reserveFactor,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive,\r\n            bool isFrozen\r\n        );\r\n\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 availableLiquidity,\r\n            uint256 totalStableDebt,\r\n            uint256 totalVariableDebt,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 averageStableBorrowRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            uint40 lastUpdateTimestamp\r\n        );\r\n\r\n    function getUserReserveData(address asset, address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentStableDebt,\r\n            uint256 currentVariableDebt,\r\n            uint256 principalStableDebt,\r\n            uint256 scaledVariableDebt,\r\n            uint256 stableBorrowRate,\r\n            uint256 liquidityRate,\r\n            uint40 stableRateLastUpdated,\r\n            bool usageAsCollateralEnabled\r\n        );\r\n\r\n    function getReserveTokensAddresses(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            address aTokenAddress,\r\n            address stableDebtTokenAddress,\r\n            address variableDebtTokenAddress\r\n        );\r\n}\r\n\r\n// Part: IVariableDebtToken\r\n\r\n/**\r\n * @title IVariableDebtToken\r\n * @author Aave\r\n * @notice Defines the basic interface for a variable debt token.\r\n **/\r\ninterface IVariableDebtToken is IERC20, IScaledBalanceToken {\r\n    /**\r\n     * @dev Emitted after the mint action\r\n     * @param from The address performing the mint\r\n     * @param onBehalfOf The address of the user on which behalf minting has been performed\r\n     * @param value The amount to be minted\r\n     * @param index The last index of the reserve\r\n     **/\r\n    event Mint(\r\n        address indexed from,\r\n        address indexed onBehalfOf,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Mints debt token to the `onBehalfOf` address\r\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n     * of credit delegate, or same as `onBehalfOf` otherwise\r\n     * @param onBehalfOf The address receiving the debt tokens\r\n     * @param amount The amount of debt being minted\r\n     * @param index The variable debt index of the reserve\r\n     * @return `true` if the the previous balance of the user is 0\r\n     **/\r\n    function mint(\r\n        address user,\r\n        address onBehalfOf,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when variable debt is burnt\r\n     * @param user The user which debt has been burned\r\n     * @param amount The amount of debt being burned\r\n     * @param index The index of the user\r\n     **/\r\n    event Burn(address indexed user, uint256 amount, uint256 index);\r\n\r\n    /**\r\n     * @dev Burns user variable debt\r\n     * @param user The user which debt is burnt\r\n     * @param index The variable debt index of the reserve\r\n     **/\r\n    function burn(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the address of the incentives controller contract\r\n     **/\r\n    function getIncentivesController()\r\n        external\r\n        view\r\n        returns (IAaveIncentivesController);\r\n}\r\n\r\n// Part: IVault\r\n\r\ninterface IVault is IERC20 {\r\n    function token() external view returns (address);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function deposit() external;\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function withdraw() external returns (uint256);\r\n\r\n    function withdraw(uint256 amount) external returns (uint256);\r\n\r\n    function withdraw(\r\n        uint256 amount,\r\n        address account,\r\n        uint256 maxLoss\r\n    ) external returns (uint256);\r\n\r\n    function availableDepositLimit() external view returns (uint256);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeERC20\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// Part: iearn-finance/yearn-vaults@0.4.3/VaultAPI\r\n\r\ninterface VaultAPI is IERC20 {\r\n    function name() external view returns (string calldata);\r\n\r\n    function symbol() external view returns (string calldata);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function apiVersion() external pure returns (string memory);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 expiry,\r\n        bytes calldata signature\r\n    ) external returns (bool);\r\n\r\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\r\n    function deposit() external returns (uint256);\r\n\r\n    function deposit(uint256 amount) external returns (uint256);\r\n\r\n    function deposit(uint256 amount, address recipient) external returns (uint256);\r\n\r\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\r\n    function withdraw() external returns (uint256);\r\n\r\n    function withdraw(uint256 maxShares) external returns (uint256);\r\n\r\n    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function strategies(address _strategy) external view returns (StrategyParams memory);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function totalAssets() external view returns (uint256);\r\n\r\n    function depositLimit() external view returns (uint256);\r\n\r\n    function maxAvailableShares() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault would increase this Strategy's borrow limit,\r\n     * based on its present performance (since its last report). Can be used to\r\n     * determine expectedReturn in your Strategy.\r\n     */\r\n    function creditAvailable() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault would like to pull back from the Strategy,\r\n     * based on its present performance (since its last report). Can be used to\r\n     * determine expectedReturn in your Strategy.\r\n     */\r\n    function debtOutstanding() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault expect this Strategy to return at the current\r\n     * block, based on its present performance (since its last report). Can be\r\n     * used to determine expectedReturn in your Strategy.\r\n     */\r\n    function expectedReturn() external view returns (uint256);\r\n\r\n    /**\r\n     * This is the main contact point where the Strategy interacts with the\r\n     * Vault. It is critical that this call is handled as intended by the\r\n     * Strategy. Therefore, this function will be called by BaseStrategy to\r\n     * make sure the integration is correct.\r\n     */\r\n    function report(\r\n        uint256 _gain,\r\n        uint256 _loss,\r\n        uint256 _debtPayment\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * This function should only be used in the scenario where the Strategy is\r\n     * being retired but no migration of the positions are possible, or in the\r\n     * extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\r\n     * mode in order for it to exit as quickly as possible. The latter scenario\r\n     * could be for any reason that is considered \"critical\" that the Strategy\r\n     * exits its position as fast as possible, such as a sudden change in\r\n     * market conditions leading to losses, or an imminent failure in an\r\n     * external dependency.\r\n     */\r\n    function revokeStrategy() external;\r\n\r\n    /**\r\n     * View the governance address of the Vault to assert privileged functions\r\n     * can only be called by governance. The Strategy serves the Vault, so it\r\n     * is subject to governance defined by the Vault.\r\n     */\r\n    function governance() external view returns (address);\r\n\r\n    /**\r\n     * View the management address of the Vault to assert privileged functions\r\n     * can only be called by management. The Strategy serves the Vault, so it\r\n     * is subject to management defined by the Vault.\r\n     */\r\n    function management() external view returns (address);\r\n\r\n    /**\r\n     * View the guardian address of the Vault to assert privileged functions\r\n     * can only be called by guardian. The Strategy serves the Vault, so it\r\n     * is subject to guardian defined by the Vault.\r\n     */\r\n    function guardian() external view returns (address);\r\n}\r\n\r\n// Part: IInitializableAToken\r\n\r\n/**\r\n * @title IInitializableAToken\r\n * @notice Interface for the initialize function on AToken\r\n * @author Aave\r\n **/\r\ninterface IInitializableAToken {\r\n    /**\r\n     * @dev Emitted when an aToken is initialized\r\n     * @param underlyingAsset The address of the underlying asset\r\n     * @param pool The address of the associated lending pool\r\n     * @param treasury The address of the treasury\r\n     * @param incentivesController The address of the incentives controller for this aToken\r\n     * @param aTokenDecimals the decimals of the underlying\r\n     * @param aTokenName the name of the aToken\r\n     * @param aTokenSymbol the symbol of the aToken\r\n     * @param params A set of encoded parameters for additional initialization\r\n     **/\r\n    event Initialized(\r\n        address indexed underlyingAsset,\r\n        address indexed pool,\r\n        address treasury,\r\n        address incentivesController,\r\n        uint8 aTokenDecimals,\r\n        string aTokenName,\r\n        string aTokenSymbol,\r\n        bytes params\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the aToken\r\n     * @param pool The address of the lending pool where this aToken will be used\r\n     * @param treasury The address of the Aave treasury, receiving the fees on this aToken\r\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n     * @param incentivesController The smart contract managing potential incentives distribution\r\n     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n     * @param aTokenName The name of the aToken\r\n     * @param aTokenSymbol The symbol of the aToken\r\n     */\r\n    function initialize(\r\n        ILendingPool pool,\r\n        address treasury,\r\n        address underlyingAsset,\r\n        IAaveIncentivesController incentivesController,\r\n        uint8 aTokenDecimals,\r\n        string calldata aTokenName,\r\n        string calldata aTokenSymbol,\r\n        bytes calldata params\r\n    ) external;\r\n}\r\n\r\n// Part: iearn-finance/yearn-vaults@0.4.3/BaseStrategy\r\n\r\n/**\r\n * @title Yearn Base Strategy\r\n * @author yearn.finance\r\n * @notice\r\n *  BaseStrategy implements all of the required functionality to interoperate\r\n *  closely with the Vault contract. This contract should be inherited and the\r\n *  abstract methods implemented to adapt the Strategy to the particular needs\r\n *  it has to create a return.\r\n *\r\n *  Of special interest is the relationship between `harvest()` and\r\n *  `vault.report()'. `harvest()` may be called simply because enough time has\r\n *  elapsed since the last report, and not because any funds need to be moved\r\n *  or positions adjusted. This is critical so that the Vault may maintain an\r\n *  accurate picture of the Strategy's performance. See  `vault.report()`,\r\n *  `harvest()`, and `harvestTrigger()` for further details.\r\n */\r\n\r\nabstract contract BaseStrategy {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    string public metadataURI;\r\n\r\n    // health checks\r\n    bool public doHealthCheck;\r\n    address public healthCheck;\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to track which version of `StrategyAPI` this Strategy\r\n     *  implements.\r\n     * @dev The Strategy's version must match the Vault's `API_VERSION`.\r\n     * @return A string which holds the current API version of this contract.\r\n     */\r\n    function apiVersion() public pure returns (string memory) {\r\n        return \"0.4.3\";\r\n    }\r\n\r\n    /**\r\n     * @notice This Strategy's name.\r\n     * @dev\r\n     *  You can use this field to manage the \"version\" of this Strategy, e.g.\r\n     *  `StrategySomethingOrOtherV1`. However, \"API Version\" is managed by\r\n     *  `apiVersion()` function above.\r\n     * @return This Strategy's name.\r\n     */\r\n    function name() external view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice\r\n     *  The amount (priced in want) of the total assets managed by this strategy should not count\r\n     *  towards Yearn's TVL calculations.\r\n     * @dev\r\n     *  You can override this field to set it to a non-zero value if some of the assets of this\r\n     *  Strategy is somehow delegated inside another part of of Yearn's ecosystem e.g. another Vault.\r\n     *  Note that this value must be strictly less than or equal to the amount provided by\r\n     *  `estimatedTotalAssets()` below, as the TVL calc will be total assets minus delegated assets.\r\n     *  Also note that this value is used to determine the total assets under management by this\r\n     *  strategy, for the purposes of computing the management fee in `Vault`\r\n     * @return\r\n     *  The amount of assets this strategy manages that should not be included in Yearn's Total Value\r\n     *  Locked (TVL) calculation across it's ecosystem.\r\n     */\r\n    function delegatedAssets() external view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    VaultAPI public vault;\r\n    address public strategist;\r\n    address public rewards;\r\n    address public keeper;\r\n\r\n    IERC20 public want;\r\n\r\n    // So indexers can keep track of this\r\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\r\n\r\n    event UpdatedStrategist(address newStrategist);\r\n\r\n    event UpdatedKeeper(address newKeeper);\r\n\r\n    event UpdatedRewards(address rewards);\r\n\r\n    event UpdatedMinReportDelay(uint256 delay);\r\n\r\n    event UpdatedMaxReportDelay(uint256 delay);\r\n\r\n    event UpdatedProfitFactor(uint256 profitFactor);\r\n\r\n    event UpdatedDebtThreshold(uint256 debtThreshold);\r\n\r\n    event EmergencyExitEnabled();\r\n\r\n    event UpdatedMetadataURI(string metadataURI);\r\n\r\n    // The minimum number of seconds between harvest calls. See\r\n    // `setMinReportDelay()` for more details.\r\n    uint256 public minReportDelay;\r\n\r\n    // The maximum number of seconds between harvest calls. See\r\n    // `setMaxReportDelay()` for more details.\r\n    uint256 public maxReportDelay;\r\n\r\n    // The minimum multiple that `callCost` must be above the credit/profit to\r\n    // be \"justifiable\". See `setProfitFactor()` for more details.\r\n    uint256 public profitFactor;\r\n\r\n    // Use this to adjust the threshold at which running a debt causes a\r\n    // harvest trigger. See `setDebtThreshold()` for more details.\r\n    uint256 public debtThreshold;\r\n\r\n    // See note on `setEmergencyExit()`.\r\n    bool public emergencyExit;\r\n\r\n    // modifiers\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyEmergencyAuthorized() {\r\n        require(\r\n            msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(),\r\n            \"!authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyStrategist() {\r\n        require(msg.sender == strategist, \"!strategist\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyKeepers() {\r\n        require(\r\n            msg.sender == keeper ||\r\n                msg.sender == strategist ||\r\n                msg.sender == governance() ||\r\n                msg.sender == vault.guardian() ||\r\n                msg.sender == vault.management(),\r\n            \"!authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyVaultManagers() {\r\n        require(msg.sender == vault.management() || msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _vault) public {\r\n        _initialize(_vault, msg.sender, msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Initializes the Strategy, this is called only once, when the\r\n     *  contract is deployed.\r\n     * @dev `_vault` should implement `VaultAPI`.\r\n     * @param _vault The address of the Vault responsible for this Strategy.\r\n     * @param _strategist The address to assign as `strategist`.\r\n     * The strategist is able to change the reward address\r\n     * @param _rewards  The address to use for pulling rewards.\r\n     * @param _keeper The adddress of the _keeper. _keeper\r\n     * can harvest and tend a strategy.\r\n     */\r\n    function _initialize(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) internal {\r\n        require(address(want) == address(0), \"Strategy already initialized\");\r\n\r\n        vault = VaultAPI(_vault);\r\n        want = IERC20(vault.token());\r\n        want.safeApprove(_vault, uint256(-1)); // Give Vault unlimited access (might save gas)\r\n        strategist = _strategist;\r\n        rewards = _rewards;\r\n        keeper = _keeper;\r\n\r\n        // initialize variables\r\n        minReportDelay = 0;\r\n        maxReportDelay = 86400;\r\n        profitFactor = 100;\r\n        debtThreshold = 0;\r\n\r\n        vault.approve(rewards, uint256(-1)); // Allow rewards to be pulled\r\n    }\r\n\r\n    function setHealthCheck(address _healthCheck) external onlyVaultManagers {\r\n        healthCheck = _healthCheck;\r\n    }\r\n\r\n    function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {\r\n        doHealthCheck = _doHealthCheck;\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `strategist`.\r\n     *\r\n     *  This may only be called by governance or the existing strategist.\r\n     * @param _strategist The new address to assign as `strategist`.\r\n     */\r\n    function setStrategist(address _strategist) external onlyAuthorized {\r\n        require(_strategist != address(0));\r\n        strategist = _strategist;\r\n        emit UpdatedStrategist(_strategist);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `keeper`.\r\n     *\r\n     *  `keeper` is the only address that may call `tend()` or `harvest()`,\r\n     *  other than `governance()` or `strategist`. However, unlike\r\n     *  `governance()` or `strategist`, `keeper` may *only* call `tend()`\r\n     *  and `harvest()`, and no other authorized functions, following the\r\n     *  principle of least privilege.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _keeper The new address to assign as `keeper`.\r\n     */\r\n    function setKeeper(address _keeper) external onlyAuthorized {\r\n        require(_keeper != address(0));\r\n        keeper = _keeper;\r\n        emit UpdatedKeeper(_keeper);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `rewards`. EOA or smart contract which has the permission\r\n     *  to pull rewards from the vault.\r\n     *\r\n     *  This may only be called by the strategist.\r\n     * @param _rewards The address to use for pulling rewards.\r\n     */\r\n    function setRewards(address _rewards) external onlyStrategist {\r\n        require(_rewards != address(0));\r\n        vault.approve(rewards, 0);\r\n        rewards = _rewards;\r\n        vault.approve(rewards, uint256(-1));\r\n        emit UpdatedRewards(_rewards);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `minReportDelay`. `minReportDelay` is the minimum number\r\n     *  of blocks that should pass for `harvest()` to be called.\r\n     *\r\n     *  For external keepers (such as the Keep3r network), this is the minimum\r\n     *  time between jobs to wait. (see `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _delay The minimum number of seconds to wait between harvests.\r\n     */\r\n    function setMinReportDelay(uint256 _delay) external onlyAuthorized {\r\n        minReportDelay = _delay;\r\n        emit UpdatedMinReportDelay(_delay);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `maxReportDelay`. `maxReportDelay` is the maximum number\r\n     *  of blocks that should pass for `harvest()` to be called.\r\n     *\r\n     *  For external keepers (such as the Keep3r network), this is the maximum\r\n     *  time between jobs to wait. (see `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _delay The maximum number of seconds to wait between harvests.\r\n     */\r\n    function setMaxReportDelay(uint256 _delay) external onlyAuthorized {\r\n        maxReportDelay = _delay;\r\n        emit UpdatedMaxReportDelay(_delay);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `profitFactor`. `profitFactor` is used to determine\r\n     *  if it's worthwhile to harvest, given gas costs. (See `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _profitFactor A ratio to multiply anticipated\r\n     * `harvest()` gas cost against.\r\n     */\r\n    function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {\r\n        profitFactor = _profitFactor;\r\n        emit UpdatedProfitFactor(_profitFactor);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Sets how far the Strategy can go into loss without a harvest and report\r\n     *  being required.\r\n     *\r\n     *  By default this is 0, meaning any losses would cause a harvest which\r\n     *  will subsequently report the loss to the Vault for tracking. (See\r\n     *  `harvestTrigger()` for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _debtThreshold How big of a loss this Strategy may carry without\r\n     * being required to report to the Vault.\r\n     */\r\n    function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {\r\n        debtThreshold = _debtThreshold;\r\n        emit UpdatedDebtThreshold(_debtThreshold);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `metadataURI`. `metadataURI` is used to store the URI\r\n     * of the file describing the strategy.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _metadataURI The URI that describe the strategy.\r\n     */\r\n    function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {\r\n        metadataURI = _metadataURI;\r\n        emit UpdatedMetadataURI(_metadataURI);\r\n    }\r\n\r\n    /**\r\n     * Resolve governance address from Vault contract, used to make assertions\r\n     * on protected functions in the Strategy.\r\n     */\r\n    function governance() internal view returns (address) {\r\n        return vault.governance();\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)\r\n     *  to `want` (using the native decimal characteristics of `want`).\r\n     * @dev\r\n     *  Care must be taken when working with decimals to assure that the conversion\r\n     *  is compatible. As an example:\r\n     *\r\n     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),\r\n     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)\r\n     *\r\n     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`\r\n     * @return The amount in `want` of `_amtInEth` converted to `want`\r\n     **/\r\n    function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide an accurate estimate for the total amount of assets\r\n     *  (principle + return) that this Strategy is currently managing,\r\n     *  denominated in terms of `want` tokens.\r\n     *\r\n     *  This total should be \"realizable\" e.g. the total value that could\r\n     *  *actually* be obtained from this Strategy if it were to divest its\r\n     *  entire position based on current on-chain conditions.\r\n     * @dev\r\n     *  Care must be taken in using this function, since it relies on external\r\n     *  systems, which could be manipulated by the attacker to give an inflated\r\n     *  (or reduced) value produced by this function, based on current on-chain\r\n     *  conditions (e.g. this function is possible to influence through\r\n     *  flashloan attacks, oracle manipulations, or other DeFi attack\r\n     *  mechanisms).\r\n     *\r\n     *  It is up to governance to use this function to correctly order this\r\n     *  Strategy relative to its peers in the withdrawal queue to minimize\r\n     *  losses for the Vault based on sudden withdrawals. This value should be\r\n     *  higher than the total debt of the Strategy and higher than its expected\r\n     *  value to be \"safe\".\r\n     * @return The estimated total assets in this Strategy.\r\n     */\r\n    function estimatedTotalAssets() public view virtual returns (uint256);\r\n\r\n    /*\r\n     * @notice\r\n     *  Provide an indication of whether this strategy is currently \"active\"\r\n     *  in that it is managing an active position, or will manage a position in\r\n     *  the future. This should correlate to `harvest()` activity, so that Harvest\r\n     *  events can be tracked externally by indexing agents.\r\n     * @return True if the strategy is actively managing a position.\r\n     */\r\n    function isActive() public view returns (bool) {\r\n        return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;\r\n    }\r\n\r\n    /**\r\n     * Perform any Strategy unwinding or other calls necessary to capture the\r\n     * \"free return\" this Strategy has generated since the last time its core\r\n     * position(s) were adjusted. Examples include unwrapping extra rewards.\r\n     * This call is only used during \"normal operation\" of a Strategy, and\r\n     * should be optimized to minimize losses as much as possible.\r\n     *\r\n     * This method returns any realized profits and/or realized losses\r\n     * incurred, and should return the total amounts of profits/losses/debt\r\n     * payments (in `want` tokens) for the Vault's accounting (e.g.\r\n     * `want.balanceOf(this) >= _debtPayment + _profit`).\r\n     *\r\n     * `_debtOutstanding` will be 0 if the Strategy is not past the configured\r\n     * debt limit, otherwise its value will be how far past the debt limit\r\n     * the Strategy is. The Strategy's debt limit is configured in the Vault.\r\n     *\r\n     * NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\r\n     *       It is okay for it to be less than `_debtOutstanding`, as that\r\n     *       should only used as a guide for how much is left to pay back.\r\n     *       Payments should be made to minimize loss from slippage, debt,\r\n     *       withdrawal fees, etc.\r\n     *\r\n     * See `vault.debtOutstanding()`.\r\n     */\r\n    function prepareReturn(uint256 _debtOutstanding)\r\n        internal\r\n        virtual\r\n        returns (\r\n            uint256 _profit,\r\n            uint256 _loss,\r\n            uint256 _debtPayment\r\n        );\r\n\r\n    /**\r\n     * Perform any adjustments to the core position(s) of this Strategy given\r\n     * what change the Vault made in the \"investable capital\" available to the\r\n     * Strategy. Note that all \"free capital\" in the Strategy after the report\r\n     * was made is available for reinvestment. Also note that this number\r\n     * could be 0, and you should handle that scenario accordingly.\r\n     *\r\n     * See comments regarding `_debtOutstanding` on `prepareReturn()`.\r\n     */\r\n    function adjustPosition(uint256 _debtOutstanding) internal virtual;\r\n\r\n    /**\r\n     * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,\r\n     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\r\n     * This function should return the amount of `want` tokens made available by the\r\n     * liquidation. If there is a difference between them, `_loss` indicates whether the\r\n     * difference is due to a realized loss, or if there is some other sitution at play\r\n     * (e.g. locked funds) where the amount made available is less than what is needed.\r\n     *\r\n     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\r\n     */\r\n    function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);\r\n\r\n    /**\r\n     * Liquidate everything and returns the amount that got freed.\r\n     * This function is used during emergency exit instead of `prepareReturn()` to\r\n     * liquidate all of the Strategy's positions back to the Vault.\r\n     */\r\n\r\n    function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide a signal to the keeper that `tend()` should be called. The\r\n     *  keeper will provide the estimated gas cost that they would pay to call\r\n     *  `tend()`, and this function should use that estimate to make a\r\n     *  determination if calling it is \"worth it\" for the keeper. This is not\r\n     *  the only consideration into issuing this trigger, for example if the\r\n     *  position would be negatively affected if `tend()` is not called\r\n     *  shortly, then this can return `true` even if the keeper might be\r\n     *  \"at a loss\" (keepers are always reimbursed by Yearn).\r\n     * @dev\r\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\r\n     *\r\n     *  This call and `harvestTrigger()` should never return `true` at the same\r\n     *  time.\r\n     * @param callCostInWei The keeper's estimated gas cost to call `tend()` (in wei).\r\n     * @return `true` if `tend()` should be called, `false` otherwise.\r\n     */\r\n    function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {\r\n        // We usually don't need tend, but if there are positions that need\r\n        // active maintainence, overriding this function is how you would\r\n        // signal for that.\r\n        // If your implementation uses the cost of the call in want, you can\r\n        // use uint256 callCost = ethToWant(callCostInWei);\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Adjust the Strategy's position. The purpose of tending isn't to\r\n     *  realize gains, but to maximize yield by reinvesting any returns.\r\n     *\r\n     *  See comments on `adjustPosition()`.\r\n     *\r\n     *  This may only be called by governance, the strategist, or the keeper.\r\n     */\r\n    function tend() external onlyKeepers {\r\n        // Don't take profits with this call, but adjust for better gains\r\n        adjustPosition(vault.debtOutstanding());\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide a signal to the keeper that `harvest()` should be called. The\r\n     *  keeper will provide the estimated gas cost that they would pay to call\r\n     *  `harvest()`, and this function should use that estimate to make a\r\n     *  determination if calling it is \"worth it\" for the keeper. This is not\r\n     *  the only consideration into issuing this trigger, for example if the\r\n     *  position would be negatively affected if `harvest()` is not called\r\n     *  shortly, then this can return `true` even if the keeper might be \"at a\r\n     *  loss\" (keepers are always reimbursed by Yearn).\r\n     * @dev\r\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\r\n     *\r\n     *  This call and `tendTrigger` should never return `true` at the\r\n     *  same time.\r\n     *\r\n     *  See `min/maxReportDelay`, `profitFactor`, `debtThreshold` to adjust the\r\n     *  strategist-controlled parameters that will influence whether this call\r\n     *  returns `true` or not. These parameters will be used in conjunction\r\n     *  with the parameters reported to the Vault (see `params`) to determine\r\n     *  if calling `harvest()` is merited.\r\n     *\r\n     *  It is expected that an external system will check `harvestTrigger()`.\r\n     *  This could be a script run off a desktop or cloud bot (e.g.\r\n     *  https://github.com/iearn-finance/yearn-vaults/blob/main/scripts/keep.py),\r\n     *  or via an integration with the Keep3r network (e.g.\r\n     *  https://github.com/Macarse/GenericKeep3rV2/blob/master/contracts/keep3r/GenericKeep3rV2.sol).\r\n     * @param callCostInWei The keeper's estimated gas cost to call `harvest()` (in wei).\r\n     * @return `true` if `harvest()` should be called, `false` otherwise.\r\n     */\r\n    function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {\r\n        uint256 callCost = ethToWant(callCostInWei);\r\n        StrategyParams memory params = vault.strategies(address(this));\r\n\r\n        // Should not trigger if Strategy is not activated\r\n        if (params.activation == 0) return false;\r\n\r\n        // Should not trigger if we haven't waited long enough since previous harvest\r\n        if (block.timestamp.sub(params.lastReport) < minReportDelay) return false;\r\n\r\n        // Should trigger if hasn't been called in a while\r\n        if (block.timestamp.sub(params.lastReport) >= maxReportDelay) return true;\r\n\r\n        // If some amount is owed, pay it back\r\n        // NOTE: Since debt is based on deposits, it makes sense to guard against large\r\n        //       changes to the value from triggering a harvest directly through user\r\n        //       behavior. This should ensure reasonable resistance to manipulation\r\n        //       from user-initiated withdrawals as the outstanding debt fluctuates.\r\n        uint256 outstanding = vault.debtOutstanding();\r\n        if (outstanding > debtThreshold) return true;\r\n\r\n        // Check for profits and losses\r\n        uint256 total = estimatedTotalAssets();\r\n        // Trigger if we have a loss to report\r\n        if (total.add(debtThreshold) < params.totalDebt) return true;\r\n\r\n        uint256 profit = 0;\r\n        if (total > params.totalDebt) profit = total.sub(params.totalDebt); // We've earned a profit!\r\n\r\n        // Otherwise, only trigger if it \"makes sense\" economically (gas cost\r\n        // is <N% of value moved)\r\n        uint256 credit = vault.creditAvailable();\r\n        return (profitFactor.mul(callCost) < credit.add(profit));\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Harvests the Strategy, recognizing any profits or losses and adjusting\r\n     *  the Strategy's position.\r\n     *\r\n     *  In the rare case the Strategy is in emergency shutdown, this will exit\r\n     *  the Strategy's position.\r\n     *\r\n     *  This may only be called by governance, the strategist, or the keeper.\r\n     * @dev\r\n     *  When `harvest()` is called, the Strategy reports to the Vault (via\r\n     *  `vault.report()`), so in some cases `harvest()` must be called in order\r\n     *  to take in profits, to borrow newly available funds from the Vault, or\r\n     *  otherwise adjust its position. In other cases `harvest()` must be\r\n     *  called to report to the Vault on the Strategy's position, especially if\r\n     *  any losses have occurred.\r\n     */\r\n    function harvest() external onlyKeepers {\r\n        uint256 profit = 0;\r\n        uint256 loss = 0;\r\n        uint256 debtOutstanding = vault.debtOutstanding();\r\n        uint256 debtPayment = 0;\r\n        if (emergencyExit) {\r\n            // Free up as much capital as possible\r\n            uint256 amountFreed = liquidateAllPositions();\r\n            if (amountFreed < debtOutstanding) {\r\n                loss = debtOutstanding.sub(amountFreed);\r\n            } else if (amountFreed > debtOutstanding) {\r\n                profit = amountFreed.sub(debtOutstanding);\r\n            }\r\n            debtPayment = debtOutstanding.sub(loss);\r\n        } else {\r\n            // Free up returns for Vault to pull\r\n            (profit, loss, debtPayment) = prepareReturn(debtOutstanding);\r\n        }\r\n\r\n        // Allow Vault to take up to the \"harvested\" balance of this contract,\r\n        // which is the amount it has earned since the last time it reported to\r\n        // the Vault.\r\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\r\n        debtOutstanding = vault.report(profit, loss, debtPayment);\r\n\r\n        // Check if free returns are left, and re-invest them\r\n        adjustPosition(debtOutstanding);\r\n\r\n        // call healthCheck contract\r\n        if (doHealthCheck && healthCheck != address(0)) {\r\n            require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), \"!healthcheck\");\r\n        } else {\r\n            doHealthCheck = true;\r\n        }\r\n\r\n        emit Harvested(profit, loss, debtPayment, debtOutstanding);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Withdraws `_amountNeeded` to `vault`.\r\n     *\r\n     *  This may only be called by the Vault.\r\n     * @param _amountNeeded How much `want` to withdraw.\r\n     * @return _loss Any realized losses\r\n     */\r\n    function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {\r\n        require(msg.sender == address(vault), \"!vault\");\r\n        // Liquidate as much as possible to `want`, up to `_amountNeeded`\r\n        uint256 amountFreed;\r\n        (amountFreed, _loss) = liquidatePosition(_amountNeeded);\r\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\r\n        want.safeTransfer(msg.sender, amountFreed);\r\n        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\r\n    }\r\n\r\n    /**\r\n     * Do anything necessary to prepare this Strategy for migration, such as\r\n     * transferring any reserve or LP tokens, CDPs, or other tokens or stores of\r\n     * value.\r\n     */\r\n    function prepareMigration(address _newStrategy) internal virtual;\r\n\r\n    /**\r\n     * @notice\r\n     *  Transfers all `want` from this Strategy to `_newStrategy`.\r\n     *\r\n     *  This may only be called by the Vault.\r\n     * @dev\r\n     * The new Strategy's Vault must be the same as this Strategy's Vault.\r\n     *  The migration process should be carefully performed to make sure all\r\n     * the assets are migrated to the new address, which should have never\r\n     * interacted with the vault before.\r\n     * @param _newStrategy The Strategy to migrate to.\r\n     */\r\n    function migrate(address _newStrategy) external {\r\n        require(msg.sender == address(vault));\r\n        require(BaseStrategy(_newStrategy).vault() == vault);\r\n        prepareMigration(_newStrategy);\r\n        want.safeTransfer(_newStrategy, want.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Activates emergency exit. Once activated, the Strategy will exit its\r\n     *  position upon the next harvest, depositing all funds into the Vault as\r\n     *  quickly as is reasonable given on-chain conditions.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @dev\r\n     *  See `vault.setEmergencyShutdown()` and `harvest()` for further details.\r\n     */\r\n    function setEmergencyExit() external onlyEmergencyAuthorized {\r\n        emergencyExit = true;\r\n        vault.revokeStrategy();\r\n\r\n        emit EmergencyExitEnabled();\r\n    }\r\n\r\n    /**\r\n     * Override this to add all tokens/tokenized positions this contract\r\n     * manages on a *persistent* basis (e.g. not just for swapping back to\r\n     * want ephemerally).\r\n     *\r\n     * NOTE: Do *not* include `want`, already included in `sweep` below.\r\n     *\r\n     * Example:\r\n     * ```\r\n     *    function protectedTokens() internal override view returns (address[] memory) {\r\n     *      address[] memory protected = new address[](3);\r\n     *      protected[0] = tokenA;\r\n     *      protected[1] = tokenB;\r\n     *      protected[2] = tokenC;\r\n     *      return protected;\r\n     *    }\r\n     * ```\r\n     */\r\n    function protectedTokens() internal view virtual returns (address[] memory);\r\n\r\n    /**\r\n     * @notice\r\n     *  Removes tokens from this Strategy that are not the type of tokens\r\n     *  managed by this Strategy. This may be used in case of accidentally\r\n     *  sending the wrong kind of token to this Strategy.\r\n     *\r\n     *  Tokens will be sent to `governance()`.\r\n     *\r\n     *  This will fail if an attempt is made to sweep `want`, or any tokens\r\n     *  that are protected by this Strategy.\r\n     *\r\n     *  This may only be called by governance.\r\n     * @dev\r\n     *  Implement `protectedTokens()` to specify any additional tokens that\r\n     *  should be protected from sweeping in addition to `want`.\r\n     * @param _token The token to transfer out of this vault.\r\n     */\r\n    function sweep(address _token) external onlyGovernance {\r\n        require(_token != address(want), \"!want\");\r\n        require(_token != address(vault), \"!shares\");\r\n\r\n        address[] memory _protectedTokens = protectedTokens();\r\n        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], \"!protected\");\r\n\r\n        IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\n// Part: IAToken\r\n\r\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\r\n    /**\r\n     * @dev Emitted after the mint action\r\n     * @param from The address performing the mint\r\n     * @param value The amount being\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event Mint(address indexed from, uint256 value, uint256 index);\r\n\r\n    /**\r\n     * @dev Mints `amount` aTokens to `user`\r\n     * @param user The address receiving the minted tokens\r\n     * @param amount The amount of tokens getting minted\r\n     * @param index The new liquidity index of the reserve\r\n     * @return `true` if the the previous balance of the user was 0\r\n     */\r\n    function mint(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted after aTokens are burned\r\n     * @param from The owner of the aTokens, getting them burned\r\n     * @param target The address that will receive the underlying\r\n     * @param value The amount being burned\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event Burn(\r\n        address indexed from,\r\n        address indexed target,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted during the transfer action\r\n     * @param from The user whose tokens are being transferred\r\n     * @param to The recipient\r\n     * @param value The amount being transferred\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event BalanceTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n     * @param user The owner of the aTokens, getting them burned\r\n     * @param receiverOfUnderlying The address that will receive the underlying\r\n     * @param amount The amount being burned\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    function burn(\r\n        address user,\r\n        address receiverOfUnderlying,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Mints aTokens to the reserve treasury\r\n     * @param amount The amount of tokens getting minted\r\n     * @param index The new liquidity index of the reserve\r\n     */\r\n    function mintToTreasury(uint256 amount, uint256 index) external;\r\n\r\n    /**\r\n     * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n     * @param from The address getting liquidated, current owner of the aTokens\r\n     * @param to The recipient\r\n     * @param value The amount of tokens getting transferred\r\n     **/\r\n    function transferOnLiquidation(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n     * assets in borrow(), withdraw() and flashLoan()\r\n     * @param user The recipient of the underlying\r\n     * @param amount The amount getting transferred\r\n     * @return The amount transferred\r\n     **/\r\n    function transferUnderlyingTo(address user, uint256 amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Invoked to execute actions on the aToken side after a repayment.\r\n     * @param user The user executing the repayment\r\n     * @param amount The amount getting repaid\r\n     **/\r\n    function handleRepayment(address user, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the address of the incentives controller contract\r\n     **/\r\n    function getIncentivesController()\r\n        external\r\n        view\r\n        returns (IAaveIncentivesController);\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n     **/\r\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n}\r\n\r\n// Part: AaveLenderBorrowerLib\r\n\r\nlibrary AaveLenderBorrowerLib {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    struct CalcMaxDebtLocalVars {\r\n        uint256 availableLiquidity;\r\n        uint256 totalStableDebt;\r\n        uint256 totalVariableDebt;\r\n        uint256 totalDebt;\r\n        uint256 utilizationRate;\r\n        uint256 totalLiquidity;\r\n        uint256 targetUtilizationRate;\r\n        uint256 maxProtocolDebt;\r\n    }\r\n\r\n    struct IrsVars {\r\n        uint256 optimalRate;\r\n        uint256 baseRate;\r\n        uint256 slope1;\r\n        uint256 slope2;\r\n    }\r\n\r\n    uint256 internal constant MAX_BPS = 10_000;\r\n    IProtocolDataProvider public constant protocolDataProvider =\r\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\r\n\r\n    function lendingPool() public view returns (ILendingPool) {\r\n        return\r\n            ILendingPool(\r\n                protocolDataProvider.ADDRESSES_PROVIDER().getLendingPool()\r\n            );\r\n    }\r\n\r\n    function priceOracle() public view returns (IPriceOracle) {\r\n        return\r\n            IPriceOracle(\r\n                protocolDataProvider.ADDRESSES_PROVIDER().getPriceOracle()\r\n            );\r\n    }\r\n\r\n    function incentivesController(\r\n        IAToken aToken,\r\n        IVariableDebtToken variableDebtToken,\r\n        bool isWantIncentivised,\r\n        bool isInvestmentTokenIncentivised\r\n    ) public view returns (IAaveIncentivesController) {\r\n        if (isWantIncentivised) {\r\n            return aToken.getIncentivesController();\r\n        } else if (isInvestmentTokenIncentivised) {\r\n            return variableDebtToken.getIncentivesController();\r\n        } else {\r\n            return IAaveIncentivesController(0);\r\n        }\r\n    }\r\n\r\n    function toETH(uint256 _amount, address asset)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _amount.mul(priceOracle().getAssetPrice(asset)).div(\r\n                uint256(10)**uint256(IOptionalERC20(asset).decimals())\r\n            );\r\n    }\r\n\r\n    function fromETH(uint256 _amount, address asset)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _amount\r\n                .mul(uint256(10)**uint256(IOptionalERC20(asset).decimals()))\r\n                .div(priceOracle().getAssetPrice(asset));\r\n    }\r\n\r\n    function calcMaxDebt(address _investmentToken, uint256 _acceptableCostsRay)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 currentProtocolDebt,\r\n            uint256 maxProtocolDebt,\r\n            uint256 targetU\r\n        )\r\n    {\r\n        // This function is used to calculate the maximum amount of debt that the protocol can take\r\n        // to keep the cost of capital lower than the set acceptableCosts\r\n        // This maxProtocolDebt will be used to decide if capital costs are acceptable or not\r\n        // and to repay required debt to keep the rates below acceptable costs\r\n\r\n        // Hack to avoid the stack too deep compiler error.\r\n        CalcMaxDebtLocalVars memory vars;\r\n        DataTypes.ReserveData memory reserveData =\r\n            lendingPool().getReserveData(address(_investmentToken));\r\n        IReserveInterestRateStrategy irs =\r\n            IReserveInterestRateStrategy(\r\n                reserveData.interestRateStrategyAddress\r\n            );\r\n\r\n        (\r\n            vars.availableLiquidity, // = total supply - total stable debt - total variable debt\r\n            vars.totalStableDebt, // total debt paying stable interest rates\r\n            vars.totalVariableDebt, // total debt paying stable variable rates\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = protocolDataProvider.getReserveData(address(_investmentToken));\r\n\r\n        vars.totalDebt = vars.totalStableDebt.add(vars.totalVariableDebt);\r\n        vars.totalLiquidity = vars.availableLiquidity.add(vars.totalDebt);\r\n        vars.utilizationRate = vars.totalDebt == 0\r\n            ? 0\r\n            : vars.totalDebt.rayDiv(vars.totalLiquidity);\r\n\r\n        // Aave's Interest Rate Strategy Parameters (see docs)\r\n        IrsVars memory irsVars;\r\n        irsVars.optimalRate = irs.OPTIMAL_UTILIZATION_RATE();\r\n        irsVars.baseRate = irs.baseVariableBorrowRate(); // minimum cost of capital with 0 % of utilisation rate\r\n        irsVars.slope1 = irs.variableRateSlope1(); // rate of increase of cost of debt up to Optimal Utilisation Rate\r\n        irsVars.slope2 = irs.variableRateSlope2(); // rate of increase of cost of debt above Optimal Utilisation Rate\r\n\r\n        // acceptableCosts should always be > baseVariableBorrowRate\r\n        // If it's not this will revert since the strategist set the wrong\r\n        // acceptableCosts value\r\n        if (\r\n            vars.utilizationRate < irsVars.optimalRate &&\r\n            _acceptableCostsRay < irsVars.baseRate.add(irsVars.slope1)\r\n        ) {\r\n            // we solve Aave's Interest Rates equation for sub optimal utilisation rates\r\n            // IR = BASERATE + SLOPE1 * CURRENT_UTIL_RATE / OPTIMAL_UTIL_RATE\r\n            vars.targetUtilizationRate = (\r\n                _acceptableCostsRay.sub(irsVars.baseRate)\r\n            )\r\n                .rayMul(irsVars.optimalRate)\r\n                .rayDiv(irsVars.slope1);\r\n        } else {\r\n            // Special case where protocol is above utilization rate but we want\r\n            // a lower interest rate than (base + slope1)\r\n            if (_acceptableCostsRay < irsVars.baseRate.add(irsVars.slope1)) {\r\n                return (toETH(vars.totalDebt, address(_investmentToken)), 0, 0);\r\n            }\r\n\r\n            // we solve Aave's Interest Rates equation for utilisation rates above optimal U\r\n            // IR = BASERATE + SLOPE1 + SLOPE2 * (CURRENT_UTIL_RATE - OPTIMAL_UTIL_RATE) / (1-OPTIMAL_UTIL_RATE)\r\n            vars.targetUtilizationRate = (\r\n                _acceptableCostsRay.sub(irsVars.baseRate.add(irsVars.slope1))\r\n            )\r\n                .rayMul(uint256(1e27).sub(irsVars.optimalRate))\r\n                .rayDiv(irsVars.slope2)\r\n                .add(irsVars.optimalRate);\r\n        }\r\n\r\n        vars.maxProtocolDebt = vars\r\n            .totalLiquidity\r\n            .rayMul(vars.targetUtilizationRate)\r\n            .rayDiv(1e27);\r\n\r\n        return (\r\n            toETH(vars.totalDebt, address(_investmentToken)),\r\n            toETH(vars.maxProtocolDebt, address(_investmentToken)),\r\n            vars.targetUtilizationRate\r\n        );\r\n    }\r\n\r\n    function calculateAmountToRepay(\r\n        uint256 amountETH,\r\n        uint256 totalCollateralETH,\r\n        uint256 totalDebtETH,\r\n        uint256 warningLTV,\r\n        uint256 targetLTV,\r\n        address investmentToken,\r\n        uint256 minThreshold\r\n    ) public view returns (uint256) {\r\n        if (amountETH == 0) {\r\n            return 0;\r\n        }\r\n        // we check if the collateral that we are withdrawing leaves us in a risky range, we then take action\r\n        uint256 amountToWithdrawETH = amountETH;\r\n        // calculate the collateral that we are leaving after withdrawing\r\n        uint256 newCollateral =\r\n            totalCollateralETH > amountToWithdrawETH\r\n                ? totalCollateralETH.sub(amountToWithdrawETH)\r\n                : 0;\r\n        uint256 ltvAfterWithdrawal =\r\n            newCollateral > 0\r\n                ? totalDebtETH.mul(MAX_BPS).div(newCollateral)\r\n                : type(uint256).max;\r\n        // check if the new LTV is in UNHEALTHY range\r\n        // remember that if balance > _amountNeeded, ltvAfterWithdrawal == 0 (0 risk)\r\n        // this is not true but the effect will be the same\r\n        if (ltvAfterWithdrawal <= warningLTV) {\r\n            // no need of repaying debt because the LTV is ok\r\n            return 0;\r\n        } else if (ltvAfterWithdrawal == type(uint256).max) {\r\n            // we are withdrawing 100% of collateral so we need to repay full debt\r\n            return fromETH(totalDebtETH, address(investmentToken));\r\n        }\r\n        // WARNING: this only works for a single collateral asset, otherwise liquidationThreshold might change depending on the collateral being withdrawn\r\n        // e.g. we have USDC + WBTC as collateral, end liquidationThreshold will be different depending on which asset we withdraw\r\n        uint256 newTargetDebt = targetLTV.mul(newCollateral).div(MAX_BPS);\r\n        // if newTargetDebt is higher, we don't need to repay anything\r\n        if (newTargetDebt > totalDebtETH) {\r\n            return 0;\r\n        }\r\n        return\r\n            fromETH(\r\n                totalDebtETH.sub(newTargetDebt) < minThreshold\r\n                    ? totalDebtETH\r\n                    : totalDebtETH.sub(newTargetDebt),\r\n                address(investmentToken)\r\n            );\r\n    }\r\n\r\n    function checkCooldown(\r\n        bool isWantIncentivised,\r\n        bool isInvestmentTokenIncentivised,\r\n        address stkAave\r\n    ) external view returns (bool) {\r\n        if (!isWantIncentivised && !isInvestmentTokenIncentivised) {\r\n            return false;\r\n        }\r\n\r\n        uint256 cooldownStartTimestamp =\r\n            IStakedAave(stkAave).stakersCooldowns(address(this));\r\n        uint256 COOLDOWN_SECONDS = IStakedAave(stkAave).COOLDOWN_SECONDS();\r\n        uint256 UNSTAKE_WINDOW = IStakedAave(stkAave).UNSTAKE_WINDOW();\r\n        return\r\n            cooldownStartTimestamp != 0 &&\r\n            block.timestamp > cooldownStartTimestamp.add(COOLDOWN_SECONDS) &&\r\n            block.timestamp <=\r\n            cooldownStartTimestamp.add(COOLDOWN_SECONDS).add(UNSTAKE_WINDOW);\r\n    }\r\n\r\n    function shouldRebalance(\r\n        address investmentToken,\r\n        uint256 acceptableCostsRay,\r\n        uint256 targetLTV,\r\n        uint256 warningLTV,\r\n        uint256 totalCollateralETH,\r\n        uint256 totalDebtETH\r\n    ) external view returns (bool) {\r\n        uint256 currentLTV = totalDebtETH.mul(MAX_BPS).div(totalCollateralETH);\r\n\r\n        (uint256 currentProtocolDebt, uint256 maxProtocolDebt, ) =\r\n            calcMaxDebt(investmentToken, acceptableCostsRay);\r\n\r\n        if (\r\n            (currentLTV < targetLTV &&\r\n                currentProtocolDebt < maxProtocolDebt &&\r\n                targetLTV.sub(currentLTV) > 1000) || // WE NEED TO TAKE ON MORE DEBT (we need a 10p.p (1000bps) difference)\r\n            (currentLTV > warningLTV || currentProtocolDebt > maxProtocolDebt) // WE NEED TO REPAY DEBT BECAUSE OF UNHEALTHY RATIO OR BORROWING COSTS\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        // no call to super.tendTrigger as it would return false\r\n        return false;\r\n    }\r\n}\r\n\r\n// File: Strategy.sol\r\n\r\ncontract Strategy is BaseStrategy {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n\r\n    // max interest rate we can afford to pay for borrowing investment token\r\n    // amount in Ray (1e27 = 100%)\r\n    uint256 public acceptableCostsRay = WadRayMath.RAY;\r\n\r\n    // max amount to borrow. used to manually limit amount (for yVault to keep APY)\r\n    uint256 public maxTotalBorrowIT;\r\n\r\n    bool public isWantIncentivised;\r\n    bool public isInvestmentTokenIncentivised;\r\n\r\n    // if set to true, the strategy will not try to repay debt by selling want\r\n    bool public leaveDebtBehind;\r\n\r\n    // Aave's referral code\r\n    uint16 internal referral;\r\n\r\n    // NOTE: LTV = Loan-To-Value = debt/collateral\r\n\r\n    // Target LTV: ratio up to which which we will borrow\r\n    uint16 public targetLTVMultiplier = 6_000;\r\n\r\n    // Warning LTV: ratio at which we will repay\r\n    uint16 public warningLTVMultiplier = 8_000; // 80% of liquidation LTV\r\n\r\n    // support\r\n    uint16 internal constant MAX_BPS = 10_000; // 100%\r\n    uint16 internal constant MAX_MULTIPLIER = 9_000; // 90%\r\n\r\n    IAToken internal aToken;\r\n    IVariableDebtToken internal variableDebtToken;\r\n    IVault public yVault;\r\n    IERC20 internal investmentToken;\r\n\r\n    ISwap public router;\r\n\r\n    IStakedAave internal constant stkAave =\r\n        IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\r\n\r\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address internal constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\r\n\r\n    uint256 internal minThreshold;\r\n    uint256 public maxLoss;\r\n    string internal strategyName;\r\n\r\n    event RepayDebt(uint256 repayAmount, uint256 previousDebtBalance);\r\n\r\n    constructor(\r\n        address _vault,\r\n        address _yVault,\r\n        string memory _strategyName\r\n    ) public BaseStrategy(_vault) {\r\n        _initializeThis(_yVault, _strategyName);\r\n    }\r\n\r\n    // ----------------- PUBLIC VIEW FUNCTIONS -----------------\r\n\r\n    function name() external view override returns (string memory) {\r\n        return strategyName;\r\n    }\r\n\r\n    function estimatedTotalAssets() public view override returns (uint256) {\r\n        // not taking into account aave rewards (they are staked and not accesible)\r\n        return\r\n            balanceOfWant() // balance of want\r\n                .add(balanceOfAToken()) // asset suplied as collateral\r\n                .add(\r\n                _fromETH(\r\n                    _toETH(_valueOfInvestment(), address(investmentToken)),\r\n                    address(want)\r\n                )\r\n            ) // current value of assets deposited in vault\r\n                .sub(\r\n                _fromETH(\r\n                    _toETH(balanceOfDebt(), address(investmentToken)),\r\n                    address(want)\r\n                )\r\n            ); // liabilities\r\n    }\r\n\r\n    // ----------------- SETTERS -----------------\r\n    // we put all together to save contract bytecode (!)\r\n    function setStrategyParams(\r\n        uint16 _targetLTVMultiplier,\r\n        uint16 _warningLTVMultiplier,\r\n        uint256 _acceptableCostsRay,\r\n        uint16 _aaveReferral,\r\n        uint256 _maxTotalBorrowIT,\r\n        bool _isWantIncentivised,\r\n        bool _isInvestmentTokenIncentivised,\r\n        bool _leaveDebtBehind,\r\n        uint256 _maxLoss\r\n    ) external onlyEmergencyAuthorized {\r\n        require(\r\n            _warningLTVMultiplier <= MAX_MULTIPLIER &&\r\n                _targetLTVMultiplier <= _warningLTVMultiplier\r\n        );\r\n        targetLTVMultiplier = _targetLTVMultiplier;\r\n        warningLTVMultiplier = _warningLTVMultiplier;\r\n        acceptableCostsRay = _acceptableCostsRay;\r\n        maxTotalBorrowIT = _maxTotalBorrowIT;\r\n        referral = _aaveReferral;\r\n        isWantIncentivised = _isWantIncentivised;\r\n        isInvestmentTokenIncentivised = _isInvestmentTokenIncentivised;\r\n        leaveDebtBehind = _leaveDebtBehind;\r\n        maxLoss = _maxLoss;\r\n    }\r\n\r\n    // Where to route token swaps\r\n    // Access control is stricter in this method as it will be sent funds\r\n    function setSwapRouter(ISwap _router) external onlyGovernance {\r\n        router = _router;\r\n    }\r\n\r\n    function _initializeThis(address _yVault, string memory _strategyName)\r\n        internal\r\n    {\r\n        yVault = IVault(_yVault);\r\n        investmentToken = IERC20(IVault(_yVault).token());\r\n        (address _aToken, , ) =\r\n            _protocolDataProvider().getReserveTokensAddresses(address(want));\r\n        aToken = IAToken(_aToken);\r\n        (, , address _variableDebtToken) =\r\n            _protocolDataProvider().getReserveTokensAddresses(\r\n                address(investmentToken)\r\n            );\r\n\r\n        variableDebtToken = IVariableDebtToken(_variableDebtToken);\r\n        minThreshold = (10**(yVault.decimals())).div(100); // 0.01 minThreshold\r\n\r\n        // Set default router to SushiSwap\r\n        router = ISwap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n\r\n        strategyName = _strategyName;\r\n    }\r\n\r\n    function initialize(\r\n        address _vault,\r\n        address _yVault,\r\n        string memory _strategyName\r\n    ) public {\r\n        address sender = msg.sender;\r\n        _initialize(_vault, sender, sender, sender);\r\n        _initializeThis(_yVault, _strategyName);\r\n    }\r\n\r\n    // ----------------- MAIN STRATEGY FUNCTIONS -----------------\r\n    function prepareReturn(uint256 _debtOutstanding)\r\n        internal\r\n        override\r\n        returns (\r\n            uint256 _profit,\r\n            uint256 _loss,\r\n            uint256 _debtPayment\r\n        )\r\n    {\r\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\r\n\r\n        // claim rewards from Aave's Liquidity Mining Program\r\n        _claimRewards();\r\n\r\n        // claim rewards from yVault\r\n        _takeVaultProfit();\r\n\r\n        uint256 totalAssetsAfterProfit = estimatedTotalAssets();\r\n\r\n        _profit = totalAssetsAfterProfit > totalDebt\r\n            ? totalAssetsAfterProfit.sub(totalDebt)\r\n            : 0;\r\n\r\n        uint256 _amountFreed;\r\n        (_amountFreed, _loss) = liquidatePosition(\r\n            _debtOutstanding.add(_profit)\r\n        );\r\n        _debtPayment = Math.min(_debtOutstanding, _amountFreed);\r\n\r\n        if (_loss > _profit) {\r\n            // Example:\r\n            // debtOutstanding 100, profit 50, _amountFreed 100, _loss 50\r\n            // loss should be 0, (50-50)\r\n            // profit should endup in 0\r\n            _loss = _loss.sub(_profit);\r\n            _profit = 0;\r\n        } else {\r\n            // Example:\r\n            // debtOutstanding 100, profit 50, _amountFreed 140, _loss 10\r\n            // _profit should be 40, (50 profit - 10 loss)\r\n            // loss should end up in be 0\r\n            _profit = _profit.sub(_loss);\r\n            _loss = 0;\r\n        }\r\n    }\r\n\r\n    function adjustPosition(uint256 _debtOutstanding) internal override {\r\n        uint256 wantBalance = balanceOfWant();\r\n\r\n        // if we have enough want to deposit more into Aave, we do\r\n        // NOTE: we do not skip the rest of the function if we don't as it may need to repay or take on more debt\r\n        if (wantBalance > _debtOutstanding) {\r\n            uint256 amountToDeposit = wantBalance.sub(_debtOutstanding);\r\n            _depositToAave(amountToDeposit);\r\n        }\r\n\r\n        // NOTE: debt + collateral calcs are done in ETH\r\n        (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            ,\r\n\r\n        ) = _getAaveUserAccountData();\r\n\r\n        // if there is no want deposited into aave, don't do nothing\r\n        // this means no debt is borrowed from aave too\r\n        if (totalCollateralETH == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 currentLTV = totalDebtETH.mul(MAX_BPS).div(totalCollateralETH);\r\n        uint256 targetLTV = _getTargetLTV(currentLiquidationThreshold); // 60% under liquidation Threshold\r\n        uint256 warningLTV = _getWarningLTV(currentLiquidationThreshold); // 80% under liquidation Threshold\r\n\r\n        // decide in which range we are and act accordingly:\r\n        // SUBOPTIMAL(borrow) (e.g. from 0 to 60% liqLTV)\r\n        // HEALTHY(do nothing) (e.g. from 60% to 80% liqLTV)\r\n        // UNHEALTHY(repay) (e.g. from 80% to 100% liqLTV)\r\n\r\n        // we use our target cost of capital to calculate how much debt we can take on / how much debt we need to repay\r\n        // in order to bring costs back to an acceptable range\r\n        // currentProtocolDebt => total amount of debt taken by all Aave's borrowers\r\n        // maxProtocolDebt => amount of total debt at which the cost of capital is equal to our acceptable costs\r\n        // if the current protocol debt is higher than the max protocol debt, we will repay debt\r\n        (\r\n            uint256 currentProtocolDebt,\r\n            uint256 maxProtocolDebt,\r\n            uint256 targetUtilisationRay\r\n        ) =\r\n            AaveLenderBorrowerLib.calcMaxDebt(\r\n                address(investmentToken),\r\n                acceptableCostsRay\r\n            );\r\n\r\n        if (targetLTV > currentLTV && currentProtocolDebt < maxProtocolDebt) {\r\n            // SUBOPTIMAL RATIO: our current Loan-to-Value is lower than what we want\r\n            // AND costs are lower than our max acceptable costs\r\n\r\n            // we need to take on more debt\r\n            uint256 targetDebtETH =\r\n                totalCollateralETH.mul(targetLTV).div(MAX_BPS);\r\n\r\n            uint256 amountToBorrowETH = targetDebtETH.sub(totalDebtETH); // safe bc we checked ratios\r\n            amountToBorrowETH = Math.min(\r\n                availableBorrowsETH,\r\n                amountToBorrowETH\r\n            );\r\n\r\n            // cap the amount of debt we are taking according to our acceptable costs\r\n            // if with the new loan we are increasing our cost of capital over what is healthy\r\n            if (currentProtocolDebt.add(amountToBorrowETH) > maxProtocolDebt) {\r\n                // Can't underflow because it's checked in the previous if condition\r\n                amountToBorrowETH = maxProtocolDebt.sub(currentProtocolDebt);\r\n            }\r\n\r\n            uint256 maxTotalBorrowETH =\r\n                _toETH(maxTotalBorrowIT, address(investmentToken));\r\n            if (totalDebtETH.add(amountToBorrowETH) > maxTotalBorrowETH) {\r\n                amountToBorrowETH = maxTotalBorrowETH > totalDebtETH\r\n                    ? maxTotalBorrowETH.sub(totalDebtETH)\r\n                    : 0;\r\n            }\r\n\r\n            // convert to InvestmentToken\r\n            uint256 amountToBorrowIT =\r\n                _fromETH(amountToBorrowETH, address(investmentToken));\r\n\r\n            if (amountToBorrowIT > 0) {\r\n                _lendingPool().borrow(\r\n                    address(investmentToken),\r\n                    amountToBorrowIT,\r\n                    2,\r\n                    referral,\r\n                    address(this)\r\n                );\r\n            }\r\n        } else if (\r\n            currentLTV > warningLTV || currentProtocolDebt > maxProtocolDebt\r\n        ) {\r\n            // UNHEALTHY RATIO\r\n            // we may be in this case if the current cost of capital is higher than our max cost of capital\r\n            // we repay debt to set it to targetLTV\r\n            uint256 targetDebtETH =\r\n                targetLTV.mul(totalCollateralETH).div(MAX_BPS);\r\n            uint256 amountToRepayETH =\r\n                targetDebtETH < totalDebtETH\r\n                    ? totalDebtETH.sub(targetDebtETH)\r\n                    : 0;\r\n\r\n            if (maxProtocolDebt == 0) {\r\n                amountToRepayETH = totalDebtETH;\r\n            } else if (currentProtocolDebt > maxProtocolDebt) {\r\n                // NOTE: take into account that we are withdrawing from yvVault which might have a GenLender lending to Aave\r\n                // REPAY = (currentProtocolDebt - maxProtocolDebt) / (1 - TargetUtilisation)\r\n                // coming from\r\n                // TargetUtilisation = (totalDebt - REPAY) / (currentLiquidity - REPAY)\r\n                // currentLiquidity = maxProtocolDebt / TargetUtilisation\r\n\r\n                uint256 iterativeRepayAmountETH =\r\n                    currentProtocolDebt\r\n                        .sub(maxProtocolDebt)\r\n                        .mul(WadRayMath.RAY)\r\n                        .div(uint256(WadRayMath.RAY).sub(targetUtilisationRay));\r\n                amountToRepayETH = Math.max(\r\n                    amountToRepayETH,\r\n                    iterativeRepayAmountETH\r\n                );\r\n            }\r\n            emit RepayDebt(amountToRepayETH, totalDebtETH);\r\n\r\n            uint256 amountToRepayIT =\r\n                _fromETH(amountToRepayETH, address(investmentToken));\r\n            uint256 withdrawnIT = _withdrawFromYVault(amountToRepayIT); // we withdraw from investmentToken vault\r\n            _repayInvestmentTokenDebt(withdrawnIT); // we repay the investmentToken debt with Aave\r\n        }\r\n\r\n        uint256 balanceIT = balanceOfInvestmentToken();\r\n        if (balanceIT > 0) {\r\n            _checkAllowance(\r\n                address(yVault),\r\n                address(investmentToken),\r\n                balanceIT\r\n            );\r\n\r\n            yVault.deposit();\r\n        }\r\n    }\r\n\r\n    function liquidateAllPositions()\r\n        internal\r\n        override\r\n        returns (uint256 _amountFreed)\r\n    {\r\n        (_amountFreed, ) = liquidatePosition(estimatedTotalAssets());\r\n    }\r\n\r\n    function liquidatePosition(uint256 _amountNeeded)\r\n        internal\r\n        override\r\n        returns (uint256 _liquidatedAmount, uint256 _loss)\r\n    {\r\n        uint256 balance = balanceOfWant();\r\n        // if we have enough want to take care of the liquidatePosition without actually liquidating positons\r\n        if (balance >= _amountNeeded) {\r\n            return (_amountNeeded, 0);\r\n        }\r\n        // NOTE: amountNeeded is in want\r\n        // NOTE: repayment amount is in investmentToken\r\n        // NOTE: collateral and debt calcs are done in ETH (always, see Aave docs)\r\n\r\n        // We first repay whatever we need to repay to keep healthy ratios\r\n        uint256 amountToRepayIT = _calculateAmountToRepay(_amountNeeded);\r\n        uint256 withdrawnIT = _withdrawFromYVault(amountToRepayIT); // we withdraw from investmentToken vault\r\n        _repayInvestmentTokenDebt(withdrawnIT); // we repay the investmentToken debt with Aave\r\n\r\n        // it will return the free amount of want\r\n        _withdrawWantFromAave(_amountNeeded);\r\n\r\n        balance = balanceOfWant();\r\n        // we check if we withdrew less than expected AND should buy investmentToken with want (realising losses)\r\n        if (\r\n            _amountNeeded > balance &&\r\n            balanceOfDebt() > 0 && // still some debt remaining\r\n            balanceOfInvestmentToken().add(_valueOfInvestment()) == 0 && // but no capital to repay\r\n            !leaveDebtBehind // if set to true, the strategy will not try to repay debt by selling want\r\n        ) {\r\n            // using this part of code will result in losses but it is necessary to unlock full collateral in case of wind down\r\n            // we calculate how much want we need to fulfill the want request\r\n            uint256 remainingAmountWant = _amountNeeded.sub(balance);\r\n            // then calculate how much InvestmentToken we need to unlock collateral\r\n            amountToRepayIT = _calculateAmountToRepay(remainingAmountWant);\r\n\r\n            // we buy investmentToken with Want\r\n            _buyInvestmentTokenWithWant(amountToRepayIT);\r\n\r\n            // we repay debt to actually unlock collateral\r\n            // after this, balanceOfDebt should be 0\r\n            _repayInvestmentTokenDebt(amountToRepayIT);\r\n\r\n            // then we try withdraw once more\r\n            _withdrawWantFromAave(remainingAmountWant);\r\n        }\r\n\r\n        uint256 totalAssets = balanceOfWant();\r\n        if (_amountNeeded > totalAssets) {\r\n            _liquidatedAmount = totalAssets;\r\n            _loss = _amountNeeded.sub(totalAssets);\r\n        } else {\r\n            _liquidatedAmount = _amountNeeded;\r\n        }\r\n    }\r\n\r\n    function delegatedAssets() external view override returns (uint256) {\r\n        // returns total debt borrowed in want (which is the delegatedAssets)\r\n        return\r\n            _fromETH(\r\n                _toETH(balanceOfDebt(), address(investmentToken)),\r\n                address(want)\r\n            );\r\n    }\r\n\r\n    function prepareMigration(address _newStrategy) internal override {\r\n        // nothing to do since debt cannot be migrated\r\n    }\r\n\r\n    function harvestTrigger(uint256 callCost)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        // we harvest if:\r\n        // 1. stakedAave is ready to be converted to Aave and sold\r\n\r\n        return\r\n            _checkCooldown() ||\r\n            super.harvestTrigger(_fromETH(callCost, address(want)));\r\n    }\r\n\r\n    function tendTrigger(uint256 callCost) public view override returns (bool) {\r\n        // we adjust position if:\r\n        // 1. LTV ratios are not in the HEALTHY range (either we take on more debt or repay debt)\r\n        // 2. costs are not acceptable and we need to repay debt\r\n        (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            ,\r\n            uint256 currentLiquidationThreshold,\r\n            ,\r\n\r\n        ) = _getAaveUserAccountData();\r\n\r\n        uint256 targetLTV = _getTargetLTV(currentLiquidationThreshold);\r\n        uint256 warningLTV = _getWarningLTV(currentLiquidationThreshold);\r\n\r\n        return\r\n            AaveLenderBorrowerLib.shouldRebalance(\r\n                address(investmentToken),\r\n                acceptableCostsRay,\r\n                targetLTV,\r\n                warningLTV,\r\n                totalCollateralETH,\r\n                totalDebtETH\r\n            );\r\n    }\r\n\r\n    // ----------------- INTERNAL FUNCTIONS SUPPORT -----------------\r\n\r\n    function _withdrawFromYVault(uint256 _amountIT) internal returns (uint256) {\r\n        if (_amountIT == 0) {\r\n            return 0;\r\n        }\r\n        // no need to check allowance bc the contract == token\r\n        uint256 balancePrior = balanceOfInvestmentToken();\r\n        uint256 sharesToWithdraw =\r\n            Math.min(\r\n                _investmentTokenToYShares(_amountIT),\r\n                yVault.balanceOf(address(this))\r\n            );\r\n        if (sharesToWithdraw == 0) {\r\n            return 0;\r\n        }\r\n        yVault.withdraw(sharesToWithdraw, address(this), maxLoss);\r\n        return balanceOfInvestmentToken().sub(balancePrior);\r\n    }\r\n\r\n    function _repayInvestmentTokenDebt(uint256 amount) internal {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        // we cannot pay more than loose balance\r\n        amount = Math.min(amount, balanceOfInvestmentToken());\r\n        // we cannot pay more than we owe\r\n        amount = Math.min(amount, balanceOfDebt());\r\n\r\n        _checkAllowance(\r\n            address(_lendingPool()),\r\n            address(investmentToken),\r\n            amount\r\n        );\r\n\r\n        if (amount > 0) {\r\n            _lendingPool().repay(\r\n                address(investmentToken),\r\n                amount,\r\n                uint256(2),\r\n                address(this)\r\n            );\r\n        }\r\n    }\r\n\r\n    function _claimRewards() internal {\r\n        if (isInvestmentTokenIncentivised || isWantIncentivised) {\r\n            // redeem AAVE from stkAave\r\n            uint256 stkAaveBalance =\r\n                IERC20(address(stkAave)).balanceOf(address(this));\r\n\r\n            if (stkAaveBalance > 0 && _checkCooldown()) {\r\n                // claim AAVE rewards\r\n                stkAave.claimRewards(address(this), type(uint256).max);\r\n                stkAave.redeem(address(this), stkAaveBalance);\r\n            }\r\n\r\n            // sell AAVE for want\r\n            // a minimum balance of 0.01 AAVE is required\r\n            uint256 aaveBalance = IERC20(AAVE).balanceOf(address(this));\r\n            if (aaveBalance > 1e15) {\r\n                _sellAForB(aaveBalance, address(AAVE), address(want));\r\n            }\r\n\r\n            // claim rewards\r\n            // only add to assets those assets that are incentivised\r\n            address[] memory assets;\r\n            if (isInvestmentTokenIncentivised && isWantIncentivised) {\r\n                assets = new address[](2);\r\n                assets[0] = address(aToken);\r\n                assets[1] = address(variableDebtToken);\r\n            } else if (isInvestmentTokenIncentivised) {\r\n                assets = new address[](1);\r\n                assets[0] = address(variableDebtToken);\r\n            } else if (isWantIncentivised) {\r\n                assets = new address[](1);\r\n                assets[0] = address(aToken);\r\n            }\r\n\r\n            _incentivesController().claimRewards(\r\n                assets,\r\n                type(uint256).max,\r\n                address(this)\r\n            );\r\n\r\n            // request start of cooldown period\r\n            uint256 cooldownStartTimestamp =\r\n                IStakedAave(stkAave).stakersCooldowns(address(this));\r\n            uint256 COOLDOWN_SECONDS = IStakedAave(stkAave).COOLDOWN_SECONDS();\r\n            uint256 UNSTAKE_WINDOW = IStakedAave(stkAave).UNSTAKE_WINDOW();\r\n            if (\r\n                IERC20(address(stkAave)).balanceOf(address(this)) > 0 &&\r\n                (cooldownStartTimestamp == 0 ||\r\n                    block.timestamp >\r\n                    cooldownStartTimestamp.add(COOLDOWN_SECONDS).add(\r\n                        UNSTAKE_WINDOW\r\n                    ))\r\n            ) {\r\n                stkAave.cooldown();\r\n            }\r\n        }\r\n    }\r\n\r\n    //withdraw an amount including any want balance\r\n    function _withdrawWantFromAave(uint256 amount) internal {\r\n        uint256 balanceUnderlying = balanceOfAToken();\r\n        if (amount > balanceUnderlying) {\r\n            amount = balanceUnderlying;\r\n        }\r\n\r\n        uint256 maxWithdrawal =\r\n            Math.min(_maxWithdrawal(), want.balanceOf(address(aToken)));\r\n\r\n        uint256 toWithdraw = Math.min(amount, maxWithdrawal);\r\n        if (toWithdraw > 0) {\r\n            _checkAllowance(\r\n                address(_lendingPool()),\r\n                address(aToken),\r\n                toWithdraw\r\n            );\r\n            _lendingPool().withdraw(address(want), toWithdraw, address(this));\r\n        }\r\n    }\r\n\r\n    function _maxWithdrawal() internal view returns (uint256) {\r\n        (uint256 totalCollateralETH, uint256 totalDebtETH, , , uint256 ltv, ) =\r\n            _getAaveUserAccountData();\r\n        uint256 minCollateralETH =\r\n            ltv > 0 ? totalDebtETH.mul(MAX_BPS).div(ltv) : totalCollateralETH;\r\n        if (minCollateralETH > totalCollateralETH) {\r\n            return 0;\r\n        }\r\n        return\r\n            _fromETH(totalCollateralETH.sub(minCollateralETH), address(want));\r\n    }\r\n\r\n    function _calculateAmountToRepay(uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (amount == 0) {\r\n            return 0;\r\n        }\r\n        // we check if the collateral that we are withdrawing leaves us in a risky range, we then take action\r\n        (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            ,\r\n            uint256 currentLiquidationThreshold,\r\n            ,\r\n\r\n        ) = _getAaveUserAccountData();\r\n        uint256 warningLTV = _getWarningLTV(currentLiquidationThreshold);\r\n        uint256 targetLTV = _getTargetLTV(currentLiquidationThreshold);\r\n        uint256 amountETH = _toETH(amount, address(want));\r\n        return\r\n            AaveLenderBorrowerLib.calculateAmountToRepay(\r\n                amountETH,\r\n                totalCollateralETH,\r\n                totalDebtETH,\r\n                warningLTV,\r\n                targetLTV,\r\n                address(investmentToken),\r\n                minThreshold\r\n            );\r\n    }\r\n\r\n    function _depositToAave(uint256 amount) internal {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        ILendingPool lp = _lendingPool();\r\n        _checkAllowance(address(lp), address(want), amount);\r\n        lp.deposit(address(want), amount, address(this), referral);\r\n    }\r\n\r\n    function _checkCooldown() internal view returns (bool) {\r\n        return\r\n            AaveLenderBorrowerLib.checkCooldown(\r\n                isWantIncentivised,\r\n                isInvestmentTokenIncentivised,\r\n                address(stkAave)\r\n            );\r\n    }\r\n\r\n    function _checkAllowance(\r\n        address _contract,\r\n        address _token,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (IERC20(_token).allowance(address(this), _contract) < _amount) {\r\n            IERC20(_token).safeApprove(_contract, 0);\r\n            IERC20(_token).safeApprove(_contract, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    function _takeVaultProfit() internal {\r\n        uint256 _debt = balanceOfDebt();\r\n        uint256 _valueInVault = _valueOfInvestment();\r\n        if (_debt >= _valueInVault) {\r\n            return;\r\n        }\r\n\r\n        uint256 profit = _valueInVault.sub(_debt);\r\n        uint256 ySharesToWithdraw = _investmentTokenToYShares(profit);\r\n        if (ySharesToWithdraw > 0) {\r\n            yVault.withdraw(ySharesToWithdraw, address(this), maxLoss);\r\n            _sellAForB(\r\n                balanceOfInvestmentToken(),\r\n                address(investmentToken),\r\n                address(want)\r\n            );\r\n        }\r\n    }\r\n\r\n    // ----------------- INTERNAL CALCS -----------------\r\n    function balanceOfWant() internal view returns (uint256) {\r\n        return want.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfInvestmentToken() internal view returns (uint256) {\r\n        return investmentToken.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfAToken() internal view returns (uint256) {\r\n        return aToken.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfDebt() internal view returns (uint256) {\r\n        return variableDebtToken.balanceOf(address(this));\r\n    }\r\n\r\n    function _valueOfInvestment() internal view returns (uint256) {\r\n        return\r\n            yVault.balanceOf(address(this)).mul(yVault.pricePerShare()).div(\r\n                10**yVault.decimals()\r\n            );\r\n    }\r\n\r\n    function _investmentTokenToYShares(uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return amount.mul(10**yVault.decimals()).div(yVault.pricePerShare());\r\n    }\r\n\r\n    function _getAaveUserAccountData()\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        )\r\n    {\r\n        return _lendingPool().getUserAccountData(address(this));\r\n    }\r\n\r\n    function _getTargetLTV(uint256 liquidationThreshold)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            liquidationThreshold.mul(uint256(targetLTVMultiplier)).div(MAX_BPS);\r\n    }\r\n\r\n    function _getWarningLTV(uint256 liquidationThreshold)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            liquidationThreshold.mul(uint256(warningLTVMultiplier)).div(\r\n                MAX_BPS\r\n            );\r\n    }\r\n\r\n    // ----------------- TOKEN CONVERSIONS -----------------\r\n    function getTokenOutPath(address _token_in, address _token_out)\r\n        internal\r\n        pure\r\n        returns (address[] memory _path)\r\n    {\r\n        bool is_weth =\r\n            _token_in == address(WETH) || _token_out == address(WETH);\r\n        _path = new address[](is_weth ? 2 : 3);\r\n        _path[0] = _token_in;\r\n\r\n        if (is_weth) {\r\n            _path[1] = _token_out;\r\n        } else {\r\n            _path[1] = address(WETH);\r\n            _path[2] = _token_out;\r\n        }\r\n    }\r\n\r\n    function _sellAForB(\r\n        uint256 _amount,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal {\r\n        if (_amount == 0 || tokenA == tokenB) {\r\n            return;\r\n        }\r\n\r\n        _checkAllowance(address(router), tokenA, _amount);\r\n        router.swapExactTokensForTokens(\r\n            _amount,\r\n            0,\r\n            getTokenOutPath(tokenA, tokenB),\r\n            address(this),\r\n            now\r\n        );\r\n    }\r\n\r\n    function _buyInvestmentTokenWithWant(uint256 _amount) internal {\r\n        if (_amount == 0 || address(investmentToken) == address(want)) {\r\n            return;\r\n        }\r\n\r\n        _checkAllowance(address(router), address(want), _amount);\r\n        router.swapTokensForExactTokens(\r\n            _amount,\r\n            type(uint256).max,\r\n            getTokenOutPath(address(want), address(investmentToken)),\r\n            address(this),\r\n            now\r\n        );\r\n    }\r\n\r\n    function _toETH(uint256 _amount, address asset)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (\r\n            _amount == 0 ||\r\n            _amount == type(uint256).max ||\r\n            address(asset) == address(WETH) // 1:1 change\r\n        ) {\r\n            return _amount;\r\n        }\r\n        return AaveLenderBorrowerLib.toETH(_amount, asset);\r\n    }\r\n\r\n    function ethToWant(uint256 _amtInWei)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _fromETH(_amtInWei, address(want));\r\n    }\r\n\r\n    function _fromETH(uint256 _amount, address asset)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (\r\n            _amount == 0 ||\r\n            _amount == type(uint256).max ||\r\n            address(asset) == address(WETH) // 1:1 change\r\n        ) {\r\n            return _amount;\r\n        }\r\n        return AaveLenderBorrowerLib.fromETH(_amount, asset);\r\n    }\r\n\r\n    // ----------------- INTERNAL SUPPORT GETTERS -----------------\r\n\r\n    function _lendingPool() internal view returns (ILendingPool lendingPool) {\r\n        return AaveLenderBorrowerLib.lendingPool();\r\n    }\r\n\r\n    function _protocolDataProvider()\r\n        internal\r\n        view\r\n        returns (IProtocolDataProvider protocolDataProvider)\r\n    {\r\n        return AaveLenderBorrowerLib.protocolDataProvider;\r\n    }\r\n\r\n    function _priceOracle() internal view returns (IPriceOracle) {\r\n        return AaveLenderBorrowerLib.priceOracle();\r\n    }\r\n\r\n    function _incentivesController()\r\n        internal\r\n        view\r\n        returns (IAaveIncentivesController)\r\n    {\r\n        return\r\n            AaveLenderBorrowerLib.incentivesController(\r\n                aToken,\r\n                variableDebtToken,\r\n                isWantIncentivised,\r\n                isInvestmentTokenIncentivised\r\n            );\r\n    }\r\n\r\n    function protectedTokens()\r\n        internal\r\n        view\r\n        override\r\n        returns (address[] memory)\r\n    {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investmentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_acceptableCostsRay\",\"type\":\"uint256\"}],\"name\":\"calcMaxDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentProtocolDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProtocolDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetU\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"warningLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetLTV\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"investmentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minThreshold\",\"type\":\"uint256\"}],\"name\":\"calculateAmountToRepay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isWantIncentivised\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isInvestmentTokenIncentivised\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"stkAave\",\"type\":\"address\"}],\"name\":\"checkCooldown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"fromETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAToken\",\"name\":\"aToken\",\"type\":\"IAToken\"},{\"internalType\":\"contract IVariableDebtToken\",\"name\":\"variableDebtToken\",\"type\":\"IVariableDebtToken\"},{\"internalType\":\"bool\",\"name\":\"isWantIncentivised\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isInvestmentTokenIncentivised\",\"type\":\"bool\"}],\"name\":\"incentivesController\",\"outputs\":[{\"internalType\":\"contract IAaveIncentivesController\",\"name\":\"\",\"type\":\"IAaveIncentivesController\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"ILendingPool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"IPriceOracle\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolDataProvider\",\"outputs\":[{\"internalType\":\"contract IProtocolDataProvider\",\"name\":\"\",\"type\":\"IProtocolDataProvider\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investmentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptableCostsRay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"warningLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"}],\"name\":\"shouldRebalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"toETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AaveLenderBorrowerLib","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4b4df2f8c05d1984b781eb6f43eee8295d7a512bc15649d5710a9d5f71e36788"}]}