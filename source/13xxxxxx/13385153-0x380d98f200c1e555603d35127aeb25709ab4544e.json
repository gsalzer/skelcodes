{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath#mul: OVERFLOW\");\r\n\r\n    return c;\r\n  }\r\n  \r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath#div: DIVISION_BY_ZERO\");\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath#sub: UNDERFLOW\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath#add: OVERFLOW\");\r\n\r\n    return c; \r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath#mod: DIVISION_BY_ZERO\");\r\n    return a % b;\r\n  }\r\n\r\n}\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { codehash := extcodehash(account) }\r\n    return (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\n\r\ncontract Context {\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == owner;\r\n    }\r\n    \r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n    \r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address payable newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface CosmoChamber {\r\n    function authorizedGenerator(uint256 _amount, address receiver) external;\r\n}\r\n\r\ncontract Whitelist is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    CosmoChamber cosmoChamber;\r\n    \r\n    event NewNFTPrice(uint256 indexed _newprice);\r\n    \r\n    uint256 public NFTprice = 0.03 * 10**18;\r\n\tmapping (address => bool) public IfWhiteList;\r\n    \r\n\tconstructor(\r\n\t\taddress cosmoChamberAddress\r\n\t) public {\r\n\t\tcosmoChamber = CosmoChamber(cosmoChamberAddress);\r\n\t}\r\n\t\r\n\tfunction mint(uint _amount) public payable {\r\n\t    require(msg.value >= NFTprice.mul(_amount), \"Insufficient ETH\");\r\n\t    require(_amount > 0 && _amount <= 2, \"Invalid amount\");\r\n\t    require(_ifWhiteListed(msg.sender), \"Unqualified!\");\r\n        IfWhiteList[msg.sender] = false;\r\n\t    cosmoChamber.authorizedGenerator(_amount, msg.sender);\r\n\t}\r\n\t\r\n\tfunction setWhitelist(address[] memory _users) public onlyOwner {\r\n\t    uint userLength = _users.length;\r\n\t    for (uint i = 0; i < userLength; i++) {\r\n\t        IfWhiteList[_users[i]] = true;\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction _ifWhiteListed(address _user) private view returns(bool) {\r\n\t    return IfWhiteList[_user];\r\n\t}\r\n\t\r\n\tfunction setNFTPrice(uint256 _newPrice) public onlyOwner {\r\n\t    require(_newPrice > 0);\r\n\t    NFTprice = _newPrice;\r\n\t    emit NewNFTPrice(_newPrice);\r\n\t}\r\n}\r\n\r\ncontract CosmoChamberWhiteList is Whitelist {\r\n    constructor(address _cosmoChamberAddress) public Whitelist(_cosmoChamberAddress) {\r\n\t\t\r\n\t}\r\n\t\r\n\tfunction withdrawBalance() external onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cosmoChamberAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newprice\",\"type\":\"uint256\"}],\"name\":\"NewNFTPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"IfWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NFTprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setNFTPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CosmoChamberWhiteList","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005ab97a44d024871ba1c0df8c9be97387bbe844c8","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e478160abab98946407ed4c6dd2b40bd4c81bfa828aff6258c7c479cf9f53b29"}]}