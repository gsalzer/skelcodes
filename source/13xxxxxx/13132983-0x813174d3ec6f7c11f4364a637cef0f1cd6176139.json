{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/claims/Claims.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/LegacyMasterAware.sol\\\";\\nimport \\\"../../interfaces/IClaims.sol\\\";\\nimport \\\"../../interfaces/IClaimsData.sol\\\";\\nimport \\\"../../interfaces/IClaimsReward.sol\\\";\\nimport \\\"../../interfaces/IIncidents.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/IQuotationData.sol\\\";\\nimport \\\"../../interfaces/ITokenController.sol\\\";\\nimport \\\"../../interfaces/ITokenData.sol\\\";\\n\\ncontract Claims is IClaims, LegacyMasterAware {\\n  using SafeMath for uint;\\n\\n  ITokenController internal tc;\\n  IClaimsReward internal cr;\\n  IPool internal p1;\\n  IClaimsData internal cd;\\n  ITokenData internal td;\\n  IQuotationData internal qd;\\n  IIncidents internal incidents;\\n\\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\\n\\n  /**\\n   * @dev Sets the status of claim using claim id.\\n   * @param claimId claim id.\\n   * @param stat status to be set.\\n   */\\n  function setClaimStatus(uint claimId, uint stat) external onlyInternal {\\n    _setClaimStatus(claimId, stat);\\n  }\\n\\n  /**\\n   * @dev Calculates total amount that has been used to assess a claim.\\n   * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\\n   * denyCA(tokens used for voting against a claim) *  current token price.\\n   * @param claimId Claim Id.\\n   * @param member Member type 0 -> Claim Assessors, else members.\\n   * @return tokens Total Amount used in Claims assessment.\\n   */\\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens) {\\n    uint coverId;\\n    (, coverId) = cd.getClaimCoverId(claimId);\\n\\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\\n    address asset = cr.getCurrencyAssetAddress(currency);\\n    uint tokenx1e18 = p1.getTokenPrice(asset);\\n\\n    uint accept;\\n    uint deny;\\n    if (member == 0) {\\n      (, accept, deny) = cd.getClaimsTokenCA(claimId);\\n    } else {\\n      (, accept, deny) = cd.getClaimsTokenMV(claimId);\\n    }\\n    tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\\n  }\\n\\n  /**\\n   * Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {\\n    td = ITokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    tc = ITokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    p1 = IPool(ms.getLatestAddress(\\\"P1\\\"));\\n    cr = IClaimsReward(ms.getLatestAddress(\\\"CR\\\"));\\n    cd = IClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    qd = IQuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    incidents = IIncidents(ms.getLatestAddress(\\\"IC\\\"));\\n  }\\n\\n  /**\\n   * @dev Submits a claim for a given cover note.\\n   * Adds claim to queue incase of emergency pause else directly submits the claim.\\n   * @param coverId Cover Id.\\n   */\\n  function submitClaim(uint coverId) external {\\n    _submitClaim(coverId, msg.sender);\\n  }\\n\\n  function submitClaimForMember(uint coverId, address member) external onlyInternal {\\n    _submitClaim(coverId, member);\\n  }\\n\\n  function _submitClaim(uint coverId, address member) internal {\\n\\n    require(!ms.isPause(), \\\"Claims: System is paused\\\");\\n\\n    (/* id */, address contractAddress) = qd.getscAddressOfCover(coverId);\\n    address token = incidents.coveredToken(contractAddress);\\n    require(token == address(0), \\\"Claims: Product type does not allow claims\\\");\\n\\n    address coverOwner = qd.getCoverMemberAddress(coverId);\\n    require(coverOwner == member, \\\"Claims: Not cover owner\\\");\\n\\n    uint expirationDate = qd.getValidityOfCover(coverId);\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    require(expirationDate.add(gracePeriod) > now, \\\"Claims: Grace period has expired\\\");\\n\\n    tc.markCoverClaimOpen(coverId);\\n    qd.changeCoverStatusNo(coverId, uint8(IQuotationData.CoverStatus.ClaimSubmitted));\\n\\n    uint claimId = cd.actualClaimLength();\\n    cd.addClaim(claimId, coverId, coverOwner, now);\\n    cd.callClaimEvent(coverId, coverOwner, claimId, now);\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function submitClaimAfterEPOff() external pure {}\\n\\n  /**\\n   * @dev Castes vote for members who have tokens locked under Claims Assessment\\n   * @param claimId  claim id.\\n   * @param verdict 1 for Accept,-1 for Deny.\\n   */\\n  function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\\n    require(checkVoteClosing(claimId) != 1);\\n    require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);\\n    uint tokens = tc.tokensLockedAtTime(msg.sender, \\\"CLA\\\", now.add(cd.claimDepositTime()));\\n    require(tokens > 0);\\n    uint stat;\\n    (, stat) = cd.getClaimStatusNumber(claimId);\\n    require(stat == 0);\\n    require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\\n    td.bookCATokens(msg.sender);\\n    cd.addVote(msg.sender, tokens, claimId, verdict);\\n    cd.callVoteEvent(msg.sender, claimId, \\\"CAV\\\", tokens, now, verdict);\\n    uint voteLength = cd.getAllVoteLength();\\n    cd.addClaimVoteCA(claimId, voteLength);\\n    cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\\n    cd.setClaimTokensCA(claimId, verdict, tokens);\\n    tc.extendLockOf(msg.sender, \\\"CLA\\\", td.lockCADays());\\n    int close = checkVoteClosing(claimId);\\n    if (close == 1) {\\n      cr.changeClaimStatus(claimId);\\n    }\\n  }\\n\\n  /**\\n   * @dev Submits a member vote for assessing a claim.\\n   * Tokens other than those locked under Claims\\n   * Assessment can be used to cast a vote for a given claim id.\\n   * @param claimId Selected claim id.\\n   * @param verdict 1 for Accept,-1 for Deny.\\n   */\\n  function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\\n    require(checkVoteClosing(claimId) != 1);\\n    uint stat;\\n    uint tokens = tc.totalBalanceOf(msg.sender);\\n    (, stat) = cd.getClaimStatusNumber(claimId);\\n    require(stat >= 1 && stat <= 5);\\n    require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\\n    cd.addVote(msg.sender, tokens, claimId, verdict);\\n    cd.callVoteEvent(msg.sender, claimId, \\\"MV\\\", tokens, now, verdict);\\n    tc.lockForMemberVote(msg.sender, td.lockMVDays());\\n    uint voteLength = cd.getAllVoteLength();\\n    cd.addClaimVotemember(claimId, voteLength);\\n    cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\\n    cd.setClaimTokensMV(claimId, verdict, tokens);\\n    int close = checkVoteClosing(claimId);\\n    if (close == 1) {\\n      cr.changeClaimStatus(claimId);\\n    }\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function pauseAllPendingClaimsVoting() external pure {}\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function startAllPendingClaimsVoting() external pure {}\\n\\n  /**\\n   * @dev Checks if voting of a claim should be closed or not.\\n   * @param claimId Claim Id.\\n   * @return close 1 -> voting should be closed, 0 -> if voting should not be closed,\\n   * -1 -> voting has already been closed.\\n   */\\n  function checkVoteClosing(uint claimId) public view returns (int8 close) {\\n    close = 0;\\n    uint status;\\n    (, status) = cd.getClaimStatusNumber(claimId);\\n    uint dateUpd = cd.getClaimDateUpd(claimId);\\n    if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {\\n      if (cd.getClaimState12Count(claimId) < 60)\\n        close = 1;\\n    }\\n\\n    if (status > 5 && status != 12) {\\n      close = - 1;\\n    } else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {\\n      close = 1;\\n    } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {\\n      close = 0;\\n    } else if (status == 0 || (status >= 1 && status <= 5)) {\\n      close = _checkVoteClosingFinal(claimId, status);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Checks if voting of a claim should be closed or not.\\n   * Internally called by checkVoteClosing method\\n   * for Claims whose status number is 0 or status number lie between 2 and 6.\\n   * @param claimId Claim Id.\\n   * @param status Current status of claim.\\n   * @return close 1 if voting should be closed,0 in case voting should not be closed,\\n   * -1 if voting has already been closed.\\n   */\\n  function _checkVoteClosingFinal(uint claimId, uint status) internal view returns (int8 close) {\\n    close = 0;\\n    uint coverId;\\n    (, coverId) = cd.getClaimCoverId(claimId);\\n\\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\\n    address asset = cr.getCurrencyAssetAddress(currency);\\n    uint tokenx1e18 = p1.getTokenPrice(asset);\\n\\n    uint accept;\\n    uint deny;\\n    (, accept, deny) = cd.getClaimsTokenCA(claimId);\\n    uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\\n    (, accept, deny) = cd.getClaimsTokenMV(claimId);\\n    uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\\n    uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\\n    if (status == 0 && caTokens >= sumassured.mul(10)) {\\n      close = 1;\\n    } else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {\\n      close = 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Changes the status of an existing claim id, based on current\\n   * status and current conditions of the system\\n   * @param claimId Claim Id.\\n   * @param stat status number.\\n   */\\n  function _setClaimStatus(uint claimId, uint stat) internal {\\n\\n    uint origstat;\\n    uint state12Count;\\n    uint dateUpd;\\n    uint coverId;\\n    (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\\n    (, origstat) = cd.getClaimStatusNumber(claimId);\\n\\n    if (stat == 12 && origstat == 12) {\\n      cd.updateState12Count(claimId, 1);\\n    }\\n    cd.setClaimStatus(claimId, stat);\\n\\n    if (state12Count >= 60 && stat == 12) {\\n      cd.setClaimStatus(claimId, 13);\\n      qd.changeCoverStatusNo(coverId, uint8(IQuotationData.CoverStatus.ClaimDenied));\\n    }\\n\\n    cd.setClaimdateUpd(claimId, now);\\n  }\\n\\n  /**\\n   * @dev Gets details of a given claim id.\\n   * @param _claimId Claim Id.\\n   * @return status Current status of claim id\\n   * @return finalVerdict Decision made on the claim, 1 -> acceptance, -1 -> denial\\n   * @return claimOwner Address through which claim is submitted\\n   * @return coverId Coverid associated with the claim id\\n  */\\n  function getClaimbyIndex(uint _claimId) external view returns (\\n    uint claimId,\\n    uint status,\\n    int8 finalVerdict,\\n    address claimOwner,\\n    uint coverId\\n  ) {\\n    (, coverId, finalVerdict, status,,) = cd.getClaim(_claimId);\\n    claimId = _claimId;\\n    claimOwner = qd.getCoverMemberAddress(coverId);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/LegacyMasterAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../interfaces/INXMMaster.sol\\\";\\n\\ncontract LegacyMasterAware {\\n\\n  INXMMaster public ms;\\n  address public nxMasterAddress;\\n\\n  modifier onlyInternal {\\n    require(ms.isInternal(msg.sender));\\n    _;\\n  }\\n\\n  modifier isMemberAndcheckPause {\\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\\n    _;\\n  }\\n\\n  modifier onlyOwner {\\n    require(ms.isOwner(msg.sender));\\n    _;\\n  }\\n\\n  modifier checkPause {\\n    require(ms.isPause() == false);\\n    _;\\n  }\\n\\n  modifier isMember {\\n    require(ms.isMember(msg.sender), \\\"Not member\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public;\\n\\n  /**\\n   * @dev change master address\\n   * @param _masterAddress is the new address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (address(ms) != address(0)) {\\n      require(address(ms) == msg.sender, \\\"Not master\\\");\\n    }\\n\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaims.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaims {\\n\\n  function setClaimStatus(uint claimId, uint stat) external;\\n\\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens);\\n\\n  function submitClaim(uint coverId) external;\\n\\n  function submitClaimForMember(uint coverId, address member) external;\\n\\n  function submitClaimAfterEPOff() external pure;\\n\\n  function submitCAVote(uint claimId, int8 verdict) external;\\n\\n  function submitMemberVote(uint claimId, int8 verdict) external;\\n\\n  function pauseAllPendingClaimsVoting() external pure;\\n\\n  function startAllPendingClaimsVoting() external pure;\\n\\n  function checkVoteClosing(uint claimId) external view returns (int8 close);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsData {\\n\\n  function pendingClaimStart() external view returns (uint);\\n  function claimDepositTime() external view returns (uint);\\n  function maxVotingTime() external view returns (uint);\\n  function minVotingTime() external view returns (uint);\\n  function payoutRetryTime() external view returns (uint);\\n  function claimRewardPerc() external view returns (uint);\\n  function minVoteThreshold() external view returns (uint);\\n  function maxVoteThreshold() external view returns (uint);\\n  function majorityConsensus() external view returns (uint);\\n  function pauseDaysCA() external view returns (uint);\\n\\n  function userClaimVotePausedOn(address) external view returns (uint);\\n\\n  function setpendingClaimStart(uint _start) external;\\n\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external;\\n\\n  function setUserClaimVotePausedOn(address user) external;\\n\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external;\\n\\n\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  ) external;\\n\\n  function setRewardClaimed(uint _voteid, bool claimed) external;\\n\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external;\\n\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  ) external;\\n\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  ) external;\\n\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function addClaimVotemember(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function updateState12Count(uint _claimId, uint _cnt) external;\\n\\n  function setClaimStatus(uint _claimId, uint _stat) external;\\n\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external;\\n\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  ) external;\\n\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external;\\n\\n\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  ) external;\\n\\n\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  ) external;\\n\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external;\\n\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  ) external;\\n\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  ) external;\\n\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  ) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  );\\n\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getAllVoteLength() external view returns (uint voteCount);\\n\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno);\\n\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV);\\n\\n  function getClaimState12Count(uint _claimId) external view returns (uint num);\\n\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd);\\n\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr);\\n\\n\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt);\\n\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt);\\n\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  );\\n\\n  function getVoterVote(uint _voteid) external view returns (address voter);\\n\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len);\\n\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver);\\n\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok);\\n\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter);\\n\\n  function getUserClaimCount(address _add) external view returns (uint len);\\n\\n  function getClaimLength() external view returns (uint len);\\n\\n  function actualClaimLength() external view returns (uint len);\\n\\n\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  );\\n\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  );\\n\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  );\\n\\n\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  );\\n\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  );\\n\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  );\\n\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid);\\n\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressCALength(address _voter) external view returns (uint);\\n\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint);\\n\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict);\\n\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len);\\n\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit);\\n\\n  function getLengthOfClaimVotingPause() external view returns (uint len);\\n\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  );\\n\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsReward {\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function changeClaimStatus(uint claimid) external;\\n\\n  function getCurrencyAssetAddress(bytes4 currency) external view returns (address);\\n\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  external\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  );\\n\\n  function upgrade(address _newAdd) external;\\n\\n  function getRewardToBeDistributedByUser(address _add) external view returns (uint total);\\n\\n  function getRewardAndClaimedStatus(uint check, uint claimId) external view returns (uint reward, bool claimed);\\n\\n  function claimAllPendingReward(uint records) external;\\n\\n  function getAllPendingRewardOfUser(address _add) external view returns (uint);\\n\\n  function unlockCoverNote(uint coverId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIncidents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IIncidents {\\n\\n  function underlyingToken(address) external view returns (address);\\n\\n  function coveredToken(address) external view returns (address);\\n\\n  function claimPayout(uint) external view returns (uint);\\n\\n  function incidentCount() external view returns (uint);\\n\\n  function addIncident(\\n    address productId,\\n    uint incidentDate,\\n    uint priceBefore\\n  ) external;\\n\\n  function redeemPayoutForMember(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount,\\n    address member\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\\n\\n  function redeemPayout(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\\n\\n  function pushBurns(address productId, uint maxIterations) external;\\n\\n  function withdrawAsset(address asset, address destination, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./IPriceFeedOracle.sol\\\";\\n\\ninterface IPool {\\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\\n\\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\\n\\n  function minPoolEth() external returns (uint);\\n\\n  function transferAssetToSwapOperator(address asset, uint amount) external;\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  );\\n\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external returns (bool success);\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external;\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external;\\n\\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\\n\\n  function getPoolValueInEth() external view returns (uint);\\n\\n\\n  function transferAssetFrom(address asset, address from, uint amount) external;\\n\\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\\n\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) external pure returns (uint);\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\\n\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\\n\\n  function getTokenPrice(address asset) external view returns (uint tokenPrice);\\n\\n  function getMCRRatio() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotationData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotationData {\\n\\n  function authQuoteEngine() external view returns (address);\\n  function stlp() external view returns (uint);\\n  function stl() external view returns (uint);\\n  function pm() external view returns (uint);\\n  function minDays() external view returns (uint);\\n  function tokensRetained() external view returns (uint);\\n  function kycAuthAddress() external view returns (address);\\n\\n  function refundEligible(address) external view returns (bool);\\n  function holdedCoverIDStatus(uint) external view returns (uint);\\n  function timestampRepeated(uint) external view returns (bool);\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function setTimestampRepeated(uint _timestamp) external;\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  ) external;\\n\\n\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  ) external;\\n\\n  function setRefundEligible(address _add, bool status) external;\\n\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external;\\n\\n  function setKycAuthAddress(address _add) external;\\n\\n  function changeAuthQuoteEngine(address _add) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  );\\n\\n  function getCoverLength() external view returns (uint len);\\n\\n  function getAuthQuoteEngine() external view returns (address _add);\\n\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount);\\n\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover);\\n\\n  function getUserCoverLength(address _add) external view returns (uint len);\\n\\n  function getCoverStatusNo(uint _cid) external view returns (uint8);\\n\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp);\\n\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa);\\n\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr);\\n\\n  function getValidityOfCover(uint _cid) external view returns (uint date);\\n\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address);\\n\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add);\\n\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM);\\n\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  );\\n\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  );\\n\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  );\\n\\n  function getUserHoldedCoverLength(address _add) external view returns (uint);\\n\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint);\\n\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  );\\n\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount);\\n\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenController {\\n\\n  function coverInfo(uint id) external view returns (uint16 claimCount, bool hasOpenClaim, bool hasAcceptedClaim);\\n\\n  function claimSubmissionGracePeriod() external view returns (uint);\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external;\\n\\n  function markCoverClaimOpen(uint coverId) external;\\n\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external;\\n\\n  function changeOperator(address _newOperator) external;\\n\\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\\n\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external;\\n\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) external returns (bool);\\n\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external;\\n\\n  function extendClaimAssessmentLock(uint256 _time) external;\\n\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time) external returns (bool);\\n\\n  function increaseClaimAssessmentLock(uint256 _amount) external;\\n\\n  function burnFrom(address _of, uint amount) external returns (bool);\\n\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) external;\\n\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function addToWhitelist(address _member) external;\\n\\n  function removeFromWhitelist(address _member) external;\\n\\n  function mint(address _member, uint _amount) external;\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n  function withdrawClaimAssessmentTokens(address _of) external;\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\\n\\n  function getLockedTokensValidity(address _of, bytes32 reason) external view returns (uint256 validity);\\n\\n  function getUnlockableTokens(address _of) external view returns (uint256 unlockableTokens);\\n\\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  external\\n  view\\n  returns (uint256 amount, uint256 validity);\\n\\n  function tokensUnlockable(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) external view returns (uint256 amount);\\n  function totalBalanceOf(address _of) external view returns (uint256 amount);\\n\\n  function totalLockedBalance(address _of) external view returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenData {\\n\\n  function walletAddress() external view returns (address payable);\\n  function lockTokenTimeAfterCoverExp() external view returns (uint);\\n  function bookTime() external view returns (uint);\\n  function lockCADays() external view returns (uint);\\n  function lockMVDays() external view returns (uint);\\n  function scValidDays() external view returns (uint);\\n  function joiningFee() external view returns (uint);\\n  function stakerCommissionPer() external view returns (uint);\\n  function stakerMaxCommissionPer() external view returns (uint);\\n  function tokenExponent() external view returns (uint);\\n  function priceStep() external view returns (uint);\\n\\n  function depositedCN(uint) external view returns (uint amount, bool isDeposited);\\n\\n  function lastCompletedStakeCommission(address) external view returns (uint);\\n\\n  function changeWalletAddress(address payable _address) external;\\n\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (address stakedContractAddress);\\n\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint burnedAmount);\\n\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint unlockable);\\n\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint scIndex);\\n\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (uint sIndex);\\n\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint length);\\n\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  ) external;\\n\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionEarned);\\n\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionRedeemed);\\n\\n  function setDepositCN(uint coverId, bool flag) external;\\n\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (address stakerAddress);\\n\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  ) external view returns (uint length);\\n\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  ) external returns (uint scIndex);\\n\\n  function bookCATokens(address _of) external;\\n\\n  function isCATokensBooked(address _of) external view returns (bool res);\\n\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  ) external;\\n\\n\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setDepositCNAmount(uint coverId, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMMaster {\\n\\n  function tokenAddress() external view returns (address);\\n\\n  function owner() external view returns (address);\\n\\n  function masterInitialized() external view returns (bool);\\n\\n  function isInternal(address _add) external view returns (bool);\\n\\n  function isPause() external view returns (bool check);\\n\\n  function isOwner(address _add) external view returns (bool);\\n\\n  function isMember(address _add) external view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\\n\\n  function dAppLocker() external view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\\n\\n  function upgradeMultipleContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses\\n  ) external;\\n\\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\\n\\n  function addNewInternalContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses,\\n    uint[] calldata _types\\n  ) external;\\n\\n  function updateOwnerParameters(bytes8 code, address payable val) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPriceFeedOracle {\\n\\n  function daiAddress() external view returns (address);\\n  function stETH() external view returns (address);\\n  function ETH() external view returns (address);\\n\\n  function getAssetToEthRate(address asset) external view returns (uint);\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"}],\"name\":\"checkVoteClosing\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"close\",\"type\":\"int8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"member\",\"type\":\"uint256\"}],\"name\":\"getCATokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimId\",\"type\":\"uint256\"}],\"name\":\"getClaimbyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"finalVerdict\",\"type\":\"int8\"},{\"internalType\":\"address\",\"name\":\"claimOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ms\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMasterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauseAllPendingClaimsVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stat\",\"type\":\"uint256\"}],\"name\":\"setClaimStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAllPendingClaimsVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"verdict\",\"type\":\"int8\"}],\"name\":\"submitCAVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"submitClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submitClaimAfterEPOff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"submitClaimForMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"verdict\",\"type\":\"int8\"}],\"name\":\"submitMemberVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Claims","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}