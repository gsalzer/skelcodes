{"status":"1","message":"OK","result":[{"SourceCode":"/*\n    ___            _       ___  _                          \n    | .\\ ___  _ _ <_> ___ | __><_>._ _  ___ ._ _  ___  ___ \n    |  _// ._>| '_>| ||___|| _> | || ' |<_> || ' |/ | '/ ._>\n    |_|  \\___.|_|  |_|     |_|  |_||_|_|<___||_|_|\\_|_.\\___.\n    \n* PeriFinance: EtherCollateral.sol\n*\n* Latest source (may be newer): https://github.com/perifinance/peri-finance/blob/master/contracts/EtherCollateral.sol\n* Docs: Will be added in the future. \n* https://docs.peri.finance/contracts/source/contracts/EtherCollateral\n*\n* Contract Dependencies: \n*\t- IAddressResolver\n*\t- IEtherCollateral\n*\t- MixinResolver\n*\t- Owned\n*\t- Pausable\n*\t- ReentrancyGuard\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2021 PeriFinance\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity 0.5.16;\n\n// https://docs.peri.finance/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// Inheritance\n\n\n// https://docs.peri.finance/contracts/source/contracts/pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    constructor() internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getPynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ipynth\ninterface IPynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferablePynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to PeriFinance\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anyPynthOrPERIRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availablePynthCount() external view returns (uint);\n\n    function availablePynths(uint index) external view returns (IPynth);\n\n    function canBurnPynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function externalTokenLimit() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuablePynths(address issuer) external view returns (uint maxIssuable);\n\n    function externalTokenQuota(\n        address _account,\n        uint _addtionalpUSD,\n        uint _addtionalExToken,\n        bool _isIssue\n    ) external view returns (uint);\n\n    function maxExternalTokenStakeAmount(address _account, bytes32 _currencyKey)\n        external\n        view\n        returns (uint issueAmountToQuota, uint stakeAmountToQuota);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuablePynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function pynths(bytes32 currencyKey) external view returns (IPynth);\n\n    function getPynths(bytes32[] calldata currencyKeys) external view returns (IPynth[] memory);\n\n    function pynthsByAddress(address pynthAddress) external view returns (bytes32);\n\n    function totalIssuedPynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\n\n    function transferablePeriFinanceAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to PeriFinance\n    function issuePynths(\n        address _issuer,\n        bytes32 _currencyKey,\n        uint _issueAmount\n    ) external;\n\n    function issueMaxPynths(address _issuer) external;\n\n    function issuePynthsToMaxQuota(address _issuer, bytes32 _currencyKey) external;\n\n    function burnPynths(\n        address _from,\n        bytes32 _currencyKey,\n        uint _burnAmount\n    ) external;\n\n    function fitToClaimable(address _from) external;\n\n    function exit(address _from) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint pusdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getPynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.pynths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// solhint-disable payable-fallback\n\n// https://docs.peri.finance/contracts/source/contracts/readproxy\ncontract ReadProxy is Owned {\n    address public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(address _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(target);\n    }\n\n    function() external {\n        // The basics of a proxy read call\n        // Note that msg.sender in the underlying will always be the address of this contract.\n        assembly {\n            calldatacopy(0, 0, calldatasize)\n\n            // Use of staticcall - this will revert if the underlying function mutates state\n            let result := staticcall(gas, sload(target_slot), 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n\n            if iszero(result) {\n                revert(0, returndatasize)\n            }\n            return(0, returndatasize)\n        }\n    }\n\n    event TargetUpdated(address newTarget);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iethercollateral\ninterface IEtherCollateral {\n    // Views\n    function totalIssuedPynths() external view returns (uint256);\n\n    function totalLoansCreated() external view returns (uint256);\n\n    function totalOpenLoanCount() external view returns (uint256);\n\n    // Mutative functions\n    function openLoan() external payable returns (uint256 loanID);\n\n    function closeLoan(uint256 loanID) external;\n\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.peri.finance/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @dev Round down the value with given number\n     */\n    function roundDownDecimal(uint x, uint d) internal pure returns (uint) {\n        return x.div(10**d).mul(10**d);\n    }\n\n    /**\n     * @dev Round up the value with given number\n     */\n    function roundUpDecimal(uint x, uint d) internal pure returns (uint) {\n        uint _decimal = 10**d;\n\n        if (x % _decimal > 0) {\n            x = x.add(10**d);\n        }\n\n        return x.div(_decimal).mul(_decimal);\n    }\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireExchangeBetweenPynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requirePynthActive(bytes32 currencyKey) external view;\n\n    function requirePynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function pynthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function pynthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function getPynthExchangeSuspensions(bytes32[] calldata pynths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getPynthSuspensions(bytes32[] calldata pynths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendPynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    // Restricted: used internally to PeriFinance\n    function appendAccountIssuanceRecord(\n        address account,\n        uint lockedAmount,\n        uint debtEntryIndex\n    ) external;\n\n    function recordFeePaid(uint pUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/idepot\ninterface IDepot {\n    // Views\n    function fundsWallet() external view returns (address payable);\n\n    function maxEthPurchase() external view returns (uint);\n\n    function minimumDepositAmount() external view returns (uint);\n\n    function pynthsReceivedForEther(uint amount) external view returns (uint);\n\n    function totalSellableDeposits() external view returns (uint);\n\n    // Mutative functions\n    function depositPynths(uint amount) external;\n\n    function exchangeEtherForPynths() external payable returns (uint);\n\n    function exchangeEtherForPynthsAtRate(uint guaranteedRate) external payable returns (uint);\n\n    function withdrawMyDepositedPynths() external;\n\n    // Note: On mainnet no PERI has been deposited. The following functions are kept alive for testnet PERI faucets.\n    function exchangeEtherForPERI() external payable returns (uint);\n\n    function exchangeEtherForPERIAtRate(uint guaranteedRate, uint guaranteedPeriFinanceRate) external payable returns (uint);\n\n    function exchangePynthsForPERI(uint pynthAmount) external returns (uint);\n\n    function periFinanceReceivedForEther(uint amount) external view returns (uint);\n\n    function periFinanceReceivedForPynths(uint amount) external view returns (uint);\n\n    function withdrawPeriFinance(uint amount) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    struct InversePricing {\n        uint entryPoint;\n        uint upperLimit;\n        uint lowerLimit;\n        bool frozenAtUpperLimit;\n        bool frozenAtLowerLimit;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\n\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint value);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function inversePricing(bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint entryPoint,\n            uint upperLimit,\n            uint lowerLimit,\n            bool frozenAtUpperLimit,\n            bool frozenAtLowerLimit\n        );\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\n        external\n        view\n        returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    // Mutative functions\n    function freezeRate(bytes32 currencyKey) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/source/contracts/ethercollateral\ncontract EtherCollateral is Owned, Pausable, ReentrancyGuard, MixinResolver, IEtherCollateral {\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    // ========== CONSTANTS ==========\n    uint256 internal constant ONE_THOUSAND = 1e18 * 1000;\n    uint256 internal constant ONE_HUNDRED = 1e18 * 100;\n\n    uint256 internal constant SECONDS_IN_A_YEAR = 31536000; // Common Year\n\n    // Where fees are pooled in pUSD.\n    address internal constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    // ========== SETTER STATE VARIABLES ==========\n\n    // The ratio of Collateral to pynths issued\n    uint256 public collateralizationRatio = SafeDecimalMath.unit() * 125; // SCCP-27\n\n    // If updated, all outstanding loans will pay this interest rate in on closure of the loan. Default 5%\n    uint256 public interestRate = (5 * SafeDecimalMath.unit()) / 100;\n    uint256 public interestPerSecond = interestRate.div(SECONDS_IN_A_YEAR);\n\n    // Minting fee for issuing the pynths. Default 50 bips.\n    uint256 public issueFeeRate = (5 * SafeDecimalMath.unit()) / 1000;\n\n    // Maximum amount of pETH that can be issued by the EtherCollateral contract. Default 5000\n    uint256 public issueLimit = SafeDecimalMath.unit() * 5000;\n\n    // Minimum amount of ETH to create loan preventing griefing and gas consumption. Min 1ETH = 0.8 pETH\n    uint256 public minLoanSize = SafeDecimalMath.unit() * 1;\n\n    // Maximum number of loans an account can create\n    uint256 public accountLoanLimit = 50;\n\n    // If true then any wallet addres can close a loan not just the loan creator.\n    bool public loanLiquidationOpen = false;\n\n    // Time when remaining loans can be liquidated\n    uint256 public liquidationDeadline;\n\n    // ========== STATE VARIABLES ==========\n\n    // The total number of pynths issued by the collateral in this contract\n    uint256 public totalIssuedPynths;\n\n    // Total number of loans ever created\n    uint256 public totalLoansCreated;\n\n    // Total number of open loans\n    uint256 public totalOpenLoanCount;\n\n    // Pynth loan storage struct\n    struct PynthLoanStruct {\n        //  Acccount that created the loan\n        address account;\n        //  Amount (in collateral token ) that they deposited\n        uint256 collateralAmount;\n        //  Amount (in pynths) that they issued to borrow\n        uint256 loanAmount;\n        // When the loan was created\n        uint256 timeCreated;\n        // ID for the loan\n        uint256 loanID;\n        // When the loan was paidback (closed)\n        uint256 timeClosed;\n    }\n\n    // Users Loans by address\n    mapping(address => PynthLoanStruct[]) public accountsPynthLoans;\n\n    // Account Open Loan Counter\n    mapping(address => uint256) public accountOpenLoanCounter;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_PYNTHPETH = \"PynthpETH\";\n    bytes32 private constant CONTRACT_PYNTHPUSD = \"PynthpUSD\";\n    bytes32 private constant CONTRACT_DEPOT = \"Depot\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n\n    // ========== CONSTRUCTOR ==========\n    constructor(address _owner, address _resolver) public Owned(_owner) Pausable() MixinResolver(_resolver) {\n        liquidationDeadline = now + 92 days; // Time before loans can be liquidated\n    }\n\n    // ========== SETTERS ==========\n\n    function setCollateralizationRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= ONE_THOUSAND, \"Too high\");\n        require(ratio >= ONE_HUNDRED, \"Too low\");\n        collateralizationRatio = ratio;\n        emit CollateralizationRatioUpdated(ratio);\n    }\n\n    function setInterestRate(uint256 _interestRate) external onlyOwner {\n        require(_interestRate > SECONDS_IN_A_YEAR, \"Interest rate cannot be less that the SECONDS_IN_A_YEAR\");\n        require(_interestRate <= SafeDecimalMath.unit(), \"Interest cannot be more than 100% APR\");\n        interestRate = _interestRate;\n        interestPerSecond = _interestRate.div(SECONDS_IN_A_YEAR);\n        emit InterestRateUpdated(interestRate);\n    }\n\n    function setIssueFeeRate(uint256 _issueFeeRate) external onlyOwner {\n        issueFeeRate = _issueFeeRate;\n        emit IssueFeeRateUpdated(issueFeeRate);\n    }\n\n    function setIssueLimit(uint256 _issueLimit) external onlyOwner {\n        issueLimit = _issueLimit;\n        emit IssueLimitUpdated(issueLimit);\n    }\n\n    function setMinLoanSize(uint256 _minLoanSize) external onlyOwner {\n        minLoanSize = _minLoanSize;\n        emit MinLoanSizeUpdated(minLoanSize);\n    }\n\n    function setAccountLoanLimit(uint256 _loanLimit) external onlyOwner {\n        uint256 HARD_CAP = 1000;\n        require(_loanLimit < HARD_CAP, \"Owner cannot set higher than HARD_CAP\");\n        accountLoanLimit = _loanLimit;\n        emit AccountLoanLimitUpdated(accountLoanLimit);\n    }\n\n    function setLoanLiquidationOpen(bool _loanLiquidationOpen) external onlyOwner {\n        require(now > liquidationDeadline, \"Before liquidation deadline\");\n        loanLiquidationOpen = _loanLiquidationOpen;\n        emit LoanLiquidationOpenUpdated(loanLiquidationOpen);\n    }\n\n    // ========== PUBLIC VIEWS ==========\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](5);\n        addresses[0] = CONTRACT_SYSTEMSTATUS;\n        addresses[1] = CONTRACT_PYNTHPETH;\n        addresses[2] = CONTRACT_PYNTHPUSD;\n        addresses[3] = CONTRACT_DEPOT;\n        addresses[4] = CONTRACT_EXRATES;\n    }\n\n    function getContractInfo()\n        external\n        view\n        returns (\n            uint256 _collateralizationRatio,\n            uint256 _issuanceRatio,\n            uint256 _interestRate,\n            uint256 _interestPerSecond,\n            uint256 _issueFeeRate,\n            uint256 _issueLimit,\n            uint256 _minLoanSize,\n            uint256 _totalIssuedPynths,\n            uint256 _totalLoansCreated,\n            uint256 _totalOpenLoanCount,\n            uint256 _ethBalance,\n            uint256 _liquidationDeadline,\n            bool _loanLiquidationOpen\n        )\n    {\n        _collateralizationRatio = collateralizationRatio;\n        _issuanceRatio = issuanceRatio();\n        _interestRate = interestRate;\n        _interestPerSecond = interestPerSecond;\n        _issueFeeRate = issueFeeRate;\n        _issueLimit = issueLimit;\n        _minLoanSize = minLoanSize;\n        _totalIssuedPynths = totalIssuedPynths;\n        _totalLoansCreated = totalLoansCreated;\n        _totalOpenLoanCount = totalOpenLoanCount;\n        _ethBalance = address(this).balance;\n        _liquidationDeadline = liquidationDeadline;\n        _loanLiquidationOpen = loanLiquidationOpen;\n    }\n\n    // returns value of 100 / collateralizationRatio.\n    // e.g. 100/125 = 0.8\n    // or in wei 100000000000000000000/125000000000000000000 = 800000000000000000\n    function issuanceRatio() public view returns (uint256) {\n        // this Rounds so you get slightly more rather than slightly less\n        // 4999999999999999995000\n        return ONE_HUNDRED.divideDecimalRound(collateralizationRatio);\n    }\n\n    function loanAmountFromCollateral(uint256 collateralAmount) public view returns (uint256) {\n        return collateralAmount.multiplyDecimal(issuanceRatio());\n    }\n\n    function collateralAmountForLoan(uint256 loanAmount) external view returns (uint256) {\n        return loanAmount.multiplyDecimal(collateralizationRatio.divideDecimalRound(ONE_HUNDRED));\n    }\n\n    function currentInterestOnLoan(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        uint256 loanLifeSpan = _loanLifeSpan(pynthLoan);\n        return accruedInterestOnLoan(pynthLoan.loanAmount, loanLifeSpan);\n    }\n\n    function accruedInterestOnLoan(uint256 _loanAmount, uint256 _seconds) public view returns (uint256 interestAmount) {\n        // Simple interest calculated per second\n        // Interest = Principal * rate * time\n        interestAmount = _loanAmount.multiplyDecimalRound(interestPerSecond.mul(_seconds));\n    }\n\n    function calculateMintingFee(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        return _calculateMintingFee(pynthLoan);\n    }\n\n    function openLoanIDsByAccount(address _account) external view returns (uint256[] memory) {\n        PynthLoanStruct[] memory pynthLoans = accountsPynthLoans[_account];\n\n        uint256[] memory _openLoanIDs = new uint256[](pynthLoans.length);\n        uint256 _counter = 0;\n\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].timeClosed == 0) {\n                _openLoanIDs[_counter] = pynthLoans[i].loanID;\n                _counter++;\n            }\n        }\n        // Create the fixed size array to return\n        uint256[] memory _result = new uint256[](_counter);\n\n        // Copy loanIDs from dynamic array to fixed array\n        for (uint256 j = 0; j < _counter; j++) {\n            _result[j] = _openLoanIDs[j];\n        }\n        // Return an array with list of open Loan IDs\n        return _result;\n    }\n\n    function getLoan(address _account, uint256 _loanID)\n        external\n        view\n        returns (\n            address account,\n            uint256 collateralAmount,\n            uint256 loanAmount,\n            uint256 timeCreated,\n            uint256 loanID,\n            uint256 timeClosed,\n            uint256 interest,\n            uint256 totalFees\n        )\n    {\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        account = pynthLoan.account;\n        collateralAmount = pynthLoan.collateralAmount;\n        loanAmount = pynthLoan.loanAmount;\n        timeCreated = pynthLoan.timeCreated;\n        loanID = pynthLoan.loanID;\n        timeClosed = pynthLoan.timeClosed;\n        interest = accruedInterestOnLoan(pynthLoan.loanAmount, _loanLifeSpan(pynthLoan));\n        totalFees = interest.add(_calculateMintingFee(pynthLoan));\n    }\n\n    function loanLifeSpan(address _account, uint256 _loanID) external view returns (uint256 loanLifeSpanResult) {\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(_account, _loanID);\n        loanLifeSpanResult = _loanLifeSpan(pynthLoan);\n    }\n\n    // ========== PUBLIC FUNCTIONS ==========\n\n    function openLoan() external payable notPaused nonReentrant pETHRateNotInvalid returns (uint256 loanID) {\n        systemStatus().requireIssuanceActive();\n\n        // Require ETH sent to be greater than minLoanSize\n        require(msg.value >= minLoanSize, \"Not enough ETH to create this loan. Please see the minLoanSize\");\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Each account is limted to creating 50 (accountLoanLimit) loans\n        require(accountsPynthLoans[msg.sender].length < accountLoanLimit, \"Each account is limted to 50 loans\");\n\n        // Calculate issuance amount\n        uint256 loanAmount = loanAmountFromCollateral(msg.value);\n\n        // Require pETH to mint does not exceed cap\n        require(totalIssuedPynths.add(loanAmount) < issueLimit, \"Loan Amount exceeds the supply cap.\");\n\n        // Get a Loan ID\n        loanID = _incrementTotalLoansCounter();\n\n        // Create Loan storage object\n        PynthLoanStruct memory pynthLoan =\n            PynthLoanStruct({\n                account: msg.sender,\n                collateralAmount: msg.value,\n                loanAmount: loanAmount,\n                timeCreated: now,\n                loanID: loanID,\n                timeClosed: 0\n            });\n\n        // Record loan in mapping to account in an array of the accounts open loans\n        accountsPynthLoans[msg.sender].push(pynthLoan);\n\n        // Increment totalIssuedPynths\n        totalIssuedPynths = totalIssuedPynths.add(loanAmount);\n\n        // Issue the pynth\n        pynthpETH().issue(msg.sender, loanAmount);\n\n        // Tell the Dapps a loan was created\n        emit LoanCreated(msg.sender, loanID, loanAmount);\n    }\n\n    function closeLoan(uint256 loanID) external nonReentrant pETHRateNotInvalid {\n        _closeLoan(msg.sender, loanID);\n    }\n\n    // Liquidation of an open loan available for anyone\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external nonReentrant pETHRateNotInvalid {\n        require(loanLiquidationOpen, \"Liquidation is not open\");\n        // Close the creators loan and send collateral to the closer.\n        _closeLoan(_loanCreatorsAddress, _loanID);\n        // Tell the Dapps this loan was liquidated\n        emit LoanLiquidated(_loanCreatorsAddress, _loanID, msg.sender);\n    }\n\n    // ========== PRIVATE FUNCTIONS ==========\n\n    function _closeLoan(address account, uint256 loanID) private {\n        systemStatus().requireIssuanceActive();\n\n        // Get the loan from storage\n        PynthLoanStruct memory pynthLoan = _getLoanFromStorage(account, loanID);\n\n        require(pynthLoan.loanID > 0, \"Loan does not exist\");\n        require(pynthLoan.timeClosed == 0, \"Loan already closed\");\n        require(\n            IERC20(address(pynthpETH())).balanceOf(msg.sender) >= pynthLoan.loanAmount,\n            \"You do not have the required Pynth balance to close this loan.\"\n        );\n\n        // Record loan as closed\n        _recordLoanClosure(pynthLoan);\n\n        // Decrement totalIssuedPynths\n        totalIssuedPynths = totalIssuedPynths.sub(pynthLoan.loanAmount);\n\n        // Calculate and deduct interest(5%) and minting fee(50 bips) in ETH\n        uint256 interestAmount = accruedInterestOnLoan(pynthLoan.loanAmount, _loanLifeSpan(pynthLoan));\n        uint256 mintingFee = _calculateMintingFee(pynthLoan);\n        uint256 totalFeeETH = interestAmount.add(mintingFee);\n\n        // Burn all Pynths issued for the loan\n        pynthpETH().burn(msg.sender, pynthLoan.loanAmount);\n\n        // Fee Distribution. Purchase pUSD with ETH from Depot\n        require(\n            IERC20(address(pynthpUSD())).balanceOf(address(depot())) >= depot().pynthsReceivedForEther(totalFeeETH),\n            \"The pUSD Depot does not have enough pUSD to buy for fees\"\n        );\n        depot().exchangeEtherForPynths.value(totalFeeETH)();\n\n        // Transfer the pUSD to distribute to PERI holders.\n        IERC20(address(pynthpUSD())).transfer(FEE_ADDRESS, IERC20(address(pynthpUSD())).balanceOf(address(this)));\n\n        // Send remainder ETH to caller\n        address(msg.sender).transfer(pynthLoan.collateralAmount.sub(totalFeeETH));\n\n        // Tell the Dapps\n        emit LoanClosed(account, loanID, totalFeeETH);\n    }\n\n    function _getLoanFromStorage(address account, uint256 loanID) private view returns (PynthLoanStruct memory) {\n        PynthLoanStruct[] memory pynthLoans = accountsPynthLoans[account];\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].loanID == loanID) {\n                return pynthLoans[i];\n            }\n        }\n    }\n\n    function _recordLoanClosure(PynthLoanStruct memory pynthLoan) private {\n        // Get storage pointer to the accounts array of loans\n        PynthLoanStruct[] storage pynthLoans = accountsPynthLoans[pynthLoan.account];\n        for (uint256 i = 0; i < pynthLoans.length; i++) {\n            if (pynthLoans[i].loanID == pynthLoan.loanID) {\n                // Record the time the loan was closed\n                pynthLoans[i].timeClosed = now;\n            }\n        }\n\n        // Reduce Total Open Loans Count\n        totalOpenLoanCount = totalOpenLoanCount.sub(1);\n    }\n\n    function _incrementTotalLoansCounter() private returns (uint256) {\n        // Increase the total Open loan count\n        totalOpenLoanCount = totalOpenLoanCount.add(1);\n        // Increase the total Loans Created count\n        totalLoansCreated = totalLoansCreated.add(1);\n        // Return total count to be used as a unique ID.\n        return totalLoansCreated;\n    }\n\n    function _calculateMintingFee(PynthLoanStruct memory pynthLoan) private view returns (uint256 mintingFee) {\n        mintingFee = pynthLoan.loanAmount.multiplyDecimalRound(issueFeeRate);\n    }\n\n    function _loanLifeSpan(PynthLoanStruct memory pynthLoan) private view returns (uint256 loanLifeSpanResult) {\n        // Get time loan is open for, and if closed from the timeClosed\n        bool loanClosed = pynthLoan.timeClosed > 0;\n        // Calculate loan life span in seconds as (Now - Loan creation time)\n        loanLifeSpanResult = loanClosed ? pynthLoan.timeClosed.sub(pynthLoan.timeCreated) : now.sub(pynthLoan.timeCreated);\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function pynthpETH() internal view returns (IPynth) {\n        return IPynth(requireAndGetAddress(CONTRACT_PYNTHPETH));\n    }\n\n    function pynthpUSD() internal view returns (IPynth) {\n        return IPynth(requireAndGetAddress(CONTRACT_PYNTHPUSD));\n    }\n\n    function depot() internal view returns (IDepot) {\n        return IDepot(requireAndGetAddress(CONTRACT_DEPOT));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier pETHRateNotInvalid() {\n        require(!exchangeRates().rateIsInvalid(\"pETH\"), \"Blocked as pETH rate is invalid\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n\n    event CollateralizationRatioUpdated(uint256 ratio);\n    event InterestRateUpdated(uint256 interestRate);\n    event IssueFeeRateUpdated(uint256 issueFeeRate);\n    event IssueLimitUpdated(uint256 issueLimit);\n    event MinLoanSizeUpdated(uint256 minLoanSize);\n    event AccountLoanLimitUpdated(uint256 loanLimit);\n    event LoanLiquidationOpenUpdated(bool loanLiquidationOpen);\n    event LoanCreated(address indexed account, uint256 loanID, uint256 amount);\n    event LoanClosed(address indexed account, uint256 loanID, uint256 feesPaid);\n    event LoanLiquidated(address indexed account, uint256 loanID, address liquidator);\n}\n\n    ","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanLimit\",\"type\":\"uint256\"}],\"name\":\"AccountLoanLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"CollateralizationRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"}],\"name\":\"InterestRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"IssueFeeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueLimit\",\"type\":\"uint256\"}],\"name\":\"IssueLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesPaid\",\"type\":\"uint256\"}],\"name\":\"LoanClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LoanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"LoanLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"LoanLiquidationOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLoanSize\",\"type\":\"uint256\"}],\"name\":\"MinLoanSizeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountLoanLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountOpenLoanCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsPynthLoans\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"accruedInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"calculateMintingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"closeLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"}],\"name\":\"collateralAmountForLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"currentInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralizationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issuanceRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minLoanSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalIssuedPynths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLoansCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalOpenLoanCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getLoan\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"liquidateUnclosedLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"loanAmountFromCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"loanLifeSpan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanLifeSpanResult\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanLiquidationOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minLoanSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"openLoanIDsByAccount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"addresses\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanLimit\",\"type\":\"uint256\"}],\"name\":\"setAccountLoanLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"setCollateralizationRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"setIssueFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"}],\"name\":\"setIssueLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"setLoanLiquidationOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minLoanSize\",\"type\":\"uint256\"}],\"name\":\"setMinLoanSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuedPynths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLoansCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOpenLoanCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EtherCollateral","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000918153d6e806df9d4d33664d1cc580416171f7200000000000000000000000007015cd1e78ba1428d103b0c2513077b2826b64fc","EVMVersion":"Default","Library":"SafeDecimalMath:6e0bff12512a94f3b1ecebe08203fe7f8f8fae64","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}