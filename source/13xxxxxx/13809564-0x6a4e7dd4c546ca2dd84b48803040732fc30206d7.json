{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/ZkSyncExit.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeMathUInt128.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nimport \\\"./Storage.sol\\\";\\nimport \\\"./Operations.sol\\\";\\nimport \\\"./Config.sol\\\";\\nimport \\\"./Events.sol\\\";\\nimport \\\"./PairTokenManager.sol\\\";\\n\\nimport \\\"./uniswap/interfaces/IUniswapV2Pair.sol\\\";\\n\\ncontract ZkSyncExit is PairTokenManager, Storage, Config, Events, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeMathUInt128 for uint128;\\n\\n    /// @notice Withdraws token from Franklin to root chain in case of exodus mode. User must provide proof that he owns funds\\n    /// @param _accountId Id of the account in the tree\\n    /// @param _proof Proof\\n    /// @param _tokenId Verified token id\\n    /// @param _amount Amount for owner (must be total amount, not part of it)\\n    function exit(uint32 _accountId, uint16 _tokenId, uint128 _amount, uint256[] calldata _proof) external nonReentrant {\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, _tokenId);\\n        require(exodusMode, \\\"fet11\\\"); // must be in exodus mode\\n        require(!exited[_accountId][_tokenId], \\\"fet12\\\"); // already exited\\n        require(verifierExit.verifyExitProof(blocks[totalBlocksVerified].stateRoot, _accountId, msg.sender, _tokenId, _amount, _proof), \\\"fet13\\\"); // verification failed\\n\\n        uint128 balance = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n        balancesToWithdraw[packedBalanceKey].balanceToWithdraw = balance.add(_amount);\\n        exited[_accountId][_tokenId] = true;\\n    }\\n\\n    /// @notice Withdraws token from Franklin to root chain in case of exodus mode. User must provide proof that he owns NFT globalId\\n    /// @param _globalId id of nft token in layer2\\n    /// @param _creatorId token creator id\\n    /// @param _seqId nft token seq id\\n    /// @param _uri nft token uri\\n    /// @param _proof Proof\\n    function exitNFT(uint64 _globalId,\\n                    uint32 _creatorId,\\n                    uint32 _seqId,\\n                    bytes32 _uri,\\n                    uint256[] calldata _proof\\n            ) external nonReentrant {\\n        require(exodusMode, \\\"fet11\\\"); // must be in exodus mode\\n        require(!nft_exited[_globalId], \\\"fet12\\\"); // already exited\\n        require(verifierExit.verifyExitNFTProof(blocks[totalBlocksVerified].stateRoot, _globalId, _creatorId, _seqId, _uri, msg.sender,  _proof), \\\"fet13\\\"); // verification failed\\n        zkSeaNFT.addWithdraw(Operations.WithdrawNFTData({\\n            valid: true,\\n            pendingWithdraw: false,\\n            globalId: _globalId,\\n            creatorId: _creatorId,\\n            seqId: _seqId,\\n            target: msg.sender,\\n            uri: _uri\\n        }));\\n        nft_exited[_globalId] = true;\\n    }\\n\\n    function updateBalance(uint16 _tokenId, uint128 _out) internal {\\n        bytes22 packedBalanceKey0 = packAddressAndTokenId(msg.sender, _tokenId);\\n        uint128 balance0 = balancesToWithdraw[packedBalanceKey0].balanceToWithdraw;\\n        balancesToWithdraw[packedBalanceKey0].balanceToWithdraw = balance0.add(_out);\\n    }\\n\\n    function checkLpL1Balance(address pair, uint128 _lpL1Amount) internal {\\n        //Check lp_L1_amount\\n        uint128 balance0 = uint128(IUniswapV2Pair(pair).balanceOf(msg.sender));\\n        require(_lpL1Amount == balance0, \\\"le6\\\");\\n\\n        //burn lp token\\n        if (balance0 > 0) {\\n            pairmanager.burn(address(pair), msg.sender, SafeCast.toUint128(_lpL1Amount)); //\\n        }\\n    }\\n\\n    function checkPairAccount(address _pairAccount, uint16[] memory _tokenIds) view internal {\\n        // check the pair account is correct with token id\\n        uint16 token = validatePairTokenAddress(_pairAccount);\\n        require(token == _tokenIds[0], \\\"le4\\\");\\n\\n        // make sure token0/token1 is pair account\\n        address _token0 = governance.getTokenAddress(_tokenIds[1]);\\n        if (_tokenIds[1] != 0) {\\n            require(_token0 != address(0), \\\"le8\\\");\\n        } else {\\n            _token0 = address(0);\\n        }\\n        address _token1 = governance.getTokenAddress(_tokenIds[2]);\\n        if (_tokenIds[2] != 0) {\\n            require(_token1 != address(0), \\\"le7\\\");\\n        } else {\\n            _token1 = address(0);\\n        }\\n        address pair = pairmanager.getPair(_token0, _token1);\\n        require(pair == _pairAccount, \\\"le5\\\");\\n    }\\n\\n    function lpExit(bytes32 _rootHash, uint32[] calldata _accountIds, address[] calldata _addresses, uint16[] calldata _tokenIds, uint128[] calldata _amounts, uint256[] calldata _proof) external nonReentrant {\\n        /* data format:\\n           bytes32 _rootHash\\n            _owner_id = _accountIds[0]\\n            _pair_acc_id = _accountIds[1]\\n            _owner_addr = _addresses[0]\\n            _pair_acc_addr = _addresses[1]\\n            _lp_token_id = _tokenIds[0]\\n            _token0_id = _tokenIds[1]\\n            _token1_id = _tokenIds[2]\\n            _lp_L2_amount = _amounts[0]\\n            _lp_L1_amount = _amounts[1]\\n            _balance0 = _amounts[2]\\n            _balance1 = _amounts[3]\\n            _out0 = _amounts[4]\\n            _out1 = _amounts[5]\\n        */\\n        //check root hash\\n        require(exodusMode, \\\"le0\\\"); // must be in exodus mode\\n        require(_rootHash == blocks[totalBlocksVerified].stateRoot, \\\"le1\\\");\\n        //check owner _account\\n        require(msg.sender == _addresses[0], \\\"le2\\\");\\n        uint32 _accountId = _accountIds[0];\\n        uint32 _pairAccountId = _accountIds[1];\\n        checkPairAccount(_addresses[1], _tokenIds);\\n        checkLpL1Balance(_addresses[1], _amounts[1]);\\n        // check (token0, out0)\\n        updateBalance(_tokenIds[1], _amounts[4]);\\n        // check (token1, out1)\\n        updateBalance(_tokenIds[2], _amounts[5]);\\n        require(!swap_exited[_accountId][_pairAccountId], \\\"le3\\\"); // already exited\\n        bytes memory _account_data = abi.encodePacked(_rootHash, _accountId, _addresses[0], _amounts[0], _amounts[1]);\\n        bytes memory _pair_data0 = abi.encodePacked(_pairAccountId, _addresses[1], _tokenIds[0], _tokenIds[1], _tokenIds[2]);\\n        bytes memory _pair_data1 = abi.encodePacked(_amounts[2], _amounts[3], _amounts[4], _amounts[5]);\\n        require(verifierExit.verifyLpExitProof(_account_data, _pair_data0, _pair_data1, _proof), \\\"levf\\\"); // verification failed\\n        swap_exited[_accountId][_pairAccountId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    /// Address of lock flag variable.\\n    /// Flag is placed at random memory location to not interfere with Storage contract.\\n    uint constant private LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\\\"ReentrancyGuard\\\") - 1;\\n\\n    function initializeReentrancyGuard () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        assembly { sstore(LOCK_FLAG_ADDRESS, 1) }\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        bool notEntered;\\n        assembly { notEntered := sload(LOCK_FLAG_ADDRESS) }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        assembly { sstore(LOCK_FLAG_ADDRESS, 0) }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        assembly { sstore(LOCK_FLAG_ADDRESS, 1) }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMathUInt128.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUInt128 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        require(b <= a, errorMessage);\\n        uint128 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint128 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint128 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeCast.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and then downcasting.\\n *\\n * _Available since v2.5.0._\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\n\\nlibrary Utils {\\n    /// @notice Returns lesser of two values\\n    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Returns lesser of two values\\n    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transfer` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendERC20(IERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) = address(_token).call(\\n            abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _amount)\\n        );\\n        // `transfer` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Transfers token from one address to another\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transferFrom` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _from Address of sender\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function transferFromERC20(IERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) = address(_token).call(\\n            abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", _from, _to, _amount)\\n        );\\n        // `transferFrom` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Sends ETH\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendETHNoRevert(address payable _to, uint256 _amount) internal returns (bool) {\\n        // TODO: Use constant from Config\\n        uint256 ETH_WITHDRAWAL_GAS_LIMIT = 10000;\\n\\n        (bool callSuccess, ) = _to.call.gas(ETH_WITHDRAWAL_GAS_LIMIT).value(_amount)(\\\"\\\");\\n        return callSuccess;\\n    }\\n\\n    /// @notice Recovers signer's address from ethereum signature for given message\\n    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)\\n    /// @param _message signed message.\\n    /// @return address of the signer\\n    function recoverAddressFromEthSignature(bytes memory _signature, bytes memory _message) internal pure returns (address) {\\n        require(_signature.length == 65, \\\"ves10\\\"); // incorrect signature length\\n\\n        bytes32 signR;\\n        bytes32 signS;\\n        uint offset = 0;\\n\\n        (offset, signR) = Bytes.readBytes32(_signature, offset);\\n        (offset, signS) = Bytes.readBytes32(_signature, offset);\\n        uint8 signV = uint8(_signature[offset]);\\n\\n        return ecrecover(keccak256(_message), signV, signR, signS);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Storage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./nft/IZKSeaNFT.sol\\\";\\nimport \\\"./Verifier.sol\\\";\\nimport \\\"./VerifierExit.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\nimport \\\"./uniswap/UniswapV2Factory.sol\\\";\\n\\n/// @title ZKSwap storage contract\\n/// @author Matter Labs\\n/// @author ZKSwap L2 Labs\\ncontract Storage {\\n\\n    /// @notice Flag indicates that upgrade preparation status is active\\n    /// @dev Will store false in case of not active upgrade mode\\n    bool public upgradePreparationActive;\\n\\n    /// @notice Upgrade preparation activation timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint public upgradePreparationActivationTime;\\n\\n    /// @notice Verifier contract. Used to verify block proof and exit proof\\n    Verifier internal verifier;\\n    VerifierExit internal verifierExit;\\n\\n    /// @notice Governance contract. Contains the governor (the owner) of whole system, validators list, possible tokens list\\n    Governance internal governance;\\n\\n    /// @notice ZKSeaNFT contract. Contains the nft info in layer1 and layer2\\n    IZKSeaNFT internal zkSeaNFT;\\n    \\n    UniswapV2Factory internal pairmanager;\\n\\n    struct BalanceToWithdraw {\\n        uint128 balanceToWithdraw;\\n        uint8 gasReserveValue; // gives user opportunity to fill storage slot with nonzero value\\n    }\\n\\n    /// @notice Root-chain balances (per owner and token id, see packAddressAndTokenId) to withdraw\\n    mapping(bytes22 => BalanceToWithdraw) public balancesToWithdraw;\\n\\n    /// @notice verified withdrawal pending to be executed.\\n    struct PendingWithdrawal {\\n        address to;\\n        uint16 tokenId;\\n    }\\n    \\n    /// @notice Verified but not executed withdrawals for addresses stored in here (key is pendingWithdrawal's index in pending withdrawals queue)\\n    mapping(uint32 => PendingWithdrawal) public pendingWithdrawals;\\n    uint32 public firstPendingWithdrawalIndex;\\n    uint32 public numberOfPendingWithdrawals;\\n\\n    /// @notice Total number of verified blocks i.e. blocks[totalBlocksVerified] points at the latest verified block (block 0 is genesis)\\n    uint32 public totalBlocksVerified;\\n\\n    /// @notice Total number of checked blocks\\n    uint32 public totalBlocksChecked;\\n\\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\\n    uint32 public totalBlocksCommitted;\\n\\n    /// @notice Rollup block data (once per block)\\n    /// @member validator Block producer\\n    /// @member committedAtBlock ETH block number at which this block was committed\\n    /// @member cumulativeOnchainOperations Total number of operations in this and all previous blocks\\n    /// @member priorityOperations Total number of priority operations for this block\\n    /// @member commitment Hash of the block circuit commitment\\n    /// @member stateRoot New tree root hash\\n    ///\\n    /// Consider memory alignment when changing field order: https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html\\n    struct Block {\\n        uint32 committedAtBlock;\\n        uint64 priorityOperations;\\n        uint32 chunks;\\n        bytes32 withdrawalsDataHash; /// can be restricted to 16 bytes to reduce number of required storage slots\\n        bytes32 commitment;\\n        bytes32 stateRoot;\\n    }\\n\\n    /// @notice Blocks by Franklin block id\\n    mapping(uint32 => Block) public blocks;\\n\\n    /// @notice Onchain operations - operations processed inside rollup blocks\\n    /// @member opType Onchain operation type\\n    /// @member amount Amount used in the operation\\n    /// @member pubData Operation pubdata\\n    struct OnchainOperation {\\n        Operations.OpType opType;\\n        bytes pubData;\\n    }\\n\\n    /// @notice Flag indicates that a user has exited certain token balance (per account id and tokenId)\\n    mapping(uint32 => mapping(uint16 => bool)) public exited;\\n    mapping(uint32 => mapping(uint32 => bool)) public swap_exited;\\n    mapping(uint64 => bool) public nft_exited;\\n\\n    /// @notice Flag indicates that exodus (mass exit) mode is triggered\\n    /// @notice Once it was raised, it can not be cleared again, and all users must exit\\n    bool public exodusMode;\\n\\n    /// @notice User authenticated fact hashes for some nonce.\\n    mapping(address => mapping(uint32 => bytes32)) public authFacts;\\n\\n    /// @notice Priority Operation container\\n    /// @member opType Priority operation type\\n    /// @member pubData Priority operation public data\\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n    struct PriorityOperation {\\n        Operations.OpType opType;\\n        bytes pubData;\\n        uint256 expirationBlock;\\n    }\\n\\n    /// @notice Priority Requests mapping (request id - operation)\\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\\n    /// @dev Numbers are in order of requests receiving\\n    mapping(uint64 => PriorityOperation) public priorityRequests;\\n\\n    /// @notice First open priority request id\\n    uint64 public firstPriorityRequestId;\\n\\n    /// @notice Total number of requests\\n    uint64 public totalOpenPriorityRequests;\\n\\n    /// @notice Total number of committed requests.\\n    /// @dev Used in checks: if the request matches the operation on Rollup contract and if provided number of requests is not too big\\n    uint64 public totalCommittedPriorityRequests;\\n\\n    /// @notice Packs address and token id into single word to use as a key in balances mapping\\n    function packAddressAndTokenId(address _address, uint16 _tokenId) internal pure returns (bytes22) {\\n        return bytes22((uint176(_address) | (uint176(_tokenId) << 160)));\\n    }\\n\\n    /// @notice Gets value from balancesToWithdraw\\n    function getBalanceToWithdraw(address _address, uint16 _tokenId) external view returns (uint128) {\\n        return balancesToWithdraw[packAddressAndTokenId(_address, _tokenId)].balanceToWithdraw;\\n    }\\n\\n    address public zkSyncCommitBlockAddress;\\n    address public zkSyncExitAddress;\\n    address public zkSeaAddress;\\n\\n    /// @notice Limit the max amount for each ERC20 deposit\\n    uint128 public maxDepositAmount;\\n\\n    /// @notice withdraw erc20 token gas limit\\n    uint256 public withdrawGasLimit;\\n\\n    /// @notice withdraw nft gas limit\\n    uint256 public withdrawNFTGasLimit;\\n}\\n\"\r\n    },\r\n    \"contracts/Operations.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\nimport \\\"./Bytes.sol\\\";\\n\\n\\n/// @title ZKSwap operations tools\\nlibrary Operations {\\n\\n    // Circuit ops and their pubdata (chunks * bytes)\\n\\n    /// @notice ZKSwap circuit operation type\\n    enum OpType {\\n        Noop,\\n        Deposit,\\n        TransferToNew,\\n        PartialExit,\\n        _CloseAccount, // used for correct op id offset\\n        Transfer,\\n        FullExit,\\n        ChangePubKey,\\n        CreatePair,\\n        AddLiquidity,\\n        RemoveLiquidity,\\n        Swap,\\n        DepositNFT,\\n        MintNFT,\\n        TransferNFT,\\n        TransferToNewNFT,\\n        PartialExitNFT,\\n        FullExitNFT,\\n        ApproveNFT,\\n        ExchangeNFT\\n    }\\n\\n    // Byte lengths\\n\\n    uint8 constant TOKEN_BYTES = 2;\\n\\n    uint8 constant PUBKEY_BYTES = 32;\\n\\n    uint8 constant NONCE_BYTES = 4;\\n\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n\\n    uint8 constant ADDRESS_BYTES = 20;\\n\\n    /// @notice Packed fee bytes lengths\\n    uint8 constant FEE_BYTES = 2;\\n\\n    /// @notice ZKSwap account id bytes lengths\\n    uint8 constant ACCOUNT_ID_BYTES = 4;\\n\\n    uint8 constant AMOUNT_BYTES = 16;\\n\\n    /// @notice Signature (for example full exit signature) bytes length\\n    uint8 constant SIGNATURE_BYTES = 64;\\n\\n    /// @notice nft uri bytes lengths\\n    uint8 constant NFT_URI_BYTES = 32;\\n\\n    /// @notice nft seq id bytes lengths\\n    uint8 constant NFT_SEQUENCE_ID_BYTES = 4;\\n\\n    /// @notice nft creator bytes lengths\\n    uint8 constant NFT_CREATOR_ID_BYTES = 4;\\n\\n    /// @notice nft priority op id bytes lengths\\n    uint8 constant NFT_PRIORITY_OP_ID_BYTES = 8;\\n\\n    /// @notice nft global id bytes lengths\\n    uint8 constant NFT_GLOBAL_ID_BYTES = 8;\\n\\n    /// @notic withdraw nft use fee token id bytes lengths\\n    uint8 constant NFT_FEE_TOKEN_ID = 1;\\n\\n    /// @notic fullexit nft success bytes lengths\\n    uint8 constant NFT_SUCCESS = 1;\\n\\n\\n    // Deposit pubdata\\n    struct Deposit {\\n        uint32 accountId;\\n        uint16 tokenId;\\n        uint128 amount;\\n        address owner;\\n    }\\n\\n    uint public constant PACKED_DEPOSIT_PUBDATA_BYTES = \\n        ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES;\\n\\n    /// Deserialize deposit pubdata\\n    function readDepositPubdata(bytes memory _data) internal pure\\n        returns (Deposit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset);   // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset);   // amount\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);    // owner\\n\\n        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, \\\"rdp10\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    /// Serialize deposit pubdata\\n    function writeDepositPubdata(Deposit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),   // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId,  // tokenId\\n            op.amount,   // amount\\n            op.owner     // owner\\n        );\\n    }\\n\\n    /// @notice Check that deposit pubdata from request and block matches\\n    function depositPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // We must ignore `accountId` because it is present in block pubdata but not in priority queue\\n        bytes memory lhs_trimmed = Bytes.slice(_lhs, ACCOUNT_ID_BYTES, PACKED_DEPOSIT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        bytes memory rhs_trimmed = Bytes.slice(_rhs, ACCOUNT_ID_BYTES, PACKED_DEPOSIT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        return keccak256(lhs_trimmed) == keccak256(rhs_trimmed);\\n    }\\n\\n    // FullExit pubdata\\n\\n    struct FullExit {\\n        uint32 accountId;\\n        address owner;\\n        uint16 tokenId;\\n        uint128 amount;\\n    }\\n\\n    uint public constant PACKED_FULL_EXIT_PUBDATA_BYTES = \\n        ACCOUNT_ID_BYTES + ADDRESS_BYTES + TOKEN_BYTES + AMOUNT_BYTES;\\n\\n    function readFullExitPubdata(bytes memory _data) internal pure\\n        returns (FullExit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset);      // accountId\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);         // owner\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset);        // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset);        // amount\\n\\n        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, \\\"rfp10\\\"); // reading invalid full exit pubdata size\\n    }\\n\\n    function writeFullExitPubdata(FullExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            op.accountId,  // accountId\\n            op.owner,      // owner\\n            op.tokenId,    // tokenId\\n            op.amount      // amount\\n        );\\n    }\\n\\n    /// @notice Check that full exit pubdata from request and block matches\\n    function fullExitPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // `amount` is ignored because it is present in block pubdata but not in priority queue\\n        uint lhs = Bytes.trim(_lhs, PACKED_FULL_EXIT_PUBDATA_BYTES - AMOUNT_BYTES);\\n        uint rhs = Bytes.trim(_rhs, PACKED_FULL_EXIT_PUBDATA_BYTES - AMOUNT_BYTES);\\n        return lhs == rhs;\\n    }\\n\\n    // PartialExit pubdata\\n    \\n    struct PartialExit {\\n        //uint32 accountId; -- present in pubdata, ignored at serialization\\n        uint16 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address owner;\\n    }\\n\\n    function readPartialExitPubdata(bytes memory _data, uint _offset) internal pure\\n        returns (PartialExit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = _offset + ACCOUNT_ID_BYTES;                   // accountId (ignored)\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);  // owner\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n    }\\n\\n    function writePartialExitPubdata(PartialExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),  // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId, // tokenId\\n            op.amount,  // amount\\n            bytes2(0),  // fee (ignored)  (update when FEE_BYTES is changed)\\n            op.owner    // owner\\n        );\\n    }\\n\\n    // ChangePubKey\\n\\n    struct ChangePubKey {\\n        uint32 accountId;\\n        bytes20 pubKeyHash;\\n        address owner;\\n        uint32 nonce;\\n    }\\n\\n    function readChangePubKeyPubdata(bytes memory _data, uint _offset) internal pure\\n        returns (ChangePubKey memory parsed)\\n    {\\n        uint offset = _offset;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset);                // accountId\\n        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset);              // pubKeyHash\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);                   // owner\\n        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset);                    // nonce\\n    }\\n\\n    // Withdrawal nft data process\\n\\n    struct WithdrawNFTData {\\n        bool valid;  //confirm the necessity of this field\\n        bool pendingWithdraw;\\n        uint64 globalId;\\n        uint32 creatorId;\\n        uint32 seqId;\\n        address target;\\n        bytes32 uri;\\n    }\\n\\n    function readWithdrawalData(bytes memory _data, uint _offset) internal pure\\n    returns (bool isNFTWithdraw, uint128 amount, uint16 _tokenId, WithdrawNFTData memory parsed)\\n    {\\n        uint offset = _offset;\\n        (offset, isNFTWithdraw) = Bytes.readBool(_data, offset);\\n        (offset, parsed.pendingWithdraw) = Bytes.readBool(_data, offset);\\n        (offset, parsed.target) = Bytes.readAddress(_data, offset);  // target\\n        if (isNFTWithdraw) {\\n            (offset, parsed.globalId) = Bytes.readUInt64(_data, offset);\\n            (offset, parsed.creatorId) = Bytes.readUInt32(_data, offset);   // creatorId\\n            (offset, parsed.seqId) = Bytes.readUInt32(_data, offset);   // seqId\\n            (offset, parsed.uri) = Bytes.readBytes32(_data, offset);   // uri\\n            (offset, parsed.valid) = Bytes.readBool(_data, offset); // is withdraw valid\\n        } else {\\n            (offset, _tokenId) = Bytes.readUInt16(_data, offset);\\n            (offset, amount) = Bytes.readUInt128(_data, offset); // withdraw erc20 or eth token amount\\n        }\\n    }\\n\\n    // CreatePair pubdata\\n    \\n    struct CreatePair {\\n        uint32 accountId;\\n        uint16 tokenA;\\n        uint16 tokenB;\\n        uint16 tokenPair;\\n        address pair;\\n    }\\n\\n    uint public constant PACKED_CREATE_PAIR_PUBDATA_BYTES =\\n        ACCOUNT_ID_BYTES + TOKEN_BYTES + TOKEN_BYTES + TOKEN_BYTES + ADDRESS_BYTES;\\n\\n    function readCreatePairPubdata(bytes memory _data) internal pure\\n        returns (CreatePair memory parsed)\\n    {\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenA) = Bytes.readUInt16(_data, offset); // tokenAId\\n        (offset, parsed.tokenB) = Bytes.readUInt16(_data, offset); // tokenBId\\n        (offset, parsed.tokenPair) = Bytes.readUInt16(_data, offset); // pairId\\n        (offset, parsed.pair) = Bytes.readAddress(_data, offset); // pairId\\n        require(offset == PACKED_CREATE_PAIR_PUBDATA_BYTES, \\\"rcp10\\\"); // reading invalid create pair pubdata size\\n    }\\n\\n    function writeCreatePairPubdata(CreatePair memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),      // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenA,      // tokenAId\\n            op.tokenB,      // tokenBId\\n            op.tokenPair,   // pairId\\n            op.pair         // pair account\\n        );\\n    }\\n\\n    /// @notice Check that create pair pubdata from request and block matches\\n    function createPairPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // We must ignore `accountId` because it is present in block pubdata but not in priority queue\\n        bytes memory lhs_trimmed = Bytes.slice(_lhs, ACCOUNT_ID_BYTES, PACKED_CREATE_PAIR_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        bytes memory rhs_trimmed = Bytes.slice(_rhs, ACCOUNT_ID_BYTES, PACKED_CREATE_PAIR_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        return keccak256(lhs_trimmed) == keccak256(rhs_trimmed);\\n    }\\n\\n    // DepositNFT pubdata\\n    struct DepositNFT {\\n        uint64 globalId;\\n        uint32 creatorId;\\n        uint32 seqId;\\n        bytes32 uri;\\n        address owner;\\n        uint32 accountId;\\n    }\\n\\n    uint public constant PACKED_DEPOSIT_NFT_PUBDATA_BYTES = ACCOUNT_ID_BYTES +\\n    NFT_GLOBAL_ID_BYTES + NFT_CREATOR_ID_BYTES + NFT_SEQUENCE_ID_BYTES +\\n    NFT_URI_BYTES + ADDRESS_BYTES ;\\n\\n    /// Deserialize deposit nft pubdata\\n    function readDepositNFTPubdata(bytes memory _data) internal pure\\n    returns (DepositNFT memory parsed) {\\n\\n        uint offset = 0;\\n        (offset, parsed.globalId) = Bytes.readUInt64(_data, offset);   // globalId\\n        (offset, parsed.creatorId) = Bytes.readUInt32(_data, offset);   // creatorId\\n        (offset, parsed.seqId) = Bytes.readUInt32(_data, offset);   // seqId\\n        (offset, parsed.uri) = Bytes.readBytes32(_data, offset);   // uri\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);    // owner\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        require(offset == PACKED_DEPOSIT_NFT_PUBDATA_BYTES, \\\"rdnp10\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    /// Serialize deposit pubdata\\n    function writeDepositNFTPubdata(DepositNFT memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            op.globalId,\\n            op.creatorId,\\n            op.seqId,\\n            op.uri,\\n            op.owner,     // owner\\n            bytes4(0)\\n        );\\n    }\\n\\n    /// @notice Check that deposit nft pubdata from request and block matches\\n    function depositNFTPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // We must ignore `accountId` because it is present in block pubdata but not in priority queue\\n        uint offset = 0;\\n        uint64 globalId;\\n        (offset, globalId) = Bytes.readUInt64(_lhs, offset);   // globalId\\n        if (globalId == 0){\\n            bytes memory lhs_trimmed = Bytes.slice(_lhs, NFT_GLOBAL_ID_BYTES, PACKED_DEPOSIT_NFT_PUBDATA_BYTES - ACCOUNT_ID_BYTES - NFT_GLOBAL_ID_BYTES);\\n            bytes memory rhs_trimmed = Bytes.slice(_rhs, NFT_GLOBAL_ID_BYTES, PACKED_DEPOSIT_NFT_PUBDATA_BYTES - ACCOUNT_ID_BYTES - NFT_GLOBAL_ID_BYTES);\\n            return keccak256(lhs_trimmed) == keccak256(rhs_trimmed);\\n\\n        }else{\\n            bytes memory lhs_trimmed = Bytes.slice(_lhs, 0, PACKED_DEPOSIT_NFT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n            bytes memory rhs_trimmed = Bytes.slice(_rhs, 0, PACKED_DEPOSIT_NFT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n            return keccak256(lhs_trimmed) == keccak256(rhs_trimmed);\\n        }\\n    }\\n\\n    // FullExitNFT pubdata\\n    struct FullExitNFT {\\n        uint32 accountId;\\n        uint64 globalId;\\n        uint32 creatorId;\\n        uint32 seqId;\\n        bytes32 uri;\\n        address owner;\\n        uint8 success;\\n    }\\n\\n    uint public constant PACKED_FULL_EXIT_NFT_PUBDATA_BYTES = ACCOUNT_ID_BYTES +\\n        NFT_GLOBAL_ID_BYTES +  NFT_CREATOR_ID_BYTES +\\n        NFT_SEQUENCE_ID_BYTES + NFT_URI_BYTES + ADDRESS_BYTES + NFT_SUCCESS;\\n\\n    function readFullExitNFTPubdata(bytes memory _data) internal pure returns (FullExitNFT memory parsed) {\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.globalId) = Bytes.readUInt64(_data, offset);   // globalId\\n        (offset, parsed.creatorId) = Bytes.readUInt32(_data, offset); // creator\\n        (offset, parsed.seqId) = Bytes.readUInt32(_data, offset); // seqId\\n        (offset, parsed.uri) = Bytes.readBytes32(_data, offset); // uri\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);    // owner\\n        (offset, parsed.success) = Bytes.readUint8(_data, offset); // success\\n\\n        require(offset == PACKED_FULL_EXIT_NFT_PUBDATA_BYTES, \\\"rfnp10\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    function writeFullExitNFTPubdata(FullExitNFT memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            op.accountId,\\n            op.globalId,   // nft id in layer2\\n            op.creatorId,\\n            op.seqId,\\n            op.uri,\\n            op.owner,\\n            op.success\\n        );\\n    }\\n\\n    /// @notice Check that full exit pubdata from request and block matches\\n    /// TODO check it\\n    function fullExitNFTPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        bytes memory lhs_trimmed_1 = Bytes.slice(_lhs, 0, ACCOUNT_ID_BYTES + NFT_GLOBAL_ID_BYTES);\\n        bytes memory rhs_trimmed_1 = Bytes.slice(_rhs, 0, ACCOUNT_ID_BYTES + NFT_GLOBAL_ID_BYTES);\\n        bytes memory lhs_trimmed_2 = Bytes.slice(_lhs, PACKED_FULL_EXIT_NFT_PUBDATA_BYTES - ADDRESS_BYTES - NFT_SUCCESS, ADDRESS_BYTES);\\n        bytes memory rhs_trimmed_2 = Bytes.slice(_rhs, PACKED_FULL_EXIT_NFT_PUBDATA_BYTES - ADDRESS_BYTES - NFT_SUCCESS, ADDRESS_BYTES);\\n        return keccak256(lhs_trimmed_1) == keccak256(rhs_trimmed_1) && keccak256(lhs_trimmed_2) == keccak256(rhs_trimmed_2);\\n    }\\n\\n    // PartialExitNFT pubdata\\n    struct PartialExitNFT {\\n//        uint32 accountId;\\n        uint64 globalId;\\n        uint32 creatorId;\\n        uint32 seqId;\\n        bytes32 uri;\\n        address owner;\\n    }\\n\\n    function readPartialExitNFTPubdata(bytes memory _data, uint _offset) internal pure\\n    returns (PartialExitNFT memory parsed) {\\n        uint offset = _offset + ACCOUNT_ID_BYTES;                   // accountId (ignored)\\n        (offset, parsed.globalId) = Bytes.readUInt64(_data, offset);   // globalId\\n        (offset, parsed.creatorId) = Bytes.readUInt32(_data, offset);   // creatorId\\n        (offset, parsed.seqId) = Bytes.readUInt32(_data, offset);   // seqId\\n        (offset, parsed.uri) = Bytes.readBytes32(_data, offset);   // uri\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);    // owner\\n    }\\n\\n    function writePartialExitNFTPubdata(PartialExitNFT memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),  // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.globalId, // tokenId in layer2\\n            bytes4(0),\\n            bytes4(0),\\n            bytes32(0),\\n            op.owner\\n        );\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title ZKSwap configuration constants\\n/// @author Matter Labs\\n/// @author ZKSwap L2 Labs\\ncontract Config {\\n\\n    /// @notice ERC20 token withdrawal gas limit, used only for complete withdrawals\\n    uint256 constant ERC20_WITHDRAWAL_GAS_LIMIT = 350000;\\n\\n    /// @notice ERC721 token withdrawal gas limit, used only for complete withdrawals\\n    uint256 constant ERC721_WITHDRAWAL_GAS_LIMIT = 350000;\\n\\n    /// @notice ETH token withdrawal gas limit, used only for complete withdrawals\\n    uint256 constant ETH_WITHDRAWAL_GAS_LIMIT = 10000;\\n\\n    /// @notice Bytes in one chunk\\n    uint8 constant CHUNK_BYTES = 11;\\n\\n    /// @notice ZKSwap address length\\n    uint8 constant ADDRESS_BYTES = 20;\\n\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n\\n    /// @notice Public key bytes length\\n    uint8 constant PUBKEY_BYTES = 32;\\n\\n    /// @notice Ethereum signature r/s bytes length\\n    uint8 constant ETH_SIGN_RS_BYTES = 32;\\n\\n    /// @notice Success flag bytes length\\n    uint8 constant SUCCESS_FLAG_BYTES = 1;\\n\\n    /// @notice Max amount of fee tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 constant MAX_AMOUNT_OF_REGISTERED_FEE_TOKENS = 32 - 1;\\n\\n    /// @notice start ID for user tokens\\n    uint16 constant USER_TOKENS_START_ID = 32;\\n\\n    /// @notice Max amount of user tokens registered in the network\\n    uint16 constant MAX_AMOUNT_OF_REGISTERED_USER_TOKENS = 16352;\\n\\n    /// @notice Max amount of tokens registered in the network\\n    uint16 constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 16384 - 1;\\n\\n    /// @notice Max account id that could be registered in the network\\n    uint32 constant MAX_ACCOUNT_ID = (2 ** 27) - 1;\\n\\n    /// @notice Max nft id that could be registered in the network\\n    uint64 constant MAX_NFT_ID = 2**(27+16);\\n\\n    /// @notice Expected average period of block creation\\n    uint256 constant BLOCK_PERIOD = 15 seconds;\\n\\n    /// @notice ETH blocks verification expectation\\n    /// Blocks can be reverted if they are not verified for at least EXPECT_VERIFICATION_IN.\\n    /// If set to 0 validator can revert blocks at any time.\\n    uint256 constant EXPECT_VERIFICATION_IN = 0 hours / BLOCK_PERIOD;\\n\\n    uint256 constant NOOP_BYTES = 1 * CHUNK_BYTES;\\n    uint256 constant CREATE_PAIR_BYTES = 3 * CHUNK_BYTES;\\n    uint256 constant DEPOSIT_BYTES = 4 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_TO_NEW_BYTES = 4 * CHUNK_BYTES;\\n    uint256 constant PARTIAL_EXIT_BYTES = 5 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\\n    uint256 constant UNISWAP_ADD_LIQ_BYTES = 3 * CHUNK_BYTES;\\n    uint256 constant UNISWAP_RM_LIQ_BYTES = 3 * CHUNK_BYTES;\\n    uint256 constant UNISWAP_SWAP_BYTES = 2 * CHUNK_BYTES;\\n    uint256 constant DEPOSIT_NFT_BYTES = 7 * CHUNK_BYTES;\\n    uint256 constant MINT_NFT_BYTES = 5 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_NFT_BYTES = 3 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_TO_NEW_NFT_BYTES = 4 * CHUNK_BYTES;\\n    uint256 constant PARTIAL_EXIT_NFT_BYTES = 7 * CHUNK_BYTES;\\n    uint256 constant FULL_EXIT_NFT_BYTES = 7 * CHUNK_BYTES;\\n    uint256 constant APPROVE_NFT_BYTES = 3 * CHUNK_BYTES;\\n    uint256 constant EXCHANGE_NFT = 4 * CHUNK_BYTES;\\n\\n    /// @notice Full exit operation length\\n    uint256 constant FULL_EXIT_BYTES = 4 * CHUNK_BYTES;\\n\\n    /// @notice OnchainWithdrawal data length\\n    uint256 constant ONCHAIN_WITHDRAWAL_BYTES = 40;\\n\\n\\n    /// @notic OnchainWithdrawalNFT data length\\n    /// (uint8 isNFTWithdraw uint8 addToPendingWithdrawalsQueue, uint64 globalId, uint32 creator,\\n    //  uint32 seqId, address _toAddr, uint8 isValid)\\n    uint256 constant ONCHAIN_WITHDRAWAL_NFT_BYTES = 71;\\n\\n\\n    /// @notice ChangePubKey operation length\\n    uint256 constant CHANGE_PUBKEY_BYTES = 5 * CHUNK_BYTES;\\n\\n    /// @notice Expiration delta for priority request to be satisfied (in seconds)\\n    /// NOTE: Priority expiration should be > (EXPECT_VERIFICATION_IN * BLOCK_PERIOD), otherwise incorrect block with priority op could not be reverted.\\n    uint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\\n\\n    /// @notice Expiration delta for priority request to be satisfied (in ETH blocks)\\n    uint256 constant PRIORITY_EXPIRATION = PRIORITY_EXPIRATION_PERIOD / BLOCK_PERIOD;\\n\\n    /// @notice Maximum number of priority request to clear during verifying the block\\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\\n    uint64 constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\\n\\n    /// @notice Reserved time for users to send full exit priority operation in case of an upgrade (in seconds)\\n    uint constant MASS_FULL_EXIT_PERIOD = 3 days;\\n\\n    /// @notice Reserved time for users to withdraw funds from full exit priority operation in case of an upgrade (in seconds)\\n    uint constant TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT = 2 days;\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode (in seconds)\\n    // NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\\n    uint constant UPGRADE_NOTICE_PERIOD = MASS_FULL_EXIT_PERIOD + PRIORITY_EXPIRATION_PERIOD + TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT;\\n\\n    // @notice Default amount limit for each ERC20 deposit\\n    uint128 constant DEFAULT_MAX_DEPOSIT_AMOUNT = 2 ** 85;\\n}\\n\"\r\n    },\r\n    \"contracts/Events.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n\\n/// @title ZKSwap events\\n/// @author Matter Labs\\n/// @author ZKSwap L2 Labs\\ninterface Events {\\n\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when a block is verified\\n    event BlockVerification(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when a sequence of blocks is verified\\n    event MultiblockVerification(uint32 indexed blockNumberFrom, uint32 indexed blockNumberTo);\\n\\n    /// @notice Event emitted when user send a transaction to withdraw her funds from onchain balance\\n    event OnchainWithdrawal(\\n        address indexed owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Event emitted when user send a transaction to deposit her funds\\n    event OnchainDeposit(\\n        address indexed sender,\\n        uint16 indexed tokenId,\\n        uint128 amount,\\n        address indexed owner\\n    );\\n\\n    /// @notice Event emitted when user send a transaction to deposit her NFT\\n    event OnchainDepositNFT(\\n        address indexed sender,\\n        address indexed token,\\n        uint256  tokenId,\\n        address indexed owner\\n    );\\n\\n    /// @notice Event emitted when user send a transaction to full exit her NFT\\n    event OnchainFullExitNFT(\\n        uint32  indexed accountId,\\n        address indexed owner,\\n        uint64 indexed globalId\\n    );\\n\\n    event OnchainCreatePair(\\n        uint16 indexed tokenAId,\\n        uint16 indexed tokenBId,\\n        uint16 indexed pairId,\\n        address pair\\n    );\\n\\n    /// @notice Event emitted when user sends a authentication fact (e.g. pub-key hash)\\n    event FactAuth(\\n        address indexed sender,\\n        uint32 nonce,\\n        bytes fact\\n    );\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(\\n        uint32 indexed totalBlocksVerified,\\n        uint32 indexed totalBlocksCommitted\\n    );\\n\\n    /// @notice Exodus mode entered event\\n    event ExodusMode();\\n\\n    /// @notice New priority request event. Emitted when a request is placed into mapping\\n    event NewPriorityRequest(\\n        address sender,\\n        uint64 serialId,\\n        Operations.OpType opType,\\n        bytes pubData,\\n        bytes userData,\\n        uint256 expirationBlock\\n    );\\n\\n    /// @notice Deposit committed event.\\n    event DepositCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Deposit committed event.\\n    event DepositNFTCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint64 indexed globalId\\n    );\\n\\n    /// @notice Full exit committed event.\\n    event FullExitCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Full exit committed event.\\n    event FullExitNFTCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint64 indexed globalId\\n    );\\n\\n    /// @notice Pending withdrawals index range that were added in the verifyBlock operation.\\n    /// NOTE: processed indexes in the queue map are [queueStartIndex, queueEndIndex)\\n    event PendingWithdrawalsAdd(\\n        uint32 queueStartIndex,\\n        uint32 queueEndIndex\\n    );\\n\\n    /// @notice Pending withdrawals index range that were executed in the completeWithdrawals operation.\\n    /// NOTE: processed indexes in the queue map are [queueStartIndex, queueEndIndex)\\n    event PendingWithdrawalsComplete(\\n        uint32 queueStartIndex,\\n        uint32 queueEndIndex\\n    );\\n\\n    event CreatePairCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        uint16 tokenAId,\\n        uint16 tokenBId,\\n        uint16 indexed tokenPairId,\\n        address pair\\n    );\\n}\\n\\n/// @title Upgrade events\\n/// @author Matter Labs\\ninterface UpgradeEvents {\\n\\n    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts\\n    event NewUpgradable(\\n        uint indexed versionId,\\n        address indexed upgradeable\\n    );\\n\\n    /// @notice Upgrade mode enter event\\n    event NoticePeriodStart(\\n        uint indexed versionId,\\n        address[] newTargets,\\n        uint noticePeriod // notice period (in seconds)\\n    );\\n\\n    /// @notice Upgrade mode cancel event\\n    event UpgradeCancel(\\n        uint indexed versionId\\n    );\\n\\n    /// @notice Upgrade mode preparation status event\\n    event PreparationStart(\\n        uint indexed versionId\\n    );\\n\\n    /// @notice Upgrade mode complete event\\n    event UpgradeComplete(\\n        uint indexed versionId,\\n        address[] newTargets\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/PairTokenManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\ncontract PairTokenManager {\\n    /// @notice Max amount of pair tokens registered in the network.\\n    uint16 constant MAX_AMOUNT_OF_PAIR_TOKENS = 49152;\\n\\n    uint16 constant PAIR_TOKEN_START_ID = 16384;\\n\\n    /// @notice Total number of pair tokens registered in the network\\n    uint16 public totalPairTokens;\\n\\n    /// @notice List of registered tokens by tokenId\\n    mapping(uint16 => address) public tokenAddresses;\\n\\n    /// @notice List of registered tokens by address\\n    mapping(address => uint16) public tokenIds;\\n    \\n    /// @notice Token added to Franklin net\\n    event NewToken(\\n        address indexed token,\\n        uint16 indexed tokenId\\n    );\\n\\n    function addPairToken(address _token) internal {\\n        require(tokenIds[_token] == 0, \\\"pan1\\\"); // token exists\\n        require(totalPairTokens < MAX_AMOUNT_OF_PAIR_TOKENS, \\\"pan2\\\"); // no free identifiers for tokens\\n\\n        uint16 newPairTokenId = PAIR_TOKEN_START_ID + totalPairTokens;\\n        totalPairTokens++;\\n\\n        tokenAddresses[newPairTokenId] = _token;\\n        tokenIds[_token] = newPairTokenId;\\n        emit NewToken(_token, newPairTokenId);\\n    }\\n\\n    /// @notice Validate pair token address\\n    /// @param _tokenAddr Token address\\n    /// @return tokens id\\n    function validatePairTokenAddress(address _tokenAddr) public view returns (uint16) {\\n        uint16 tokenId = tokenIds[_tokenAddr];\\n        require(tokenId != 0, \\\"pms3\\\");\\n        require(tokenId <= (PAIR_TOKEN_START_ID -1 + MAX_AMOUNT_OF_PAIR_TOKENS), \\\"pms4\\\");\\n        return tokenId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n\\n    function initialize(address, address) external;\\n\\n    function mint(address to, uint amount) external;\\n    function burn(address to, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/Bytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\\n// implements the following algorithm:\\n// f(bytes memory input, uint offset) -> X out\\n// where byte representation of out is N bytes from input at the given offset\\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\\n// 2) We load W from memory into out, last N bytes of W are placed into out\\n\\nlibrary Bytes {\\n\\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 2);\\n    }\\n\\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 3);\\n    }\\n\\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 4);\\n    }\\n\\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 16);\\n    }\\n\\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\\n    function toBytesFromUIntTruncated(uint self, uint8 byteLength) private pure returns (bytes memory bts) {\\n        require(byteLength <= 32, \\\"bt211\\\");\\n        bts = new bytes(byteLength);\\n        // Even though the bytes will allocate a full word, we don't want\\n        // any potential garbage bytes in there.\\n        uint data = self << ((32 - byteLength) * 8);\\n        assembly {\\n            mstore(add(bts, /*BYTES_HEADER_SIZE*/32), data)\\n        }\\n    }\\n\\n    // Copies 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\\n        bts = toBytesFromUIntTruncated(uint(self), 20);\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\\n        uint256 offset = _start + 20;\\n        require(self.length >= offset, \\\"bta11\\\");\\n        assembly {\\n            addr := mload(add(self, offset))\\n        }\\n    }\\n\\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\\n        require(self.length >= (_start + 20), \\\"btb20\\\");\\n        assembly {\\n            r := mload(add(add(self, 0x20), _start))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x2)\\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\\n        uint256 offset = _start + 0x2;\\n        require(_bytes.length >= offset, \\\"btu02\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x3)\\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\\n        uint256 offset = _start + 0x3;\\n        require(_bytes.length >= offset, \\\"btu03\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x4)\\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\\n        uint256 offset = _start + 0x4;\\n        require(_bytes.length >= offset, \\\"btu04\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x8)\\n    function bytesToUInt64(bytes memory _bytes, uint256 _start) internal pure returns (uint64 r) {\\n        uint256 offset = _start + 0x8;\\n        require(_bytes.length >= offset, \\\"btu08\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x10)\\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\\n        uint256 offset = _start + 0x10;\\n        require(_bytes.length >= offset, \\\"btu16\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x14)\\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\\n        uint256 offset = _start + 0x14;\\n        require(_bytes.length >= offset, \\\"btu20\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x20)\\n    function bytesToBytes32(bytes memory  _bytes, uint256 _start) internal pure returns (bytes32 r) {\\n        uint256 offset = _start + 0x20;\\n        require(_bytes.length >= offset, \\\"btb32\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\\n    // Get slice from bytes arrays\\n    // Returns the newly created 'bytes memory'\\n    // NOTE: theoretically possible overflow of (_start + _length)\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length), \\\"bse11\\\"); // bytes length is less then start byte + length bytes\\n\\n        bytes memory tempBytes = new bytes(_length);\\n\\n        if (_length != 0) {\\n            // TODO: Review this thoroughly.\\n            assembly {\\n                let slice_curr := add(tempBytes, 0x20)\\n                let slice_end := add(slice_curr, _length)\\n\\n                for {\\n                    let array_current := add(_bytes, add(_start, 0x20))\\n                } lt(slice_curr, slice_end) {\\n                    slice_curr := add(slice_curr, 0x20)\\n                    array_current := add(array_current, 0x20)\\n                } {\\n                    mstore(slice_curr, mload(array_current))\\n                }\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// Reads byte stream\\n    /// @return new_offset - offset + amount of bytes read\\n    /// @return data - actually read data\\n    // NOTE: theoretically possible overflow of (_offset + _length)\\n    function read(bytes memory _data, uint _offset, uint _length) internal pure returns (uint new_offset, bytes memory data) {\\n        data = slice(_data, _offset, _length);\\n        new_offset = _offset + _length;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readBool(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bool r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]) != 0;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readUint8(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint8 r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 2)\\n    function readUInt16(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint16 r) {\\n        new_offset = _offset + 2;\\n        r = bytesToUInt16(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 3)\\n    function readUInt24(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint24 r) {\\n        new_offset = _offset + 3;\\n        r = bytesToUInt24(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 4)\\n    function readUInt32(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint32 r) {\\n        new_offset = _offset + 4;\\n        r = bytesToUInt32(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 8)\\n    function readUInt64(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint64 r) {\\n        new_offset = _offset + 8;\\n        r = bytesToUInt64(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 16)\\n    function readUInt128(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint128 r) {\\n        new_offset = _offset + 16;\\n        r = bytesToUInt128(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readUInt160(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint160 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToUInt160(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readAddress(bytes memory _data, uint _offset) internal pure returns (uint new_offset, address r) {\\n        new_offset = _offset + 20;\\n        r = bytesToAddress(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readBytes20(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bytes20 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToBytes20(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 32)\\n    function readBytes32(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bytes32 r) {\\n        new_offset = _offset + 32;\\n        r = bytesToBytes32(_data, _offset);\\n    }\\n\\n    // Helper function for hex conversion.\\n    function halfByteToHex(byte _byte) internal pure returns (byte _hexByte) {\\n        require(uint8(_byte) < 0x10, \\\"hbh11\\\");  // half byte's value is out of 0..15 range.\\n\\n        // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n        return byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byte) * 8)));\\n    }\\n\\n    // Convert bytes to ASCII hex representation\\n    function bytesToHexASCIIBytes(bytes memory  _input) internal pure returns (bytes memory _output) {\\n        bytes memory outStringBytes = new bytes(_input.length * 2);\\n\\n        // code in `assembly` construction is equivalent of the next code:\\n        // for (uint i = 0; i < _input.length; ++i) {\\n        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);\\n        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);\\n        // }\\n        assembly {\\n            let input_curr := add(_input, 0x20)\\n            let input_end := add(input_curr, mload(_input))\\n\\n            for {\\n                let out_curr := add(outStringBytes, 0x20)\\n            } lt(input_curr, input_end) {\\n                input_curr := add(input_curr, 0x01)\\n                out_curr := add(out_curr, 0x02)\\n            } {\\n                let curr_input_byte := shr(0xf8, mload(input_curr))\\n                // here outStringByte from each half of input byte calculates by the next:\\n                //\\n                // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n                // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))\\n                mstore(out_curr,            shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130)))\\n                mstore(add(out_curr, 0x01), shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130)))\\n            }\\n        }\\n        return outStringBytes;\\n    }\\n\\n    /// Trim bytes into single word\\n    function trim(bytes memory _data, uint _new_length) internal pure returns (uint r) {\\n        require(_new_length <= 0x20, \\\"trm10\\\");  // new_length is longer than word\\n        require(_data.length >= _new_length, \\\"trm11\\\");  // data is to short\\n\\n        uint a;\\n        assembly {\\n            a := mload(add(_data, 0x20)) // load bytes into uint256\\n        }\\n\\n        return a >> ((0x20 - _new_length) * 8);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Governance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Config.sol\\\";\\n\\n\\n/// @title Governance Contract\\n/// @author Matter Labs\\n/// @author ZKSwap L2 Labs\\ncontract Governance is Config {\\n\\n    /// @notice Token added to Franklin net\\n    event NewToken(\\n        address indexed token,\\n        uint16 indexed tokenId\\n    );\\n\\n    /// @notice Governor changed\\n    event NewGovernor(\\n        address newGovernor\\n    );\\n\\n    /// @notice tokenLister changed\\n    event NewTokenLister(\\n        address newTokenLister\\n    );\\n\\n    /// @notice Validator's status changed\\n    event ValidatorStatusUpdate(\\n        address indexed validatorAddress,\\n        bool isActive\\n    );\\n\\n    /// @notice Address which will exercise governance over the network i.e. add tokens, change validator set, conduct upgrades\\n    address public networkGovernor;\\n\\n    /// @notice Total number of ERC20 fee tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 public totalFeeTokens;\\n\\n    /// @notice Total number of ERC20 user tokens registered in the network\\n    uint16 public totalUserTokens;\\n\\n    /// @notice List of registered tokens by tokenId\\n    mapping(uint16 => address) public tokenAddresses;\\n\\n    /// @notice List of registered tokens by address\\n    mapping(address => uint16) public tokenIds;\\n\\n    /// @notice List of permitted validators\\n    mapping(address => bool) public validators;\\n\\n    address public tokenLister;\\n\\n    constructor() public {\\n        networkGovernor = msg.sender;\\n    }\\n\\n    /// @notice Governance contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    ///     _networkGovernor The address of network governor\\n    function initialize(bytes calldata initializationParameters) external {\\n        require(networkGovernor == address(0), \\\"init0\\\");\\n        (address _networkGovernor, address _tokenLister) = abi.decode(initializationParameters, (address, address));\\n\\n        networkGovernor = _networkGovernor;\\n        tokenLister = _tokenLister;\\n    }\\n\\n    /// @notice Governance contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    /// @notice Change current governor\\n    /// @param _newGovernor Address of the new governor\\n    function changeGovernor(address _newGovernor) external {\\n        requireGovernor(msg.sender);\\n        require(_newGovernor != address(0), \\\"zero address is passed as _newGovernor\\\");\\n        if (networkGovernor != _newGovernor) {\\n            networkGovernor = _newGovernor;\\n            emit NewGovernor(_newGovernor);\\n        }\\n    }\\n\\n    /// @notice Change current governor\\n    /// @param _newTokenLister Address of the new tokenLister\\n    function changeTokenLister(address _newTokenLister) external {\\n        requireGovernor(msg.sender);\\n        require(_newTokenLister != address(0), \\\"zero address is passed as _newTokenLister\\\");\\n        if (tokenLister != _newTokenLister) {\\n            tokenLister = _newTokenLister;\\n            emit NewTokenLister(_newTokenLister);\\n        }\\n    }\\n\\n    /// @notice Add fee token to the list of networks tokens\\n    /// @param _token Token address\\n    function addFeeToken(address _token) external {\\n        requireGovernor(msg.sender);\\n        require(tokenIds[_token] == 0, \\\"gan11\\\"); // token exists\\n        require(totalFeeTokens < MAX_AMOUNT_OF_REGISTERED_FEE_TOKENS, \\\"fee12\\\"); // no free identifiers for tokens\\n\\trequire(\\n            _token != address(0), \\\"address cannot be zero\\\"\\n        );\\n\\n        totalFeeTokens++;\\n        uint16 newTokenId = totalFeeTokens; // it is not `totalTokens - 1` because tokenId = 0 is reserved for eth\\n\\n        tokenAddresses[newTokenId] = _token;\\n        tokenIds[_token] = newTokenId;\\n        emit NewToken(_token, newTokenId);\\n    }\\n\\n    /// @notice Add token to the list of networks tokens\\n    /// @param _token Token address\\n    function addToken(address _token) external {\\n        requireTokenLister(msg.sender);\\n        require(tokenIds[_token] == 0, \\\"gan11\\\"); // token exists\\n        require(totalUserTokens < MAX_AMOUNT_OF_REGISTERED_USER_TOKENS, \\\"gan12\\\"); // no free identifiers for tokens\\n        require(\\n            _token != address(0), \\\"address cannot be zero\\\"\\n        );\\n\\n        uint16 newTokenId = USER_TOKENS_START_ID + totalUserTokens;\\n        totalUserTokens++;\\n\\n        tokenAddresses[newTokenId] = _token;\\n        tokenIds[_token] = newTokenId;\\n        emit NewToken(_token, newTokenId);\\n    }\\n\\n    /// @notice Change validator status (active or not active)\\n    /// @param _validator Validator address\\n    /// @param _active Active flag\\n    function setValidator(address _validator, bool _active) external {\\n        requireGovernor(msg.sender);\\n        if (validators[_validator] != _active) {\\n            validators[_validator] = _active;\\n            emit ValidatorStatusUpdate(_validator, _active);\\n        }\\n    }\\n\\n    /// @notice Check if specified address is is governor\\n    /// @param _address Address to check\\n    function requireGovernor(address _address) public view {\\n        require(_address == networkGovernor, \\\"grr11\\\"); // only by governor\\n    }\\n\\n    /// @notice Check if specified address can list token\\n    /// @param _address Address to check\\n    function requireTokenLister(address _address) public view {\\n        require(_address == networkGovernor || _address == tokenLister, \\\"grr11\\\"); // token lister or governor\\n    }\\n\\n    /// @notice Checks if validator is active\\n    /// @param _address Validator address\\n    function requireActiveValidator(address _address) external view {\\n        require(validators[_address], \\\"grr21\\\"); // validator is not active\\n    }\\n\\n    /// @notice Validate token id (must be less than or equal to total tokens amount)\\n    /// @param _tokenId Token id\\n    /// @return bool flag that indicates if token id is less than or equal to total tokens amount\\n    function isValidTokenId(uint16 _tokenId) external view returns (bool) {\\n        return (_tokenId <= totalFeeTokens) || (_tokenId >= USER_TOKENS_START_ID && _tokenId < (USER_TOKENS_START_ID + totalUserTokens  ));\\n    }\\n\\n    /// @notice Validate token address\\n    /// @param _tokenAddr Token address\\n    /// @return tokens id\\n    function validateTokenAddress(address _tokenAddr) external view returns (uint16) {\\n        uint16 tokenId = tokenIds[_tokenAddr];\\n        require(tokenId != 0, \\\"gvs11\\\"); // 0 is not a valid token\\n\\trequire(tokenId <= MAX_AMOUNT_OF_REGISTERED_TOKENS, \\\"gvs12\\\");\\n        return tokenId;\\n    }\\n\\n    function getTokenAddress(uint16 _tokenId) external view returns (address) {\\n        address tokenAddr = tokenAddresses[_tokenId];\\n        return tokenAddr;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nft/IZKSeaNFT.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./libs/IERC721.sol\\\";\\nimport \\\"../Operations.sol\\\";\\n\\ninterface IZKSeaNFT {\\n    function onDeposit(IERC721 c, uint256 tokenId, address addr) external returns (Operations.DepositNFT memory);\\n    function addWithdraw(Operations.WithdrawNFTData calldata wd) external;\\n    function genWithdrawItems(uint32 n) external returns (WithdrawItem[] memory);\\n    function onWithdraw(address target, uint64 globalId) external returns (address, uint256);\\n    function withdrawBalanceUpdate(address addr, uint64 globalId) external;\\n    function numOfPendingWithdrawals() external view returns (uint32);\\n\\n    struct WithdrawItem {\\n        address tokenContract;\\n        uint256 tokenId;\\n        uint64 globalId;\\n        address to;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Verifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./KeysWithPlonkAggVerifier.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract Verifier is KeysWithPlonkAggVerifier {\\n\\n    bool constant DUMMY_VERIFIER = false;\\n\\n    function initialize(bytes calldata) external {\\n    }\\n\\n    /// @notice Verifier contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    function isBlockSizeSupported(uint32 _size) public pure returns (bool) {\\n        if (DUMMY_VERIFIER) {\\n            return true;\\n        } else {\\n            return isBlockSizeSupportedInternal(_size);\\n        }\\n    }\\n\\n    function verifyMultiblockProof(\\n        uint256[] calldata _recursiveInput,\\n        uint256[] calldata _proof,\\n        uint32[] calldata _block_sizes,\\n        uint256[] calldata _individual_vks_inputs,\\n        uint256[] calldata _subproofs_limbs\\n    ) external view returns (bool) {\\n        if (DUMMY_VERIFIER) {\\n            uint oldGasValue = gasleft();\\n            uint tmp;\\n            while (gasleft() + 500000 > oldGasValue) {\\n                tmp += 1;\\n            }\\n            return true;\\n        }\\n        uint8[] memory vkIndexes = new uint8[](_block_sizes.length);\\n        for (uint32 i = 0; i < _block_sizes.length; i++) {\\n            vkIndexes[i] = blockSizeToVkIndex(_block_sizes[i]);\\n        }\\n        VerificationKey memory vk = getVkAggregated(uint32(_block_sizes.length));\\n        return  verify_serialized_proof_with_recursion(_recursiveInput, _proof, VK_TREE_ROOT, VK_MAX_INDEX, vkIndexes, _individual_vks_inputs, _subproofs_limbs, vk);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/VerifierExit.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./KeysWithPlonkSingleVerifier.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract VerifierExit is KeysWithPlonkSingleVerifier {\\n\\n    function initialize(bytes calldata) external {\\n    }\\n\\n    /// @notice VerifierExit contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    function verifyExitProof(\\n        bytes32 _rootHash,\\n        uint32 _accountId,\\n        address _owner,\\n        uint16 _tokenId,\\n        uint128 _amount,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes32 commitment = sha256(abi.encodePacked(_rootHash, _accountId, _owner, _tokenId, _amount));\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkExit();\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n\\n\\n    function verifyExitNFTProof(\\n        bytes32 _rootHash,\\n        uint64 _tokenId,\\n        uint32 _creatorId,\\n        uint32 _seqId,\\n        bytes32 _uri,\\n        address _owner,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes32 commitment = sha256(abi.encodePacked(_rootHash, _tokenId, _creatorId, _seqId, _uri, _owner));\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkNFTExit();\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n\\n    function concatBytes(bytes memory param1, bytes memory param2) public pure returns (bytes memory) {\\n        bytes memory merged = new bytes(param1.length + param2.length);\\n\\n        uint k = 0;\\n        for (uint i = 0; i < param1.length; i++) {\\n            merged[k] = param1[i];\\n            k++;\\n        }\\n\\n        for (uint i = 0; i < param2.length; i++) {\\n            merged[k] = param2[i];\\n            k++;\\n        }\\n        return merged;\\n    }\\n\\n    function verifyLpExitProof(\\n        bytes calldata _account_data,\\n        bytes calldata _pair_data0,\\n        bytes calldata _pair_data1,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes memory _data1 = concatBytes(_account_data, _pair_data0);\\n        bytes memory _data2 = concatBytes(_data1, _pair_data1);\\n        bytes32 commitment = sha256(_data2);\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkLpExit();\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/UniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './UniswapV2Pair.sol';\\n\\ncontract UniswapV2Factory is IUniswapV2Factory {\\n    mapping(address => mapping(address => address)) public getPair;\\n    address[] public allPairs;\\n    address public zkSyncAddress;\\n\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    constructor() public {\\n    }\\n\\n    function initialize(bytes calldata data) external {\\n\\n    }\\n\\n    function setZkSyncAddress(address _zksyncAddress) external {\\n        require(zkSyncAddress == address(0), \\\"szsa1\\\");\\n        zkSyncAddress = _zksyncAddress;\\n    }\\n\\n    /// @notice PairManager contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    function allPairsLength() external view returns (uint) {\\n        return allPairs.length;\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\\n        require(msg.sender == zkSyncAddress, 'fcp1');\\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        //require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n\\n        require(zkSyncAddress != address(0), 'wzk');\\n        IUniswapV2Pair(pair).initialize(token0, token1);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function mint(address pair, address to, uint amount) external {\\n        require(msg.sender == zkSyncAddress, 'fmt1');\\n        IUniswapV2Pair(pair).mint(to, amount);\\n    }\\n\\n    function burn(address pair, address to, uint amount) external {\\n        require(msg.sender == zkSyncAddress, 'fbr1');\\n        IUniswapV2Pair(pair).burn(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\n/// @author ZKSwap L2 Labs\\ninterface Upgradeable {\\n\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/nft/libs/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/KeysWithPlonkAggVerifier.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PlonkAggCore.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkAggVerifier is AggVerifierWithDeserialize {\\n\\nuint256 constant VK_TREE_ROOT = 0x106d6ce8f9af9a0f7a8d14c821ea38368146519aa0c61caa1f694a29751cfddb;\\nuint8 constant VK_MAX_INDEX = 4;\\n\\nfunction isBlockSizeSupportedInternal(uint32 _size) internal pure returns (bool) {\\nif (_size == uint32(12)) { return true; }\\nelse if (_size == uint32(36)) { return true; }\\nelse if (_size == uint32(78)) { return true; }\\nelse if (_size == uint32(156)) { return true; }\\nelse if (_size == uint32(318)) { return true; }\\nelse { return false; }\\n}\\n\\nfunction blockSizeToVkIndex(uint32 _chunks) internal pure returns (uint8) {\\nif (_chunks == uint32(12)) { return 0; }\\nelse if (_chunks == uint32(36)) { return 1; }\\nelse if (_chunks == uint32(78)) { return 2; }\\nelse if (_chunks == uint32(156)) { return 3; }\\nelse if (_chunks == uint32(318)) { return 4; }\\n}\\n\\n\\nfunction getVkAggregated(uint32 _blocks) internal pure returns (VerificationKey memory vk) {\\nif (_blocks == uint32(1)) { return getVkAggregated1(); }\\nelse if (_blocks == uint32(5)) { return getVkAggregated5(); }\\nelse if (_blocks == uint32(10)) { return getVkAggregated10(); }\\nelse if (_blocks == uint32(20)) { return getVkAggregated20(); }\\n}\\n\\n\\nfunction getVkAggregated1() internal pure returns(VerificationKey memory vk) {\\nvk.domain_size = 4194304;\\nvk.num_inputs = 1;\\nvk.omega = PairingsBn254.new_fr(0x18c95f1ae6514e11a1b30fd7923947c5ffcec5347f16e91b4dd654168326bede);\\nvk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n0x19fbd6706b4cbde524865701eae0ae6a270608a09c3afdab7760b685c1c6c41b,\\n0x25082a191f0690c175cc9af1106c6c323b5b5de4e24dc23be1e965e1851bca48\\n);\\nvk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n0x16c02d9ca95023d1812a58d16407d1ea065073f02c916290e39242303a8a1d8e,\\n0x230338b422ce8533e27cd50086c28cb160cf05a7ae34ecd5899dbdf449dc7ce0\\n);\\nvk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n0x1db0d133243750e1ea692050bbf6068a49dc9f6bae1f11960b6ce9e10adae0f5,\\n0x12a453ed0121ae05de60848b4374d54ae4b7127cb307372e14e8daf5097c5123\\n);\\nvk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n0x1062ed5e86781fd34f78938e5950c2481a79f132085d2bc7566351ddff9fa3b7,\\n0x2fd7aac30f645293cc99883ab57d8c99a518d5b4ab40913808045e8653497346\\n);\\nvk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n0x062755048bb95739f845e8659795813127283bf799443d62fea600ae23e7f263,\\n0x2af86098beaa241281c78a454c5d1aa6e9eedc818c96cd1e6518e1ac2d26aa39\\n);\\nvk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n0x0994e25148bbd25be655034f81062d1ebf0a1c2b41e0971434beab1ae8101474,\\n0x27cc8cfb1fafd13068aeee0e08a272577d89f8aa0fb8507aabbc62f37587b98f\\n);\\nvk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n0x044edf69ce10cfb6206795f92c3be2b0d26ab9afd3977b789840ee58c7dbe927,\\n0x2a8aa20c106f8dc7e849bc9698064dcfa9ed0a4050d794a1db0f13b0ee3def37\\n);\\n\\nvk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n0x136967f1a2696db05583a58dbf8971c5d9d1dc5f5c97e88f3b4822aa52fefa1c,\\n0x127b41299ea5c840c3b12dbe7b172380f432b7b63ce3b004750d6abb9e7b3b7a\\n);\\nvk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n0x02fd5638bf3cc2901395ad1124b951e474271770a337147a2167e9797ab9d951,\\n0x0fcb2e56b077c8461c36911c9252008286d782e96030769bf279024fc81d412a\\n);\\n\\nvk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n0x1865c60ecad86f81c6c952445707203c9c7fdace3740232ceb704aefd5bd45b3,\\n0x2f35e29b39ec8bb054e2cff33c0299dd13f8c78ea24a07622128a7444aba3f26\\n);\\nvk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n0x2a86ec9c6c1f903650b5abbf0337be556b03f79aecc4d917e90c7db94518dde6,\\n0x15b1b6be641336eebd58e7991be2991debbbd780e70c32b49225aa98d10b7016\\n);\\nvk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n0x213e42fcec5297b8e01a602684fcd412208d15bdac6b6331a8819d478ba46899,\\n0x03223485f4e808a3b2496ae1a3c0dfbcbf4391cffc57ee01e8fca114636ead18\\n);\\nvk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n0x2e9b02f8cf605ad1a36e99e990a07d435de06716448ad53053c7a7a5341f71e1,\\n0x2d6fdf0bc8bd89112387b1894d6f24b45dcb122c09c84344b6fc77a619dd1d59\\n);\\n\\nvk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000005\\n);\\nvk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000007\\n);\\nvk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n0x000000000000000000000000000000000000000000000000000000000000000a\\n);\\n\\nvk.g2_x = PairingsBn254.new_g2(\\n[0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n[0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n);\\n}\\n\\nfunction getVkAggregated5() internal pure returns(VerificationKey memory vk) {\\nvk.domain_size = 16777216;\\nvk.num_inputs = 1;\\nvk.omega = PairingsBn254.new_fr(0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb);\\nvk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n0x023cfc69ef1b002da66120fce352ede75893edd8cd8196403a54e1eceb82cd43,\\n0x2baf3bd673e46be9df0d43ca30f834671543c22db422f450b2efd8c931e9b34e\\n);\\nvk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n0x23783fe0e5c3f83c02c864e25fe766afb727134c9a77ae6b9694efb7b46f31ab,\\n0x1903d01005e447d061c16323a1d604d8fbd4b5cc9b64945a71f1234d280c4d3a\\n);\\nvk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n0x2897df6c6fa993661b2b0b0cf52460278e33533de71b3c0f7ed7c1f20af238c6,\\n0x042344afee0aed5505e59bce4ebbe942a91268a8af6b77ea95f603b5b726e8cb\\n);\\nvk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n0x0fceed33e78426afc38d8a68c0d93413d2bbaa492b087125271d33d52bdb07b8,\\n0x0057e4f63be36edb56e91da931f3d0ba72d1862d4b7751c59b92b6ae9f1fcc11\\n);\\nvk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n0x14230a35f172cd77a2147cecc20b2a13148363cbab78709489a29d08001e26fb,\\n0x04f1040477d77896475080b5abb8091cda2cce4917ee0ba5dd62d0ab1be379b4\\n);\\nvk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n0x20d1a079ad80a8abb7fd8ba669dddbbe23231360a5f0ba679b6536b6bf980649,\\n0x120c5a845903bd6de4105eb8cef90e6dff2c3888ada16c90e1efb393778d6a4d\\n);\\nvk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n0x1af6b9e362e458a96b8bbbf8f8ce2bdbd650fb68478360c408a2acf1633c1ce1,\\n0x27033728b767b44c659e7896a6fcc956af97566a5a1135f87a2e510976a62d41\\n);\\n\\nvk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n0x0dbfb3c5f5131eb6f01e12b1a6333b0ad22cc8292b666e46e9bd4d80802cccdf,\\n0x2d058711c42fd2fd2eef33fb327d111a27fe2063b46e1bb54b32d02e9676e546\\n);\\nvk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n0x0c8c7352a84dd3f32412b1a96acd94548a292411fd7479d8609ca9bd872f1e36,\\n0x0874203fd8012d6976698cc2df47bca14bc04879368ade6412a2109c1e71e5e8\\n);\\n\\nvk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n0x1b17bb7c319b1cf15461f4f0b69d98e15222320cb2d22f4e3a5f5e0e9e51f4bd,\\n0x0cf5bc338235ded905926006027aa2aab277bc32a098cd5b5353f5545cbd2825\\n);\\nvk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n0x0794d3cfbc2fdd756b162571a40e40b8f31e705c77063f30a4e9155dbc00e0ef,\\n0x1f821232ab8826ea5bf53fe9866c74e88a218c8d163afcaa395eda4db57b7a23\\n);\\nvk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n0x224d93783aa6856621a9bbec495f4830c94994e266b240db9d652dbb394a283b,\\n0x161bcec99f3bc449d655c0ca59874dafe1194138eec91af34392b09a83338ca1\\n);\\nvk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n0x1fa27e2916b2c11d39c74c0e61063190da31c102d2b7da5c0a61ec8c5e82f132,\\n0x0a815ee76cd8aa600e6f66463b25a0ee57814bfdf06c65a91ddc70cede41caae\\n);\\n\\nvk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000005\\n);\\nvk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000007\\n);\\nvk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n0x000000000000000000000000000000000000000000000000000000000000000a\\n);\\n\\nvk.g2_x = PairingsBn254.new_g2(\\n[0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n[0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n);\\n}\\n\\nfunction getVkAggregated10() internal pure returns(VerificationKey memory vk) {\\nvk.domain_size = 33554432;\\nvk.num_inputs = 1;\\nvk.omega = PairingsBn254.new_fr(0x0d94d63997367c97a8ed16c17adaae39262b9af83acb9e003f94c217303dd160);\\nvk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n0x118a33d75bd2b49bc91e7e9b60592a9e93128780f0ee45909d5c1583fc312e2b,\\n0x029bfeb33d7ea821336d26518d0ea369963ed9a697feab042ed9c1196ce60fcd\\n);\\nvk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n0x237c2be6d5ab05dac2f085e603d16a40474d8507e9e3ffb26ca054b71bec84e8,\\n0x0a041723d3c5882a11f0380cab33ba8c0ec5d333b7618b477073970b93e4161b\\n);\\nvk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n0x06e8bb6c2c9ef293a5273b2a501c8484c81cf8907eb20b3b3e8745670d3edf9c,\\n0x144efe2e483905c439661fdce23df9ebbadd45dd8002ff5658356e4448c12cdf\\n);\\nvk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n0x186679a0b8edcf535be61dd0c4b3d9f1f1d570f53ace4100c154bc8d857467a3,\\n0x0b294653f6bba0293f8d9a91dff2bf2156d7a7169e22ae80f31dc10a500d1275\\n);\\nvk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n0x1b097f651e551cfca089d6483aa78c9fca8022f11cc0f5210062df4ea09675dc,\\n0x08cd7b2c48da8faefa0d79d5ca5e6106d9375e17a65d8ff184eed450e4d90de4\\n);\\nvk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n0x2f558b39270c076e92f12a09863a5b70ba3f471e75bc4a76c5bf0709bc39410a,\\n0x25f36985d8ede876604c7f5d08dd2fb6f4b069d6e8d587dbb50f7418b3ff87d3\\n);\\nvk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n0x194e7f1cf485a42a4d4313a28ba289a9a2d80a09482cc85acbc2b39713bae24a,\\n0x2f9491a38a23267390e77c706ad178a4884cf960708c601e2841cc173c580427\\n);\\n\\nvk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n0x11aea225adaaced8cadf40634b8ec791133a571f1ef60e9857305d1b6c4af319,\\n0x1c71a79c4433117ec0ef80d773cf03dc2555d10cfa8726301f4fda6a273f9790\\n);\\nvk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n0x12f7e96a400593a494e9d5541b641c804edabdb56f9a3004187e82fc97f45e41,\\n0x14205d243f5a63f318b0826e2b69aaa61dd8e19cb1b353545619b063dc2a4c52\\n);\\n\\nvk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n0x1faf8943996cbaa6882e78b34bce97e5c2e623e7ba4c1f46cbfba88da7ffd132,\\n0x1fbb80b092682f790975ae9323c957b49d51f9e5562152fc73bc00c291a71664\\n);\\nvk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n0x0871ff65b88a40eec8c8a9573625b76eb7c5cd07e1374fb29b984c8e9bdac46b,\\n0x2788d12e2329037f8184ee892a22a92d056616921d3df424a208ebd06b7870e7\\n);\\nvk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n0x1b54676a721bbeb1304eb2721a0ce8d8f147e792481880a3e9164de4ed8958c7,\\n0x0af99225ab387d31f9654e8b26de1b67a175e47d59adaf6340fbc1dcc7ce2196\\n);\\nvk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n0x1313fcb16f52505aee519aff9adc46c81d7fc702d41ce04a89516c7da5a5cc4a,\\n0x060a56882fc5eeb6f267876174fb0490c0c6ccde2ed4f56b021370d47051caac\\n);\\n\\nvk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000005\\n);\\nvk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000007\\n);\\nvk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n0x000000000000000000000000000000000000000000000000000000000000000a\\n);\\n\\nvk.g2_x = PairingsBn254.new_g2(\\n[0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n[0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n);\\n}\\n\\nfunction getVkAggregated20() internal pure returns(VerificationKey memory vk) {\\nvk.domain_size = 67108864;\\nvk.num_inputs = 1;\\nvk.omega = PairingsBn254.new_fr(0x1dba8b5bdd64ef6ce29a9039aca3c0e524395c43b9227b96c75090cc6cc7ec97);\\nvk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n0x2657afa69e15a3998bde27116082a0e8cfe5e7fe9be3ffb37d318b5368e92a2f,\\n0x15b2c5e18b45bdc797c1102ad693259df3f3cdf7432b21337a93dd428878d4dc\\n);\\nvk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n0x120d7974239dd8111afeb34cca058db63227e5eea30495479c2f86ef2704239d,\\n0x185de0bdd64bb1f78e9de92bd71d112ce1b5290bd4f15f58e54ef783730bdb2e\\n);\\nvk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n0x20c77a6ac5ec6a5cf728a6496bad151a7fa84583a4e44cafab5335ece5b68e92,\\n0x28955c55fa76091bb1beb3bc81f3f0abea9c1772b213e9cc24fb32ce017fdc19\\n);\\nvk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n0x072a5373c38c252bbd9dbd16ea4ff418e3e6c3d13073c17347805af6afc016a0,\\n0x150ff2f3ae9c31a8c94c31605f5f70804bdf3bc601269bca4b6b4137eaf2db53\\n);\\nvk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n0x2d8fc65e12e3262a891d252a81f13f75e03e5e3be04ca03a0c376a1aafa833c5,\\n0x14b32a4898df4aa936fe124a5dc886263e12b0f173b8e96eb011eea6b43a6c2b\\n);\\nvk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n0x2a10059adb643c8fd510fa78b1d3ca75acfabf6dd02e777421510f59b7fe35db,\\n0x0de555189d42fbe10d0f1f325b431499562fc0bdfa631e24babc3b08f2b40239\\n);\\nvk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n0x15aebf231748de2a113e3b78d4778ee429485ee725192adcd83d90195ae46a62,\\n0x1643482806d5c12ed94b8843ed3ab29b443be1c4303757b4494965e2725aca21\\n);\\n\\nvk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n0x22e8fa104dc1110e140f69f66defd24c501459661ab45680be88107773596583,\\n0x0dea216f16fedc871f884b081d934b7be1637c1705e33cee7e33d301e9dd0a31\\n);\\nvk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n0x24830cfaa291d8dcd99a8f7fcfe313645286e26c427a75ec64bb385d03d18a62,\\n0x0cf6a160da9f331955256a0fba54561e82b6ee0ce2f4fa434addf1e07304f4ea\\n);\\n\\nvk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n0x05a5a5b8bd64cb5c0ec27397ece0f4c00e1f0889f1516b4ba8b821f832b24bb6,\\n0x22d6f8ac4a745aaaa9b48b388f7ca383f13d1684e04b24f627fbfa65d10404c0\\n);\\nvk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n0x0b44251fce15393e219d9bec3e17261f9b041b2b837ed6897735544e0d7d195d,\\n0x15c907d4d776e0878ab9491847edc0a857ef4c7ca77acd365d95f00dddc327aa\\n);\\nvk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n0x132f2aafa0add2184b557aa5e5a75cbef16661fd28209728a658dbda6fdccfbb,\\n0x223da3cd1f9ad3cf6a0cd37ceb1010286bcd88a92a16eef81447bbd0b365042c\\n);\\nvk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n0x3006215b71c3d3ce7dd057f3a139fbb293e44a6ed529494b4e32e4517f51b6f4,\\n0x061a53d503897b89fd301316a738bf7b0e483232dc9e38677a18a8d3742cb370\\n);\\n\\nvk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000005\\n);\\nvk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n0x0000000000000000000000000000000000000000000000000000000000000007\\n);\\nvk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n0x000000000000000000000000000000000000000000000000000000000000000a\\n);\\n\\nvk.g2_x = PairingsBn254.new_g2(\\n[0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n[0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n);\\n}\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/KeysWithPlonkSingleVerifier.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.7.0;\\n\\nimport \\\"./PlonkSingleCore.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkSingleVerifier is SingleVerifierWithDeserialize {\\n\\n    function isBlockSizeSupportedInternal(uint32 _size) internal pure returns (bool) {\\n        if (_size == uint32(12)) { return true; }\\n        else if (_size == uint32(36)) { return true; }\\n        else if (_size == uint32(78)) { return true; }\\n        else if (_size == uint32(156)) { return true; }\\n        else if (_size == uint32(318)) { return true; }\\n        else { return false; }\\n    }\\n\\n    \\n    function getVkExit() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 262144;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0f60c8fe0414cb9379b2d39267945f6bd60d06a05216231b26a9fcf88ddbfebe);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x135a8971e309397099f1c5c0b9c2a141e83b888ff0504ba8c9a7c13b8c66873f,\\n            0x0eed3feed06aa8e4d3493aefd4c6f9a6c337e20b7e2f20d22b08b3b4129f8efc\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x0b97dc8947583759347e13c8f2abdccf1004e13f771fe9c46155af71d336de2e,\\n            0x1d39ffdb681fca7ce01b775e9aaaf5d8b71d9b7602ac00c60bbde91dca816dec\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x04b4d20919f8c66794a986ad27a0e4e820fb7a1bf863048017a59b1f7b3030f6,\\n            0x2da162d6902e64de2d4f6178f090bf9db7fbb9199d1640d5eab9c0a26869524f\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x242d28e776c833130fb04fb097c1c166c4293018e64947c46086f1bea2184732,\\n            0x277463020cda47c42366610a37cde00ef3a32b44906e1adee02fcd66bbe44a75\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x24d289d00964c5501b4a32521df5685264fb490a4549e794f998f18f169f3195,\\n            0x14307765ce1383efab72009df36fd97d28b94c9c1fce57a64697e5633d8d4e0d\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x0c3697df5aef9952def7b12d29447e9ae12fe6580f0e00399237bee51a5fa0e0,\\n            0x2b120b7d414a0843aa2e9e606bcec5ff8eb3c38d8b73479de42fc8901bb626e6\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x0e09a50a8e0635250a3a200dab94a1a51de811b179f61df2d4683e59fd1774ee,\\n            0x251732ea6c2951b7b54f2dbc349b14db2b63def8d132f86499d2e43edc21ad51\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1889e41a3cebf0b097ec6cef8849e66480c344c422ed9a2e4d63fe75155af0d0,\\n            0x0ed098f479a2f229cd47f645517737f512612915010cb576398cd4ec7c803baf\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x141171280664b7aea2c65ddb87f28391cab60913a74f4255b3dd4295d162a02c,\\n            0x033c1cc5f1e58a035eb5f3951e79cc90e9fccf3c82781c2553b1d49694a18991\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x0fc9a25cc839ef11afab0a9f320cf2b7346054f566135611bb25b6cec46205b3,\\n            0x16ea53198b77ab1e469d166b36d89d9fd88b3c356958cdf377a534d73f47a9a3\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2040345b5f92cc70a9607cf5fc28e5be26f673852450488d4e65f70890649b45,\\n            0x2c0e0bf512b4aa690449b589513e2b34cbc5e748a4217947331e0350c73be310\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkLpExit() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 524288;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0cf1526aaafac6bacbb67d11a4077806b123f767e4b0883d14cc0193568fc082);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x26aafba448a6c22abfa5286eef01b17a6bffaacf20a8a0fca1a59035c8e45ddd,\\n            0x160835d2c20ea81f2f4c2c7f1644e30ae41b2541588a27552c08c190d5b32af8\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x20954e6cd2ad660dd9723263311b03986d6f8993ebfeb67a60a46608b35701fe,\\n            0x059ce6f6469bb72b8758473f86e86a959c4b9f74193d931dd172883c641a25c7\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x26245ff891a4328caa0da951efba1b5b3cc13136cd315ac7c8794053e47a4315,\\n            0x1681b7685491b5f8fb470a21a326bc91bd75178d411ead030aefcddd9b51bd06\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x2857e4543592da2693e7e97477f186736c4a0a325bd9477bbd996819dc0ca4ce,\\n            0x0ffe00e34dd8592675469bb7a92b1e78e7c9e4ace22343605fb3a48dd4f15970\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x0180059910e776f202efcb1b96d72ab597e811caef2a9af5d8b42fc79949d913,\\n            0x1a43d65fba7b7340f6cb120a31ad0a1d5a26e0a1151398d9a80d6930e623be21\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x007b755d547d62eaf1375f3efe8a62ef52ed1b40ef2ec0943ab9a1de7198f274,\\n            0x28f96cb876dc97aada23aa73d202682e3f29a29126d5711df0747234660cd83d\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x00dfc41dc088a145be5a6978121abea7dffaef90012b9d6f1b577e957a28dd24,\\n            0x2ef1b64e6b0afe751b5531869a17dd9d5c90d734880de7fed3d3ae74a01d989a\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1d69be00b5e7d9d2af9d10da25eda41333effe6b9435caefe07ddae096d30ddf,\\n            0x162137b0ead7f1be6f448f36db186c5bee0e44f19a926e88b53f7760b64e9dbd\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x179c8e2df764ec8a2a5f5dbd37ffdde057178b6c10ef04bbb3331a7843934331,\\n            0x1a71e27ade54b801c811bd10d93c2b9e6c80bfea3d808487cf375f50e065e896\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x2fc48aa7bcba72e922843e8732398afe655368a3aedca1f204b0e1bd9ddbf981,\\n            0x2f6adc4261e3dd2fc80affdb39de386de5c38aa0066a8560f76dff220341071a\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2a096bb764588fb3f422291918e33c1d8d9f5a8ef6c9cf41d288a5ddea0cf26a,\\n            0x1e2ab7435be44f4101b1af83f76d5b621f4ecdd9d673a4b019ffb41072413f9b\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkNFTExit() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 262144;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0f60c8fe0414cb9379b2d39267945f6bd60d06a05216231b26a9fcf88ddbfebe);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x27ad08e12b6087f6fe0d7e1d8d8f14f53e92aaabf05e4f7d1051b0fbe3db046d,\\n            0x11f1f49ccf9f433366c3dc71fe9efa794678b87cbb2b07deea0cfbb7093e5369\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x1ee701b0be61332b7de5d4260ad352a3f50a8e51ac4a761f6ab5077c8dffab51,\\n            0x21451115294a50d06c5c442e9a61b04699fd8f296e70ef00e78a5908ef541444\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x1eccd5e119cc4a7bc8d274e0d8f61a054ee38694796790dacd22a098642bf2bc,\\n            0x10bb95ce678a633560f0a704001e4c148aff47b7aee0856bfec735fb13884e02\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x013fa8820794811964f35f04adb7600a9a3c76c9960b9cbb162b8324e09a14f5,\\n            0x0c110889cdf3554c95c7876f3e9d64804b3f0a6effa2baaf8bcb4ca847e5ed1d\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x1d5d922608eb262a5b05dc872b81238a352ba3521a1e847b06606d0937c7a34c,\\n            0x291cd60f7f242bd5e1075f99ed70583f40460758aa58c8cd418cb5b6929e8c12\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x2bc438c9650f27fd6b4125e098c5d87f874cfd29efad4a3e4ecae04e23b05009,\\n            0x283af270ef1c1c897e85b844536745dbf4d744f2e0fe8dc113143b5209a60baa\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x16f50151d8dccdd5e06a29eee62a9f614d534c542640bee31e9e9a3f2b708a83,\\n            0x120854cacf85957ca9777576bda620a21312769ab9596c7c64dc742156839882\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x27d2cd3c7a778fed777f6410fca3a65521282818e187e901827b1e666281d38b,\\n            0x1f5484c3976cadaea11704759c33ecfffe4900b696febcffb397ec15324c484a\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x26a13c2a6968f979cfc4ef24b965487c5f22f2dfc5e9008942fa32bbb72f7b3c,\\n            0x2bbb803702a9e0c0d4e3a078e2ffa2c525165f940a551555efbdd8876cc3f06e\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x17210a663b894d0d08db4ba0f2da65bf67b5e4c94317d03e0eb6077b11e849ef,\\n            0x2c98fb45631bd244290296ce55afc885e0e3cc96b506037183338141e97fdf61\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x1ef739c21d81d82ecb30445c5c6e775597aed256ee615b84c71dff243c81dd9e,\\n            0x072138b9876fc2f52d29b5cf35478fe4091f384c034fa59ab4b29deb69e98281\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/UniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport './interfaces/IUniswapV2Pair.sol';\\nimport './UniswapV2ERC20.sol';\\nimport './libraries/Math.sol';\\nimport './libraries/UQ112x112.sol';\\nimport './interfaces/IUNISWAPERC20.sol';\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './interfaces/IUniswapV2Callee.sol';\\n\\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {\\n    using UniswapSafeMath  for uint;\\n    using UQ112x112 for uint224;\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n\\n    uint private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'UniswapV2: LOCKED');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    constructor() public {\\n        factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    function mint(address to, uint amount) external lock {\\n        require(msg.sender == factory, 'mt1');\\n        _mint(to, amount);\\n    }\\n\\n    function burn(address to, uint amount) external lock {\\n        require(msg.sender == factory, 'br1');\\n        _burn(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PlonkAggCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PlonkCoreLib.sol\\\";\\n\\ncontract Plonk4AggVerifierWithAccessToDNext {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n\\n    uint256 constant ZERO = 0;\\n    uint256 constant ONE = 1;\\n    uint256 constant TWO = 2;\\n    uint256 constant THREE = 3;\\n    uint256 constant FOUR = 4;\\n\\n    uint256 constant STATE_WIDTH = 4;\\n    uint256 constant NUM_DIFFERENT_GATES = 2;\\n    uint256 constant NUM_SETUP_POLYS_FOR_MAIN_GATE = 7;\\n    uint256 constant NUM_SETUP_POLYS_RANGE_CHECK_GATE = 0;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\\n    uint256 constant NUM_GATE_SELECTORS_OPENED_EXPLICITLY = 1;\\n\\n    uint256 constant RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 constant LIMB_WIDTH = 68;\\n\\n    struct VerificationKey {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[NUM_SETUP_POLYS_FOR_MAIN_GATE + NUM_SETUP_POLYS_RANGE_CHECK_GATE] gate_setup_commitments;\\n        PairingsBn254.G1Point[NUM_DIFFERENT_GATES] gate_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH] copy_permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH-1] copy_permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\\n        PairingsBn254.Fr[NUM_GATE_SELECTORS_OPENED_EXPLICITLY] gate_selector_values_at_z;\\n        PairingsBn254.Fr copy_grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH-1] permutation_polynomials_at_z;\\n\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function evaluate_vanishing(\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            inputs_term.add_assign(tmp);\\n        }\\n\\n        inputs_term.mul_assign(proof.gate_selector_values_at_z[0]);\\n        rhs.add_assign(inputs_term);\\n\\n        // now we need 5th power\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.copy_grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function add_contribution_from_range_constraint_gates(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        PairingsBn254.Fr memory current_alpha\\n    ) internal pure returns (PairingsBn254.Fr memory res) {\\n        // now add contribution from range constraint gate\\n        // we multiply selector commitment by all the factors (alpha*(c - 4d)(c - 4d - 1)(..-2)(..-3) + alpha^2 * (4b - c)()()() + {} + {})\\n\\n        PairingsBn254.Fr memory one_fr = PairingsBn254.new_fr(ONE);\\n        PairingsBn254.Fr memory two_fr = PairingsBn254.new_fr(TWO);\\n        PairingsBn254.Fr memory three_fr = PairingsBn254.new_fr(THREE);\\n        PairingsBn254.Fr memory four_fr = PairingsBn254.new_fr(FOUR);\\n\\n        res = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t0 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t2 = PairingsBn254.new_fr(0);\\n\\n        for (uint256 i = 0; i < 3; i++) {\\n            current_alpha.mul_assign(state.alpha);\\n\\n            // high - 4*low\\n\\n            // this is 4*low\\n            t0 = PairingsBn254.copy(proof.wire_values_at_z[3 - i]);\\n            t0.mul_assign(four_fr);\\n\\n            // high\\n            t1 = PairingsBn254.copy(proof.wire_values_at_z[2 - i]);\\n            t1.sub_assign(t0);\\n\\n            // t0 is now t1 - {0,1,2,3}\\n\\n            // first unroll manually for -0;\\n            t2 = PairingsBn254.copy(t1);\\n\\n            // -1\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(one_fr);\\n            t2.mul_assign(t0);\\n\\n            // -2\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(two_fr);\\n            t2.mul_assign(t0);\\n\\n            // -3\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(three_fr);\\n            t2.mul_assign(t0);\\n\\n            t2.mul_assign(current_alpha);\\n\\n            res.add_assign(t2);\\n        }\\n\\n        // now also d_next - 4a\\n\\n        current_alpha.mul_assign(state.alpha);\\n\\n        // high - 4*low\\n\\n        // this is 4*low\\n        t0 = PairingsBn254.copy(proof.wire_values_at_z[0]);\\n        t0.mul_assign(four_fr);\\n\\n        // high\\n        t1 = PairingsBn254.copy(proof.wire_values_at_z_omega[0]);\\n        t1.sub_assign(t0);\\n\\n        // t0 is now t1 - {0,1,2,3}\\n\\n        // first unroll manually for -0;\\n        t2 = PairingsBn254.copy(t1);\\n\\n        // -1\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(one_fr);\\n        t2.mul_assign(t0);\\n\\n        // -2\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(two_fr);\\n        t2.mul_assign(t0);\\n\\n        // -3\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(three_fr);\\n        t2.mul_assign(t0);\\n\\n        t2.mul_assign(current_alpha);\\n\\n        res.add_assign(t2);\\n\\n        return res;\\n    }\\n\\n    function reconstruct_linearization_commitment(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^{6} * (selector(x) - selector(z))\\n        // + v^{7..9} * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^10 (z(x) - z(z*omega)) <- we need this power\\n        // + v^11 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n\\n        // we reconstruct linearization polynomial virtual selector\\n        // for that purpose we first linearize over main gate (over all it's selectors)\\n        // and multiply them by value(!) of the corresponding main gate selector\\n        res = PairingsBn254.copy_g1(vk.gate_setup_commitments[STATE_WIDTH + 1]); // index of q_const(x)\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            tmp_g1 = vk.gate_setup_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH+2].point_mul(proof.wire_values_at_z_omega[0]); // index of q_d_next(x)\\n        res.point_add_assign(tmp_g1);\\n\\n        // multiply by main gate selector(z)\\n        res.point_mul_assign(proof.gate_selector_values_at_z[0]); // these is only one explicitly opened selector\\n\\n        PairingsBn254.Fr memory current_alpha = PairingsBn254.new_fr(ONE);\\n\\n        // calculate scalar contribution from the range check gate\\n        tmp_fr = add_contribution_from_range_constraint_gates(state, proof, current_alpha);\\n        tmp_g1 = vk.gate_selector_commitments[1].point_mul(tmp_fr); // selector commitment for range constraint gate * scalar\\n        res.point_add_assign(tmp_g1);\\n\\n        // proceed as normal to copy permutation\\n        current_alpha.mul_assign(state.alpha); // alpha^5\\n\\n        PairingsBn254.Fr memory alpha_for_grand_product = PairingsBn254.copy(current_alpha);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.copy_permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.copy_permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i+1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(alpha_for_grand_product);\\n\\n        // alpha^n & L_{0}(z), and we bump current_alpha\\n        current_alpha.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(current_alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        // prefactor for grand_product(x) is complete\\n\\n        // add to the linearization a part from the term\\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.copy_grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(alpha_for_grand_product); // we multiply by the power of alpha from the argument\\n\\n        // actually multiply prefactors by z(x) and perm_d(x) and combine them\\n        tmp_g1 = proof.copy_permutation_grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.copy_permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        // multiply them by v immedately as linearization has a factor of v^1\\n        res.point_mul_assign(state.v);\\n        // res now contains contribution from the gates linearization and\\n        // copy permutation part\\n\\n        // now we need to add a part that is the rest\\n        // for z(x*omega):\\n        // - (a(z) + beta*perm_a + gamma)*()*()*(d(z) + gamma) * z(x*omega)\\n    }\\n\\n    function aggregate_commitments(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point[2] memory res) {\\n        PairingsBn254.G1Point memory d = reconstruct_linearization_commitment(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint i = 0; i < NUM_GATE_SELECTORS_OPENED_EXPLICITLY; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.gate_selector_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint i = 0; i < vk.copy_permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.copy_permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        // now do prefactor for grand_product(x*omega)\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        commitment_aggregation.point_add_assign(proof.copy_permutation_grand_product_commitment.point_mul(tmp_fr));\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_fr.assign(proof.gate_selector_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.copy_grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        res[0] = pair_with_generator;\\n        res[1] = pair_with_x;\\n\\n        return res;\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs == 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        state.cached_lagrange_evals = new PairingsBn254.Fr[](1);\\n        state.cached_lagrange_evals[0] = evaluate_lagrange_poly_out_of_domain(\\n            0,\\n            vk.domain_size,\\n            vk.omega, state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.gate_selector_values_at_z[0]);\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.copy_grand_product_at_z_omega);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function aggregate_for_verification(Proof memory proof, VerificationKey memory vk) internal view returns (bool valid, PairingsBn254.G1Point[2] memory part) {\\n        PartialVerifierState memory state;\\n\\n        valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return (valid, part);\\n        }\\n\\n        part = aggregate_commitments(state, proof, vk);\\n\\n        (valid, part);\\n    }\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = PairingsBn254.pairingProd2(recursive_proof_part[0], PairingsBn254.P2(), recursive_proof_part[1], vk.g2_x);\\n\\n        return valid;\\n    }\\n\\n    function verify_recursive(\\n        Proof memory proof,\\n        VerificationKey memory vk,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[] memory subproofs_limbs\\n    ) internal view returns (bool) {\\n        (uint256 recursive_input, PairingsBn254.G1Point[2] memory aggregated_g1s) = reconstruct_recursive_public_input(\\n            recursive_vks_root, max_valid_index, recursive_vks_indexes,\\n            individual_vks_inputs, subproofs_limbs\\n        );\\n\\n        assert(recursive_input == proof.input_values[0]);\\n\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        recursive_proof_part[0].point_add_assign(aggregated_g1s[0]);\\n        recursive_proof_part[1].point_add_assign(aggregated_g1s[1]);\\n\\n        valid = PairingsBn254.pairingProd2(recursive_proof_part[0], PairingsBn254.P2(), recursive_proof_part[1], vk.g2_x);\\n\\n        return valid;\\n    }\\n\\n    function reconstruct_recursive_public_input(\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[] memory subproofs_aggregated\\n    ) internal pure returns (uint256 recursive_input, PairingsBn254.G1Point[2] memory reconstructed_g1s) {\\n        assert(recursive_vks_indexes.length == individual_vks_inputs.length);\\n        bytes memory concatenated = abi.encodePacked(recursive_vks_root);\\n        uint8 index;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            index = recursive_vks_indexes[i];\\n            assert(index <= max_valid_index);\\n            concatenated = abi.encodePacked(concatenated, index);\\n        }\\n        uint256 input;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            input = individual_vks_inputs[i];\\n            //            assert(input < PairingsBn254.r_mod);\\n            concatenated = abi.encodePacked(concatenated, input);\\n        }\\n\\n        concatenated = abi.encodePacked(concatenated, subproofs_aggregated);\\n\\n        bytes32 commitment = sha256(concatenated);\\n        recursive_input = uint256(commitment) & RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK;\\n\\n        reconstructed_g1s[0] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[0] + (subproofs_aggregated[1] << LIMB_WIDTH) + (subproofs_aggregated[2] << 2*LIMB_WIDTH) + (subproofs_aggregated[3] << 3*LIMB_WIDTH),\\n            subproofs_aggregated[4] + (subproofs_aggregated[5] << LIMB_WIDTH) + (subproofs_aggregated[6] << 2*LIMB_WIDTH) + (subproofs_aggregated[7] << 3*LIMB_WIDTH)\\n        );\\n\\n        reconstructed_g1s[1] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[8] + (subproofs_aggregated[9] << LIMB_WIDTH) + (subproofs_aggregated[10] << 2*LIMB_WIDTH) + (subproofs_aggregated[11] << 3*LIMB_WIDTH),\\n            subproofs_aggregated[12] + (subproofs_aggregated[13] << LIMB_WIDTH) + (subproofs_aggregated[14] << 2*LIMB_WIDTH) + (subproofs_aggregated[15] << 3*LIMB_WIDTH)\\n        );\\n\\n        return (recursive_input, reconstructed_g1s);\\n    }\\n}\\n\\ncontract AggVerifierWithDeserialize is Plonk4AggVerifierWithAccessToDNext {\\n    uint256 constant SERIALIZED_PROOF_LENGTH = 34;\\n\\n    function deserialize_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof\\n    ) internal pure returns(Proof memory proof) {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            proof.gate_selector_values_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n\\n        proof.copy_grand_product_at_z_omega = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n    }\\n\\n    function verify_serialized_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid = verify(proof, vk);\\n\\n        return valid;\\n    }\\n\\n    function verify_serialized_proof_with_recursion(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[] memory subproofs_limbs,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid = verify_recursive(proof, vk, recursive_vks_root, max_valid_index, recursive_vks_indexes, individual_vks_inputs, subproofs_limbs);\\n\\n        return valid;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PlonkSingleCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.7.0;\\n\\nimport \\\"./PlonkCoreLib.sol\\\";\\n\\ncontract Plonk4SingleVerifierWithAccessToDNext {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant STATE_WIDTH = 4;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\\n\\n    struct VerificationKey {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[STATE_WIDTH+2] selector_commitments; // STATE_WIDTH for witness + multiplication + constant\\n        PairingsBn254.G1Point[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] next_step_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH-1] permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\\n        PairingsBn254.G1Point grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\\n        PairingsBn254.Fr grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH-1] permutation_polynomials_at_z;\\n\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function evaluate_vanishing(\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            rhs.add_assign(tmp);\\n        }\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function reconstruct_d(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^(6..8) * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^9 (z(x) - z(z*omega)) <- we need this power\\n        // + v^10 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n        // we pay a little for a few arithmetic operations to not introduce another constant\\n        uint256 power_for_z_omega_opening = 1 + 1 + STATE_WIDTH + STATE_WIDTH - 1;\\n        res = PairingsBn254.copy_g1(vk.selector_commitments[STATE_WIDTH + 1]);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            tmp_g1 = vk.selector_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.selector_commitments[STATE_WIDTH].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.next_step_selector_commitments[0].point_mul(proof.wire_values_at_z_omega[0]);\\n        res.point_add_assign(tmp_g1);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i+1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(state.alpha);\\n        tmp_fr.mul_assign(state.alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        PairingsBn254.Fr memory grand_product_part_at_z_omega = state.v.pow(power_for_z_omega_opening);\\n        grand_product_part_at_z_omega.mul_assign(state.u);\\n\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(state.alpha);\\n\\n        // add to the linearization\\n        tmp_g1 = proof.grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        res.point_mul_assign(state.v);\\n\\n        res.point_add_assign(proof.grand_product_commitment.point_mul(grand_product_part_at_z_omega));\\n    }\\n\\n    function verify_commitments(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.G1Point memory d = reconstruct_d(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint i = 0; i < vk.permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        return PairingsBn254.pairingProd2(pair_with_generator, PairingsBn254.P2(), pair_with_x, vk.g2_x);\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs == 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        state.cached_lagrange_evals = new PairingsBn254.Fr[](1);\\n        state.cached_lagrange_evals[0] = evaluate_lagrange_poly_out_of_domain(\\n            0,\\n            vk.domain_size,\\n            vk.omega, state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n        transcript.update_with_fr(proof.grand_product_at_z_omega);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        PartialVerifierState memory state;\\n\\n        bool valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = verify_commitments(state, proof, vk);\\n\\n        return valid;\\n    }\\n}\\n\\ncontract SingleVerifierWithDeserialize is Plonk4SingleVerifierWithAccessToDNext {\\n    uint256 constant SERIALIZED_PROOF_LENGTH = 33;\\n\\n    function deserialize_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof\\n    ) internal pure returns(Proof memory proof) {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        proof.grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        proof.grand_product_at_z_omega = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/UniswapV2ERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport './interfaces/IUniswapV2ERC20.sol';\\nimport './libraries/UniswapSafeMath.sol';\\n\\ncontract UniswapV2ERC20 is IUniswapV2ERC20 {\\n    using UniswapSafeMath for uint;\\n\\n    string public constant name = 'ZKSWAP V2';\\n    string public constant symbol = 'ZKS-V2';\\n    uint8 public constant decimals = 18;\\n    uint  public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid\\n        }\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/interfaces/IUNISWAPERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUNISWAPERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/interfaces/IUniswapV2Callee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Callee {\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/PlonkCoreLib.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.7.0;\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod-2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint[2] X;\\n        uint[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod);\\n        require(y < q_mod);\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs);\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return G2Point(\\n            [0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n            0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed],\\n            [0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n            0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa]\\n        );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2)\\n    internal view returns (G1Point memory r)\\n    {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2)\\n    internal view\\n    {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(G1Point memory p1, G1Point memory p2, G1Point memory dest)\\n    internal view\\n    {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2)\\n    internal view\\n    {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(G1Point memory p1, G1Point memory p2, G1Point memory dest)\\n    internal view\\n    {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s)\\n    internal view returns (G1Point memory r)\\n    {\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s)\\n    internal view\\n    {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(G1Point memory p, Fr memory s, G1Point memory dest)\\n    internal view\\n    {\\n        uint[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2)\\n    internal view returns (bool)\\n    {\\n        require(p1.length == p2.length);\\n        uint elements = p1.length;\\n        uint inputSize = elements * 6;\\n        uint[] memory input = new uint[](inputSize);\\n        for (uint i = 0; i < elements; i++)\\n        {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n        }\\n        uint[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(G1Point memory a1, G2Point memory a2, G1Point memory b1, G2Point memory b2)\\n    internal view returns (bool)\\n    {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\\nlibrary TranscriptLibrary {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns(PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/interfaces/IUniswapV2ERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2ERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/libraries/UniswapSafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary UniswapSafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"}],\"name\":\"BlockCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"}],\"name\":\"BlockVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"totalBlocksVerified\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"totalBlocksCommitted\",\"type\":\"uint32\"}],\"name\":\"BlocksRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"zkSyncBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenAId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenBId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenPairId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"CreatePairCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"zkSyncBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"DepositCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"zkSyncBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"globalId\",\"type\":\"uint64\"}],\"name\":\"DepositNFTCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ExodusMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fact\",\"type\":\"bytes\"}],\"name\":\"FactAuth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"zkSyncBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"FullExitCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"zkSyncBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"globalId\",\"type\":\"uint64\"}],\"name\":\"FullExitNFTCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumberFrom\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumberTo\",\"type\":\"uint32\"}],\"name\":\"MultiblockVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"serialId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enum Operations.OpType\",\"name\":\"opType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"}],\"name\":\"NewPriorityRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"NewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenAId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenBId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"pairId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"OnchainCreatePair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OnchainDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OnchainDepositNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"globalId\",\"type\":\"uint64\"}],\"name\":\"OnchainFullExitNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"OnchainWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"queueStartIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"queueEndIndex\",\"type\":\"uint32\"}],\"name\":\"PendingWithdrawalsAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"queueStartIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"queueEndIndex\",\"type\":\"uint32\"}],\"name\":\"PendingWithdrawalsComplete\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"authFacts\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes22\",\"name\":\"\",\"type\":\"bytes22\"}],\"name\":\"balancesToWithdraw\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"balanceToWithdraw\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"gasReserveValue\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"committedAtBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"chunks\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawalsDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_globalId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_creatorId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_seqId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_uri\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"exitNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"exited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exodusMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPendingWithdrawalIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPriorityRequestId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"getBalanceToWithdraw\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32[]\",\"name\":\"_accountIds\",\"type\":\"uint32[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"lpExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDepositAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"nft_exited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfPendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"priorityRequests\",\"outputs\":[{\"internalType\":\"enum Operations.OpType\",\"name\":\"opType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"pubData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"swap_exited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"tokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBlocksChecked\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBlocksCommitted\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBlocksVerified\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCommittedPriorityRequests\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOpenPriorityRequests\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPairTokens\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradePreparationActivationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradePreparationActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"validatePairTokenAddress\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawNFTGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zkSeaAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zkSyncCommitBlockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zkSyncExitAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ZkSyncExit","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}