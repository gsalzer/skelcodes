{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"IRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IRegistry {\\n  event SystemWalletUpdated(address newWallet);\\n  event FeeVariablesChanged(uint256 indexed newFee, uint256 indexed newScale);\\n  event ContractStatusChanged(address indexed changed, bool indexed status);\\n  event CurrencyStatusChanged(address indexed changed, bool indexed status);\\n\\n  function feeInfo(uint256 _salePrice) external view returns(address, uint256);\\n  function isPlatformContract(address toCheck) external view returns(bool);\\n  function isApprovedCurrency(address tokenContract) external view returns(bool);\\n  function setSystemWallet(address newWallet) external;\\n  function setFeeVariables(uint256 newFee, uint256 newScale) external;\\n  function setContractStatus(address toChange, bool status) external;\\n  function setCurrencyStatus(address tokenContract, bool status) external;\\n  function approveAllCurrencies() external;\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"Registry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Registry for the Etched platform\\n * @author Linum Labs\\n */\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IRegistry.sol\\\";\\n\\ncontract EtchedRegistry is IRegistry, Ownable {\\n  mapping(address =\\u003e bool) private platformContracts;\\n  mapping(address =\\u003e bool) private approvedCurrencies;\\n  bool allowAllCurrencies;\\n  address systemWallet;\\n  // scale: how many zeroes should follow the fee\\n  // in the default values, there would be a 10% tax on a 18 decimal asset\\n  uint256 fee = 10_000;\\n  uint256 scale = 1e5;\\n\\n  constructor() {\\n    approvedCurrencies[address(0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa)] = true;\\n  }\\n\\n  /// @notice checks if a contract is active on the platform\\n  /// @dev used by platform contracts to verify interactions\\n  /// @param toCheck the address of the contract to check\\n  /// @return a boolean if the contract is active on the platform or not\\n  function isPlatformContract(address toCheck) external view override returns(bool) {\\n    return platformContracts[toCheck];\\n  }\\n\\n  /// @notice checks if a token is approved for use on the platform\\n  /// @dev use 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa for ETH\\n  /// @param tokenContract the address of the token to check\\n  /// @return a boolean value if the token is approved for use on the platform\\n  function isApprovedCurrency(address tokenContract) external view override returns(bool) {\\n    if(allowAllCurrencies) return true;\\n    return approvedCurrencies[tokenContract];\\n  }\\n\\n  /// @notice returns relevant details about system fees\\n  /// @dev structured similar to EIP2981 for royalties\\n  /// @param _salePrice the amount of a sale to calculate fees for\\n  /// @return a tuple of (address, uint256) of the system wallet and the amount of the fee\\n  function feeInfo(uint256 _salePrice) external view override returns(address, uint256) {\\n    return (systemWallet, (_salePrice * fee / scale));\\n  }\\n\\n  /// @notice sets the address for the system wallet\\n  /// @param newWallet the address of the new system wallet\\n  function setSystemWallet(address newWallet) external override onlyOwner {\\n    systemWallet = newWallet;\\n\\n    emit SystemWalletUpdated(newWallet);\\n  }\\n\\n  /// @notice sets the global fee variables (fee and scale)\\n  /// @dev fee / scale = percentage\\n  /// @param newFee the new value for the fee global variable\\n  /// @param newScale the new value for the scale global variable\\n  function setFeeVariables(uint256 newFee, uint256 newScale) external override onlyOwner {\\n    fee = newFee;\\n    scale = newScale;\\n    emit FeeVariablesChanged(newFee, newScale);\\n  }\\n\\n  /// @notice sets the status of a contract as active or inactive\\n  /// @param toChange the address of the contract to change the status of\\n  /// @param status a bool representing if the contract should be active or not\\n  function setContractStatus(address toChange, bool status) external override onlyOwner {\\n    string memory boolString = status == true ? \\\"true\\\" : \\\"false\\\";\\n    require(platformContracts[toChange] != status, \\n      string(abi.encodePacked(\\\"contract status is already \\\", boolString))\\n    );\\n    platformContracts[toChange] = status;\\n    emit ContractStatusChanged(toChange, status);\\n  }\\n\\n  /// @notice Explain to an end user what this does\\n  /// @dev Explain to a developer any extra details\\n  /// @param tokenContract the address of the token to change the status of\\n  /// @param status a bool representing if the token is approved or not\\n  function setCurrencyStatus(address tokenContract, bool status) external override onlyOwner {\\n    require(!allowAllCurrencies, \\\"all currencies approved\\\");\\n    string memory boolString = status == true ? \\\"true\\\" : \\\"false\\\";\\n    require(approvedCurrencies[tokenContract] != status, \\n      string(abi.encodePacked(\\\"token status is already \\\", boolString))\\n    );\\n    approvedCurrencies[tokenContract] = status;\\n    emit CurrencyStatusChanged(tokenContract, status);\\n  }\\n\\n  /// @notice globally allows all tokens\\n  /// @dev this is irrversible, and can only be called once\\n  function approveAllCurrencies() external override onlyOwner {\\n    require(!allowAllCurrencies, \\\"already approved\\\");\\n    allowAllCurrencies = true;\\n    emit CurrencyStatusChanged(address(0), true);\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"changed\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"ContractStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"changed\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"CurrencyStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newScale\",\"type\":\"uint256\"}],\"name\":\"FeeVariablesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"SystemWalletUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"approveAllCurrencies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"feeInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"isApprovedCurrency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"isPlatformContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toChange\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setContractStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setCurrencyStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newScale\",\"type\":\"uint256\"}],\"name\":\"setFeeVariables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setSystemWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtchedRegistry","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4fabbcb8d888bea550327deb04590630953ea898511a06a66b3ce37c066f37ba"}]}