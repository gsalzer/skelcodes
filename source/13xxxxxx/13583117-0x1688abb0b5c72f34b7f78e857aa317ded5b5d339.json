{"status":"1","message":"OK","result":[{"SourceCode":"{\"Common.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  Common Utility librarries.\\n  I. Addresses (extending address).\\n*/\\nlibrary Addresses {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function performEthTransfer(address recipient, uint256 amount) internal {\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\"); // NOLINT: low-level-calls.\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20/ERC721 calls.\\n      This is required because many deployed ERC20 contracts don\\u0027t return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        require(isContract(tokenAddress), \\\"BAD_TOKEN_ADDRESS\\\");\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\\n        require(success, string(returndata));\\n\\n        if (returndata.length \\u003e 0) {\\n            require(abi.decode(returndata, (bool)), \\\"TOKEN_OPERATION_FAILED\\\");\\n        }\\n    }\\n\\n    /*\\n      Validates that the passed contract address is of a real contract,\\n      and that its id hash (as infered fromn identify()) matched the expected one.\\n    */\\n    function validateContractId(address contractAddress, bytes32 expectedIdHash) internal {\\n        require(isContract(contractAddress), \\\"ADDRESS_NOT_CONTRACT\\\");\\n        (bool success, bytes memory returndata) = contractAddress.call( // NOLINT: low-level-calls.\\n            abi.encodeWithSignature(\\\"identify()\\\")\\n        );\\n        require(success, \\\"FAILED_TO_IDENTIFY_CONTRACT\\\");\\n        string memory realContractId = abi.decode(returndata, (string));\\n        require(\\n            keccak256(abi.encodePacked(realContractId)) == expectedIdHash,\\n            \\\"UNEXPECTED_CONTRACT_IDENTIFIER\\\"\\n        );\\n    }\\n}\\n\\n/*\\n  II. StarkExTypes - Common data types.\\n*/\\nlibrary StarkExTypes {\\n    // Structure representing a list of verifiers (validity/availability).\\n    // A statement is valid only if all the verifiers in the list agree on it.\\n    // Adding a verifier to the list is immediate - this is used for fast resolution of\\n    // any soundness issues.\\n    // Removing from the list is time-locked, to ensure that any user of the system\\n    // not content with the announced removal has ample time to leave the system before it is\\n    // removed.\\n    struct ApprovalChainData {\\n        address[] list;\\n        // Represents the time after which the verifier with the given address can be removed.\\n        // Removal of the verifier with address A is allowed only in the case the value\\n        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] \\u003c (current time).\\n        mapping(address =\\u003e uint256) unlockedForRemovalTime;\\n    }\\n}\\n\"},\"Governance.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"GovernanceStorage.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\n\\n/*\\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\\n  Notes:\\n  1. This class is virtual (getGovernanceTag is not implemented).\\n  2. The use of the same function names by both the Proxy and a delegated implementation\\n     is not possible since calling the implementation functions is done via the default function\\n     of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\\n     exposes mainIsGovernor, which calls the internal isGovernor method.\\n*/\\nabstract contract Governance is GovernanceStorage, MGovernance {\\n    event LogNominatedGovernor(address nominatedGovernor);\\n    event LogNewGovernorAccepted(address acceptedGovernor);\\n    event LogRemovedGovernor(address removedGovernor);\\n    event LogNominationCancelled();\\n\\n    /*\\n      Returns a string which uniquely identifies the type of the governance mechanism.\\n    */\\n    function getGovernanceTag() internal pure virtual returns (string memory);\\n\\n    /*\\n      Returns the GovernanceInfoStruct associated with the governance tag.\\n    */\\n    function contractGovernanceInfo() internal view returns (GovernanceInfoStruct storage) {\\n        string memory tag = getGovernanceTag();\\n        GovernanceInfoStruct storage gub = governanceInfo[tag];\\n        require(gub.initialized, \\\"NOT_INITIALIZED\\\");\\n        return gub;\\n    }\\n\\n    /*\\n      Current code intentionally prevents governance re-initialization.\\n      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\\n      performs an initialization (for real) and within that calls initGovernance().\\n\\n      Possible workarounds:\\n      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\\n         This will remove existing main governance information.\\n      2. Modify the require part in this function, so that it will exit quietly\\n         when trying to re-initialize (uncomment the lines below).\\n    */\\n    function initGovernance() internal {\\n        string memory tag = getGovernanceTag();\\n        GovernanceInfoStruct storage gub = governanceInfo[tag];\\n        require(!gub.initialized, \\\"ALREADY_INITIALIZED\\\");\\n        gub.initialized = true; // to ensure addGovernor() won\\u0027t fail.\\n        // Add the initial governer.\\n        addGovernor(msg.sender);\\n    }\\n\\n    function isGovernor(address testGovernor) internal view override returns (bool) {\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        return gub.effectiveGovernors[testGovernor];\\n    }\\n\\n    /*\\n      Cancels the nomination of a governor candidate.\\n    */\\n    function cancelNomination() internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        gub.candidateGovernor = address(0x0);\\n        emit LogNominationCancelled();\\n    }\\n\\n    function nominateNewGovernor(address newGovernor) internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        require(!isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        gub.candidateGovernor = newGovernor;\\n        emit LogNominatedGovernor(newGovernor);\\n    }\\n\\n    /*\\n      The addGovernor is called in two cases:\\n      1. by acceptGovernance when a new governor accepts its role.\\n      2. by initGovernance to add the initial governor.\\n      The difference is that the init path skips the nominate step\\n      that would fail because of the onlyGovernance modifier.\\n    */\\n    function addGovernor(address newGovernor) private {\\n        require(!isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        gub.effectiveGovernors[newGovernor] = true;\\n    }\\n\\n    function acceptGovernance() internal {\\n        // The new governor was proposed as a candidate by the current governor.\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        require(msg.sender == gub.candidateGovernor, \\\"ONLY_CANDIDATE_GOVERNOR\\\");\\n\\n        // Update state.\\n        addGovernor(gub.candidateGovernor);\\n        gub.candidateGovernor = address(0x0);\\n\\n        // Send a notification about the change of governor.\\n        emit LogNewGovernorAccepted(msg.sender);\\n    }\\n\\n    /*\\n      Remove a governor from office.\\n    */\\n    function removeGovernor(address governorForRemoval) internal onlyGovernance {\\n        require(msg.sender != governorForRemoval, \\\"GOVERNOR_SELF_REMOVE\\\");\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        require(isGovernor(governorForRemoval), \\\"NOT_GOVERNOR\\\");\\n        gub.effectiveGovernors[governorForRemoval] = false;\\n        emit LogRemovedGovernor(governorForRemoval);\\n    }\\n}\\n\"},\"GovernanceStorage.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  Holds the governance slots for ALL entities, including proxy and the main contract.\\n*/\\ncontract GovernanceStorage {\\n    struct GovernanceInfoStruct {\\n        mapping(address =\\u003e bool) effectiveGovernors;\\n        address candidateGovernor;\\n        bool initialized;\\n    }\\n\\n    // A map from a Governor tag to its own GovernanceInfoStruct.\\n    mapping(string =\\u003e GovernanceInfoStruct) internal governanceInfo;\\n}\\n\"},\"Identity.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\ninterface Identity {\\n    /*\\n      Allows a caller, typically another contract,\\n      to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify() external pure returns (string memory);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  Interface of the ERC20 standard as defined in the EIP. Does not include\\n  the optional functions; to access them see {ERC20Detailed}.\\n*/\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"LibConstants.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\ncontract LibConstants {\\n    // Durations for time locked mechanisms (in seconds).\\n    // Note that it is known that miners can manipulate block timestamps\\n    // up to a deviation of a few seconds.\\n    // This mechanism should not be used for fine grained timing.\\n\\n    // The time required to cancel a deposit, in the case the operator does not move the funds\\n    // to the off-chain storage.\\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 2 days;\\n\\n    // The time required to freeze the exchange, in the case the operator does not execute a\\n    // requested full withdrawal.\\n    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\\n\\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\\n    // for users to perform escape hatches to get back their funds.\\n    uint256 public constant UNFREEZE_DELAY = 365 days;\\n\\n    // Maximal number of verifiers which may co-exist.\\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\\n\\n    // The time required to remove a verifier in case of a verifier upgrade.\\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\\n\\n    address constant ZERO_ADDRESS = address(0x0);\\n\\n    uint256 constant K_MODULUS = 0x800000000000011000000000000000000000000000000000000000000000001;\\n\\n    uint256 constant K_BETA = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\\n\\n    uint256 internal constant MASK_250 =\\n        0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant MASK_240 =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    uint256 public constant MAX_FORCED_ACTIONS_REQS_PER_BLOCK = 10;\\n\\n    uint256 constant QUANTUM_UPPER_BOUND = 2**128;\\n    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1 \\u003c\\u003c 250;\\n}\\n\"},\"MainGovernance.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"Governance.sol\\\";\\n\\n/**\\n  The StarkEx contract is governed by one or more Governors of which the initial one is the\\n  deployer of the contract.\\n\\n  A governor has the sole authority to perform the following operations:\\n\\n  1. Nominate additional governors (:sol:func:`mainNominateNewGovernor`)\\n  2. Remove other governors (:sol:func:`mainRemoveGovernor`)\\n  3. Add new :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers`\\n  4. Remove :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers` after a timelock allows it\\n  5. Nominate Operators (see :sol:mod:`Operator`) and Token Administrators (see :sol:mod:`TokenRegister`)\\n\\n  Adding governors is performed in a two step procedure:\\n\\n  1. First, an existing governor nominates a new governor (:sol:func:`mainNominateNewGovernor`)\\n  2. Then, the new governor must accept governance to become a governor (:sol:func:`mainAcceptGovernance`)\\n\\n  This two step procedure ensures that a governor public key cannot be nominated unless there is an\\n  entity that has the corresponding private key. This is intended to prevent errors in the addition\\n  process.\\n\\n  The governor private key should typically be held in a secure cold wallet.\\n*/\\n/*\\n  Implements Governance for the StarkDex main contract.\\n  The wrapper methods (e.g. mainIsGovernor wrapping isGovernor) are needed to give\\n  the method unique names.\\n  Both Proxy and StarkExchange inherit from Governance. Thus, the logical contract method names\\n  must have unique names in order for the proxy to successfully delegate to them.\\n*/\\ncontract MainGovernance is Governance {\\n    // The tag is the sting key that is used in the Governance storage mapping.\\n    string public constant MAIN_GOVERNANCE_INFO_TAG = \\\"StarkEx.Main.2019.GovernorsInformation\\\";\\n\\n    function getGovernanceTag() internal pure override returns (string memory tag) {\\n        tag = MAIN_GOVERNANCE_INFO_TAG;\\n    }\\n\\n    function mainIsGovernor(address testGovernor) external view returns (bool) {\\n        return isGovernor(testGovernor);\\n    }\\n\\n    function mainNominateNewGovernor(address newGovernor) external {\\n        nominateNewGovernor(newGovernor);\\n    }\\n\\n    function mainRemoveGovernor(address governorForRemoval) external {\\n        removeGovernor(governorForRemoval);\\n    }\\n\\n    function mainAcceptGovernance() external {\\n        acceptGovernance();\\n    }\\n\\n    function mainCancelNomination() external {\\n        cancelNomination();\\n    }\\n}\\n\"},\"MainStorage.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"ProxyStorage.sol\\\";\\nimport \\\"Common.sol\\\";\\n\\n/*\\n  Holds ALL the main contract state (storage) variables.\\n*/\\ncontract MainStorage is ProxyStorage {\\n    uint256 internal constant LAYOUT_LENGTH = 2**64;\\n\\n    address escapeVerifierAddress; // NOLINT: constable-states.\\n\\n    // Global dex-frozen flag.\\n    bool stateFrozen; // NOLINT: constable-states.\\n\\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\\n    uint256 unFreezeTime; // NOLINT: constable-states.\\n\\n    // Pending deposits.\\n    // A map STARK key =\\u003e asset id =\\u003e vault id =\\u003e quantized amount.\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) pendingDeposits;\\n\\n    // Cancellation requests.\\n    // A map STARK key =\\u003e asset id =\\u003e vault id =\\u003e request timestamp.\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) cancellationRequests;\\n\\n    // Pending withdrawals.\\n    // A map STARK key =\\u003e asset id =\\u003e quantized amount.\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256)) pendingWithdrawals;\\n\\n    // vault_id =\\u003e escape used boolean.\\n    mapping(uint256 =\\u003e bool) escapesUsed;\\n\\n    // Number of escapes that were performed when frozen.\\n    uint256 escapesUsedCount; // NOLINT: constable-states.\\n\\n    // NOTE: fullWithdrawalRequests is deprecated, and replaced by forcedActionRequests.\\n    // NOLINTNEXTLINE naming-convention.\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256)) fullWithdrawalRequests_DEPRECATED;\\n\\n    // State sequence number.\\n    uint256 sequenceNumber; // NOLINT: constable-states uninitialized-state.\\n\\n    // Vaults Tree Root \\u0026 Height.\\n    uint256 vaultRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 vaultTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    // Order Tree Root \\u0026 Height.\\n    uint256 orderRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 orderTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    // True if and only if the address is allowed to add tokens.\\n    mapping(address =\\u003e bool) tokenAdmins;\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping(address =\\u003e bool) userAdmins_DEPRECATED; // NOLINT: naming-convention.\\n\\n    // True if and only if the address is an operator (allowed to update state).\\n    mapping(address =\\u003e bool) operators;\\n\\n    // Mapping of contract ID to asset data.\\n    mapping(uint256 =\\u003e bytes) assetTypeToAssetInfo; // NOLINT: uninitialized-state.\\n\\n    // Mapping of registered contract IDs.\\n    mapping(uint256 =\\u003e bool) registeredAssetType; // NOLINT: uninitialized-state.\\n\\n    // Mapping from contract ID to quantum.\\n    mapping(uint256 =\\u003e uint256) assetTypeToQuantum; // NOLINT: uninitialized-state.\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping(address =\\u003e uint256) starkKeys_DEPRECATED; // NOLINT: naming-convention.\\n\\n    // Mapping from STARK public key to the Ethereum public key of its owner.\\n    mapping(uint256 =\\u003e address) ethKeys; // NOLINT: uninitialized-state.\\n\\n    // Timelocked state transition and availability verification chain.\\n    StarkExTypes.ApprovalChainData verifiersChain;\\n    StarkExTypes.ApprovalChainData availabilityVerifiersChain;\\n\\n    // Batch id of last accepted proof.\\n    uint256 lastBatchId; // NOLINT: constable-states uninitialized-state.\\n\\n    // Mapping between sub-contract index to sub-contract address.\\n    mapping(uint256 =\\u003e address) subContracts; // NOLINT: uninitialized-state.\\n\\n    mapping(uint256 =\\u003e bool) permissiveAssetType_DEPRECATED; // NOLINT: naming-convention.\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX2.0 ----\\n\\n    // Onchain-data version configured for the system.\\n    uint256 onchainDataVersion; // NOLINT: constable-states uninitialized-state.\\n\\n    // Counter of forced action request in block. The key is the block number.\\n    mapping(uint256 =\\u003e uint256) forcedRequestsInBlock;\\n\\n    // ForcedAction requests: actionHash =\\u003e requestTime.\\n    mapping(bytes32 =\\u003e uint256) forcedActionRequests;\\n\\n    // Mapping for timelocked actions.\\n    // A actionKey =\\u003e activation time.\\n    mapping(bytes32 =\\u003e uint256) actionsTimeLock;\\n\\n    // Append only list of requested forced action hashes.\\n    bytes32[] actionHashList;\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention.\\n    uint256[LAYOUT_LENGTH - 37] private __endGap; // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"},\"MGovernance.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MGovernance {\\n    function isGovernor(address testGovernor) internal view virtual returns (bool);\\n\\n    /*\\n      Allows calling the function only by a Governor.\\n    */\\n    modifier onlyGovernance() {\\n        require(isGovernor(msg.sender), \\\"ONLY_GOVERNANCE\\\");\\n        _;\\n    }\\n}\\n\"},\"MTokenAssetData.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MTokenAssetData {\\n    // NOLINTNEXTLINE: external-function.\\n    function getAssetInfo(uint256 assetType) public view virtual returns (bytes memory assetInfo);\\n\\n    function extractTokenSelector(bytes memory assetInfo)\\n        internal\\n        pure\\n        virtual\\n        returns (bytes4 selector);\\n\\n    function isEther(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isERC20(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isERC721(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isFungibleAssetType(uint256 assetType) internal view virtual returns (bool);\\n\\n    function isMintableAssetType(uint256 assetType) internal view virtual returns (bool);\\n\\n    function extractContractAddress(uint256 assetType) internal view virtual returns (address);\\n\\n    function verifyAssetInfo(bytes memory assetInfo) internal view virtual;\\n\\n    function isNonFungibleAssetInfo(bytes memory assetInfo) internal pure virtual returns (bool);\\n\\n    function calculateNftAssetId(uint256 assetType, uint256 tokenId)\\n        internal\\n        pure\\n        virtual\\n        returns (uint256 assetId);\\n\\n    function calculateMintableAssetId(uint256 assetType, bytes memory mintingBlob)\\n        internal\\n        pure\\n        virtual\\n        returns (uint256 assetId);\\n}\\n\"},\"MTokenQuantization.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MTokenQuantization {\\n    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256 amount);\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function getQuantum(uint256 presumedAssetType) public view virtual returns (uint256 quantum);\\n\\n    function toQuantized(uint256 presumedAssetType, uint256 amount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256 quantizedAmount);\\n}\\n\"},\"MTokenTransfers.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MTokenTransfers {\\n    function transferIn(uint256 assetType, uint256 quantizedAmount) internal virtual;\\n\\n    function transferInNft(uint256 assetType, uint256 tokenId) internal virtual;\\n\\n    function transferOut(\\n        address payable recipient,\\n        uint256 assetType,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n\\n    function transferOutNft(\\n        address recipient,\\n        uint256 assetType,\\n        uint256 tokenId\\n    ) internal virtual;\\n\\n    function transferOutMint(\\n        uint256 assetType,\\n        uint256 quantizedAmount,\\n        address recipient,\\n        bytes memory mintingBlob\\n    ) internal virtual;\\n}\\n\"},\"MVaultLocks.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  Onchain vaults\\u0027 lock functionality.\\n*/\\nabstract contract MVaultLocks {\\n    function applyDefaultLock(uint256 assetId, uint256 vaultId) internal virtual;\\n\\n    function isVaultLocked( // NOLINT external-function.\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) public view virtual returns (bool);\\n}\\n\"},\"OnchainVaults.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"VaultDepositWithdrawal.sol\\\";\\nimport \\\"VaultLocks.sol\\\";\\nimport \\\"MainGovernance.sol\\\";\\nimport \\\"TokenTransfers.sol\\\";\\nimport \\\"TokenAssetData.sol\\\";\\nimport \\\"TokenQuantization.sol\\\";\\nimport \\\"SubContractor.sol\\\";\\n\\ncontract OnchainVaults is\\n    SubContractor,\\n    MainGovernance,\\n    VaultLocks,\\n    TokenAssetData,\\n    TokenTransfers,\\n    TokenQuantization,\\n    VaultDepositWithdrawal\\n{\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_OnchainVaults_2021_1\\\";\\n    }\\n\\n    function initialize(bytes calldata) external override {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function initializerSize() external view override returns (uint256) {\\n        return 0;\\n    }\\n\\n    function isStrictVaultBalancePolicy() external view returns (bool) {\\n        return strictVaultBalancePolicy;\\n    }\\n}\\n\"},\"ProxyStorage.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"GovernanceStorage.sol\\\";\\n\\n/*\\n  Holds the Proxy-specific state variables.\\n  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\\n  to prevent collision hazard.\\n*/\\ncontract ProxyStorage is GovernanceStorage {\\n    // NOLINTNEXTLINE: naming-convention uninitialized-state.\\n    mapping(address =\\u003e bytes32) internal initializationHash_DEPRECATED;\\n\\n    // The time after which we can switch to the implementation.\\n    // Hash(implementation, data, finalize) =\\u003e time.\\n    mapping(bytes32 =\\u003e uint256) internal enabledTime;\\n\\n    // A central storage of the flags whether implementation has been initialized.\\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\\n    // (i.e. using different key salting schemes for different initialization levels).\\n    mapping(bytes32 =\\u003e bool) internal initialized;\\n}\\n\"},\"StarkExConstants.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"LibConstants.sol\\\";\\n\\ncontract StarkExConstants is LibConstants {\\n    uint256 constant STARKEX_VAULT_ID_UPPER_BOUND = 2**31;\\n    uint256 constant STARKEX_EXPIRATION_TIMESTAMP_BITS = 22;\\n    uint256 public constant STARKEX_MAX_DEFAULT_VAULT_LOCK = 7 days;\\n}\\n\"},\"StarkExStorage.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Extends MainStorage, holds StarkEx App specific state (storage) variables.\\n\\n  ALL State variables that are common to all applications, reside in MainStorage,\\n  whereas ALL the StarkEx app specific ones reside here.\\n*/\\ncontract StarkExStorage is MainStorage {\\n    // Onchain vaults balances.\\n    // A map eth_address =\\u003e asset_id =\\u003e vault_id =\\u003e quantized amount.\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) vaultsBalances;\\n\\n    // Onchain vaults withdrawal lock time.\\n    // A map eth_address =\\u003e asset_id =\\u003e vault_id =\\u003e lock expiration timestamp.\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) vaultsWithdrawalLocks;\\n\\n    // Enforces the minimal balance requirement (as output by Cairo) on onchain vault updates.\\n    // When disabled, flash loans are enabled.\\n    bool strictVaultBalancePolicy; // NOLINT: constable-states, uninitialized-state.\\n\\n    // The default time, in seconds, that an onchain vault is locked for withdrawal after a deposit.\\n    uint256 public defaultVaultWithdrawalLock; // NOLINT: constable-states.\\n\\n    // Address of the message registry contract that is used to sign and verify L1 orders.\\n    address public orderRegistryAddress; // NOLINT: constable-states.\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention shadowing-abstract.\\n    uint256[LAYOUT_LENGTH - 5] private __endGap; // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"},\"SubContractor.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"Identity.sol\\\";\\n\\ninterface SubContractor is Identity {\\n    function initialize(bytes calldata data) external;\\n\\n    function initializerSize() external view returns (uint256);\\n}\\n\"},\"TokenAssetData.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"Common.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\n\\ncontract TokenAssetData is MainStorage, LibConstants, MTokenAssetData {\\n    bytes4 internal constant ERC20_SELECTOR = bytes4(keccak256(\\\"ERC20Token(address)\\\"));\\n    bytes4 internal constant ETH_SELECTOR = bytes4(keccak256(\\\"ETH()\\\"));\\n    bytes4 internal constant ERC721_SELECTOR = bytes4(keccak256(\\\"ERC721Token(address,uint256)\\\"));\\n    bytes4 internal constant MINTABLE_ERC20_SELECTOR =\\n        bytes4(keccak256(\\\"MintableERC20Token(address)\\\"));\\n    bytes4 internal constant MINTABLE_ERC721_SELECTOR =\\n        bytes4(keccak256(\\\"MintableERC721Token(address,uint256)\\\"));\\n\\n    // The selector follows the 0x20 bytes assetInfo.length field.\\n    uint256 internal constant SELECTOR_OFFSET = 0x20;\\n    uint256 internal constant SELECTOR_SIZE = 4;\\n    uint256 internal constant TOKEN_CONTRACT_ADDRESS_OFFSET = SELECTOR_OFFSET + SELECTOR_SIZE;\\n    string internal constant NFT_ASSET_ID_PREFIX = \\\"NFT:\\\";\\n    string internal constant MINTABLE_PREFIX = \\\"MINTABLE:\\\";\\n\\n    using Addresses for address;\\n\\n    /*\\n      Extract the tokenSelector from assetInfo.\\n\\n      Works like bytes4 tokenSelector = abi.decode(assetInfo, (bytes4))\\n      but does not revert when assetInfo.length \\u003c SELECTOR_OFFSET.\\n    */\\n    function extractTokenSelector(bytes memory assetInfo)\\n        internal\\n        pure\\n        override\\n        returns (bytes4 selector)\\n    {\\n        assembly {\\n            selector := and(\\n                0xffffffff00000000000000000000000000000000000000000000000000000000,\\n                mload(add(assetInfo, SELECTOR_OFFSET))\\n            )\\n        }\\n    }\\n\\n    function getAssetInfo(uint256 assetType) public view override returns (bytes memory assetInfo) {\\n        // Verify that the registration is set and valid.\\n        require(registeredAssetType[assetType], \\\"ASSET_TYPE_NOT_REGISTERED\\\");\\n\\n        // Retrieve registration.\\n        assetInfo = assetTypeToAssetInfo[assetType];\\n    }\\n\\n    function isEther(uint256 assetType) internal view override returns (bool) {\\n        return extractTokenSelector(getAssetInfo(assetType)) == ETH_SELECTOR;\\n    }\\n\\n    function isERC20(uint256 assetType) internal view override returns (bool) {\\n        return extractTokenSelector(getAssetInfo(assetType)) == ERC20_SELECTOR;\\n    }\\n\\n    function isERC721(uint256 assetType) internal view override returns (bool) {\\n        return extractTokenSelector(getAssetInfo(assetType)) == ERC721_SELECTOR;\\n    }\\n\\n    function isFungibleAssetType(uint256 assetType) internal view override returns (bool) {\\n        bytes4 tokenSelector = extractTokenSelector(getAssetInfo(assetType));\\n        return\\n            tokenSelector == ETH_SELECTOR ||\\n            tokenSelector == ERC20_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC20_SELECTOR;\\n    }\\n\\n    function isMintableAssetType(uint256 assetType) internal view override returns (bool) {\\n        bytes4 tokenSelector = extractTokenSelector(getAssetInfo(assetType));\\n        return\\n            tokenSelector == MINTABLE_ERC20_SELECTOR || tokenSelector == MINTABLE_ERC721_SELECTOR;\\n    }\\n\\n    function isTokenSupported(bytes4 tokenSelector) private pure returns (bool) {\\n        return\\n            tokenSelector == ETH_SELECTOR ||\\n            tokenSelector == ERC20_SELECTOR ||\\n            tokenSelector == ERC721_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC20_SELECTOR ||\\n            tokenSelector == MINTABLE_ERC721_SELECTOR;\\n    }\\n\\n    function extractContractAddressFromAssetInfo(bytes memory assetInfo)\\n        private\\n        pure\\n        returns (address)\\n    {\\n        uint256 offset = TOKEN_CONTRACT_ADDRESS_OFFSET;\\n        uint256 res;\\n        assembly {\\n            res := mload(add(assetInfo, offset))\\n        }\\n        return address(res);\\n    }\\n\\n    function extractContractAddress(uint256 assetType) internal view override returns (address) {\\n        return extractContractAddressFromAssetInfo(getAssetInfo(assetType));\\n    }\\n\\n    function verifyAssetInfo(bytes memory assetInfo) internal view override {\\n        bytes4 tokenSelector = extractTokenSelector(assetInfo);\\n\\n        // Ensure the selector is of an asset type we know.\\n        require(isTokenSupported(tokenSelector), \\\"UNSUPPORTED_TOKEN_TYPE\\\");\\n\\n        if (tokenSelector == ETH_SELECTOR) {\\n            // Assset info for ETH assetType is only a selector, i.e. 4 bytes length.\\n            require(assetInfo.length == 4, \\\"INVALID_ASSET_STRING\\\");\\n        } else {\\n            // Assset info for other asset types are a selector + uint256 concatanation.\\n            // We pass the address as a uint256 (zero padded),\\n            // thus its length is 0x04 + 0x20 = 0x24.\\n            require(assetInfo.length == 0x24, \\\"INVALID_ASSET_STRING\\\");\\n            address tokenAddress = extractContractAddressFromAssetInfo(assetInfo);\\n            require(tokenAddress.isContract(), \\\"BAD_TOKEN_ADDRESS\\\");\\n        }\\n    }\\n\\n    function isNonFungibleAssetInfo(bytes memory assetInfo) internal pure override returns (bool) {\\n        bytes4 tokenSelector = extractTokenSelector(assetInfo);\\n        return tokenSelector == ERC721_SELECTOR || tokenSelector == MINTABLE_ERC721_SELECTOR;\\n    }\\n\\n    function calculateNftAssetId(uint256 assetType, uint256 tokenId)\\n        internal\\n        pure\\n        override\\n        returns (uint256 assetId)\\n    {\\n        assetId =\\n            uint256(keccak256(abi.encodePacked(NFT_ASSET_ID_PREFIX, assetType, tokenId))) \\u0026\\n            MASK_250;\\n    }\\n\\n    function calculateMintableAssetId(uint256 assetType, bytes memory mintingBlob)\\n        internal\\n        pure\\n        override\\n        returns (uint256 assetId)\\n    {\\n        uint256 blobHash = uint256(keccak256(mintingBlob));\\n        assetId =\\n            (uint256(keccak256(abi.encodePacked(MINTABLE_PREFIX, assetType, blobHash))) \\u0026\\n                MASK_240) |\\n            MINTABLE_ASSET_ID_FLAG;\\n    }\\n}\\n\"},\"TokenQuantization.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\n\\ncontract TokenQuantization is MainStorage, MTokenQuantization {\\n    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\\n        internal\\n        view\\n        override\\n        returns (uint256 amount)\\n    {\\n        uint256 quantum = getQuantum(presumedAssetType);\\n        amount = quantizedAmount * quantum;\\n        require(amount / quantum == quantizedAmount, \\\"DEQUANTIZATION_OVERFLOW\\\");\\n    }\\n\\n    function getQuantum(uint256 presumedAssetType) public view override returns (uint256 quantum) {\\n        if (!registeredAssetType[presumedAssetType]) {\\n            // Default quantization, for NFTs etc.\\n            quantum = 1;\\n        } else {\\n            // Retrieve registration.\\n            quantum = assetTypeToQuantum[presumedAssetType];\\n        }\\n    }\\n\\n    function toQuantized(uint256 presumedAssetType, uint256 amount)\\n        internal\\n        view\\n        override\\n        returns (uint256 quantizedAmount)\\n    {\\n        uint256 quantum = getQuantum(presumedAssetType);\\n        require(amount % quantum == 0, \\\"INVALID_AMOUNT\\\");\\n        quantizedAmount = amount / quantum;\\n    }\\n}\\n\"},\"TokenTransfers.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"Common.sol\\\";\\nimport \\\"MTokenTransfers.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\n/*\\n  Implements various transferIn and transferOut functionalities.\\n*/\\nabstract contract TokenTransfers is MTokenQuantization, MTokenAssetData, MTokenTransfers {\\n    using Addresses for address;\\n    using Addresses for address payable;\\n\\n    /*\\n      Transfers funds from msg.sender to the exchange.\\n    */\\n    function transferIn(uint256 assetType, uint256 quantizedAmount) internal override {\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        if (isERC20(assetType)) {\\n            address tokenAddress = extractContractAddress(assetType);\\n            IERC20 token = IERC20(tokenAddress);\\n            uint256 exchangeBalanceBefore = token.balanceOf(address(this));\\n            bytes memory callData = abi.encodeWithSelector(\\n                token.transferFrom.selector,\\n                msg.sender,\\n                address(this),\\n                amount\\n            );\\n            tokenAddress.safeTokenContractCall(callData);\\n            uint256 exchangeBalanceAfter = token.balanceOf(address(this));\\n            require(exchangeBalanceAfter \\u003e= exchangeBalanceBefore, \\\"OVERFLOW\\\");\\n            // NOLINTNEXTLINE(incorrect-equality): strict equality needed.\\n            require(\\n                exchangeBalanceAfter == exchangeBalanceBefore + amount,\\n                \\\"INCORRECT_AMOUNT_TRANSFERRED\\\"\\n            );\\n        } else if (isEther(assetType)) {\\n            require(msg.value == amount, \\\"INCORRECT_DEPOSIT_AMOUNT\\\");\\n        } else {\\n            revert(\\\"UNSUPPORTED_TOKEN_TYPE\\\");\\n        }\\n    }\\n\\n    function transferInNft(uint256 assetType, uint256 tokenId) internal override {\\n        require(isERC721(assetType), \\\"NOT_ERC721_TOKEN\\\");\\n        address tokenAddress = extractContractAddress(assetType);\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                msg.sender,\\n                address(this),\\n                tokenId\\n            )\\n        );\\n    }\\n\\n    /*\\n      Transfers funds from the exchange to recipient.\\n    */\\n    function transferOut(\\n        address payable recipient,\\n        uint256 assetType,\\n        uint256 quantizedAmount\\n    ) internal override {\\n        // Make sure we don\\u0027t accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        if (isERC20(assetType)) {\\n            address tokenAddress = extractContractAddress(assetType);\\n            IERC20 token = IERC20(tokenAddress);\\n            uint256 exchangeBalanceBefore = token.balanceOf(address(this));\\n            bytes memory callData = abi.encodeWithSelector(\\n                token.transfer.selector,\\n                recipient,\\n                amount\\n            );\\n            tokenAddress.safeTokenContractCall(callData);\\n            uint256 exchangeBalanceAfter = token.balanceOf(address(this));\\n            require(exchangeBalanceAfter \\u003c= exchangeBalanceBefore, \\\"UNDERFLOW\\\");\\n            // NOLINTNEXTLINE(incorrect-equality): strict equality needed.\\n            require(\\n                exchangeBalanceAfter == exchangeBalanceBefore - amount,\\n                \\\"INCORRECT_AMOUNT_TRANSFERRED\\\"\\n            );\\n        } else if (isEther(assetType)) {\\n            recipient.performEthTransfer(amount);\\n        } else {\\n            revert(\\\"UNSUPPORTED_TOKEN_TYPE\\\");\\n        }\\n    }\\n\\n    /*\\n      Transfers NFT from the exchange to recipient.\\n    */\\n    function transferOutNft(\\n        address recipient,\\n        uint256 assetType,\\n        uint256 tokenId\\n    ) internal override {\\n        // Make sure we don\\u0027t accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        require(isERC721(assetType), \\\"NOT_ERC721_TOKEN\\\");\\n        address tokenAddress = extractContractAddress(assetType);\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                address(this),\\n                recipient,\\n                tokenId\\n            )\\n        );\\n    }\\n\\n    function transferOutMint(\\n        uint256 assetType,\\n        uint256 quantizedAmount,\\n        address recipient,\\n        bytes memory mintingBlob\\n    ) internal override {\\n        // Make sure we don\\u0027t accidentally burn funds.\\n        require(recipient != address(0x0), \\\"INVALID_RECIPIENT\\\");\\n        require(isMintableAssetType(assetType), \\\"NON_MINTABLE_ASSET_TYPE\\\");\\n        uint256 amount = fromQuantized(assetType, quantizedAmount);\\n        address tokenAddress = extractContractAddress(assetType);\\n        tokenAddress.safeTokenContractCall(\\n            abi.encodeWithSignature(\\n                \\\"mintFor(address,uint256,bytes)\\\",\\n                recipient,\\n                amount,\\n                mintingBlob\\n            )\\n        );\\n    }\\n}\\n\"},\"VaultDepositWithdrawal.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"StarkExStorage.sol\\\";\\nimport \\\"MVaultLocks.sol\\\";\\nimport \\\"MTokenTransfers.sol\\\";\\nimport \\\"MTokenAssetData.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\n\\n/*\\n  Onchain vaults deposit and withdrawal functionalities.\\n*/\\nabstract contract VaultDepositWithdrawal is\\n    StarkExStorage,\\n    MVaultLocks,\\n    MTokenQuantization,\\n    MTokenAssetData,\\n    MTokenTransfers\\n{\\n    event LogDepositToVault(\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    event LogWithdrawalFromVault(\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    function depositToVault(\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) internal {\\n        require(!isMintableAssetType(assetId), \\\"MINTABLE_ASSET_TYPE\\\");\\n\\n        // A default withdrawal lock is applied when deposits are made.\\n        applyDefaultLock(assetId, vaultId);\\n        // Update the balance.\\n        vaultsBalances[msg.sender][assetId][vaultId] += quantizedAmount;\\n        require(vaultsBalances[msg.sender][assetId][vaultId] \\u003e= quantizedAmount, \\\"VAULT_OVERFLOW\\\");\\n\\n        // Transfer the tokens to the contract.\\n        transferIn(assetId, quantizedAmount);\\n\\n        // Log event.\\n        emit LogDepositToVault(\\n            msg.sender,\\n            assetId,\\n            vaultId,\\n            fromQuantized(assetId, quantizedAmount),\\n            quantizedAmount\\n        );\\n    }\\n\\n    function getQuantizedVaultBalance(\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) public view returns (uint256) {\\n        return vaultsBalances[ethKey][assetId][vaultId];\\n    }\\n\\n    function getVaultBalance(\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) external view returns (uint256) {\\n        return fromQuantized(assetId, getQuantizedVaultBalance(ethKey, assetId, vaultId));\\n    }\\n\\n    // NOLINTNEXTLINE: locked-ether.\\n    function depositEthToVault(uint256 assetId, uint256 vaultId) external payable {\\n        require(isEther(assetId), \\\"INVALID_ASSET_TYPE\\\");\\n        uint256 quantizedAmount = toQuantized(assetId, msg.value);\\n        depositToVault(assetId, vaultId, quantizedAmount);\\n    }\\n\\n    function depositERC20ToVault(\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) external {\\n        require(isFungibleAssetType(assetId), \\\"NON_FUNGIBLE_ASSET_TYPE\\\");\\n        depositToVault(assetId, vaultId, quantizedAmount);\\n    }\\n\\n    function withdrawFromVault(\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) external {\\n        require(quantizedAmount \\u003e 0, \\\"ZERO_WITHDRAWAL\\\");\\n        require(!isVaultLocked(msg.sender, assetId, vaultId), \\\"VAULT_IS_LOCKED\\\");\\n        require(!isMintableAssetType(assetId), \\\"MINTABLE_ASSET_TYPE\\\");\\n        require(isFungibleAssetType(assetId), \\\"NON_FUNGIBLE_ASSET_TYPE\\\");\\n\\n        // Make sure the vault contains sufficient funds.\\n        uint256 vaultBalance = vaultsBalances[msg.sender][assetId][vaultId];\\n        require(vaultBalance \\u003e= quantizedAmount, \\\"INSUFFICIENT_BALANCE\\\");\\n\\n        // Update the balance.\\n        vaultsBalances[msg.sender][assetId][vaultId] = vaultBalance - quantizedAmount;\\n\\n        // Transfer funds.\\n        transferOut(msg.sender, assetId, quantizedAmount);\\n\\n        // Log event.\\n        emit LogWithdrawalFromVault(\\n            msg.sender,\\n            assetId,\\n            vaultId,\\n            fromQuantized(assetId, quantizedAmount),\\n            quantizedAmount\\n        );\\n    }\\n}\\n\"},\"VaultLocks.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"StarkExStorage.sol\\\";\\nimport \\\"StarkExConstants.sol\\\";\\nimport \\\"MVaultLocks.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\n\\n/*\\n  Onchain vaults\\u0027 lock functionality.\\n*/\\nabstract contract VaultLocks is StarkExStorage, StarkExConstants, MGovernance, MVaultLocks {\\n    event LogDefaultVaultWithdrawalLockSet(uint256 newDefaultLockTime);\\n    event LogVaultWithdrawalLockSet(\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 timeRelease\\n    );\\n\\n    function initialize(uint256 defaultLockTime) internal {\\n        setDefaultVaultWithdrawalLock(defaultLockTime);\\n    }\\n\\n    // NOLINTNEXTLINE external-function.\\n    function setDefaultVaultWithdrawalLock(uint256 newDefaultTime) public onlyGovernance {\\n        require(newDefaultTime \\u003c= STARKEX_MAX_DEFAULT_VAULT_LOCK, \\\"DEFAULT_LOCK_TIME_TOO_LONG\\\");\\n        defaultVaultWithdrawalLock = newDefaultTime;\\n        emit LogDefaultVaultWithdrawalLockSet(newDefaultTime);\\n    }\\n\\n    function getVaultWithdrawalLock(\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) public view returns (uint256) {\\n        return vaultsWithdrawalLocks[ethKey][assetId][vaultId];\\n    }\\n\\n    function lockVault(\\n        uint256 assetId,\\n        uint256 vaultId,\\n        uint256 lockTime\\n    ) public {\\n        uint256 currentLockRelease = getVaultWithdrawalLock(msg.sender, assetId, vaultId);\\n        uint256 timeRelease = block.timestamp + lockTime;\\n        require(timeRelease \\u003e= currentLockRelease, \\\"INVALID_LOCK_TIME\\\");\\n\\n        vaultsWithdrawalLocks[msg.sender][assetId][vaultId] = timeRelease;\\n        emit LogVaultWithdrawalLockSet(msg.sender, assetId, vaultId, timeRelease);\\n    }\\n\\n    function applyDefaultLock(uint256 assetId, uint256 vaultId) internal override {\\n        uint256 currentLockRelease = getVaultWithdrawalLock(msg.sender, assetId, vaultId);\\n        if (currentLockRelease \\u003c block.timestamp + defaultVaultWithdrawalLock) {\\n            lockVault(assetId, vaultId, defaultVaultWithdrawalLock);\\n        }\\n    }\\n\\n    function isVaultLocked( // NOLINT external-function.\\n        address ethKey,\\n        uint256 assetId,\\n        uint256 vaultId\\n    ) public view override returns (bool) {\\n        uint256 timeRelease = getVaultWithdrawalLock(ethKey, assetId, vaultId);\\n        return (block.timestamp \\u003c timeRelease);\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDefaultLockTime\",\"type\":\"uint256\"}],\"name\":\"LogDefaultVaultWithdrawalLockSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogDepositToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acceptedGovernor\",\"type\":\"address\"}],\"name\":\"LogNewGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nominatedGovernor\",\"type\":\"address\"}],\"name\":\"LogNominatedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogNominationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedGovernor\",\"type\":\"address\"}],\"name\":\"LogRemovedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeRelease\",\"type\":\"uint256\"}],\"name\":\"LogVaultWithdrawalLockSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawalFromVault\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEPOSIT_CANCEL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREEZE_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAIN_GOVERNANCE_INFO_TAG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FORCED_ACTIONS_REQS_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VERIFIER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STARKEX_MAX_DEFAULT_VAULT_LOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNFREEZE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFIER_REMOVAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultVaultWithdrawalLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"depositERC20ToVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"depositEthToVault\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"}],\"name\":\"getAssetInfo\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"assetInfo\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getQuantizedVaultBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"presumedAssetType\",\"type\":\"uint256\"}],\"name\":\"getQuantum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultWithdrawalLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializerSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStrictVaultBalancePolicy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"isVaultLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"lockVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainAcceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainCancelNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"testGovernor\",\"type\":\"address\"}],\"name\":\"mainIsGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"mainNominateNewGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governorForRemoval\",\"type\":\"address\"}],\"name\":\"mainRemoveGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultTime\",\"type\":\"uint256\"}],\"name\":\"setDefaultVaultWithdrawalLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OnchainVaults","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f7fc9060f208e843a5ad1abbc0d4bb9c259805b66b3c5c6483400c5cb177ad9a"}]}