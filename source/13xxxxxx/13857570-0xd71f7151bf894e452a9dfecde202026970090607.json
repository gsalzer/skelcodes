{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.9;\r\n\r\ninterface IAxelarGateway {\r\n    /**********\\\r\n    |* Events *|\r\n    \\**********/\r\n\r\n    event Executed(bytes32 indexed commandId);\r\n\r\n    event TokenDeployed(string symbol, address tokenAddresses);\r\n\r\n    event TokenFrozen(string indexed symbol);\r\n\r\n    event TokenUnfrozen(string indexed symbol);\r\n\r\n    event AllTokensFrozen();\r\n\r\n    event AllTokensUnfrozen();\r\n\r\n    event AccountBlacklisted(address indexed account);\r\n\r\n    event AccountWhitelisted(address indexed account);\r\n\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function allTokensFrozen() external view returns (bool);\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function tokenAddresses(string memory symbol) external view returns (address);\r\n\r\n    function tokenFrozen(string memory symbol) external view returns (bool);\r\n\r\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\r\n\r\n    /*******************\\\r\n    |* Admin Functions *|\r\n    \\*******************/\r\n\r\n    function freezeToken(string memory symbol) external;\r\n\r\n    function unfreezeToken(string memory symbol) external;\r\n\r\n    function freezeAllTokens() external;\r\n\r\n    function unfreezeAllTokens() external;\r\n\r\n    function upgrade(address newImplementation, bytes calldata setupParams) external;\r\n\r\n    /**********************\\\r\n    |* External Functions *|\r\n    \\**********************/\r\n\r\n    function setup(bytes calldata params) external;\r\n\r\n    function execute(bytes calldata input) external;\r\n}\r\n\r\ninterface IAxelarGatewayMultisig is IAxelarGateway {\r\n\r\n    event OwnershipTransferred(address[] preOwners, uint256 prevThreshold, address[] newOwners, uint256 newThreshold);\r\n\r\n    event OperatorshipTransferred(address[] preOperators, uint256 prevThreshold, address[] newOperators, uint256 newThreshold);\r\n\r\n    function owners() external view returns (address[] memory);\r\n\r\n    function operators() external view returns (address[] memory);\r\n\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\r\n        // Check the signature length\r\n        require(signature.length == 65, 'INV_LEN');\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');\r\n\r\n        require(v == 27 || v == 28, 'INV_V');\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        require((signer = ecrecover(hash, v, r, s)) != address(0), 'INV_SIG');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    mapping(address => uint256) public override balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n\r\n    uint256 public override totalSupply;\r\n\r\n    string public name;\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name}, {symbol}, and {decimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) {\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), allowance[sender][_msgSender()] - amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, allowance[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, allowance[_msgSender()][spender] - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), 'ZERO_ADDR');\r\n        require(recipient != address(0), 'ZERO_ADDR');\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        balanceOf[sender] -= amount;\r\n        balanceOf[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), 'ZERO_ADDR');\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        totalSupply += amount;\r\n        balanceOf[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), 'ZERO_ADDR');\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        balanceOf[account] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), 'ZERO_ADDR');\r\n        require(spender != address(0), 'ZERO_ADDR');\r\n\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\nabstract contract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, 'NOT_OWNER');\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), 'ZERO_ADDR');\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Burner {\r\n    constructor(address tokenAddress, bytes32 salt) {\r\n        BurnableMintableCappedERC20(tokenAddress).burn(salt);\r\n\r\n        selfdestruct(payable(address(0)));\r\n    }\r\n}\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\r\n */\r\ncontract EternalStorage {\r\n    mapping(bytes32 => uint256) private _uintStorage;\r\n    mapping(bytes32 => string) private _stringStorage;\r\n    mapping(bytes32 => address) private _addressStorage;\r\n    mapping(bytes32 => bytes) private _bytesStorage;\r\n    mapping(bytes32 => bool) private _boolStorage;\r\n    mapping(bytes32 => int256) private _intStorage;\r\n\r\n    // *** Getter Methods ***\r\n    function getUint(bytes32 key) public view returns (uint256) {\r\n        return _uintStorage[key];\r\n    }\r\n\r\n    function getString(bytes32 key) public view returns (string memory) {\r\n        return _stringStorage[key];\r\n    }\r\n\r\n    function getAddress(bytes32 key) public view returns (address) {\r\n        return _addressStorage[key];\r\n    }\r\n\r\n    function getBytes(bytes32 key) public view returns (bytes memory) {\r\n        return _bytesStorage[key];\r\n    }\r\n\r\n    function getBool(bytes32 key) public view returns (bool) {\r\n        return _boolStorage[key];\r\n    }\r\n\r\n    function getInt(bytes32 key) public view returns (int256) {\r\n        return _intStorage[key];\r\n    }\r\n\r\n    // *** Setter Methods ***\r\n    function _setUint(bytes32 key, uint256 value) internal {\r\n        _uintStorage[key] = value;\r\n    }\r\n\r\n    function _setString(bytes32 key, string memory value) internal {\r\n        _stringStorage[key] = value;\r\n    }\r\n\r\n    function _setAddress(bytes32 key, address value) internal {\r\n        _addressStorage[key] = value;\r\n    }\r\n\r\n    function _setBytes(bytes32 key, bytes memory value) internal {\r\n        _bytesStorage[key] = value;\r\n    }\r\n\r\n    function _setBool(bytes32 key, bool value) internal {\r\n        _boolStorage[key] = value;\r\n    }\r\n\r\n    function _setInt(bytes32 key, int256 value) internal {\r\n        _intStorage[key] = value;\r\n    }\r\n\r\n    // *** Delete Methods ***\r\n    function _deleteUint(bytes32 key) internal {\r\n        delete _uintStorage[key];\r\n    }\r\n\r\n    function _deleteString(bytes32 key) internal {\r\n        delete _stringStorage[key];\r\n    }\r\n\r\n    function _deleteAddress(bytes32 key) internal {\r\n        delete _addressStorage[key];\r\n    }\r\n\r\n    function _deleteBytes(bytes32 key) internal {\r\n        delete _bytesStorage[key];\r\n    }\r\n\r\n    function _deleteBool(bytes32 key) internal {\r\n        delete _boolStorage[key];\r\n    }\r\n\r\n    function _deleteInt(bytes32 key) internal {\r\n        delete _intStorage[key];\r\n    }\r\n}\r\n\r\ncontract BurnableMintableCappedERC20 is ERC20, Ownable {\r\n    uint256 public cap;\r\n\r\n    bytes32 private constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\r\n    bytes32 private constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\r\n\r\n    event Frozen(address indexed owner);\r\n    event Unfrozen(address indexed owner);\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals,\r\n        uint256 capacity\r\n    ) ERC20(name, symbol, decimals) Ownable() {\r\n        cap = capacity;\r\n    }\r\n\r\n    function depositAddress(bytes32 salt) public view returns (address) {\r\n        // This would be easier, cheaper, simpler, and result in  globally consistent deposit addresses for any salt (all chains, all tokens).\r\n        // return address(uint160(uint256(keccak256(abi.encodePacked(bytes32(0x000000000000000000000000000000000000000000000000000000000000dead), salt)))));\r\n\r\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\r\n        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */\r\n        return\r\n            address(\r\n                uint160(\r\n                    uint256(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                bytes1(0xff),\r\n                                owner,\r\n                                salt,\r\n                                keccak256(abi.encodePacked(type(Burner).creationCode, abi.encode(address(this)), salt))\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function mint(address account, uint256 amount) public onlyOwner {\r\n        uint256 capacity = cap;\r\n        require(capacity == 0 || totalSupply + amount <= capacity, 'CAP_EXCEEDED');\r\n\r\n        _mint(account, amount);\r\n    }\r\n\r\n    function burn(bytes32 salt) public onlyOwner {\r\n        address account = depositAddress(salt);\r\n        _burn(account, balanceOf[account]);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) internal view override {\r\n        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');\r\n        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');\r\n    }\r\n}\r\n\r\ncontract AdminMultisigBase is EternalStorage {\r\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\r\n\r\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\r\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\r\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\r\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\r\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\r\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\r\n\r\n    modifier onlyAdmin() {\r\n        uint256 adminEpoch = _adminEpoch();\r\n\r\n        require(_isAdmin(adminEpoch, msg.sender), 'NOT_ADMIN');\r\n\r\n        bytes32 topic = keccak256(msg.data);\r\n\r\n        // Check that admin has not voted, then record that they have voted.\r\n        require(!_hasVoted(adminEpoch, topic, msg.sender), 'VOTED');\r\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\r\n\r\n        // Determine the new vote count and update it.\r\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\r\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\r\n\r\n        // Do not proceed with operation execution if insufficient votes.\r\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\r\n\r\n        _;\r\n\r\n        // Clear vote count and voted booleans.\r\n        _setVoteCount(adminEpoch, topic, uint256(0));\r\n\r\n        uint256 adminCount = _getAdminCount(adminEpoch);\r\n\r\n        for (uint256 i; i < adminCount; i++) {\r\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\r\n        }\r\n    }\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\r\n    }\r\n\r\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\r\n    }\r\n\r\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\r\n    }\r\n\r\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\r\n    }\r\n\r\n    function _getAdminVotedKey(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        address account\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\r\n    }\r\n\r\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function _adminEpoch() internal view returns (uint256) {\r\n        return getUint(KEY_ADMIN_EPOCH);\r\n    }\r\n\r\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\r\n        return getAddress(_getAdminKey(adminEpoch, index));\r\n    }\r\n\r\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\r\n        return getUint(_getAdminCountKey(adminEpoch));\r\n    }\r\n\r\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\r\n        return getUint(_getAdminThresholdKey(adminEpoch));\r\n    }\r\n\r\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\r\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\r\n    }\r\n\r\n    function _hasVoted(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        address account\r\n    ) internal view returns (bool) {\r\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\r\n    }\r\n\r\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\r\n        return getBool(_getIsAdminKey(adminEpoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Setters *|\r\n    \\***********/\r\n\r\n    function _setAdminEpoch(uint256 adminEpoch) internal {\r\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\r\n    }\r\n\r\n    function _setAdmin(\r\n        uint256 adminEpoch,\r\n        uint256 index,\r\n        address account\r\n    ) internal {\r\n        _setAddress(_getAdminKey(adminEpoch, index), account);\r\n    }\r\n\r\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\r\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\r\n    }\r\n\r\n    function _setAdmins(\r\n        uint256 adminEpoch,\r\n        address[] memory accounts,\r\n        uint256 threshold\r\n    ) internal {\r\n        uint256 adminLength = accounts.length;\r\n\r\n        require(adminLength >= threshold, 'INV_ADMINS');\r\n        require(threshold > uint256(0), 'INV_ADMIN_THLD');\r\n\r\n        _setAdminThreshold(adminEpoch, threshold);\r\n        _setAdminCount(adminEpoch, adminLength);\r\n\r\n        for (uint256 i; i < adminLength; i++) {\r\n            address account = accounts[i];\r\n\r\n            // Check that the account wasn't already set as an admin for this epoch.\r\n            require(!_isAdmin(adminEpoch, account), 'DUP_ADMIN');\r\n\r\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\r\n            _setAdmin(adminEpoch, i, account);\r\n            _setIsAdmin(adminEpoch, account, true);\r\n        }\r\n    }\r\n\r\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\r\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\r\n    }\r\n\r\n    function _setVoteCount(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        uint256 voteCount\r\n    ) internal {\r\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\r\n    }\r\n\r\n    function _setHasVoted(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        address account,\r\n        bool voted\r\n    ) internal {\r\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\r\n    }\r\n\r\n    function _setIsAdmin(\r\n        uint256 adminEpoch,\r\n        address account,\r\n        bool isAdmin\r\n    ) internal {\r\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\r\n    }\r\n}\r\n\r\nabstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {\r\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\r\n    bytes32 internal constant KEY_IMPLEMENTATION =\r\n        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\r\n\r\n    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\r\n\r\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\r\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\r\n    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\r\n\r\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\r\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\r\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\r\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\r\n    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');\r\n\r\n    uint8 internal constant OLD_KEY_RETENTION = 16;\r\n\r\n    modifier onlySelf() {\r\n        require(msg.sender == address(this), 'NOT_SELF');\r\n\r\n        _;\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function allTokensFrozen() public view override returns (bool) {\r\n        return getBool(KEY_ALL_TOKENS_FROZEN);\r\n    }\r\n\r\n    function implementation() public view override returns (address) {\r\n        return getAddress(KEY_IMPLEMENTATION);\r\n    }\r\n\r\n    function tokenAddresses(string memory symbol) public view override returns (address) {\r\n        return getAddress(_getTokenAddressKey(symbol));\r\n    }\r\n\r\n    function tokenFrozen(string memory symbol) public view override returns (bool) {\r\n        return getBool(_getFreezeTokenKey(symbol));\r\n    }\r\n\r\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\r\n        return getBool(_getIsCommandExecutedKey(commandId));\r\n    }\r\n\r\n    /*******************\\\r\n    |* Admin Functions *|\r\n    \\*******************/\r\n\r\n    function freezeToken(string memory symbol) external override onlyAdmin {\r\n        _setBool(_getFreezeTokenKey(symbol), true);\r\n\r\n        emit TokenFrozen(symbol);\r\n    }\r\n\r\n    function unfreezeToken(string memory symbol) external override onlyAdmin {\r\n        _setBool(_getFreezeTokenKey(symbol), false);\r\n\r\n        emit TokenUnfrozen(symbol);\r\n    }\r\n\r\n    function freezeAllTokens() external override onlyAdmin {\r\n        _setBool(KEY_ALL_TOKENS_FROZEN, true);\r\n\r\n        emit AllTokensFrozen();\r\n    }\r\n\r\n    function unfreezeAllTokens() external override onlyAdmin {\r\n        _setBool(KEY_ALL_TOKENS_FROZEN, false);\r\n\r\n        emit AllTokensUnfrozen();\r\n    }\r\n\r\n    function upgrade(address newImplementation, bytes calldata setupParams) external override onlyAdmin {\r\n        emit Upgraded(newImplementation);\r\n\r\n        (bool success, ) = newImplementation.delegatecall(\r\n            abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)\r\n        );\r\n        require(success, 'SETUP_FAILED');\r\n\r\n        _setImplementation(newImplementation);\r\n    }\r\n\r\n    /**********************\\\r\n    |* Internal Functions *|\r\n    \\**********************/\r\n\r\n    function _deployToken(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals,\r\n        uint256 cap\r\n    ) internal {\r\n        require(tokenAddresses(symbol) == address(0), 'TOKEN_EXIST');\r\n\r\n        bytes32 salt = keccak256(abi.encodePacked(symbol));\r\n        address token = address(new BurnableMintableCappedERC20{ salt: salt }(name, symbol, decimals, cap));\r\n\r\n        _setTokenAddress(symbol, token);\r\n\r\n        emit TokenDeployed(symbol, token);\r\n    }\r\n\r\n    function _mintToken(\r\n        string memory symbol,\r\n        address account,\r\n        uint256 amount\r\n    ) internal {\r\n        address tokenAddress = tokenAddresses(symbol);\r\n        require(tokenAddress != address(0), 'TOKEN_NOT_EXIST');\r\n\r\n        BurnableMintableCappedERC20(tokenAddress).mint(account, amount);\r\n    }\r\n\r\n    function _burnToken(string memory symbol, bytes32 salt) internal {\r\n        address tokenAddress = tokenAddresses(symbol);\r\n        require(tokenAddress != address(0), 'TOKEN_NOT_EXIST');\r\n\r\n        BurnableMintableCappedERC20(tokenAddress).burn(salt);\r\n    }\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));\r\n    }\r\n\r\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\r\n    }\r\n\r\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\r\n    }\r\n\r\n    /********************\\\r\n    |* Internal Getters *|\r\n    \\********************/\r\n\r\n    function _getChainID() internal view returns (uint256 id) {\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n    }\r\n\r\n    /********************\\\r\n    |* Internal Setters *|\r\n    \\********************/\r\n\r\n    function _setTokenAddress(string memory symbol, address tokenAddr) internal {\r\n        _setAddress(_getTokenAddressKey(symbol), tokenAddr);\r\n    }\r\n\r\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\r\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\r\n    }\r\n\r\n    function _setImplementation(address newImplementation) internal {\r\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\r\n    }\r\n}\r\n\r\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\r\n    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\r\n\r\n    bytes32 internal constant PREFIX_OWNER = keccak256('owner');\r\n    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\r\n    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\r\n    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\r\n\r\n    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\r\n\r\n    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\r\n    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\r\n    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\r\n    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\r\n\r\n    function _containsDuplicates(address[] memory accounts) internal pure returns (bool) {\r\n        uint256 count = accounts.length;\r\n\r\n        for (uint256 i; i < count; ++i) {\r\n            for (uint256 j = i + 1; j < count; ++j) {\r\n                if (accounts[i] == accounts[j]) return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /************************\\\r\n    |* Owners Functionality *|\r\n    \\************************/\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getOwnerKey(uint256 ownerEpoch, uint256 index) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OWNER, ownerEpoch, index));\r\n    }\r\n\r\n    function _getOwnerCountKey(uint256 ownerEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, ownerEpoch));\r\n    }\r\n\r\n    function _getOwnerThresholdKey(uint256 ownerEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, ownerEpoch));\r\n    }\r\n\r\n    function _getIsOwnerKey(uint256 ownerEpoch, address account) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, ownerEpoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function _ownerEpoch() internal view returns (uint256) {\r\n        return getUint(KEY_OWNER_EPOCH);\r\n    }\r\n\r\n    function _getOwner(uint256 ownerEpoch, uint256 index) internal view returns (address) {\r\n        return getAddress(_getOwnerKey(ownerEpoch, index));\r\n    }\r\n\r\n    function _getOwnerCount(uint256 ownerEpoch) internal view returns (uint256) {\r\n        return getUint(_getOwnerCountKey(ownerEpoch));\r\n    }\r\n\r\n    function _getOwnerThreshold(uint256 ownerEpoch) internal view returns (uint256) {\r\n        return getUint(_getOwnerThresholdKey(ownerEpoch));\r\n    }\r\n\r\n    function _isOwner(uint256 ownerEpoch, address account) internal view returns (bool) {\r\n        return getBool(_getIsOwnerKey(ownerEpoch, account));\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the same `ownerEpoch`, within the last `OLD_KEY_RETENTION + 1` owner epochs.\r\n    function _areValidRecentOwners(address[] memory accounts) internal view returns (bool) {\r\n        uint256 ownerEpoch = _ownerEpoch();\r\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\r\n        uint256 lowerBoundOwnerEpoch = ownerEpoch > recentEpochs ? ownerEpoch - recentEpochs : uint256(0);\r\n\r\n        while (ownerEpoch > lowerBoundOwnerEpoch) {\r\n            if (_areValidOwnersInEpoch(ownerEpoch--, accounts)) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.\r\n    function _areValidOwnersInEpoch(uint256 ownerEpoch, address[] memory accounts) internal view returns (bool) {\r\n        if (_containsDuplicates(accounts)) return false;\r\n\r\n        uint256 threshold = _getOwnerThreshold(ownerEpoch);\r\n        uint256 validSignerCount;\r\n\r\n        for (uint256 i; i < accounts.length; i++) {\r\n            if (_isOwner(ownerEpoch, accounts[i]) && ++validSignerCount >= threshold) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns the array of owners within the current `ownerEpoch`.\r\n    function owners() public view override returns (address[] memory results) {\r\n        uint256 ownerEpoch = _ownerEpoch();\r\n        uint256 ownerCount = _getOwnerCount(ownerEpoch);\r\n        results = new address[](ownerCount);\r\n\r\n        for (uint256 i; i < ownerCount; i++) {\r\n            results[i] = _getOwner(ownerEpoch, i);\r\n        }\r\n    }\r\n\r\n    /***********\\\r\n    |* Setters *|\r\n    \\***********/\r\n\r\n    function _setOwnerEpoch(uint256 ownerEpoch) internal {\r\n        _setUint(KEY_OWNER_EPOCH, ownerEpoch);\r\n    }\r\n\r\n    function _setOwner(\r\n        uint256 ownerEpoch,\r\n        uint256 index,\r\n        address account\r\n    ) internal {\r\n        require(account != address(0), 'ZERO_ADDR');\r\n        _setAddress(_getOwnerKey(ownerEpoch, index), account);\r\n    }\r\n\r\n    function _setOwnerCount(uint256 ownerEpoch, uint256 ownerCount) internal {\r\n        _setUint(_getOwnerCountKey(ownerEpoch), ownerCount);\r\n    }\r\n\r\n    function _setOwners(\r\n        uint256 ownerEpoch,\r\n        address[] memory accounts,\r\n        uint256 threshold\r\n    ) internal {\r\n        uint256 accountLength = accounts.length;\r\n\r\n        require(accountLength >= threshold, 'INV_OWNERS');\r\n        require(threshold > uint256(0), 'INV_OWNER_THLD');\r\n\r\n        _setOwnerThreshold(ownerEpoch, threshold);\r\n        _setOwnerCount(ownerEpoch, accountLength);\r\n\r\n        for (uint256 i; i < accountLength; i++) {\r\n            address account = accounts[i];\r\n\r\n            // Check that the account wasn't already set as an owner for this ownerEpoch.\r\n            require(!_isOwner(ownerEpoch, account), 'DUP_OWNER');\r\n\r\n            // Set this account as the i-th owner in this ownerEpoch (needed to we can get all the owners for `owners`).\r\n            _setOwner(ownerEpoch, i, account);\r\n            _setIsOwner(ownerEpoch, account, true);\r\n        }\r\n    }\r\n\r\n    function _setOwnerThreshold(uint256 ownerEpoch, uint256 ownerThreshold) internal {\r\n        _setUint(_getOwnerThresholdKey(ownerEpoch), ownerThreshold);\r\n    }\r\n\r\n    function _setIsOwner(\r\n        uint256 ownerEpoch,\r\n        address account,\r\n        bool isOwner\r\n    ) internal {\r\n        _setBool(_getIsOwnerKey(ownerEpoch, account), isOwner);\r\n    }\r\n\r\n    /**************************\\\r\n    |* Operator Functionality *|\r\n    \\**************************/\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getOperatorKey(uint256 operatorEpoch, uint256 index) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR, operatorEpoch, index));\r\n    }\r\n\r\n    function _getOperatorCountKey(uint256 operatorEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, operatorEpoch));\r\n    }\r\n\r\n    function _getOperatorThresholdKey(uint256 operatorEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, operatorEpoch));\r\n    }\r\n\r\n    function _getIsOperatorKey(uint256 operatorEpoch, address account) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, operatorEpoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function _operatorEpoch() internal view returns (uint256) {\r\n        return getUint(KEY_OPERATOR_EPOCH);\r\n    }\r\n\r\n    function _getOperator(uint256 operatorEpoch, uint256 index) internal view returns (address) {\r\n        return getAddress(_getOperatorKey(operatorEpoch, index));\r\n    }\r\n\r\n    function _getOperatorCount(uint256 operatorEpoch) internal view returns (uint256) {\r\n        return getUint(_getOperatorCountKey(operatorEpoch));\r\n    }\r\n\r\n    function _getOperatorThreshold(uint256 operatorEpoch) internal view returns (uint256) {\r\n        return getUint(_getOperatorThresholdKey(operatorEpoch));\r\n    }\r\n\r\n    function _isOperator(uint256 operatorEpoch, address account) internal view returns (bool) {\r\n        return getBool(_getIsOperatorKey(operatorEpoch, account));\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.\r\n    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {\r\n        uint256 operatorEpoch = _operatorEpoch();\r\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\r\n        uint256 lowerBoundOperatorEpoch = operatorEpoch > recentEpochs ? operatorEpoch - recentEpochs : uint256(0);\r\n\r\n        while (operatorEpoch > lowerBoundOperatorEpoch) {\r\n            if (_areValidOperatorsInEpoch(operatorEpoch--, accounts)) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.\r\n    function _areValidOperatorsInEpoch(uint256 operatorEpoch, address[] memory accounts) internal view returns (bool) {\r\n        if (_containsDuplicates(accounts)) return false;\r\n\r\n        uint256 threshold = _getOperatorThreshold(operatorEpoch);\r\n        uint256 validSignerCount;\r\n\r\n        for (uint256 i; i < accounts.length; i++) {\r\n            if (_isOperator(operatorEpoch, accounts[i]) && ++validSignerCount >= threshold) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns the array of operators within the current `operatorEpoch`.\r\n    function operators() public view override returns (address[] memory results) {\r\n        uint256 operatorEpoch = _operatorEpoch();\r\n        uint256 operatorCount = _getOperatorCount(operatorEpoch);\r\n        results = new address[](operatorCount);\r\n\r\n        for (uint256 i; i < operatorCount; i++) {\r\n            results[i] = _getOperator(operatorEpoch, i);\r\n        }\r\n    }\r\n\r\n    /***********\\\r\n    |* Setters *|\r\n    \\***********/\r\n\r\n    function _setOperatorEpoch(uint256 operatorEpoch) internal {\r\n        _setUint(KEY_OPERATOR_EPOCH, operatorEpoch);\r\n    }\r\n\r\n    function _setOperator(\r\n        uint256 operatorEpoch,\r\n        uint256 index,\r\n        address account\r\n    ) internal {\r\n        _setAddress(_getOperatorKey(operatorEpoch, index), account);\r\n    }\r\n\r\n    function _setOperatorCount(uint256 operatorEpoch, uint256 operatorCount) internal {\r\n        _setUint(_getOperatorCountKey(operatorEpoch), operatorCount);\r\n    }\r\n\r\n    function _setOperators(\r\n        uint256 operatorEpoch,\r\n        address[] memory accounts,\r\n        uint256 threshold\r\n    ) internal {\r\n        uint256 accountLength = accounts.length;\r\n\r\n        require(accountLength >= threshold, 'INV_OPERATORS');\r\n        require(threshold > uint256(0), 'INV_OPERATOR_THLD');\r\n\r\n        _setOperatorThreshold(operatorEpoch, threshold);\r\n        _setOperatorCount(operatorEpoch, accountLength);\r\n\r\n        for (uint256 i; i < accountLength; i++) {\r\n            address account = accounts[i];\r\n\r\n            // Check that the account wasn't already set as an operator for this operatorEpoch.\r\n            require(!_isOperator(operatorEpoch, account), 'DUP_OPERATOR');\r\n\r\n            // Set this account as the i-th operator in this operatorEpoch (needed to we can get all the operators for `operators`).\r\n            _setOperator(operatorEpoch, i, account);\r\n            _setIsOperator(operatorEpoch, account, true);\r\n        }\r\n    }\r\n\r\n    function _setOperatorThreshold(uint256 operatorEpoch, uint256 operatorThreshold) internal {\r\n        _setUint(_getOperatorThresholdKey(operatorEpoch), operatorThreshold);\r\n    }\r\n\r\n    function _setIsOperator(\r\n        uint256 operatorEpoch,\r\n        address account,\r\n        bool isOperator\r\n    ) internal {\r\n        _setBool(_getIsOperatorKey(operatorEpoch, account), isOperator);\r\n    }\r\n\r\n    /**********************\\\r\n    |* Self Functionality *|\r\n    \\**********************/\r\n\r\n    function deployToken(bytes calldata params) external onlySelf {\r\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap) = abi.decode(\r\n            params,\r\n            (string, string, uint8, uint256)\r\n        );\r\n\r\n        _deployToken(name, symbol, decimals, cap);\r\n    }\r\n\r\n    function mintToken(bytes calldata params) external onlySelf {\r\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\r\n\r\n        _mintToken(symbol, account, amount);\r\n    }\r\n\r\n    function burnToken(bytes calldata params) external onlySelf {\r\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\r\n\r\n        _burnToken(symbol, salt);\r\n    }\r\n\r\n    function transferOwnership(bytes calldata params) external onlySelf {\r\n        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));\r\n\r\n        uint256 ownerEpoch = _ownerEpoch();\r\n\r\n        emit OwnershipTransferred(owners(), _getOwnerThreshold(ownerEpoch), newOwners, newThreshold);\r\n\r\n        _setOwnerEpoch(++ownerEpoch);\r\n        _setOwners(ownerEpoch, newOwners, newThreshold);\r\n    }\r\n\r\n    function transferOperatorship(bytes calldata params) external onlySelf {\r\n        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));\r\n\r\n        uint256 ownerEpoch = _ownerEpoch();\r\n\r\n        emit OperatorshipTransferred(operators(), _getOperatorThreshold(ownerEpoch), newOperators, newThreshold);\r\n\r\n        uint256 operatorEpoch = _operatorEpoch();\r\n        _setOperatorEpoch(++operatorEpoch);\r\n        _setOperators(operatorEpoch, newOperators, newThreshold);\r\n    }\r\n\r\n    /**************************\\\r\n    |* External Functionality *|\r\n    \\**************************/\r\n\r\n    function setup(bytes calldata params) external override {\r\n        // Prevent setup from being called on a non-proxy (the implementation).\r\n        require(implementation() != address(0), 'NOT_PROXY');\r\n\r\n        (\r\n            address[] memory adminAddresses,\r\n            uint256 adminThreshold,\r\n            address[] memory ownerAddresses,\r\n            uint256 ownerThreshold,\r\n            address[] memory operatorAddresses,\r\n            uint256 operatorThreshold\r\n        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));\r\n\r\n        uint256 adminEpoch = _adminEpoch() + uint256(1);\r\n        _setAdminEpoch(adminEpoch);\r\n        _setAdmins(adminEpoch, adminAddresses, adminThreshold);\r\n\r\n        uint256 ownerEpoch = _ownerEpoch() + uint256(1);\r\n        _setOwnerEpoch(ownerEpoch);\r\n        _setOwners(ownerEpoch, ownerAddresses, ownerThreshold);\r\n\r\n        uint256 operatorEpoch = _operatorEpoch() + uint256(1);\r\n        _setOperatorEpoch(operatorEpoch);\r\n        _setOperators(operatorEpoch, operatorAddresses, operatorThreshold);\r\n\r\n        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, ownerThreshold);\r\n        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, operatorThreshold);\r\n    }\r\n\r\n    function execute(bytes calldata input) external override {\r\n        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));\r\n\r\n        _execute(data, signatures);\r\n    }\r\n\r\n    function _execute(bytes memory data, bytes[] memory signatures) internal {\r\n        uint256 signatureCount = signatures.length;\r\n\r\n        address[] memory signers = new address[](signatureCount);\r\n\r\n        for (uint256 i; i < signatureCount; i++) {\r\n            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);\r\n        }\r\n\r\n        (uint256 chainId, bytes32[] memory commandIds, string[] memory commands, bytes[] memory params) = abi.decode(\r\n            data,\r\n            (uint256, bytes32[], string[], bytes[])\r\n        );\r\n\r\n        require(chainId == _getChainID(), 'INV_CHAIN');\r\n\r\n        uint256 commandsLength = commandIds.length;\r\n\r\n        require(commandsLength == commands.length && commandsLength == params.length, 'INV_CMDS');\r\n\r\n        bool areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);\r\n        bool areValidRecentOwners = areValidCurrentOwners || _areValidRecentOwners(signers);\r\n        bool areValidRecentOperators = _areValidRecentOperators(signers);\r\n\r\n        for (uint256 i; i < commandsLength; i++) {\r\n            bytes32 commandId = commandIds[i];\r\n\r\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\r\n\r\n            bytes4 commandSelector;\r\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\r\n\r\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\r\n                if (!areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.deployToken.selector;\r\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\r\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.mintToken.selector;\r\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\r\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.burnToken.selector;\r\n            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {\r\n                if (!areValidCurrentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;\r\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\r\n                if (!areValidCurrentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;\r\n            } else {\r\n                continue; /* Ignore if unknown command received */\r\n            }\r\n\r\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\r\n            _setCommandExecuted(commandId, true);\r\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i]));\r\n            _setCommandExecuted(commandId, success);\r\n\r\n            if (success) {\r\n                emit Executed(commandId);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllTokensFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllTokensUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"preOperators\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newOperators\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"OperatorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"preOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddresses\",\"type\":\"address\"}],\"name\":\"TokenDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allTokensFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"burnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"deployToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezeAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"freezeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getBool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getInt\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"}],\"name\":\"isCommandExecuted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"mintToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"results\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"results\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"tokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"tokenFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"transferOperatorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreezeAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"unfreezeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"setupParams\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AxelarGatewayMultisig","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://650a3d16decebe4547c4596d6c58eb39fc086a5e2785d73373e140c33d3203ab"}]}