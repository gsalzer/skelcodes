{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/SpiritOrbPetsCarev1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n//\\r\\n// Spirit Orb Pets Pet Care Contract for v1 Pets\\r\\n// Developed by:  Heartfelt Games LLC\\r\\n//\\r\\n// This is the first of many contracts that allows Spirit Orb Pets to be\\r\\n// interactable in the Spirit Orb Pets blockchain-based game.\\r\\n//\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\ninterface ICareToken is IERC20 {\\r\\n  function mintToApprovedContract(uint256 amount, address mintToAddress) external;\\r\\n  function burn(address sender, uint256 paymentAmount) external;\\r\\n}\\r\\n\\r\\ninterface ISpiritOrbPetsv1 is IERC721, IERC721Enumerable {\\r\\n  function getPetInfo(uint16 id) external view returns (\\r\\n    uint8 level,\\r\\n    bool active\\r\\n  );\\r\\n\\r\\n  function getPetCooldowns(uint16 id) external view returns (\\r\\n    uint64 cdPlay,\\r\\n    uint64 cdFeed,\\r\\n    uint64 cdClean,\\r\\n    uint64 cdTrain,\\r\\n    uint64 cdDaycare\\r\\n  );\\r\\n\\r\\n  function getPausedState() external view returns (bool);\\r\\n  function getMaxPetLevel() external view returns (uint8);\\r\\n  function petName(uint16 id) external view returns (string memory);\\r\\n\\r\\n  function setPetName(uint16 id, string memory name) external;\\r\\n  function setPetLevel(uint16 id, uint8 level) external;\\r\\n  function setPetActive(uint16 id, bool active) external;\\r\\n  function setPetCdPlay(uint16 id, uint64 cdPlay) external;\\r\\n  function setPetCdFeed(uint16 id, uint64 cdFeed) external;\\r\\n  function setPetCdClean(uint16 id, uint64 cdClean) external;\\r\\n  function setPetCdTrain(uint16 id, uint64 cdTrain) external;\\r\\n  function setPetCdDaycare(uint16 id, uint64 cdDaycare) external;\\r\\n}\\r\\n\\r\\ncontract SpiritOrbPetsCarev1 is Ownable {\\r\\n\\r\\n    ISpiritOrbPetsv1 public SOPv1;\\r\\n    ICareToken public CareToken;\\r\\n\\r\\n    uint256 public _timeUntilLevelDown = 72 hours; // 259200 uint value in seconds\\r\\n\\r\\n    event Activated(address sender, uint16 id);\\r\\n    event Deactivated(address sender, uint16 id);\\r\\n    event PlayedWithPet(address sender, uint16 id, bool levelDownEventOccurred);\\r\\n    event FedPet(address sender, uint16 id, uint careTokensToPay, bool levelDownEventOccurred);\\r\\n    event CleanedPet(address sender,uint16 id, bool levelDownEventOccurred);\\r\\n    event TrainedPet(address sender, uint16 id);\\r\\n    event SentToDaycare(address sender, uint16 id, uint daysToPayFor);\\r\\n\\r\\n    modifier notAtDaycare(uint16 id) {\\r\\n      ( , , , , uint cdDaycare ) = SOPv1.getPetCooldowns(id);\\r\\n      require(cdDaycare <= block.timestamp, \\\"Cannot perform action while pet is at daycare.\\\");\\r\\n      _;\\r\\n    }\\r\\n\\r\\n    function setTimeUntilLevelDown(uint256 newTime) external onlyOwner {\\r\\n      _timeUntilLevelDown = newTime;\\r\\n    }\\r\\n\\r\\n    function getTrueLevel(uint16 id) public view returns (uint8) {\\r\\n      (uint64 cdPlay, uint64 cdFeed, uint64 cdClean, , ) = SOPv1.getPetCooldowns(id);\\r\\n      (uint8 level, ) = SOPv1.getPetInfo(id);\\r\\n      uint64 blockTimestamp = uint64(block.timestamp);\\r\\n      bool hungry = cdFeed <= blockTimestamp;\\r\\n      bool dirty = cdClean + _timeUntilLevelDown <= blockTimestamp;\\r\\n      bool unhappy = cdPlay + _timeUntilLevelDown <= blockTimestamp;\\r\\n\\r\\n      // if completely neglected, pet's level resets to 1\\r\\n      if (hungry && dirty && unhappy && level != 30) {\\r\\n        level = 1;\\r\\n      }\\r\\n      // Separated into 3 so it doesn't go below 1\\r\\n      if (hungry && level > 1 && level != 30) {\\r\\n        level = level - 1;\\r\\n      }\\r\\n      if (dirty && level > 1 && level != 30) {\\r\\n        level = level - 1;\\r\\n      }\\r\\n      if (unhappy && level > 1 && level != 30) {\\r\\n        level = level - 1;\\r\\n      }\\r\\n      return level;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    / @dev Enables all pet interactions.\\r\\n    */\\r\\n    function activatePet(uint16 id) external {\\r\\n      ( , bool active) = SOPv1.getPetInfo(id);\\r\\n      require(!SOPv1.getPausedState(), \\\"Pet adoption has not yet begun.\\\");\\r\\n      require(SOPv1.ownerOf(id) == msg.sender);\\r\\n      require(!active, \\\"Pet is already active!\\\");\\r\\n\\r\\n      resetPetCooldowns(id);\\r\\n\\r\\n      emit Activated(msg.sender, id);\\r\\n    }\\r\\n\\r\\n    function resetPetCooldowns(uint16 id) internal {\\r\\n      (uint64 cdPlay, , , , ) = SOPv1.getPetCooldowns(id);\\r\\n      SOPv1.setPetActive(id, true);\\r\\n      if (cdPlay == 0) SOPv1.setPetCdPlay(id, uint64(block.timestamp));\\r\\n      SOPv1.setPetCdFeed(id, uint64(block.timestamp + 1 hours));\\r\\n      SOPv1.setPetCdClean(id, uint64(block.timestamp + 3 days - 1 hours));\\r\\n      SOPv1.setPetCdTrain(id, uint64(block.timestamp + 23 hours));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Deactivating the pet will reduce the level to 1 unless they are at max level\\r\\n    */\\r\\n    function deactivatePet(uint16 id) external {\\r\\n      ( , , , , uint cdDaycare) = SOPv1.getPetCooldowns(id);\\r\\n      (  uint8 level, bool active) = SOPv1.getPetInfo(id);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender);\\r\\n      require(active, \\\"Pet is not active yet.\\\");\\r\\n\\r\\n      SOPv1.setPetActive(id, false);\\r\\n      if (cdDaycare > uint64(block.timestamp)) {\\r\\n        SOPv1.setPetCdDaycare(id, 0);\\r\\n        SOPv1.setPetCdPlay(id, uint64(block.timestamp));\\r\\n        // everything else is reset during reactivation\\r\\n      }\\r\\n      if (level < SOPv1.getMaxPetLevel()) {\\r\\n        SOPv1.setPetLevel(id, 1);\\r\\n      }\\r\\n\\r\\n      emit Deactivated(msg.sender, id);\\r\\n    }\\r\\n\\r\\n    function levelDown(uint16 id) internal {\\r\\n      (uint64 cdPlay, uint64 cdFeed, uint64 cdClean, , ) = SOPv1.getPetCooldowns(id);\\r\\n      (uint8 level, ) = SOPv1.getPetInfo(id);\\r\\n      uint64 blockTimestamp = uint64(block.timestamp);\\r\\n      bool hungry = cdFeed <= blockTimestamp;\\r\\n      bool dirty = cdClean + _timeUntilLevelDown <= blockTimestamp;\\r\\n      bool unhappy = cdPlay + _timeUntilLevelDown <= blockTimestamp;\\r\\n\\r\\n      if (level > 1 && level != 30) {\\r\\n        SOPv1.setPetLevel(id, level - 1);\\r\\n      }\\r\\n\\r\\n      // if completely neglected, pet's level resets to 1\\r\\n      if (hungry && dirty && unhappy && level != 30) {\\r\\n        SOPv1.setPetLevel(id, 1);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    function levelUp(uint16 id) internal {\\r\\n      (uint8 level, ) = SOPv1.getPetInfo(id);\\r\\n      if (level < SOPv1.getMaxPetLevel()) {\\r\\n        SOPv1.setPetLevel(id, level + 1);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Playing with your pet is one of the primary ways to earn CARE tokens.\\r\\n    */\\r\\n    function playWithPet(uint16 id) external {\\r\\n      (uint64 cdPlay, uint64 cdFeed, uint64 cdClean, , ) = SOPv1.getPetCooldowns(id);\\r\\n      ( , bool active) = SOPv1.getPetInfo(id);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet can play with it!\\\");\\r\\n      require(active, \\\"Pet needs to be active to receive CARE tokens.\\\");\\r\\n      require(cdFeed >= uint64(block.timestamp), \\\"Pet is too hungry to play.\\\");\\r\\n      require(cdClean >= uint64(block.timestamp), \\\"Pet is too dirty to play.\\\");\\r\\n      require(cdPlay <= uint64(block.timestamp), \\\"You can only redeem CARE tokens every 23 hours.\\\");\\r\\n\\r\\n      // send CARE tokens to owner\\r\\n      CareToken.mintToApprovedContract(10 * 10 ** 18, msg.sender);\\r\\n\\r\\n      // check if the pet was played with on time, if not, level down\\r\\n      bool levelDownEventOccurred = false;\\r\\n      if (cdPlay + _timeUntilLevelDown <= uint64(block.timestamp)) {\\r\\n        levelDown(id);\\r\\n        levelDownEventOccurred = true;\\r\\n      }\\r\\n\\r\\n      // set new time for playing with pet\\r\\n      SOPv1.setPetCdPlay(id, uint64(block.timestamp + 23 hours));\\r\\n\\r\\n      emit PlayedWithPet(msg.sender, id, levelDownEventOccurred);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Sets the cdFeed timer when you activate it. The user must approve\\r\\n    * @dev token use on the ERC20 contract so that this contract can accept the\\r\\n    * @dev transaction.  The pet will level down if you took too long to feed it.\\r\\n    */\\r\\n    function feedPet(uint16 id, uint careTokensToPay) external notAtDaycare(id) {\\r\\n      ( , uint64 cdFeed, uint64 cdClean,  ,  ) = SOPv1.getPetCooldowns(id);\\r\\n      ( , bool active) = SOPv1.getPetInfo(id);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet can feed it!\\\");\\r\\n      require(active, \\\"Pet needs to be active to feed it.\\\");\\r\\n      require(cdClean >= uint64(block.timestamp), \\\"Pet is too dirty to eat.\\\");\\r\\n      require(careTokensToPay <= 15, \\\"You should not overfeed your pet.\\\");\\r\\n      require(careTokensToPay >= 5, \\\"Too little CARE sent to feed pet.\\\");\\r\\n      // Skip checking if it's too soon to feed the pet.  We can just\\r\\n      // control this from the front end.  This also allows players to\\r\\n      // top off their pet's feeding meter whenever they want.\\r\\n\\r\\n      // take CARE tokens from owner\\r\\n      uint paymentAmount = careTokensToPay * 10 ** 18;\\r\\n      // Token must be approved from the CARE token's address by the owner\\r\\n      CareToken.burn(msg.sender, paymentAmount);\\r\\n\\r\\n      uint64 blockTimestamp = uint64(block.timestamp);\\r\\n\\r\\n      // check if the pet was fed on time, if not, level down\\r\\n      bool levelDownEventOccurred = false;\\r\\n      if (cdFeed <= blockTimestamp) {\\r\\n        levelDown(id);\\r\\n        levelDownEventOccurred = true;\\r\\n      }\\r\\n\\r\\n      // set new time for feeding pet\\r\\n      // if pet isn't starving yet, just add the time, otherwise set the time to now + tokens/5 days\\r\\n      if (cdFeed > blockTimestamp) {\\r\\n        uint64 newFeedTime = cdFeed + uint64(careTokensToPay/5 * 1 days);\\r\\n        SOPv1.setPetCdFeed(id, newFeedTime);\\r\\n        // Pet cannot be full for more than 3 days max\\r\\n        if (newFeedTime > blockTimestamp + 3 days) {\\r\\n          SOPv1.setPetCdFeed(id, blockTimestamp + 3 days);\\r\\n        }\\r\\n      } else {\\r\\n        SOPv1.setPetCdFeed(id, uint64(blockTimestamp + (careTokensToPay/5 * 1 days))); //5 tokens per 24hrs up to 72hrs\\r\\n      }\\r\\n\\r\\n      emit FedPet(msg.sender, id, careTokensToPay, levelDownEventOccurred);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Cleaning your pet is a secondary way to earn CARE tokens.  If you don't clean\\r\\n    * @dev your pet in time, your pet will level down.\\r\\n    */\\r\\n    function cleanPet(uint16 id) external {\\r\\n      ( , , uint64 cdClean, , ) = SOPv1.getPetCooldowns(id);\\r\\n      ( , bool active) = SOPv1.getPetInfo(id);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet can clean it!\\\");\\r\\n      require(active, \\\"Pet needs to be active to clean.\\\");\\r\\n      uint64 blockTimestamp = uint64(block.timestamp);\\r\\n      require(cdClean <= blockTimestamp, \\\"Pet is not dirty yet.\\\");\\r\\n\\r\\n      // send CARE tokens to owner\\r\\n      CareToken.mintToApprovedContract(30 * 10 ** 18, msg.sender);\\r\\n\\r\\n      // check if the pet was cleaned on time, if not, level down\\r\\n      bool levelDownEventOccurred = false;\\r\\n      if ((cdClean + _timeUntilLevelDown) <= blockTimestamp) {\\r\\n        levelDown(id);\\r\\n        levelDownEventOccurred = true;\\r\\n      }\\r\\n\\r\\n      SOPv1.setPetCdClean(id, blockTimestamp + 3 days - 1 hours);\\r\\n      emit CleanedPet(msg.sender, id, levelDownEventOccurred);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Training your pet is the primary way to level it up.  You can do it once per\\r\\n    * @dev day - 1 hour, 23 hours after activating it.\\r\\n    */\\r\\n    function trainPet(uint16 id) external notAtDaycare(id) {\\r\\n      ( , uint64 cdFeed, uint64 cdClean, uint64 cdTrain, ) = SOPv1.getPetCooldowns(id);\\r\\n      ( uint8 level, bool active) = SOPv1.getPetInfo(id);\\r\\n      uint64 blockTimestamp = uint64(block.timestamp);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet can train it!\\\");\\r\\n      require(active, \\\"Pet needs to be active to train.\\\");\\r\\n      require(cdFeed >= blockTimestamp, \\\"Pet is too hungry to train.\\\");\\r\\n      require(cdClean >= blockTimestamp, \\\"Pet is too dirty to train.\\\");\\r\\n      require(cdTrain <= blockTimestamp, \\\"Pet is too tired to train.\\\");\\r\\n\\r\\n      if (level < 30) {\\r\\n\\r\\n        // take CARE tokens from owner\\r\\n        uint paymentAmount = 10 * 10 ** 18;\\r\\n        // Token must be approved from the CARE token's address by the owner\\r\\n        CareToken.burn(msg.sender, paymentAmount);\\r\\n\\r\\n        levelUp(id);\\r\\n      } else {\\r\\n        // send CARE tokens to owner\\r\\n        CareToken.mintToApprovedContract(10 * 10 ** 18, msg.sender);\\r\\n      }\\r\\n\\r\\n      SOPv1.setPetCdTrain(id, blockTimestamp + 23 hours);\\r\\n      emit TrainedPet(msg.sender, id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Sending your pet to daycare is intended to freeze your pet's status if you\\r\\n    * @dev plan to be away from it for a while. There is no refund for bringing your\\r\\n    * @dev pet back early.\\r\\n    */\\r\\n    function sendToDaycare(uint16 id, uint daysToPayFor) external notAtDaycare(id) {\\r\\n      (uint8 level , bool active) = SOPv1.getPetInfo(id);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet can send it to daycare!\\\");\\r\\n      require(active, \\\"Pet needs to be active to send it to daycare.\\\");\\r\\n      require(daysToPayFor >= 1, \\\"Minimum 1 day of daycare required.\\\");\\r\\n      require(daysToPayFor <= 30, \\\"You cannot send pet to daycare for that long.\\\");\\r\\n\\r\\n      // pet MUST NOT have a level-down event occuring; daycare would otherwise by-pass it\\r\\n      require(getTrueLevel(id) == level, \\\"Pet cannot go to daycare if it has been neglected.\\\");\\r\\n\\r\\n      // take CARE tokens from owner\\r\\n      // each day is 10 whole CARE tokens\\r\\n      uint paymentAmount = daysToPayFor * 10 * 10 ** 18;\\r\\n      // Token must be approved from the CARE token's address by the owner\\r\\n      CareToken.burn(msg.sender, paymentAmount);\\r\\n\\r\\n      // calculate how many days to send pet to daycare\\r\\n      uint timeToSendPet = daysToPayFor * 1 days;\\r\\n\\r\\n      // set timer for daycare and caretaking activities\\r\\n      uint64 timeToSetCareCooldowns = uint64(block.timestamp + timeToSendPet);\\r\\n      SOPv1.setPetCdDaycare(id, timeToSetCareCooldowns);\\r\\n      SOPv1.setPetCdPlay(id, timeToSetCareCooldowns);\\r\\n      SOPv1.setPetCdFeed(id, timeToSetCareCooldowns);\\r\\n      SOPv1.setPetCdClean(id, timeToSetCareCooldowns + 3 days - 1 hours);\\r\\n      SOPv1.setPetCdTrain(id, timeToSetCareCooldowns);\\r\\n\\r\\n      emit SentToDaycare(msg.sender, id, daysToPayFor);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Brings pet back from daycare. Funds are not refunded and cooldowns are\\r\\n    * @dev reset as if from the state of activation again.\\r\\n    */\\r\\n    function retrieveFromDaycare(uint16 id) external {\\r\\n      ( ,  ,  ,  , uint cdDaycare) = SOPv1.getPetCooldowns(id);\\r\\n      ( , bool active) = SOPv1.getPetInfo(id);\\r\\n      uint64 blockTimestamp = uint64(block.timestamp);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet send it to daycare!\\\");\\r\\n      require(active, \\\"Pet needs to be active to retrieve it from daycare.\\\");\\r\\n      require(cdDaycare > blockTimestamp, \\\"Cannot perform action if pet is not in daycare.\\\");\\r\\n\\r\\n      resetPetCooldowns(id);\\r\\n      // Additional exceptions for daycare; allow play\\r\\n      SOPv1.setPetCdDaycare(id, 0);\\r\\n      SOPv1.setPetCdPlay(id, blockTimestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Allows the user to rename their pet.  If the pet has a name already,\\r\\n    * @dev it will cost 100 CARE tokens.\\r\\n    * @dev The front-end can limit number of characters displayed from the output\\r\\n    * @dev of getName\\r\\n    */\\r\\n    function namePet(uint16 id, string memory newName) external {\\r\\n      ( , bool active) = SOPv1.getPetInfo(id);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet can name it!\\\");\\r\\n      require(active, \\\"Pet needs to be active to name it.\\\");\\r\\n      require(keccak256(abi.encodePacked(newName)) != keccak256(abi.encodePacked(SOPv1.petName(id))), \\\"Pet already has this name.\\\");\\r\\n\\r\\n      if (keccak256(abi.encodePacked(SOPv1.petName(id))) == keccak256(abi.encodePacked(\\\"\\\"))) {\\r\\n        SOPv1.setPetName(id, newName);\\r\\n      } else {\\r\\n        // take CARE tokens from owner\\r\\n        uint paymentAmount = 100 * 10 ** 18;\\r\\n        // Token must be approved from the CARE token's address by the owner\\r\\n        CareToken.burn(msg.sender, paymentAmount);\\r\\n\\r\\n        SOPv1.setPetName(id, newName);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * @dev This is a secondary way to level up more quickly if you want to bypass the\\r\\n    * @dev main way. It costs more CARE, but is not limited by time cooldowns.\\r\\n    */\\r\\n    function levelUpWithCare(uint16 id, uint levelsToGoUp) external notAtDaycare(id) {\\r\\n      (uint8 level, bool active) = SOPv1.getPetInfo(id);\\r\\n      require(SOPv1.ownerOf(id) == msg.sender, \\\"Only the owner of the pet can level it up!\\\");\\r\\n      require(active, \\\"Pet needs to be active to level up.\\\");\\r\\n      require(level < 30, \\\"Pet is already at max level.\\\");\\r\\n      require(level + uint8(levelsToGoUp) <= 30, \\\"This would make your pet exceed level 30 and waste tokens.\\\");\\r\\n\\r\\n      // take CARE tokens from owner\\r\\n      // each level is 100 whole CARE tokens\\r\\n      uint paymentAmount = levelsToGoUp * 100 * 10 ** 18;\\r\\n      // Token must be approved from the CARE token's address by the owner\\r\\n      CareToken.burn(msg.sender, paymentAmount);\\r\\n\\r\\n      for (uint i = 0; i < levelsToGoUp; i++) {\\r\\n        levelUp(id);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    function setCareToken(address careTokenAddress) external onlyOwner {\\r\\n      CareToken = ICareToken(careTokenAddress);\\r\\n    }\\r\\n\\r\\n    function setSOPV1Contract(address sopv1Address) external onlyOwner {\\r\\n      SOPv1 = ISpiritOrbPetsv1(sopv1Address);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"Activated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"levelDownEventOccurred\",\"type\":\"bool\"}],\"name\":\"CleanedPet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"Deactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"careTokensToPay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"levelDownEventOccurred\",\"type\":\"bool\"}],\"name\":\"FedPet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"levelDownEventOccurred\",\"type\":\"bool\"}],\"name\":\"PlayedWithPet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daysToPayFor\",\"type\":\"uint256\"}],\"name\":\"SentToDaycare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"TrainedPet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CareToken\",\"outputs\":[{\"internalType\":\"contract ICareToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SOPv1\",\"outputs\":[{\"internalType\":\"contract ISpiritOrbPetsv1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_timeUntilLevelDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"activatePet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"cleanPet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"deactivatePet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"careTokensToPay\",\"type\":\"uint256\"}],\"name\":\"feedPet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"getTrueLevel\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"levelsToGoUp\",\"type\":\"uint256\"}],\"name\":\"levelUpWithCare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"namePet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"playWithPet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"retrieveFromDaycare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"daysToPayFor\",\"type\":\"uint256\"}],\"name\":\"sendToDaycare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"careTokenAddress\",\"type\":\"address\"}],\"name\":\"setCareToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sopv1Address\",\"type\":\"address\"}],\"name\":\"setSOPV1Contract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"setTimeUntilLevelDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"trainPet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SpiritOrbPetsCarev1","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}