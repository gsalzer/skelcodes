{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Controlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\nimport \\\"../interfaces/IKernel.sol\\\";\\n\\nabstract contract Controlled is Initializable, ModuleMapConsumer {\\n  // controller address => is a controller\\n  mapping(address => bool) internal _controllers;\\n  address[] public controllers;\\n\\n  function __Controlled_init(address[] memory controllers_, address moduleMap_)\\n    public\\n    initializer\\n  {\\n    for (uint256 i; i < controllers_.length; i++) {\\n      _controllers[controllers_[i]] = true;\\n    }\\n    controllers = controllers_;\\n    __ModuleMapConsumer_init(moduleMap_);\\n  }\\n\\n  function addController(address controller) external onlyOwner {\\n    _controllers[controller] = true;\\n    bool added;\\n    for (uint256 i; i < controllers.length; i++) {\\n      if (controller == controllers[i]) {\\n        added = true;\\n      }\\n    }\\n    if (!added) {\\n      controllers.push(controller);\\n    }\\n  }\\n\\n  modifier onlyOwner() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isOwner(msg.sender),\\n      \\\"Controlled::onlyOwner: Caller is not owner\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isManager(msg.sender),\\n      \\\"Controlled::onlyManager: Caller is not manager\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyController() {\\n    require(\\n      _controllers[msg.sender],\\n      \\\"Controlled::onlyController: Caller is not controller\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/EtherRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/IEtherRewards.sol\\\";\\nimport \\\"../interfaces/IIntegrationMap.sol\\\";\\nimport \\\"../interfaces/IStrategyMap.sol\\\";\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\n\\ncontract EtherRewards is\\n  Initializable,\\n  ModuleMapConsumer,\\n  Controlled,\\n  IEtherRewards\\n{\\n  /// @param controllers_ The array of controllers for this contract\\n  /// @param moduleMap_ The address of the ModuleMap contract\\n  function initialize(address[] memory controllers_, address moduleMap_)\\n    public\\n    initializer\\n  {\\n    __Controlled_init(controllers_, moduleMap_);\\n    __ModuleMapConsumer_init(moduleMap_);\\n  }\\n\\n  uint256 private totalEthRewards;\\n  uint256 private totalClaimedEthRewards;\\n  mapping(address => uint256) private totalUserClaimedEthRewards;\\n  mapping(address => uint256) private tokenRewardRate;\\n  mapping(address => uint256) private tokenEthRewards;\\n  mapping(address => mapping(address => uint256)) private userTokenRewardRate;\\n  mapping(address => mapping(address => uint256))\\n    private userTokenAccumulatedRewards;\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @param user The address of the user\\n  function updateUserRewards(address token, address user)\\n    public\\n    override\\n    onlyController\\n  {\\n    uint256 userTokenDeposits = IStrategyMap(\\n      moduleMap.getModuleAddress(Modules.StrategyMap)\\n    ).getUserInvestedAmountByToken(token, user);\\n\\n    userTokenAccumulatedRewards[token][user] +=\\n      ((tokenRewardRate[token] - userTokenRewardRate[token][user]) *\\n        userTokenDeposits) /\\n      10**18;\\n\\n    userTokenRewardRate[token][user] = tokenRewardRate[token];\\n  }\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @param ethRewardsAmount The amount of Ether rewards to add\\n  function increaseEthRewards(address token, uint256 ethRewardsAmount)\\n    external\\n    override\\n    onlyController\\n  {\\n    uint256 tokenTotalDeposits = IStrategyMap(\\n      moduleMap.getModuleAddress(Modules.StrategyMap)\\n    ).getTokenTotalBalance(token);\\n    require(\\n      tokenTotalDeposits > 0,\\n      \\\"EtherRewards::increaseEthRewards: Token has not been deposited yet\\\"\\n    );\\n\\n    totalEthRewards += ethRewardsAmount;\\n    tokenEthRewards[token] += ethRewardsAmount;\\n    tokenRewardRate[token] += (ethRewardsAmount * 10**18) / tokenTotalDeposits;\\n  }\\n\\n  /// @param user The address of the user\\n  /// @return ethRewards The amount of Ether claimed\\n  function claimEthRewards(address user)\\n    external\\n    override\\n    onlyController\\n    returns (uint256 ethRewards)\\n  {\\n    address integrationMap = moduleMap.getModuleAddress(Modules.IntegrationMap);\\n    uint256 tokenCount = IIntegrationMap(integrationMap)\\n      .getTokenAddressesLength();\\n\\n    for (uint256 tokenId; tokenId < tokenCount; tokenId++) {\\n      address token = IIntegrationMap(integrationMap).getTokenAddress(tokenId);\\n      ethRewards += claimTokenEthRewards(token, user);\\n    }\\n  }\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @param user The address of the user\\n  /// @return ethRewards The amount of Ether claimed\\n  function claimTokenEthRewards(address token, address user)\\n    private\\n    returns (uint256 ethRewards)\\n  {\\n    updateUserRewards(token, user);\\n    ethRewards = userTokenAccumulatedRewards[token][user];\\n\\n    userTokenAccumulatedRewards[token][user] = 0;\\n    tokenEthRewards[token] -= ethRewards;\\n    totalEthRewards -= ethRewards;\\n    totalClaimedEthRewards += ethRewards;\\n    totalUserClaimedEthRewards[user] += ethRewards;\\n  }\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @param user The address of the user\\n  /// @return ethRewards The amount of Ether claimed\\n  function getUserTokenEthRewards(address token, address user)\\n    public\\n    view\\n    override\\n    returns (uint256 ethRewards)\\n  {\\n    uint256 userTokenDeposits = IStrategyMap(\\n      moduleMap.getModuleAddress(Modules.StrategyMap)\\n    ).getUserInvestedAmountByToken(token, user);\\n\\n    ethRewards =\\n      userTokenAccumulatedRewards[token][user] +\\n      ((tokenRewardRate[token] - userTokenRewardRate[token][user]) *\\n        userTokenDeposits) /\\n      10**18;\\n  }\\n\\n  /// @param user The address of the user\\n  /// @return ethRewards The amount of Ether claimed\\n  function getUserEthRewards(address user)\\n    external\\n    view\\n    override\\n    returns (uint256 ethRewards)\\n  {\\n    address integrationMap = moduleMap.getModuleAddress(Modules.IntegrationMap);\\n    uint256 tokenCount = IIntegrationMap(integrationMap)\\n      .getTokenAddressesLength();\\n\\n    for (uint256 tokenId; tokenId < tokenCount; tokenId++) {\\n      address token = IIntegrationMap(integrationMap).getTokenAddress(tokenId);\\n      ethRewards += getUserTokenEthRewards(token, user);\\n    }\\n  }\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @return The amount of Ether rewards for the specified token\\n  function getTokenEthRewards(address token)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return tokenEthRewards[token];\\n  }\\n\\n  /// @return The total value of ETH claimed by users\\n  function getTotalClaimedEthRewards()\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return totalClaimedEthRewards;\\n  }\\n\\n  /// @return The total value of ETH claimed by a user\\n  function getTotalUserClaimedEthRewards(address account)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return totalUserClaimedEthRewards[account];\\n  }\\n\\n  /// @return The total amount of Ether rewards\\n  function getEthRewards() external view override returns (uint256) {\\n    return totalEthRewards;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ModuleMapConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IModuleMap.sol\\\";\\n\\nabstract contract ModuleMapConsumer is Initializable {\\n  IModuleMap public moduleMap;\\n\\n  function __ModuleMapConsumer_init(address moduleMap_) internal initializer {\\n    moduleMap = IModuleMap(moduleMap_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEtherRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IEtherRewards {\\n  /// @param token The address of the token ERC20 contract\\n  /// @param user The address of the user\\n  function updateUserRewards(address token, address user) external;\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @param ethRewardsAmount The amount of Ether rewards to add\\n  function increaseEthRewards(address token, uint256 ethRewardsAmount) external;\\n\\n  /// @param user The address of the user\\n  /// @return ethRewards The amount of Ether claimed\\n  function claimEthRewards(address user) external returns (uint256 ethRewards);\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @param user The address of the user\\n  /// @return ethRewards The amount of Ether claimed\\n  function getUserTokenEthRewards(address token, address user)\\n    external\\n    view\\n    returns (uint256 ethRewards);\\n\\n  /// @param user The address of the user\\n  /// @return ethRewards The amount of Ether claimed\\n  function getUserEthRewards(address user)\\n    external\\n    view\\n    returns (uint256 ethRewards);\\n\\n  /// @param token The address of the token ERC20 contract\\n  /// @return The amount of Ether rewards for the specified token\\n  function getTokenEthRewards(address token) external view returns (uint256);\\n\\n  /// @return The total value of ETH claimed by users\\n  function getTotalClaimedEthRewards() external view returns (uint256);\\n\\n  /// @return The total value of ETH claimed by a user\\n  function getTotalUserClaimedEthRewards(address user)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return The total amount of Ether rewards\\n  function getEthRewards() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIntegration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IIntegration {\\n  /// @param tokenAddress The address of the deposited token\\n  /// @param amount The amount of the token being deposited\\n  function deposit(address tokenAddress, uint256 amount) external;\\n\\n  /// @param tokenAddress The address of the withdrawal token\\n  /// @param amount The amount of the token to withdraw\\n  function withdraw(address tokenAddress, uint256 amount) external;\\n\\n  /// @dev Deploys all tokens held in the integration contract to the integrated protocol\\n  function deploy() external;\\n\\n  /// @dev Harvests token yield from the Aave lending pool\\n  function harvestYield() external;\\n\\n  /// @dev This returns the total amount of the underlying token that\\n  /// @dev has been deposited to the integration contract\\n  /// @param tokenAddress The address of the deployed token\\n  /// @return The amount of the underlying token that can be withdrawn\\n  function getBalance(address tokenAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIntegrationMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IIntegrationMap {\\n  struct Integration {\\n    bool added;\\n    string name;\\n  }\\n\\n  struct Token {\\n    uint256 id;\\n    bool added;\\n    bool acceptingDeposits;\\n    bool acceptingWithdrawals;\\n    uint256 biosRewardWeight;\\n    uint256 reserveRatioNumerator;\\n  }\\n\\n  /// @param contractAddress The address of the integration contract\\n  /// @param name The name of the protocol being integrated to\\n  function addIntegration(address contractAddress, string memory name) external;\\n\\n  /// @param tokenAddress The address of the ERC20 token contract\\n  /// @param acceptingDeposits Whether token deposits are enabled\\n  /// @param acceptingWithdrawals Whether token withdrawals are enabled\\n  /// @param biosRewardWeight Token weight for BIOS rewards\\n  /// @param reserveRatioNumerator Number that gets divided by reserve ratio denominator to get reserve ratio\\n  function addToken(\\n    address tokenAddress,\\n    bool acceptingDeposits,\\n    bool acceptingWithdrawals,\\n    uint256 biosRewardWeight,\\n    uint256 reserveRatioNumerator\\n  ) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function enableTokenDeposits(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function disableTokenDeposits(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function enableTokenWithdrawals(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function disableTokenWithdrawals(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @param rewardWeight The updated token BIOS reward weight\\n  function updateTokenRewardWeight(address tokenAddress, uint256 rewardWeight)\\n    external;\\n\\n  /// @param tokenAddress the address of the token ERC20 contract\\n  /// @param reserveRatioNumerator Number that gets divided by reserve ratio denominator to get reserve ratio\\n  function updateTokenReserveRatioNumerator(\\n    address tokenAddress,\\n    uint256 reserveRatioNumerator\\n  ) external;\\n\\n  /// @param integrationId The ID of the integration\\n  /// @return The address of the integration contract\\n  function getIntegrationAddress(uint256 integrationId)\\n    external\\n    view\\n    returns (address);\\n\\n  /// @param integrationAddress The address of the integration contract\\n  /// @return The name of the of the protocol being integrated to\\n  function getIntegrationName(address integrationAddress)\\n    external\\n    view\\n    returns (string memory);\\n\\n  /// @return The address of the WETH token\\n  function getWethTokenAddress() external view returns (address);\\n\\n  /// @return The address of the BIOS token\\n  function getBiosTokenAddress() external view returns (address);\\n\\n  /// @param tokenId The ID of the token\\n  /// @return The address of the token ERC20 contract\\n  function getTokenAddress(uint256 tokenId) external view returns (address);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The index of the token in the tokens array\\n  function getTokenId(address tokenAddress) external view returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The token BIOS reward weight\\n  function getTokenBiosRewardWeight(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return rewardWeightSum reward weight of depositable tokens\\n  function getBiosRewardWeightSum()\\n    external\\n    view\\n    returns (uint256 rewardWeightSum);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return bool indicating whether depositing this token is currently enabled\\n  function getTokenAcceptingDeposits(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return bool indicating whether withdrawing this token is currently enabled\\n  function getTokenAcceptingWithdrawals(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  // @param tokenAddress The address of the token ERC20 contract\\n  // @return bool indicating whether the token has been added\\n  function getIsTokenAdded(address tokenAddress) external view returns (bool);\\n\\n  // @param integrationAddress The address of the integration contract\\n  // @return bool indicating whether the integration has been added\\n  function getIsIntegrationAdded(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  /// @notice get the length of supported tokens\\n  /// @return The quantity of tokens added\\n  function getTokenAddressesLength() external view returns (uint256);\\n\\n  /// @notice get the length of supported integrations\\n  /// @return The quantity of integrations added\\n  function getIntegrationAddressesLength() external view returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The value that gets divided by the reserve ratio denominator\\n  function getTokenReserveRatioNumerator(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return The token reserve ratio denominator\\n  function getReserveRatioDenominator() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IKernel {\\n  /// @param account The address of the account to check if they are a manager\\n  /// @return Bool indicating whether the account is a manger\\n  function isManager(address account) external view returns (bool);\\n\\n  /// @param account The address of the account to check if they are an owner\\n  /// @return Bool indicating whether the account is an owner\\n  function isOwner(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IModuleMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nenum Modules {\\n  Kernel, // 0\\n  UserPositions, // 1\\n  YieldManager, // 2\\n  IntegrationMap, // 3\\n  BiosRewards, // 4\\n  EtherRewards, // 5\\n  SushiSwapTrader, // 6\\n  UniswapTrader, // 7\\n  StrategyMap, // 8\\n  StrategyManager // 9\\n}\\n\\ninterface IModuleMap {\\n  function getModuleAddress(Modules key) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategyMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\nimport \\\"../interfaces/IIntegration.sol\\\";\\n\\ninterface IStrategyMap {\\n  // #### Structs\\n  struct WeightedIntegration {\\n    address integration;\\n    uint256 weight;\\n  }\\n\\n  struct Strategy {\\n    string name;\\n    uint256 totalStrategyWeight;\\n    mapping(address => bool) enabledTokens;\\n    address[] tokens;\\n    WeightedIntegration[] integrations;\\n  }\\n\\n  struct StrategySummary {\\n    string name;\\n    uint256 totalStrategyWeight;\\n    address[] tokens;\\n    WeightedIntegration[] integrations;\\n  }\\n\\n  struct StrategyTransaction {\\n    uint256 amount;\\n    address token;\\n  }\\n\\n  // #### Events\\n  event NewStrategy(\\n    uint256 indexed id,\\n    string name,\\n    WeightedIntegration[] integrations,\\n    address[] tokens\\n  );\\n  event UpdateName(uint256 indexed id, string name);\\n  event UpdateIntegrations(\\n    uint256 indexed id,\\n    WeightedIntegration[] integrations\\n  );\\n  event UpdateTokens(uint256 indexed id, address[] tokens);\\n  event DeleteStrategy(\\n    uint256 indexed id,\\n    string name,\\n    address[] tokens,\\n    WeightedIntegration[] integrations\\n  );\\n\\n  event EnterStrategy(\\n    uint256 indexed id,\\n    address indexed user,\\n    address[] tokens,\\n    uint256[] amounts\\n  );\\n  event ExitStrategy(\\n    uint256 indexed id,\\n    address indexed user,\\n    address[] tokens,\\n    uint256[] amounts\\n  );\\n\\n  // #### Functions\\n  /**\\n     @notice Adds a new strategy to the list of available strategies\\n     @param name  the name of the new strategy\\n     @param integrations  the integrations and weights that form the strategy\\n     */\\n  function addStrategy(\\n    string calldata name,\\n    WeightedIntegration[] memory integrations,\\n    address[] calldata tokens\\n  ) external;\\n\\n  /**\\n    @notice Updates the strategy name\\n    @param name  the new name\\n     */\\n  function updateName(uint256 id, string calldata name) external;\\n\\n  /**\\n  @notice Updates a strategy's accepted tokens\\n  @param id  The strategy ID\\n  @param tokens  The new tokens to allow\\n  */\\n  function updateTokens(uint256 id, address[] calldata tokens) external;\\n\\n  /**\\n    @notice Updates the strategy integrations \\n    @param integrations  the new integrations\\n     */\\n  function updateIntegrations(\\n    uint256 id,\\n    WeightedIntegration[] memory integrations\\n  ) external;\\n\\n  /**\\n    @notice Deletes a strategy\\n    @dev This can only be called successfully if the strategy being deleted doesn't have any assets invested in it\\n    @param id  the strategy to delete\\n     */\\n  function deleteStrategy(uint256 id) external;\\n\\n  /**\\n    @notice Increases the amount of a set of tokens in a strategy\\n    @param id  the strategy to deposit into\\n    @param tokens  the tokens to deposit\\n    @param amounts  The amounts to be deposited\\n     */\\n  function enterStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n    @notice Decreases the amount of a set of tokens invested in a strategy\\n    @param id  the strategy to withdraw assets from\\n    @param tokens  the tokens to withdraw\\n    @param amounts  The amounts to be withdrawn\\n     */\\n  function exitStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n    @notice Getter function to return the nested arrays as well as the name\\n    @param id  the strategy to return\\n     */\\n  function getStrategy(uint256 id)\\n    external\\n    view\\n    returns (StrategySummary memory);\\n\\n  /**\\n    @notice Returns the expected balance of a given token in a given integration\\n    @param integration  the integration the amount should be invested in\\n    @param token  the token that is being invested\\n    @return balance  the balance of the token that should be currently invested in the integration \\n     */\\n  function getExpectedBalance(address integration, address token)\\n    external\\n    view\\n    returns (uint256 balance);\\n\\n  /**\\n    @notice Returns the amount of a given token currently invested in a strategy\\n    @param id  the strategy id to check\\n    @param token  The token to retrieve the balance for\\n    @return amount  the amount of token that is invested in the strategy\\n     */\\n  function getStrategyTokenBalance(uint256 id, address token)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n    @notice returns the amount of a given token a user has invested in a given strategy\\n    @param id  the strategy id\\n    @param token  the token address\\n    @param user  the user who holds the funds\\n    @return amount  the amount of token that the user has invested in the strategy \\n     */\\n  function getUserStrategyBalanceByToken(\\n    uint256 id,\\n    address token,\\n    address user\\n  ) external view returns (uint256 amount);\\n\\n  /**\\n    @notice Returns the amount of a given token that a user has invested across all strategies\\n    @param token  the token address\\n    @param user  the user holding the funds\\n    @return amount  the amount of tokens the user has invested across all strategies\\n     */\\n  function getUserInvestedAmountByToken(address token, address user)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n    @notice Returns the total amount of a token invested across all strategies\\n    @param token  the token to fetch the balance for\\n    @return amount  the amount of the token currently invested\\n    */\\n  function getTokenTotalBalance(address token)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n  @notice Returns the weight of an individual integration within the system\\n  @param integration  the integration to look up\\n  @return The weight of the integration\\n   */\\n  function getIntegrationWeight(address integration)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n  @notice Returns the sum of all weights in the system.\\n  @return The sum of all integration weights within the system\\n   */\\n  function getIntegrationWeightSum() external view returns (uint256);\\n\\n  /// @notice autogenerated getter definition\\n  function idCounter() external view returns(uint256);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"}],\"name\":\"__Controlled_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"addController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimEthRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenEthRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalClaimedEthRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalUserClaimedEthRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserEthRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTokenEthRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethRewardsAmount\",\"type\":\"uint256\"}],\"name\":\"increaseEthRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleMap\",\"outputs\":[{\"internalType\":\"contract IModuleMap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateUserRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherRewards","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":""}]}