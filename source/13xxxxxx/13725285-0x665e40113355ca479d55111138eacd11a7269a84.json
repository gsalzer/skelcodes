{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Sacred.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Helpers.sol\\\";\\n\\n\\n/*\\n * @title Sacred contract\\n * @author @0xAnimist\\n * @notice Used for pseudorandomly assigning sacred names\\n */\\nlibrary Sacred {\\n\\n  uint8 public constant tokensPerName = 4;\\n  uint8 public constant totalNgrams = 89;\\n  string public constant nameDelimiter = \\\".\\\";\\n\\n\\n  /** @notice Returns a sacred syllable from a host of languages, ancient and\\n    * contemporary, based on the _index\\n    * @param _index The index value from 0-88\\n    * @return The sacred syllable ngram\\n    */\\n  function ngram(uint8 _index) public pure returns (string memory) {\\n    string[totalNgrams] memory ngrams = [\\n      //Sanskrit sacred seeds\\n      \\\"\\\\u0101\\\\u1E25\\\",//birth of the universe\\n      \\\"o\\\\u1E43\\\",//opening syllable\\n      \\\"h\\\\u016B\\\\u1E43\\\",//closing syllable\\n      \\\"dh\\\\u012B\\\\u1E25\\\",//perfect wisdom\\n      \\\"pha\\\\u1E6D\\\",//ancient magical word\\n      \\\"au\\\",//Sanskrit, \\\"o\\\"\\n\\n      //Sanskrit consonants, Egyptian and Maori terms\\n      \\\"akh\\\",//Egyptian\\n      \\\"ua\\\",//Egyptian: \\\"one who becomes eight\\\" / \\\"growth comes to be\\\"\\n      \\\"kh\\\",//Egyptian: \\\"pool of water rises up\\\"\\n      \\\"qet\\\",//Egyptian: fire, grain, Serpent, \\\"pedestal gives circle\\\"\\n      \\\"ka\\\",//Sanskrit, Egypt\\n      \\\"kha\\\",//Sanskrit\\n      \\\"ba\\\",//Sanskrit, Egypt\\n      \\\"bha\\\",//Sanskrit\\n      \\\"la\\\",//Sanskrit\\n      \\\"\\\\u1E6Da\\\",//Sanskrit\\n      \\\"\\\\u1E6Dha\\\",//Sanskrit\\n      \\\"pa\\\",//Sanskrit, Maori\\n      \\\"pha\\\",//Sanskrit\\n      \\\"ga\\\",//Sanskrit\\n      \\\"gha\\\",//Sanskrit\\n      \\\"ja\\\",//Sanskrit\\n      \\\"jha\\\",//Sanskrit\\n      \\\"\\\\u1E0Da\\\",//Sanskrit\\n      \\\"\\\\u1E0Dha\\\",//Sanskrit\\n      \\\"\\\\u00F1a\\\",//Sanskrit\\n      \\\"ya\\\",//Sanskrit, Dogon\\n      \\\"ra\\\",//Sanskrit, Egyptian\\n      \\\"\\\\u015Ba\\\",//Sanskrit\\n\\n      //Dogon\\n      \\\"\\\\u0119mm\\\\u0119\\\",//from female sorghum\\n      \\\"p\\\\u014D\\\",//digitaria\\n      \\\"sigi\\\",//Sigui, Sirius\\n      \\\"tolo\\\",//star\\n\\n      //Angels\\n      \\\"el\\\",\\n      \\\"ael\\\",\\n      \\\"iel\\\",\\n      \\\"al\\\",\\n      \\\"iah\\\",\\n      \\\"vehu\\\",\\n      \\\"jel\\\",\\n      \\\"nik\\\",\\n      \\\"sit\\\",\\n      \\\"man\\\",\\n      \\\"leu\\\",\\n\\n      //Goetia\\n      \\\"mon\\\",\\n      \\\"eth\\\",\\n      \\\"deus\\\",\\n      \\\"aga\\\",\\n      \\\"bar\\\",\\n      \\\"ast\\\",\\n      \\\"mur\\\",\\n      \\\"ion\\\",\\n      \\\"tri\\\",\\n      \\\"nab\\\",\\n      \\\"ius\\\",\\n\\n      //Faerie\\n      \\\"tit\\\",\\n      \\\"mabd\\\",\\n      \\\"elf\\\",\\n      \\\"gno\\\",\\n      \\\"tua\\\",\\n      \\\"d\\\\u00E9\\\",\\n      \\\"aos\\\",\\n      \\\"s\\\\u00ED\\\",\\n\\n      //Q'ero\\n      \\\"ayni\\\",\\n      \\\"hua\\\",\\n      \\\"nee\\\",\\n      \\\"ska\\\",\\n\\n      //Greek\\n      \\\"nym\\\",\\n      \\\"pan\\\",\\n      \\\"syb\\\",\\n\\n      //Urbit\\n      \\\"zod\\\",\\n      \\\"bin\\\",\\n      \\\"ryx\\\",\\n\\n      //Chinese\\n      \\\"tian\\\",\\n      \\\"ren\\\",\\n      \\\"jing\\\",\\n      \\\"dao\\\",\\n      \\\"zhi\\\",\\n      \\\"ye\\\",\\n      \\\"xu\\\",\\n      \\\"shi\\\",\\n      \\\"gu\\\\u01D0\\\",\\n\\n      //Shintoism\\n      \\\"ama\\\",\\n      \\\"chi\\\",\\n      \\\"edo\\\",\\n      \\\"gi\\\",\\n      \\\"kon\\\",\\n      \\\"oni\\\",\\n      \\\"sei\\\"\\n    ];\\n\\n    return ngrams[_index];\\n  }\\n\\n\\n  /** @notice Pseudorandomly selects and punctuates an ngram\\n    * @param _tokenId The _tokenId of the token name to reveal\\n    * @param _index The index of the ngram (for names with > 1 ngram)\\n    * @return The resulting ngram\\n    */\\n  function pluckNGram(uint256 _tokenId, uint256 _index) public pure returns (string memory) {\\n      uint256 rand = Helpers.random(string(abi.encodePacked(Helpers.toString(_index), Helpers.toString(_tokenId))));\\n      string memory output = ngram(uint8(rand % totalNgrams));\\n      //punctuate pseudorandomly\\n      if(_index < (tokensPerName - 1)){\\n        uint256 daemonicPotential  = rand % 33;\\n        if (daemonicPotential >= 13) {\\n            output = string(abi.encodePacked(output, nameDelimiter));\\n        }\\n      }\\n\\n      return output;\\n  }\\n\\n\\n  /** @notice Reveals the name of a token\\n    * @param _tokenId The _tokenId of the token name to reveal\\n    * @return The name of _tokenId\\n    */\\n  function callBy(uint256 _tokenId) public pure returns (string memory) {\\n    string memory name = \\\"\\\";\\n\\n    for(uint i = 0; i < tokensPerName; i++){\\n      name = string(abi.encodePacked(name, pluckNGram(_tokenId, i)));\\n    }\\n\\n    return name;\\n  }\\n\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\n\\n/** @title Daemonica helper functions\\n  * @author @0xAnimist\\n  * @notice Misc support for Daemonica contract suite\\n  */\\nlibrary Helpers{\\n\\n  /** @notice Converts boolean to a string\\n    * @param  value The boolean value\\n    * @return A string that reads \\\"true\\\" or \\\"false\\\"\\n    */\\n  function boolToString(bool value) public pure returns (string memory) {\\n    if(value){\\n      return \\\"true\\\";\\n    }else{\\n      return \\\"false\\\";\\n    }\\n  }\\n\\n  /** @notice Converts uint256 to a string\\n    * @param  value The uint256 value\\n    * @return A string that represents the numerical value of the input\\n    */\\n  function toString(uint256 value) public pure returns (string memory) {\\n  // Inspired by OraclizeAPI's implementation - MIT license\\n  // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n      if (value == 0) {\\n          return \\\"0\\\";\\n      }\\n      uint256 temp = value;\\n      uint256 digits;\\n      while (temp != 0) {\\n          digits++;\\n          temp /= 10;\\n      }\\n      bytes memory buffer = new bytes(digits);\\n      while (value != 0) {\\n          digits -= 1;\\n          buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n          value /= 10;\\n      }\\n      return string(buffer);\\n  }\\n\\n  /** @notice Converts uint8 to a string\\n    * @param  value The uint8 value\\n    * @return A string that represents the numerical value of the input\\n    */\\n  function toString8(uint8 value) public pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"00\\\";\\n    }\\n\\n    uint8 temp = value;\\n    uint8 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer;\\n    if(digits == 1){\\n      buffer = new bytes(2);\\n      buffer[0] = bytes1(uint8(48));\\n      buffer[1] = bytes1(uint8(48 + uint8(value % 10)));\\n    }else{\\n      buffer = new bytes(digits);\\n      while (value != 0) {\\n        digits -= 1;\\n        buffer[digits] = bytes1(uint8(48 + uint8(value % 10)));\\n        value /= 10;\\n      }\\n    }\\n\\n    return string(buffer);\\n  }\\n\\n\\n\\n  /** @notice Returns a _delimiter delimited string of all the values in an 8 uint8 long array\\n    * @param  _array Array of uint8 values to concatenate\\n    * @param  _delimiter String to delimit each value\\n    * @return Concatenated string of all the values delimited by _delimiter\\n    */\\n  function stringifyRow(uint8[8] memory _array, string memory _delimiter) internal pure returns (string memory) {\\n    string memory output = string(abi.encodePacked(\\n      '<tspan x=\\\"153\\\">',toString8(_array[0]),'</tspan>',_delimiter,\\n      '<tspan x=\\\"198\\\">',toString8(_array[1]),'</tspan>',_delimiter,\\n      '<tspan x=\\\"243\\\">',toString8(_array[2]),'</tspan>',_delimiter\\n    ));\\n\\n    output = string(abi.encodePacked(\\n      output,\\n      '<tspan x=\\\"288\\\">',toString8(_array[3]),'</tspan>',_delimiter,\\n      '<tspan x=\\\"333\\\">',toString8(_array[4]),'</tspan>',_delimiter,\\n      '<tspan x=\\\"378\\\">',toString8(_array[5]),'</tspan>',_delimiter\\n    ));\\n\\n    return string(abi.encodePacked(\\n      output,\\n      '<tspan x=\\\"423\\\">',toString8(_array[6]),'</tspan>',_delimiter,\\n      '<tspan x=\\\"468\\\">',toString8(_array[7]),'</tspan>',_delimiter\\n    ));\\n  }\\n\\n  /** @notice Compares two strings\\n    * @param  _a First string to compare\\n    * @param  _b Second string to compare\\n    * @return True if equal, false if not\\n    */\\n  function compareStrings(string memory _a, string memory _b) public pure returns (bool) {\\n    return (keccak256(abi.encodePacked((_a))) == keccak256(abi.encodePacked((_b))));\\n  }\\n\\n\\n  /** @notice Returns a substring of the given string\\n    * @param  str The string\\n    * @param  startIndex Starting index determining the substring to return\\n    * @param  endIndex Ending index determining the substring to return\\n    * @return Substring parsed from the string\\n    */\\n  function substring(string memory str, uint startIndex, uint endIndex) public pure returns (string memory) {\\n      bytes memory strBytes = bytes(str);\\n      if(endIndex == 0){\\n        endIndex = strBytes.length;\\n      }\\n      bytes memory result = new bytes(endIndex-startIndex);\\n      for(uint i = startIndex; i < endIndex; i++) {\\n          result[i-startIndex] = strBytes[i];\\n      }\\n      return string(result);\\n  }\\n\\n\\n  /** @notice Returns a pseudorandom number from a string input\\n    * @param  input A string to seed the pseudorandom number generator\\n    * @return  A pseudorandom uint256 number based on the input string\\n    */\\n  function random(string memory input) internal pure returns (uint256) {\\n      return uint256(keccak256(abi.encodePacked(input)));\\n  }\\n\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {\r\n      \"/contracts/Helpers.sol\": {\r\n        \"Helpers\": \"0x30D432918c74193032C0CD03935B02a3e026B933\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"callBy\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nameDelimiter\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_index\",\"type\":\"uint8\"}],\"name\":\"ngram\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"pluckNGram\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerName\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNgrams\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Sacred","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}