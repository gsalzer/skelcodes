{"status":"1","message":"OK","result":[{"SourceCode":"{\"AbiDecoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\nimport \\\"./Strings.sol\\\";\\n\\nlibrary AbiDecoder {\\n  /**\\n   * @notice Extract all params from calldata given a list of param types and raw calldata bytes\\n   */\\n  function getParamsFromCalldata(\\n    string[] memory paramTypes,\\n    bytes calldata data\\n  ) public pure returns (bytes[] memory) {\\n    uint256 numberOfParams = paramTypes.length;\\n    bytes[] memory results = new bytes[](numberOfParams);\\n    for (uint256 paramIdx = 0; paramIdx \\u003c numberOfParams; paramIdx++) {\\n      string memory paramType = paramTypes[paramIdx];\\n      bytes memory param = getParamFromCalldata(data, paramType, paramIdx);\\n      results[paramIdx] = param;\\n    }\\n    return results;\\n  }\\n\\n  /**\\n   * @notice Extract param bytes given calldata, param type and param index\\n   */\\n  function getParamFromCalldata(\\n    bytes calldata data,\\n    string memory paramType,\\n    uint256 paramIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramsStartIdx = 0x04; // Start after method selector\\n    uint256 paramOffset = 0x20 * paramIdx;\\n    bytes memory paramDescriptorValue = bytes(\\n      data[paramsStartIdx + paramOffset:paramsStartIdx + paramOffset + 0x20]\\n    );\\n\\n    bool paramTypeIsStringOrBytes = Strings.stringsEqual(paramType, \\\"bytes\\\") ||\\n      Strings.stringsEqual(paramType, \\\"string\\\");\\n    bool paramTypeIsStringArrayOrBytesArray = Strings.stringsEqual(\\n      paramType,\\n      \\\"bytes[]\\\"\\n    ) || Strings.stringsEqual(paramType, \\\"string[]\\\");\\n    bool _paramTypeIsArray = paramTypeIsArray(paramType);\\n\\n    uint256 paramStartIdx = uint256(bytes32(paramDescriptorValue)) + 0x04;\\n    if (paramTypeIsStringOrBytes) {\\n      return extractParamForBytesType(data, paramStartIdx);\\n    } else if (paramTypeIsStringArrayOrBytesArray) {\\n      return extractParamForBytesArrayType(data, paramStartIdx);\\n    } else if (_paramTypeIsArray) {\\n      return extractParamForSimpleArray(data, paramStartIdx);\\n    } else {\\n      return paramDescriptorValue;\\n    }\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"bytes\\\" and \\\"string\\\" types given calldata and a param start index\\n   */\\n  function extractParamForBytesType(bytes calldata data, uint256 paramStartIdx)\\n    public\\n    pure\\n    returns (bytes memory)\\n  {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 bytesLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 bytesLength = uint256(bytesLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(bytesLengthBytes)\\n    );\\n    uint256 numberOfRowsOfBytes = (bytesLength / 32) + 1;\\n    for (uint256 rowIdx; rowIdx \\u003c numberOfRowsOfBytes; rowIdx++) {\\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\\n      dataToAdd = abi.encodePacked(\\n        dataToAdd,\\n        data[rowStartIdx:rowStartIdx + 0x20]\\n      );\\n    }\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"bytes[]\\\" and \\\"string[]\\\" types given calldata and a param start index\\n   */\\n  function extractParamForBytesArrayType(\\n    bytes calldata data,\\n    uint256 paramStartIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 arrayLength = uint256(arrayLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(arrayLengthBytes)\\n    );\\n    uint256 lastOffsetStartIdx = paramEndIdx + (0x20 * arrayLength) - 0x20;\\n    uint256 lastOffset = uint256(\\n      bytes32(data[lastOffsetStartIdx:lastOffsetStartIdx + 0x20])\\n    );\\n    bytes32 lastElementBytesLengthBytes = bytes32(\\n      data[paramEndIdx + lastOffset:paramEndIdx + lastOffset + 0x20]\\n    );\\n    uint256 lastElementBytesLength = uint256(lastElementBytesLengthBytes);\\n    uint256 numberOfRowsOfBytesForLastElement = (lastElementBytesLength / 32) +\\n      1;\\n    uint256 dataEndIdx = paramEndIdx +\\n      lastOffset +\\n      0x20 +\\n      (0x20 * numberOfRowsOfBytesForLastElement);\\n    dataToAdd = abi.encodePacked(dataToAdd, data[paramEndIdx:dataEndIdx]);\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"*[]\\\" types given calldata and a param start index, assuming each element is 32 bytes\\n   */\\n  function extractParamForSimpleArray(\\n    bytes calldata data,\\n    uint256 paramStartIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 arrayLength = uint256(arrayLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(arrayLengthBytes)\\n    );\\n    for (uint256 rowIdx; rowIdx \\u003c arrayLength; rowIdx++) {\\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\\n      dataToAdd = abi.encodePacked(\\n        dataToAdd,\\n        data[rowStartIdx:rowStartIdx + 0x20]\\n      );\\n    }\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Check to see if the last two characters of a string are \\\"[]\\\"\\n   */\\n  function paramTypeIsArray(string memory paramType)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    bytes32 lastTwoCharacters;\\n    assembly {\\n      let len := mload(paramType)\\n      lastTwoCharacters := mload(add(add(paramType, 0x20), sub(len, 2)))\\n    }\\n    return lastTwoCharacters == bytes32(bytes(\\\"[]\\\"));\\n  }\\n}\\n\"},\"Allowlist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./Introspection.sol\\\";\\n\\n/*******************************************************\\n *                      Interfaces\\n *******************************************************/\\ninterface IAllowlistFactory {\\n  function protocolOwnerAddressByOriginName(string memory originName)\\n    external\\n    view\\n    returns (address ownerAddress);\\n}\\n\\n/*******************************************************\\n *                      Core Logic\\n *******************************************************/\\ncontract Allowlist {\\n  /**\\n   * methodName: Name of the method to validate (ie. \\\"approve\\\")\\n   * paramTypes: Param types of the method to validate (ie. [\\\"address\\\", \\\"uint256\\\"])\\n   * requirements: Array of requirements, where a requirement is as follows:\\n   *    Element 0: Requirement type (ie. \\\"target\\\" or \\\"param\\\")\\n   *    Element 1: Method name of validation method (ie. \\\"isVaultToken\\\")\\n   *    Element 2: Index of param to test as a string. Only applicable where requirement type is \\\"param\\\" (ie. \\\"0\\\")\\n   */\\n  struct Condition {\\n    string methodName;\\n    string[] paramTypes;\\n    string[][] requirements;\\n    address implementationAddress;\\n  }\\n\\n  Condition[] public conditions; // Array of conditions per protocol (managed by protocol owner)\\n  string public protocolOriginName; // Domain name of protocol (ie. \\\"yearn.finance\\\")\\n  address public rootAllowlistAddress; // Address of root allowlist (parent/factory)\\n\\n  /**\\n   * Initialize the contract (this will only be called by proxy)\\n   */\\n  function initialize(string memory _protocolOriginName) public {\\n    require(\\n      rootAllowlistAddress == address(0),\\n      \\\"Contract is already initialized\\\"\\n    );\\n    rootAllowlistAddress = msg.sender;\\n    protocolOriginName = _protocolOriginName;\\n  }\\n\\n  /*******************************************************\\n   *                     Owner logic\\n   *******************************************************/\\n  modifier onlyOwner() {\\n    require(\\n      msg.sender == ownerAddress() || msg.sender == address(0),\\n      \\\"Caller is not the protocol owner\\\"\\n    );\\n    _;\\n  }\\n\\n  function ownerAddress() public view returns (address protcolOwnerAddress) {\\n    protcolOwnerAddress = IAllowlistFactory(rootAllowlistAddress)\\n      .protocolOwnerAddressByOriginName(protocolOriginName);\\n  }\\n\\n  /*******************************************************\\n   *                   Condition CRUD Logic\\n   *******************************************************/\\n  function addCondition(Condition memory condition) public onlyOwner {\\n    validateCondition(condition);\\n    conditions.push(condition);\\n  }\\n\\n  function addConditions(Condition[] memory _conditions) public onlyOwner {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = _conditions[conditionIdx];\\n      addCondition(condition);\\n    }\\n  }\\n\\n  function addConditionWithoutValidation(Condition memory condition)\\n    public\\n    onlyOwner\\n  {\\n    conditions.push(condition);\\n  }\\n\\n  function addConditionsWithoutValidation(Condition[] memory _conditions)\\n    public\\n    onlyOwner\\n  {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = _conditions[conditionIdx];\\n      addCondition(condition);\\n    }\\n  }\\n\\n  function deleteCondition(uint256 conditionIdx) public onlyOwner {\\n    Condition memory lastCondition = conditions[conditions.length - 1];\\n    conditions[conditionIdx] = lastCondition;\\n    conditions.pop();\\n  }\\n\\n  function deleteAllConditions() public onlyOwner {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c conditions.length;\\n      conditionIdx++\\n    ) {\\n      conditions.pop();\\n    }\\n  }\\n\\n  function updateCondition(uint256 conditionIdx, Condition memory condition)\\n    public\\n    onlyOwner\\n  {\\n    deleteCondition(conditionIdx);\\n    addCondition(condition);\\n  }\\n\\n  function conditionsList() public view returns (Condition[] memory test) {\\n    Condition[] memory _conditions = new Condition[](conditions.length);\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c conditions.length;\\n      conditionIdx++\\n    ) {\\n      _conditions[conditionIdx] = conditions[conditionIdx];\\n    }\\n    return _conditions;\\n  }\\n\\n  function conditionsLength() public view returns (uint256) {\\n    return conditions.length;\\n  }\\n\\n  /*******************************************************\\n   *                Condition Validation Logic\\n   *******************************************************/\\n  function validateCondition(Condition memory condition) public view {\\n    string[][] memory requirements = condition.requirements;\\n\\n    for (\\n      uint256 requirementIdx;\\n      requirementIdx \\u003c requirements.length;\\n      requirementIdx++\\n    ) {\\n      string[] memory requirement = requirements[requirementIdx];\\n      string memory requirementType = requirement[0];\\n      string memory requirementValidationMethod = requirement[1];\\n      string memory methodSignature;\\n      string memory paramType;\\n      bool requirementTypeIsTarget = Strings.stringsEqual(\\n        requirementType,\\n        \\\"target\\\"\\n      );\\n      bool requirementTypeIsParam = Strings.stringsEqual(\\n        requirementType,\\n        \\\"param\\\"\\n      );\\n      if (requirementTypeIsTarget) {\\n        require(\\n          requirement.length == 2,\\n          \\\"Requirement length must be equal to 2\\\"\\n        );\\n        methodSignature = string(\\n          abi.encodePacked(requirementValidationMethod, \\\"(address)\\\")\\n        );\\n      } else if (requirementTypeIsParam) {\\n        require(\\n          requirement.length == 3,\\n          \\\"Requirement length must be equal to 3\\\"\\n        );\\n        uint256 paramIdx = Strings.atoi(requirement[2], 10);\\n        require(\\n          paramIdx \\u003c= condition.paramTypes.length - 1,\\n          \\\"Requirement parameter index is out of range\\\"\\n        );\\n        paramType = condition.paramTypes[paramIdx];\\n        methodSignature = string(\\n          abi.encodePacked(requirementValidationMethod, \\\"(\\\", paramType, \\\")\\\")\\n        );\\n      } else {\\n        revert(\\\"Unsupported requirement type\\\");\\n      }\\n\\n      address implementationAddress = condition.implementationAddress;\\n      require(\\n        implementationAddress != address(0),\\n        \\\"Implementation address is not set\\\"\\n      );\\n\\n      bool implementsInterface = Introspection.implementsMethodSignature(\\n        implementationAddress,\\n        methodSignature\\n      );\\n      require(\\n        implementsInterface == true,\\n        \\\"Implementation does not implement method selector\\\"\\n      );\\n    }\\n  }\\n\\n  function validateConditions() public view {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = conditions[conditionIdx];\\n      validateCondition(condition);\\n    }\\n  }\\n\\n  function implementationValid() public view returns (bool) {\\n    (bool success, ) = address(this).staticcall(\\n      abi.encodeWithSignature(\\\"validateConditions()\\\")\\n    );\\n    return success;\\n  }\\n}\\n\"},\"AllowlistFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./AbiDecoder.sol\\\";\\nimport \\\"./EnsHelper.sol\\\";\\nimport \\\"./Allowlist.sol\\\";\\n\\n/*******************************************************\\n *                      Interfaces\\n *******************************************************/\\ninterface Registry {\\n  function isRegistered(address) external view returns (bool);\\n}\\n\\ninterface IAllowlist {\\n  function implementationAddress() external view returns (address);\\n\\n  function conditionsLength() external view returns (uint256);\\n\\n  function initialize(string memory) external;\\n\\n  function conditionsList()\\n    external\\n    view\\n    returns (Allowlist.Condition[] memory);\\n\\n  function implementationValid() external view returns (bool);\\n}\\n\\n/*******************************************************\\n *                     Main Contract Logic\\n *******************************************************/\\ncontract AllowlistFactory {\\n  /**\\n   * @notice Protocol registration\\n   */\\n  address private allowlistTemplateAddress;\\n  string[] public registeredProtocols; // Array of all protocols which have successfully completed registration\\n  mapping(string =\\u003e bool) public registeredProtocol; // Determine whether or not a specific protocol is registered\\n  mapping(string =\\u003e address) public allowlistAddressByOriginName; // Address of protocol specific allowlist\\n\\n  constructor(address _allowlistTemplateAddress) {\\n    allowlistTemplateAddress = _allowlistTemplateAddress;\\n  }\\n\\n  /**\\n   * @notice Determine protocol onwer address given an origin name\\n   * @param originName is the domain name for a protocol (ie. \\\"yearn.finance\\\")\\n   * @return ownerAddress Returns the address of the domain controller if the domain is registered on ENS\\n   */\\n  function protocolOwnerAddressByOriginName(string memory originName)\\n    public\\n    view\\n    returns (address ownerAddress)\\n  {\\n    ownerAddress = EnsHelper.ownerAddressByName(originName);\\n  }\\n\\n  /**\\n   * @notice Begin protocol registration\\n   * @param originName is the domain name for a protocol (ie. \\\"yearn.finance\\\")\\n   * @dev Only valid protocol owners can begin registration\\n   * @dev Beginning registration generates a smart contract each protocol can use\\n   *      to manage their conditions and validation implementation logic\\n   * @dev Only fully registered protocols appear on the registration list\\n   */\\n  function startProtocolRegistration(string memory originName) public {\\n    address protocolOwnerAddress = protocolOwnerAddressByOriginName(originName);\\n    if (protocolOwnerAddress != msg.sender) {\\n      revert(\\\"Only protocol owners can register protocols\\\");\\n    }\\n\\n    address allowlistAddress = cloneAllowlist();\\n    IAllowlist(allowlistAddress).initialize(originName);\\n    allowlistAddressByOriginName[originName] = allowlistAddress;\\n  }\\n\\n  /**\\n   * @notice Clones the allowlist using EIP-1167 template during new protocol registration\\n   */\\n  function cloneAllowlist() internal returns (address allowlistAddress) {\\n    bytes20 templateAddress = bytes20(allowlistTemplateAddress);\\n    assembly {\\n      let clone := mload(0x40)\\n      mstore(\\n        clone,\\n        0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n      )\\n      mstore(add(clone, 0x14), templateAddress)\\n      mstore(\\n        add(clone, 0x28),\\n        0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n      )\\n      allowlistAddress := create(0, clone, 0x37)\\n    }\\n  }\\n\\n  /**\\n   * @notice Finish protocol registration\\n   * @param originName is the domain name for a protocol (ie. \\\"yearn.finance\\\")\\n   * @dev In order to fully register a protocol the protocol must have a\\n   *      valid implementation contract and at least one condition\\n   * @dev Fully registered protocols are added to the registration list\\n   */\\n  function finishProtocolRegistration(string memory originName) public {\\n    address allowListAddress = allowlistAddressByOriginName[originName];\\n    IAllowlist allowList = IAllowlist(allowListAddress);\\n\\n    uint256 conditionsLength = allowList.conditionsLength();\\n    if (conditionsLength == 0) {\\n      revert(\\\"Must have at least one condition to complete registration\\\");\\n    }\\n\\n    bool implementationValid = allowList.implementationValid();\\n    if (!implementationValid) {\\n      revert(\\\"Protocol implementation does not satisfy all conditions\\\");\\n    }\\n\\n    registeredProtocols.push(originName);\\n    registeredProtocol[originName] = true;\\n  }\\n\\n  /**\\n   * @notice Return a list of fully registered protocols\\n   */\\n  function registeredProtocolsList() public view returns (string[] memory) {\\n    return registeredProtocols;\\n  }\\n\\n  /**\\n   * @notice Calculate a method signature given a condition\\n   * @param condition The condition from which to generate the signature\\n   * @return signature The method signature in string format (ie. \\\"approve(address,uint256)\\\")\\n   */\\n  function methodSignatureByCondition(Allowlist.Condition memory condition)\\n    public\\n    pure\\n    returns (string memory signature)\\n  {\\n    bytes memory signatureBytes = abi.encodePacked(condition.methodName, \\\"(\\\");\\n    for (uint256 paramIdx; paramIdx \\u003c condition.paramTypes.length; paramIdx++) {\\n      signatureBytes = abi.encodePacked(\\n        signatureBytes,\\n        condition.paramTypes[paramIdx]\\n      );\\n      if (paramIdx + 1 \\u003c condition.paramTypes.length) {\\n        signatureBytes = abi.encodePacked(signatureBytes, \\\",\\\");\\n      }\\n    }\\n    signatureBytes = abi.encodePacked(signatureBytes, \\\")\\\");\\n    signature = string(signatureBytes);\\n  }\\n\\n  /**\\n   * @notice Check target validity\\n   * @param implementationAddress The address the validation method will be executed against\\n   * @param targetAddress The target address to validate\\n   * @param requirementValidationMethod The method to execute\\n   * @return targetValid Returns true if the target is valid and false otherwise\\n   * @dev If \\\"requirementValidationMethod\\\" is \\\"isValidVaultToken\\\" and target address is usdc\\n   *      the validation check will look like this: usdc.isValidVaultToken(targetAddress),\\n   *      where the result of the validation method is expected to return a bool\\n   */\\n  function checkTarget(\\n    address implementationAddress,\\n    address targetAddress,\\n    string memory requirementValidationMethod\\n  ) public view returns (bool targetValid) {\\n    string memory methodSignature = string(\\n      abi.encodePacked(requirementValidationMethod, \\\"(address)\\\")\\n    );\\n    (, bytes memory data) = address(implementationAddress).staticcall(\\n      abi.encodeWithSignature(methodSignature, targetAddress)\\n    );\\n    targetValid = abi.decode(data, (bool));\\n  }\\n\\n  /**\\n   * @notice Check method selector validity\\n   * @param data Raw input calldata (we will extract the 4-byte selector\\n   *             from the beginning of the calldata)\\n   * @param condition The condition struct to check (we generate the complete\\n   *        method selector using condition.methodName and condition.paramTypes)\\n   * @return methodSelectorValid Returns true if the method selector is valid and false otherwise\\n   */\\n  function checkMethodSelector(\\n    bytes calldata data,\\n    Allowlist.Condition memory condition\\n  ) public pure returns (bool methodSelectorValid) {\\n    string memory methodSignature = methodSignatureByCondition(condition);\\n    bytes4 methodSelectorBySignature = bytes4(\\n      keccak256(bytes(methodSignature))\\n    );\\n    bytes4 methodSelectorByCalldata = bytes4(data[0:4]);\\n    methodSelectorValid = methodSelectorBySignature == methodSelectorByCalldata;\\n  }\\n\\n  /**\\n   * @notice Check an individual method param\\u0027s validity\\n   * @param implementationAddress The address the validation method will be executed against\\n   * @param requirement The specific requirement (of type \\\"param\\\") to check (ie. [\\\"param\\\", \\\"isVault\\\", \\\"0\\\"])\\n   * @dev A condition may have multiple requirements, all of which must be true\\n   * @dev The middle element of a requirement is the requirement validation method\\n   * @dev The last element of a requirement is the parameter index to validate against\\n   * @param condition The entire condition struct to check the param against\\n   * @param data Raw input calldata for the original method call\\n   * @return Returns true if the param is valid, false if not\\n   */\\n  function checkParam(\\n    address implementationAddress,\\n    string[] memory requirement,\\n    Allowlist.Condition memory condition,\\n    bytes calldata data\\n  ) public view returns (bool) {\\n    uint256 paramIdx = Strings.atoi(requirement[2], 10);\\n    string memory paramType = condition.paramTypes[paramIdx];\\n    bytes memory paramCalldata = AbiDecoder.getParamFromCalldata(\\n      data,\\n      paramType,\\n      paramIdx\\n    );\\n    string memory methodSignature = string(\\n      abi.encodePacked(requirement[1], \\\"(\\\", paramType, \\\")\\\")\\n    );\\n    bytes memory encodedCalldata = abi.encodePacked(\\n      bytes4(keccak256(bytes(methodSignature))),\\n      paramCalldata\\n    );\\n    bool success;\\n    bytes memory resultData;\\n    (success, resultData) = address(implementationAddress).staticcall(\\n      encodedCalldata\\n    );\\n    if (success) {\\n      return abi.decode(resultData, (bool));\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @notice Test a target address and calldata against a specific condition and implementation\\n   * @param condition The condition to test\\n   * @param targetAddress Target address of the original method call\\n   * @param data Calldata of the original methodcall\\n   * @return Returns true if the condition passes and false if not\\n   * @dev The condition check is comprised of 3 parts:\\n          - Method selector check (to make sure the calldata method selector matches the condition method selector)\\n          - Target check (to make sure the target is valid)\\n          - Param check (to make sure the specified param is valid)\\n   */\\n  function testCondition(\\n    Allowlist.Condition memory condition,\\n    address targetAddress,\\n    bytes calldata data\\n  ) public view returns (bool) {\\n    string[][] memory requirements = condition.requirements;\\n    address implementationAddress = condition.implementationAddress;\\n    for (\\n      uint256 requirementIdx;\\n      requirementIdx \\u003c requirements.length;\\n      requirementIdx++\\n    ) {\\n      string[] memory requirement = requirements[requirementIdx];\\n      string memory requirementType = requirement[0];\\n      string memory requirementValidationMethod = requirement[1];\\n      if (!checkMethodSelector(data, condition)) {\\n        return false;\\n      }\\n      if (Strings.stringsEqual(requirementType, \\\"target\\\")) {\\n        bool targetValid = checkTarget(\\n          implementationAddress,\\n          targetAddress,\\n          requirementValidationMethod\\n        );\\n        if (!targetValid) {\\n          return false;\\n        }\\n      } else if (Strings.stringsEqual(requirementType, \\\"param\\\")) {\\n        bool paramValid = checkParam(\\n          implementationAddress,\\n          requirement,\\n          condition,\\n          data\\n        );\\n        if (!paramValid) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Test target address and calldata against all stored protocol conditions\\n   * @dev This is done to determine whether or not the target address and calldata are valid and whitelisted\\n   * @dev This is the primary method that should be called by integrators\\n   * @return Returns true if the check is successful and false if not\\n   */\\n  function validateCalldata(\\n    string memory originName,\\n    address targetAddress,\\n    bytes calldata data\\n  ) public view returns (bool) {\\n    Allowlist.Condition[] memory _conditions = conditionsByOriginName(\\n      originName\\n    );\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditions.length;\\n      conditionIdx++\\n    ) {\\n      Allowlist.Condition memory condition = _conditions[conditionIdx];\\n      bool conditionPassed = testCondition(condition, targetAddress, data);\\n      if (conditionPassed) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @notice Fetch a list of conditions given a protocol origin name\\n   * @param originName is the domain name for a protocol (ie. \\\"yearn.finance\\\")\\n   * @return Returns an array of conditions\\n   */\\n  function conditionsByOriginName(string memory originName)\\n    public\\n    view\\n    returns (Allowlist.Condition[] memory)\\n  {\\n    address allowlistAddress = allowlistAddressByOriginName[originName];\\n    Allowlist.Condition[] memory _conditions = IAllowlist(allowlistAddress)\\n      .conditionsList();\\n    return _conditions;\\n  }\\n}\\n\"},\"EnsHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\ninterface IEnsRegistry {\\n  function resolver(bytes32 node) external view returns (address);\\n\\n  function owner(bytes32 node) external view returns (address);\\n}\\n\\ninterface IEnsResolver {\\n  function addr(bytes32 node) external view returns (address);\\n}\\n\\ninterface IStringSplit {\\n  function splitStringByDeliminator(\\n    string memory input,\\n    string memory deliminator\\n  ) external view returns (string[] memory);\\n}\\n\\nlibrary EnsHelper {\\n  address public constant registryAddress =\\n    0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;\\n  address private constant splitStringAddress =\\n    0x1C0EeEF670d82498F7547062Aac7eE2143eC52ff;\\n\\n  function resolvedAddressByNamehash(bytes32 namehash)\\n    public\\n    view\\n    returns (address resolvedAddress)\\n  {\\n    address resolverAddress = resolverAddressByNamehash(namehash);\\n    resolvedAddress = IEnsResolver(resolverAddress).addr(namehash);\\n  }\\n\\n  function resolvedAddressByName(string memory name)\\n    public\\n    view\\n    returns (address resolvedAddress)\\n  {\\n    bytes32 namehash = namehashByName(name);\\n    resolvedAddress = resolvedAddressByNamehash(namehash);\\n  }\\n\\n  function resolverAddressByNamehash(bytes32 namehash)\\n    public\\n    view\\n    returns (address resolverAddress)\\n  {\\n    resolverAddress = IEnsRegistry(registryAddress).resolver(namehash);\\n  }\\n\\n  function resolverAddressByName(string memory name)\\n    public\\n    view\\n    returns (address resolverAddress)\\n  {\\n    bytes32 namehash = namehashByName(name);\\n    resolverAddress = resolverAddressByNamehash(namehash);\\n  }\\n\\n  function namehashByName(string memory name)\\n    public\\n    view\\n    returns (bytes32 namehash)\\n  {\\n    string[] memory parts = IStringSplit(splitStringAddress)\\n      .splitStringByDeliminator(name, \\\".\\\");\\n    for (uint256 partIdx = parts.length - 1; partIdx \\u003e= 0; partIdx--) {\\n      string memory part = parts[partIdx];\\n      namehash = keccak256(\\n        abi.encodePacked(namehash, keccak256(abi.encodePacked(bytes(part))))\\n      );\\n      if (partIdx == 0) {\\n        break;\\n      }\\n    }\\n  }\\n\\n  function ownerAddressByNamehash(bytes32 namehash)\\n    public\\n    view\\n    returns (address ownerAddress)\\n  {\\n    ownerAddress = IEnsRegistry(registryAddress).owner(namehash);\\n  }\\n\\n  function ownerAddressByName(string memory name)\\n    public\\n    view\\n    returns (address ownerAddress)\\n  {\\n    bytes32 namehash = namehashByName(name);\\n    ownerAddress = IEnsRegistry(registryAddress).owner(namehash);\\n  }\\n}\\n\"},\"Introspection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary Introspection {\\n  // function implementsMethodNameAndParamTypes(string memory methodName, string[])\\n  function implementsMethodSignature(address _address, string memory _signature)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    bytes4 _selector = bytes4(keccak256(bytes(_signature)));\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_address)\\n    }\\n    bytes memory code = new bytes(contractSize);\\n    assembly {\\n      extcodecopy(_address, add(code, 0x20), 0, contractSize)\\n    }\\n    uint256 ptr = 0;\\n    while (ptr \\u003c contractSize) {\\n      // PUSH4 0x000000 (selector)\\n      if (code[ptr] == 0x63) {\\n        bytes memory selectorBytes = new bytes(64);\\n        selectorBytes[0] = code[ptr + 1];\\n        selectorBytes[1] = code[ptr + 2];\\n        selectorBytes[2] = code[ptr + 3];\\n        selectorBytes[3] = code[ptr + 4];\\n        bytes4 selector = abi.decode(selectorBytes, (bytes4));\\n        if (selector == _selector) {\\n          return true;\\n        }\\n      }\\n      ptr++;\\n    }\\n    return false;\\n  }\\n\\n  function implementsInterface(address _address, string[] memory _interface)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    for (uint256 methodIdx = 0; methodIdx \\u003c _interface.length; methodIdx++) {\\n      string memory method = _interface[methodIdx];\\n      bool methodIsImplemented = implementsMethodSignature(_address, method);\\n      if (!methodIsImplemented) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary Strings {\\n  /**\\n   * @notice Search for a needle in a haystack\\n   * @param haystack The string to search\\n   * @param needle The string to search for\\n   */\\n  function stringStartsWith(string memory haystack, string memory needle)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    return indexOfStringInString(needle, haystack) == 0;\\n  }\\n\\n  /**\\n   * @notice Case insensitive string search\\n   * @param needle The string to search for\\n   * @param haystack The string to search\\n   * @return Returns -1 if no match is found, otherwise returns the index of the match\\n   */\\n  function indexOfStringInString(string memory needle, string memory haystack)\\n    public\\n    pure\\n    returns (int256)\\n  {\\n    bytes memory _needle = bytes(needle);\\n    bytes memory _haystack = bytes(haystack);\\n    if (_haystack.length \\u003c _needle.length) {\\n      return -1;\\n    }\\n    bool _match;\\n    for (uint256 haystackIdx; haystackIdx \\u003c _haystack.length; haystackIdx++) {\\n      for (uint256 needleIdx; needleIdx \\u003c _needle.length; needleIdx++) {\\n        uint8 needleChar = uint8(_needle[needleIdx]);\\n        if (haystackIdx + needleIdx \\u003e= _haystack.length) {\\n          return -1;\\n        }\\n        uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\\n        if (needleChar == haystackChar) {\\n          _match = true;\\n          if (needleIdx == _needle.length - 1) {\\n            return int256(haystackIdx);\\n          }\\n        } else {\\n          _match = false;\\n          break;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  /**\\n   * @notice Check to see if two strings are exactly equal\\n   */\\n  function stringsEqual(string memory input1, string memory input2)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    uint256 input1Length = bytes(input1).length;\\n    uint256 input2Length = bytes(input2).length;\\n    uint256 maxLength;\\n    if (input1Length \\u003e input2Length) {\\n      maxLength = input1Length;\\n    } else {\\n      maxLength = input2Length;\\n    }\\n    uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\\n    bytes32 input1Bytes32;\\n    bytes32 input2Bytes32;\\n    for (uint256 rowIdx; rowIdx \\u003c numberOfRowsToCompare; rowIdx++) {\\n      uint256 offset = 0x20 * (rowIdx + 1);\\n      assembly {\\n        input1Bytes32 := mload(add(input1, offset))\\n        input2Bytes32 := mload(add(input2, offset))\\n      }\\n      if (input1Bytes32 != input2Bytes32) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  function atoi(string memory a, uint8 base) public pure returns (uint256 i) {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    bytes memory buf = bytes(a);\\n    for (uint256 p = 0; p \\u003c buf.length; p++) {\\n      uint8 digit = uint8(buf[p]) - 0x30;\\n      if (digit \\u003e 10) {\\n        digit -= 7;\\n      }\\n      require(digit \\u003c base);\\n      i *= base;\\n      i += digit;\\n    }\\n    return i;\\n  }\\n\\n  function itoa(uint256 i, uint8 base) public pure returns (string memory a) {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    if (i == 0) {\\n      return \\\"0\\\";\\n    }\\n    bytes memory buf = new bytes(256);\\n    uint256 p = 0;\\n    while (i \\u003e 0) {\\n      uint8 digit = uint8(i % base);\\n      uint8 ascii = digit + 0x30;\\n      if (digit \\u003e 9) {\\n        ascii += 7;\\n      }\\n      buf[p++] = bytes1(ascii);\\n      i /= base;\\n    }\\n    uint256 length = p;\\n    for (p = 0; p \\u003c length / 2; p++) {\\n      buf[p] ^= buf[length - 1 - p];\\n      buf[length - 1 - p] ^= buf[p];\\n      buf[p] ^= buf[length - 1 - p];\\n    }\\n    return string(buf);\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allowlistTemplateAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"allowlistAddressByOriginName\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"},{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"internalType\":\"struct Allowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"}],\"name\":\"checkMethodSelector\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"methodSelectorValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"requirement\",\"type\":\"string[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"},{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"internalType\":\"struct Allowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"checkParam\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"requirementValidationMethod\",\"type\":\"string\"}],\"name\":\"checkTarget\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"targetValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"originName\",\"type\":\"string\"}],\"name\":\"conditionsByOriginName\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"},{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"internalType\":\"struct Allowlist.Condition[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"originName\",\"type\":\"string\"}],\"name\":\"finishProtocolRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"},{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"internalType\":\"struct Allowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"}],\"name\":\"methodSignatureByCondition\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"originName\",\"type\":\"string\"}],\"name\":\"protocolOwnerAddressByOriginName\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"registeredProtocol\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredProtocols\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registeredProtocolsList\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"originName\",\"type\":\"string\"}],\"name\":\"startProtocolRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"},{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"internalType\":\"struct Allowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"testCondition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"originName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"validateCalldata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AllowlistFactory","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c4ed8de23884db99f3c04c1869a1e3380f2dcf04","EVMVersion":"Default","Library":"Strings:dbedc4ee481be454dc3ecd2f9b00e9315467a483;AbiDecoder:62627154d5ef4c3a2aa7fd1cadbd4425596ac74d;EnsHelper:7d33110619e8f95f12a750f21a08b8c7cfb864e1","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4b59200a8bed81f92aa862d312eee23fe395cd58d30dd17bd6892afeb204069b"}]}