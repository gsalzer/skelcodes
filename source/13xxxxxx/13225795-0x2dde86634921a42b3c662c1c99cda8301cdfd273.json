{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/farm/MagicPool2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n *Submitted for verification at arbiscan.io on 2021-09-08\\n */\\n\\n//SPDX-License-Identifier: MIT\\n\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\n\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'Ownable: caller is not the owner');\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(\\n            newOwner != address(0),\\n            'Ownable: new owner is the zero address'\\n        );\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ncontract StakedTokenWrapper {\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) private _balances;\\n    IERC20 public stakedToken;\\n\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    string constant _transferErrorMessage = 'staked token transfer failed';\\n\\n    function stakeFor(address forWhom, uint128 amount) public payable virtual {\\n        IERC20 st = stakedToken;\\n        if (st == IERC20(address(0))) {\\n            //eth\\n            unchecked {\\n                totalSupply += msg.value;\\n                _balances[forWhom] += msg.value;\\n            }\\n        } else {\\n            require(msg.value == 0, 'non-zero eth');\\n            require(amount > 0, 'Cannot stake 0');\\n            require(\\n                st.transferFrom(msg.sender, address(this), amount),\\n                _transferErrorMessage\\n            );\\n            unchecked {\\n                totalSupply += amount;\\n                _balances[forWhom] += amount;\\n            }\\n        }\\n        emit Staked(forWhom, amount);\\n    }\\n\\n    function withdraw(uint128 amount) public virtual {\\n        require(amount <= _balances[msg.sender], 'withdraw: balance is lower');\\n        unchecked {\\n            _balances[msg.sender] -= amount;\\n            totalSupply = totalSupply - amount;\\n        }\\n        IERC20 st = stakedToken;\\n        if (st == IERC20(address(0))) {\\n            //eth\\n            (bool success, ) = msg.sender.call{ value: amount }('');\\n            require(success, 'eth transfer failure');\\n        } else {\\n            require(\\n                stakedToken.transfer(msg.sender, amount),\\n                _transferErrorMessage\\n            );\\n        }\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n}\\n\\ncontract MagicRewards is StakedTokenWrapper, Ownable {\\n    IERC20 public rewardToken;\\n    uint256 public rewardRate;\\n    uint64 public periodFinish;\\n    uint64 public lastUpdateTime;\\n    uint128 public rewardPerTokenStored;\\n    struct UserRewards {\\n        uint128 userRewardPerTokenPaid;\\n        uint128 rewards;\\n    }\\n    mapping(address => UserRewards) public userRewards;\\n\\n    event RewardAdded(uint256 reward);\\n    event RewardPaid(address indexed user, uint256 reward);\\n\\n    constructor(IERC20 _rewardToken, IERC20 _stakedToken) {\\n        rewardToken = _rewardToken;\\n        stakedToken = _stakedToken;\\n    }\\n\\n    modifier updateReward(address account) {\\n        uint128 _rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        rewardPerTokenStored = _rewardPerTokenStored;\\n        userRewards[account].rewards = earned(account);\\n        userRewards[account].userRewardPerTokenPaid = _rewardPerTokenStored;\\n        _;\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint64) {\\n        uint64 blockTimestamp = uint64(block.timestamp);\\n        return blockTimestamp < periodFinish ? blockTimestamp : periodFinish;\\n    }\\n\\n    function rewardPerToken() public view returns (uint128) {\\n        uint256 totalStakedSupply = totalSupply;\\n        if (totalStakedSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        unchecked {\\n            uint256 rewardDuration = lastTimeRewardApplicable() -\\n                lastUpdateTime;\\n            return\\n                uint128(\\n                    rewardPerTokenStored +\\n                        (rewardDuration * rewardRate * 1e18) /\\n                        totalStakedSupply\\n                );\\n        }\\n    }\\n\\n    function earned(address account) public view returns (uint128) {\\n        unchecked {\\n            return\\n                uint128(\\n                    (balanceOf(account) *\\n                        (rewardPerToken() -\\n                            userRewards[account].userRewardPerTokenPaid)) /\\n                        1e18 +\\n                        userRewards[account].rewards\\n                );\\n        }\\n    }\\n\\n    function stake(uint128 amount) external payable {\\n        stakeFor(msg.sender, amount);\\n    }\\n\\n    function stakeFor(address forWhom, uint128 amount)\\n        public\\n        payable\\n        override\\n        updateReward(forWhom)\\n    {\\n        super.stakeFor(forWhom, amount);\\n    }\\n\\n    function withdraw(uint128 amount) public override updateReward(msg.sender) {\\n        super.withdraw(amount);\\n    }\\n\\n    function exit() external {\\n        getReward();\\n        withdraw(uint128(balanceOf(msg.sender)));\\n    }\\n\\n    function getReward() public updateReward(msg.sender) {\\n        uint256 reward = earned(msg.sender);\\n        if (reward > 0) {\\n            userRewards[msg.sender].rewards = 0;\\n            require(\\n                rewardToken.transfer(msg.sender, reward),\\n                'reward transfer failed'\\n            );\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function setRewardParams(uint128 reward, uint64 duration)\\n        external\\n        onlyOwner\\n    {\\n        unchecked {\\n            require(reward > 0);\\n            rewardPerTokenStored = rewardPerToken();\\n            uint64 blockTimestamp = uint64(block.timestamp);\\n            uint256 maxRewardSupply = rewardToken.balanceOf(address(this));\\n            if (rewardToken == stakedToken) maxRewardSupply -= totalSupply;\\n            uint256 leftover = 0;\\n            if (blockTimestamp >= periodFinish) {\\n                rewardRate = reward / duration;\\n            } else {\\n                uint256 remaining = periodFinish - blockTimestamp;\\n                leftover = remaining * rewardRate;\\n                rewardRate = (reward + leftover) / duration;\\n            }\\n            require(reward + leftover <= maxRewardSupply, 'not enough tokens');\\n            lastUpdateTime = blockTimestamp;\\n            periodFinish = blockTimestamp + duration;\\n            emit RewardAdded(reward);\\n        }\\n    }\\n\\n    function withdrawReward() external onlyOwner {\\n        uint256 rewardSupply = rewardToken.balanceOf(address(this));\\n        //ensure funds staked by users can't be transferred out\\n        if (rewardToken == stakedToken) rewardSupply -= totalSupply;\\n        require(rewardToken.transfer(msg.sender, rewardSupply));\\n        rewardRate = 0;\\n        periodFinish = uint64(block.timestamp);\\n    }\\n}\\n\\n/*\\n   ____            __   __        __   _\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\n     /___/\\n\\n* Synthetix: YFIRewards.sol\\n*\\n* Docs: https://docs.synthetix.io/\\n*\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2020 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_stakedToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"reward\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"}],\"name\":\"setRewardParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forWhom\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewards\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"userRewardPerTokenPaid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rewards\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MagicRewards","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b0c7a3ba49c7a6eaba6cd4a96c55a1391070ac9a0000000000000000000000008c56ca4f7eb12a7c217bbe36cc427a9dcb66f590","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}