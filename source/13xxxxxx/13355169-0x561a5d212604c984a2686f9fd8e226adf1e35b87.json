{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LobsterGenome.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n* @title LobsterBeachClub interface\\n*/\\ninterface ILobsterBeachClub {\\n    function seedNumber() external view returns (uint256);\\n    function maxSupply() external view returns (uint256);\\n}\\n\\n/**\\n* @title LobsterGenome contract\\n* @dev Handles lobster traits, assets and constructing gene sequences\\n*/\\ncontract LobsterGenome is Ownable {\\n    // mapping of gene sequence to traits / rarities\\n    mapping(uint => uint16[]) public traits;\\n    // mapping of gene sequence to sum of all rarities\\n    mapping(uint => uint16) public sequenceToRarityTotals;\\n    // provenance record of images and metadata\\n    string public provenance;\\n    // list of gene sequences\\n    uint16[] sequences;\\n    // list of assets\\n    uint16[] assets;\\n    ILobsterBeachClub public lobsterBeachClub;\\n\\n    constructor(address lbcAddress) {\\n        setLobsterBeachClub(lbcAddress);\\n    }\\n\\n    function setLobsterBeachClub(address lbcAddress) public onlyOwner {\\n        lobsterBeachClub = ILobsterBeachClub(lbcAddress);\\n    }\\n\\n    function setProvenance(string memory _provenance) public onlyOwner {\\n        provenance = _provenance;\\n    }\\n\\n    /**\\n    * @dev reset traits and rarities\\n    */\\n    function resetTraits() public onlyOwner {\\n        for(uint i; i < sequences.length; i++) {\\n            delete traits[i];\\n            delete sequenceToRarityTotals[i];\\n        }\\n        delete sequences;\\n    }\\n\\n    /**\\n    * @dev set available traits and rarities at the same time\\n    * @dev example: [500, 500, 0, 100, 300, 600] sets two sequences separated by '0'\\n    *               [500, 500], [100, 300, 600] sequence 0 and 1, index is trait value is rarity\\n    */\\n    function setTraits(uint16[] memory rarities) public onlyOwner {\\n        require(rarities.length > 0, \\\"Rarities is empty, Use resetTraits() instead\\\");\\n        resetTraits();\\n        uint16 trait = 0;\\n        sequences.push(trait);\\n        for(uint i; i < rarities.length; i++) {\\n            uint16 rarity = rarities[i];\\n            if (rarity == 0) {\\n                trait++;\\n                sequences.push(trait);\\n            } else {\\n                traits[trait].push(rarity);\\n                sequenceToRarityTotals[trait] += rarity;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Returns the sequence for a given tokenId\\n    * @dev Deterministic based on tokenId and seedNumber from lobsterBeachClub\\n    * @dev One trait is selected and appended to sequence based on rarity\\n    * @dev Returns geneSequence of asset if tokenId is chosen for an asset\\n    */\\n    function getGeneSequence(uint256 tokenId) public view returns (uint256 _geneSequence) {\\n        uint256 assetOwned = getAssetOwned(tokenId);\\n        if (assetOwned != 0) {\\n            return assetOwned;\\n        }\\n        uint256 seedNumber = lobsterBeachClub.seedNumber();\\n        uint256 geneSequenceSeed = uint256(keccak256(abi.encode(seedNumber, tokenId)));\\n        uint256 geneSequence;\\n        for(uint i; i < sequences.length; i++) {\\n            uint16 sequence = sequences[i];\\n            uint16[] memory rarities = traits[sequence];\\n            uint256 sequenceRandomValue = uint256(keccak256(abi.encode(geneSequenceSeed, i)));\\n            uint256 sequenceRandomResult = (sequenceRandomValue % sequenceToRarityTotals[sequence]) + 1;\\n            uint16 rarityCount;\\n            uint resultingTrait;\\n            for(uint j; j < rarities.length; j++) {\\n                uint16 rarity = rarities[j];\\n                rarityCount += rarity;\\n                if (sequenceRandomResult <= rarityCount) {\\n                    resultingTrait = j;\\n                    break;\\n                }\\n            }\\n            geneSequence += 10**(3*sequence) * resultingTrait;\\n        }\\n        return geneSequence;\\n    }\\n\\n    /**\\n    * @dev Set geneSequences of assets available\\n    * @dev Used as 1 of 1s or 1 of Ns (N being same geneSequence repeated N times)\\n    */\\n    function setAssets(uint16[] memory _assets) public onlyOwner {\\n        uint256 maxSupply = lobsterBeachClub.maxSupply();\\n        require(_assets.length <= maxSupply, \\\"You cannot supply more assets than max supply\\\");\\n        for (uint i; i < _assets.length; i++) {\\n            require(_assets[i] > 0 && _assets[i] < 1000, \\\"Asset id must be between 1 and 999\\\");\\n        }\\n        assets = _assets;\\n    }\\n    \\n    /**\\n    * @dev Deterministically decides which tokenIds of maxSupply from lobsterBeachClub will receive each asset\\n    * @dev Determination is based on seedNumber\\n    * @dev To prevent from tokenHolders knowing which section of tokenIds are more likely to receive an asset\\n    *      the direction which assets are chosen from 0 or maxSupply is also deterministic on the seedNumber\\n    */\\n    function getAssetOwned(uint256 tokenId) public view returns (uint16 assetId) {\\n        uint256 maxSupply = lobsterBeachClub.maxSupply();\\n        uint256 seedNumber = lobsterBeachClub.seedNumber();\\n        uint256 totalDistance = maxSupply;\\n        uint256 direction = seedNumber % 2;\\n        for (uint i; i < assets.length; i++) {\\n            uint256 difference = totalDistance / (assets.length - i);\\n            uint256 assetSeed = uint256(keccak256(abi.encode(seedNumber, i)));\\n            uint256 distance = (assetSeed % difference) + 1;\\n            totalDistance -= distance;\\n            if ((direction == 0 && totalDistance == tokenId) || (direction == 1 && (maxSupply - totalDistance - 1 == tokenId))) {\\n                return assets[i];\\n            }\\n        }\\n        return 0;\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lbcAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getAssetOwned\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"assetId\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getGeneSequence\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_geneSequence\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lobsterBeachClub\",\"outputs\":[{\"internalType\":\"contract ILobsterBeachClub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"provenance\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sequenceToRarityTotals\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_assets\",\"type\":\"uint16[]\"}],\"name\":\"setAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lbcAddress\",\"type\":\"address\"}],\"name\":\"setLobsterBeachClub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_provenance\",\"type\":\"string\"}],\"name\":\"setProvenance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"rarities\",\"type\":\"uint16[]\"}],\"name\":\"setTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"traits\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LobsterGenome","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007032e0eb1f32e485e530710d9db5e98e175d8572","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}