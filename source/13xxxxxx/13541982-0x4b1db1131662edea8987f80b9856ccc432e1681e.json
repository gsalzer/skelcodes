{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/L2MintableERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"./lib/AddressSet.sol\\\";\\nimport \\\"./lib/Claimable.sol\\\";\\nimport \\\"./lib/Ownable.sol\\\";\\n\\nimport \\\"./thirdparty/erc165/ERC165.sol\\\";\\nimport \\\"./thirdparty/erc165/IERC165.sol\\\";\\n\\nimport \\\"./thirdparty/erc1155/Context.sol\\\";\\nimport \\\"./thirdparty/erc1155/ERC1155.sol\\\";\\nimport \\\"./thirdparty/erc1155/IERC1155.sol\\\";\\nimport \\\"./thirdparty/erc1155/IERC1155MetadataURI.sol\\\";\\nimport \\\"./thirdparty/erc1155/IERC1155Receiver.sol\\\";\\nimport \\\"./thirdparty/erc1155/SafeMath.sol\\\";\\n\\nimport \\\"./MintAuthorization.sol\\\";\\n\\ncontract L2MintableERC1155 is ERC1155, Claimable {\\n    event MintFromL2(address owner, uint256 id, uint256 amount, address minter);\\n\\n    string public name;\\n\\n    // Authorization for which addresses can mint tokens and add collections is\\n    // delegated to another contract.\\n    // TODO: (Loopring feedback) Make this field immutable when contract is upgradable\\n    MintAuthorization private authorization;\\n\\n    // The IPFS hash for each collection (these hashes represent a directory within\\n    // IPFS that contain one JSON file per edition in the collection).\\n    mapping(uint64 => string) private _ipfsHashes;\\n\\n    modifier onlyFromLayer2() {\\n        require(_msgSender() == authorization.layer2(), \\\"UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    modifier onlyMinter(address addr) {\\n        require(\\n            authorization.isActiveMinter(addr) ||\\n                authorization.isRetiredMinter(addr),\\n            \\\"NOT_MINTER\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyFromUpdater() {\\n        require(authorization.isUpdater(msg.sender), \\\"NOT_FROM_UPDATER\\\");\\n        _;\\n    }\\n\\n    // Prevent initialization of the implementation deployment.\\n    // (L2MintableERC1155Factory should be used to create usable instances.)\\n    constructor() {\\n        owner = 0x000000000000000000000000000000000000dEaD;\\n    }\\n\\n    // An init method is used instead of a constructor to allow use of the proxy\\n    // factory pattern. The init method can only be called once and should be\\n    // called within the factory.\\n    function init(\\n        address _owner,\\n        address _authorization,\\n        string memory _name\\n    ) public {\\n        require(owner == address(0), \\\"ALREADY_INITIALIZED\\\");\\n        require(_owner != address(0), \\\"OWNER_REQUIRED\\\");\\n\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n\\n        owner = _owner;\\n        name = _name;\\n        authorization = MintAuthorization(_authorization);\\n    }\\n\\n    // This function is called when an NFT minted on L2 is withdrawn from Loopring.\\n    // That means the NFTs were burned on L2 and now need to be minted on L1.\\n    // This function can only be called by the Loopring exchange.\\n    function mintFromL2(\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address minter,\\n        bytes calldata data\\n    ) external onlyFromLayer2 onlyMinter(minter) {\\n        _mint(to, tokenId, amount, data);\\n        emit MintFromL2(to, tokenId, amount, minter);\\n    }\\n\\n    // Allow only the owner to mint directly on L1\\n    // TODO: (Loopring feedback) Can be removed once contract is upgrabable\\n    function mint(\\n        address tokenId,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external onlyOwner {\\n        _mint(tokenId, id, amount, data);\\n    }\\n\\n    // All address that are currently authorized to mint NFTs on L2.\\n    function minters() public view returns (address[] memory) {\\n        return authorization.activeMinters();\\n    }\\n\\n    // Delegate authorization to a different contract (can be called by an owner to\\n    // \\\"eject\\\" from the GameStop ecosystem).\\n    // TODO: (Loopring feedback) Should be removed once contract is upgrabable\\n    function setAuthorization(address _authorization) external onlyOwner {\\n        authorization = MintAuthorization(_authorization);\\n    }\\n\\n    function uri(uint256 id) external view override returns (string memory) {\\n        // The layout of an ID is: 64 bit creator ID, 64 bits of flags, 64 bit\\n        // collection ID then 64 bit edition ID:\\n        uint64 collectionId = uint64(\\n            (id &\\n                0x00000000000000000000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\n                64\\n        );\\n        uint64 editionId = uint64(\\n            id &\\n                0x000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF\\n        );\\n\\n        string memory ipfsHash = _ipfsHashes[collectionId];\\n        require(bytes(ipfsHash).length != 0, \\\"NO_IPFS_BASE\\\");\\n\\n        return\\n            _appendStrings(\\n                \\\"ipfs://\\\",\\n                ipfsHash,\\n                \\\"/\\\",\\n                _uintToString(editionId),\\n                \\\".json\\\"\\n            );\\n    }\\n\\n    function setIpfsHash(uint64 collectionId, string memory ipfsHash)\\n        external\\n        onlyFromUpdater\\n    {\\n        string memory existingIpfsHash = _ipfsHashes[collectionId];\\n        require(bytes(existingIpfsHash).length == 0, \\\"IPFS_ALREADY_SET\\\");\\n        _ipfsHashes[collectionId] = ipfsHash;\\n    }\\n\\n    function getIpfsHash(uint64 collectionId)\\n        external\\n        view\\n        returns (string memory)\\n    {\\n        return _ipfsHashes[collectionId];\\n    }\\n\\n    function _appendStrings(\\n        string memory a,\\n        string memory b,\\n        string memory c,\\n        string memory d,\\n        string memory e\\n    ) private pure returns (string memory) {\\n        return string(abi.encodePacked(a, b, c, d, e));\\n    }\\n\\n    // TODO: (Loopring feedback) Is there a library that implements this?\\n    function _uintToString(uint256 input)\\n        private\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (input == 0) {\\n            return \\\"0\\\";\\n        }\\n\\n        uint256 i = input;\\n        uint256 length = 0;\\n        while (i != 0) {\\n            length++;\\n            i /= 10;\\n        }\\n\\n        bytes memory result = new bytes(length);\\n        i = length;\\n        while (input != 0) {\\n            i--;\\n            uint8 character = (48 + uint8(input - (input / 10) * 10));\\n            result[i] = bytes1(character);\\n            input /= 10;\\n        }\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\ncontract AddressSet {\\n    struct Set {\\n        address[] addresses;\\n        mapping(address => uint256) positions;\\n        uint256 count;\\n    }\\n    mapping(bytes32 => Set) private sets;\\n\\n    function addAddressToSet(\\n        bytes32 key,\\n        address addr,\\n        bool maintainList\\n    ) internal {\\n        Set storage set = sets[key];\\n        require(set.positions[addr] == 0, \\\"ALREADY_IN_SET\\\");\\n\\n        if (maintainList) {\\n            require(\\n                set.addresses.length == set.count,\\n                \\\"PREVIOUSLY_NOT_MAINTAILED\\\"\\n            );\\n            set.addresses.push(addr);\\n        } else {\\n            require(set.addresses.length == 0, \\\"MUST_MAINTAIN\\\");\\n        }\\n\\n        set.count += 1;\\n        set.positions[addr] = set.count;\\n    }\\n\\n    function removeAddressFromSet(bytes32 key, address addr) internal {\\n        Set storage set = sets[key];\\n        uint256 pos = set.positions[addr];\\n        require(pos != 0, \\\"NOT_IN_SET\\\");\\n\\n        delete set.positions[addr];\\n        set.count -= 1;\\n\\n        if (set.addresses.length > 0) {\\n            address lastAddr = set.addresses[set.count];\\n            if (lastAddr != addr) {\\n                set.addresses[pos - 1] = lastAddr;\\n                set.positions[lastAddr] = pos;\\n            }\\n            set.addresses.pop();\\n        }\\n    }\\n\\n    function isAddressInSet(bytes32 key, address addr)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return sets[key].positions[addr] != 0;\\n    }\\n\\n    function numAddressesInSet(bytes32 key) internal view returns (uint256) {\\n        Set storage set = sets[key];\\n        return set.count;\\n    }\\n\\n    function addressesInSet(bytes32 key)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        Set storage set = sets[key];\\n        require(set.count == set.addresses.length, \\\"NOT_MAINTAINED\\\");\\n        return sets[key].addresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n// Extension for the Ownable contract, where the ownership needs\\n// to be claimed. This allows the new owner to accept the transfer.\\ncontract Claimable is Ownable {\\n    address public pendingOwner;\\n\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwner, \\\"UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0) && newOwner != owner, \\\"INVALID_ADDRESS\\\");\\n        pendingOwner = newOwner;\\n    }\\n\\n    function claimOwnership() public onlyPendingOwner {\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\n// The Ownable contract has an owner address, and provides basic\\n// authorization control functions, this simplifies the implementation of\\n// \\\"user permissions\\\". Subclasses are responsible for initializing the\\n// `owner` property (it is not done in a constructor to faciliate use of\\n// a factory proxy pattern).\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc165/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n// Implementation of the {IERC165} interface.\\n// Contracts may inherit from this and call {_registerInterface} to declare\\n// their support of an interface.  Derived contracts must call\\n// _registerInterface(_INTERFACE_ID_ERC165).\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 internal constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc165/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc1155/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"../erc165/ERC165.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n// Implementation of the basic standard multi-token.\\n// See https://eips.ethereum.org/EIPS/eip-1155\\n// Originally based on code by Enjin: https://github.com/enjin/erc-1155\\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 internal constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 internal constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    function balanceOf(address account, uint256 id)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        require(\\n            account != address(0),\\n            \\\"ERC1155: balance query for the zero address\\\"\\n        );\\n        return _balances[id][account];\\n    }\\n\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(\\n            accounts.length == ids.length,\\n            \\\"ERC1155: accounts and ids length mismatch\\\"\\n        );\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            require(\\n                accounts[i] != address(0),\\n                \\\"ERC1155: batch balance query for the zero address\\\"\\n            );\\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        require(\\n            _msgSender() != operator,\\n            \\\"ERC1155: setting approval status for self\\\"\\n        );\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    function isApprovedForAll(address account, address operator)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _balances[id][from] = _balances[id][from].sub(\\n            amount,\\n            \\\"ERC1155: insufficient balance for transfer\\\"\\n        );\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155: ids and amounts length mismatch\\\"\\n        );\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            from,\\n            to,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            account,\\n            id,\\n            amount,\\n            data\\n        );\\n    }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155Received(\\n                    operator,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC1155Receiver(to).onERC1155Received.selector\\n                ) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155BatchReceived(\\n                    operator,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response !=\\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector\\n                ) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"../erc165/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(\\n        address indexed account,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc1155/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"../erc165/ERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc1155/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MintAuthorization.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"./lib/OwnerManagable.sol\\\";\\n\\ncontract MintAuthorization is OwnerManagable {\\n    address public immutable layer2;\\n\\n    constructor(\\n        address _owner,\\n        address _layer2,\\n        address[] memory _initialMinters,\\n        address[] memory _initialUpdaters\\n    ) {\\n        // Initially allow the deploying account to add minters/updaters\\n        owner = msg.sender;\\n\\n        layer2 = _layer2;\\n\\n        for (uint256 i = 0; i < _initialMinters.length; i++) {\\n            addActiveMinter(_initialMinters[i]);\\n        }\\n\\n        for (uint256 i = 0; i < _initialUpdaters.length; i++) {\\n            addUpdater(_initialUpdaters[i]);\\n        }\\n\\n        // From now on, only the specified owner can add/remove minters/updaters\\n        owner = _owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/erc1155/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OwnerManagable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AddressSet.sol\\\";\\nimport \\\"./Claimable.sol\\\";\\n\\ncontract OwnerManagable is Claimable, AddressSet {\\n    bytes32 internal constant MINTER = keccak256(\\\"__MINTERS__\\\");\\n    bytes32 internal constant RETIREDMINTER = keccak256(\\\"__RETIREDMINTERS__\\\");\\n    bytes32 internal constant UPDATER = keccak256(\\\"__UPDATER__\\\");\\n\\n    event MinterAdded(address indexed minter);\\n    event MinterRetired(address indexed minter);\\n    event UpdaterAdded(address indexed updater);\\n    event UpdaterRemoved(address indexed updater);\\n\\n    // All address that are currently authorized to mint NFTs on L2.\\n    function activeMinters() public view returns (address[] memory) {\\n        return addressesInSet(MINTER);\\n    }\\n\\n    // All address that were previously authorized to mint NFTs on L2.\\n    function retiredMinters() public view returns (address[] memory) {\\n        return addressesInSet(RETIREDMINTER);\\n    }\\n\\n    // All address that are authorized to add new collections.\\n    function updaters() public view returns (address[] memory) {\\n        return addressesInSet(UPDATER);\\n    }\\n\\n    function numActiveMinters() public view returns (uint256) {\\n        return numAddressesInSet(MINTER);\\n    }\\n\\n    function numRetiredMinters() public view returns (uint256) {\\n        return numAddressesInSet(RETIREDMINTER);\\n    }\\n\\n    function numUpdaters() public view returns (uint256) {\\n        return numAddressesInSet(UPDATER);\\n    }\\n\\n    function isActiveMinter(address addr) public view returns (bool) {\\n        return isAddressInSet(MINTER, addr);\\n    }\\n\\n    function isRetiredMinter(address addr) public view returns (bool) {\\n        return isAddressInSet(RETIREDMINTER, addr);\\n    }\\n\\n    function isUpdater(address addr) public view returns (bool) {\\n        return isAddressInSet(UPDATER, addr);\\n    }\\n\\n    function addActiveMinter(address minter) public virtual onlyOwner {\\n        addAddressToSet(MINTER, minter, true);\\n        if (isRetiredMinter(minter)) {\\n            removeAddressFromSet(RETIREDMINTER, minter);\\n        }\\n        emit MinterAdded(minter);\\n    }\\n\\n    function addUpdater(address updater) public virtual onlyOwner {\\n        addAddressToSet(UPDATER, updater, true);\\n        emit UpdaterAdded(updater);\\n    }\\n\\n    function removeUpdater(address updater) public virtual onlyOwner {\\n        removeAddressFromSet(UPDATER, updater);\\n        emit UpdaterRemoved(updater);\\n    }\\n\\n    function retireMinter(address minter) public virtual onlyOwner {\\n        removeAddressFromSet(MINTER, minter);\\n        addAddressToSet(RETIREDMINTER, minter, true);\\n        emit MinterRetired(minter);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"MintFromL2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"collectionId\",\"type\":\"uint64\"}],\"name\":\"getIpfsHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_authorization\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintFromL2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorization\",\"type\":\"address\"}],\"name\":\"setAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"collectionId\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"name\":\"setIpfsHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"L2MintableERC1155","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}