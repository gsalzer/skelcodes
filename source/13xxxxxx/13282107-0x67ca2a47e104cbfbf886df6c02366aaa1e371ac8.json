{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @title LP Staking\r\n * @author gotbit\r\n */\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address who) external view returns (uint256 balance);\r\n    function transfer(address to, uint256 value) external returns (bool trans1);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool trans);\r\n}\r\n\r\ncontract OwnableAndWhitelistble {\r\n\r\n    address public owner;\r\n    mapping(address => bool) internal whitelist;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event WhitelistAdded(address indexed sender, address indexed whitelistUser);\r\n    event WhitelistRemoved(address indexed sender, address indexed whitelistUser);\r\n\r\n\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'Only owner can call this function');\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), 'You cant transfer ownerships to address 0x0');\r\n        require(newOwner != owner, 'You cant transfer ownerships to yourself');\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        whitelist[owner] = false;\r\n        whitelist[newOwner] = true;\r\n        owner = newOwner;\r\n    }\r\n\r\n    modifier onlyWhitelist() {\r\n        require(whitelist[msg.sender], 'Only whitelist users can call this function');\r\n        _;\r\n    }\r\n\r\n    function addToWhitelist(address newWhitelistUser) external onlyOwner {\r\n        require(newWhitelistUser != address(0), 'You cant add to whitelist address 0x0');\r\n        emit WhitelistAdded(msg.sender, newWhitelistUser);\r\n        whitelist[newWhitelistUser] = true;\r\n    }\r\n    function removeFromWhitelist(address newWhitelistUser) external onlyOwner {\r\n        require(whitelist[newWhitelistUser], 'You cant remove from whitelist');\r\n        emit WhitelistRemoved(msg.sender, newWhitelistUser);\r\n        whitelist[newWhitelistUser] = false;\r\n    }\r\n}\r\n\r\ncontract LPStaking is OwnableAndWhitelistble{\r\n\r\n    struct Stake {\r\n        uint amount;\r\n        uint startStaking;\r\n        uint lastHarvest;\r\n        uint bonus;\r\n        uint boost; \r\n    }\r\n\r\n\r\n    IERC20 mainToken;\r\n    \r\n    address dividends;\r\n\r\n    uint public year = 365 days;\r\n\r\n    uint public constant ETH = 1e18; \r\n    uint public rate = 888;\r\n    uint public lowRate = 70;\r\n    uint public alpha = 70;\r\n\r\n    uint public pool;\r\n\r\n    uint constant public cutoff = 48 hours;\r\n    uint constant public beforeCutoff = 15;\r\n    uint constant public afterCutoff = 10;\r\n\r\n    address[] public users;\r\n\r\n    mapping(address => bool) public isPermitted;\r\n    mapping(address => mapping(address => Stake)) public stakes;\r\n    mapping(address => bool) public userIncludes;\r\n\r\n    event Staked(address indexed who, address indexed lpToken, uint amount, uint startTime);\r\n    event AddedAmount(address indexed who, address indexed lpToken, uint amount);\r\n    event Harvested(address indexed who, address indexed lpToken, uint value, uint toDividends);    \r\n    event Unstaked(address indexed who, address indexed lpToken, uint amount);\r\n    event Boosted(address indexed who, address indexed lpToken, uint boost);\r\n    event SettedPermisionLPToken(address indexed lpToken, bool perm);\r\n\r\n    event SettedAlpha(address indexed sender, uint alpha);\r\n    event SettedLowRate(address indexed sender, uint lowRate);\r\n    event SettedDividends(address indexed sender, address indexed dividends);\r\n\r\n\r\n    constructor(address owner_, address token_, address dividends_) {\r\n        owner = owner_;\r\n        mainToken = IERC20(token_);\r\n        dividends = dividends_;\r\n    }\r\n\r\n    function stake(address lpTokenAddress_, uint amount_)\r\n    external {\r\n        require(amount_ > 0, 'Amount must be greater then zero');\r\n        require(stakes[msg.sender][lpTokenAddress_].startStaking == 0, 'You have already staked');\r\n        require(isPermitted[lpTokenAddress_], 'You cant stake those LP tokens');\r\n\r\n        IERC20 lpToken_ = IERC20(lpTokenAddress_); \r\n\r\n        require(lpToken_.balanceOf(msg.sender) >= amount_, 'You dont enough LP tokens');\r\n        require(lpToken_.transferFrom(msg.sender, address(this), amount_), 'Transfer issues');\r\n\r\n        addBonuses(lpTokenAddress_, pool, pool + amount_);\r\n        pool += amount_;\r\n        \r\n        stakes[msg.sender][lpTokenAddress_] = Stake({\r\n            amount: amount_,\r\n            startStaking: block.timestamp,\r\n            lastHarvest: block.timestamp,\r\n            bonus: 0,\r\n            boost: 0\r\n        });\r\n\r\n        require(addUser(msg.sender), 'Contract issue');\r\n\r\n        emit Staked(msg.sender, lpTokenAddress_, amount_, block.timestamp);\r\n    }\r\n\r\n    function addBonuses(address lpTokenAddress_, uint oldPool_, uint newPool_)\r\n    internal {\r\n        uint length_ = users.length;\r\n        \r\n        for (uint i = 0; i < length_; i++) {\r\n            if (userIncludes[users[i]]) {\r\n                (uint oldVal_, ) = harvested(users[i], lpTokenAddress_,  oldPool_);\r\n                (uint newVal_, ) = harvested(users[i], lpTokenAddress_, newPool_); \r\n                stakes[users[i]][lpTokenAddress_].bonus += oldVal_ - newVal_;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeBonuses(address lpTokenAddress_, uint oldPool_, uint newPool_)\r\n    internal {\r\n        uint length_ = users.length;\r\n\r\n        for (uint i = 0; i < length_; i++) {\r\n            if (userIncludes[users[i]]) {\r\n                (uint oldVal_, ) = harvested(users[i], lpTokenAddress_, oldPool_);\r\n                (uint newVal_, ) = harvested(users[i], lpTokenAddress_, newPool_); \r\n                stakes[users[i]][lpTokenAddress_].bonus -= newVal_ - oldVal_;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addAmount(uint amount_, address lpTokenAddress_)\r\n    external {\r\n        require(amount_ > 0, 'Amount must be greater then zero');\r\n        require(stakes[msg.sender][lpTokenAddress_].startStaking != 0, 'You dont have stake');\r\n\r\n        IERC20 lpToken_ = IERC20(lpTokenAddress_);\r\n\r\n        require(lpToken_.balanceOf(msg.sender) >= amount_, 'You dont enough LP tokens');\r\n        require(lpToken_.transferFrom(msg.sender, address(this), amount_), 'Transfer issues');\r\n\r\n        addBonuses(lpTokenAddress_, pool, pool + amount_);\r\n        pool += amount_;\r\n\r\n        stakes[msg.sender][lpTokenAddress_].amount += amount_;\r\n\r\n        emit AddedAmount(msg.sender, lpTokenAddress_, amount_);\r\n    }\r\n\r\n    function harvest(address lpTokenAddress_) \r\n    public {\r\n        require(stakes[msg.sender][lpTokenAddress_].startStaking != 0, 'You dont have stake');\r\n\r\n\r\n        (uint value_, uint toDividends_) = harvested(msg.sender, lpTokenAddress_, pool);\r\n        require(mainToken.balanceOf(address(this)) >= (value_ + toDividends_), 'Contract doesnt have enough DES');\r\n    \r\n        stakes[msg.sender][lpTokenAddress_].lastHarvest = block.timestamp;\r\n        stakes[msg.sender][lpTokenAddress_].bonus = 0;\r\n\r\n        require(mainToken.transfer(msg.sender, value_), 'Transfer issues');\r\n        require(mainToken.transfer(dividends, toDividends_), 'Transfer issues');\r\n\r\n        emit Harvested(msg.sender, lpTokenAddress_, value_, toDividends_);\r\n    }\r\n\r\n    function harvested(address who_, address lpTokenAddress_, uint pool_) \r\n    public \r\n    view\r\n    returns (uint value_, uint toDividends_) {\r\n        require(stakes[msg.sender][lpTokenAddress_].startStaking != 0, 'You dont have stake');\r\n\r\n        if (stakes[who_][lpTokenAddress_].lastHarvest == 0) return (0, 0);\r\n        Stake memory stake_ = stakes[who_][lpTokenAddress_];\r\n\r\n        uint timePassed_ = block.timestamp - stake_.lastHarvest;\r\n        uint percentDiv_ = timePassed_ < cutoff ? beforeCutoff: afterCutoff;\r\n\r\n        uint reward_ = (stake_.amount * timePassed_ * (getRate(pool_) + stake_.boost)) / (100 * year) + stake_.bonus;\r\n        uint toDiv_ = (reward_ * percentDiv_) / 100;\r\n\r\n        return (reward_ - toDiv_, toDiv_);\r\n    }\r\n\r\n    function getRate(uint pool_)\r\n    public\r\n    view\r\n    returns (uint rate_) {\r\n        return ((rate - lowRate) * alpha * ETH) / (pool_ + alpha * ETH) + lowRate;\r\n    }\r\n\r\n    function unstake(address lpTokenAddress_) \r\n    public {\r\n        require(stakes[msg.sender][lpTokenAddress_].startStaking != 0, 'You dont have stake');\r\n\r\n        harvest(lpTokenAddress_);\r\n\r\n        uint amount_ = stakes[msg.sender][lpTokenAddress_].amount;\r\n\r\n        IERC20 lpToken_ = IERC20(lpTokenAddress_);\r\n        require(lpToken_.balanceOf(address(this)) >= amount_, 'Contract doesnt have enough DES');\r\n        \r\n        delete stakes[msg.sender][lpTokenAddress_];\r\n\r\n        require(removeUser(msg.sender), 'Contract issue');\r\n        removeBonuses(lpTokenAddress_, pool, pool - amount_);\r\n        pool -= amount_;\r\n\r\n        require(lpToken_.transfer(msg.sender, amount_), 'Transfer issues');\r\n\r\n        emit Unstaked(msg.sender, lpTokenAddress_, amount_);\r\n    }\r\n\r\n\r\n    function addUser(address user_) \r\n    internal \r\n    returns (bool _status) {\r\n        users.push(user_);\r\n        userIncludes[user_] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeUser(address user_)\r\n    internal \r\n    returns (bool _status) {\r\n        uint len = users.length;\r\n\r\n        for (uint i = 0; i < len; i++ ) {\r\n            if (users[i] == user_) {\r\n                users[i] = address(0);\r\n                userIncludes[user_] = false;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getStake(address user_, address lpTokenAddress_)\r\n    external\r\n    view\r\n    returns (Stake memory) {\r\n        return stakes[user_][lpTokenAddress_];\r\n    }\r\n\r\n    function setBoost(address for_, address lpTokenAddress_, uint boost_) \r\n    external\r\n    onlyWhitelist {\r\n        stakes[for_][lpTokenAddress_].boost = boost_;\r\n        emit Boosted(for_, lpTokenAddress_,  boost_);\r\n    }\r\n\r\n    function setDividends(address newDividends_)\r\n    external\r\n    onlyOwner {\r\n        dividends = newDividends_;\r\n        emit SettedDividends(msg.sender, newDividends_);\r\n    }\r\n\r\n    function setAlpha(uint alpha_)\r\n    external\r\n    onlyOwner {\r\n        alpha = alpha_;\r\n        emit SettedAlpha(msg.sender, alpha_);\r\n    }\r\n\r\n    function setLowRate(uint lowRate_)\r\n    external\r\n    onlyOwner {\r\n        lowRate = lowRate_;\r\n        emit SettedAlpha(msg.sender, lowRate_);\r\n    }\r\n\r\n    function setPermission(address lpTokenAddress_, bool perm_) \r\n    external \r\n    onlyOwner {\r\n        isPermitted[lpTokenAddress_] = perm_;\r\n        emit SettedPermisionLPToken(lpTokenAddress_, perm_);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dividends_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddedAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"name\":\"Boosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toDividends\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alpha\",\"type\":\"uint256\"}],\"name\":\"SettedAlpha\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dividends\",\"type\":\"address\"}],\"name\":\"SettedDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lowRate\",\"type\":\"uint256\"}],\"name\":\"SettedLowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"perm\",\"type\":\"bool\"}],\"name\":\"SettedPermisionLPToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistUser\",\"type\":\"address\"}],\"name\":\"WhitelistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistUser\",\"type\":\"address\"}],\"name\":\"WhitelistRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"}],\"name\":\"addAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWhitelistUser\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"afterCutoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alpha\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beforeCutoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cutoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pool_\",\"type\":\"uint256\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"internalType\":\"struct LPStaking.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pool_\",\"type\":\"uint256\"}],\"name\":\"harvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toDividends_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPermitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWhitelistUser\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"alpha_\",\"type\":\"uint256\"}],\"name\":\"setAlpha\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"for_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boost_\",\"type\":\"uint256\"}],\"name\":\"setBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDividends_\",\"type\":\"address\"}],\"name\":\"setDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lowRate_\",\"type\":\"uint256\"}],\"name\":\"setLowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"perm_\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenAddress_\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIncludes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"year\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LPStaking","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f7909ae68bf8287f692d03fdda35441621b554c3000000000000000000000000634239cfa331df0291653139d1a6083b9cf705e3000000000000000000000000bf434b109a9cced493903abdb104ddbcb3470428","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://530820ff6173aaa2187bcba1fd423d52e23c9ea07ba4062446c77b5e2ede8e53"}]}