{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/SushiswapSimple/PendleSushiswapSimpleForge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// solhint-disable ordering\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../UniswapV2/PendleUniswapV2Forge.sol\\\";\\nimport \\\"../../interfaces/IMasterChef.sol\\\";\\n\\n/*\\n- SushiswapSimpleForge is for tokens that are not in Sushi's Onsen program (i.e doesn't have a pid\\nthe MasterChef)\\n*/\\ncontract PendleSushiswapSimpleForge is PendleUniswapV2Forge {\\n    constructor(\\n        address _governanceManager,\\n        IPendleRouter _router,\\n        bytes32 _forgeId,\\n        address _rewardToken,\\n        address _rewardManager,\\n        address _yieldContractDeployer,\\n        bytes32 _codeHash,\\n        address _pairFactory\\n    )\\n        PendleUniswapV2Forge(\\n            _governanceManager,\\n            _router,\\n            _forgeId,\\n            _rewardToken,\\n            _rewardManager,\\n            _yieldContractDeployer,\\n            _codeHash,\\n            _pairFactory\\n        )\\n    {}\\n}\\n\"\r\n    },\r\n    \"contracts/core/UniswapV2/PendleUniswapV2Forge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// solhint-disable ordering\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"../../interfaces/IPendleGenericForge.sol\\\";\\nimport \\\"../abstractV2/PendleForgeBaseV2.sol\\\";\\nimport \\\"../../libraries/UniswapV2Lib.sol\\\";\\n\\n/*\\n- For UniswapV2, the container of each underlyingAsset will be empty\\n*/\\ncontract PendleUniswapV2Forge is PendleForgeBaseV2, IPendleGenericForge {\\n    using SafeMath for uint256;\\n    using Math for uint256;\\n\\n    mapping(address => uint256) public lastRateForUnderlyingAsset;\\n    mapping(address => mapping(uint256 => uint256)) public lastRateBeforeExpiry;\\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public lastRate;\\n    bytes32 public immutable codeHash;\\n    address public immutable pairFactory;\\n\\n    constructor(\\n        address _governanceManager,\\n        IPendleRouter _router,\\n        bytes32 _forgeId,\\n        address _rewardToken,\\n        address _rewardManager,\\n        address _yieldContractDeployer,\\n        bytes32 _codeHash,\\n        address _pairFactory\\n    )\\n        PendleForgeBaseV2(\\n            _governanceManager,\\n            _router,\\n            _forgeId,\\n            _rewardToken,\\n            _rewardManager,\\n            _yieldContractDeployer\\n        )\\n    {\\n        codeHash = _codeHash;\\n        pairFactory = _pairFactory;\\n    }\\n\\n    /**\\n    @dev the logic of verifying tokens is the same as how Uniswap does it\\n    */\\n    function verifyToken(address _underlyingAsset, uint256[] calldata _tokenInfo)\\n        public\\n        virtual\\n        override\\n    {\\n        // in the case of Uniswap, _underlyingAsset == tokenAddr\\n        require(\\n            _tokenInfo.length == 1 && address(_tokenInfo[0]) == _underlyingAsset,\\n            \\\"INVALID_TOKEN_INFO\\\"\\n        );\\n\\n        IUniswapV2Pair pair = IUniswapV2Pair(_underlyingAsset);\\n        address poolAddr = UniswapV2Library.pairFor(\\n            pairFactory,\\n            pair.token0(),\\n            pair.token1(),\\n            codeHash\\n        );\\n        require(poolAddr == _underlyingAsset, \\\"INVALID_TOKEN_ADDR\\\");\\n    }\\n\\n    /**\\n    @dev please refer to the specs\\n    */\\n    function getExchangeRate(address _underlyingAsset) public override returns (uint256 rate) {\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_underlyingAsset).getReserves();\\n\\n        uint256 currentK = Math.sqrt(reserve0.mul(reserve1));\\n        uint256 totalSupply = IUniswapV2Pair(_underlyingAsset).totalSupply();\\n        rate = Math.max(currentK.rdiv(totalSupply), lastRateForUnderlyingAsset[_underlyingAsset]);\\n        lastRateForUnderlyingAsset[_underlyingAsset] = rate;\\n    }\\n\\n    /**\\n    @dev for Uniswap, the yieldBearingToken of an asset is itself\\n    */\\n    function getYieldBearingToken(address _underlyingAsset)\\n        public\\n        view\\n        override(IPendleForge, PendleForgeBaseV2)\\n        returns (address yieldBearingToken)\\n    {\\n        require(tokenInfo[_underlyingAsset].registered, \\\"INVALID_UNDERLYING_ASSET\\\");\\n        return _underlyingAsset;\\n    }\\n\\n    /**\\n    @dev please refer to the specs\\n    */\\n    function _calcTotalAfterExpiry(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        uint256 _redeemedAmount\\n    ) internal view override returns (uint256 totalAfterExpiry) {\\n        totalAfterExpiry = _redeemedAmount.rdiv(lastRateBeforeExpiry[_underlyingAsset][_expiry]);\\n    }\\n\\n    function getExchangeRateBeforeExpiry(address _underlyingAsset, uint256 _expiry)\\n        internal\\n        returns (uint256 exchangeRate)\\n    {\\n        if (block.timestamp > _expiry) {\\n            return lastRateBeforeExpiry[_underlyingAsset][_expiry];\\n        }\\n        exchangeRate = getExchangeRate(_underlyingAsset);\\n\\n        lastRateBeforeExpiry[_underlyingAsset][_expiry] = exchangeRate;\\n    }\\n\\n    /**\\n    @dev please refer to the specs\\n    */\\n    function _calcUnderlyingToRedeem(address _underlyingAsset, uint256 _amountToRedeem)\\n        internal\\n        override\\n        returns (uint256 underlyingToRedeem)\\n    {\\n        underlyingToRedeem = _amountToRedeem.rdiv(getExchangeRate(_underlyingAsset));\\n    }\\n\\n    /**\\n    @dev please refer to the specs\\n    */\\n    function _calcAmountToMint(address _underlyingAsset, uint256 _amountToTokenize)\\n        internal\\n        override\\n        returns (uint256 amountToMint)\\n    {\\n        amountToMint = _amountToTokenize.rmul(getExchangeRate(_underlyingAsset));\\n    }\\n\\n    /**\\n    @dev please refer to the specs\\n    */\\n    function _updateDueInterests(\\n        uint256 _principal,\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user\\n    ) internal override {\\n        uint256 prevRate = lastRate[_underlyingAsset][_expiry][_user];\\n        uint256 currentRate = getExchangeRateBeforeExpiry(_underlyingAsset, _expiry);\\n\\n        lastRate[_underlyingAsset][_expiry][_user] = currentRate;\\n        // first time getting XYT, or there is no update in exchangeRate\\n        if (prevRate == 0 || prevRate == currentRate) {\\n            return;\\n        }\\n\\n        uint256 interestFromXyt = _principal.mul(currentRate.sub(prevRate)).rdiv(\\n            prevRate.mul(currentRate)\\n        );\\n\\n        dueInterests[_underlyingAsset][_expiry][_user] = dueInterests[_underlyingAsset][_expiry][\\n            _user\\n        ]\\n        .add(interestFromXyt);\\n    }\\n\\n    /**\\n    @dev please refer to the specs\\n    */\\n    function _updateForgeFee(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        uint256 _feeAmount\\n    ) internal override {\\n        totalFee[_underlyingAsset][_expiry] = totalFee[_underlyingAsset][_expiry].add(_feeAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\npragma abicoder v2;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMasterChef {\\n    struct UserInfo {\\n        uint256 amount;\\n        int256 rewardDebt;\\n    }\\n\\n    struct PoolInfo {\\n        IERC20 lpToken;\\n        uint256 allocPoint;\\n        uint256 lastRewardBlock;\\n        uint256 accSushiPerShare;\\n    }\\n\\n    function userInfo(uint256 pid, address user) external view returns (UserInfo calldata);\\n\\n    function poolInfo(uint256 pid) external view returns (PoolInfo calldata);\\n\\n    function deposit(uint256 pid, uint256 amount) external;\\n\\n    function withdraw(uint256 pid, uint256 amount) external;\\n\\n    function emergencyWithdraw(uint256 pid) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n// solhint-disable\\npragma solidity 0.7.6;\\n\\n/// @author Uniswap\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleGenericForge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IPendleCompoundForge.sol\\\";\\n\\n// Forges should implement this Interface to guarantee compatibility with GenericMarket & Liq\\ninterface IPendleGenericForge is IPendleCompoundForge {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/abstractV2/PendleForgeBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// solhint-disable ordering\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../libraries/ExpiryUtilsLib.sol\\\";\\nimport \\\"../../interfaces/IPendleBaseToken.sol\\\";\\nimport \\\"../../interfaces/IPendleData.sol\\\";\\nimport \\\"../../interfaces/IPendleForgeV2.sol\\\";\\nimport \\\"../../interfaces/IPendleRewardManager.sol\\\";\\nimport \\\"../../interfaces/IPendleYieldContractDeployer.sol\\\";\\nimport \\\"../../interfaces/IPendleYieldContractDeployerV2.sol\\\";\\nimport \\\"../../interfaces/IPendleYieldTokenHolderV2.sol\\\";\\nimport \\\"../../periphery/WithdrawableV2.sol\\\";\\nimport \\\"../../libraries/MathLib.sol\\\";\\nimport \\\"../../libraries/TokenUtilsLib.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\n/// @notice Common contract base for a forge implementation.\\n/// @dev Each specific forge implementation will need to override necessary virtual functions\\nabstract contract PendleForgeBaseV2 is IPendleForgeV2, WithdrawableV2, ReentrancyGuard {\\n    using ExpiryUtils for string;\\n    using SafeMath for uint256;\\n    using Math for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    struct PendleTokens {\\n        IPendleYieldToken xyt;\\n        IPendleYieldToken ot;\\n    }\\n\\n    // the container here will contain any data needed by tokens. Fields of type that are not\\n    // uin256 will be upcasted to uint256 and downcasted when use\\n    struct TokenInfo {\\n        bool registered;\\n        uint256[] container;\\n    }\\n\\n    IPendleRouter public immutable override router;\\n    IPendleData public immutable override data;\\n    bytes32 public immutable override forgeId;\\n    IERC20 public immutable override rewardToken;\\n    IPendleRewardManager public immutable override rewardManager;\\n    IPendleYieldContractDeployer public immutable override yieldContractDeployer;\\n    IPendlePausingManager public immutable pausingManager;\\n\\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\\n        public\\n        override dueInterests;\\n\\n    mapping(address => mapping(uint256 => uint256)) public totalFee;\\n    mapping(address => mapping(uint256 => address)) public override yieldTokenHolders; // yieldTokenHolders[underlyingAsset][expiry]\\n    mapping(address => TokenInfo) public tokenInfo;\\n\\n    string private constant OT = \\\"OT\\\";\\n    string private constant XYT = \\\"YT\\\";\\n\\n    event RegisterTokens(bytes32 forgeId, address underlyingAsset, uint256[] container);\\n\\n    modifier onlyXYT(address _underlyingAsset, uint256 _expiry) {\\n        require(\\n            msg.sender == address(data.xytTokens(forgeId, _underlyingAsset, _expiry)),\\n            \\\"ONLY_YT\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOT(address _underlyingAsset, uint256 _expiry) {\\n        require(\\n            msg.sender == address(data.otTokens(forgeId, _underlyingAsset, _expiry)),\\n            \\\"ONLY_OT\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyRouter() {\\n        require(msg.sender == address(router), \\\"ONLY_ROUTER\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _governanceManager,\\n        IPendleRouter _router,\\n        bytes32 _forgeId,\\n        address _rewardToken,\\n        address _rewardManager,\\n        address _yieldContractDeployer\\n    ) PermissionsV2(_governanceManager) {\\n        require(address(_router) != address(0), \\\"ZERO_ADDRESS\\\");\\n        require(_forgeId != 0x0, \\\"ZERO_BYTES\\\");\\n        // In the case there is no rewardToken, a valid ERC20 token must still be passed in for\\n        // compatibility reasons\\n        TokenUtils.requireERC20(_rewardToken);\\n        router = _router;\\n        forgeId = _forgeId;\\n        IPendleData _dataTemp = IPendleRouter(_router).data();\\n        data = _dataTemp;\\n        rewardToken = IERC20(_rewardToken);\\n        rewardManager = IPendleRewardManager(_rewardManager);\\n        yieldContractDeployer = IPendleYieldContractDeployer(_yieldContractDeployer);\\n        pausingManager = _dataTemp.pausingManager();\\n    }\\n\\n    /**\\n    @dev INVARIANT: All write functions must go through this check.\\n    All XYT/OT transfers must go through this check as well. As such, XYT/OT transfers are also paused\\n    */\\n    function checkNotPaused(address _underlyingAsset, uint256 _expiry) internal virtual {\\n        (bool paused, ) = pausingManager.checkYieldContractStatus(\\n            forgeId,\\n            _underlyingAsset,\\n            _expiry\\n        );\\n        require(!paused, \\\"YIELD_CONTRACT_PAUSED\\\");\\n    }\\n\\n    /**\\n    @dev function has been depreciated but must still be left here to conform with the interface\\n    */\\n    function setUpEmergencyMode(\\n        address,\\n        uint256,\\n        address\\n    ) external pure override {\\n        revert(\\\"FUNCTION_DEPRECIATED\\\");\\n    }\\n\\n    /**\\n    @dev  Only the forgeEmergencyHandler can call this function, when its in emergencyMode this\\n    will allow a spender to spend the whole balance of the specified tokens of the yieldTokenHolder contract\\n    @dev the spender should ideally be a contract with logic for users to withdraw out their funds\\n    @param extraFlag an optional flag for any forges which need an additional flag (like SushiComplex\\n    which allows either normal withdraw or emergencyWithdraw)\\n    */\\n    function setUpEmergencyModeV2(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address spender,\\n        bool extraFlag\\n    ) external virtual override {\\n        (, bool emergencyMode) = pausingManager.checkYieldContractStatus(\\n            forgeId,\\n            _underlyingAsset,\\n            _expiry\\n        );\\n        require(emergencyMode, \\\"NOT_EMERGENCY\\\");\\n        (address forgeEmergencyHandler, , ) = pausingManager.forgeEmergencyHandler();\\n        require(msg.sender == forgeEmergencyHandler, \\\"NOT_EMERGENCY_HANDLER\\\");\\n        IPendleYieldTokenHolderV2(yieldTokenHolders[_underlyingAsset][_expiry])\\n            .setUpEmergencyModeV2(spender, extraFlag);\\n    }\\n\\n    /**\\n    @dev each element in the _underlyingAssets array will have one auxillary array in _tokenInfos\\n    to store necessary data.\\n    @dev only governance can call this. In V2 we no longer allow users to self-register new tokens\\n    */\\n    function registerTokens(address[] calldata _underlyingAssets, uint256[][] calldata _tokenInfos)\\n        external\\n        virtual\\n        onlyGovernance\\n    {\\n        require(_underlyingAssets.length == _tokenInfos.length, \\\"LENGTH_MISMATCH\\\");\\n        for (uint256 i = 0; i < _underlyingAssets.length; ++i) {\\n            TokenInfo storage info = tokenInfo[_underlyingAssets[i]];\\n            require(!info.registered, \\\"EXISTED_TOKENS\\\");\\n            verifyToken(_underlyingAssets[i], _tokenInfos[i]);\\n            info.registered = true;\\n            info.container = _tokenInfos[i];\\n            emit RegisterTokens(forgeId, _underlyingAssets[i], _tokenInfos[i]);\\n        }\\n    }\\n\\n    /**\\n    @dev this function should be implemented on a best effort basis, since we only call from\\n    governance anyway\\n    */\\n    function verifyToken(address _underlyingAsset, uint256[] calldata _tokenInfo) public virtual;\\n\\n    /**\\n    @notice to create a newYieldContract\\n    @dev Conditions:\\n        * only call by Router\\n        * the yield contract for this pair of _underlyingAsset & _expiry must not exist yet (checked on Router)\\n    */\\n    function newYieldContracts(address _underlyingAsset, uint256 _expiry)\\n        external\\n        virtual\\n        override\\n        onlyRouter\\n        returns (address ot, address xyt)\\n    {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n        address yieldToken = getYieldBearingToken(_underlyingAsset);\\n\\n        uint8 underlyingAssetDecimals = IPendleYieldToken(_underlyingAsset).decimals();\\n\\n        // Deploy the OT contract -> XYT contract -> yieldTokenHolder\\n        ot = yieldContractDeployer.forgeOwnershipToken(\\n            _underlyingAsset,\\n            OT.concat(IPendleBaseToken(yieldToken).name(), _expiry, \\\" \\\"),\\n            OT.concat(IPendleBaseToken(yieldToken).symbol(), _expiry, \\\"-\\\"),\\n            underlyingAssetDecimals,\\n            _expiry\\n        );\\n\\n        xyt = yieldContractDeployer.forgeFutureYieldToken(\\n            _underlyingAsset,\\n            XYT.concat(IPendleBaseToken(yieldToken).name(), _expiry, \\\" \\\"),\\n            XYT.concat(IPendleBaseToken(yieldToken).symbol(), _expiry, \\\"-\\\"),\\n            underlyingAssetDecimals,\\n            _expiry\\n        );\\n\\n        // Because we have to conform with the IPendleForge interface, we must store\\n        // YieldContractDeployerV2 as V1, then upcast here\\n        yieldTokenHolders[_underlyingAsset][_expiry] = IPendleYieldContractDeployerV2(\\n            address(yieldContractDeployer)\\n        ).deployYieldTokenHolder(yieldToken, _expiry, tokenInfo[_underlyingAsset].container);\\n\\n        data.storeTokens(forgeId, ot, xyt, _underlyingAsset, _expiry);\\n\\n        emit NewYieldContracts(forgeId, _underlyingAsset, _expiry, ot, xyt, yieldToken);\\n    }\\n\\n    /**\\n    @notice To redeem the underlying asset & due interests after the XYT has expired\\n    @dev Conditions:\\n        * only be called by Router\\n        * only callable after XYT has expired (checked on Router)\\n    */\\n    function redeemAfterExpiry(\\n        address _user,\\n        address _underlyingAsset,\\n        uint256 _expiry\\n    ) external virtual override onlyRouter returns (uint256 redeemedAmount) {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\\n        uint256 expiredOTamount = tokens.ot.balanceOf(_user);\\n        require(expiredOTamount > 0, \\\"NOTHING_TO_REDEEM\\\");\\n\\n        // burn ot only, since users don't need xyt to redeem this\\n        tokens.ot.burn(_user, expiredOTamount);\\n\\n        // calc the value of the OT after since it expired (total of its underlying value + dueInterests since expiry)\\n        // no forge fee is charged on redeeming OT. Forge fee is only charged on redeeming XYT\\n        redeemedAmount = _calcTotalAfterExpiry(_underlyingAsset, _expiry, expiredOTamount);\\n\\n        // redeem the interest of any XYT (of the same underlyingAsset+expiry) that the user is having\\n        redeemedAmount = redeemedAmount.add(\\n            _beforeTransferDueInterests(tokens, _underlyingAsset, _expiry, _user, false)\\n        );\\n\\n        // transfer back to the user\\n        _pushYieldToken(_underlyingAsset, _expiry, _user, redeemedAmount);\\n\\n        // Notice for anyone taking values from this event:\\n        //   The redeemedAmount includes the interest due to any XYT held\\n        //   to get the exact yieldToken redeemed from OT, we need to deduct the (amount +forgeFeeAmount) of interests\\n        //   settled that was emitted in the DueInterestsSettled event emitted earlier in this same transaction\\n        emit RedeemYieldToken(\\n            forgeId,\\n            _underlyingAsset,\\n            _expiry,\\n            expiredOTamount,\\n            redeemedAmount,\\n            _user\\n        );\\n    }\\n\\n    /**\\n    @notice To redeem the underlying asset & due interests before the expiry of the XYT.\\n    In this case, for each OT used to redeem, there must be an XYT (of the same yield contract)\\n    @dev  Conditions:\\n        * only be called by Router\\n        * only callable if the XYT hasn't expired\\n    */\\n    function redeemUnderlying(\\n        address _user,\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        uint256 _amountToRedeem\\n    ) external virtual override onlyRouter returns (uint256 redeemedAmount) {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\\n\\n        tokens.ot.burn(_user, _amountToRedeem);\\n        tokens.xyt.burn(_user, _amountToRedeem);\\n\\n        /*\\n        * calc the amount of underlying asset for OT + the amount of dueInterests for XYT\\n        * dueInterests for XYT has been updated during the process of burning XYT, so we skip\\n        updating dueInterests in the _beforeTransferDueInterests function\\n        */\\n        redeemedAmount = _calcUnderlyingToRedeem(_underlyingAsset, _amountToRedeem).add(\\n            _beforeTransferDueInterests(tokens, _underlyingAsset, _expiry, _user, true)\\n        );\\n\\n        // transfer back to the user\\n        _pushYieldToken(_underlyingAsset, _expiry, _user, redeemedAmount);\\n\\n        // Notice for anyone taking values from this event:\\n        //   The redeemedAmount includes the interest due to the XYT held\\n        //   to get the exact yieldToken redeemed from OT+XYT, we need to deduct the\\n        //   (amount +forgeFeeAmount) of interests settled that was emitted in the\\n        //   DueInterestsSettled event emitted earlier in this same transaction\\n        emit RedeemYieldToken(\\n            forgeId,\\n            _underlyingAsset,\\n            _expiry,\\n            _amountToRedeem,\\n            redeemedAmount,\\n            _user\\n        );\\n\\n        return redeemedAmount;\\n    }\\n\\n    /**\\n    @notice To redeem the due interests. This function can always be called regardless of whether\\n        the XYT has expired or not\\n    @dev Conditions:\\n        * only be called by Router\\n    */\\n    function redeemDueInterests(\\n        address _user,\\n        address _underlyingAsset,\\n        uint256 _expiry\\n    ) external virtual override onlyRouter returns (uint256 amountOut) {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\\n\\n        // update the dueInterests of the user before we transfer out\\n        amountOut = _beforeTransferDueInterests(tokens, _underlyingAsset, _expiry, _user, false);\\n\\n        _pushYieldToken(_underlyingAsset, _expiry, _user, amountOut);\\n    }\\n\\n    /**\\n    @notice To update the dueInterests for users(before their balances of XYT changes)\\n    @dev This must be called before any transfer / mint/ burn action of XYT\\n        (and this has been implemented in the beforeTokenTransfer of the PendleFutureYieldToken)\\n    @dev Conditions:\\n        * Can only be called by the respective XYT contract, before transferring XYTs\\n    */\\n    function updateDueInterests(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user\\n    ) external virtual override onlyXYT(_underlyingAsset, _expiry) nonReentrant {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\\n        uint256 principal = tokens.xyt.balanceOf(_user);\\n        _updateDueInterests(principal, _underlyingAsset, _expiry, _user);\\n    }\\n\\n    /**\\n    @notice To redeem the rewards (COMP, StkAAVE, SUSHI,...) for users(before their balances of OT changes)\\n    @dev This must be called before any transfer / mint/ burn action of OT\\n        (and this has been implemented in the beforeTokenTransfer of the PendleOwnershipToken)\\n    @dev Conditions:\\n        * Can only be called by the respective OT contract, before transferring OTs\\n    Note:\\n        This function is just a proxy to call to rewardManager\\n    */\\n    function updatePendingRewards(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user\\n    ) external virtual override onlyOT(_underlyingAsset, _expiry) nonReentrant {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n        rewardManager.updatePendingRewards(_underlyingAsset, _expiry, _user);\\n    }\\n\\n    /**\\n    @notice To mint OT & XYT given that the user has transferred in _amountToTokenize of yieldToken\\n    @dev The newly minted OT & XYT can be minted to somebody else different from the user who transfer the aToken/cToken in\\n    @dev Conditions:\\n        * Should only be called by Router\\n        * The yield contract (OT & XYT) must not be expired yet (checked at Router)\\n    */\\n    function mintOtAndXyt(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        uint256 _amountToTokenize,\\n        address _to\\n    )\\n        external\\n        virtual\\n        override\\n        onlyRouter\\n        returns (\\n            address ot,\\n            address xyt,\\n            uint256 amountTokenMinted\\n        )\\n    {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n\\n        // surely if any users call tokenizeYield, they will have to call this function\\n        IPendleYieldTokenHolderV2(yieldTokenHolders[_underlyingAsset][_expiry]).afterReceiveTokens(\\n            _amountToTokenize\\n        );\\n\\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\\n\\n        amountTokenMinted = _calcAmountToMint(_underlyingAsset, _amountToTokenize);\\n\\n        // updatePendingRewards will be called in mint\\n        tokens.ot.mint(_to, amountTokenMinted);\\n\\n        // updateDueInterests will be called in mint\\n        tokens.xyt.mint(_to, amountTokenMinted);\\n\\n        emit MintYieldTokens(\\n            forgeId,\\n            _underlyingAsset,\\n            _expiry,\\n            _amountToTokenize,\\n            amountTokenMinted,\\n            _to\\n        );\\n        return (address(tokens.ot), address(tokens.xyt), amountTokenMinted);\\n    }\\n\\n    /**\\n    @notice To withdraw the forgeFee\\n    @dev Conditions:\\n        * Should only be called by Governance\\n        * This function must be the only way to withdrawForgeFee\\n    */\\n    function withdrawForgeFee(address _underlyingAsset, uint256 _expiry)\\n        external\\n        virtual\\n        override\\n        onlyGovernance\\n    {\\n        checkNotPaused(_underlyingAsset, _expiry);\\n        //ping to update interest up to now\\n        _updateForgeFee(_underlyingAsset, _expiry, 0);\\n        uint256 _totalFee = totalFee[_underlyingAsset][_expiry];\\n        totalFee[_underlyingAsset][_expiry] = 0;\\n\\n        address treasuryAddress = data.treasury();\\n        _pushYieldToken(_underlyingAsset, _expiry, treasuryAddress, _totalFee);\\n        emit ForgeFeeWithdrawn(forgeId, _underlyingAsset, _expiry, _totalFee);\\n    }\\n\\n    function getYieldBearingToken(address _underlyingAsset)\\n        public\\n        virtual\\n        override\\n        returns (address);\\n\\n    /**\\n    @notice To be called before the dueInterest of any users is redeemed.\\n    @param _skipUpdateDueInterests: this is set to true, if there was already a call to _updateDueInterests() in this transaction\\n    INVARIANT: there must be a transfer of the interests (amountOut) to the user after this function is called\\n    */\\n    function _beforeTransferDueInterests(\\n        PendleTokens memory _tokens,\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user,\\n        bool _skipUpdateDueInterests\\n    ) internal virtual returns (uint256 amountOut) {\\n        uint256 principal = _tokens.xyt.balanceOf(_user);\\n\\n        if (!_skipUpdateDueInterests) {\\n            _updateDueInterests(principal, _underlyingAsset, _expiry, _user);\\n        }\\n\\n        amountOut = dueInterests[_underlyingAsset][_expiry][_user];\\n        dueInterests[_underlyingAsset][_expiry][_user] = 0;\\n\\n        uint256 forgeFee = data.forgeFee();\\n        uint256 forgeFeeAmount;\\n        /*\\n         * Collect the forgeFee\\n         * INVARIANT: all XYT interest payout must go through this line\\n         */\\n        if (forgeFee > 0) {\\n            forgeFeeAmount = amountOut.rmul(forgeFee);\\n            amountOut = amountOut.sub(forgeFeeAmount);\\n            _updateForgeFee(_underlyingAsset, _expiry, forgeFeeAmount);\\n        }\\n\\n        emit DueInterestsSettled(\\n            forgeId,\\n            _underlyingAsset,\\n            _expiry,\\n            amountOut,\\n            forgeFeeAmount,\\n            _user\\n        );\\n    }\\n\\n    /**\\n    @dev Must be the only way to transfer yieldToken out\\n    @dev summary of invariance logic:\\n    - This is the only function where the underlying yield tokens are transfered out\\n    - After this function executes (at the end of the .pushYieldTokens() function), we require that\\n    there must be enough yield tokens left to entertain all OT holders redeeming\\n    - As such, protocol users are always assured that they can redeem back their underlying yield tokens\\n    - Further note: this pushYieldTokens function relies on the same calc functions\\n    (_calcUnderlyingToRedeem and _calcTotalAfterExpiry) as the functions that called pushYieldTokens.\\n    Why it is safe to do that? Because to drain funds, hackers need to compromise the calc functions to\\n    return a very large result (hence large _amount in this function) but in the same transaction,\\n    they also need to compromise the very same calc function to return a very small result (to fool\\n    the contract that all the underlyingAsset of OTs are still intact). Doing these 2\\n    compromises in one single transaction is much harder than doing just one\\n    */\\n    function _pushYieldToken(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user,\\n        uint256 _amount\\n    ) internal virtual {\\n        if (_amount == 0) return;\\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\\n        uint256 otBalance = tokens.ot.totalSupply();\\n        uint256 minNYieldAfterPush = block.timestamp < _expiry\\n            ? _calcUnderlyingToRedeem(_underlyingAsset, otBalance)\\n            : _calcTotalAfterExpiry(_underlyingAsset, _expiry, otBalance);\\n        IPendleYieldTokenHolderV2(yieldTokenHolders[_underlyingAsset][_expiry]).pushYieldTokens(\\n            _user,\\n            _amount,\\n            minNYieldAfterPush\\n        );\\n    }\\n\\n    function _getTokens(address _underlyingAsset, uint256 _expiry)\\n        internal\\n        view\\n        virtual\\n        returns (PendleTokens memory _tokens)\\n    {\\n        (_tokens.ot, _tokens.xyt) = data.getPendleYieldTokens(forgeId, _underlyingAsset, _expiry);\\n    }\\n\\n    // There shouldn't be any fund in here\\n    // hence governance is allowed to withdraw anything from here.\\n    function _allowedToWithdraw(address) internal pure virtual override returns (bool allowed) {\\n        allowed = true;\\n    }\\n\\n    /// INVARIANT: after _updateDueInterests is called, dueInterests[][][] must already be\\n    /// updated with all the due interest for the user, until exactly the current timestamp (no caching whatsoever)\\n    /// Refer to updateDueInterests function for more info\\n    function _updateDueInterests(\\n        uint256 _principal,\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user\\n    ) internal virtual;\\n\\n    /**\\n    @notice To update the amount of forgeFee (taking into account the compound interest effect)\\n    @dev To be called whenever the forge collect fees, or before withdrawing the fee\\n    @param _feeAmount the new fee that this forge just collected\\n    */\\n    function _updateForgeFee(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        uint256 _feeAmount\\n    ) internal virtual;\\n\\n    /// calculate the (principal + interest) from the last action before expiry to now.\\n    function _calcTotalAfterExpiry(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        uint256 redeemedAmount\\n    ) internal virtual returns (uint256 totalAfterExpiry);\\n\\n    function _calcUnderlyingToRedeem(address, uint256 _amountToRedeem)\\n        internal\\n        virtual\\n        returns (uint256 underlyingToRedeem);\\n\\n    function _calcAmountToMint(address, uint256 _amountToTokenize)\\n        internal\\n        virtual\\n        returns (uint256 amountToMint);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV2Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// solhint-disable\\npragma solidity 0.7.6;\\n\\n/// @author Uniswap\\nlibrary UniswapV2Library {\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB)\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB,\\n        bytes32 codeHash\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        factory,\\n                        keccak256(abi.encodePacked(token0, token1)),\\n                        codeHash\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleCompoundForge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IPendleForge.sol\\\";\\n\\ninterface IPendleCompoundForge is IPendleForge {\\n    /**\\n    @dev directly get the exchangeRate from Compound\\n    */\\n    function getExchangeRate(address _underlyingAsset) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleForge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IPendleRouter.sol\\\";\\nimport \\\"./IPendleRewardManager.sol\\\";\\nimport \\\"./IPendleYieldContractDeployer.sol\\\";\\nimport \\\"./IPendleData.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPendleForge {\\n    /**\\n     * @dev Emitted when the Forge has minted the OT and XYT tokens.\\n     * @param forgeId The forgeId\\n     * @param underlyingAsset The address of the underlying yield token.\\n     * @param expiry The expiry of the XYT token\\n     * @param amountToTokenize The amount of yield bearing assets to tokenize\\n     * @param amountTokenMinted The amount of OT/XYT minted\\n     **/\\n    event MintYieldTokens(\\n        bytes32 forgeId,\\n        address indexed underlyingAsset,\\n        uint256 indexed expiry,\\n        uint256 amountToTokenize,\\n        uint256 amountTokenMinted,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted when the Forge has created new yield token contracts.\\n     * @param forgeId The forgeId\\n     * @param underlyingAsset The address of the underlying asset.\\n     * @param expiry The date in epoch time when the contract will expire.\\n     * @param ot The address of the ownership token.\\n     * @param xyt The address of the new future yield token.\\n     **/\\n    event NewYieldContracts(\\n        bytes32 forgeId,\\n        address indexed underlyingAsset,\\n        uint256 indexed expiry,\\n        address ot,\\n        address xyt,\\n        address yieldBearingAsset\\n    );\\n\\n    /**\\n     * @dev Emitted when the Forge has redeemed the OT and XYT tokens.\\n     * @param forgeId The forgeId\\n     * @param underlyingAsset the address of the underlying asset\\n     * @param expiry The expiry of the XYT token\\n     * @param amountToRedeem The amount of OT to be redeemed.\\n     * @param redeemedAmount The amount of yield token received\\n     **/\\n    event RedeemYieldToken(\\n        bytes32 forgeId,\\n        address indexed underlyingAsset,\\n        uint256 indexed expiry,\\n        uint256 amountToRedeem,\\n        uint256 redeemedAmount,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted when interest claim is settled\\n     * @param forgeId The forgeId\\n     * @param underlyingAsset the address of the underlying asset\\n     * @param expiry The expiry of the XYT token\\n     * @param user Interest receiver Address\\n     * @param amount The amount of interest claimed\\n     **/\\n    event DueInterestsSettled(\\n        bytes32 forgeId,\\n        address indexed underlyingAsset,\\n        uint256 indexed expiry,\\n        uint256 amount,\\n        uint256 forgeFeeAmount,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted when forge fee is withdrawn\\n     * @param forgeId The forgeId\\n     * @param underlyingAsset the address of the underlying asset\\n     * @param expiry The expiry of the XYT token\\n     * @param amount The amount of interest claimed\\n     **/\\n    event ForgeFeeWithdrawn(\\n        bytes32 forgeId,\\n        address indexed underlyingAsset,\\n        uint256 indexed expiry,\\n        uint256 amount\\n    );\\n\\n    function setUpEmergencyMode(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address spender\\n    ) external;\\n\\n    function newYieldContracts(address underlyingAsset, uint256 expiry)\\n        external\\n        returns (address ot, address xyt);\\n\\n    function redeemAfterExpiry(\\n        address user,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external returns (uint256 redeemedAmount);\\n\\n    function redeemDueInterests(\\n        address user,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external returns (uint256 interests);\\n\\n    function updateDueInterests(\\n        address underlyingAsset,\\n        uint256 expiry,\\n        address user\\n    ) external;\\n\\n    function updatePendingRewards(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user\\n    ) external;\\n\\n    function redeemUnderlying(\\n        address user,\\n        address underlyingAsset,\\n        uint256 expiry,\\n        uint256 amountToRedeem\\n    ) external returns (uint256 redeemedAmount);\\n\\n    function mintOtAndXyt(\\n        address underlyingAsset,\\n        uint256 expiry,\\n        uint256 amountToTokenize,\\n        address to\\n    )\\n        external\\n        returns (\\n            address ot,\\n            address xyt,\\n            uint256 amountTokenMinted\\n        );\\n\\n    function withdrawForgeFee(address underlyingAsset, uint256 expiry) external;\\n\\n    function getYieldBearingToken(address underlyingAsset) external returns (address);\\n\\n    /**\\n     * @notice Gets a reference to the PendleRouter contract.\\n     * @return Returns the router contract reference.\\n     **/\\n    function router() external view returns (IPendleRouter);\\n\\n    function data() external view returns (IPendleData);\\n\\n    function rewardManager() external view returns (IPendleRewardManager);\\n\\n    function yieldContractDeployer() external view returns (IPendleYieldContractDeployer);\\n\\n    function rewardToken() external view returns (IERC20);\\n\\n    /**\\n     * @notice Gets the bytes32 ID of the forge.\\n     * @return Returns the forge and protocol identifier.\\n     **/\\n    function forgeId() external view returns (bytes32);\\n\\n    function dueInterests(\\n        address _underlyingAsset,\\n        uint256 expiry,\\n        address _user\\n    ) external view returns (uint256);\\n\\n    function yieldTokenHolders(address _underlyingAsset, uint256 _expiry)\\n        external\\n        view\\n        returns (address yieldTokenHolder);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"./IPendleData.sol\\\";\\nimport \\\"../libraries/PendleStructs.sol\\\";\\nimport \\\"./IPendleMarketFactory.sol\\\";\\n\\ninterface IPendleRouter {\\n    /**\\n     * @notice Emitted when a market for a future yield token and an ERC20 token is created.\\n     * @param marketFactoryId Forge identifier.\\n     * @param xyt The address of the tokenized future yield token as the base asset.\\n     * @param token The address of an ERC20 token as the quote asset.\\n     * @param market The address of the newly created market.\\n     **/\\n    event MarketCreated(\\n        bytes32 marketFactoryId,\\n        address indexed xyt,\\n        address indexed token,\\n        address indexed market\\n    );\\n\\n    /**\\n     * @notice Emitted when a swap happens on the market.\\n     * @param trader The address of msg.sender.\\n     * @param inToken The input token.\\n     * @param outToken The output token.\\n     * @param exactIn The exact amount being traded.\\n     * @param exactOut The exact amount received.\\n     * @param market The market address.\\n     **/\\n    event SwapEvent(\\n        address indexed trader,\\n        address inToken,\\n        address outToken,\\n        uint256 exactIn,\\n        uint256 exactOut,\\n        address market\\n    );\\n\\n    /**\\n     * @dev Emitted when user adds liquidity\\n     * @param sender The user who added liquidity.\\n     * @param token0Amount the amount of token0 (xyt) provided by user\\n     * @param token1Amount the amount of token1 provided by user\\n     * @param market The market address.\\n     * @param exactOutLp The exact LP minted\\n     */\\n    event Join(\\n        address indexed sender,\\n        uint256 token0Amount,\\n        uint256 token1Amount,\\n        address market,\\n        uint256 exactOutLp\\n    );\\n\\n    /**\\n     * @dev Emitted when user removes liquidity\\n     * @param sender The user who removed liquidity.\\n     * @param token0Amount the amount of token0 (xyt) given to user\\n     * @param token1Amount the amount of token1 given to user\\n     * @param market The market address.\\n     * @param exactInLp The exact Lp to remove\\n     */\\n    event Exit(\\n        address indexed sender,\\n        uint256 token0Amount,\\n        uint256 token1Amount,\\n        address market,\\n        uint256 exactInLp\\n    );\\n\\n    /**\\n     * @notice Gets a reference to the PendleData contract.\\n     * @return Returns the data contract reference.\\n     **/\\n    function data() external view returns (IPendleData);\\n\\n    /**\\n     * @notice Gets a reference of the WETH9 token contract address.\\n     * @return WETH token reference.\\n     **/\\n    function weth() external view returns (IWETH);\\n\\n    /***********\\n     *  FORGE  *\\n     ***********/\\n\\n    function newYieldContracts(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external returns (address ot, address xyt);\\n\\n    function redeemAfterExpiry(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external returns (uint256 redeemedAmount);\\n\\n    function redeemDueInterests(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry,\\n        address user\\n    ) external returns (uint256 interests);\\n\\n    function redeemUnderlying(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry,\\n        uint256 amountToRedeem\\n    ) external returns (uint256 redeemedAmount);\\n\\n    function renewYield(\\n        bytes32 forgeId,\\n        uint256 oldExpiry,\\n        address underlyingAsset,\\n        uint256 newExpiry,\\n        uint256 renewalRate\\n    )\\n        external\\n        returns (\\n            uint256 redeemedAmount,\\n            uint256 amountRenewed,\\n            address ot,\\n            address xyt,\\n            uint256 amountTokenMinted\\n        );\\n\\n    function tokenizeYield(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry,\\n        uint256 amountToTokenize,\\n        address to\\n    )\\n        external\\n        returns (\\n            address ot,\\n            address xyt,\\n            uint256 amountTokenMinted\\n        );\\n\\n    /***********\\n     *  MARKET *\\n     ***********/\\n\\n    function addMarketLiquidityDual(\\n        bytes32 _marketFactoryId,\\n        address _xyt,\\n        address _token,\\n        uint256 _desiredXytAmount,\\n        uint256 _desiredTokenAmount,\\n        uint256 _xytMinAmount,\\n        uint256 _tokenMinAmount\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountXytUsed,\\n            uint256 amountTokenUsed,\\n            uint256 lpOut\\n        );\\n\\n    function addMarketLiquiditySingle(\\n        bytes32 marketFactoryId,\\n        address xyt,\\n        address token,\\n        bool forXyt,\\n        uint256 exactInAsset,\\n        uint256 minOutLp\\n    ) external payable returns (uint256 exactOutLp);\\n\\n    function removeMarketLiquidityDual(\\n        bytes32 marketFactoryId,\\n        address xyt,\\n        address token,\\n        uint256 exactInLp,\\n        uint256 minOutXyt,\\n        uint256 minOutToken\\n    ) external returns (uint256 exactOutXyt, uint256 exactOutToken);\\n\\n    function removeMarketLiquiditySingle(\\n        bytes32 marketFactoryId,\\n        address xyt,\\n        address token,\\n        bool forXyt,\\n        uint256 exactInLp,\\n        uint256 minOutAsset\\n    ) external returns (uint256 exactOutXyt, uint256 exactOutToken);\\n\\n    /**\\n     * @notice Creates a market given a protocol ID, future yield token, and an ERC20 token.\\n     * @param marketFactoryId Market Factory identifier.\\n     * @param xyt Token address of the future yield token as base asset.\\n     * @param token Token address of an ERC20 token as quote asset.\\n     * @return market Returns the address of the newly created market.\\n     **/\\n    function createMarket(\\n        bytes32 marketFactoryId,\\n        address xyt,\\n        address token\\n    ) external returns (address market);\\n\\n    function bootstrapMarket(\\n        bytes32 marketFactoryId,\\n        address xyt,\\n        address token,\\n        uint256 initialXytLiquidity,\\n        uint256 initialTokenLiquidity\\n    ) external payable;\\n\\n    function swapExactIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 inTotalAmount,\\n        uint256 minOutTotalAmount,\\n        bytes32 marketFactoryId\\n    ) external payable returns (uint256 outTotalAmount);\\n\\n    function swapExactOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 outTotalAmount,\\n        uint256 maxInTotalAmount,\\n        bytes32 marketFactoryId\\n    ) external payable returns (uint256 inTotalAmount);\\n\\n    function redeemLpInterests(address market, address user) external returns (uint256 interests);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleRewardManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\n\\ninterface IPendleRewardManager {\\n    event UpdateFrequencySet(address[], uint256[]);\\n    event SkippingRewardsSet(bool);\\n\\n    event DueRewardsSettled(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry,\\n        uint256 amountOut,\\n        address user\\n    );\\n\\n    function redeemRewards(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user\\n    ) external returns (uint256 dueRewards);\\n\\n    function updatePendingRewards(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address _user\\n    ) external;\\n\\n    function updateParamLManual(address _underlyingAsset, uint256 _expiry) external;\\n\\n    function setUpdateFrequency(\\n        address[] calldata underlyingAssets,\\n        uint256[] calldata frequencies\\n    ) external;\\n\\n    function setSkippingRewards(bool skippingRewards) external;\\n\\n    function forgeId() external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleYieldContractDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\n\\ninterface IPendleYieldContractDeployer {\\n    function forgeId() external returns (bytes32);\\n\\n    function forgeOwnershipToken(\\n        address _underlyingAsset,\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint256 _expiry\\n    ) external returns (address ot);\\n\\n    function forgeFutureYieldToken(\\n        address _underlyingAsset,\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint256 _expiry\\n    ) external returns (address xyt);\\n\\n    function deployYieldTokenHolder(address yieldToken, uint256 expiry)\\n        external\\n        returns (address yieldTokenHolder);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IPendleRouter.sol\\\";\\nimport \\\"./IPendleYieldToken.sol\\\";\\nimport \\\"./IPendlePausingManager.sol\\\";\\nimport \\\"./IPendleMarket.sol\\\";\\n\\ninterface IPendleData {\\n    /**\\n     * @notice Emitted when validity of a forge-factory pair is updated\\n     * @param _forgeId the forge id\\n     * @param _marketFactoryId the market factory id\\n     * @param _valid valid or not\\n     **/\\n    event ForgeFactoryValiditySet(bytes32 _forgeId, bytes32 _marketFactoryId, bool _valid);\\n\\n    /**\\n     * @notice Emitted when Pendle and PendleFactory addresses have been updated.\\n     * @param treasury The address of the new treasury contract.\\n     **/\\n    event TreasurySet(address treasury);\\n\\n    /**\\n     * @notice Emitted when LockParams is changed\\n     **/\\n    event LockParamsSet(uint256 lockNumerator, uint256 lockDenominator);\\n\\n    /**\\n     * @notice Emitted when ExpiryDivisor is changed\\n     **/\\n    event ExpiryDivisorSet(uint256 expiryDivisor);\\n\\n    /**\\n     * @notice Emitted when forge fee is changed\\n     **/\\n    event ForgeFeeSet(uint256 forgeFee);\\n\\n    /**\\n     * @notice Emitted when interestUpdateRateDeltaForMarket is changed\\n     * @param interestUpdateRateDeltaForMarket new interestUpdateRateDeltaForMarket setting\\n     **/\\n    event InterestUpdateRateDeltaForMarketSet(uint256 interestUpdateRateDeltaForMarket);\\n\\n    /**\\n     * @notice Emitted when market fees are changed\\n     * @param _swapFee new swapFee setting\\n     * @param _protocolSwapFee new protocolSwapFee setting\\n     **/\\n    event MarketFeesSet(uint256 _swapFee, uint256 _protocolSwapFee);\\n\\n    /**\\n     * @notice Emitted when the curve shift block delta is changed\\n     * @param _blockDelta new block delta setting\\n     **/\\n    event CurveShiftBlockDeltaSet(uint256 _blockDelta);\\n\\n    /**\\n     * @dev Emitted when new forge is added\\n     * @param marketFactoryId Human Readable Market Factory ID in Bytes\\n     * @param marketFactoryAddress The Market Factory Address\\n     */\\n    event NewMarketFactory(bytes32 indexed marketFactoryId, address indexed marketFactoryAddress);\\n\\n    /**\\n     * @notice Set/update validity of a forge-factory pair\\n     * @param _forgeId the forge id\\n     * @param _marketFactoryId the market factory id\\n     * @param _valid valid or not\\n     **/\\n    function setForgeFactoryValidity(\\n        bytes32 _forgeId,\\n        bytes32 _marketFactoryId,\\n        bool _valid\\n    ) external;\\n\\n    /**\\n     * @notice Sets the PendleTreasury contract addresses.\\n     * @param newTreasury Address of new treasury contract.\\n     **/\\n    function setTreasury(address newTreasury) external;\\n\\n    /**\\n     * @notice Gets a reference to the PendleRouter contract.\\n     * @return Returns the router contract reference.\\n     **/\\n    function router() external view returns (IPendleRouter);\\n\\n    /**\\n     * @notice Gets a reference to the PendleRouter contract.\\n     * @return Returns the router contract reference.\\n     **/\\n    function pausingManager() external view returns (IPendlePausingManager);\\n\\n    /**\\n     * @notice Gets the treasury contract address where fees are being sent to.\\n     * @return Address of the treasury contract.\\n     **/\\n    function treasury() external view returns (address);\\n\\n    /***********\\n     *  FORGE  *\\n     ***********/\\n\\n    /**\\n     * @notice Emitted when a forge for a protocol is added.\\n     * @param forgeId Forge and protocol identifier.\\n     * @param forgeAddress The address of the added forge.\\n     **/\\n    event ForgeAdded(bytes32 indexed forgeId, address indexed forgeAddress);\\n\\n    /**\\n     * @notice Adds a new forge for a protocol.\\n     * @param forgeId Forge and protocol identifier.\\n     * @param forgeAddress The address of the added forge.\\n     **/\\n    function addForge(bytes32 forgeId, address forgeAddress) external;\\n\\n    /**\\n     * @notice Store new OT and XYT details.\\n     * @param forgeId Forge and protocol identifier.\\n     * @param ot The address of the new XYT.\\n     * @param xyt The address of the new XYT.\\n     * @param underlyingAsset Token address of the underlying asset.\\n     * @param expiry Yield contract expiry in epoch time.\\n     **/\\n    function storeTokens(\\n        bytes32 forgeId,\\n        address ot,\\n        address xyt,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external;\\n\\n    /**\\n     * @notice Set a new forge fee\\n     * @param _forgeFee new forge fee\\n     **/\\n    function setForgeFee(uint256 _forgeFee) external;\\n\\n    /**\\n     * @notice Gets the OT and XYT tokens.\\n     * @param forgeId Forge and protocol identifier.\\n     * @param underlyingYieldToken Token address of the underlying yield token.\\n     * @param expiry Yield contract expiry in epoch time.\\n     * @return ot The OT token references.\\n     * @return xyt The XYT token references.\\n     **/\\n    function getPendleYieldTokens(\\n        bytes32 forgeId,\\n        address underlyingYieldToken,\\n        uint256 expiry\\n    ) external view returns (IPendleYieldToken ot, IPendleYieldToken xyt);\\n\\n    /**\\n     * @notice Gets a forge given the identifier.\\n     * @param forgeId Forge and protocol identifier.\\n     * @return forgeAddress Returns the forge address.\\n     **/\\n    function getForgeAddress(bytes32 forgeId) external view returns (address forgeAddress);\\n\\n    /**\\n     * @notice Checks if an XYT token is valid.\\n     * @param forgeId The forgeId of the forge.\\n     * @param underlyingAsset Token address of the underlying asset.\\n     * @param expiry Yield contract expiry in epoch time.\\n     * @return True if valid, false otherwise.\\n     **/\\n    function isValidXYT(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Checks if an OT token is valid.\\n     * @param forgeId The forgeId of the forge.\\n     * @param underlyingAsset Token address of the underlying asset.\\n     * @param expiry Yield contract expiry in epoch time.\\n     * @return True if valid, false otherwise.\\n     **/\\n    function isValidOT(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external view returns (bool);\\n\\n    function validForgeFactoryPair(bytes32 _forgeId, bytes32 _marketFactoryId)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice Gets a reference to a specific OT.\\n     * @param forgeId Forge and protocol identifier.\\n     * @param underlyingYieldToken Token address of the underlying yield token.\\n     * @param expiry Yield contract expiry in epoch time.\\n     * @return ot Returns the reference to an OT.\\n     **/\\n    function otTokens(\\n        bytes32 forgeId,\\n        address underlyingYieldToken,\\n        uint256 expiry\\n    ) external view returns (IPendleYieldToken ot);\\n\\n    /**\\n     * @notice Gets a reference to a specific XYT.\\n     * @param forgeId Forge and protocol identifier.\\n     * @param underlyingAsset Token address of the underlying asset\\n     * @param expiry Yield contract expiry in epoch time.\\n     * @return xyt Returns the reference to an XYT.\\n     **/\\n    function xytTokens(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external view returns (IPendleYieldToken xyt);\\n\\n    /***********\\n     *  MARKET *\\n     ***********/\\n\\n    event MarketPairAdded(address indexed market, address indexed xyt, address indexed token);\\n\\n    function addMarketFactory(bytes32 marketFactoryId, address marketFactoryAddress) external;\\n\\n    function isMarket(address _addr) external view returns (bool result);\\n\\n    function isXyt(address _addr) external view returns (bool result);\\n\\n    function addMarket(\\n        bytes32 marketFactoryId,\\n        address xyt,\\n        address token,\\n        address market\\n    ) external;\\n\\n    function setMarketFees(uint256 _swapFee, uint256 _protocolSwapFee) external;\\n\\n    function setInterestUpdateRateDeltaForMarket(uint256 _interestUpdateRateDeltaForMarket)\\n        external;\\n\\n    function setLockParams(uint256 _lockNumerator, uint256 _lockDenominator) external;\\n\\n    function setExpiryDivisor(uint256 _expiryDivisor) external;\\n\\n    function setCurveShiftBlockDelta(uint256 _blockDelta) external;\\n\\n    /**\\n     * @notice Displays the number of markets currently existing.\\n     * @return Returns markets length,\\n     **/\\n    function allMarketsLength() external view returns (uint256);\\n\\n    function forgeFee() external view returns (uint256);\\n\\n    function interestUpdateRateDeltaForMarket() external view returns (uint256);\\n\\n    function expiryDivisor() external view returns (uint256);\\n\\n    function lockNumerator() external view returns (uint256);\\n\\n    function lockDenominator() external view returns (uint256);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function protocolSwapFee() external view returns (uint256);\\n\\n    function curveShiftBlockDelta() external view returns (uint256);\\n\\n    function getMarketByIndex(uint256 index) external view returns (address market);\\n\\n    /**\\n     * @notice Gets a market given a future yield token and an ERC20 token.\\n     * @param xyt Token address of the future yield token as base asset.\\n     * @param token Token address of an ERC20 token as quote asset.\\n     * @return market Returns the market address.\\n     **/\\n    function getMarket(\\n        bytes32 marketFactoryId,\\n        address xyt,\\n        address token\\n    ) external view returns (address market);\\n\\n    /**\\n     * @notice Gets a market factory given the identifier.\\n     * @param marketFactoryId MarketFactory identifier.\\n     * @return marketFactoryAddress Returns the factory address.\\n     **/\\n    function getMarketFactoryAddress(bytes32 marketFactoryId)\\n        external\\n        view\\n        returns (address marketFactoryAddress);\\n\\n    function getMarketFromKey(\\n        address xyt,\\n        address token,\\n        bytes32 marketFactoryId\\n    ) external view returns (address market);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PendleStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\nstruct TokenReserve {\\n    uint256 weight;\\n    uint256 balance;\\n}\\n\\nstruct PendingTransfer {\\n    uint256 amount;\\n    bool isOut;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleMarketFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IPendleRouter.sol\\\";\\n\\ninterface IPendleMarketFactory {\\n    /**\\n     * @notice Creates a market given a protocol ID, future yield token, and an ERC20 token.\\n     * @param xyt Token address of the futuonlyCorere yield token as base asset.\\n     * @param token Token address of an ERC20 token as quote asset.\\n     * @return market Returns the address of the newly created market.\\n     **/\\n    function createMarket(address xyt, address token) external returns (address market);\\n\\n    /**\\n     * @notice Gets a reference to the PendleRouter contract.\\n     * @return Returns the router contract reference.\\n     **/\\n    function router() external view returns (IPendleRouter);\\n\\n    function marketFactoryId() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleYieldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IPendleBaseToken.sol\\\";\\nimport \\\"./IPendleForge.sol\\\";\\n\\ninterface IPendleYieldToken is IERC20, IPendleBaseToken {\\n    /**\\n     * @notice Emitted when burning OT or XYT tokens.\\n     * @param user The address performing the burn.\\n     * @param amount The amount to be burned.\\n     **/\\n    event Burn(address indexed user, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when minting OT or XYT tokens.\\n     * @param user The address performing the mint.\\n     * @param amount The amount to be minted.\\n     **/\\n    event Mint(address indexed user, uint256 amount);\\n\\n    /**\\n     * @notice Burns OT or XYT tokens from user, reducing the total supply.\\n     * @param user The address performing the burn.\\n     * @param amount The amount to be burned.\\n     **/\\n    function burn(address user, uint256 amount) external;\\n\\n    /**\\n     * @notice Mints new OT or XYT tokens for user, increasing the total supply.\\n     * @param user The address to send the minted tokens.\\n     * @param amount The amount to be minted.\\n     **/\\n    function mint(address user, uint256 amount) external;\\n\\n    /**\\n     * @notice Gets the forge address of the PendleForge contract for this yield token.\\n     * @return Retuns the forge address.\\n     **/\\n    function forge() external view returns (IPendleForge);\\n\\n    /**\\n     * @notice Returns the address of the underlying asset.\\n     * @return Returns the underlying asset address.\\n     **/\\n    function underlyingAsset() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the underlying yield token.\\n     * @return Returns the underlying yield token address.\\n     **/\\n    function underlyingYieldToken() external view returns (address);\\n\\n    /**\\n     * @notice let the router approve itself to spend OT/XYT/LP from any wallet\\n     * @param user user to approve\\n     **/\\n    function approveRouter(address user) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendlePausingManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\n\\ninterface IPendlePausingManager {\\n    event AddPausingAdmin(address admin);\\n    event RemovePausingAdmin(address admin);\\n    event PendingForgeEmergencyHandler(address _pendingForgeHandler);\\n    event PendingMarketEmergencyHandler(address _pendingMarketHandler);\\n    event PendingLiqMiningEmergencyHandler(address _pendingLiqMiningHandler);\\n    event ForgeEmergencyHandlerSet(address forgeEmergencyHandler);\\n    event MarketEmergencyHandlerSet(address marketEmergencyHandler);\\n    event LiqMiningEmergencyHandlerSet(address liqMiningEmergencyHandler);\\n\\n    event PausingManagerLocked();\\n    event ForgeHandlerLocked();\\n    event MarketHandlerLocked();\\n    event LiqMiningHandlerLocked();\\n\\n    event SetForgePaused(bytes32 forgeId, bool settingToPaused);\\n    event SetForgeAssetPaused(bytes32 forgeId, address underlyingAsset, bool settingToPaused);\\n    event SetForgeAssetExpiryPaused(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry,\\n        bool settingToPaused\\n    );\\n\\n    event SetForgeLocked(bytes32 forgeId);\\n    event SetForgeAssetLocked(bytes32 forgeId, address underlyingAsset);\\n    event SetForgeAssetExpiryLocked(bytes32 forgeId, address underlyingAsset, uint256 expiry);\\n\\n    event SetMarketFactoryPaused(bytes32 marketFactoryId, bool settingToPaused);\\n    event SetMarketPaused(bytes32 marketFactoryId, address market, bool settingToPaused);\\n\\n    event SetMarketFactoryLocked(bytes32 marketFactoryId);\\n    event SetMarketLocked(bytes32 marketFactoryId, address market);\\n\\n    event SetLiqMiningPaused(address liqMiningContract, bool settingToPaused);\\n    event SetLiqMiningLocked(address liqMiningContract);\\n\\n    function forgeEmergencyHandler()\\n        external\\n        view\\n        returns (\\n            address handler,\\n            address pendingHandler,\\n            uint256 timelockDeadline\\n        );\\n\\n    function marketEmergencyHandler()\\n        external\\n        view\\n        returns (\\n            address handler,\\n            address pendingHandler,\\n            uint256 timelockDeadline\\n        );\\n\\n    function liqMiningEmergencyHandler()\\n        external\\n        view\\n        returns (\\n            address handler,\\n            address pendingHandler,\\n            uint256 timelockDeadline\\n        );\\n\\n    function permLocked() external view returns (bool);\\n\\n    function permForgeHandlerLocked() external view returns (bool);\\n\\n    function permMarketHandlerLocked() external view returns (bool);\\n\\n    function permLiqMiningHandlerLocked() external view returns (bool);\\n\\n    function isPausingAdmin(address) external view returns (bool);\\n\\n    function setPausingAdmin(address admin, bool isAdmin) external;\\n\\n    function requestForgeHandlerChange(address _pendingForgeHandler) external;\\n\\n    function requestMarketHandlerChange(address _pendingMarketHandler) external;\\n\\n    function requestLiqMiningHandlerChange(address _pendingLiqMiningHandler) external;\\n\\n    function applyForgeHandlerChange() external;\\n\\n    function applyMarketHandlerChange() external;\\n\\n    function applyLiqMiningHandlerChange() external;\\n\\n    function lockPausingManagerPermanently() external;\\n\\n    function lockForgeHandlerPermanently() external;\\n\\n    function lockMarketHandlerPermanently() external;\\n\\n    function lockLiqMiningHandlerPermanently() external;\\n\\n    function setForgePaused(bytes32 forgeId, bool paused) external;\\n\\n    function setForgeAssetPaused(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        bool paused\\n    ) external;\\n\\n    function setForgeAssetExpiryPaused(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry,\\n        bool paused\\n    ) external;\\n\\n    function setForgeLocked(bytes32 forgeId) external;\\n\\n    function setForgeAssetLocked(bytes32 forgeId, address underlyingAsset) external;\\n\\n    function setForgeAssetExpiryLocked(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external;\\n\\n    function checkYieldContractStatus(\\n        bytes32 forgeId,\\n        address underlyingAsset,\\n        uint256 expiry\\n    ) external returns (bool _paused, bool _locked);\\n\\n    function setMarketFactoryPaused(bytes32 marketFactoryId, bool paused) external;\\n\\n    function setMarketPaused(\\n        bytes32 marketFactoryId,\\n        address market,\\n        bool paused\\n    ) external;\\n\\n    function setMarketFactoryLocked(bytes32 marketFactoryId) external;\\n\\n    function setMarketLocked(bytes32 marketFactoryId, address market) external;\\n\\n    function checkMarketStatus(bytes32 marketFactoryId, address market)\\n        external\\n        returns (bool _paused, bool _locked);\\n\\n    function setLiqMiningPaused(address liqMiningContract, bool settingToPaused) external;\\n\\n    function setLiqMiningLocked(address liqMiningContract) external;\\n\\n    function checkLiqMiningStatus(address liqMiningContract)\\n        external\\n        returns (bool _paused, bool _locked);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IPendleRouter.sol\\\";\\nimport \\\"./IPendleBaseToken.sol\\\";\\nimport \\\"../libraries/PendleStructs.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPendleMarket is IERC20 {\\n    /**\\n     * @notice Emitted when reserves pool has been updated\\n     * @param reserve0 The XYT reserves.\\n     * @param weight0  The XYT weight\\n     * @param reserve1 The generic token reserves.\\n     * For the generic Token weight it can be inferred by (2^40) - weight0\\n     **/\\n    event Sync(uint256 reserve0, uint256 weight0, uint256 reserve1);\\n\\n    function setUpEmergencyMode(address spender) external;\\n\\n    function bootstrap(\\n        address user,\\n        uint256 initialXytLiquidity,\\n        uint256 initialTokenLiquidity\\n    ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);\\n\\n    function addMarketLiquiditySingle(\\n        address user,\\n        address inToken,\\n        uint256 inAmount,\\n        uint256 minOutLp\\n    ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);\\n\\n    function addMarketLiquidityDual(\\n        address user,\\n        uint256 _desiredXytAmount,\\n        uint256 _desiredTokenAmount,\\n        uint256 _xytMinAmount,\\n        uint256 _tokenMinAmount\\n    ) external returns (PendingTransfer[2] memory transfers, uint256 lpOut);\\n\\n    function removeMarketLiquidityDual(\\n        address user,\\n        uint256 inLp,\\n        uint256 minOutXyt,\\n        uint256 minOutToken\\n    ) external returns (PendingTransfer[2] memory transfers);\\n\\n    function removeMarketLiquiditySingle(\\n        address user,\\n        address outToken,\\n        uint256 exactInLp,\\n        uint256 minOutToken\\n    ) external returns (PendingTransfer[2] memory transfers);\\n\\n    function swapExactIn(\\n        address inToken,\\n        uint256 inAmount,\\n        address outToken,\\n        uint256 minOutAmount\\n    ) external returns (uint256 outAmount, PendingTransfer[2] memory transfers);\\n\\n    function swapExactOut(\\n        address inToken,\\n        uint256 maxInAmount,\\n        address outToken,\\n        uint256 outAmount\\n    ) external returns (uint256 inAmount, PendingTransfer[2] memory transfers);\\n\\n    function redeemLpInterests(address user) external returns (uint256 interests);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint256 xytBalance,\\n            uint256 xytWeight,\\n            uint256 tokenBalance,\\n            uint256 tokenWeight,\\n            uint256 currentBlock\\n        );\\n\\n    function factoryId() external view returns (bytes32);\\n\\n    function token() external view returns (address);\\n\\n    function xyt() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleBaseToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPendleBaseToken is IERC20 {\\n    /**\\n     * @notice Decreases the allowance granted to spender by the caller.\\n     * @param spender The address to reduce the allowance from.\\n     * @param subtractedValue The amount allowance to subtract.\\n     * @return Returns true if allowance has decreased, otherwise false.\\n     **/\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**\\n     * @notice The yield contract start in epoch time.\\n     * @return Returns the yield start date.\\n     **/\\n    function start() external view returns (uint256);\\n\\n    /**\\n     * @notice The yield contract expiry in epoch time.\\n     * @return Returns the yield expiry date.\\n     **/\\n    function expiry() external view returns (uint256);\\n\\n    /**\\n     * @notice Increases the allowance granted to spender by the caller.\\n     * @param spender The address to increase the allowance from.\\n     * @param addedValue The amount allowance to add.\\n     * @return Returns true if allowance has increased, otherwise false\\n     **/\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @notice Returns the number of decimals the token uses.\\n     * @return Returns the token's decimals.\\n     **/\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @notice Returns the name of the token.\\n     * @return Returns the token's name.\\n     **/\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the symbol of the token.\\n     * @return Returns the token's symbol.\\n     **/\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice approve using the owner's signature\\n     **/\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ExpiryUtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary ExpiryUtils {\\n    struct Date {\\n        uint16 year;\\n        uint8 month;\\n        uint8 day;\\n    }\\n\\n    uint256 private constant DAY_IN_SECONDS = 86400;\\n    uint256 private constant YEAR_IN_SECONDS = 31536000;\\n    uint256 private constant LEAP_YEAR_IN_SECONDS = 31622400;\\n    uint16 private constant ORIGIN_YEAR = 1970;\\n\\n    /**\\n     * @notice Concatenates a Pendle token name/symbol, a yield token name/symbol,\\n     *         and an expiry, using a delimiter (usually \\\"-\\\" or \\\" \\\").\\n     * @param _bt The Pendle token name/symbol.\\n     * @param _yt The yield token name/symbol.\\n     * @param _expiry The expiry in epoch time.\\n     * @param _delimiter Can be any delimiter, but usually \\\"-\\\" or \\\" \\\".\\n     * @return result Returns the concatenated string.\\n     **/\\n    function concat(\\n        string memory _bt,\\n        string memory _yt,\\n        uint256 _expiry,\\n        string memory _delimiter\\n    ) internal pure returns (string memory result) {\\n        result = string(\\n            abi.encodePacked(_bt, _delimiter, _yt, _delimiter, toRFC2822String(_expiry))\\n        );\\n    }\\n\\n    function toRFC2822String(uint256 _timestamp) internal pure returns (string memory s) {\\n        Date memory d = parseTimestamp(_timestamp);\\n        string memory day = uintToString(d.day);\\n        string memory month = monthName(d);\\n        string memory year = uintToString(d.year);\\n        s = string(abi.encodePacked(day, month, year));\\n    }\\n\\n    function getDaysInMonth(uint8 _month, uint16 _year) private pure returns (uint8) {\\n        if (\\n            _month == 1 ||\\n            _month == 3 ||\\n            _month == 5 ||\\n            _month == 7 ||\\n            _month == 8 ||\\n            _month == 10 ||\\n            _month == 12\\n        ) {\\n            return 31;\\n        } else if (_month == 4 || _month == 6 || _month == 9 || _month == 11) {\\n            return 30;\\n        } else if (isLeapYear(_year)) {\\n            return 29;\\n        } else {\\n            return 28;\\n        }\\n    }\\n\\n    function getYear(uint256 _timestamp) private pure returns (uint16) {\\n        uint256 secondsAccountedFor = 0;\\n        uint16 year;\\n        uint256 numLeapYears;\\n\\n        // Year\\n        year = uint16(ORIGIN_YEAR + _timestamp / YEAR_IN_SECONDS);\\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n\\n        while (secondsAccountedFor > _timestamp) {\\n            if (isLeapYear(uint16(year - 1))) {\\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n            } else {\\n                secondsAccountedFor -= YEAR_IN_SECONDS;\\n            }\\n            year -= 1;\\n        }\\n        return year;\\n    }\\n\\n    function isLeapYear(uint16 _year) private pure returns (bool) {\\n        return ((_year % 4 == 0) && (_year % 100 != 0)) || (_year % 400 == 0);\\n    }\\n\\n    function leapYearsBefore(uint256 _year) private pure returns (uint256) {\\n        _year -= 1;\\n        return _year / 4 - _year / 100 + _year / 400;\\n    }\\n\\n    function monthName(Date memory d) private pure returns (string memory) {\\n        string[12] memory months =\\n            [\\\"JAN\\\", \\\"FEB\\\", \\\"MAR\\\", \\\"APR\\\", \\\"MAY\\\", \\\"JUN\\\", \\\"JUL\\\", \\\"AUG\\\", \\\"SEP\\\", \\\"OCT\\\", \\\"NOV\\\", \\\"DEC\\\"];\\n        return months[d.month - 1];\\n    }\\n\\n    function parseTimestamp(uint256 _timestamp) private pure returns (Date memory d) {\\n        uint256 secondsAccountedFor = 0;\\n        uint256 buf;\\n        uint8 i;\\n\\n        // Year\\n        d.year = getYear(_timestamp);\\n        buf = leapYearsBefore(d.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (d.year - ORIGIN_YEAR - buf);\\n\\n        // Month\\n        uint256 secondsInMonth;\\n        for (i = 1; i <= 12; i++) {\\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, d.year);\\n            if (secondsInMonth + secondsAccountedFor > _timestamp) {\\n                d.month = i;\\n                break;\\n            }\\n            secondsAccountedFor += secondsInMonth;\\n        }\\n\\n        // Day\\n        for (i = 1; i <= getDaysInMonth(d.month, d.year); i++) {\\n            if (DAY_IN_SECONDS + secondsAccountedFor > _timestamp) {\\n                d.day = i;\\n                break;\\n            }\\n            secondsAccountedFor += DAY_IN_SECONDS;\\n        }\\n    }\\n\\n    function uintToString(uint256 _i) private pure returns (string memory) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleForgeV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IPendleForge.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPendleForgeV2 is IPendleForge {\\n    function setUpEmergencyModeV2(\\n        address _underlyingAsset,\\n        uint256 _expiry,\\n        address spender,\\n        bool extraFlag\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleYieldContractDeployerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\n\\ninterface IPendleYieldContractDeployerV2 {\\n    function forgeId() external returns (bytes32);\\n\\n    function forgeOwnershipToken(\\n        address underlyingAsset,\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals,\\n        uint256 expiry\\n    ) external returns (address ot);\\n\\n    function forgeFutureYieldToken(\\n        address underlyingAsset,\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals,\\n        uint256 expiry\\n    ) external returns (address xyt);\\n\\n    function deployYieldTokenHolder(\\n        address yieldToken,\\n        uint256 expiry,\\n        uint256[] calldata container\\n    ) external returns (address yieldTokenHolder);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleYieldTokenHolderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\n\\nimport \\\"./IPendleYieldTokenHolder.sol\\\";\\n\\ninterface IPendleYieldTokenHolderV2 is IPendleYieldTokenHolder {\\n    function setUpEmergencyModeV2(address spender, bool extraFlag) external;\\n\\n    function pushYieldTokens(\\n        address to,\\n        uint256 amount,\\n        uint256 minNYieldAfterPush\\n    ) external;\\n\\n    function afterReceiveTokens(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/WithdrawableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./PermissionsV2.sol\\\";\\n\\nabstract contract WithdrawableV2 is PermissionsV2 {\\n    using SafeERC20 for IERC20;\\n\\n    event EtherWithdraw(uint256 amount, address sendTo);\\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\\n\\n    /**\\n     * @dev Allows governance to withdraw Ether in a Pendle contract\\n     *      in case of accidental ETH transfer into the contract.\\n     * @param amount The amount of Ether to withdraw.\\n     * @param sendTo The recipient address.\\n     */\\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyGovernance {\\n        (bool success, ) = sendTo.call{value: amount}(\\\"\\\");\\n        require(success, \\\"WITHDRAW_FAILED\\\");\\n        emit EtherWithdraw(amount, sendTo);\\n    }\\n\\n    /**\\n     * @dev Allows governance to withdraw all IERC20 compatible tokens in a Pendle\\n     *      contract in case of accidental token transfer into the contract.\\n     * @param token IERC20 The address of the token contract.\\n     * @param amount The amount of IERC20 tokens to withdraw.\\n     * @param sendTo The recipient address.\\n     */\\n    function withdrawToken(\\n        IERC20 token,\\n        uint256 amount,\\n        address sendTo\\n    ) external onlyGovernance {\\n        require(_allowedToWithdraw(address(token)), \\\"TOKEN_NOT_ALLOWED\\\");\\n        token.safeTransfer(sendTo, amount);\\n        emit TokenWithdraw(token, amount, sendTo);\\n    }\\n\\n    // must be overridden by the sub contracts, so we must consider explicitly\\n    // in each and every contract which tokens are allowed to be withdrawn\\n    function _allowedToWithdraw(address) internal view virtual returns (bool allowed);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary Math {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant BIG_NUMBER = (uint256(1) << uint256(200));\\n    uint256 internal constant PRECISION_BITS = 40;\\n    uint256 internal constant RONE = uint256(1) << PRECISION_BITS;\\n    uint256 internal constant PI = (314 * RONE) / 10**2;\\n    uint256 internal constant PI_PLUSONE = (414 * RONE) / 10**2;\\n    uint256 internal constant PRECISION_POW = 1e2;\\n\\n    function checkMultOverflow(uint256 _x, uint256 _y) internal pure returns (bool) {\\n        if (_y == 0) return false;\\n        return (((_x * _y) / _y) != _x);\\n    }\\n\\n    /**\\n    @notice find the integer part of log2(p/q)\\n        => find largest x s.t p >= q * 2^x\\n        => find largest x s.t 2^x <= p / q\\n     */\\n    function log2Int(uint256 _p, uint256 _q) internal pure returns (uint256) {\\n        uint256 res = 0;\\n        uint256 remain = _p / _q;\\n        while (remain > 0) {\\n            res++;\\n            remain /= 2;\\n        }\\n        return res - 1;\\n    }\\n\\n    /**\\n    @notice log2 for a number that it in [1,2)\\n    @dev _x is FP, return a FP\\n    @dev function is from Kyber. Long modified the condition to be (_x >= one) && (_x < two)\\n    to avoid the case where x = 2 may lead to incorrect result\\n     */\\n    function log2ForSmallNumber(uint256 _x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n        uint256 one = (uint256(1) << PRECISION_BITS);\\n        uint256 two = 2 * one;\\n        uint256 addition = one;\\n\\n        require((_x >= one) && (_x < two), \\\"MATH_ERROR\\\");\\n        require(PRECISION_BITS < 125, \\\"MATH_ERROR\\\");\\n\\n        for (uint256 i = PRECISION_BITS; i > 0; i--) {\\n            _x = (_x * _x) / one;\\n            addition = addition / 2;\\n            if (_x >= two) {\\n                _x = _x / 2;\\n                res += addition;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n    @notice log2 of (p/q). returns result in FP form\\n    @dev function is from Kyber.\\n    @dev _p & _q is FP, return a FP\\n     */\\n    function logBase2(uint256 _p, uint256 _q) internal pure returns (uint256) {\\n        uint256 n = 0;\\n\\n        if (_p > _q) {\\n            n = log2Int(_p, _q);\\n        }\\n\\n        require(n * RONE <= BIG_NUMBER, \\\"MATH_ERROR\\\");\\n        require(!checkMultOverflow(_p, RONE), \\\"MATH_ERROR\\\");\\n        require(!checkMultOverflow(n, RONE), \\\"MATH_ERROR\\\");\\n        require(!checkMultOverflow(uint256(1) << n, _q), \\\"MATH_ERROR\\\");\\n\\n        uint256 y = (_p * RONE) / (_q * (uint256(1) << n));\\n        uint256 log2Small = log2ForSmallNumber(y);\\n\\n        assert(log2Small <= BIG_NUMBER);\\n\\n        return n * RONE + log2Small;\\n    }\\n\\n    /**\\n    @notice calculate ln(p/q). returned result >= 0\\n    @dev function is from Kyber.\\n    @dev _p & _q is FP, return a FP\\n    */\\n    function ln(uint256 p, uint256 q) internal pure returns (uint256) {\\n        uint256 ln2Numerator = 6931471805599453094172;\\n        uint256 ln2Denomerator = 10000000000000000000000;\\n\\n        uint256 log2x = logBase2(p, q);\\n\\n        require(!checkMultOverflow(ln2Numerator, log2x), \\\"MATH_ERROR\\\");\\n\\n        return (ln2Numerator * log2x) / ln2Denomerator;\\n    }\\n\\n    /**\\n    @notice extract the fractional part of a FP\\n    @dev value is a FP, return a FP\\n     */\\n    function fpart(uint256 value) internal pure returns (uint256) {\\n        return value % RONE;\\n    }\\n\\n    /**\\n    @notice convert a FP to an Int\\n    @dev value is a FP, return an Int\\n     */\\n    function toInt(uint256 value) internal pure returns (uint256) {\\n        return value / RONE;\\n    }\\n\\n    /**\\n    @notice convert an Int to a FP\\n    @dev value is an Int, return a FP\\n     */\\n    function toFP(uint256 value) internal pure returns (uint256) {\\n        return value * RONE;\\n    }\\n\\n    /**\\n    @notice return e^exp in FP form\\n    @dev estimation by formula at http://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap04/exp.html\\n        the function is based on exp function of:\\n        https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol\\n    @dev the function is expected to converge quite fast, after about 20 iteration\\n    @dev exp is a FP, return a FP\\n     */\\n    function rpowe(uint256 exp) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 curTerm = RONE;\\n\\n        for (uint256 n = 0; ; n++) {\\n            res += curTerm;\\n            curTerm = rmul(curTerm, rdiv(exp, toFP(n + 1)));\\n            if (curTerm == 0) {\\n                break;\\n            }\\n            if (n == 500) {\\n                /*\\n                testing shows that in the most extreme case, it will take 430 turns to converge.\\n                however, it's expected that the numbers will not exceed 2^120 in normal situation\\n                the most extreme case is rpow((1<<256)-1,(1<<40)-1) (equal to rpow((2^256-1)/2^40,0.99..9))\\n                */\\n                revert(\\\"RPOWE_SLOW_CONVERGE\\\");\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n    @notice calculate base^exp with base and exp being FP int\\n    @dev to improve accuracy, base^exp = base^(int(exp)+frac(exp))\\n                                       = base^int(exp) * base^frac\\n    @dev base & exp are FP, return a FP\\n     */\\n    function rpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n        if (exp == 0) {\\n            // Anything to the 0 is 1\\n            return RONE;\\n        }\\n        if (base == 0) {\\n            // 0 to anything except 0 is 0\\n            return 0;\\n        }\\n\\n        uint256 frac = fpart(exp); // get the fractional part\\n        uint256 whole = exp - frac;\\n\\n        uint256 wholePow = rpowi(base, toInt(whole)); // whole is a FP, convert to Int\\n        uint256 fracPow;\\n\\n        // instead of calculating base ^ frac, we will calculate e ^ (frac*ln(base))\\n        if (base < RONE) {\\n            /* since the base is smaller than 1.0, ln(base) < 0.\\n            Since 1 / (e^(frac*ln(1/base))) = e ^ (frac*ln(base)),\\n            we will calculate 1 / (e^(frac*ln(1/base))) instead.\\n            */\\n            uint256 newExp = rmul(frac, ln(rdiv(RONE, base), RONE));\\n            fracPow = rdiv(RONE, rpowe(newExp));\\n        } else {\\n            /* base is greater than 1, calculate normally */\\n            uint256 newExp = rmul(frac, ln(base, RONE));\\n            fracPow = rpowe(newExp);\\n        }\\n        return rmul(wholePow, fracPow);\\n    }\\n\\n    /**\\n    @notice return base^exp with base in FP form and exp in Int\\n    @dev this function use a technique called: exponentiating by squaring\\n        complexity O(log(q))\\n    @dev function is from Kyber.\\n    @dev base is a FP, exp is an Int, return a FP\\n     */\\n    function rpowi(uint256 base, uint256 exp) internal pure returns (uint256) {\\n        uint256 res = exp % 2 != 0 ? base : RONE;\\n\\n        for (exp /= 2; exp != 0; exp /= 2) {\\n            base = rmul(base, base);\\n\\n            if (exp % 2 != 0) {\\n                res = rmul(res, base);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    /**\\n    @dev y is an Int, returns an Int\\n    @dev babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    @dev from Uniswap\\n     */\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    /**\\n    @notice divide 2 FP, return a FP\\n    @dev function is from Balancer.\\n    @dev x & y are FP, return a FP\\n     */\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return (y / 2).add(x.mul(RONE)).div(y);\\n    }\\n\\n    /**\\n    @notice multiply 2 FP, return a FP\\n    @dev function is from Balancer.\\n    @dev x & y are FP, return a FP\\n     */\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return (RONE / 2).add(x.mul(y)).div(RONE);\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a - b : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TokenUtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.7.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary TokenUtils {\\n    function requireERC20(address tokenAddr) internal view {\\n        require(IERC20(tokenAddr).totalSupply() > 0, \\\"INVALID_ERC20\\\");\\n    }\\n\\n    function requireERC20(IERC20 token) internal view {\\n        require(token.totalSupply() > 0, \\\"INVALID_ERC20\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPendleYieldTokenHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.7.6;\\n\\ninterface IPendleYieldTokenHolder {\\n    function redeemRewards() external;\\n\\n    function setUpEmergencyMode(address spender) external;\\n\\n    function yieldToken() external returns (address);\\n\\n    function forge() external returns (address);\\n\\n    function rewardToken() external returns (address);\\n\\n    function expiry() external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/PermissionsV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../core/PendleGovernanceManager.sol\\\";\\nimport \\\"../interfaces/IPermissionsV2.sol\\\";\\n\\nabstract contract PermissionsV2 is IPermissionsV2 {\\n    PendleGovernanceManager public immutable override governanceManager;\\n    address internal initializer;\\n\\n    constructor(address _governanceManager) {\\n        require(_governanceManager != address(0), \\\"ZERO_ADDRESS\\\");\\n        initializer = msg.sender;\\n        governanceManager = PendleGovernanceManager(_governanceManager);\\n    }\\n\\n    modifier initialized() {\\n        require(initializer == address(0), \\\"NOT_INITIALIZED\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == _governance(), \\\"ONLY_GOVERNANCE\\\");\\n        _;\\n    }\\n\\n    function _governance() internal view returns (address) {\\n        return governanceManager.governance();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/PendleGovernanceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\n\\ncontract PendleGovernanceManager {\\n    address public governance;\\n    address public pendingGovernance;\\n\\n    event GovernanceClaimed(address newGovernance, address previousGovernance);\\n\\n    event TransferGovernancePending(address pendingGovernance);\\n\\n    constructor(address _governance) {\\n        require(_governance != address(0), \\\"ZERO_ADDRESS\\\");\\n        governance = _governance;\\n    }\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == governance, \\\"ONLY_GOVERNANCE\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingGovernance address to finalize the change governance process.\\n     */\\n    function claimGovernance() external {\\n        require(pendingGovernance == msg.sender, \\\"WRONG_GOVERNANCE\\\");\\n        emit GovernanceClaimed(pendingGovernance, governance);\\n        governance = pendingGovernance;\\n        pendingGovernance = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current governance to set the pendingGovernance address.\\n     * @param _governance The address to transfer ownership to.\\n     */\\n    function transferGovernance(address _governance) external onlyGovernance {\\n        require(_governance != address(0), \\\"ZERO_ADDRESS\\\");\\n        pendingGovernance = _governance;\\n\\n        emit TransferGovernancePending(pendingGovernance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermissionsV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../core/PendleGovernanceManager.sol\\\";\\n\\ninterface IPermissionsV2 {\\n    function governanceManager() external returns (PendleGovernanceManager);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governanceManager\",\"type\":\"address\"},{\"internalType\":\"contract IPendleRouter\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_forgeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldContractDeployer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_codeHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_pairFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"forgeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forgeFeeAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"DueInterestsSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"forgeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ForgeFeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"forgeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToTokenize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokenMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"MintYieldTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"forgeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"xyt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"yieldBearingAsset\",\"type\":\"address\"}],\"name\":\"NewYieldContracts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"forgeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToRedeem\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemedAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RedeemYieldToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"forgeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"container\",\"type\":\"uint256[]\"}],\"name\":\"RegisterTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"codeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"internalType\":\"contract IPendleData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dueInterests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forgeId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"}],\"name\":\"getExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"}],\"name\":\"getYieldBearingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"yieldBearingToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceManager\",\"outputs\":[{\"internalType\":\"contract PendleGovernanceManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastRateBeforeExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRateForUnderlyingAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountToTokenize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mintOtAndXyt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xyt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"newYieldContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xyt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausingManager\",\"outputs\":[{\"internalType\":\"contract IPendlePausingManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"redeemAfterExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"redeemDueInterests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountToRedeem\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_underlyingAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_tokenInfos\",\"type\":\"uint256[][]\"}],\"name\":\"registerTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardManager\",\"outputs\":[{\"internalType\":\"contract IPendleRewardManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPendleRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"setUpEmergencyMode\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"extraFlag\",\"type\":\"bool\"}],\"name\":\"setUpEmergencyModeV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"updateDueInterests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"updatePendingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenInfo\",\"type\":\"uint256[]\"}],\"name\":\"verifyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"withdrawForgeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldContractDeployer\",\"outputs\":[{\"internalType\":\"contract IPendleYieldContractDeployer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"yieldTokenHolders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PendleSushiswapSimpleForge","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009b528bf0639fc31ae6d698c48d830873227741f10000000000000000000000001b6d3e5da9004668e14ca39d1553e9a46fe842b353757368697377617053696d706c6500000000000000000000000000000000000000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe20000000000000000000000005f183210d58eba0812a2c33888786e7028b4e6870000000000000000000000003714e5d5a32fdc16e3e6fee6788afc3ac9eb5762e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}