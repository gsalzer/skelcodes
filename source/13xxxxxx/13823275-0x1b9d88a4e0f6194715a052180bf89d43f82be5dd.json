{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/allocators/FxsAllocator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    return c;\\n  }\\n}\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies in extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return _functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function _functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 weiValue,\\n    string memory errorMessage\\n  ) private returns (bytes memory) {\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\\n      data\\n    );\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\\ninterface IERC20 {\\n  function decimals() external view returns (uint8);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    bytes memory returndata = address(token).functionCall(\\n      data,\\n      \\\"SafeERC20: low-level call failed\\\"\\n    );\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(\\n        abi.decode(returndata, (bool)),\\n        \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n      );\\n    }\\n  }\\n}\\n\\ninterface IveFXS {\\n  struct LockedBalance {\\n    int128 amount;\\n    uint256 end;\\n  }\\n\\n  function commit_transfer_ownership(address addr) external;\\n\\n  function apply_transfer_ownership() external;\\n\\n  function commit_smart_wallet_checker(address addr) external;\\n\\n  function apply_smart_wallet_checker() external;\\n\\n  function toggleEmergencyUnlock() external;\\n\\n  function recoverERC20(address token_addr, uint256 amount) external;\\n\\n  function get_last_user_slope(address addr) external view returns (int128);\\n\\n  function user_point_history__ts(address _addr, uint256 _idx)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function locked__end(address _addr) external view returns (uint256);\\n\\n  function checkpoint() external;\\n\\n  function deposit_for(address _addr, uint256 _value) external;\\n\\n  function create_lock(uint256 _value, uint256 _unlock_time) external;\\n\\n  function increase_amount(uint256 _value) external;\\n\\n  function increase_unlock_time(uint256 _unlock_time) external;\\n\\n  function withdraw() external;\\n\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  function balanceOf(address addr, uint256 _t) external view returns (uint256);\\n\\n  function balanceOfAt(address addr, uint256 _block)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function totalSupply(uint256 t) external view returns (uint256);\\n\\n  function totalSupplyAt(uint256 _block) external view returns (uint256);\\n\\n  function totalFXSSupply() external view returns (uint256);\\n\\n  function totalFXSSupplyAt(uint256 _block) external view returns (uint256);\\n\\n  function changeController(address _newController) external;\\n\\n  function token() external view returns (address);\\n\\n  function supply() external view returns (uint256);\\n\\n  function locked(address addr) external view returns (LockedBalance memory);\\n\\n  function epoch() external view returns (uint256);\\n\\n  function point_history(uint256 arg0)\\n    external\\n    view\\n    returns (\\n      int128 bias,\\n      int128 slope,\\n      uint256 ts,\\n      uint256 blk,\\n      uint256 fxs_amt\\n    );\\n\\n  function user_point_history(address arg0, uint256 arg1)\\n    external\\n    view\\n    returns (\\n      int128 bias,\\n      int128 slope,\\n      uint256 ts,\\n      uint256 blk,\\n      uint256 fxs_amt\\n    );\\n\\n  function user_point_epoch(address arg0) external view returns (uint256);\\n\\n  function slope_changes(uint256 arg0) external view returns (int128);\\n\\n  function controller() external view returns (address);\\n\\n  function transfersEnabled() external view returns (bool);\\n\\n  function emergencyUnlockActive() external view returns (bool);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function version() external view returns (string memory);\\n\\n  function decimals() external view returns (uint256);\\n\\n  function future_smart_wallet_checker() external view returns (address);\\n\\n  function smart_wallet_checker() external view returns (address);\\n\\n  function admin() external view returns (address);\\n\\n  function future_admin() external view returns (address);\\n}\\n\\ninterface IYieldDistributor {\\n  function getYield() external returns (uint256);\\n\\n  function checkpoint() external;\\n}\\n\\ninterface IFraxGaugeController {\\n  function vote_for_gauge_weights(address, uint256) external;\\n}\\n\\ninterface IDelegateRegistry {\\n  function setDelegate(bytes32 id, address delegate) external;\\n\\n  function clearDelegate(bytes32 id) external;\\n}\\n\\ninterface ITreasury {\\n  function manage(address _token, uint256 _amount) external;\\n\\n  function updateReserve(address _token, uint256 _amount) external;\\n}\\n\\ncontract FxsAllocator {\\n  using SafeERC20 for IERC20;\\n  using Address for address;\\n  using SafeMath for uint256;\\n\\n  address public policy;\\n  address public treasury;\\n\\n  address public constant fxs =\\n    address(0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0);\\n\\n  address public constant veFXS =\\n    address(0xc8418aF6358FFddA74e09Ca9CC3Fe03Ca6aDC5b0);\\n\\n  address public yieldDistributor =\\n    address(0xc6764e58b36e26b08Fd1d2AeD4538c02171fA872);\\n\\n  address public gaugeController =\\n    address(0x44ade9AA409B0C29463fF7fcf07c9d3c939166ce);\\n\\n  address public snapshotDelegationRegistry =\\n    address(0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446);\\n\\n  constructor(address _treasury) public {\\n    policy = msg.sender;\\n    treasury = _treasury;\\n  }\\n\\n  modifier onlyPolicy() {\\n    require(msg.sender == policy, \\\"!policy\\\");\\n    _;\\n  }\\n\\n  function deposit(uint256 _amount) external onlyPolicy {\\n    ITreasury(treasury).manage(fxs, _amount);\\n    increaseAmount(_amount);\\n  }\\n\\n  function withdraw() external onlyPolicy {\\n    IYieldDistributor(yieldDistributor).getYield();\\n    IveFXS(veFXS).withdraw();\\n\\n    uint256 amount = IERC20(fxs).balanceOf(address(this));\\n    IERC20(fxs).safeTransfer(treasury, amount);\\n  }\\n\\n  function createLock(uint256 _value, uint256 _unlockTime) external onlyPolicy {\\n    IERC20(fxs).approve(veFXS, 0);\\n    IERC20(fxs).approve(veFXS, _value);\\n    IveFXS(veFXS).create_lock(_value, _unlockTime);\\n    IYieldDistributor(yieldDistributor).checkpoint();\\n  }\\n\\n  function increaseAmount(uint256 _value) internal {\\n    IERC20(fxs).approve(veFXS, 0);\\n    IERC20(fxs).approve(veFXS, _value);\\n    IveFXS(veFXS).increase_amount(_value);\\n    IYieldDistributor(yieldDistributor).checkpoint();\\n  }\\n\\n  function increaseUnlockTime(uint256 _unlockTime) external onlyPolicy {\\n    IveFXS(veFXS).increase_unlock_time(_unlockTime);\\n    IYieldDistributor(yieldDistributor).checkpoint();\\n  }\\n\\n  function claimRewards() external onlyPolicy {\\n    IYieldDistributor(yieldDistributor).getYield();\\n    increaseAmount(IERC20(fxs).balanceOf(address(this)));\\n  }\\n\\n  function voteGaugeWeight(address _gauge, uint256 _weight)\\n    external\\n    onlyPolicy\\n  {\\n    IFraxGaugeController(gaugeController).vote_for_gauge_weights(\\n      _gauge,\\n      _weight\\n    );\\n  }\\n\\n  function setDelegateSnapshotVoting(bytes32 _id, address _delegate)\\n    external\\n    onlyPolicy\\n  {\\n    IDelegateRegistry(snapshotDelegationRegistry).setDelegate(_id, _delegate);\\n  }\\n\\n  function clearDelegateSnapshotVoting(bytes32 _id) external onlyPolicy {\\n    IDelegateRegistry(snapshotDelegationRegistry).clearDelegate(_id);\\n  }\\n\\n  function setGovernance(address _policy) external onlyPolicy {\\n    policy = _policy;\\n  }\\n\\n  function setTreasury(address _treasury) external onlyPolicy {\\n    treasury = _treasury;\\n  }\\n\\n  function setYieldDistributor(address _newYieldDistributor)\\n    external\\n    onlyPolicy\\n  {\\n    yieldDistributor = _newYieldDistributor;\\n  }\\n\\n  function setGaugeController(address _gaugeController) external onlyPolicy {\\n    gaugeController = _gaugeController;\\n  }\\n\\n  function execute(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external onlyPolicy returns (bool, bytes memory) {\\n    (bool success, bytes memory result) = to.call{value: value}(data);\\n    return (success, result);\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"clearDelegateSnapshotVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"}],\"name\":\"createLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"}],\"name\":\"increaseUnlockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"setDelegateSnapshotVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gaugeController\",\"type\":\"address\"}],\"name\":\"setGaugeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newYieldDistributor\",\"type\":\"address\"}],\"name\":\"setYieldDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshotDelegationRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veFXS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"voteGaugeWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FxsAllocator","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000873ad91fa4f2aa0d557c0919ec3f6c9d240cdd05","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}