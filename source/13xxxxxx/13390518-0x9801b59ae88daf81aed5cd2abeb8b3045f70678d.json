{"status":"1","message":"OK","result":[{"SourceCode":"{\"TeleportToken.sol\":{\"content\":\"pragma solidity ^0.8.6;\\n/*\\n * SPDX-License-Identifier: MIT\\n */\\npragma experimental ABIEncoderV2;\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\n\\ncontract Verify {\\n\\n  function recoverSigner(bytes32 message, bytes memory sig)\\n       public\\n       pure\\n       returns (address)\\n    {\\n       uint8 v;\\n       bytes32 r;\\n       bytes32 s;\\n\\n       (v, r, s) = splitSignature(sig);\\n\\n       if (v != 27 \\u0026\\u0026 v != 28) {\\n           return (address(0));\\n       } else {\\n           // solium-disable-next-line arg-overflow\\n           return ecrecover(message, v, r, s);\\n       }\\n  }\\n\\n  function splitSignature(bytes memory sig)\\n       public\\n       pure\\n       returns (uint8, bytes32, bytes32)\\n   {\\n       require(sig.length == 65);\\n\\n       bytes32 r;\\n       bytes32 s;\\n       uint8 v;\\n\\n       assembly {\\n           // first 32 bytes, after the length prefix\\n           r := mload(add(sig, 32))\\n           // second 32 bytes\\n           s := mload(add(sig, 64))\\n           // final byte (first byte of the next 32 bytes)\\n           v := byte(0, mload(add(sig, 96)))\\n       }\\n\\n       if (v \\u003c 27)\\n           v += 27;\\n\\n       return (v, r, s);\\n   }\\n}\\n\\n\\nlibrary Endian {\\n    /* https://ethereum.stackexchange.com/questions/83626/how-to-reverse-byte-order-in-uint256-or-bytes32 */\\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v \\u0026 0xFF00FF00FF00FF00) \\u003e\\u003e 8) |\\n            ((v \\u0026 0x00FF00FF00FF00FF) \\u003c\\u003c 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v \\u0026 0xFFFF0000FFFF0000) \\u003e\\u003e 16) |\\n            ((v \\u0026 0x0000FFFF0000FFFF) \\u003c\\u003c 16);\\n\\n        // swap 4-byte long pairs\\n        v = (v \\u003e\\u003e 32) | (v \\u003c\\u003c 32);\\n    }\\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v \\u0026 0xFF00FF00) \\u003e\\u003e 8) |\\n            ((v \\u0026 0x00FF00FF) \\u003c\\u003c 8);\\n\\n        // swap 2-byte long pairs\\n        v = (v \\u003e\\u003e 16) | (v \\u003c\\u003c 16);\\n    }\\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = (v \\u003e\\u003e 8) | (v \\u003c\\u003c 8);\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n// Safe maths\\n// ----------------------------------------------------------------------------\\nlibrary SafeMath {\\n    function add(uint a, uint b) internal pure returns (uint c) {\\n        c = a + b;\\n        require(c \\u003e= a);\\n    }\\n    function sub(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003c= a);\\n        c = a - b;\\n    }\\n    function mul(uint a, uint b) internal pure returns (uint c) {\\n        c = a * b;\\n        require(a == 0 || c / a == b);\\n    }\\n    function div(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003e 0);\\n        c = a / b;\\n    }\\n}\\n\\n\\n// ----------------------------------------------------------------------------\\n// ERC Token Standard #20 Interface\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n// ----------------------------------------------------------------------------\\nabstract contract ERC20Interface {\\n    function totalSupply() virtual public view returns (uint);\\n    function balanceOf(address tokenOwner) virtual public view returns (uint balance);\\n    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\\n    function transfer(address to, uint tokens) virtual public returns (bool success);\\n    function approve(address spender, uint tokens) virtual public returns (bool success);\\n    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\\n\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n}\\n\\n\\n// ----------------------------------------------------------------------------\\n// Contract function to receive approval and execute function in one call\\n//\\n// Borrowed from MiniMeToken\\n// ----------------------------------------------------------------------------\\nabstract contract ApproveAndCallFallBack {\\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;\\n}\\n\\n\\n// ----------------------------------------------------------------------------\\n// Owned contract\\n// ----------------------------------------------------------------------------\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        newOwner = _newOwner;\\n    }\\n\\n    function acceptOwnership() public {\\n        require(msg.sender == newOwner);\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\\n\\n\\ncontract Oracled is Owned {\\n    mapping(address =\\u003e bool) public oracles;\\n    address[] public oraclesArr;\\n\\n    modifier onlyOracle {\\n        require(oracles[msg.sender] == true, \\\"Account is not a registered oracle\\\");\\n\\n        _;\\n    }\\n\\n    function regOracle(address _newOracle) public onlyOwner {\\n        require(!oracles[_newOracle], \\\"Oracle is already registered\\\");\\n        oraclesArr.push(_newOracle);\\n        oracles[_newOracle] = true;\\n    }\\n\\n    function unregOracle(address _remOracle) public onlyOwner {\\n        require(oracles[_remOracle] == true, \\\"Oracle is not registered\\\");\\n\\n        delete oracles[_remOracle];\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n// ERC20 Token, with the addition of symbol, name and decimals and an\\n// initial fixed supply, added teleport method\\n// ----------------------------------------------------------------------------\\ncontract TeleportToken is ERC20Interface, Owned, Oracled, Verify {\\n    using SafeMath for uint;\\n\\n    string public symbol;\\n    string public  name;\\n    uint8 public decimals;\\n    uint public _totalSupply;\\n    uint8 public threshold;\\n    uint8 public thisChainId;\\n\\n    mapping(address =\\u003e uint) balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\n\\n    mapping(uint64 =\\u003e mapping(address =\\u003e bool)) signed;\\n    mapping(uint64 =\\u003e bool) public claimed;\\n\\n    event Teleport(address indexed from, string to, uint tokens, uint chainId);\\n    event Claimed(uint64 id, address to, uint tokens);\\n\\n    struct TeleportData {\\n        uint64 id;\\n        uint32 ts;\\n        uint64 fromAddr;\\n        uint64 quantity;\\n        uint64 symbolRaw;\\n        uint8 chainId;\\n        address toAddress;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    constructor(string memory _symbol, string memory _name, uint8 _decimals, uint __totalSupply, uint8 _threshold, uint8 _thisChainId) {\\n        symbol = _symbol;\\n        name = _name;\\n        decimals = _decimals;\\n        _totalSupply = __totalSupply * 10**uint(_decimals);\\n        balances[address(0)] = _totalSupply;\\n        threshold = _threshold;\\n        thisChainId = _thisChainId;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Total supply\\n    // ------------------------------------------------------------------------\\n    function totalSupply() override public view returns (uint) {\\n        return _totalSupply - balances[address(0)];\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Get the token balance for account `tokenOwner`\\n    // ------------------------------------------------------------------------\\n    function balanceOf(address tokenOwner) override public view returns (uint balance) {\\n        return balances[tokenOwner];\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transfer(address to, uint tokens) override public returns (bool success) {\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\n        balances[to] = balances[to].add(tokens);\\n        emit Transfer(msg.sender, to, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner\\u0027s account\\n    //\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n    // recommends that there are no checks for the approval double-spend attack\\n    // as this should be implemented in user interfaces\\n    // ------------------------------------------------------------------------\\n    function approve(address spender, uint tokens) override public returns (bool success) {\\n        allowed[msg.sender][spender] = tokens;\\n        emit Approval(msg.sender, spender, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer `tokens` from the `from` account to the `to` account\\n    //\\n    // The calling account must already have sufficient tokens approve(...)-d\\n    // for spending from the `from` account and\\n    // - From account must have sufficient balance to transfer\\n    // - Spender must have sufficient allowance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transferFrom(address from, address to, uint tokens) override public returns (bool success) {\\n        balances[from] = balances[from].sub(tokens);\\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\n        balances[to] = balances[to].add(tokens);\\n        emit Transfer(from, to, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Returns the amount of tokens approved by the owner that can be\\n    // transferred to the spender\\u0027s account\\n    // ------------------------------------------------------------------------\\n    function allowance(address tokenOwner, address spender) override public view returns (uint remaining) {\\n        return allowed[tokenOwner][spender];\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner\\u0027s account. The `spender` contract function\\n    // `receiveApproval(...)` is then executed\\n    // ------------------------------------------------------------------------\\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\\n        allowed[msg.sender][spender] = tokens;\\n        emit Approval(msg.sender, spender, tokens);\\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Moves tokens to the inaccessible account and then sends event for the oracles\\n    // to monitor and issue on other chain\\n    // to : EOS address\\n    // tokens : number of tokens in satoshis\\n    // chainId : The chain id that they will be sent to\\n    // ------------------------------------------------------------------------\\n\\n    function teleport(string memory to, uint tokens, uint chainid) public returns (bool success) {\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\n        balances[address(0)] = balances[address(0)].add(tokens);\\n\\n        emit Transfer(msg.sender, address(0), tokens);\\n        emit Teleport(msg.sender, to, tokens, chainid);\\n\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Claim tokens sent using signatures supplied to the other chain\\n    // ------------------------------------------------------------------------\\n\\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\\n        bytes memory tempEmptyStringTest = bytes(source);\\n        if (tempEmptyStringTest.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            result := mload(add(source, 32))\\n        }\\n    }\\n\\n    function verifySigData(bytes memory sigData) private returns (TeleportData memory) {\\n        TeleportData memory td;\\n\\n        uint64 id;\\n        uint32 ts;\\n        uint64 fromAddr;\\n        uint64 quantity;\\n        uint64 symbolRaw;\\n        uint8 chainId;\\n        address toAddress;\\n        uint64 requiredSymbolRaw;\\n        \\n        assembly {\\n            id := mload(add(add(sigData, 0x8), 0))\\n            ts := mload(add(add(sigData, 0x4), 8))\\n            fromAddr := mload(add(add(sigData, 0x8), 12))\\n            quantity := mload(add(add(sigData, 0x8), 20))\\n            symbolRaw := mload(add(add(sigData, 0x8), 29))\\n            chainId := mload(add(add(sigData, 0x1), 36))\\n            toAddress := mload(add(add(sigData, 0x14), 37))            \\n        }\\n        td.id = Endian.reverse64(id);\\n        td.ts = Endian.reverse32(ts);\\n        td.fromAddr = Endian.reverse64(fromAddr);\\n        td.quantity = Endian.reverse64(quantity);\\n        td.symbolRaw = Endian.reverse64(symbolRaw);\\n        td.chainId = chainId;\\n        td.toAddress = toAddress;\\n\\n        requiredSymbolRaw = uint64(bytes8(stringToBytes32(TeleportToken.symbol)));\\n        require(requiredSymbolRaw == symbolRaw-td.chainId, \\\"Wrong symbol\\\");\\n        require(thisChainId == td.chainId, \\\"Invalid Chain ID\\\");\\n        require(block.timestamp \\u003c SafeMath.add(td.ts, (60 * 60 * 24 * 30)), \\\"Teleport has expired\\\");\\n        require(!claimed[td.id], \\\"Already Claimed\\\");\\n\\n        claimed[td.id] = true;\\n\\n        return td;\\n    }\\n\\n    function claim(bytes memory sigData, bytes[] calldata signatures) public returns (address toAddress) {\\n        TeleportData memory td = verifySigData(sigData);\\n\\n        // verify signatures\\n        require(sigData.length == 69, \\\"Signature data is the wrong size\\\");\\n        require(signatures.length \\u003c= 10, \\\"Maximum of 10 signatures can be provided\\\");\\n\\n        bytes32 message = keccak256(sigData);\\n\\n        uint8 numberSigs = 0;\\n\\n        for (uint8 i = 0; i \\u003c signatures.length; i++){\\n            address potential = Verify.recoverSigner(message, signatures[i]);\\n\\n            // console.log(potential);\\n            // console.log(oracles[potential]);\\n            // console.log(!signed[td.id][potential]);\\n            // Check that they are an oracle and they haven\\u0027t signed twice\\n            if (oracles[potential] \\u0026\\u0026 !signed[td.id][potential]){\\n                signed[td.id][potential] = true;\\n                numberSigs++;\\n\\n                if (numberSigs \\u003e= threshold){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        require(numberSigs \\u003e= threshold, \\\"Not enough valid signatures provided\\\");\\n\\n        balances[address(0)] = balances[address(0)].sub(td.quantity);\\n        balances[td.toAddress] = balances[td.toAddress].add(td.quantity);\\n\\n        emit Claimed(td.id, td.toAddress, td.quantity);\\n        emit Transfer(address(0), td.toAddress, td.quantity);\\n\\n        return td.toAddress;\\n    }\\n\\n    function updateThreshold(uint8 newThreshold) public onlyOwner returns (bool success) {\\n        if (newThreshold \\u003e 0){\\n            require(newThreshold \\u003c= 10, \\\"Threshold has maximum of 10\\\");\\n\\n            threshold = newThreshold;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function updateChainId(uint8 newChainId) public onlyOwner returns (bool success) {\\n        if (newChainId \\u003e 0){\\n            require(newChainId \\u003c= 100, \\\"ChainID is too big\\\");\\n            thisChainId = newChainId;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Don\\u0027t accept ETH\\n    // ------------------------------------------------------------------------\\n    receive () external payable {\\n        revert();\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n    // ------------------------------------------------------------------------\\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\\n    }\\n}\\n\"},\"TeleportTokenFactory.sol\":{\"content\":\"pragma solidity ^0.8.6;\\n/*\\n * SPDX-License-Identifier: MIT\\n */\\npragma experimental ABIEncoderV2;\\n\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"./TeleportToken.sol\\\";\\n\\ncontract TeleportTokenFactory is Owned, Oracled {\\n    TeleportToken[] public teleporttokens;\\n    uint256 public creationFee = 0.1 ether;\\n\\n    // Payable constructor can receive Ether\\n    constructor() payable {\\n    }\\n\\n    // Function to deposit Ether into this contract.\\n    // Call this function along with some Ether.\\n    // The balance of this contract will be automatically updated.\\n    function deposit() public payable {}\\n\\n    // Call this function along with some Ether.\\n    // The function will throw an error since this function is not payable.\\n    function notPayable() public {}\\n\\n    // Function to withdraw all Ether from this contract.\\n    function withdraw() onlyOwner public {\\n        // get the amount of Ether stored in this contract\\n        uint amount = address(this).balance;\\n\\n        // send all Ether to owner\\n        // Owner can receive Ether since the address of owner is payable\\n        (bool success, ) = owner.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Failed to send Ether\\\");\\n    }\\n\\n    // Function to receive Ether. msg.data must be empty\\n    receive() external payable {}\\n\\n    // Fallback function is called when msg.data is not empty\\n    fallback() external payable {}\\n\\n    function getBalance() public view returns (uint) {\\n        return address(this).balance;\\n    }\\n\\n    function create(\\n        string memory _symbol,\\n        string memory _name,\\n        uint8 _decimals,\\n        uint256 __totalSupply,\\n        uint8 _threshold,\\n        uint8 _thisChainId\\n    ) public payable {\\n        // correct fee\\n        require(msg.value == creationFee, \\\"Wrong fee\\\");\\n        TeleportToken tt = new TeleportToken(\\n            _symbol,\\n            _name,\\n            _decimals,\\n            __totalSupply,\\n            _threshold,\\n            _thisChainId\\n        );\\n\\n        uint oraclesLength = oraclesArr.length;\\n        for (uint i = 0; i \\u003c oraclesLength; i++) {\\n            tt.regOracle(oraclesArr[i]);\\n        }\\n        tt.transferOwnership(msg.sender);\\n\\n        teleporttokens.push(tt);\\n    }\\n\\n    function getTokenAddress(uint256 _index)\\n        public\\n        view\\n        returns (\\n            address ttAddress\\n        )\\n    {\\n        TeleportToken tt = teleporttokens[_index];\\n\\n        return (\\n            address(tt)\\n        );\\n    }\\n\\n    function setFee(uint256 _fee) public onlyOwner {\\n        creationFee = _fee;\\n    }\\n\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"__totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_thisChainId\",\"type\":\"uint8\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ttAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notPayable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oraclesArr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOracle\",\"type\":\"address\"}],\"name\":\"regOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teleporttokens\",\"outputs\":[{\"internalType\":\"contract TeleportToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_remOracle\",\"type\":\"address\"}],\"name\":\"unregOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"TeleportTokenFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://89c923c9719fb7fa474eb2c37098657d705827bb94cf476c1753428845d463bd"}]}