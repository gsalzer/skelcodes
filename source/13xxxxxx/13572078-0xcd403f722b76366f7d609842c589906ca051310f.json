{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IMultisigControl.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.8;\r\n\r\n/// @title MultisigControl Interface\r\n/// @author Vega Protocol\r\n/// @notice Implementations of this interface are used by the Vega network to control smart contracts without the need for Vega to have any Ethereum of its own.\r\n/// @notice To do this, the Vega validators sign a MultisigControl order to construct a signature bundle. Any interested party can then take that signature bundle and pay the gas to run the command on Ethereum\r\nabstract contract IMultisigControl {\r\n\r\n    /***************************EVENTS****************************/\r\n    event SignerAdded(address new_signer, uint256 nonce);\r\n    event SignerRemoved(address old_signer, uint256 nonce);\r\n    event ThresholdSet(uint16 new_threshold, uint256 nonce);\r\n\r\n    /**************************FUNCTIONS*********************/\r\n    /// @notice Sets threshold of signatures that must be met before function is executed.\r\n    /// @param new_threshold New threshold value\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Ethereum has no decimals, threshold is % * 10 so 50% == 500 100% == 1000\r\n    /// @notice signatures are OK if they are >= threshold count of total valid signers\r\n    /// @dev MUST emit ThresholdSet event\r\n    function set_threshold(uint16 new_threshold, uint nonce, bytes calldata signatures) public virtual;\r\n\r\n    /// @notice Adds new valid signer and adjusts signer count.\r\n    /// @param new_signer New signer address\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit 'SignerAdded' event\r\n    function add_signer(address new_signer, uint nonce, bytes calldata signatures) public virtual;\r\n\r\n    /// @notice Removes currently valid signer and adjusts signer count.\r\n    /// @param old_signer Address of signer to be removed.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit 'SignerRemoved' event\r\n    function remove_signer(address old_signer, uint nonce, bytes calldata signatures) public virtual;\r\n\r\n    /// @notice Verifies a signature bundle and returns true only if the threshold of valid signers is met,\r\n    /// @notice this is a function that any function controlled by Vega MUST call to be securely controlled by the Vega network\r\n    /// @notice message to hash to sign follows this pattern:\r\n    /// @notice abi.encode( abi.encode(param1, param2, param3, ... , nonce, function_name_string), validating_contract_or_submitter_address);\r\n    /// @notice Note that validating_contract_or_submitter_address is the the submitting party. If on MultisigControl contract itself, it's the submitting ETH address\r\n    /// @notice if function on bridge that then calls Multisig, then it's the address of that contract\r\n    /// @notice Note also the embedded encoding, this is required to verify what function/contract the function call goes to\r\n    /// @return MUST return true if valid signatures are over the threshold\r\n    function verify_signatures(bytes calldata signatures, bytes memory message, uint nonce) public virtual returns(bool);\r\n\r\n    /**********************VIEWS*********************/\r\n    /// @return Number of valid signers\r\n    function get_valid_signer_count() public virtual view returns(uint8);\r\n\r\n    /// @return Current threshold\r\n    function get_current_threshold() public virtual view returns(uint16);\r\n\r\n    /// @param signer_address target potential signer address\r\n    /// @return true if address provided is valid signer\r\n    function is_valid_signer(address signer_address) public virtual view returns(bool);\r\n\r\n    /// @param nonce Nonce to lookup\r\n    /// @return true if nonce has been used\r\n    function is_nonce_used(uint nonce) public virtual view returns(bool);\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\r\n\r\n// File: contracts/IERC20_Bridge_Logic.sol\r\n\r\n\r\n/// @title ERC20 Bridge Logic Interface\r\n/// @author Vega Protocol\r\n/// @notice Implementations of this interface are used by Vega network users to deposit and withdraw ERC20 tokens to/from Vega.\r\n// @notice All funds deposited/withdrawn are to/from the ERC20_Asset_Pool\r\nabstract contract IERC20_Bridge_Logic {\r\n\r\n    /***************************EVENTS****************************/\r\n    event Asset_Withdrawn(address indexed user_address, address indexed asset_source, uint256 amount, uint256 nonce);\r\n    event Asset_Deposited(address indexed user_address, address indexed asset_source, uint256 amount, bytes32 vega_public_key);\r\n    event Asset_Deposit_Minimum_Set(address indexed asset_source,  uint256 new_minimum, uint256 nonce);\r\n    event Asset_Deposit_Maximum_Set(address indexed asset_source,  uint256 new_maximum, uint256 nonce);\r\n    event Asset_Listed(address indexed asset_source,  bytes32 indexed vega_asset_id, uint256 nonce);\r\n    event Asset_Removed(address indexed asset_source,  uint256 nonce);\r\n\r\n    /***************************FUNCTIONS*************************/\r\n    /// @notice This function lists the given ERC20 token contract as valid for deposit to this bridge\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param vega_asset_id Vega-generated asset ID for internal use in Vega Core\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit Asset_Listed if successful\r\n    function list_asset(address asset_source, bytes32 vega_asset_id, uint256 nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice This function removes from listing the given ERC20 token contract. This marks the token as invalid for deposit to this bridge\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit Asset_Removed if successful\r\n    function remove_asset(address asset_source, uint256 nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice This function sets the minimum allowable deposit for the given ERC20 token\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param minimum_amount Minimum deposit amount\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit Asset_Deposit_Minimum_Set if successful\r\n    function set_deposit_minimum(address asset_source, uint256 minimum_amount, uint256 nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice This function sets the maximum allowable deposit for the given ERC20 token\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param maximum_amount Maximum deposit amount\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit Asset_Deposit_Maximum_Set if successful\r\n    function set_deposit_maximum(address asset_source, uint256 maximum_amount, uint256 nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice This function withdrawals assets to the target Ethereum address\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param amount Amount of ERC20 tokens to withdraw\r\n    /// @param target Target Ethereum address to receive withdrawn ERC20 tokens\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit Asset_Withdrawn if successful\r\n    function withdraw_asset(address asset_source, uint256 amount, address target, uint256 nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice This function allows a user to deposit given ERC20 tokens into Vega\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param amount Amount of tokens to be deposited into Vega\r\n    /// @param vega_public_key Target Vega public key to be credited with this deposit\r\n    /// @dev MUST emit Asset_Deposited if successful\r\n    /// @dev ERC20 approve function should be run before running this\r\n    /// @notice ERC20 approve function should be run before running this\r\n    function deposit_asset(address asset_source, uint256 amount, bytes32 vega_public_key) public virtual;\r\n\r\n    /***************************VIEWS*****************************/\r\n    /// @notice This view returns true if the given ERC20 token contract has been listed valid for deposit\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return True if asset is listed\r\n    function is_asset_listed(address asset_source) public virtual view returns(bool);\r\n\r\n    /// @notice This view returns minimum valid deposit\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return Minimum valid deposit of given ERC20 token\r\n    function get_deposit_minimum(address asset_source) public virtual view returns(uint256);\r\n\r\n    /// @notice This view returns maximum valid deposit\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return Maximum valid deposit of given ERC20 token\r\n    function get_deposit_maximum(address asset_source) public virtual view returns(uint256);\r\n\r\n    /// @return current multisig_control_address\r\n    function get_multisig_control_address() public virtual view returns(address);\r\n\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return The assigned Vega Asset ID for given ERC20 token\r\n    function get_vega_asset_id(address asset_source) public virtual view returns(bytes32);\r\n\r\n    /// @param vega_asset_id Vega-assigned asset ID for which you want the ERC20 token address\r\n    /// @return The ERC20 token contract address for a given Vega Asset ID\r\n    function get_asset_source(bytes32 vega_asset_id) public virtual view returns(address);\r\n\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\r\n\r\n// File: contracts/IERC20.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/ERC20_Asset_Pool.sol\r\n\r\n\r\n/// @title ERC20 Asset Pool\r\n/// @author Vega Protocol\r\n/// @notice This contract is the target for all deposits to the ERC20 Bridge via ERC20_Bridge_Logic\r\ncontract ERC20_Asset_Pool {\r\n\r\n    event Multisig_Control_Set(address indexed new_address);\r\n    event Bridge_Address_Set(address indexed new_address);\r\n\r\n    /// @return Current MultisigControl contract address\r\n    address public multisig_control_address;\r\n\r\n    /// @return Current ERC20_Bridge_Logic contract address\r\n    address public erc20_bridge_address;\r\n\r\n    /// @param multisig_control The initial MultisigControl contract address\r\n    /// @notice Emits Multisig_Control_Set event\r\n    constructor(address multisig_control) {\r\n        multisig_control_address = multisig_control;\r\n        emit Multisig_Control_Set(multisig_control);\r\n    }\r\n\r\n    /// @notice this contract is not intended to accept ether directly\r\n    receive() external payable {\r\n      revert(\"this contract does not accept ETH\");\r\n    }\r\n\r\n    /// @param new_address The new MultisigControl contract address.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_multisig_control order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Emits Multisig_Control_Set event\r\n    function set_multisig_control(address new_address, uint256 nonce, bytes memory signatures) public {\r\n        require(new_address != address(0));\r\n        bytes memory message = abi.encode(new_address, nonce, 'set_multisig_control');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        multisig_control_address = new_address;\r\n        emit Multisig_Control_Set(new_address);\r\n    }\r\n\r\n    /// @param new_address The new ERC20_Bridge_Logic contract address.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_bridge_address order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Emits Bridge_Address_Set event\r\n    function set_bridge_address(address new_address, uint256 nonce, bytes memory signatures) public {\r\n        bytes memory message = abi.encode(new_address, nonce, 'set_bridge_address');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        erc20_bridge_address = new_address;\r\n        emit Bridge_Address_Set(new_address);\r\n    }\r\n\r\n    /// @notice This function can only be run by the current \"multisig_control_address\" and, if available, will send the target tokens to the target\r\n    /// @param token_address Contract address of the ERC20 token to be withdrawn\r\n    /// @param target Target Ethereum address that the ERC20 tokens will be sent to\r\n    /// @param amount Amount of ERC20 tokens to withdraw\r\n    /// @dev amount is in whatever the lowest decimal value the ERC20 token has. For instance, an 18 decimal ERC20 token, 1 \"amount\" == 0.000000000000000001\r\n    /// @return true if transfer was successful.\r\n    function withdraw(address token_address, address target, uint256 amount) public returns(bool) {\r\n        require(msg.sender == erc20_bridge_address, \"msg.sender not authorized bridge\");\r\n\r\n        IERC20(token_address).transfer(target, amount);\r\n        /// @dev the following is a test for non-standard ERC20 tokens IE ones without a return value\r\n        bool result;\r\n        assembly {\r\n           switch returndatasize()\r\n               case 0 {                      // no return value but didn't revert\r\n                   result := true\r\n               }\r\n               case 32 {                     // standard ERC20, has return value\r\n                   returndatacopy(0, 0, 32)\r\n                   result := mload(0)        // result is result of transfer call\r\n               }\r\n               default {}\r\n       }\r\n       require(result, \"token transfer failed\"); // revert() if result is false\r\n\r\n      return true;\r\n    }\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\r\n\r\n// File: contracts/ERC20_Bridge_Logic.sol\r\n\r\n\r\n\r\n/// @title ERC20 Bridge Logic\r\n/// @author Vega Protocol\r\n/// @notice This contract is used by Vega network users to deposit and withdraw ERC20 tokens to/from Vega.\r\n// @notice All funds deposited/withdrawn are to/from the assigned ERC20_Asset_Pool\r\ncontract ERC20_Bridge_Logic is IERC20_Bridge_Logic {\r\n\r\n    address multisig_control_address;\r\n    address payable erc20_asset_pool_address;\r\n    // asset address => is listed\r\n    mapping(address => bool) listed_tokens;\r\n    // asset address => minimum deposit amt\r\n    mapping(address => uint256) minimum_deposits;\r\n    // asset address => maximum deposit amt\r\n    mapping(address => uint256) maximum_deposits;\r\n    // Vega asset ID => asset_source\r\n    mapping(bytes32 => address) vega_asset_ids_to_source;\r\n    // asset_source => Vega asset ID\r\n    mapping(address => bytes32) asset_source_to_vega_asset_id;\r\n\r\n    /// @param erc20_asset_pool Initial Asset Pool contract address\r\n    /// @param multisig_control Initial MultisigControl contract address\r\n    constructor(address payable erc20_asset_pool, address multisig_control) {\r\n        erc20_asset_pool_address = erc20_asset_pool;\r\n        multisig_control_address = multisig_control;\r\n    }\r\n\r\n    /***************************FUNCTIONS*************************/\r\n    /// @notice This function lists the given ERC20 token contract as valid for deposit to this bridge\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param vega_asset_id Vega-generated asset ID for internal use in Vega Core\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev Emits Asset_Listed if successful\r\n    function list_asset(address asset_source, bytes32 vega_asset_id, uint256 nonce, bytes memory signatures) public override {\r\n        require(!listed_tokens[asset_source], \"asset already listed\");\r\n        bytes memory message = abi.encode(asset_source, vega_asset_id, nonce, 'list_asset');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        listed_tokens[asset_source] = true;\r\n        vega_asset_ids_to_source[vega_asset_id] = asset_source;\r\n        asset_source_to_vega_asset_id[asset_source] = vega_asset_id;\r\n        emit Asset_Listed(asset_source, vega_asset_id, nonce);\r\n    }\r\n\r\n    /// @notice This function removes from listing the given ERC20 token contract. This marks the token as invalid for deposit to this bridge\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev Emits Asset_Removed if successful\r\n    function remove_asset(address asset_source, uint256 nonce, bytes memory signatures) public override {\r\n        require(listed_tokens[asset_source], \"asset not listed\");\r\n        bytes memory message = abi.encode(asset_source, nonce, 'remove_asset');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        listed_tokens[asset_source] = false;\r\n        emit Asset_Removed(asset_source, nonce);\r\n    }\r\n\r\n    /// @notice This function sets the minimum allowable deposit for the given ERC20 token\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param minimum_amount Minimum deposit amount\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev Emits Asset_Deposit_Minimum_Set if successful\r\n    function set_deposit_minimum(address asset_source, uint256 minimum_amount, uint256 nonce, bytes memory signatures) public override{\r\n        require(listed_tokens[asset_source], \"asset not listed\");\r\n        bytes memory message = abi.encode(asset_source, minimum_amount, nonce, 'set_deposit_minimum');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        minimum_deposits[asset_source] = minimum_amount;\r\n        emit Asset_Deposit_Minimum_Set(asset_source, minimum_amount, nonce);\r\n    }\r\n\r\n    /// @notice This function sets the maximum allowable deposit for the given ERC20 token\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param maximum_amount Maximum deposit amount\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev Emits Asset_Deposit_Maximum_Set if successful\r\n    function set_deposit_maximum(address asset_source, uint256 maximum_amount, uint256 nonce, bytes memory signatures) public override {\r\n        require(listed_tokens[asset_source], \"asset not listed\");\r\n        bytes memory message = abi.encode(asset_source, maximum_amount, nonce, 'set_deposit_maximum');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        maximum_deposits[asset_source] = maximum_amount;\r\n        emit Asset_Deposit_Maximum_Set(asset_source, maximum_amount, nonce);\r\n    }\r\n\r\n    /// @notice This function withdrawals assets to the target Ethereum address\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param amount Amount of ERC20 tokens to withdraw\r\n    /// @param target Target Ethereum address to receive withdrawn ERC20 tokens\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev Emits Asset_Withdrawn if successful\r\n    function withdraw_asset(address asset_source, uint256 amount, address target, uint256 nonce, bytes memory signatures) public  override{\r\n        bytes memory message = abi.encode(asset_source, amount, target,  nonce, 'withdraw_asset');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        require(ERC20_Asset_Pool(erc20_asset_pool_address).withdraw(asset_source, target, amount), \"token didn't transfer, rejected by asset pool.\");\r\n        emit Asset_Withdrawn(target, asset_source, amount, nonce);\r\n    }\r\n\r\n    /// @notice This function allows a user to deposit given ERC20 tokens into Vega\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @param amount Amount of tokens to be deposited into Vega\r\n    /// @param vega_public_key Target Vega public key to be credited with this deposit\r\n    /// @dev MUST emit Asset_Deposited if successful\r\n    /// @dev ERC20 approve function should be run before running this\r\n    /// @notice ERC20 approve function should be run before running this\r\n    function deposit_asset(address asset_source, uint256 amount, bytes32 vega_public_key) public override {\r\n        require(listed_tokens[asset_source], \"asset not listed\");\r\n        //User must run approve before deposit\r\n        require(maximum_deposits[asset_source] == 0 || amount <= maximum_deposits[asset_source], \"deposit above maximum\");\r\n        require(amount >= minimum_deposits[asset_source], \"deposit below minimum\");\r\n        require(IERC20(asset_source).transferFrom(msg.sender, erc20_asset_pool_address, amount), \"transfer failed in deposit\");\r\n        emit Asset_Deposited(msg.sender, asset_source, amount, vega_public_key);\r\n    }\r\n\r\n    /***************************VIEWS*****************************/\r\n    /// @notice This view returns true if the given ERC20 token contract has been listed valid for deposit\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return True if asset is listed\r\n    function is_asset_listed(address asset_source) public override view returns(bool){\r\n        return listed_tokens[asset_source];\r\n    }\r\n\r\n    /// @notice This view returns minimum valid deposit\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return Minimum valid deposit of given ERC20 token\r\n    function get_deposit_minimum(address asset_source) public override view returns(uint256){\r\n        return minimum_deposits[asset_source];\r\n    }\r\n\r\n    /// @notice This view returns maximum valid deposit\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return Maximum valid deposit of given ERC20 token\r\n    function get_deposit_maximum(address asset_source) public override view returns(uint256){\r\n        return maximum_deposits[asset_source];\r\n    }\r\n\r\n    /// @return current multisig_control_address\r\n    function get_multisig_control_address() public override view returns(address) {\r\n        return multisig_control_address;\r\n    }\r\n\r\n    /// @param asset_source Contract address for given ERC20 token\r\n    /// @return The assigned Vega Asset Id for given ERC20 token\r\n    function get_vega_asset_id(address asset_source) public override view returns(bytes32){\r\n        return asset_source_to_vega_asset_id[asset_source];\r\n    }\r\n\r\n    /// @param vega_asset_id Vega-assigned asset ID for which you want the ERC20 token address\r\n    /// @return The ERC20 token contract address for a given Vega Asset Id\r\n    function get_asset_source(bytes32 vega_asset_id) public override view returns(address){\r\n        return vega_asset_ids_to_source[vega_asset_id];\r\n    }\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"erc20_asset_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multisig_control\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_maximum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Asset_Deposit_Maximum_Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_minimum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Asset_Deposit_Minimum_Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"Asset_Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"vega_asset_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Asset_Listed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Asset_Removed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Asset_Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"deposit_asset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vega_asset_id\",\"type\":\"bytes32\"}],\"name\":\"get_asset_source\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"}],\"name\":\"get_deposit_maximum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"}],\"name\":\"get_deposit_minimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_multisig_control_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"}],\"name\":\"get_vega_asset_id\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"}],\"name\":\"is_asset_listed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"vega_asset_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"list_asset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"remove_asset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximum_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"set_deposit_maximum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimum_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"set_deposit_minimum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"withdraw_asset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20_Bridge_Logic","CompilerVersion":"v0.8.8+commit.dddeac2f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f0f0fcda832415b935802c6dad0a6da2c7eaed8f000000000000000000000000164d322b2377c0fddb73cd32f24e972a7d9c72f9","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dda9939ad5c1380c7f934bf19db31051c648ae958f3a9e7ae3c88eadc59a4b84"}]}