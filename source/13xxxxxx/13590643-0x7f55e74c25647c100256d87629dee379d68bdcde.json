{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.7;\r\n\r\nabstract contract StructLike {\r\n    function val(uint256 _id) virtual public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title LinkedList (Structured Link List)\r\n * @author Vittorio Minacori (https://github.com/vittominacori)\r\n * @dev A utility library for using sorted linked list data structures in your Solidity project.\r\n */\r\nlibrary LinkedList {\r\n\r\n    uint256 private constant NULL = 0;\r\n    uint256 private constant HEAD = 0;\r\n\r\n    bool private constant PREV = false;\r\n    bool private constant NEXT = true;\r\n\r\n    struct List {\r\n        mapping(uint256 => mapping(bool => uint256)) list;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the list exists\r\n     * @param self stored linked list from contract\r\n     * @return bool true if list exists, false otherwise\r\n     */\r\n    function isList(List storage self) internal view returns (bool) {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the node exists\r\n     * @param self stored linked list from contract\r\n     * @param _node a node to search for\r\n     * @return bool true if node exists, false otherwise\r\n     */\r\n    function isNode(List storage self, uint256 _node) internal view returns (bool) {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the list\r\n     * @param self stored linked list from contract\r\n     * @return uint256\r\n     */\r\n    function range(List storage self) internal view returns (uint256) {\r\n        uint256 i;\r\n        uint256 num;\r\n        (, i) = adj(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (, i) = adj(self, i, NEXT);\r\n            num++;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the links of a node as a tuple\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to get\r\n     * @return bool, uint256, uint256 true if node exists or false otherwise, previous node, next node\r\n     */\r\n    function node(List storage self, uint256 _node) internal view returns (bool, uint256, uint256) {\r\n        if (!isNode(self, _node)) {\r\n            return (false, 0, 0);\r\n        } else {\r\n            return (true, self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @param _direction direction to step in\r\n     * @return bool, uint256 true if node exists or false otherwise, node in _direction\r\n     */\r\n    function adj(List storage self, uint256 _node, bool _direction) internal view returns (bool, uint256) {\r\n        if (!isNode(self, _node)) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `NEXT`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @return bool, uint256 true if node exists or false otherwise, next node\r\n     */\r\n    function next(List storage self, uint256 _node) internal view returns (bool, uint256) {\r\n        return adj(self, _node, NEXT);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `PREV`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @return bool, uint256 true if node exists or false otherwise, previous node\r\n     */\r\n    function prev(List storage self, uint256 _node) internal view returns (bool, uint256) {\r\n        return adj(self, _node, PREV);\r\n    }\r\n\r\n    /**\r\n     * @dev Can be used before `insert` to build an ordered list.\r\n     * @dev Get the node and then `back` or `face` basing on your list order.\r\n     * @dev If you want to order basing on other than `structure.val()` override this function\r\n     * @param self stored linked list from contract\r\n     * @param _struct the structure instance\r\n     * @param _val value to seek\r\n     * @return uint256 next node with a value less than StructLike(_struct).val(next_)\r\n     */\r\n    function sort(List storage self, address _struct, uint256 _val) internal view returns (uint256) {\r\n        if (range(self) == 0) {\r\n            return 0;\r\n        }\r\n        bool exists;\r\n        uint256 next_;\r\n        (exists, next_) = adj(self, HEAD, NEXT);\r\n        while ((next_ != 0) && ((_val < StructLike(_struct).val(next_)) != NEXT)) {\r\n            next_ = self.list[next_][NEXT];\r\n        }\r\n        return next_;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n     * @param self stored linked list from contract\r\n     * @param _node first node for linking\r\n     * @param _link  node to link to in the _direction\r\n     */\r\n    function form(List storage self, uint256 _node, uint256 _link, bool _dir) internal {\r\n        self.list[_link][!_dir] = _node;\r\n        self.list[_node][_dir] = _link;\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @param _direction direction to insert node in\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function insert(List storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\r\n        if (!isNode(self, _new) && isNode(self, _node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            form(self, _node, _new, _direction);\r\n            form(self, _new, c, _direction);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `NEXT`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function face(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\r\n        return insert(self, _node, _new, NEXT);\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `PREV`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function back(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\r\n        return insert(self, _node, _new, PREV);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _node node to remove from the list\r\n     * @return uint256 the removed node\r\n     */\r\n    function del(List storage self, uint256 _node) internal returns (uint256) {\r\n        if ((_node == NULL) || (!isNode(self, _node))) {\r\n            return 0;\r\n        }\r\n        form(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        return _node;\r\n    }\r\n\r\n    /**\r\n     * @dev Pushes an entry to the head or tail of the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _node new entry to push to the head\r\n     * @param _direction push to the head (NEXT) or tail (PREV)\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function push(List storage self, uint256 _node, bool _direction) internal returns (bool) {\r\n        return insert(self, HEAD, _node, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Pops the first entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _direction pop from the head (NEXT) or the tail (PREV)\r\n     * @return uint256 the removed node\r\n     */\r\n    function pop(List storage self, bool _direction) internal returns (uint256) {\r\n        bool exists;\r\n        uint256 adj_;\r\n        (exists, adj_) = adj(self, HEAD, _direction);\r\n        return del(self, adj_);\r\n    }\r\n}\r\n\r\nabstract contract RewardAdjusterLike {\r\n    function recomputeRewards(address, bytes4) external virtual;\r\n}\r\n\r\ncontract RewardAdjusterBundler {\r\n    using LinkedList for LinkedList.List;\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"RewardAdjusterBundler/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Variables ---\r\n    // Number of funded functions ever added\r\n    uint256            public fundedFunctionNonce;\r\n    // Max number of functions that can be in the list\r\n    uint256            public maxFunctions;\r\n    // Latest funded function index in the list\r\n    uint256            public latestFundedFunction;\r\n\r\n    // Mapping with functions that were already added\r\n    mapping(address => mapping(bytes4 => uint256)) public addedFunction;\r\n    // Data about each funded function\r\n    mapping(uint256 => FundedFunction)             public fundedFunctions;\r\n\r\n    // Linked list with functions offering rewards to be called\r\n    LinkedList.List    internal fundedFunctionsList;\r\n\r\n    // The fixed reward adjuster\r\n    RewardAdjusterLike public fixedRewardAdjuster;\r\n    // The min + max reward adjuster\r\n    RewardAdjusterLike public minMaxRewardAdjuster;\r\n\r\n    // --- Structs ---\r\n    struct FundedFunction {\r\n        uint256 adjusterType;\r\n        bytes4  functionName;\r\n        address receiverContract;\r\n    }\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event FailedRecomputeReward(uint256 adjusterType, address receiverContract, bytes4 functionName);\r\n    event AddFundedFunction(\r\n      uint256 latestFundedFunction,\r\n      uint256 adjusterType,\r\n      bytes4 functionName,\r\n      address receiverContract\r\n    );\r\n    event RemoveFundedFunction(uint256 functionPosition);\r\n    event ModifyParameters(bytes32 parameter, address val);\r\n    event ModifyParameters(bytes32 actionType, uint256 functionPosition, uint256 adjusterType, bytes4 functionName, address receiverContract);\r\n\r\n    constructor(address _fixedRewardAdjuster, address _minMaxRewardAdjuster, uint256 _maxFunctions) public {\r\n        require(_maxFunctions > 0, \"RewardAdjusterBundler/null-max-functions\");\r\n        require(_fixedRewardAdjuster != address(0), \"RewardAdjusterBundler/null-fixed-reward-adjuster\");\r\n        require(_minMaxRewardAdjuster != address(0), \"RewardAdjusterBundler/null-minmax-reward-adjuster\");\r\n\r\n        authorizedAccounts[msg.sender] = 1;\r\n        maxFunctions                   = _maxFunctions;\r\n\r\n        fixedRewardAdjuster            = RewardAdjusterLike(_fixedRewardAdjuster);\r\n        minMaxRewardAdjuster           = RewardAdjusterLike(_minMaxRewardAdjuster);\r\n\r\n        emit AddAuthorization(msg.sender);\r\n    }\r\n\r\n    // --- Boolean Logic ---\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- Math ---\r\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x + y;\r\n        require(z >= x, \"RewardAdjusterBundler/add-uint-uint-overflow\");\r\n    }\r\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"RewardAdjusterBundler/sub-uint-uint-underflow\");\r\n    }\r\n\r\n    // --- Administration ---\r\n    /*\r\n     * @notice Modify address params\r\n     * @param parameter The name of the parameter to update\r\n     * @param val The new address for the parameter\r\n     */\r\n    function modifyParameters(bytes32 parameter, address val) external isAuthorized {\r\n        require(val != address(0), \"RewardAdjusterBundler/null-val\");\r\n\r\n        if (parameter == \"fixedRewardAdjuster\") {\r\n          fixedRewardAdjuster = RewardAdjusterLike(val);\r\n        } else if (parameter == \"minMaxRewardAdjuster\") {\r\n          minMaxRewardAdjuster = RewardAdjusterLike(val);\r\n        } else revert(\"RewardAdjusterBundler/modify-unrecognized-param\");\r\n\r\n        emit ModifyParameters(parameter, val);\r\n    }\r\n    /*\r\n     * @notice Add or remove a funded function\r\n     * @param actionType The type of action to execute\r\n     * @param functionPosition The position of the funded function in fundedFunctions\r\n     * @param adjusterType The adjuster contract to include for the funded function\r\n     * @param functionName The signature of the function that gets funded\r\n     * @param receiverContract The contract hosting the funded function\r\n     */\r\n    function modifyParameters(bytes32 actionType, uint256 functionPosition, uint256 adjusterType, bytes4 functionName, address receiverContract)\r\n      external isAuthorized {\r\n        if (actionType == \"addFunction\") {\r\n          addFundedFunction(adjusterType, functionName, receiverContract);\r\n        } else if (actionType == \"removeFunction\") {\r\n          removeFundedFunction(functionPosition);\r\n        }\r\n        else revert(\"RewardAdjusterBundler/modify-unrecognized-param\");\r\n\r\n        emit ModifyParameters(actionType, functionPosition, adjusterType, functionName, receiverContract);\r\n    }\r\n\r\n    // --- Internal Logic ---\r\n    /*\r\n     * @notice Add a funded function\r\n     * @param adjusterType The type of adjuster that recomputes the rewards offered by this function\r\n     * @param functionName The name of the function offering rewards\r\n     * @param receiverContract Contract that has the funded function\r\n     */\r\n    function addFundedFunction(uint256 adjusterType, bytes4 functionName, address receiverContract) internal {\r\n        require(receiverContract != address(0), \"RewardAdjusterBundler/null-receiver-contract\");\r\n        require(adjusterType <= 1, \"RewardAdjusterBundler/invalid-adjuster-type\");\r\n        require(addedFunction[receiverContract][functionName] == 0, \"RewardAdjusterBundler/function-already-added\");\r\n        require(fundedFunctionsAmount() < maxFunctions, \"RewardAdjusterBundler/function-limit-reached\");\r\n\r\n        addedFunction[receiverContract][functionName] = 1;\r\n        fundedFunctionNonce                           = addition(fundedFunctionNonce, 1);\r\n        latestFundedFunction                          = fundedFunctionNonce;\r\n        fundedFunctions[fundedFunctionNonce]          = FundedFunction(adjusterType, functionName, receiverContract);\r\n\r\n        fundedFunctionsList.push(latestFundedFunction, false);\r\n\r\n        emit AddFundedFunction(\r\n          latestFundedFunction,\r\n          adjusterType,\r\n          functionName,\r\n          receiverContract\r\n        );\r\n    }\r\n    /*\r\n     * @notice Remove a funded function\r\n     * @param functionPosition The position of the funded function in fundedFunctions\r\n     */\r\n    function removeFundedFunction(uint256 functionPosition) internal {\r\n        require(both(functionPosition <= latestFundedFunction, functionPosition > 0), \"RewardAdjusterBundler/invalid-position\");\r\n        FundedFunction memory fundedFunction = fundedFunctions[functionPosition];\r\n\r\n        require(addedFunction[fundedFunction.receiverContract][fundedFunction.functionName] == 1, \"RewardAdjusterBundler/function-not-added\");\r\n        delete(addedFunction[fundedFunction.receiverContract][fundedFunction.functionName]);\r\n\r\n        if (functionPosition == latestFundedFunction) {\r\n          (, uint256 prevReceiver) = fundedFunctionsList.prev(latestFundedFunction);\r\n          latestFundedFunction     = prevReceiver;\r\n        }\r\n\r\n        fundedFunctionsList.del(functionPosition);\r\n        delete(fundedFunctions[functionPosition]);\r\n\r\n        emit RemoveFundedFunction(functionPosition);\r\n    }\r\n\r\n    // --- Core Logic ---\r\n    /*\r\n     * @param Recopute all system coin rewards for all funded functions included in this contract\r\n     */\r\n    function recomputeAllRewards() external {\r\n        // Start looping from the latest funded function\r\n        uint256 currentFundedFunction = latestFundedFunction;\r\n\r\n        FundedFunction memory fundedFunction;\r\n\r\n        // While we still haven't gone through the entire list\r\n        while (currentFundedFunction > 0) {\r\n          fundedFunction = fundedFunctions[currentFundedFunction];\r\n          if (fundedFunction.adjusterType == 0) {\r\n            try fixedRewardAdjuster.recomputeRewards(fundedFunction.receiverContract, fundedFunction.functionName) {}\r\n            catch(bytes memory /* revertReason */) {\r\n              emit FailedRecomputeReward(fundedFunction.adjusterType, fundedFunction.receiverContract, fundedFunction.functionName);\r\n            }\r\n          } else {\r\n            try minMaxRewardAdjuster.recomputeRewards(fundedFunction.receiverContract, fundedFunction.functionName) {}\r\n            catch(bytes memory /* revertReason */) {\r\n              emit FailedRecomputeReward(fundedFunction.adjusterType, fundedFunction.receiverContract, fundedFunction.functionName);\r\n            }\r\n          }\r\n          // Continue looping\r\n          (, currentFundedFunction) = fundedFunctionsList.prev(currentFundedFunction);\r\n        }\r\n    }\r\n\r\n    // --- Getters ---\r\n    /**\r\n     * @notice Get the secondary tax receiver list length\r\n     */\r\n    function fundedFunctionsAmount() public view returns (uint256) {\r\n        return fundedFunctionsList.range();\r\n    }\r\n    /**\r\n     * @notice Check if a funded function index is in the list\r\n     */\r\n    function isFundedFunction(uint256 _fundedFunction) public view returns (bool) {\r\n        if (_fundedFunction == 0) return false;\r\n        return fundedFunctionsList.isNode(_fundedFunction);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fixedRewardAdjuster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minMaxRewardAdjuster\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxFunctions\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"latestFundedFunction\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjusterType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"functionName\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverContract\",\"type\":\"address\"}],\"name\":\"AddFundedFunction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjusterType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"functionName\",\"type\":\"bytes4\"}],\"name\":\"FailedRecomputeReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"functionPosition\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjusterType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"functionName\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverContract\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"functionPosition\",\"type\":\"uint256\"}],\"name\":\"RemoveFundedFunction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"addedFunction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedRewardAdjuster\",\"outputs\":[{\"internalType\":\"contract RewardAdjusterLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundedFunctionNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fundedFunctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjusterType\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"functionName\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"receiverContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundedFunctionsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fundedFunction\",\"type\":\"uint256\"}],\"name\":\"isFundedFunction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestFundedFunction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFunctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minMaxRewardAdjuster\",\"outputs\":[{\"internalType\":\"contract RewardAdjusterLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"functionPosition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjusterType\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"functionName\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"receiverContract\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recomputeAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RewardAdjusterBundler","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ff5126b97f37ddb4743858b7e0d6c5ae8e5db2ab000000000000000000000000be0d9016714c64a877ed28fd3f3c7c8ff513d807000000000000000000000000000000000000000000000000000000000000000f","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3e1878df53a5b42b8aefaf6fdeb3cd3a50bced783124f5986ffef0c608cb846d"}]}