{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/nft/OpenNFT.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"./NftBase.sol\\\";\\nimport \\\"../auctions/IHub.sol\\\";\\nimport \\\"../registry/Registry.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract OpenNFT is  NftBase, Ownable {\\n    using SafeMath for uint256;\\n    // -----------------------------------------------------------------------\\n    // STATE\\n    // -----------------------------------------------------------------------\\n\\n    // Storage for the registry\\n    Registry internal registryInstance_;\\n\\n    // Storage for minter role\\n    struct Minter {\\n        bool isMinter; // Is this address a minter\\n        bool isActive; // Is this address an active minter\\n        bool isDuplicateBatchMinter; // Is this address able to batch mint duplicates\\n    }\\n    // Storage for minters\\n    mapping(address => Minter) internal minters_;\\n\\n    // -----------------------------------------------------------------------\\n    // EVENTS\\n    // -----------------------------------------------------------------------\\n\\n    event MinterUpdated(\\n        address minter,\\n        bool isDuplicateMinter,\\n        bool isMinter,\\n        bool isActiveMinter,\\n        string userIdentifier\\n    );\\n\\n    event NewTokensMinted(\\n        uint256[] tokenIDs, // ID(s) of token(s).\\n        uint256 batchID, // ID of batch. 0 if not batch\\n        address indexed creator, // Address of the royalties receiver\\n        address indexed minter, // Address that minted the tokens\\n        address indexed receiver, // Address receiving token(s)\\n        string identifier, // Content ID within the location\\n        string location, // Where it is stored i.e IPFS, Arweave\\n        string contentHash // Checksum hash of the content\\n    );\\n\\n    event NewTokenMinted(\\n        // uint256 batchTokenID == 0\\n        uint256 tokenID,\\n        address indexed minter,\\n        address indexed creator,\\n        address indexed receiver\\n    );\\n\\n    event NewBatchTokenMint(\\n        // uint256 batchTokenID\\n        uint256[] tokenIDs,\\n        address indexed minter,\\n        address indexed creator,\\n        address indexed receiver\\n    );\\n\\n    // -----------------------------------------------------------------------\\n    // MODIFIERS\\n    // -----------------------------------------------------------------------\\n\\n    modifier onlyMinter() {\\n        require(\\n            minters_[msg.sender].isMinter && minters_[msg.sender].isActive,\\n            \\\"Not active minter\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyBatchDuplicateMinter() {\\n        require(\\n            minters_[msg.sender].isDuplicateBatchMinter,\\n            \\\"Not active batch copy minter\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyAuctions() {\\n        IHub auctionHubInstance_ = IHub(registryInstance_.getHub());\\n\\n        uint256 auctionID = auctionHubInstance_.getAuctionID(msg.sender);\\n        require(\\n            msg.sender == address(auctionHubInstance_) ||\\n                auctionHubInstance_.isAuctionActive(auctionID),\\n            \\\"NFT: Not hub or auction\\\"\\n        );\\n        _;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // CONSTRUCTOR\\n    // -----------------------------------------------------------------------\\n\\n    constructor(string memory name,\\n        string memory symbol) NftBase(name, symbol) Ownable() {\\n\\n        }\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _minter Address of the minter being checked\\n     * @return  isMinter If the minter has the minter role\\n     * @return  isActiveMinter If the minter is an active minter\\n     */\\n    function isMinter(address _minter)\\n        external\\n        view\\n        returns (bool isMinter, bool isActiveMinter)\\n    {\\n        isMinter = minters_[_minter].isMinter;\\n        isActiveMinter = minters_[_minter].isActive;\\n    }\\n\\n    function isActive() external view returns (bool) {\\n        return true;\\n    }\\n\\n    function isTokenBatch(uint256 _tokenID) external view returns (uint256) {\\n        return isBatchToken_[_tokenID];\\n    }\\n\\n    function getBatchInfo(uint256 _batchID)\\n        external\\n        view\\n        returns (\\n            uint256 baseTokenID,\\n            uint256[] memory tokenIDs,\\n            bool limitedStock,\\n            uint256 totalMinted\\n        )\\n    {\\n        baseTokenID = batchTokens_[_batchID].baseToken;\\n        tokenIDs = batchTokens_[_batchID].tokenIDs;\\n        limitedStock = batchTokens_[_batchID].limitedStock;\\n        totalMinted = batchTokens_[_batchID].totalMinted;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //  ONLY AUCTIONS (hub or spokes) STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _to Address of receiver\\n     * @param   _tokenID Token to transfer\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if the\\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function transfer(address _to, uint256 _tokenID) external {\\n        _transfer(_to, _tokenID);\\n    }\\n\\n    /**\\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if the\\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function batchTransfer(address _to, uint256[] memory _tokenIDs)\\n        external\\n        onlyAuctions()\\n    {\\n        _batchTransfer(_to, _tokenIDs);\\n    }\\n\\n    /**\\n     * @param   from Address being transferee from\\n     * @param   to Address to transfer to\\n     * @param   tokenId ID of token being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if\\n     *          _from is _to address.\\n     */\\n    function transferFrom(\\n        address from, address to, uint256 tokenId\\n    ) public override {\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @param   _from Address being transferee from\\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if\\n     *          _from is _to address.\\n     */\\n    function batchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] memory _tokenIDs\\n    ) external onlyAuctions() {\\n        _batchTransferFrom(_from, _to, _tokenIDs);\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY MINTER STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _tokenCreator Address of the creator. Address will receive the\\n     *          royalties from sales of the NFT\\n     * @param   _mintTo The address that should receive the token. Note that on\\n     *          the initial sale this address will not receive the sale\\n     *          collateral. Sale collateral will be distributed to creator and\\n     *          system fees\\n     * @notice  Only valid active minters will be able to mint new tokens\\n     */\\n    function mint(\\n        address _tokenCreator,\\n        address _mintTo,\\n        string calldata identifier,\\n        string calldata location,\\n        string calldata contentHash\\n    ) external onlyMinter() returns (uint256) {\\n        require(_isValidCreator(_tokenCreator), \\\"NFT: Invalid creator\\\");\\n        // Minting token\\n        uint256 tokenID = _mint(_mintTo, _tokenCreator, location);\\n        // Creating temp array for token ID\\n        uint256[] memory tempTokenIDs = new uint256[](1);\\n        tempTokenIDs[0] = tokenID;\\n        {\\n            // Emitting event\\n            emit NewTokensMinted(\\n                tempTokenIDs,\\n                0,\\n                _tokenCreator,\\n                msg.sender,\\n                _mintTo,\\n                identifier,\\n                location,\\n                contentHash\\n            );\\n        }\\n\\n        return tokenID;\\n    }\\n\\n    /**\\n     * @param   _mintTo The address that should receive the token. Note that on\\n     *          the initial sale this address will not receive the sale\\n     *          collateral. Sale collateral will be distributed to creator and\\n     *          system fees\\n     * @param   _amount Amount of tokens to mint\\n     * @param   _baseTokenID ID of the token being duplicated\\n     * @param   _isLimitedStock Bool for if the batch has a pre-set limit\\n     */\\n    function batchDuplicateMint(\\n        address _mintTo,\\n        uint256 _amount,\\n        uint256 _baseTokenID,\\n        bool _isLimitedStock\\n    ) external onlyBatchDuplicateMinter() returns (uint256[] memory) {\\n        require(\\n            tokens_[_baseTokenID].creator != address(0),\\n            \\\"Mint token before batch\\\"\\n        );\\n        uint256 originalBatchID = isBatchToken_[_baseTokenID];\\n        uint256 batch;\\n        // Minting tokens\\n        uint256[] memory tokenIDs;\\n        (tokenIDs, batch) = _batchMint(\\n            _mintTo,\\n            tokens_[_baseTokenID].creator,\\n            _amount,\\n            _baseTokenID,\\n            originalBatchID\\n        );\\n\\n        // If this is the first batch mint of the base token\\n        if (originalBatchID == 0) {\\n            // Storing batch against base token\\n            isBatchToken_[_baseTokenID] = batch;\\n            // Storing all info as a new object\\n            batchTokens_[batch] = BatchTokens(\\n                _baseTokenID,\\n                tokenIDs,\\n                _isLimitedStock,\\n                _amount\\n            );\\n        } else {\\n            batch = isBatchToken_[_baseTokenID];\\n            batchTokens_[batch].totalMinted += _amount;\\n        }\\n        // Wrapping for the stack\\n        {\\n            // Emitting event\\n            emit NewTokensMinted(\\n                tokenIDs,\\n                batch,\\n                tokens_[_baseTokenID].creator,\\n                msg.sender,\\n                _mintTo,\\n                \\\"\\\",\\n                \\\"\\\",\\n                \\\"\\\"\\n            );\\n        }\\n        return tokenIDs;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY OWNER STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _minter Address of the minter\\n     * @param   _hasMinterPermissions If the address has minter permissions. If\\n     *          false user will not be able to mint, nor will they be able to be\\n     *          set as the creator of a token\\n     * @param   _isActiveMinter If the minter is an active minter. If they do\\n     *          not have minter permissions they will not be able to be assigned\\n     *          as the creator of a token\\n     */\\n    function updateMinter(\\n        address _minter,\\n        bool _hasMinterPermissions,\\n        bool _isActiveMinter,\\n        string calldata _userIdentifier\\n    ) external onlyOwner() {\\n        minters_[_minter].isMinter = _hasMinterPermissions;\\n        minters_[_minter].isActive = _isActiveMinter;\\n\\n        emit MinterUpdated(\\n            _minter,\\n            false,\\n            _hasMinterPermissions,\\n            _isActiveMinter,\\n            _userIdentifier\\n        );\\n    }\\n\\n    function setDuplicateMinter(address _minter, bool _isDuplicateMinter)\\n        external\\n        onlyOwner()\\n    {\\n        minters_[_minter].isDuplicateBatchMinter = _isDuplicateMinter;\\n        minters_[_minter].isMinter = _isDuplicateMinter;\\n        minters_[_minter].isActive = _isDuplicateMinter;\\n\\n        emit MinterUpdated(\\n            _minter,\\n            _isDuplicateMinter,\\n            _isDuplicateMinter,\\n            _isDuplicateMinter,\\n            \\\"Auction\\\"\\n        );\\n    }\\n\\n    function setRegistry(address _registry) external onlyOwner() {\\n        require(_registry != address(0), \\\"NFT: cannot set REG to 0x\\\");\\n        require(\\n            address(registryInstance_) != _registry,\\n            \\\"NFT: Cannot set REG to existing\\\"\\n        );\\n        registryInstance_ = Registry(_registry);\\n        require(registryInstance_.isActive(), \\\"NFT: REG instance invalid\\\");\\n    }\\n\\n    fallback() external payable {\\n        revert();\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // INTERNAL STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _creator Address to check\\n     * @return  bool If the address to check is a valid creator\\n     * @notice  Will return true if the user is a minter, or is an active minter\\n     */\\n    function _isValidCreator(address _creator) internal view returns (bool) {\\n        if (minters_[_creator].isMinter) {\\n            return true;\\n        } else if (minters_[_creator].isMinter && minters_[_creator].isActive) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nft/NftBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\\\";\\n\\ncontract NftBase is ERC165, IERC721,IERC721Metadata {\\n    // Libraries \\n    using SafeMath for uint256;\\n\\n    // -----------------------------------------------------------------------\\n    // STATE \\n    // -----------------------------------------------------------------------\\n\\n    // Counter for minted tokens\\n    uint256 private totalMinted_;\\n    // Accurate count of circulating supply (decremented on burns)\\n    uint256 private circulatingSupply_;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    struct TokenInfo{\\n        address creator;\\n        address currentOwner;\\n        string uri;\\n    }\\n    string _name;\\n    string _symbol; \\n\\n    // token ID => Owner \\n    mapping(uint256 => TokenInfo) internal tokens_;\\n    // Owner => Token IDs => is owner\\n    mapping(address => mapping(uint256 => bool)) internal owners_;\\n    // Owner => tokens owned counter\\n    mapping(address => uint256) internal ownerBalances_;\\n    // Approvals for token spending | owner => spender => token ID => approved\\n    mapping(address => mapping(address => mapping (uint256 => bool))) internal approvals_;\\n    // Counter for batch mints\\n    uint256 internal batchMintCounter_;\\n    // Storage for batch minted tokens (where they are duplicates)\\n    struct BatchTokens {\\n        uint256 baseToken;\\n        uint256[] tokenIDs;\\n        bool limitedStock;\\n        uint256 totalMinted;\\n    }\\n    // Storage of Batch IDs to their batch tokens\\n    mapping(uint256 => BatchTokens) internal batchTokens_;\\n    // Token ID => their batch number. 0 if they are not batch tokens\\n    mapping(uint256 => uint256) internal isBatchToken_;\\n\\n\\n    // -----------------------------------------------------------------------\\n    // EVENTS \\n    // -----------------------------------------------------------------------\\n\\n    event ApprovalSet(\\n        address owner,\\n        address spender,\\n        uint256 tokenID,\\n        bool approval\\n    );\\n\\n    event BatchTransfer(\\n        address from,\\n        address to,\\n        uint256[] tokenIDs\\n    );\\n\\n    // -----------------------------------------------------------------------\\n    // CONSTRUCTOR \\n    // -----------------------------------------------------------------------\\n\\n    constructor(string memory name,\\n        string memory symbol) {\\n            _name = name;\\n            _symbol = symbol;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _tokenID The ID of the token\\n     * @return  address of the owner for this token  \\n     */\\n    function ownerOf(uint256 _tokenID) public override view returns(address) {\\n        return tokens_[_tokenID].currentOwner;\\n    }\\n\\n    /**\\n     * @param   _tokenID The ID of the token\\n     * @return  address of the creator of the token\\n     */\\n    function creatorOf(uint256 _tokenID) external view returns(address) {\\n        return tokens_[_tokenID].creator; \\n    }\\n\\n    /**\\n     * @param   _owner The address of the address to check\\n     * @return  uint256 The number of tokens the user owns\\n     */\\n    function balanceOf(address _owner) public override view returns(uint256) {\\n        return ownerBalances_[_owner];\\n    }\\n\\n    /**\\n     * @return  uint256 The total number of circulating tokens\\n     */\\n    function totalSupply() public  view returns(uint256) {\\n        return circulatingSupply_;\\n    } \\n\\n    /**\\n     * @return  uint256 The total number of unique tokens minted\\n     */\\n    function totalMintedTokens() external view returns(uint256) {\\n        return totalMinted_;\\n    }\\n   function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n    /**\\n     * @param   _owner Address of the owner\\n     * @param   _spender The address of the spender\\n     * @param   _tokenID ID of the token to check\\n     * @return  bool The approved status of the spender against the owner\\n     */\\n    function isApprovedSpenderOf(\\n        address _owner, \\n        address _spender, \\n        uint256 _tokenID\\n    )\\n        external\\n        view\\n        returns(bool)\\n    {\\n        return approvals_[_owner][_spender][_tokenID];\\n    }\\n\\n    /**\\n     * @param   _tokenId ID of the token to get the URI of\\n     * @return  string the token URI\\n     */\\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\\n        return tokens_[_tokenId].uri;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLIC STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _spender The address of the spender\\n     * @param   _tokenID ID of the token to check\\n     * @param   _approvalSpender The status of the spenders approval on the \\n     *          owner\\n     * @notice  Will revert if msg.sender is the spender or if the msg.sender\\n     *          is not the owner of the token.\\n     */\\n    function approveSpender(\\n        address _spender,\\n        uint256 _tokenID,\\n        bool _approvalSpender\\n    )\\n        external \\n    {\\n        require(\\n            msg.sender != _spender, \\n            \\\"NFT: cannot approve self\\\"\\n        );\\n        require(\\n            tokens_[_tokenID].currentOwner == msg.sender,\\n            \\\"NFT: Only owner can approve\\\"\\n        );\\n        // Set approval status\\n        approvals_[msg.sender][_spender][_tokenID] = _approvalSpender;\\n\\n        emit ApprovalSet(\\n            msg.sender,\\n            _spender,\\n            _tokenID,\\n            _approvalSpender\\n        );\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // ERC721 Functions\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n    function transferFrom(address from, address to, uint256 tokenId) virtual external override {\\n         _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n    }\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) virtual external override{\\n         _transferFrom(from, to, tokenId);\\n\\n    }\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) virtual external override{\\n         _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) virtual external override{\\n        require(operator != msg.sender, \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[msg.sender][operator] = _approved;\\n        emit ApprovalForAll(msg.sender, operator, _approved);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n    // -----------------------------------------------------------------------\\n    // INTERNAL STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param    _oldOwner Address of the old owner losing the token\\n     * @param   _newOwner Address of the new owner gaining the token\\n     * @param   _tokenID ID of the token getting transferred\\n     */\\n    function _changeOwner(\\n        address _oldOwner,\\n        address _newOwner,\\n        uint256 _tokenID\\n    )\\n        internal\\n    {\\n        // Changing the tokens owner to the new owner\\n        tokens_[_tokenID].currentOwner = _newOwner;\\n        // Removing the token from the old owner\\n        owners_[_oldOwner][_tokenID] = false;\\n        // Reducing the old owners token count\\n        ownerBalances_[_oldOwner] = ownerBalances_[_oldOwner].sub(1);\\n        // Adding the token to the new owner\\n        owners_[_newOwner][_tokenID] = true;\\n        // Increasing the new owners token count\\n        ownerBalances_[_newOwner] = ownerBalances_[_newOwner].add(1);\\n    }\\n\\n    /**\\n     * @param   _to Address to transfer to\\n     * @param   _tokenID Token being transferred\\n     * @notice  Will revert if to address is the 0x address. Will revert if the \\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function _transfer(\\n        address _to,\\n        uint256 _tokenID\\n    )\\n        internal \\n    {\\n        require(_to != address(0), \\\"NFT: Cannot send to zero address\\\");\\n        require(\\n            tokens_[_tokenID].currentOwner == msg.sender,\\n            \\\"NFT: Only owner can transfer\\\"\\n        );\\n        require(\\n            _to != msg.sender,\\n            \\\"NFT: Cannot transfer to self\\\"\\n        );\\n        // Updating storage to reflect transfer\\n        _changeOwner(\\n            msg.sender,\\n            _to,\\n            _tokenID\\n        );\\n        emit Transfer(\\n            msg.sender,\\n            _to,\\n            _tokenID\\n        );\\n    }\\n\\n    /**\\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Will revert if to address is the 0x address. Will revert if the \\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function _batchTransfer(\\n        address _to,\\n        uint256[] memory _tokenIDs\\n    )\\n        internal\\n    {\\n        require(_to != address(0), \\\"NFT: Cannot send to zero address\\\");\\n        require(\\n            _to != msg.sender,\\n            \\\"NFT: Cannot transfer to self\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _tokenIDs.length; i++) {\\n            require(\\n                tokens_[_tokenIDs[i]].currentOwner == msg.sender,\\n                \\\"NFT: Only owner can transfer\\\"\\n            );\\n            // Updating storage to reflect transfer\\n            _changeOwner(\\n                msg.sender,\\n                _to,\\n                _tokenIDs[i]\\n            );\\n        }\\n\\n        emit BatchTransfer(\\n            msg.sender,\\n            _to,\\n            _tokenIDs\\n        );\\n    }\\n\\n    /**\\n     * @param   _from Address being transferee from \\n     * @param   _to Address to transfer to\\n     * @param   _tokenID ID of token being transferred\\n     * @notice  Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if \\n     *          _from is _to address.\\n     */\\n    function _transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenID\\n    )\\n        internal\\n    {\\n        require(_to != address(0), \\\"NFT: Cannot send to zero address\\\");\\n        require(\\n            approvals_[_from][msg.sender][_tokenID],\\n            \\\"NFT: Caller not approved\\\"\\n        );\\n        require(\\n            tokens_[_tokenID].currentOwner == _from,\\n            \\\"NFT: From is not token owner\\\"\\n        );\\n        require(\\n            _to != _from,\\n            \\\"NFT: Cannot transfer to self\\\"\\n        );\\n        // Removing spender as approved spender of token on owner\\n        approvals_[_from][msg.sender][_tokenID] = false;\\n        // Updating storage to reflect transfer\\n        _changeOwner(\\n            _from,\\n            _to,\\n            _tokenID\\n        );\\n\\n        emit Transfer(\\n            _from,\\n            _to,\\n            _tokenID\\n        );\\n    }\\n\\n    /**\\n     * @param   _from Address being transferee from \\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if \\n     *          _from is _to address.\\n     */\\n    function _batchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] memory _tokenIDs\\n    )\\n        internal\\n    {\\n        require(_to != address(0), \\\"NFT: Cannot send to zero address\\\");\\n        require(\\n            _to != _from,\\n            \\\"NFT: Cannot transfer to self\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _tokenIDs.length; i++) {\\n            require(\\n                approvals_[_from][msg.sender][_tokenIDs[i]],\\n                \\\"NFT: Caller not approved\\\"\\n            );\\n            // Removing spender as approved spender of token on owner\\n            approvals_[_from][msg.sender][_tokenIDs[i]] = false;\\n            require(\\n                tokens_[_tokenIDs[i]].currentOwner == _from,\\n                \\\"NFT: From is not token owner\\\"\\n            );\\n            // Updating storage to reflect transfer\\n            _changeOwner(\\n                _from,\\n                _to,\\n                _tokenIDs[i]\\n            );\\n        }\\n        \\n        emit BatchTransfer(\\n            _from,\\n            _to,\\n            _tokenIDs\\n        );\\n    }\\n\\n    /**\\n     * @param   _owner Address of the owner of the newly created token\\n     * @param   _tokenID Token ID of the new token created\\n     */\\n    function _createToken(\\n        address _owner,\\n        address _creator,\\n        uint256 _tokenID,\\n        string memory _uri\\n    )\\n        internal\\n    {\\n        // Setting the creator\\n        tokens_[_tokenID].creator = _creator;\\n        // Adding the tokens owner\\n        tokens_[_tokenID].currentOwner = _owner;\\n        // Adding the URI for the token\\n        tokens_[_tokenID].uri = _uri;\\n        // Adding the token to the owner\\n        owners_[_owner][_tokenID] = true;\\n        // Increasing the owners token count\\n        ownerBalances_[_owner] = ownerBalances_[_owner].add(1);\\n    }\\n\\n    /**\\n     * @param   _to Address receiving the newly minted token\\n     * @return  uint256 The ID of the new token created\\n     * @notice  Will revert if _to is the 0x address\\n     */\\n    function _mint(address _to, address _creator, string memory _uri) internal returns(uint256) {\\n        require(_to != address(0), \\\"NFT: Cannot mint to zero address\\\");\\n        // Incrementing token trackers\\n        totalMinted_ = totalMinted_.add(1);\\n        circulatingSupply_ = circulatingSupply_.add(1);\\n\\n        uint256 tokenID = totalMinted_;\\n        // Updating the state with the new token\\n        _createToken(\\n            _to,\\n            _creator,\\n            tokenID,\\n            _uri\\n        );\\n\\n        emit Transfer(\\n            address(0),\\n            _to,\\n            tokenID\\n        );\\n\\n        return tokenID;\\n    }\\n\\n     /**\\n     * @param   _to Address receiving the newly minted tokens\\n     * @param   _amount The amount of tokens to mint\\n     * @return  uint256[] The IDs of the new tokens created\\n     * @notice  Will revert if _to is the 0x address\\n     */\\n    function _batchMint(\\n        address _to, \\n        address _creator,\\n        uint256 _amount,\\n        uint256 _originalTokenID,\\n        uint256 _batchID\\n    ) \\n        internal \\n        returns(uint256[] memory, uint256) \\n    {\\n        require(_to != address(0), \\\"NFT: Cannot mint to zero address\\\");\\n\\n        uint256[] memory tokenIDs = new uint256[](_amount);\\n\\n        string memory uri = this.tokenURI(_originalTokenID);\\n\\n        uint256 batch;\\n\\n        if(_batchID == 0) {\\n            batchMintCounter_ += 1;\\n            batch = batchMintCounter_;\\n        }\\n\\n        for (uint256 i = 0; i < _amount; i++) {\\n            _mint(_to, _creator, uri);\\n            tokenIDs[i] = totalMinted_;\\n            batchTokens_[batch].tokenIDs.push(totalMinted_);\\n        }\\n\\n        emit BatchTransfer(\\n            address(0),\\n            _to,\\n            tokenIDs\\n        );\\n\\n        return (tokenIDs, batch);\\n    }\\n\\n    /**\\n     * @param   _owner Address of the owner \\n     * @param   _tokenID Token ID of the token being destroyed\\n     */\\n    function _destroyToken(\\n        address _owner,\\n        uint256 _tokenID\\n    )\\n        internal\\n    {\\n        // Reducing circulating supply. \\n        circulatingSupply_ = circulatingSupply_.sub(1);\\n        // Removing the tokens owner\\n        tokens_[_tokenID].currentOwner = address(0);\\n        // Remove the tokens creator\\n        tokens_[_tokenID].creator = address(0);\\n        // Removing the token from the owner\\n        owners_[_owner][_tokenID] = false;\\n        // Decreasing the owners token count\\n        ownerBalances_[_owner] = ownerBalances_[_owner].sub(1);\\n    }\\n\\n    /**\\n     * @param   _from Address that was the last owner of the token\\n     * @param   _tokenID Token ID of the token being burnt\\n     */\\n    function _burn(address _from, uint256 _tokenID) internal {\\n        require(_from != address(0), \\\"NFT: Cannot burn from zero address\\\");\\n\\n        _destroyToken(\\n            _from,\\n            _tokenID\\n        );\\n\\n        emit Transfer(\\n            _from,\\n            address(0),\\n            _tokenID\\n        );\\n    }\\n\\n    /**\\n     * @param   _from Address that was the last owner of the token\\n     * @param   _tokenIDs Array of the token IDs being burnt\\n     */\\n    function _batchBurn(address _from, uint256[] memory _tokenIDs) internal {\\n        require(_from != address(0), \\\"NFT: Cannot burn from zero address\\\");\\n\\n        for (uint256 i = 0; i < _tokenIDs.length; i++) {\\n            _destroyToken(\\n                _from,\\n                _tokenIDs[i]\\n            );\\n        }\\n\\n        emit BatchTransfer(\\n            _from,\\n            address(0),\\n            _tokenIDs\\n        );\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return tokens_[tokenId].currentOwner != address(0);\\n    }\\n}\"\r\n    },\r\n    \"contracts/auctions/IHub.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IHub {\\n    enum LotStatus {\\n        NO_LOT,\\n        LOT_REQUESTED,\\n        LOT_CREATED,\\n        AUCTION_ACTIVE,\\n        AUCTION_RESOLVED,\\n        AUCTION_RESOLVED_AND_CLAIMED,\\n        AUCTION_CANCELED\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    function getLotInformation(uint256 _lotID)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            uint256 tokenID,\\n            uint256 auctionID,\\n            LotStatus status\\n        );\\n\\n    function getAuctionInformation(uint256 _auctionID)\\n        external\\n        view\\n        returns (\\n            bool active,\\n            string memory auctionName,\\n            address auctionContract,\\n            bool onlyPrimarySales\\n        );\\n\\n    function getAuctionID(address _auction) external view returns (uint256);\\n\\n    function isAuctionActive(uint256 _auctionID) external view returns (bool);\\n\\n    function getAuctionCount() external view returns (uint256);\\n\\n    function isAuctionHubImplementation() external view returns (bool);\\n\\n    function isFirstSale(uint256 _tokenID) external view returns (bool);\\n\\n    function getFirstSaleSplit()\\n        external\\n        view\\n        returns (uint256 creatorSplit, uint256 systemSplit);\\n\\n    function getSecondarySaleSplits()\\n        external\\n        view\\n        returns (\\n            uint256 creatorSplit,\\n            uint256 sellerSplit,\\n            uint256 systemSplit\\n        );\\n\\n    function getScalingFactor() external view returns (uint256);\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLIC STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function requestAuctionLot(uint256 _auctionType, uint256 _tokenID)\\n        external\\n        returns (uint256 lotID);\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY AUCTIONS STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function firstSaleCompleted(uint256 _tokenID) external;\\n\\n    function lotCreated(uint256 _auctionID, uint256 _lotID) external;\\n\\n    function lotAuctionStarted(uint256 _auctionID, uint256 _lotID) external;\\n\\n    function lotAuctionCompleted(uint256 _auctionID, uint256 _lotID) external;\\n\\n    function lotAuctionCompletedAndClaimed(uint256 _auctionID, uint256 _lotID)\\n        external;\\n\\n    function cancelLot(uint256 _auctionID, uint256 _lotID) external;\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY REGISTRY STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function init() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/registry/Registry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n// Registry managed contracts\\nimport \\\"../auctions/IHub.sol\\\";\\nimport \\\"../royalties/IRoyalties.sol\\\";\\nimport \\\"../nft/INft.sol\\\";\\n\\ncontract Registry is Ownable, ReentrancyGuard {\\n    // -----------------------------------------------------------------------\\n    // STATE\\n    // -----------------------------------------------------------------------\\n\\n    // Storage of current hub instance\\n    IHub internal hubInstance_;\\n    // Storage of current royalties instance\\n    IRoyalties internal royaltiesInstance_;\\n    // Storage of NFT contract (cannot be changed)\\n    INft internal nftInstance_;\\n\\n    // -----------------------------------------------------------------------\\n    // CONSTRUCTOR\\n    // -----------------------------------------------------------------------\\n\\n    constructor(address _nft) Ownable() {\\n        require(INft(_nft).isActive(), \\\"REG: Address invalid NFT\\\");\\n        nftInstance_ = INft(_nft);\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    function getHub() external view returns (address) {\\n        return address(hubInstance_);\\n    }\\n\\n    function getRoyalties() external view returns (address) {\\n        return address(royaltiesInstance_);\\n    }\\n\\n    function getNft() external view returns (address) {\\n        return address(nftInstance_);\\n    }\\n\\n    function isActive() external view returns (bool) {\\n        return true;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //  ONLY OWNER STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function updateHub(address _newHub) external onlyOwner nonReentrant {\\n        IHub newHub = IHub(_newHub);\\n        require(_newHub != address(0), \\\"REG: cannot set HUB to 0x\\\");\\n        require(\\n            address(hubInstance_) != _newHub,\\n            \\\"REG: Cannot set HUB to existing\\\"\\n        );\\n        require(\\n            newHub.isAuctionHubImplementation(),\\n            \\\"REG: HUB implementation error\\\"\\n        );\\n        require(IHub(_newHub).init(), \\\"REG: HUB could not be init\\\");\\n        hubInstance_ = IHub(_newHub);\\n    }\\n\\n    function updateRoyalties(address _newRoyalties)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        require(_newRoyalties != address(0), \\\"REG: cannot set ROY to 0x\\\");\\n        require(\\n            address(royaltiesInstance_) != _newRoyalties,\\n            \\\"REG: Cannot set ROY to existing\\\"\\n        );\\n        require(IRoyalties(_newRoyalties).init(), \\\"REG: ROY could not be init\\\");\\n        royaltiesInstance_ = IRoyalties(_newRoyalties);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/royalties/IRoyalties.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IRoyalties {\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    function getBalance(address _user) external view returns (uint256);\\n\\n    function getCollateral() external view returns (address);\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLIC STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function deposit(address _to, uint256 _amount) external payable;\\n\\n    function withdraw(uint256 _amount) external payable;\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY REGISTRY STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function init() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/nft/INft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface INft {\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _tokenID The ID of the token\\n     * @return  address of the owner for this token  \\n     */\\n    function ownerOf(uint256 _tokenID) external view returns(address);\\n\\n    /**\\n     * @param   _tokenID The ID of the token\\n     * @return  address of the creator of the token\\n     */\\n    function creatorOf(uint256 _tokenID) external view returns(address);\\n\\n    /**\\n     * @param   _owner The address of the address to check\\n     * @return  uint256 The number of tokens the user owns\\n     */\\n    function balanceOf(address _owner) external view returns(uint256);\\n\\n    /**\\n     * @return  uint256 The total number of circulating tokens\\n     */\\n    function totalSupply() external view returns(uint256);\\n\\n    /**\\n     * @param   _owner Address of the owner\\n     * @param   _spender The address of the spender\\n     * @param   _tokenID ID of the token to check\\n     * @return  bool The approved status of the spender against the owner\\n     */\\n    function isApprovedSpenderOf(\\n        address _owner, \\n        address _spender, \\n        uint256 _tokenID\\n    )\\n        external\\n        view\\n        returns(bool);\\n\\n    /**\\n     * @param   _minter Address of the minter being checked\\n     * @return  isMinter If the minter has the minter role\\n     * @return  isActiveMinter If the minter is an active minter \\n     */\\n    function isMinter(\\n        address _minter\\n    ) \\n        external \\n        view \\n        returns(\\n            bool isMinter, \\n            bool isActiveMinter\\n        );\\n\\n    function isActive() external view returns(bool);\\n\\n    function isTokenBatch(uint256 _tokenID) external view returns(uint256);\\n\\n    function getBatchInfo(\\n        uint256 _batchID\\n    ) \\n        external \\n        view\\n        returns(\\n            uint256 baseTokenID,\\n            uint256[] memory tokenIDs,\\n            bool limitedStock,\\n            uint256 totalMinted\\n        );\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLIC STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _spender The address of the spender\\n     * @param   _tokenID ID of the token to check\\n     * @param   _approvalSpender The status of the spenders approval on the \\n     *          owner\\n     * @notice  Will revert if msg.sender is the spender or if the msg.sender\\n     *          is not the owner of the token.\\n     */\\n    function approveSpender(\\n        address _spender,\\n        uint256 _tokenID,\\n        bool _approvalSpender\\n    )\\n        external;\\n\\n    // -----------------------------------------------------------------------\\n    //  ONLY AUCTIONS (hub or spokes) STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _to Address of receiver \\n     * @param   _tokenID Token to transfer\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if the \\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _tokenID\\n    )\\n        external;\\n\\n    /**\\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if the \\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function batchTransfer(\\n        address _to,\\n        uint256[] memory _tokenIDs\\n    )\\n        external;\\n\\n    /**\\n     * @param   _from Address being transferee from \\n     * @param   _to Address to transfer to\\n     * @param   _tokenID ID of token being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if \\n     *          _from is _to address.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenID\\n    )\\n        external;\\n\\n    /**\\n     * @param   _from Address being transferee from \\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if \\n     *          _from is _to address.\\n     */\\n    function batchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] memory _tokenIDs\\n    )\\n        external;\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY MINTER STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _tokenCreator Address of the creator. Address will receive the \\n     *          royalties from sales of the NFT\\n     * @param   _mintTo The address that should receive the token. Note that on\\n     *          the initial sale this address will not receive the sale \\n     *          collateral. Sale collateral will be distributed to creator and\\n     *          system fees\\n     * @notice  Only valid active minters will be able to mint new tokens\\n     */\\n    function mint(\\n        address _tokenCreator, \\n        address _mintTo,\\n        string calldata identifier,      \\n        string calldata location,\\n        bytes32 contentHash \\n    ) external returns(uint256);\\n\\n    /**\\n     * @param   _mintTo The address that should receive the token. Note that on\\n     *          the initial sale this address will not receive the sale \\n     *          collateral. Sale collateral will be distributed to creator and\\n     *          system fees\\n     * @param   _amount Amount of tokens to mint\\n     * @param   _baseTokenID ID of the token being duplicated\\n     * @param   _isLimitedStock Bool for if the batch has a pre-set limit\\n     */\\n    function batchDuplicateMint(\\n        address _mintTo,\\n        uint256 _amount,\\n        uint256 _baseTokenID,\\n        bool _isLimitedStock\\n    )\\n        external\\n        returns(uint256[] memory);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approval\",\"type\":\"bool\"}],\"name\":\"ApprovalSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"BatchTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDuplicateMinter\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isMinter\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActiveMinter\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"userIdentifier\",\"type\":\"string\"}],\"name\":\"MinterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"NewBatchTokenMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"NewTokenMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"location\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"contentHash\",\"type\":\"string\"}],\"name\":\"NewTokensMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approvalSpender\",\"type\":\"bool\"}],\"name\":\"approveSpender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mintTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseTokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLimitedStock\",\"type\":\"bool\"}],\"name\":\"batchDuplicateMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"creatorOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_batchID\",\"type\":\"uint256\"}],\"name\":\"getBatchInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"limitedStock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"isApprovedSpenderOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMinter\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActiveMinter\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"isTokenBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenCreator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mintTo\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"location\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contentHash\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isDuplicateMinter\",\"type\":\"bool\"}],\"name\":\"setDuplicateMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_hasMinterPermissions\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isActiveMinter\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_userIdentifier\",\"type\":\"string\"}],\"name\":\"updateMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OpenNFT","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000006457463686564000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044554434800000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}