{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor () {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The defaut value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overloaded;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/VerifiedAccount.sol\r\n\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\n\r\n\r\nabstract contract VerifiedAccount is ERC20, Ownable {\r\n\r\n    mapping(address => bool) private _isRegistered;\r\n\r\n    constructor () {\r\n        // The smart contract starts off registering itself, since address is known.\r\n        registerAccount();\r\n    }\r\n\r\n    event AccountRegistered(address indexed account);\r\n\r\n    /**\r\n     * This registers the calling wallet address as a known address. Operations that transfer responsibility\r\n     * may require the target account to be a registered account, to protect the system from getting into a\r\n     * state where administration or a large amount of funds can become forever inaccessible.\r\n     */\r\n    function registerAccount() public {\r\n        _isRegistered[msg.sender] = true;\r\n        emit AccountRegistered(msg.sender);\r\n    }\r\n\r\n    function isRegistered(address account) public view returns (bool) {\r\n        return _isRegistered[account];\r\n    }\r\n\r\n    function _accountExists(address account) internal view returns (bool) {\r\n        return account == msg.sender || _isRegistered[account];\r\n    }\r\n\r\n    modifier onlyExistingAccount(address account) {\r\n        require(_accountExists(account), \"account not registered\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwnerOrSelf(address account) {\r\n        require(owner() == _msgSender() || msg.sender == account, \"onlyOwnerOrSelf\");\r\n        _;\r\n    }\r\n\r\n    // =========================================================================\r\n    // === Safe ERC20 methods\r\n    // =========================================================================\r\n\r\n    function safeTransfer(address to, uint256 value) public onlyExistingAccount(to) returns (bool) {\r\n        if(value == 0) return false;\r\n        require(transfer(to, value), \"error in transfer\");\r\n        return true;\r\n    }\r\n\r\n    function safeApprove(address spender, uint256 value) public onlyExistingAccount(spender) returns (bool) {\r\n        require(approve(spender, value), \"error in approve\");\r\n        return true;\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 value) public onlyExistingAccount(to) returns (bool) {\r\n        if(value == 0) return false;\r\n        require(transferFrom(from, to, value), \"error in transferFrom\");\r\n        return true;\r\n    }\r\n\r\n\r\n    // =========================================================================\r\n    // === Safe ownership transfer\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public override onlyExistingAccount(newOwner) onlyOwner {\r\n        super.transferOwnership(newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/IERC20Vestable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\ninterface IERC20Vestable {\r\n\r\n    function grantVestingTokens(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 vestingAmount,\r\n        uint32 startDay,\r\n        uint32 duration,\r\n        uint32 cliffDuration,\r\n        uint32 interval\r\n    ) external returns (bool ok);\r\n\r\n    function today() external view returns (uint32 dayNumber);\r\n\r\n    function vestingForAccountAsOf(\r\n        address grantHolder,\r\n        uint32 onDayOrToday\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        uint256 amountVested,\r\n        uint256 amountNotVested,\r\n        uint256 amountOfGrant,\r\n        uint32 vestStartDay,\r\n        uint32 cliffDuration,\r\n        uint32 vestDuration,\r\n        uint32 vestIntervalDays\r\n    );\r\n\r\n    function vestingAsOf(uint32 onDayOrToday) external view returns (\r\n        uint256 amountVested,\r\n        uint256 amountNotVested,\r\n        uint256 amountOfGrant,\r\n        uint32 vestStartDay,\r\n        uint32 cliffDuration,\r\n        uint32 vestDuration,\r\n        uint32 vestIntervalDays\r\n    );\r\n\r\n    event VestingScheduleCreated(\r\n        address indexed vestingLocation,\r\n        uint32 cliffDuration, \r\n        uint32 indexed duration, \r\n        uint32 interval);\r\n\r\n    event VestingTokensGranted(\r\n        address indexed beneficiary,\r\n        uint256 indexed vestingAmount,\r\n        uint32 startDay,\r\n        address vestingLocation,\r\n        address indexed grantor);\r\n}\r\n\r\n// File: contracts/ERC20Vestable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contract for grantable ERC20 token vesting schedules\r\n *\r\n * @notice Adds to an ERC20 support for grantor wallets, which are able to grant vesting tokens to\r\n *   beneficiary wallets, following per-wallet custom vesting schedules.\r\n *\r\n * @dev Contract which gives subclass contracts the ability to act as a pool of funds for allocating\r\n *   tokens to any number of other addresses. Token grants support the ability to vest over time in\r\n *   accordance a predefined vesting schedule. A given wallet can receive no more than one token grant.\r\n *\r\n *   Tokens are transferred from the pool to the recipient at the time of grant, but the recipient\r\n *   will only able to transfer tokens out of their wallet after they have vested. Transfers of non-\r\n *   vested tokens are prevented.\r\n *\r\n *   Two types of toke grants are supported:\r\n *   - Irrevocable grants, intended for use in cases when vesting tokens have been issued in exchange\r\n *     for value, such as with tokens that have been purchased in an ICO.\r\n *   - Revocable grants, intended for use in cases when vesting tokens have been gifted to the holder,\r\n *     such as with employee grants that are given as compensation.\r\n */\r\nabstract contract ERC20Vestable is ERC20, IERC20Vestable, VerifiedAccount {\r\n\r\n    // Date-related constants for sanity-checking dates to reject obvious erroneous inputs\r\n    // and conversions from seconds to days and years that are more or less leap year-aware.\r\n    uint32 private constant THOUSAND_YEARS_DAYS = 365243;                   /* See https://www.timeanddate.com/date/durationresult.html?m1=1&d1=1&y1=2000&m2=1&d2=1&y2=3000 */\r\n    uint32 private constant TEN_YEARS_DAYS = THOUSAND_YEARS_DAYS / 100;     /* Includes leap years (though it doesn't really matter) */\r\n    uint32 private constant SECONDS_PER_DAY = 24 * 60 * 60;                 /* 86400 seconds in a day */\r\n    uint32 private constant JAN_1_3000_DAYS = 4102444800;  /* Wednesday, January 1, 2100 0:00:00 (GMT) (see https://www.epochconverter.com/) */\r\n\r\n    struct vestingSchedule {\r\n        bool isValid;               /* true if an entry exists and is valid */\r\n        uint32 cliffDuration;       /* Duration of the cliff, with respect to the grant start day, in days. */\r\n        uint32 duration;            /* Duration of the vesting schedule, with respect to the grant start day, in days. */\r\n        uint32 interval;            /* Duration in days of the vesting interval. */\r\n    }\r\n\r\n    struct tokenGrant {\r\n        bool isActive;              /* true if this vesting entry is active and in-effect entry. */\r\n        uint32 startDay;            /* Start day of the grant, in days since the UNIX epoch (start of day). */\r\n        address vestingLocation;    /* Address of wallet that is holding the vesting schedule. */\r\n        address grantor;            /* Grantor that made the grant */\r\n        uint256 amount;             /* Total number of tokens that vest. */\r\n    }\r\n\r\n    mapping(address => vestingSchedule) private _vestingSchedules;\r\n    mapping(address => tokenGrant) private _tokenGrants;\r\n\r\n    // =========================================================================\r\n    // === Methods for administratively creating a vesting schedule for an account.\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @dev This one-time operation permanently establishes a vesting schedule in the given account.\r\n     *\r\n     * For standard grants, this establishes the vesting schedule in the beneficiary's account.\r\n     *\r\n     * @param vestingLocation = Account into which to store the vesting schedule. Can be the account\r\n     *   of the beneficiary (for one-off grants) or the account of the grantor (for uniform grants\r\n     *   made from grant pools).\r\n     * @param cliffDuration = Duration of the cliff, with respect to the grant start day, in days.\r\n     * @param duration = Duration of the vesting schedule, with respect to the grant start day, in days.\r\n     * @param interval = Number of days between vesting increases.\r\n     *   be revoked (i.e. tokens were purchased).\r\n     */\r\n    function _setVestingSchedule(\r\n        address vestingLocation,\r\n        uint32 cliffDuration, \r\n        uint32 duration, \r\n        uint32 interval\r\n        ) internal returns (bool) {\r\n\r\n        // Check for a valid vesting schedule given (disallow absurd values to reject likely bad input).\r\n        require(\r\n            duration > 0 && duration <= TEN_YEARS_DAYS\r\n            && cliffDuration < duration\r\n            && interval >= 1,\r\n            \"invalid vesting schedule\"\r\n        );\r\n\r\n        // Make sure the duration values are in harmony with interval (both should be an exact multiple of interval).\r\n        require(\r\n            duration % interval == 0 && cliffDuration % interval == 0,\r\n            \"invalid cliff/duration for interval\"\r\n        );\r\n\r\n        // Create and populate a vesting schedule.\r\n        _vestingSchedules[vestingLocation] = vestingSchedule(\r\n            true,cliffDuration, duration, interval\r\n        );\r\n\r\n        // Emit the event and return success.\r\n        emit VestingScheduleCreated(\r\n            vestingLocation,\r\n            cliffDuration, duration, interval);\r\n        return true;\r\n    }\r\n\r\n    function _hasVestingSchedule(address account) internal view returns (bool) {\r\n        return _vestingSchedules[account].isValid;\r\n    }\r\n\r\n    // =========================================================================\r\n    // === Token grants (general-purpose)\r\n    // === Methods to be used for administratively creating one-off token grants with vesting schedules.\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @dev Immediately grants tokens to an account, referencing a vesting schedule which may be\r\n     * stored in the same account (individual/one-off) or in a different account (shared/uniform).\r\n     *\r\n     * @param beneficiary = Address to which tokens will be granted.\r\n     * @param totalAmount = Total number of tokens to deposit into the account.\r\n     * @param vestingAmount = Out of totalAmount, the number of tokens subject to vesting.\r\n     * @param startDay = Start day of the grant's vesting schedule, in days since the UNIX epoch\r\n     *   (start of day). The startDay may be given as a date in the future or in the past, going as far\r\n     *   back as year 2000.\r\n     * @param vestingLocation = Account where the vesting schedule is held (must already exist).\r\n     * @param grantor = Account which performed the grant. Also the account from where the granted\r\n     *   funds will be withdrawn.\r\n     */\r\n    function _grantVestingTokens(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 vestingAmount,\r\n        uint32 startDay,\r\n        address vestingLocation,\r\n        address grantor\r\n    )\r\n    internal returns (bool)\r\n    {\r\n        // Make sure no prior grant is in effect.\r\n        require(!_tokenGrants[beneficiary].isActive, \"grant already exists\");\r\n\r\n        // Check for valid vestingAmount\r\n        require(\r\n            vestingAmount <= totalAmount && vestingAmount > 0\r\n            && startDay >= this.today() && startDay < JAN_1_3000_DAYS,\r\n            \"invalid vesting params\");\r\n\r\n        // Make sure the vesting schedule we are about to use is valid.\r\n        require(_hasVestingSchedule(vestingLocation), \"no such vesting schedule\");\r\n\r\n        // Transfer the total number of tokens from grantor into the account's holdings.\r\n        _transfer(grantor, beneficiary, totalAmount);\r\n        /* Emits a Transfer event. */\r\n\r\n        // Create and populate a token grant, referencing vesting schedule.\r\n        _tokenGrants[beneficiary] = tokenGrant(\r\n            true/*isActive*/,\r\n            startDay,\r\n            vestingLocation, /* The wallet address where the vesting schedule is kept. */\r\n            grantor,             /* The account that performed the grant (where revoked funds would be sent) */\r\n            vestingAmount\r\n        );\r\n\r\n        // Emit the event and return success.\r\n        emit VestingTokensGranted(beneficiary, vestingAmount, startDay, vestingLocation, grantor);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Immediately grants tokens to an address, including a portion that will vest over time\r\n     * according to a set vesting schedule. The overall duration and cliff duration of the grant must\r\n     * be an even multiple of the vesting interval.\r\n     *\r\n     * @param beneficiary = Address to which tokens will be granted.\r\n     * @param totalAmount = Total number of tokens to deposit into the account.\r\n     * @param vestingAmount = Out of totalAmount, the number of tokens subject to vesting.\r\n     * @param startDay = Start day of the grant's vesting schedule, in days since the UNIX epoch\r\n     *   (start of day). The startDay may be given as a date in the future or in the past, going as far\r\n     *   back as year 2000.\r\n     * @param duration = Duration of the vesting schedule, with respect to the grant start day, in days.\r\n     * @param cliffDuration = Duration of the cliff, with respect to the grant start day, in days.\r\n     * @param interval = Number of days between vesting increases.\r\n     *   be revoked (i.e. tokens were purchased).\r\n     */\r\n    function grantVestingTokens(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 vestingAmount,\r\n        uint32 startDay,\r\n        uint32 duration,\r\n        uint32 cliffDuration,\r\n        uint32 interval\r\n    ) public onlyOwner override returns (bool) {\r\n        // Make sure no prior vesting schedule has been set.\r\n        require(!_tokenGrants[beneficiary].isActive, \"grant already exists\");\r\n\r\n        // The vesting schedule is unique to this wallet and so will be stored here,\r\n        require(_setVestingSchedule(beneficiary, cliffDuration, duration, interval), \"error in establishing a vesting schedule\");\r\n\r\n        // Issue grantor tokens to the beneficiary, using beneficiary's own vesting schedule.\r\n        require(_grantVestingTokens(beneficiary, totalAmount, vestingAmount, startDay, beneficiary, msg.sender), \"error in granting tokens\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev This variant only grants tokens if the beneficiary account has previously self-registered.\r\n     */\r\n    function safeGrantVestingTokens(\r\n        address beneficiary, \r\n        uint256 totalAmount, \r\n        uint256 vestingAmount,\r\n        uint32 startDay, \r\n        uint32 duration, \r\n        uint32 cliffDuration, \r\n        uint32 interval\r\n        ) public onlyOwner onlyExistingAccount(beneficiary) returns (bool) {\r\n\r\n        return grantVestingTokens(\r\n            beneficiary, totalAmount, vestingAmount,\r\n            startDay, duration, cliffDuration, interval);\r\n    }\r\n\r\n\r\n    // =========================================================================\r\n    // === Check vesting.\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @dev returns the day number of the current day, in days since the UNIX epoch.\r\n     */\r\n    function today() public view override returns (uint32) {\r\n        return uint32(block.timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function _effectiveDay(uint32 onDayOrToday) internal view returns (uint32) {\r\n        return onDayOrToday == 0 ? today() : onDayOrToday;\r\n    }\r\n\r\n    /**\r\n     * @dev Determines the amount of tokens that have not vested in the given account.\r\n     *\r\n     * The math is: not vested amount = vesting amount * (end date - on date)/(end date - start date)\r\n     *\r\n     * @param grantHolder = The account to check.\r\n     * @param onDayOrToday = The day to check for, in days since the UNIX epoch. Can pass\r\n     *   the special value 0 to indicate today.\r\n     */\r\n    function _getNotVestedAmount(address grantHolder, uint32 onDayOrToday) internal view returns (uint256) {\r\n        tokenGrant storage grant = _tokenGrants[grantHolder];\r\n        vestingSchedule storage vesting = _vestingSchedules[grant.vestingLocation];\r\n        uint32 onDay = _effectiveDay(onDayOrToday);\r\n\r\n        // If there's no schedule, or before the vesting cliff, then the full amount is not vested.\r\n        if (!grant.isActive || onDay < grant.startDay + vesting.cliffDuration)\r\n        {\r\n            // None are vested (all are not vested)\r\n            return grant.amount;\r\n        }\r\n        // If after end of vesting, then the not vested amount is zero (all are vested).\r\n        else if (onDay >= grant.startDay + vesting.duration)\r\n        {\r\n            // All are vested (none are not vested)\r\n            return uint256(0);\r\n        }\r\n        // Otherwise a fractional amount is vested.\r\n        else\r\n        {\r\n            // Compute the exact number of days vested.\r\n            uint32 daysVested = onDay - grant.startDay;\r\n            // Adjust result rounding down to take into consideration the interval.\r\n            // Examples for vesting interval = 30 days\r\n            // Example 1 - daysVested = 15: (15 / 30) * 30 = 0 * 30 = 0; \r\n            // Example 2 - daysVested = 30: (30 / 30) * 30 = 1 * 30 = 30; \r\n            // Example 3 - daysVested = 65: (65 / 30) * 30 = 2 * 30 = 60; \r\n            uint32 effectiveDaysVested = (daysVested / vesting.interval) * vesting.interval;\r\n\r\n            // Compute the fraction vested from schedule using 224.32 fixed point math for date range ratio.\r\n            // Note: This is safe in 256-bit math because max value of X billion tokens = X*10^27 wei, and\r\n            // typical token amounts can fit into 90 bits. Scaling using a 32 bits value results in only 125\r\n            // bits before reducing back to 90 bits by dividing. There is plenty of room left, even for token\r\n            // amounts many orders of magnitude greater than mere billions.\r\n            // uint256 vested = grant.amount.mul(effectiveDaysVested).div(vesting.duration);\r\n            uint256 vested = (grant.amount * effectiveDaysVested) / vesting.duration;\r\n            return grant.amount - vested;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the amount of funds in the given account which are available for use as of\r\n     * the given day. If there's no vesting schedule then 0 tokens are considered to be vested and\r\n     * this just returns the full account balance.\r\n     *\r\n     * The math is: available amount = total funds - notVestedAmount.\r\n     *\r\n     * @param grantHolder = The account to check.\r\n     * @param onDay = The day to check for, in days since the UNIX epoch.\r\n     */\r\n    function _getAvailableAmount(address grantHolder, uint32 onDay) internal view returns (uint256) {\r\n        uint256 totalTokens = balanceOf(grantHolder);\r\n        return totalTokens - _getNotVestedAmount(grantHolder, onDay);\r\n    }\r\n\r\n    /*\r\n     * @dev returns all information about the grant's vesting as of the given day\r\n     * for the given account. Only callable by the account holder or a grantor, so\r\n     * this is mainly intended for administrative use.\r\n     *\r\n     * @param grantHolder = The address to do this for.\r\n     * @param onDayOrToday = The day to check for, in days since the UNIX epoch. Can pass\r\n     *   the special value 0 to indicate today.\r\n     * @return = A tuple with the following values:\r\n     *   amountVested = the amount out of vestingAmount that is vested\r\n     *   amountNotVested = the amount that is vested (equal to vestingAmount - vestedAmount)\r\n     *   amountOfGrant = the amount of tokens subject to vesting.\r\n     *   vestStartDay = starting day of the grant (in days since the UNIX epoch).\r\n     *   vestDuration = grant duration in days.\r\n     *   cliffDuration = duration of the cliff.\r\n     *   vestIntervalDays = number of days between vesting periods.\r\n     */\r\n    function vestingForAccountAsOf(\r\n        address grantHolder,\r\n        uint32 onDayOrToday\r\n    )\r\n    public\r\n    view\r\n    override\r\n    onlyOwnerOrSelf(grantHolder)\r\n    returns (\r\n        uint256 amountVested,\r\n        uint256 amountNotVested,\r\n        uint256 amountOfGrant,\r\n        uint32 vestStartDay,\r\n        uint32 vestDuration,\r\n        uint32 cliffDuration,\r\n        uint32 vestIntervalDays\r\n    )\r\n    {\r\n        tokenGrant storage grant = _tokenGrants[grantHolder];\r\n        vestingSchedule storage vesting = _vestingSchedules[grant.vestingLocation];\r\n        uint256 notVestedAmount = _getNotVestedAmount(grantHolder, onDayOrToday);\r\n        uint256 grantAmount = grant.amount;\r\n\r\n        return (\r\n        grantAmount - notVestedAmount,\r\n        notVestedAmount,\r\n        grantAmount,\r\n        grant.startDay,\r\n        vesting.duration,\r\n        vesting.cliffDuration,\r\n        vesting.interval\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @dev returns all information about the grant's vesting as of the given day\r\n     * for the current account, to be called by the account holder.\r\n     *\r\n     * @param onDayOrToday = The day to check for, in days since the UNIX epoch. Can pass\r\n     *   the special value 0 to indicate today.\r\n     * @return = A tuple with the following values:\r\n     *   amountVested = the amount out of vestingAmount that is vested\r\n     *   amountNotVested = the amount that is vested (equal to vestingAmount - vestedAmount)\r\n     *   amountOfGrant = the amount of tokens subject to vesting.\r\n     *   vestStartDay = starting day of the grant (in days since the UNIX epoch).\r\n     *   cliffDuration = duration of the cliff.\r\n     *   vestDuration = grant duration in days.\r\n     *   vestIntervalDays = number of days between vesting periods.\r\n     */\r\n    function vestingAsOf(uint32 onDayOrToday) public override view returns (\r\n        uint256 amountVested,\r\n        uint256 amountNotVested,\r\n        uint256 amountOfGrant,\r\n        uint32 vestStartDay,\r\n        uint32 vestDuration,\r\n        uint32 cliffDuration,\r\n        uint32 vestIntervalDays\r\n    )\r\n    {\r\n        return vestingForAccountAsOf(msg.sender, onDayOrToday);\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if the account has sufficient funds available to cover the given amount,\r\n     *   including consideration for vesting tokens.\r\n     *\r\n     * @param account = The account to check.\r\n     * @param amount = The required amount of vested funds.\r\n     * @param onDay = The day to check for, in days since the UNIX epoch.\r\n     */\r\n    function _fundsAreAvailableOn(address account, uint256 amount, uint32 onDay) internal view returns (bool) {\r\n        return (amount <= _getAvailableAmount(account, onDay));\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the amount is sufficiently vested right now.\r\n     *\r\n     * @param account = The account to check.\r\n     * @param amount = The required amount of vested funds.\r\n     */\r\n    modifier onlyIfFundsAvailableNow(address account, uint256 amount) {\r\n        // Distinguish insufficient overall balance from insufficient vested funds balance in failure msg.\r\n        require(_fundsAreAvailableOn(account, amount, today()),\r\n            balanceOf(account) < amount ? \"insufficient funds\" : \"insufficient vested funds\");\r\n        _;\r\n    }\r\n\r\n    // =========================================================================\r\n    // === Overridden ERC20 functionality\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @dev Methods transfer() and approve() require an additional available funds check to\r\n     * prevent spending held but non-vested tokens. Note that transferFrom() does NOT have this\r\n     * additional check because approved funds come from an already set-aside allowance, not from the wallet.\r\n     */\r\n    function transfer(address to, uint256 value) public override onlyIfFundsAvailableNow(msg.sender, value) returns (bool) {\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Additional available funds check to prevent spending held but non-vested tokens.\r\n     */\r\n    function approve(address spender, uint256 value) public override virtual onlyIfFundsAvailableNow(msg.sender, value) returns (bool) {\r\n        return super.approve(spender, value);\r\n    }\r\n}\r\n\r\n// File: contracts/XNLToken.sol\r\n\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\n\r\n\r\n/**\r\n * @title XNLToken\r\n * @dev Implementation of ERC20Token using Standard token from OpenZeppelin library\r\n * with ability to pause transfers, approvals and set vesting period for owner until ownership is renounced. \r\n * All token are assigned to owner.\r\n */\r\n \r\ncontract XNLToken is ERC20Vestable, Pausable {\r\n\r\n    uint public INITIAL_SUPPLY = 100000000 * (uint(10) ** 18); // 100,000,000 XNL\r\n\r\n    constructor() ERC20(\"Chronical\",\"XNL\") {\r\n        _mint(_msgSender(), INITIAL_SUPPLY);\r\n    }\r\n\r\n    function pause() onlyOwner() external  {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() onlyOwner() external {\r\n        _unpause();\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override whenNotPaused {\r\n        require(to != address(this), \"ERC20: transfer to the contract address\");\r\n        super._beforeTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override whenNotPaused returns (bool) {\r\n        return super.approve(spender, amount);\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual override whenNotPaused returns (bool)  {\r\n        return super.increaseAllowance(spender, addedValue);\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 addedValue) public virtual override whenNotPaused returns (bool)  {\r\n        return super.decreaseAllowance(spender, addedValue);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vestingLocation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"}],\"name\":\"VestingScheduleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vestingLocation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"grantor\",\"type\":\"address\"}],\"name\":\"VestingTokensGranted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"}],\"name\":\"grantVestingTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"}],\"name\":\"safeGrantVestingTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"today\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"onDayOrToday\",\"type\":\"uint32\"}],\"name\":\"vestingAsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountNotVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOfGrant\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"vestStartDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"vestDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"vestIntervalDays\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"grantHolder\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"onDayOrToday\",\"type\":\"uint32\"}],\"name\":\"vestingForAccountAsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountNotVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOfGrant\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"vestStartDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"vestDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"vestIntervalDays\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"XNLToken","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://58139a527c6c3b80146dd5e115e33e905aebf73a642c7c65d7da5ec6ebf34281"}]}