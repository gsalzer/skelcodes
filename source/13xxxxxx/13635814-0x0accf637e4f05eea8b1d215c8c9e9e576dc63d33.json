{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PartyBidFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\nimport {InitializedProxy} from \\\"./InitializedProxy.sol\\\";\\nimport {PartyBid} from \\\"./PartyBid.sol\\\";\\nimport {Structs} from \\\"./Structs.sol\\\";\\n\\n/**\\n * @title PartyBid Factory\\n * @author Anna Carroll\\n *\\n * WARNING: A malicious MarketWrapper contract could be used to steal user funds;\\n * A poorly implemented MarketWrapper contract could permanently lose access to the NFT.\\n * When deploying a PartyBid, exercise extreme caution.\\n * Only use MarketWrapper contracts that have been audited and tested.\\n */\\ncontract PartyBidFactory {\\n    //======== Events ========\\n\\n    event PartyBidDeployed(\\n        address partyBidProxy,\\n        address creator,\\n        address nftContract,\\n        uint256 tokenId,\\n        address marketWrapper,\\n        uint256 auctionId,\\n        address splitRecipient,\\n        uint256 splitBasisPoints,\\n        address gatedToken,\\n        uint256 gatedTokenAmount,\\n        string name,\\n        string symbol\\n    );\\n\\n    //======== Immutable storage =========\\n\\n    address public immutable logic;\\n    address public immutable partyDAOMultisig;\\n    address public immutable tokenVaultFactory;\\n    address public immutable weth;\\n\\n    //======== Mutable storage =========\\n\\n    // PartyBid proxy => block number deployed at\\n    mapping(address => uint256) public deployedAt;\\n\\n    //======== Constructor =========\\n\\n    constructor(\\n        address _partyDAOMultisig,\\n        address _tokenVaultFactory,\\n        address _weth\\n    ) {\\n        partyDAOMultisig = _partyDAOMultisig;\\n        tokenVaultFactory = _tokenVaultFactory;\\n        weth = _weth;\\n        // deploy logic contract\\n        PartyBid _logicContract = new PartyBid(_partyDAOMultisig, _tokenVaultFactory, _weth);\\n        // store logic contract address\\n        logic = address(_logicContract);\\n    }\\n\\n    //======== Deploy function =========\\n\\n    function startParty(\\n        address _marketWrapper,\\n        address _nftContract,\\n        uint256 _tokenId,\\n        uint256 _auctionId,\\n        Structs.AddressAndAmount calldata _split,\\n        Structs.AddressAndAmount calldata _tokenGate,\\n        string memory _name,\\n        string memory _symbol\\n    ) external returns (address partyBidProxy) {\\n        bytes memory _initializationCalldata =\\n            abi.encodeWithSelector(\\n                PartyBid.initialize.selector,\\n                _marketWrapper,\\n                _nftContract,\\n                _tokenId,\\n                _auctionId,\\n                _split,\\n                _tokenGate,\\n                _name,\\n                _symbol\\n            );\\n\\n        partyBidProxy = address(\\n            new InitializedProxy(\\n                logic,\\n                _initializationCalldata\\n            )\\n        );\\n\\n        deployedAt[partyBidProxy] = block.number;\\n\\n        emit PartyBidDeployed(\\n            partyBidProxy,\\n            msg.sender,\\n            _nftContract,\\n            _tokenId,\\n            _marketWrapper,\\n            _auctionId,\\n            _split.addr,\\n            _split.amount,\\n            _tokenGate.addr,\\n            _tokenGate.amount,\\n            _name,\\n            _symbol\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InitializedProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n/**\\n * @title InitializedProxy\\n * @author Anna Carroll\\n */\\ncontract InitializedProxy {\\n    // address of logic contract\\n    address public immutable logic;\\n\\n    // ======== Constructor =========\\n\\n    constructor(\\n        address _logic,\\n        bytes memory _initializationCalldata\\n    ) {\\n        logic = _logic;\\n        // Delegatecall into the logic contract, supplying initialization calldata\\n        (bool _ok, bytes memory returnData) =\\n            _logic.delegatecall(_initializationCalldata);\\n        // Revert if delegatecall to implementation reverts\\n        require(_ok, string(returnData));\\n    }\\n\\n    // ======== Fallback =========\\n\\n    fallback() external payable {\\n        address _impl = logic;\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n\\n    // ======== Receive =========\\n\\n    receive() external payable {} // solhint-disable-line no-empty-blocks\\n}\\n\"\r\n    },\r\n    \"contracts/PartyBid.sol\": {\r\n      \"content\": \"/*\\n\\n      ___           ___           ___           ___           ___           ___                       ___\\n     /\\\\  \\\\         /\\\\  \\\\         /\\\\  \\\\         /\\\\  \\\\         |\\\\__\\\\         /\\\\  \\\\          ___        /\\\\  \\\\\\n    /::\\\\  \\\\       /::\\\\  \\\\       /::\\\\  \\\\        \\\\:\\\\  \\\\        |:|  |       /::\\\\  \\\\        /\\\\  \\\\      /::\\\\  \\\\\\n   /:/\\\\:\\\\  \\\\     /:/\\\\:\\\\  \\\\     /:/\\\\:\\\\  \\\\        \\\\:\\\\  \\\\       |:|  |      /:/\\\\:\\\\  \\\\       \\\\:\\\\  \\\\    /:/\\\\:\\\\  \\\\\\n  /::\\\\~\\\\:\\\\  \\\\   /::\\\\~\\\\:\\\\  \\\\   /::\\\\~\\\\:\\\\  \\\\       /::\\\\  \\\\      |:|__|__   /::\\\\~\\\\:\\\\__\\\\      /::\\\\__\\\\  /:/  \\\\:\\\\__\\\\\\n /:/\\\\:\\\\ \\\\:\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\     /:/\\\\:\\\\__\\\\     /::::\\\\__\\\\ /:/\\\\:\\\\ \\\\:|__|  __/:/\\\\/__/ /:/__/ \\\\:|__|\\n \\\\/__\\\\:\\\\/:/  / \\\\/__\\\\:\\\\/:/  / \\\\/_|::\\\\/:/  /    /:/  \\\\/__/    /:/~~/~    \\\\:\\\\~\\\\:\\\\/:/  / /\\\\/:/  /    \\\\:\\\\  \\\\ /:/  /\\n      \\\\::/  /       \\\\::/  /     |:|::/  /    /:/  /        /:/  /       \\\\:\\\\ \\\\::/  /  \\\\::/__/      \\\\:\\\\  /:/  /\\n       \\\\/__/        /:/  /      |:|\\\\/__/     \\\\/__/         \\\\/__/         \\\\:\\\\/:/  /    \\\\:\\\\__\\\\       \\\\:\\\\/:/  /\\n                   /:/  /       |:|  |                                    \\\\::/__/      \\\\/__/        \\\\::/__/\\n                   \\\\/__/         \\\\|__|                                     ~~                        ~~\\n\\nAnna Carroll for PartyDAO\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n// ============ Internal Imports ============\\nimport {Party} from \\\"./Party.sol\\\";\\nimport {IMarketWrapper} from \\\"./market-wrapper/IMarketWrapper.sol\\\";\\nimport {Structs} from \\\"./Structs.sol\\\";\\n\\ncontract PartyBid is Party {\\n    // partyStatus Transitions:\\n    //   (1) PartyStatus.ACTIVE on deploy\\n    //   (2) PartyStatus.WON or PartyStatus.LOST on finalize()\\n\\n    // ============ Internal Constants ============\\n\\n    // PartyBid version 3\\n    uint16 public constant VERSION = 3;\\n\\n    // ============ Public Not-Mutated Storage ============\\n\\n    // market wrapper contract exposing interface for\\n    // market auctioning the NFT\\n    IMarketWrapper public marketWrapper;\\n    // ID of auction within market contract\\n    uint256 public auctionId;\\n\\n    // ============ Public Mutable Storage ============\\n\\n    // the highest bid submitted by PartyBid\\n    uint256 public highestBid;\\n\\n    // ============ Events ============\\n\\n    event Bid(uint256 amount);\\n\\n    event Finalized(PartyStatus result, uint256 totalSpent, uint256 fee, uint256 totalContributed);\\n\\n    // ======== Constructor =========\\n\\n    constructor(\\n        address _partyDAOMultisig,\\n        address _tokenVaultFactory,\\n        address _weth\\n    ) Party(_partyDAOMultisig, _tokenVaultFactory, _weth) {}\\n\\n    // ======== Initializer =========\\n\\n    function initialize(\\n        address _marketWrapper,\\n        address _nftContract,\\n        uint256 _tokenId,\\n        uint256 _auctionId,\\n        Structs.AddressAndAmount calldata _split,\\n        Structs.AddressAndAmount calldata _tokenGate,\\n        string memory _name,\\n        string memory _symbol\\n    ) external initializer {\\n        // validate auction exists\\n        require(\\n            IMarketWrapper(_marketWrapper).auctionIdMatchesToken(\\n                _auctionId,\\n                _nftContract,\\n                _tokenId\\n            ),\\n            \\\"PartyBid::initialize: auctionId doesn't match token\\\"\\n        );\\n        // initialize & validate shared Party variables\\n        __Party_init(_nftContract, _tokenId, _split, _tokenGate, _name, _symbol);\\n        // set PartyBid-specific state variables\\n        marketWrapper = IMarketWrapper(_marketWrapper);\\n        auctionId = _auctionId;\\n    }\\n\\n    // ======== External: Contribute =========\\n\\n    /**\\n     * @notice Contribute to the Party's treasury\\n     * while the Party is still active\\n     * @dev Emits a Contributed event upon success; callable by anyone\\n     */\\n    function contribute() external payable nonReentrant {\\n        _contribute();\\n    }\\n\\n    // ======== External: Bid =========\\n\\n    /**\\n     * @notice Submit a bid to the Market\\n     * @dev Reverts if insufficient funds to place the bid and pay PartyDAO fees,\\n     * or if any external auction checks fail (including if PartyBid is current high bidder)\\n     * Emits a Bid event upon success.\\n     * Callable by any contributor\\n     */\\n    function bid() external nonReentrant {\\n        require(\\n            partyStatus == PartyStatus.ACTIVE,\\n            \\\"PartyBid::bid: auction not active\\\"\\n        );\\n        require(\\n            totalContributed[msg.sender] > 0,\\n            \\\"PartyBid::bid: only contributors can bid\\\"\\n        );\\n        require(\\n            address(this) !=\\n                marketWrapper.getCurrentHighestBidder(\\n                    auctionId\\n                ),\\n            \\\"PartyBid::bid: already highest bidder\\\"\\n        );\\n        require(\\n            !marketWrapper.isFinalized(auctionId),\\n            \\\"PartyBid::bid: auction already finalized\\\"\\n        );\\n        // get the minimum next bid for the auction\\n        uint256 _bid = marketWrapper.getMinimumBid(auctionId);\\n        // ensure there is enough ETH to place the bid including PartyDAO fee\\n        require(\\n            _bid <= getMaximumBid(),\\n            \\\"PartyBid::bid: insufficient funds to bid\\\"\\n        );\\n        // submit bid to Auction contract using delegatecall\\n        (bool success, bytes memory returnData) =\\n            address(marketWrapper).delegatecall(\\n                abi.encodeWithSignature(\\\"bid(uint256,uint256)\\\", auctionId, _bid)\\n            );\\n        require(\\n            success,\\n            string(\\n                abi.encodePacked(\\n                    \\\"PartyBid::bid: place bid failed: \\\",\\n                    returnData\\n                )\\n            )\\n        );\\n        // update highest bid submitted & emit success event\\n        highestBid = _bid;\\n        emit Bid(_bid);\\n    }\\n\\n    // ======== External: Finalize =========\\n\\n    /**\\n     * @notice Finalize the state of the auction\\n     * @dev Emits a Finalized event upon success; callable by anyone\\n     */\\n    function finalize() external nonReentrant {\\n        require(\\n            partyStatus == PartyStatus.ACTIVE,\\n            \\\"PartyBid::finalize: auction not active\\\"\\n        );\\n        // finalize auction if it hasn't already been done\\n        if (!marketWrapper.isFinalized(auctionId)) {\\n            marketWrapper.finalize(auctionId);\\n        }\\n        // after the auction has been finalized,\\n        // if the NFT is owned by the PartyBid, then the PartyBid won the auction\\n        address _owner = _getOwner();\\n        partyStatus = _owner == address(this) ? PartyStatus.WON : PartyStatus.LOST;\\n        uint256 _ethFee;\\n        // if the auction was won,\\n        if (partyStatus == PartyStatus.WON) {\\n            // record totalSpent,\\n            // send ETH fees to PartyDAO,\\n            // fractionalize the Token\\n            // send Token fees to PartyDAO & split proceeds to split recipient\\n            _ethFee = _closeSuccessfulParty(highestBid);\\n        }\\n        // set the contract status & emit result\\n        emit Finalized(partyStatus, totalSpent, _ethFee, totalContributedToParty);\\n    }\\n\\n    // ======== Public: Utility Calculations =========\\n\\n    /**\\n     * @notice The maximum bid that can be submitted\\n     * while paying the ETH fee to PartyDAO\\n     * @return _maxBid the maximum bid\\n     */\\n    function getMaximumBid() public view returns (uint256 _maxBid) {\\n        _maxBid = getMaximumSpend();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface Structs {\\n    struct AddressAndAmount {\\n        address addr;\\n        uint256 amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Party.sol\": {\r\n      \"content\": \"/*\\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____________________________________________________________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\\\\\\\\\\\______\\n _\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\__________________________________________________________\\\\/\\\\\\\\\\\\////////\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\______/\\\\\\\\\\\\///\\\\\\\\\\\\____\\n  _\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\__________________________________/\\\\\\\\\\\\_________/\\\\\\\\\\\\__/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\______\\\\//\\\\\\\\\\\\__/\\\\\\\\\\\\/////////\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\///\\\\\\\\\\\\__\\n   _\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/___/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\___/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\\\//\\\\\\\\\\\\/\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\__/\\\\\\\\\\\\______\\\\//\\\\\\\\\\\\_\\n    _\\\\/\\\\\\\\\\\\/////////____\\\\////////\\\\\\\\\\\\___\\\\/\\\\\\\\\\\\/////\\\\\\\\\\\\_\\\\////\\\\\\\\\\\\////_____\\\\//\\\\\\\\\\\\\\\\\\\\___\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\n     _\\\\/\\\\\\\\\\\\_______________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\___\\\\///_____\\\\/\\\\\\\\\\\\__________\\\\//\\\\\\\\\\\\____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\\\//\\\\\\\\\\\\______/\\\\\\\\\\\\__\\n      _\\\\/\\\\\\\\\\\\______________/\\\\\\\\\\\\/////\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\____________\\\\/\\\\\\\\\\\\_/\\\\\\\\___/\\\\\\\\_/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______/\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\__\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\____\\n       _\\\\/\\\\\\\\\\\\_____________\\\\//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/\\\\\\\\_\\\\/\\\\\\\\\\\\____________\\\\//\\\\\\\\\\\\\\\\\\\\___\\\\//\\\\\\\\\\\\\\\\/______\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/___\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\____\\\\///\\\\\\\\\\\\\\\\\\\\/_____\\n        _\\\\///_______________\\\\////////\\\\//__\\\\///______________\\\\/////_____\\\\////________\\\\////////////_____\\\\///________\\\\///_______\\\\/////_______\\n\\nAnna Carroll for PartyDAO\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n// ============ External Imports: Inherited Contracts ============\\n// NOTE: we inherit from OpenZeppelin upgradeable contracts\\n// because of the proxy structure used for cheaper deploys\\n// (the proxies are NOT actually upgradeable)\\nimport {\\nReentrancyGuardUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {\\nERC721HolderUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\n// ============ External Imports: External Contracts & Contract Interfaces ============\\nimport {\\nIERC721VaultFactory\\n} from \\\"./external/interfaces/IERC721VaultFactory.sol\\\";\\nimport {ITokenVault} from \\\"./external/interfaces/ITokenVault.sol\\\";\\nimport {IWETH} from \\\"./external/interfaces/IWETH.sol\\\";\\nimport {\\nIERC721Metadata\\n} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {\\nIERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n// ============ Internal Imports ============\\nimport {Structs} from \\\"./Structs.sol\\\";\\n\\ncontract Party is ReentrancyGuardUpgradeable, ERC721HolderUpgradeable {\\n    // ============ Enums ============\\n\\n    // State Transitions:\\n    //   (1) ACTIVE on deploy\\n    //   (2) WON if the Party has won the token\\n    //   (2) LOST if the Party is over & did not win the token\\n    enum PartyStatus {ACTIVE, WON, LOST}\\n\\n    // ============ Structs ============\\n\\n    struct Contribution {\\n        uint256 amount;\\n        uint256 previousTotalContributedToParty;\\n    }\\n\\n    // ============ Internal Constants ============\\n\\n    // tokens are minted at a rate of 1 ETH : 1000 tokens\\n    uint16 internal constant TOKEN_SCALE = 1000;\\n    // PartyDAO receives an ETH fee equal to 2.5% of the amount spent\\n    uint16 internal constant ETH_FEE_BASIS_POINTS = 250;\\n    // PartyDAO receives a token fee equal to 2.5% of the total token supply\\n    uint16 internal constant TOKEN_FEE_BASIS_POINTS = 250;\\n    // token is relisted on Fractional with an\\n    // initial reserve price equal to 2x the price of the token\\n    uint8 internal constant RESALE_MULTIPLIER = 2;\\n\\n    // ============ Immutables ============\\n\\n    address public immutable partyFactory;\\n    address public immutable partyDAOMultisig;\\n    IERC721VaultFactory public immutable tokenVaultFactory;\\n    IWETH public immutable weth;\\n\\n    // ============ Public Not-Mutated Storage ============\\n\\n    // NFT contract\\n    IERC721Metadata public nftContract;\\n    // ID of token within NFT contract\\n    uint256 public tokenId;\\n    // Fractionalized NFT vault responsible for post-purchase experience\\n    ITokenVault public tokenVault;\\n    // the address that will receive a portion of the tokens\\n    // if the Party successfully buys the token\\n    address public splitRecipient;\\n    // percent of the total token supply\\n    // taken by the splitRecipient\\n    uint256 public splitBasisPoints;\\n    // address of token that users need to hold to contribute\\n    // address(0) if party is not token gated\\n    IERC20 public gatedToken;\\n    // amount of token that users need to hold to contribute\\n    // 0 if party is not token gated\\n    uint256 public gatedTokenAmount;\\n    // ERC-20 name and symbol for fractional tokens\\n    string public name;\\n    string public symbol;\\n\\n    // ============ Public Mutable Storage ============\\n\\n    // state of the contract\\n    PartyStatus public partyStatus;\\n    // total ETH deposited by all contributors\\n    uint256 public totalContributedToParty;\\n    // the total spent buying the token;\\n    // 0 if the NFT is not won; price of token + 2.5% PartyDAO fee if NFT is won\\n    uint256 public totalSpent;\\n    // contributor => array of Contributions\\n    mapping(address => Contribution[]) public contributions;\\n    // contributor => total amount contributed\\n    mapping(address => uint256) public totalContributed;\\n    // contributor => true if contribution has been claimed\\n    mapping(address => bool) public claimed;\\n\\n    // ============ Events ============\\n\\n    event Contributed(\\n        address indexed contributor,\\n        uint256 amount,\\n        uint256 previousTotalContributedToParty,\\n        uint256 totalFromContributor\\n    );\\n\\n    event Claimed(\\n        address indexed contributor,\\n        uint256 totalContributed,\\n        uint256 excessContribution,\\n        uint256 tokenAmount\\n    );\\n\\n    // ======== Modifiers =========\\n\\n    modifier onlyPartyDAO() {\\n        require(\\n            msg.sender == partyDAOMultisig,\\n            \\\"Party:: only PartyDAO multisig\\\"\\n        );\\n        _;\\n    }\\n\\n    // ======== Constructor =========\\n\\n    constructor(\\n        address _partyDAOMultisig,\\n        address _tokenVaultFactory,\\n        address _weth\\n    ) {\\n        partyFactory = msg.sender;\\n        partyDAOMultisig = _partyDAOMultisig;\\n        tokenVaultFactory = IERC721VaultFactory(_tokenVaultFactory);\\n        weth = IWETH(_weth);\\n    }\\n\\n    // ======== Internal: Initialize =========\\n\\n    function __Party_init(\\n        address _nftContract,\\n        uint256 _tokenId,\\n        Structs.AddressAndAmount calldata _split,\\n        Structs.AddressAndAmount calldata _tokenGate,\\n        string memory _name,\\n        string memory _symbol\\n    ) internal {\\n        require(msg.sender == partyFactory, \\\"Party::__Party_init: only factory can init\\\");\\n        // validate token exists (must set nftContract & tokenId before _getOwner)\\n        nftContract = IERC721Metadata(_nftContract);\\n        tokenId = _tokenId;\\n        require(_getOwner() != address(0), \\\"Party::__Party_init: NFT getOwner failed\\\");\\n        // if split is non-zero,\\n        if (_split.addr != address(0) && _split.amount != 0) {\\n            // validate that party split won't retain the total token supply\\n            uint256 _remainingBasisPoints = 10000 - TOKEN_FEE_BASIS_POINTS;\\n            require(_split.amount < _remainingBasisPoints, \\\"Party::__Party_init: basis points can't take 100%\\\");\\n            splitBasisPoints = _split.amount;\\n            splitRecipient = _split.addr;\\n        }\\n        // if token gating is non-zero\\n        if (_tokenGate.addr != address(0) && _tokenGate.amount != 0) {\\n            // call totalSupply to verify that address is ERC-20 token contract\\n            IERC20(_tokenGate.addr).totalSupply();\\n            gatedToken = IERC20(_tokenGate.addr);\\n            gatedTokenAmount = _tokenGate.amount;\\n        }\\n        // initialize ReentrancyGuard and ERC721Holder\\n        __ReentrancyGuard_init();\\n        __ERC721Holder_init();\\n        // set storage variables\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    // ======== Internal: Contribute =========\\n\\n    /**\\n     * @notice Contribute to the Party's treasury\\n     * while the Party is still active\\n     * @dev Emits a Contributed event upon success; callable by anyone\\n     */\\n    function _contribute() internal {\\n        require(\\n            partyStatus == PartyStatus.ACTIVE,\\n            \\\"Party::contribute: party not active\\\"\\n        );\\n        address _contributor = msg.sender;\\n        uint256 _amount = msg.value;\\n        // if token gated, require that contributor has balance of gated tokens\\n        if (address(gatedToken) != address(0)) {\\n            require(gatedToken.balanceOf(_contributor) >= gatedTokenAmount, \\\"Party::contribute: must hold tokens to contribute\\\");\\n        }\\n        require(_amount > 0, \\\"Party::contribute: must contribute more than 0\\\");\\n        // get the current contract balance\\n        uint256 _previousTotalContributedToParty = totalContributedToParty;\\n        // add contribution to contributor's array of contributions\\n        Contribution memory _contribution =\\n            Contribution({\\n                amount: _amount,\\n                previousTotalContributedToParty: _previousTotalContributedToParty\\n            });\\n        contributions[_contributor].push(_contribution);\\n        // add to contributor's total contribution\\n        totalContributed[_contributor] = totalContributed[_contributor] + _amount;\\n        // add to party's total contribution & emit event\\n        totalContributedToParty = _previousTotalContributedToParty + _amount;\\n        emit Contributed(\\n            _contributor,\\n            _amount,\\n            _previousTotalContributedToParty,\\n            totalContributed[_contributor]\\n        );\\n    }\\n\\n    // ======== External: Claim =========\\n\\n    /**\\n     * @notice Claim the tokens and excess ETH owed\\n     * to a single contributor after the party has ended\\n     * @dev Emits a Claimed event upon success\\n     * callable by anyone (doesn't have to be the contributor)\\n     * @param _contributor the address of the contributor\\n     */\\n    function claim(address _contributor) external nonReentrant {\\n        // ensure party has finalized\\n        require(\\n            partyStatus != PartyStatus.ACTIVE,\\n            \\\"Party::claim: party not finalized\\\"\\n        );\\n        // ensure contributor submitted some ETH\\n        require(\\n            totalContributed[_contributor] != 0,\\n            \\\"Party::claim: not a contributor\\\"\\n        );\\n        // ensure the contributor hasn't already claimed\\n        require(\\n            !claimed[_contributor],\\n            \\\"Party::claim: contribution already claimed\\\"\\n        );\\n        // mark the contribution as claimed\\n        claimed[_contributor] = true;\\n        // calculate the amount of fractional NFT tokens owed to the user\\n        // based on how much ETH they contributed towards the party,\\n        // and the amount of excess ETH owed to the user\\n        (uint256 _tokenAmount, uint256 _ethAmount) =\\n        getClaimAmounts(_contributor);\\n        // transfer tokens to contributor for their portion of ETH used\\n        _transferTokens(_contributor, _tokenAmount);\\n        // if there is excess ETH, send it back to the contributor\\n        _transferETHOrWETH(_contributor, _ethAmount);\\n        emit Claimed(\\n            _contributor,\\n            totalContributed[_contributor],\\n            _ethAmount,\\n            _tokenAmount\\n        );\\n    }\\n\\n    // ======== External: Emergency Escape Hatches (PartyDAO Multisig Only) =========\\n\\n    /**\\n     * @notice Escape hatch: in case of emergency,\\n     * PartyDAO can use emergencyWithdrawEth to withdraw\\n     * ETH stuck in the contract\\n     */\\n    function emergencyWithdrawEth(uint256 _value)\\n        external\\n        onlyPartyDAO\\n    {\\n        _transferETHOrWETH(partyDAOMultisig, _value);\\n    }\\n\\n    /**\\n     * @notice Escape hatch: in case of emergency,\\n     * PartyDAO can use emergencyCall to call an external contract\\n     * (e.g. to withdraw a stuck NFT or stuck ERC-20s)\\n     */\\n    function emergencyCall(address _contract, bytes memory _calldata)\\n        external\\n        onlyPartyDAO\\n        returns (bool _success, bytes memory _returnData)\\n    {\\n        (_success, _returnData) = _contract.call(_calldata);\\n        require(_success, string(_returnData));\\n    }\\n\\n    /**\\n     * @notice Escape hatch: in case of emergency,\\n     * PartyDAO can force the Party to finalize with status LOST\\n     * (e.g. if finalize is not callable)\\n     */\\n    function emergencyForceLost()\\n        external\\n        onlyPartyDAO\\n    {\\n        // set partyStatus to LOST\\n        partyStatus = PartyStatus.LOST;\\n    }\\n\\n    // ======== Public: Utility Calculations =========\\n\\n    /**\\n     * @notice Convert ETH value to equivalent token amount\\n     */\\n    function valueToTokens(uint256 _value)\\n        public\\n        pure\\n        returns (uint256 _tokens)\\n    {\\n        _tokens = _value * TOKEN_SCALE;\\n    }\\n\\n    /**\\n     * @notice The maximum amount that can be spent by the Party\\n     * while paying the ETH fee to PartyDAO\\n     * @return _maxSpend the maximum spend\\n     */\\n    function getMaximumSpend() public view returns (uint256 _maxSpend) {\\n        _maxSpend = (totalContributedToParty * 10000) / (10000 + ETH_FEE_BASIS_POINTS);\\n    }\\n\\n    /**\\n     * @notice Calculate the amount of fractional NFT tokens owed to the contributor\\n     * based on how much ETH they contributed towards buying the token,\\n     * and the amount of excess ETH owed to the contributor\\n     * based on how much ETH they contributed *not* used towards buying the token\\n     * @param _contributor the address of the contributor\\n     * @return _tokenAmount the amount of fractional NFT tokens owed to the contributor\\n     * @return _ethAmount the amount of excess ETH owed to the contributor\\n     */\\n    function getClaimAmounts(address _contributor)\\n        public\\n        view\\n        returns (uint256 _tokenAmount, uint256 _ethAmount)\\n    {\\n        require(partyStatus != PartyStatus.ACTIVE, \\\"Party::getClaimAmounts: party still active; amounts undetermined\\\");\\n        uint256 _totalContributed = totalContributed[_contributor];\\n        if (partyStatus == PartyStatus.WON) {\\n            // calculate the amount of this contributor's ETH\\n            // that was used to buy the token\\n            uint256 _totalEthUsed = totalEthUsed(_contributor);\\n            if (_totalEthUsed > 0) {\\n                _tokenAmount = valueToTokens(_totalEthUsed);\\n            }\\n            // the rest of the contributor's ETH should be returned\\n            _ethAmount = _totalContributed - _totalEthUsed;\\n        } else {\\n            // if the token wasn't bought, no ETH was spent;\\n            // all of the contributor's ETH should be returned\\n            _ethAmount = _totalContributed;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the total amount of a contributor's funds\\n     * that were used towards the buying the token\\n     * @dev always returns 0 until the party has been finalized\\n     * @param _contributor the address of the contributor\\n     * @return _total the sum of the contributor's funds that were\\n     * used towards buying the token\\n     */\\n    function totalEthUsed(address _contributor)\\n        public\\n        view\\n        returns (uint256 _total)\\n    {\\n        require(partyStatus != PartyStatus.ACTIVE, \\\"Party::totalEthUsed: party still active; amounts undetermined\\\");\\n        // load total amount spent once from storage\\n        uint256 _totalSpent = totalSpent;\\n        // get all of the contributor's contributions\\n        Contribution[] memory _contributions = contributions[_contributor];\\n        for (uint256 i = 0; i < _contributions.length; i++) {\\n            // calculate how much was used from this individual contribution\\n            uint256 _amount = _ethUsed(_totalSpent, _contributions[i]);\\n            // if we reach a contribution that was not used,\\n            // no subsequent contributions will have been used either,\\n            // so we can stop calculating to save some gas\\n            if (_amount == 0) break;\\n            _total = _total + _amount;\\n        }\\n    }\\n\\n    // ============ Internal ============\\n\\n    function _closeSuccessfulParty(uint256 _nftCost) internal returns (uint256 _ethFee) {\\n        // calculate PartyDAO fee & record total spent\\n        _ethFee = _getEthFee(_nftCost);\\n        totalSpent = _nftCost + _ethFee;\\n        // transfer ETH fee to PartyDAO\\n        _transferETHOrWETH(partyDAOMultisig, _ethFee);\\n        // deploy fractionalized NFT vault\\n        // and mint fractional ERC-20 tokens\\n        _fractionalizeNFT(_nftCost);\\n    }\\n\\n    /**\\n     * @notice Calculate ETH fee for PartyDAO\\n     * NOTE: Remove this fee causes a critical vulnerability\\n     * allowing anyone to exploit a Party via price manipulation.\\n     * See Security Review in README for more info.\\n     * @return _fee the portion of _amount represented by scaling to ETH_FEE_BASIS_POINTS\\n     */\\n    function _getEthFee(uint256 _amount) internal pure returns (uint256 _fee) {\\n        _fee = (_amount * ETH_FEE_BASIS_POINTS) / 10000;\\n    }\\n\\n    /**\\n     * @notice Calculate token amount for specified token recipient\\n     * @return _totalSupply the total token supply\\n     * @return _partyDAOAmount the amount of tokens for partyDAO fee,\\n     * which is equivalent to TOKEN_FEE_BASIS_POINTS of total supply\\n     * @return _splitRecipientAmount the amount of tokens for the token recipient,\\n     * which is equivalent to splitBasisPoints of total supply\\n     */\\n    function _getTokenInflationAmounts(uint256 _amountSpent)\\n        internal\\n        view\\n        returns (uint256 _totalSupply, uint256 _partyDAOAmount, uint256 _splitRecipientAmount)\\n    {\\n        // the token supply will be inflated to provide a portion of the\\n        // total supply for PartyDAO, and a portion for the splitRecipient\\n        uint256 inflationBasisPoints = TOKEN_FEE_BASIS_POINTS + splitBasisPoints;\\n        _totalSupply = valueToTokens((_amountSpent * 10000) / (10000 - inflationBasisPoints));\\n        // PartyDAO receives TOKEN_FEE_BASIS_POINTS of the total supply\\n        _partyDAOAmount = (_totalSupply * TOKEN_FEE_BASIS_POINTS) / 10000;\\n        // splitRecipient receives splitBasisPoints of the total supply\\n        _splitRecipientAmount = (_totalSupply * splitBasisPoints) / 10000;\\n    }\\n\\n    /**\\n    * @notice Query the NFT contract to get the token owner\\n    * @dev nftContract must implement the ERC-721 token standard exactly:\\n    * function ownerOf(uint256 _tokenId) external view returns (address);\\n    * See https://eips.ethereum.org/EIPS/eip-721\\n    * @dev Returns address(0) if NFT token or NFT contract\\n    * no longer exists (token burned or contract self-destructed)\\n    * @return _owner the owner of the NFT\\n    */\\n    function _getOwner() internal view returns (address _owner) {\\n        (bool _success, bytes memory _returnData) =\\n            address(nftContract).staticcall(\\n                abi.encodeWithSignature(\\n                    \\\"ownerOf(uint256)\\\",\\n                    tokenId\\n                )\\n        );\\n        if (_success && _returnData.length > 0) {\\n            _owner = abi.decode(_returnData, (address));\\n        }\\n    }\\n\\n    /**\\n     * @notice Upon winning the token, transfer the NFT\\n     * to fractional.art vault & mint fractional ERC-20 tokens\\n     */\\n    function _fractionalizeNFT(uint256 _amountSpent) internal {\\n        // approve fractionalized NFT Factory to withdraw NFT\\n        nftContract.approve(address(tokenVaultFactory), tokenId);\\n        // Party \\\"votes\\\" for a reserve price on Fractional\\n        // equal to 2x the price of the token\\n        uint256 _listPrice = RESALE_MULTIPLIER * _amountSpent;\\n        // users receive tokens at a rate of 1:TOKEN_SCALE for each ETH they contributed that was ultimately spent\\n        // partyDAO receives a percentage of the total token supply equivalent to TOKEN_FEE_BASIS_POINTS\\n        // splitRecipient receives a percentage of the total token supply equivalent to splitBasisPoints\\n        (uint256 _tokenSupply, uint256 _partyDAOAmount, uint256 _splitRecipientAmount) = _getTokenInflationAmounts(totalSpent);\\n        // deploy fractionalized NFT vault\\n        uint256 vaultNumber =\\n            tokenVaultFactory.mint(\\n                name,\\n                symbol,\\n                address(nftContract),\\n                tokenId,\\n                _tokenSupply,\\n                _listPrice,\\n                0\\n            );\\n        // store token vault address to storage\\n        tokenVault = ITokenVault(tokenVaultFactory.vaults(vaultNumber));\\n        // transfer curator to null address (burn the curator role)\\n        tokenVault.updateCurator(address(0));\\n        // transfer tokens to PartyDAO multisig\\n        _transferTokens(partyDAOMultisig, _partyDAOAmount);\\n        // transfer tokens to token recipient\\n        if (splitRecipient != address(0)) {\\n            _transferTokens(splitRecipient, _splitRecipientAmount);\\n        }\\n    }\\n\\n    // ============ Internal: Claim ============\\n\\n    /**\\n     * @notice Calculate the amount of a single Contribution\\n     * that was used towards buying the token\\n     * @param _contribution the Contribution struct\\n     * @return the amount of funds from this contribution\\n     * that were used towards buying the token\\n     */\\n    function _ethUsed(uint256 _totalSpent, Contribution memory _contribution)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (\\n            _contribution.previousTotalContributedToParty +\\n            _contribution.amount <=\\n            _totalSpent\\n        ) {\\n            // contribution was fully used\\n            return _contribution.amount;\\n        } else if (\\n            _contribution.previousTotalContributedToParty < _totalSpent\\n        ) {\\n            // contribution was partially used\\n            return _totalSpent - _contribution.previousTotalContributedToParty;\\n        }\\n        // contribution was not used\\n        return 0;\\n    }\\n\\n    // ============ Internal: TransferTokens ============\\n\\n    /**\\n    * @notice Transfer tokens to a recipient\\n    * @param _to recipient of tokens\\n    * @param _value amount of tokens\\n    */\\n    function _transferTokens(address _to, uint256 _value) internal {\\n        // skip if attempting to send 0 tokens\\n        if (_value == 0) {\\n            return;\\n        }\\n        // guard against rounding errors;\\n        // if token amount to send is greater than contract balance,\\n        // send full contract balance\\n        uint256 _partyBalance = tokenVault.balanceOf(address(this));\\n        if (_value > _partyBalance) {\\n            _value = _partyBalance;\\n        }\\n        tokenVault.transfer(_to, _value);\\n    }\\n\\n    // ============ Internal: TransferEthOrWeth ============\\n\\n    /**\\n     * @notice Attempt to transfer ETH to a recipient;\\n     * if transferring ETH fails, transfer WETH insteads\\n     * @param _to recipient of ETH or WETH\\n     * @param _value amount of ETH or WETH\\n     */\\n    function _transferETHOrWETH(address _to, uint256 _value) internal {\\n        // skip if attempting to send 0 ETH\\n        if (_value == 0) {\\n            return;\\n        }\\n        // guard against rounding errors;\\n        // if ETH amount to send is greater than contract balance,\\n        // send full contract balance\\n        if (_value > address(this).balance) {\\n            _value = address(this).balance;\\n        }\\n        // Try to transfer ETH to the given recipient.\\n        if (!_attemptETHTransfer(_to, _value)) {\\n            // If the transfer fails, wrap and send as WETH\\n            weth.deposit{value: _value}();\\n            weth.transfer(_to, _value);\\n            // At this point, the recipient can unwrap WETH.\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempt to transfer ETH to a recipient\\n     * @dev Sending ETH is not guaranteed to succeed\\n     * this method will return false if it fails.\\n     * We will limit the gas used in transfers, and handle failure cases.\\n     * @param _to recipient of ETH\\n     * @param _value amount of ETH\\n     */\\n    function _attemptETHTransfer(address _to, uint256 _value)\\n        internal\\n        returns (bool)\\n    {\\n        // Here increase the gas limit a reasonable amount above the default, and try\\n        // to send ETH to the recipient.\\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\\n        (bool success, ) = _to.call{value: _value, gas: 30000}(\\\"\\\");\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/market-wrapper/IMarketWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n/**\\n * @title IMarketWrapper\\n * @author Anna Carroll\\n * @notice IMarketWrapper provides a common interface for\\n * interacting with NFT auction markets.\\n * Contracts can abstract their interactions with\\n * different NFT markets using IMarketWrapper.\\n * NFT markets can become compatible with any contract\\n * using IMarketWrapper by deploying a MarketWrapper contract\\n * that implements this interface using the logic of their Market.\\n *\\n * WARNING: MarketWrapper contracts should NEVER write to storage!\\n * When implementing a MarketWrapper, exercise caution; a poorly implemented\\n * MarketWrapper contract could permanently lose access to the NFT or user funds.\\n */\\ninterface IMarketWrapper {\\n    /**\\n     * @notice Given the auctionId, nftContract, and tokenId, check that:\\n     * 1. the auction ID matches the token\\n     * referred to by tokenId + nftContract\\n     * 2. the auctionId refers to an *ACTIVE* auction\\n     * (e.g. an auction that will accept bids)\\n     * within this market contract\\n     * 3. any additional validation to ensure that\\n     * a PartyBid can bid on this auction\\n     * (ex: if the market allows arbitrary bidding currencies,\\n     * check that the auction currency is ETH)\\n     * Note: This function probably should have been named \\\"isValidAuction\\\"\\n     * @dev Called in PartyBid.sol in `initialize` at line 174\\n     * @return TRUE if the auction is valid\\n     */\\n    function auctionIdMatchesToken(\\n        uint256 auctionId,\\n        address nftContract,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Calculate the minimum next bid for this auction.\\n     * PartyBid contracts always submit the minimum possible\\n     * bid that will be accepted by the Market contract.\\n     * usually, this is either the reserve price (if there are no bids)\\n     * or a certain percentage increase above the current highest bid\\n     * @dev Called in PartyBid.sol in `bid` at line 251\\n     * @return minimum bid amount\\n     */\\n    function getMinimumBid(uint256 auctionId) external view returns (uint256);\\n\\n    /**\\n     * @notice Query the current highest bidder for this auction\\n     * It is assumed that there is always 1 winning highest bidder for an auction\\n     * This is used to ensure that PartyBid cannot outbid itself if it is already winning\\n     * @dev Called in PartyBid.sol in `bid` at line 241\\n     * @return highest bidder\\n     */\\n    function getCurrentHighestBidder(uint256 auctionId)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @notice Submit bid to Market contract\\n     * @dev Called in PartyBid.sol in `bid` at line 259\\n     */\\n    function bid(uint256 auctionId, uint256 bidAmount) external;\\n\\n    /**\\n     * @notice Determine whether the auction has been finalized\\n     * Used to check if it is still possible to bid\\n     * And to determine whether the PartyBid should finalize the auction\\n     * @dev Called in PartyBid.sol in `bid` at line 247\\n     * @dev and in `finalize` at line 288\\n     * @return TRUE if the auction has been finalized\\n     */\\n    function isFinalized(uint256 auctionId) external view returns (bool);\\n\\n    /**\\n     * @notice Finalize the results of the auction\\n     * on the Market contract\\n     * It is assumed  that this operation is performed once for each auction,\\n     * that after it is done the auction is over and the NFT has been\\n     * transferred to the auction winner.\\n     * @dev Called in PartyBid.sol in `finalize` at line 289\\n     */\\n    function finalize(uint256 auctionId) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers.\\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal initializer {\\n        __ERC721Holder_init_unchained();\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal initializer {\\n    }\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IERC721VaultFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface IERC721VaultFactory {\\n    /// @notice the mapping of vault number to vault address\\n    function vaults(uint256) external returns (address);\\n\\n    /// @notice the function to mint a new vault\\n    /// @param _name the desired name of the vault\\n    /// @param _symbol the desired sumbol of the vault\\n    /// @param _token the ERC721 token address fo the NFT\\n    /// @param _id the uint256 ID of the token\\n    /// @param _listPrice the initial price of the NFT\\n    /// @return the ID of the vault\\n    function mint(string memory _name, string memory _symbol, address _token, uint256 _id, uint256 _supply, uint256 _listPrice, uint256 _fee) external returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/ITokenVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface ITokenVault {\\n    /// @notice allow curator to update the curator address\\n    /// @param _curator the new curator\\n    function updateCurator(address _curator) external;\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/external/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partyDAOMultisig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenVaultFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"partyBidProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketWrapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"splitRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"splitBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gatedToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gatedTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"PartyBidDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deployedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyDAOMultisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketWrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_auctionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.AddressAndAmount\",\"name\":\"_split\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.AddressAndAmount\",\"name\":\"_tokenGate\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"startParty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"partyBidProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenVaultFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PartyBidFactory","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000f7f52dd34bc21eda08c0b804c7c1dbc48375820f00000000000000000000000085aa7f78bdb2de8f3e0c0010d99ad5853ffcfc63000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}