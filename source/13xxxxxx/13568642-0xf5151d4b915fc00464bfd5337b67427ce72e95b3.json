{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LibRegion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary LibRegion {\\r\\n\\t\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Config\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    \\r\\n    //Costing Config\\r\\n    uint constant regionCostBase = 100;\\r\\n    uint constant initialGrowthOffset = 5;\\r\\n    uint constant regionGrowthExponent = 2;\\r\\n    uint constant fakePercentMultiplier = 10000;\\r\\n    uint constant fakePercent = 2000; //fakePercentMultiplier * 20%\\r\\n    //With these numbers, the result should be roughly:\\r\\n    //region 1 - 500 fame\\r\\n    //region 2 - 720 fame\\r\\n    //region 3 - 980 fame\\r\\n    //region 4 - 1280 fame\\r\\n    //region 5 - 1620 fame\\r\\n    //region 6 - 2000 fame\\r\\n    //region 7 - 2420 fame\\r\\n    //region 8 - 2880 fame\\r\\n    //region 9 - 3380 fame\\r\\n    //and so on, up to 216,320 fame for region 100\\r\\n\\r\\n    //Value Constraints\\r\\n    uint8 constant minConnections = 1;\\r\\n    uint8 constant maxConnections = 8;\\r\\n\\r\\n    //Misc Config\\r\\n    uint8 constant connectionChancePercent = 25;\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Enums\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Structs\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    struct regionHeader {\\r\\n        address owner;\\r\\n        bytes32 bytesName;\\r\\n        string description;\\r\\n        string linkURL;\\r\\n        string regionMetaURL;\\r\\n        uint seed;\\r\\n        uint balance;\\r\\n        uint32 creationTime;\\r\\n    }\\r\\n\\r\\n    struct region {\\r\\n        regionHeader header;\\r\\n        uint[] connections;\\r\\n        mapping(uint=>uint) config;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Constructors/Initializers\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    function initialize(region storage r, address owner, uint randomSeed) public {\\r\\n        r.header = regionHeader(\\r\\n            owner,                      //Owner\\r\\n            bytes32(0),                 //Name (in Bytes32 format)\\r\\n            \\\"\\\",                         //Description\\r\\n            \\\"\\\",                         //Link URL\\r\\n            \\\"\\\",                         //RegionMetaURL\\r\\n            random(randomSeed,1),       //Random Seed\\r\\n            0,                          //Starting Balance\\r\\n            uint32(block.timestamp)     //Creation Time\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Utilities\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    function random(uint seeda, uint seedb) public pure returns (uint) {\\r\\n        return uint(keccak256(abi.encodePacked(seeda,seedb)));  \\r\\n    }\\r\\n\\r\\n\\tfunction stringToBytes32(string memory source) public pure returns (bytes32 result) {\\r\\n        bytes memory tempEmptyStringTest = bytes(source);\\r\\n        if (tempEmptyStringTest.length == 0) {\\r\\n            return 0x0;\\r\\n        }\\r\\n\\r\\n        assembly {\\r\\n            result := mload(add(source, 32))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function bytes32ToString(bytes32 source) public pure returns (string memory result) {\\r\\n        uint8 len = 32;\\r\\n        uint8 i = 0;\\r\\n        for(i=0;i<32;i++){\\r\\n            if(source[i]==0){\\r\\n                len = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        bytes memory bytesArray = new bytes(len);\\r\\n        for (i=0;i<len;i++) {\\r\\n            bytesArray[i] = source[i];\\r\\n        }\\r\\n        result = string(bytesArray);\\r\\n    }\\r\\n\\r\\n    function getMinConnectionCount() public pure returns (uint8) {\\r\\n        return minConnections;\\r\\n    }\\r\\n    \\r\\n    function getMaxConnectionCount() public pure returns (uint8) {\\r\\n        return maxConnections;\\r\\n    }\\r\\n\\r\\n    function getConnectionChancePercent() public pure returns (uint8) {\\r\\n        return connectionChancePercent;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Derivation / Calaculation Pure Functions\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    function getRandomProperty(region storage r, string memory propertyKey) public view returns (uint) {\\r\\n        uint idx = uint(keccak256(abi.encodePacked(propertyKey)));\\r\\n        return random(r.header.seed,idx);\\r\\n    }\\r\\n\\r\\n    function getName(region storage r) public view returns(string memory name) {\\r\\n        name = bytes32ToString(r.header.bytesName);\\r\\n    }\\r\\n\\r\\n    function needsAnotherConnection(region storage r) public view returns(bool) {\\r\\n        if(r.connections.length<minConnections){\\r\\n            return true;\\r\\n        }else{\\r\\n            uint8 roll = uint8(random(r.header.seed,r.connections.length)%100);\\r\\n            return roll<connectionChancePercent;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Costing Getters\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    function getRegionCost(uint regionCounter) public pure returns(uint) {\\r\\n        return (((regionCounter+initialGrowthOffset)**regionGrowthExponent)*(regionCostBase*fakePercent))/fakePercentMultiplier;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Setters\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    function setName(region storage r, string memory name) public {\\r\\n        require(r.header.bytesName==bytes32(0));\\r\\n        r.header.bytesName = stringToBytes32(name);\\r\\n    }\\r\\n\\r\\n    function addConnection(region storage r, uint connectionID) public {\\r\\n        r.connections.push(connectionID);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Buying Things\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n    // Actions/Activities/Effects\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"source\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConnectionChancePercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxConnectionCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinConnectionCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"regionCounter\",\"type\":\"uint256\"}],\"name\":\"getRegionCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seeda\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seedb\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"LibRegion","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}