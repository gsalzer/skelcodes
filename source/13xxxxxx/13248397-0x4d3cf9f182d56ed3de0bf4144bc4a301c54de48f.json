{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-08-26\r\n*/\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ncontract RewardPoolDelegationStorage {\r\n    // The FILST token address\r\n    address public filstAddress;\r\n\r\n    // The eFIL token address\r\n    address public efilAddress;\r\n\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active implementation\r\n    */\r\n    address public implementation;\r\n\r\n    /**\r\n    * @notice Pending implementation\r\n    */\r\n    address public pendingImplementation;\r\n}\r\n\r\ninterface IRewardCalculator {\r\n    function calculate(uint filstAmount, uint fromBlockNumber) external view returns (uint);\r\n}\r\n\r\ninterface IRewardStrategy {\r\n    // returns allocated result\r\n    function allocate(address staking, uint rewardAmount) external view returns (uint stakingPart, address[] memory others, uint[] memory othersParts);\r\n}\r\n\r\ninterface IFilstManagement {\r\n    function getTotalMintedAmount() external view returns (uint);\r\n    function getMintedAmount(string calldata miner) external view returns (uint);\r\n}\r\n\r\ncontract RewardPoolStorage is RewardPoolDelegationStorage {\r\n    // The IFilstManagement\r\n    IFilstManagement public management;\r\n\r\n    // The IRewardStrategy\r\n    IRewardStrategy public strategy;\r\n\r\n    // The IRewardCalculator contract\r\n    IRewardCalculator public calculator;\r\n\r\n    // The address of FILST Staking contract\r\n    address public staking;\r\n\r\n    // The last accrued block number\r\n    uint public accrualBlockNumber;\r\n\r\n    // The accrued reward for each participant\r\n    mapping(address => uint) public accruedRewards;\r\n\r\n    struct Debt {\r\n        // accrued index of debts \r\n        uint accruedIndex;\r\n\r\n        // accrued debts\r\n        uint accruedAmount;\r\n\r\n        // The last time the miner repay debts\r\n        uint lastRepaymentBlock;\r\n    }\r\n\r\n    // The last accrued index of debts\r\n    uint public debtAccruedIndex;\r\n\r\n    // The accrued debts for each miner\r\n    // minerId -> Debt\r\n    mapping(string => Debt) public minerDebts;\r\n}\r\n\r\ncontract RewardPoolDelegator is RewardPoolDelegationStorage {\r\n    /**\r\n      * @notice Emitted when pendingImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingImplementation is accepted, which means implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor(address filstAddress_, address efilAddress_) public {\r\n        filstAddress = filstAddress_;\r\n        efilAddress = efilAddress_;\r\n\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) external {\r\n        require(msg.sender == admin, \"admin check\");\r\n\r\n        address oldPendingImplementation = pendingImplementation;\r\n        pendingImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    */\r\n    function _acceptImplementation() external {\r\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\r\n        require(msg.sender == pendingImplementation && pendingImplementation != address(0), \"pendingImplementation check\");\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = implementation;\r\n        address oldPendingImplementation = pendingImplementation;\r\n\r\n        implementation = pendingImplementation;\r\n        pendingImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) external {\r\n        require(msg.sender == admin, \"admin check\");\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      */\r\n    function _acceptAdmin() external {\r\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\r\n        require(msg.sender == pendingAdmin && pendingAdmin != address(0), \"pendingAdmin check\");\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () payable external {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n\r\n// Copied from Compound/ExponentialNoError\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author DeFil\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract ExponentialNoError {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return add_(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n\r\ninterface Distributor {\r\n    // The asset to be distributed\r\n    function asset() external view returns (address);\r\n\r\n    // Return the accrued amount of account based on stored data\r\n    function accruedStored(address account) external view returns (uint);\r\n\r\n    // Accrue and distribute for caller, but not actually transfer assets to the caller\r\n    // returns the new accrued amount\r\n    function accrue() external returns (uint);\r\n\r\n    // Claim asset, transfer the given amount assets to receiver\r\n    function claim(address receiver, uint amount) external returns (uint);\r\n}\r\n\r\n// Copied from compound/EIP20Interface\r\n/**\r\n * @title ERC 20 Token Standard Interface\r\n *  https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface EIP20Interface {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n      * @notice Get the total number of tokens in circulation\r\n      * @return The supply of tokens\r\n      */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return Whether or not the transfer succeeded\r\n      */\r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return Whether or not the transfer succeeded\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved (-1 means infinite)\r\n      * @return Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return The number of tokens allowed to be spent (-1 means infinite)\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n// Copied from compound/EIP20NonStandardInterface\r\n/**\r\n * @title EIP20NonStandardInterface\r\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\r\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ninterface EIP20NonStandardInterface {\r\n\r\n    /**\r\n     * @notice Get the total number of tokens in circulation\r\n     * @return The supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transfer(address dst, uint256 amount) external;\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external;\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved\r\n      * @return Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return The number of tokens allowed to be spent\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\ncontract Redistributor is Distributor, ExponentialNoError {\r\n    /**\r\n     * @notice The superior Distributor contract\r\n     */\r\n    Distributor public superior;\r\n\r\n    // The accrued amount of this address in superior Distributor\r\n    uint public superiorAccruedAmount;\r\n\r\n    // The initial accrual index\r\n    uint internal constant initialAccruedIndex = 1e36;\r\n\r\n    // The last accrued block number\r\n    uint public accrualBlockNumber;\r\n\r\n    // The last accrued index\r\n    uint public globalAccruedIndex;\r\n\r\n    // Total count of shares.\r\n    uint internal totalShares;\r\n\r\n    struct AccountState {\r\n        /// @notice The share of account\r\n        uint share;\r\n        // The last accrued index of account\r\n        uint accruedIndex;\r\n        /// @notice The accrued but not yet transferred to account\r\n        uint accruedAmount;\r\n    }\r\n\r\n    // The AccountState for each account\r\n    mapping(address => AccountState) internal accountStates;\r\n\r\n    /*** Events ***/\r\n    // Emitted when dfl is accrued\r\n    event Accrued(uint amount, uint globalAccruedIndex);\r\n\r\n    // Emitted when distribute to a account\r\n    event Distributed(address account, uint amount, uint accruedIndex);\r\n\r\n    // Emitted when account claims asset\r\n    event Claimed(address account, address receiver, uint amount);\r\n\r\n    // Emitted when account transfer asset\r\n    event Transferred(address from, address to, uint amount);\r\n\r\n    constructor(Distributor superior_) public {\r\n        // set superior\r\n        superior = superior_;\r\n        // init accrued index\r\n        globalAccruedIndex = initialAccruedIndex;\r\n    }\r\n\r\n    function asset() external view returns (address) {\r\n        return superior.asset();\r\n    }\r\n\r\n    // Return the accrued amount of account based on stored data\r\n    function accruedStored(address account) external view returns(uint) {\r\n        uint storedGlobalAccruedIndex;\r\n        if (totalShares == 0) {\r\n            storedGlobalAccruedIndex = globalAccruedIndex;\r\n        } else {\r\n            uint superiorAccruedStored = superior.accruedStored(address(this));\r\n            uint delta = sub_(superiorAccruedStored, superiorAccruedAmount);\r\n\r\n            Double memory ratio = fraction(delta, totalShares);\r\n            Double memory doubleGlobalAccruedIndex = add_(Double({mantissa: globalAccruedIndex}), ratio);\r\n            storedGlobalAccruedIndex = doubleGlobalAccruedIndex.mantissa;\r\n        }\r\n\r\n        (, uint instantAccountAccruedAmount) = accruedStoredInternal(account, storedGlobalAccruedIndex);\r\n        return instantAccountAccruedAmount;\r\n    }\r\n\r\n    // Return the accrued amount of account based on stored data\r\n    function accruedStoredInternal(address account, uint withGlobalAccruedIndex) internal view returns(uint, uint) {\r\n        AccountState memory state = accountStates[account];\r\n\r\n        Double memory doubleGlobalAccruedIndex = Double({mantissa: withGlobalAccruedIndex});\r\n        Double memory doubleAccountAccruedIndex = Double({mantissa: state.accruedIndex});\r\n        if (doubleAccountAccruedIndex.mantissa == 0 && doubleGlobalAccruedIndex.mantissa > 0) {\r\n            doubleAccountAccruedIndex.mantissa = initialAccruedIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(doubleGlobalAccruedIndex, doubleAccountAccruedIndex);\r\n        uint delta = mul_(state.share, deltaIndex);\r\n\r\n        return (delta, add_(state.accruedAmount, delta));\r\n    }\r\n\r\n    function accrueInternal() internal {\r\n        uint blockNumber = getBlockNumber();\r\n        if (accrualBlockNumber == blockNumber) {\r\n            return;\r\n        }\r\n\r\n        uint newSuperiorAccruedAmount = superior.accrue();\r\n        if (totalShares == 0) {\r\n            accrualBlockNumber = blockNumber;\r\n            return;\r\n        }\r\n\r\n        uint delta = sub_(newSuperiorAccruedAmount, superiorAccruedAmount);\r\n\r\n        Double memory ratio = fraction(delta, totalShares);\r\n        Double memory doubleAccruedIndex = add_(Double({mantissa: globalAccruedIndex}), ratio);\r\n\r\n        // update globalAccruedIndex\r\n        globalAccruedIndex = doubleAccruedIndex.mantissa;\r\n        superiorAccruedAmount = newSuperiorAccruedAmount;\r\n        accrualBlockNumber = blockNumber;\r\n\r\n        emit Accrued(delta, doubleAccruedIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice accrue and returns accrued stored of msg.sender\r\n     */\r\n    function accrue() external returns (uint) {\r\n        accrueInternal();\r\n\r\n        (, uint instantAccountAccruedAmount) = accruedStoredInternal(msg.sender, globalAccruedIndex);\r\n        return instantAccountAccruedAmount;\r\n    }\r\n\r\n    function distributeInternal(address account) internal {\r\n        (uint delta, uint instantAccruedAmount) = accruedStoredInternal(account, globalAccruedIndex);\r\n\r\n        AccountState storage state = accountStates[account];\r\n        state.accruedIndex = globalAccruedIndex;\r\n        state.accruedAmount = instantAccruedAmount;\r\n\r\n        // emit Distributed event\r\n        emit Distributed(account, delta, globalAccruedIndex);\r\n    }\r\n\r\n    function claim(address receiver, uint amount) external returns (uint) {\r\n        address account = msg.sender;\r\n\r\n        // keep fresh\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        AccountState storage state = accountStates[account];\r\n        require(amount <= state.accruedAmount, \"claim: insufficient value\");\r\n\r\n        // claim from superior\r\n        require(superior.claim(receiver, amount) == amount, \"claim: amount mismatch\");\r\n\r\n        // update storage\r\n        state.accruedAmount = sub_(state.accruedAmount, amount);\r\n        superiorAccruedAmount = sub_(superiorAccruedAmount, amount);\r\n\r\n        emit Claimed(account, receiver, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    function claimAll() external {\r\n        address account = msg.sender;\r\n\r\n        // accrue and distribute\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        AccountState storage state = accountStates[account];\r\n        uint amount = state.accruedAmount;\r\n\r\n        // claim from superior\r\n        require(superior.claim(account, amount) == amount, \"claim: amount mismatch\");\r\n\r\n        // update storage\r\n        state.accruedAmount = 0;\r\n        superiorAccruedAmount = sub_(superiorAccruedAmount, amount);\r\n\r\n        emit Claimed(account, account, amount);\r\n    }\r\n\r\n    function transfer(address to, uint amount) external {\r\n        address from = msg.sender;\r\n\r\n        // keep fresh\r\n        accrueInternal();\r\n        distributeInternal(from);\r\n\r\n        AccountState storage fromState = accountStates[from];\r\n        uint actualAmount = amount;\r\n        if (actualAmount == 0) {\r\n            actualAmount = fromState.accruedAmount;\r\n        }\r\n        require(fromState.accruedAmount >= actualAmount, \"transfer: insufficient value\");\r\n\r\n        AccountState storage toState = accountStates[to];\r\n\r\n        // update storage\r\n        fromState.accruedAmount = sub_(fromState.accruedAmount, actualAmount);\r\n        toState.accruedAmount = add_(toState.accruedAmount, actualAmount);\r\n\r\n        emit Transferred(from, to, actualAmount);\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n}\r\n\r\ncontract Staking is Redistributor {\r\n    // The token to deposit\r\n    address public property;\r\n\r\n    /*** Events ***/\r\n    // Event emitted when new property tokens is deposited\r\n    event Deposit(address account, uint amount);\r\n\r\n    // Event emitted when new property tokens is withdrawed\r\n    event Withdraw(address account, uint amount);\r\n\r\n    constructor(address property_, Distributor superior_) Redistributor(superior_) public {\r\n        property = property_;\r\n    }\r\n\r\n    function totalDeposits() external view returns (uint) {\r\n        return totalShares;\r\n    }\r\n\r\n    function accountState(address account) external view returns (uint, uint, uint) {\r\n        AccountState memory state = accountStates[account];\r\n        return (state.share, state.accruedIndex, state.accruedAmount);\r\n    }\r\n\r\n    // Deposit property tokens\r\n    function deposit(uint amount) external returns (uint) {\r\n        address account = msg.sender;\r\n\r\n        // accrue & distribute\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        // transfer property token in\r\n        uint actualAmount = doTransferIn(account, amount);\r\n\r\n        // update storage\r\n        AccountState storage state = accountStates[account];\r\n        totalShares = add_(totalShares, actualAmount);\r\n        state.share = add_(state.share, actualAmount);\r\n\r\n        emit Deposit(account, actualAmount);\r\n\r\n        return actualAmount;\r\n    }\r\n\r\n    // Withdraw property tokens\r\n    function withdraw(uint amount) external returns (uint) {\r\n        address account = msg.sender;\r\n        AccountState storage state = accountStates[account];\r\n        require(state.share >= amount, \"withdraw: insufficient value\");\r\n\r\n        // accrue & distribute\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        // decrease total deposits\r\n        totalShares = sub_(totalShares, amount);\r\n        state.share = sub_(state.share, amount);\r\n\r\n        // transfer property tokens back to account\r\n        doTransferOut(account, amount);\r\n\r\n        emit Withdraw(account, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\r\n     *      This will revert due to insufficient balance or insufficient allowance.\r\n     *      This function returns the actual amount received,\r\n     *      which may be less than `amount` if there is a fee attached to the transfer.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(property);\r\n        uint balanceBefore = EIP20Interface(property).balanceOf(address(this));\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                       // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                      // This is a compliant ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                      // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\r\n\r\n        // Calculate the amount that was *actually* transferred\r\n        uint balanceAfter = EIP20Interface(property).balanceOf(address(this));\r\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\r\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\r\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\r\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\r\n     *      it is >= amount, this should not revert in normal conditions.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferOut(address to, uint amount) internal {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(property);\r\n        token.transfer(to, amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                     // This is a complaint ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n    }\r\n}\r\n\r\ncontract RewardPool is RewardPoolStorage, Distributor, ExponentialNoError {\r\n    // The initial accrual index\r\n    uint internal constant initialAccruedIndex = 1e36;\r\n\r\n    /*** Events ***/\r\n\r\n    // Emitted when accrued rewards\r\n    event Accrued(uint stakingPart, address[] others, uint[] othersParts, uint debtAccruedIndex);\r\n\r\n    // Emitted when claimed rewards\r\n    event Claimed(address account, address receiver, uint amount);\r\n\r\n    // Emitted when distributed debt to miner \r\n    event DistributedDebt(string miner, uint debtDelta, uint accruedIndex);\r\n\r\n    // Emitted when repayment happend\r\n    event Repayment(string miner, address repayer, uint amount);\r\n\r\n    // Emitted when account transfer rewards\r\n    event Transferred(address from, address to, uint amount);\r\n\r\n    // Emitted when strategy is changed\r\n    event StrategyChanged(IRewardStrategy oldStrategy, IRewardStrategy newStrategy);\r\n\r\n    // Emitted when calcaultor is changed\r\n    event CalculatorChanged(IRewardCalculator oldCalculator, IRewardCalculator newCalculator);\r\n\r\n    // Emitted when staking is changed\r\n    event StakingChanged(address oldStaking, address newStaking);\r\n\r\n    // Emitted when management is changed\r\n    event ManagementChanged(IFilstManagement oldManagement, IFilstManagement newManagement);\r\n\r\n    // Emitted when liquditity is added\r\n    event LiqudityAdded(address benefactor, address admin, uint addAmount);\r\n\r\n    constructor() public { }\r\n    \r\n    function getEfilAddress() internal view returns (address) {\r\n        return 0x2a2cB9bA73289D4D068BD57D3c26165DaD5Cb628;\r\n    }\r\n\r\n    function asset() external view returns (address) {\r\n        address efilAddr = getEfilAddress();\r\n        return efilAddr;\r\n    }\r\n\r\n    // Return the accrued reward of account based on stored data\r\n    function accruedStored(address account) external view returns (uint) {\r\n        if (accrualBlockNumber == getBlockNumber() || Staking(staking).totalDeposits() == 0) {\r\n            return accruedRewards[account];\r\n        }\r\n\r\n        uint totalFilst = management.getTotalMintedAmount();\r\n        // calculate rewards\r\n        uint deltaRewards = calculator.calculate(totalFilst, accrualBlockNumber);\r\n\r\n        // allocate rewards\r\n        (uint stakingPart, address[] memory others, uint[] memory othersParts) = strategy.allocate(staking, deltaRewards);\r\n        require(others.length == othersParts.length, \"IRewardStrategy.allocalte: others length mismatch\");\r\n\r\n        if (staking == account) {\r\n            return add_(accruedRewards[staking], stakingPart);\r\n        } else {\r\n            // add accrued rewards for others\r\n            uint sumAllocation = stakingPart;\r\n            uint accountAccruedReward = accruedRewards[account];\r\n\r\n            for (uint i = 0; i < others.length; i ++) {\r\n                sumAllocation = add_(sumAllocation, othersParts[i]);\r\n                if (others[i] == account) {\r\n                    accountAccruedReward = add_(accountAccruedReward, othersParts[i]);\r\n                }\r\n            }\r\n            require(sumAllocation == deltaRewards, \"sumAllocation mismatch\");\r\n\r\n            return accountAccruedReward;\r\n        }\r\n    }\r\n\r\n    // Accrue and distribute for caller, but not actually transfer rewards to the caller\r\n    // returns the new accrued amount\r\n    function accrue() public returns (uint) {\r\n        uint blockNumber = getBlockNumber();\r\n        if (accrualBlockNumber == blockNumber) {\r\n            return accruedRewards[msg.sender];\r\n        }\r\n\r\n        if (Staking(staking).totalDeposits() == 0) {\r\n            accrualBlockNumber = blockNumber;\r\n            return accruedRewards[msg.sender];\r\n        }\r\n\r\n        // total number of FILST that participates in dividends\r\n        uint totalFilst = management.getTotalMintedAmount();\r\n        // calculate rewards\r\n        uint deltaRewards = calculator.calculate(totalFilst, accrualBlockNumber);\r\n        // allocate rewards\r\n        (uint stakingPart, address[] memory others, uint[] memory othersParts) = strategy.allocate(staking, deltaRewards);\r\n        require(others.length == othersParts.length, \"IRewardStrategy.allocalte: others length mismatch\");\r\n\r\n        // add accrued rewards for staking\r\n        accruedRewards[staking] = add_(accruedRewards[staking], stakingPart);\r\n\r\n        // add accrued rewards for others\r\n        uint sumAllocation = stakingPart;\r\n        for (uint i = 0; i < others.length; i ++) {\r\n            sumAllocation = add_(sumAllocation, othersParts[i]);\r\n            accruedRewards[others[i]] = add_(accruedRewards[others[i]], othersParts[i]);\r\n        }\r\n        require(sumAllocation == deltaRewards, \"sumAllocation mismatch\");\r\n\r\n        // accure debts\r\n        accureDebtInternal(deltaRewards);\r\n\r\n        // update accrualBlockNumber\r\n        accrualBlockNumber = blockNumber;\r\n\r\n        // emint event\r\n        emit Accrued(stakingPart, others, othersParts, debtAccruedIndex);\r\n\r\n        return accruedRewards[msg.sender];\r\n    }\r\n\r\n    function accureDebtInternal(uint deltaDebts) internal {\r\n        // require(accrualBlockNumber == getBlockNumber(), \"freshness check\");\r\n\r\n        uint totalFilst = management.getTotalMintedAmount();\r\n        Double memory ratio = fraction(deltaDebts, totalFilst);\r\n        Double memory doubleAccruedIndex = add_(Double({mantissa: debtAccruedIndex}), ratio);\r\n\r\n        // update debtAccruedIndex\r\n        debtAccruedIndex = doubleAccruedIndex.mantissa;\r\n    }\r\n\r\n\r\n    // Return the accrued debts of miner based on stored data\r\n    function accruedDebtStored(string calldata miner) external view returns(uint) {\r\n        uint storedGlobalAccruedIndex;\r\n        if (accrualBlockNumber == getBlockNumber() || Staking(staking).totalDeposits() == 0) {\r\n            storedGlobalAccruedIndex = debtAccruedIndex;\r\n        } else {\r\n            uint totalFilst = management.getTotalMintedAmount();\r\n            uint deltaDebts = calculator.calculate(totalFilst, accrualBlockNumber);\r\n            \r\n            Double memory ratio = fraction(deltaDebts, totalFilst);\r\n            Double memory doubleAccruedIndex = add_(Double({mantissa: debtAccruedIndex}), ratio);\r\n            storedGlobalAccruedIndex = doubleAccruedIndex.mantissa;\r\n        }\r\n\r\n        (, uint instantAccruedAmount) = accruedDebtStoredInternal(miner, storedGlobalAccruedIndex);\r\n        return instantAccruedAmount;\r\n    }\r\n\r\n    // Return the accrued debt of miner based on stored data\r\n    function accruedDebtStoredInternal(string memory miner, uint withDebtAccruedIndex) internal view returns(uint, uint) {\r\n        Debt memory debt = minerDebts[miner];\r\n\r\n        Double memory doubleDebtAccruedIndex = Double({mantissa: withDebtAccruedIndex});\r\n        Double memory doubleMinerAccruedIndex = Double({mantissa: debt.accruedIndex});\r\n        if (doubleMinerAccruedIndex.mantissa == 0 && doubleDebtAccruedIndex.mantissa > 0) {\r\n            doubleMinerAccruedIndex.mantissa = initialAccruedIndex;\r\n        }\r\n\r\n        uint minerMintedAmount = management.getMintedAmount(miner);\r\n\r\n        Double memory deltaIndex = sub_(doubleDebtAccruedIndex, doubleMinerAccruedIndex);\r\n        uint delta = mul_(minerMintedAmount, deltaIndex);\r\n\r\n        return (delta, add_(debt.accruedAmount, delta));\r\n    }\r\n\r\n    // accrue and distribute debt for given miner\r\n    function accrue(string memory miner) public {\r\n        accrue();\r\n        distributeDebtInternal(miner);\r\n    }\r\n\r\n    function distributeDebtInternal(string memory miner) internal {\r\n        (uint delta, uint instantAccruedAmount) = accruedDebtStoredInternal(miner, debtAccruedIndex);\r\n\r\n        Debt storage debt = minerDebts[miner];\r\n        debt.accruedIndex = debtAccruedIndex;\r\n        debt.accruedAmount = instantAccruedAmount;\r\n\r\n        // emit Distributed event\r\n        emit DistributedDebt(miner, delta, debtAccruedIndex);\r\n    }\r\n\r\n    // Claim rewards, transfer given amount rewards to receiver\r\n    function claim(address receiver, uint amount) external returns (uint) {\r\n        address account = msg.sender;\r\n\r\n        // keep fresh\r\n        accrue();\r\n\r\n        uint accruedReward = accruedRewards[account];\r\n        require(accruedReward >= amount, \"Insufficient value\");\r\n\r\n        // transfer reward to receiver\r\n        transferRewardOut(receiver, amount);\r\n\r\n        // update storage\r\n        accruedRewards[account] = sub_(accruedReward, amount);\r\n\r\n        emit Claimed(account, receiver, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    // Claim all accrued rewards\r\n    function claimAll() external returns (uint) {\r\n        address account = msg.sender;\r\n\r\n        // keep fresh\r\n        accrue();\r\n\r\n        uint accruedReward = accruedRewards[account];\r\n\r\n        // transfer\r\n        transferRewardOut(account, accruedReward);\r\n\r\n        // update storage\r\n        accruedRewards[account] = 0;\r\n\r\n        emit Claimed(account, account, accruedReward);\r\n    }\r\n\r\n    function transferRewardOut(address account, uint amount) internal {\r\n        address efilAddr = getEfilAddress();\r\n        EIP20Interface efil = EIP20Interface(efilAddr);\r\n        uint remaining = efil.balanceOf(address(this));\r\n        require(remaining >= amount, \"Insufficient cash\");\r\n\r\n        efil.transfer(account, amount);\r\n    }\r\n\r\n    // repay given amount of debts for miner\r\n    function repayDebt(string calldata miner, uint amount) external {\r\n        address repayer = msg.sender;\r\n\r\n        // keep fresh (distribute debt for miner)\r\n        accrue(miner);\r\n\r\n        // reference storage\r\n        Debt storage debt = minerDebts[miner];\r\n\r\n        uint actualAmount = amount;\r\n        if (actualAmount > debt.accruedAmount) {\r\n            actualAmount = debt.accruedAmount;\r\n        }\r\n\r\n        address efilAddr = getEfilAddress();\r\n        EIP20Interface efil = EIP20Interface(efilAddr);\r\n        require(efil.transferFrom(repayer, address(this), actualAmount), \"transferFrom failed\");\r\n\r\n        debt.accruedAmount = sub_(debt.accruedAmount, actualAmount);\r\n        debt.lastRepaymentBlock = getBlockNumber();\r\n\r\n        emit Repayment(miner, repayer, actualAmount);\r\n    }\r\n\r\n    function transfer(address to, uint amount) external {\r\n        address from = msg.sender;\r\n\r\n        // keep fresh\r\n        accrue();\r\n\r\n        uint actualAmount = amount;\r\n        if (actualAmount == 0) {\r\n            actualAmount = accruedRewards[from];\r\n        }\r\n        require(accruedRewards[from] >= actualAmount, \"Insufficient value\");\r\n\r\n        // update storage\r\n        accruedRewards[from] = sub_(accruedRewards[from], actualAmount);\r\n        accruedRewards[to] = add_(accruedRewards[to], actualAmount);\r\n\r\n        emit Transferred(from, to, actualAmount);\r\n    }\r\n    \r\n    /*** Admin Functions ***/\r\n\r\n    // set management contract\r\n    function setManagement(IFilstManagement newManagement) external {\r\n        require(msg.sender == admin, \"admin check\");\r\n        require(address(newManagement) != address(0), \"Invalid newManagement\");\r\n\r\n        if (debtAccruedIndex == 0) {\r\n            debtAccruedIndex = initialAccruedIndex;\r\n        }\r\n\r\n        // save old for event\r\n        IFilstManagement oldManagement = management;\r\n        // update\r\n        management = newManagement;\r\n\r\n        emit ManagementChanged(oldManagement, newManagement);\r\n    }\r\n\r\n    // set strategy contract\r\n    function setStrategy(IRewardStrategy newStrategy) external {\r\n        require(msg.sender == admin, \"admin check\");\r\n        require(address(newStrategy) != address(0), \"Invalid newStrategy\");\r\n\r\n        // save old for event\r\n        IRewardStrategy oldStrategy = strategy;\r\n        // update\r\n        strategy = newStrategy;\r\n\r\n        emit StrategyChanged(oldStrategy, newStrategy);\r\n    }\r\n\r\n    // set calculator contract\r\n    function setCalculator(IRewardCalculator newCalculator) external {\r\n        require(msg.sender == admin, \"admin check\");\r\n        require(address(newCalculator) != address(0), \"Invalid newCalculator\");\r\n\r\n        // save old for event\r\n        IRewardCalculator oldCalculator = calculator;\r\n        // update\r\n        calculator = newCalculator;\r\n\r\n        emit CalculatorChanged(oldCalculator, newCalculator);\r\n    }\r\n\r\n    // set staking contract\r\n    function setStaking(address newStaking) external {\r\n        require(msg.sender == admin, \"admin check\");\r\n        require(address(Staking(newStaking).superior()) == address(this), \"Staking superior mismatch\");\r\n        require(Staking(newStaking).property() == filstAddress, \"Staking property mismatch\");\r\n        address efilAddr = getEfilAddress();\r\n        require(Staking(newStaking).asset() == efilAddr, \"Staking asset mismatch\");\r\n\r\n        // save old for event\r\n        address oldStaking = staking;\r\n        // update\r\n        staking = newStaking;\r\n\r\n        emit StakingChanged(oldStaking, newStaking);\r\n    }\r\n\r\n    // add eFIL to pool\r\n    function addLiqudity(uint amount) external {\r\n        // transfer in\r\n        address efilAddr = getEfilAddress();\r\n        require(EIP20Interface(efilAddr).transferFrom(msg.sender, address(this), amount), \"transfer in failed\");\r\n        // added accrued rewards to admin\r\n        accruedRewards[admin] = add_(accruedRewards[admin], amount);\r\n\r\n        emit LiqudityAdded(msg.sender, admin, amount);\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    function _become(RewardPoolDelegator delegator) public {\r\n        require(msg.sender == delegator.admin(), \"only delegator admin can change implementation\");\r\n        delegator._acceptImplementation();\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingPart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"others\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"othersParts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtAccruedIndex\",\"type\":\"uint256\"}],\"name\":\"Accrued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRewardCalculator\",\"name\":\"oldCalculator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IRewardCalculator\",\"name\":\"newCalculator\",\"type\":\"address\"}],\"name\":\"CalculatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"miner\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accruedIndex\",\"type\":\"uint256\"}],\"name\":\"DistributedDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"}],\"name\":\"LiqudityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IFilstManagement\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IFilstManagement\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"miner\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"repayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Repayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldStaking\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStaking\",\"type\":\"address\"}],\"name\":\"StakingChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRewardStrategy\",\"name\":\"oldStrategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IRewardStrategy\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"StrategyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract RewardPoolDelegator\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"_become\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"miner\",\"type\":\"string\"}],\"name\":\"accrue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"accrue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"miner\",\"type\":\"string\"}],\"name\":\"accruedDebtStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accruedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accruedStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiqudity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculator\",\"outputs\":[{\"internalType\":\"contract IRewardCalculator\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debtAccruedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"efilAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"filstAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"contract IFilstManagement\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"minerDebts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRepaymentBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"miner\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayDebt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IRewardCalculator\",\"name\":\"newCalculator\",\"type\":\"address\"}],\"name\":\"setCalculator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IFilstManagement\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStaking\",\"type\":\"address\"}],\"name\":\"setStaking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IRewardStrategy\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"setStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract IRewardStrategy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RewardPool","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://46b1e7ab841bc91abf1858bd8f5e52b43b594bfed24419fce8b204d9fe912c2d"}]}