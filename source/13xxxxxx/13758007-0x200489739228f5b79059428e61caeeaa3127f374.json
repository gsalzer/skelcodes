{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/interfaces/IChickenNoodle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IChickenNoodle {\\n    // struct to store each token's traits\\n    struct ChickenNoodleTraits {\\n        bool minted;\\n        bool isChicken;\\n        uint8 backgrounds;\\n        uint8 snakeBodies;\\n        uint8 mouthAccessories;\\n        uint8 pupils;\\n        uint8 bodyAccessories;\\n        uint8 hats;\\n        uint8 tier;\\n    }\\n\\n    function MAX_TOKENS() external view returns (uint256);\\n\\n    function PAID_TOKENS() external view returns (uint256);\\n\\n    function tokenTraits(uint256 tokenId)\\n        external\\n        view\\n        returns (ChickenNoodleTraits memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function mint(address to, uint16 tokenId) external;\\n\\n    function finalize(\\n        uint16 tokenId,\\n        ChickenNoodleTraits memory traits,\\n        address thief\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './IChickenNoodle.sol';\\n\\ninterface IFarm {\\n    struct Stake {\\n        uint16 tokenId;\\n        uint80 value;\\n        address owner;\\n    }\\n\\n    struct PagingData {\\n        address tokenOwner;\\n        uint16 limit;\\n        uint16 page;\\n    }\\n\\n    function totalChickenStaked() external view returns (uint16);\\n\\n    function MINIMUM_TO_EXIT() external view returns (uint256);\\n\\n    function MAX_TIER_SCORE() external view returns (uint8);\\n\\n    function MAXIMUM_GLOBAL_EGG() external view returns (uint256);\\n\\n    function DAILY_GEN0_EGG_RATE() external view returns (uint256);\\n\\n    function DAILY_GEN1_EGG_RATE() external view returns (uint256);\\n\\n    function eggPerTierScore() external view returns (uint256);\\n\\n    function totalEggEarned() external view returns (uint256);\\n\\n    function lastClaimTimestamp() external view returns (uint256);\\n\\n    function denIndices(uint16 tokenId) external view returns (uint16);\\n\\n    function chickenNoodle() external view returns (IChickenNoodle);\\n\\n    function isChicken(uint16 tokenId) external view returns (bool);\\n\\n    function tierScoreForNoodle(uint16 tokenId) external view returns (uint8);\\n\\n    function randomNoodleOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FarmLookupLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IFarm.sol';\\n\\nlibrary FarmLookupLibrary {\\n    struct Counters {\\n        uint256 skipCounter;\\n        uint256 counter;\\n    }\\n\\n    function getTotalStaked(\\n        address farmAddress,\\n        mapping(uint8 => IFarm.Stake[]) storage den\\n    )\\n        public\\n        view\\n        returns (\\n            uint16 chickens,\\n            uint16 noodles,\\n            uint16 tier5Noodles,\\n            uint16 tier4Noodles,\\n            uint16 tier3Noodles,\\n            uint16 tier2Noodles,\\n            uint16 tier1Noodles\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        chickens = farm.totalChickenStaked();\\n\\n        tier5Noodles = uint16(den[farm.MAX_TIER_SCORE()].length);\\n        tier4Noodles = uint16(den[farm.MAX_TIER_SCORE() - 1].length);\\n        tier3Noodles = uint16(den[farm.MAX_TIER_SCORE() - 2].length);\\n        tier2Noodles = uint16(den[farm.MAX_TIER_SCORE() - 3].length);\\n        tier1Noodles = uint16(den[farm.MAX_TIER_SCORE() - 4].length);\\n\\n        noodles =\\n            tier5Noodles +\\n            tier4Noodles +\\n            tier3Noodles +\\n            tier2Noodles +\\n            tier1Noodles;\\n    }\\n\\n    function getStakedBalanceOf(\\n        address farmAddress,\\n        address tokenOwner,\\n        mapping(uint16 => IFarm.Stake) storage henHouse,\\n        mapping(uint8 => IFarm.Stake[]) storage den,\\n        mapping(uint16 => uint16) storage denIndices\\n    )\\n        public\\n        view\\n        returns (\\n            uint16 chickens,\\n            uint16 noodles,\\n            uint16 tier5Noodles,\\n            uint16 tier4Noodles,\\n            uint16 tier3Noodles,\\n            uint16 tier2Noodles,\\n            uint16 tier1Noodles\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\\n\\n        for (uint16 tokenId = 1; tokenId <= supply; tokenId++) {\\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\\n                continue;\\n            }\\n\\n            if (farm.isChicken(tokenId)) {\\n                if (henHouse[tokenId].owner == tokenOwner) {\\n                    chickens++;\\n                }\\n            } else {\\n                uint8 tierScore = farm.tierScoreForNoodle(tokenId);\\n\\n                if (den[tierScore][denIndices[tokenId]].owner == tokenOwner) {\\n                    if (tierScore == 8) {\\n                        tier5Noodles++;\\n                    } else if (tierScore == 7) {\\n                        tier4Noodles++;\\n                    } else if (tierScore == 6) {\\n                        tier3Noodles++;\\n                    } else if (tierScore == 5) {\\n                        tier2Noodles++;\\n                    } else if (tierScore == 4) {\\n                        tier1Noodles++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        noodles =\\n            tier5Noodles +\\n            tier4Noodles +\\n            tier3Noodles +\\n            tier2Noodles +\\n            tier1Noodles;\\n    }\\n\\n    function getStakedChickensForOwner(\\n        address farmAddress,\\n        IFarm.PagingData memory data,\\n        mapping(uint16 => IFarm.Stake) storage henHouse,\\n        mapping(uint8 => IFarm.Stake[]) storage den,\\n        mapping(uint16 => uint16) storage denIndices\\n    )\\n        public\\n        view\\n        returns (\\n            uint16[] memory tokens,\\n            uint256[] memory timeTellUnlock,\\n            uint256[] memory earnedEgg\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        (uint16 tokensOwned, , , , , , ) = getStakedBalanceOf(\\n            farmAddress,\\n            data.tokenOwner,\\n            henHouse,\\n            den,\\n            denIndices\\n        );\\n\\n        (uint256 tokensSize, uint256 pageStart) = _paging(\\n            tokensOwned,\\n            data.limit,\\n            data.page\\n        );\\n\\n        tokens = new uint16[](tokensSize);\\n        timeTellUnlock = new uint256[](tokensSize);\\n        earnedEgg = new uint256[](tokensSize);\\n\\n        Counters memory counters;\\n\\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counters.counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\\n                continue;\\n            }\\n\\n            if (\\n                farm.isChicken(tokenId) &&\\n                henHouse[tokenId].owner == data.tokenOwner\\n            ) {\\n                IFarm.Stake memory stake = henHouse[tokenId];\\n\\n                if (counters.skipCounter < pageStart) {\\n                    counters.skipCounter++;\\n                    continue;\\n                }\\n\\n                tokens[counters.counter] = tokenId;\\n                timeTellUnlock[counters.counter] = block.timestamp -\\n                    stake.value <\\n                    farm.MINIMUM_TO_EXIT()\\n                    ? farm.MINIMUM_TO_EXIT() - (block.timestamp - stake.value)\\n                    : 0;\\n\\n                if (farm.totalEggEarned() < farm.MAXIMUM_GLOBAL_EGG()) {\\n                    earnedEgg[counters.counter] =\\n                        ((block.timestamp - stake.value) *\\n                            (\\n                                tokenId <= farm.chickenNoodle().PAID_TOKENS()\\n                                    ? farm.DAILY_GEN0_EGG_RATE()\\n                                    : farm.DAILY_GEN1_EGG_RATE()\\n                            )) /\\n                        1 days;\\n                } else if (stake.value > farm.lastClaimTimestamp()) {\\n                    earnedEgg[counters.counter] = 0; // $EGG production stopped already\\n                } else {\\n                    earnedEgg[counters.counter] =\\n                        ((farm.lastClaimTimestamp() - stake.value) *\\n                            (\\n                                tokenId <= farm.chickenNoodle().PAID_TOKENS()\\n                                    ? farm.DAILY_GEN0_EGG_RATE()\\n                                    : farm.DAILY_GEN1_EGG_RATE()\\n                            )) /\\n                        1 days; // stop earning additional $EGG if it's all been earned\\n                }\\n\\n                counters.counter++;\\n            }\\n        }\\n    }\\n\\n    function getStakedNoodlesForOwner(\\n        address farmAddress,\\n        IFarm.PagingData memory data,\\n        mapping(uint16 => IFarm.Stake) storage henHouse,\\n        mapping(uint8 => IFarm.Stake[]) storage den,\\n        mapping(uint16 => uint16) storage denIndices\\n    )\\n        public\\n        view\\n        returns (\\n            uint16[] memory tokens,\\n            uint8[] memory tier,\\n            uint256[] memory taxedEgg\\n        )\\n    {\\n        IFarm farm = IFarm(farmAddress);\\n\\n        (, uint16 tokensOwned, , , , , ) = getStakedBalanceOf(\\n            farmAddress,\\n            data.tokenOwner,\\n            henHouse,\\n            den,\\n            denIndices\\n        );\\n\\n        (uint256 tokensSize, uint256 pageStart) = _paging(\\n            tokensOwned,\\n            data.limit,\\n            data.page\\n        );\\n\\n        tokens = new uint16[](tokensSize);\\n        tier = new uint8[](tokensSize);\\n        taxedEgg = new uint256[](tokensSize);\\n\\n        Counters memory counters;\\n\\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counters.counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\\n                continue;\\n            }\\n\\n            if (!farm.isChicken(tokenId)) {\\n                uint8 tierScore = farm.tierScoreForNoodle(tokenId);\\n\\n                IFarm.Stake memory stake = den[tierScore][denIndices[tokenId]];\\n\\n                if (stake.owner == data.tokenOwner) {\\n                    if (counters.skipCounter < pageStart) {\\n                        counters.skipCounter++;\\n                        continue;\\n                    }\\n\\n                    tokens[counters.counter] = tokenId;\\n                    tier[counters.counter] = tierScore - 3;\\n                    taxedEgg[counters.counter] =\\n                        (tierScore) *\\n                        (farm.eggPerTierScore() - stake.value);\\n                    counters.counter++;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _paging(\\n        uint16 tokensOwned,\\n        uint16 limit,\\n        uint16 page\\n    ) private pure returns (uint256 tokensSize, uint256 pageStart) {\\n        pageStart = limit * page;\\n        uint256 pageEnd = limit * (page + 1);\\n        tokensSize = tokensOwned >= pageEnd\\n            ? limit\\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[]","ContractName":"FarmLookupLibrary","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}