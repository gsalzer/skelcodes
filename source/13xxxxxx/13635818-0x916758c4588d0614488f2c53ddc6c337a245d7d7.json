{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MiniStayPuft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IERC721.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Enumerable.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Metadata.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Receiver.sol\\\";\\r\\nimport \\\"./interfaces/IERC165.sol\\\";\\r\\n\\r\\nimport \\\"./IGBATrapsPartial.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\nimport \\\"./GBAWhitelist.sol\\\";\\r\\n\\r\\n/// @author Andrew Parker\\r\\n/// @title Ghost Busters: Afterlife Mini Stay Puft NFT contract\\r\\ncontract MiniStayPuft is IERC721, IERC721Metadata, IERC165, Ownable{\\r\\n\\r\\n    enum Phase{Init,PreReserve,Reserve,Final} // Launch phase\\r\\n    struct Reservation{\\r\\n        uint24 block;       // Using uint24 to store block number is fine for the next 2.2 years\\r\\n        uint16[] tokens;    // TokenIDs reserved by person\\r\\n    }\\r\\n    bool paused = true;                 // Sale pause state\\r\\n    bool unpausable;                    // Unpausable\\r\\n    uint startTime;                     // Timestamp of when preReserve phase started (adjusts when paused/unpaused)\\r\\n    uint pauseTime;                     // Timestamp of pause\\r\\n    uint16 tokenCount;                  // Total tokens minted and reserved. (not including caught mobs)\\r\\n\\r\\n    uint16 tokensGiven;                     // Total number of giveaway token's minted\\r\\n    uint16 constant TOKENS_GIVEAWAY = 200;  // Max number of giveaway tokens\\r\\n\\r\\n    uint constant PRICE_MINT = 0.08 ether;    // Mint cost\\r\\n\\r\\n    string __uriBase;       // Metadata URI base\\r\\n    string __uriSuffix;     // Metadata URI suffix\\r\\n\\r\\n    uint constant COOLDOWN = 10;            // Min interval in blocks to reserve\\r\\n    uint16 constant TRANSACTION_LIMIT = 10; // Max tokens reservable in one transaction\\r\\n\\r\\n    mapping(address => Reservation) reservations;       // Mapping of buyer to reservations\\r\\n    mapping(address => uint8) whitelistReserveCount;    // Mapping of how many times listees have preReserved\\r\\n    uint8 constant WHITELIST_RESERVE_LIMIT = 2;         // Limit of how many tokens a listee can preReserve\\r\\n    uint constant PRESALE_LIMIT = 2000;                 // Max number of tokens that can be preReserved\\r\\n    uint presaleCount;                                  // Number of tokens that have been preReserved\\r\\n\\r\\n\\r\\n    event Pause(bool _pause,uint _startTime,uint _pauseTime);\\r\\n    event Reserve(address indexed reservist, uint indexed tokenId);\\r\\n    event Claim(address indexed reservist, uint indexed tokenId);\\r\\n\\r\\n    //MOB VARS\\r\\n    address trapContract;   // Address of Traps contract\\r\\n    address whitelist;      // Address of Whitelist contract\\r\\n\\r\\n    uint16 constant SALE_MAX = 10000;       // Max number of tokens that can be sold\\r\\n    uint16[4] mobTokenIds;                  // Partial IDs of current mobs. 4th slot is highest id (used to detect mob end)\\r\\n    uint16 constant TOTAL_MOB_COUNT = 500;  // Total number of mobs that will exist\\r\\n\\r\\n    uint constant MOB_OFFSET = 100000;      // TokenId offset for mobs\\r\\n\\r\\n    bool mobReleased = false;               // Has mob been released\\r\\n    bytes32 mobHash;                        // Current mob data\\r\\n\\r\\n\\r\\n    mapping(address => uint256) internal balances;                      // Mapping of balances (not including active mobs)\\r\\n    mapping (uint256 => address) internal allowance;                    // Mapping of allowances\\r\\n    mapping (address => mapping (address => bool)) internal authorised; // Mapping of token allowances\\r\\n\\r\\n    mapping(uint256 => address) owners;  // Mapping of owners (not including active mobs)\\r\\n\\r\\n    uint[] tokens;      // Array of tokenIds (not including active mobs)\\r\\n\\r\\n    mapping (bytes4 => bool) internal supportedInterfaces;\\r\\n\\r\\n\\r\\n    constructor(string memory _uriBase, string memory _uriSuffix, address _trapContract, address _whitelist){\\r\\n\\r\\n        supportedInterfaces[0x80ac58cd] = true; //ERC721\\r\\n        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\\r\\n        supportedInterfaces[0x01ffc9a7] = true; //ERC165\\r\\n\\r\\n        mobTokenIds[0] = 1;\\r\\n        mobTokenIds[1] = 2;\\r\\n        mobTokenIds[2] = 3;\\r\\n        mobTokenIds[3] = 3;\\r\\n\\r\\n        trapContract = _trapContract;\\r\\n        whitelist = _whitelist;\\r\\n\\r\\n        __uriBase = _uriBase;\\r\\n        __uriSuffix = _uriSuffix;\\r\\n\\r\\n        //Init mobHash segments\\r\\n        mobHash =\\r\\n            shiftBytes(bytes32(uint(0)),0) ^ // Random data that changes every tx to even out gas costs\\r\\n            shiftBytes(bytes32(uint(1)),1) ^ // Number of owners to base ownership calcs on for mob 0\\r\\n            shiftBytes(bytes32(uint(1)),2) ^ // Number of owners to base ownership calcs on for mob 1\\r\\n            shiftBytes(bytes32(uint(1)),3) ^ // Number of owners to base ownership calcs on for mob 2\\r\\n            shiftBytes(bytes32(uint(0)),4);  // Location data for calculating ownership of all mobs\\r\\n    }\\r\\n\\r\\n    /// Mint-Reserve State\\r\\n    /// @notice Get struct properties of reservation mapping for given address, as well as preReserve count.\\r\\n    /// @dev Combined these to lower compiled contract size (Spurious Dragon).\\r\\n    /// @param _tokenOwner Address of reservation data to check\\r\\n    /// @return _whitelistReserveCount Number of times address has pre-reserved\\r\\n    /// @return blockNumber Block number of last reservation\\r\\n    /// @return tokenIds Array of reserved, unclaimed tokens\\r\\n    function mintReserveState(address _tokenOwner)  public view returns(uint8 _whitelistReserveCount, uint24 blockNumber, uint16[] memory tokenIds){\\r\\n        return (whitelistReserveCount[_tokenOwner],reservations[_tokenOwner].block,reservations[_tokenOwner].tokens);\\r\\n    }\\r\\n\\r\\n    /// Contract State\\r\\n    /// @notice View function for various contract state properties\\r\\n    /// @dev Combined these to lower compiled contract size (Spurious Dragon).\\r\\n    /// @return _tokenCount Number of tokens reserved or minted (not including mobs)\\r\\n    /// @return _phase Current launch phase\\r\\n    /// @return mobMax Uint used to calculate IDs and number if mobs in circulation.\\r\\n    function contractState() public view returns(uint _tokenCount, Phase _phase, uint mobMax){\\r\\n        return (tokenCount,phase(),mobTokenIds[3]);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /// Pre-Reserve\\r\\n    /// @notice Pre-reserve tokens during Pre-Reserve phase if whitelisted. Max 2 per address. Must pay mint fee\\r\\n    /// @param merkleProof Merkle proof for your address in the whitelist\\r\\n    /// @param _count Number of tokens to reserve\\r\\n    function preReserve(bytes32[] memory merkleProof, uint8 _count) external payable{\\r\\n        require(!paused,\\\"paused\\\");\\r\\n        require(phase() == Phase.PreReserve,\\\"phase\\\");\\r\\n        require(msg.value >= PRICE_MINT * _count,\\\"PRICE_MINT\\\");\\r\\n        require(whitelistReserveCount[msg.sender] + _count <= WHITELIST_RESERVE_LIMIT,\\\"whitelistReserveCount\\\");\\r\\n        require(presaleCount + _count < PRESALE_LIMIT,\\\"PRESALE_LIMIT\\\");\\r\\n        require(GBAWhitelist(whitelist).isWhitelisted(merkleProof,msg.sender),\\\"whitelist\\\");\\r\\n\\r\\n        whitelistReserveCount[msg.sender] += _count;\\r\\n        presaleCount += _count;\\r\\n        _reserve(_count,msg.sender,true);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Mint Giveaway\\r\\n    /// @notice Mint tokens for giveaway\\r\\n    /// @param numTokens Number of tokens to mint\\r\\n    function mintGiveaway(uint16 numTokens) public onlyOwner {\\r\\n        require(tokensGiven + numTokens <= TOKENS_GIVEAWAY,\\\"tokensGiven\\\");\\r\\n        require(tokenCount + numTokens <= SALE_MAX,\\\"SALE_MAX\\\");\\r\\n        for(uint i = 0; i < numTokens; i++){\\r\\n            tokensGiven++;\\r\\n            _mint(msg.sender,++tokenCount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// Withdraw All\\r\\n    /// @notice Withdraw all Eth from mint fees\\r\\n    function withdrawAll() public onlyOwner {\\r\\n        require(payable(msg.sender).send(address(this).balance));\\r\\n    }\\r\\n\\r\\n    /// Reserve\\r\\n    /// @notice Reserve tokens. Max 10 per tx, one tx per 10 blocks. Can't be called by contracts. Must be in Reserve phase. Must pay mint fee.\\r\\n    /// @param _count Number of tokens to reserve\\r\\n    /// @dev requires tx.origin == msg.sender\\r\\n    function reserve(uint16 _count) public payable{\\r\\n        require(msg.sender == tx.origin,\\\"origin\\\");\\r\\n        require(!paused,\\\"paused\\\");\\r\\n        require(phase() == Phase.Reserve,\\\"phase\\\");\\r\\n        require(_count <= TRANSACTION_LIMIT,\\\"TRANSACTION_LIMIT\\\");\\r\\n        require(msg.value >= uint(_count) * PRICE_MINT,\\\"PRICE MINT\\\");\\r\\n\\r\\n        _reserve(_count,msg.sender,false);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Internal Reserve\\r\\n    /// @notice Does the work in both Reserve and PreReserve\\r\\n    /// @param _count Number of tokens being reserved\\r\\n    /// @param _to Address that is reserving\\r\\n    /// @param ignoreCooldown Don't revert for cooldown.Used in pre-reserve\\r\\n    function _reserve(uint16 _count, address _to, bool ignoreCooldown) internal{\\r\\n        require(tokenCount + _count <= SALE_MAX, \\\"SALE_MAX\\\");\\r\\n        require(ignoreCooldown ||\\r\\n            reservations[_to].block == 0 || block.number >= uint(reservations[_to].block) + COOLDOWN\\r\\n        ,\\\"COOLDOWN\\\");\\r\\n\\r\\n        for(uint16 i = 0; i < _count; i++){\\r\\n            reservations[address(_to)].tokens.push(++tokenCount);\\r\\n\\r\\n            emit Reserve(_to,tokenCount);\\r\\n        }\\r\\n        reservations[_to].block = uint24(block.number);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Claim\\r\\n    /// @notice Mint reserved tokens\\r\\n    /// @param reservist Address with reserved tokens.\\r\\n    /// @param _count Number of reserved tokens mint.\\r\\n    /// @dev Allows anyone to call claim for anyone else. Will mint to the address that made the reservations.\\r\\n    function claim(address reservist, uint _count) public{\\r\\n        require(!paused,\\\"paused\\\");\\r\\n        require(\\r\\n            phase() == Phase.Final\\r\\n        ,\\\"phase\\\");\\r\\n\\r\\n        require( reservations[reservist].tokens.length >= _count, \\\"_count\\\");\\r\\n        for(uint i = 0; i < _count; i++){\\r\\n            uint tokenId = uint(reservations[reservist].tokens[reservations[reservist].tokens.length - 1]);\\r\\n            reservations[reservist].tokens.pop();\\r\\n            _mint(reservist,tokenId);\\r\\n            emit Claim(reservist,tokenId);\\r\\n        }\\r\\n\\r\\n        updateMobStart();\\r\\n        updateMobFinish();\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Mint\\r\\n    /// @notice Mint unreserved tokens. Must pay mint fee.\\r\\n    /// @param _count Number of reserved tokens mint.\\r\\n    function mint(uint _count) public payable{\\r\\n        require(!paused,\\\"paused\\\");\\r\\n        require(\\r\\n            phase() == Phase.Final\\r\\n        ,\\\"phase\\\");\\r\\n        require(msg.value >= _count * PRICE_MINT,\\\"PRICE\\\");\\r\\n\\r\\n        require(tokenCount + uint16(_count) <= SALE_MAX,\\\"SALE_MAX\\\");\\r\\n\\r\\n        for(uint i = 0; i < _count; i++){\\r\\n            _mint(msg.sender,uint(++tokenCount));\\r\\n        }\\r\\n\\r\\n        updateMobStart();\\r\\n        updateMobFinish();\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Update URI\\r\\n    /// @notice Update URI base and suffix\\r\\n    /// @param _uriBase URI base\\r\\n    /// @param _uriSuffix URI suffix\\r\\n    /// @dev Pushing size limits (Spurious Dragon), so rather than having an explicit lock function, it can be implicit by renouncing ownership.\\r\\n    function updateURI(string memory _uriBase, string memory _uriSuffix) public onlyOwner{\\r\\n        __uriBase   = _uriBase;\\r\\n        __uriSuffix = _uriSuffix;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Phase\\r\\n    /// @notice Internal function to calculate current Phase\\r\\n    /// @return Phase (enum value)\\r\\n    function phase() internal view returns(Phase){\\r\\n        uint _startTime = startTime;\\r\\n        if(_startTime == 0){\\r\\n            return Phase.Init;\\r\\n        }else if(block.timestamp <= _startTime + 2 hours){\\r\\n            return Phase.PreReserve;\\r\\n        }else if(block.timestamp <= _startTime + 2 hours + 1 days && tokenCount < SALE_MAX){\\r\\n            return Phase.Reserve;\\r\\n        }else{\\r\\n            return Phase.Final;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// Pause State\\r\\n    /// @notice Get current pause state\\r\\n    /// @return _paused Contract is paused\\r\\n    /// @return _startTime Start timestamp of Cat phase (adjusted for pauses)\\r\\n    /// @return _pauseTime Timestamp of pause\\r\\n    function pauseState() view public returns(bool _paused,uint _startTime,uint _pauseTime){\\r\\n        return (paused,startTime,pauseTime);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Disable pause\\r\\n    /// @notice Disable mint pausability\\r\\n    function disablePause() public onlyOwner{\\r\\n        if(paused) togglePause();\\r\\n        unpausable = true;\\r\\n    }\\r\\n\\r\\n    /// Toggle pause\\r\\n    /// @notice Toggle pause on/off\\r\\n    function togglePause() public onlyOwner{\\r\\n        if(startTime == 0){\\r\\n            startTime = block.timestamp;\\r\\n            paused = false;\\r\\n            emit Pause(false,startTime,pauseTime);\\r\\n            return;\\r\\n        }\\r\\n        require(!unpausable,\\\"unpausable\\\");\\r\\n\\r\\n        bool _pause = !paused;\\r\\n        if(_pause){\\r\\n            pauseTime = block.timestamp;\\r\\n        }else if(pauseTime != 0){\\r\\n            startTime += block.timestamp - pauseTime;\\r\\n            delete pauseTime;\\r\\n        }\\r\\n        paused = _pause;\\r\\n        emit Pause(_pause,startTime,pauseTime);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Get Mob Owner\\r\\n    /// @notice Internal func to calculate the owner of a given mob for a given mob hash\\r\\n    /// @param _mobIndex Index of mob to check (0-2)\\r\\n    /// @param _mobHash Mob hash to base calcs off\\r\\n    /// @return Address of the calculated owner\\r\\n    function getMobOwner(uint _mobIndex, bytes32 _mobHash) internal view returns(address){\\r\\n        bytes32 mobModulo = extractBytes(_mobHash, _mobIndex + 1);\\r\\n        bytes32 locationHash = extractBytes(_mobHash,4);\\r\\n\\r\\n        uint hash = uint(keccak256(abi.encodePacked(locationHash,_mobIndex,mobModulo)));\\r\\n        uint index = hash % uint(mobModulo);\\r\\n\\r\\n        address _owner = owners[tokens[index]];\\r\\n\\r\\n        if(mobReleased){\\r\\n            return _owner;\\r\\n        }else{\\r\\n            return address(0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// Get Mob Token ID (internal)\\r\\n    /// @notice Internal func to calculate mob token ID given an index\\r\\n    /// @dev Doesn't check invalid vals, inferred by places where its used and saves gas\\r\\n    /// @param _mobIndex Index of mob to calculate\\r\\n    /// @return tokenId of mob\\r\\n    function _getMobTokenId(uint _mobIndex) internal view returns(uint){\\r\\n        return MOB_OFFSET+uint(mobTokenIds[_mobIndex]);\\r\\n    }\\r\\n\\r\\n    /// Get Mob Token ID\\r\\n    /// @notice Calculate mob token ID given an index\\r\\n    /// @dev Doesn't fail for _mobIndex = 3, because of Spurious Dragon and because it doesnt matter\\r\\n    /// @param _mobIndex Index of mob to calculate\\r\\n    /// @return tokenId of mob\\r\\n    function getMobTokenId(uint _mobIndex) public view returns(uint){\\r\\n        uint tokenId = _getMobTokenId(_mobIndex);\\r\\n        require(tokenId != MOB_OFFSET,\\\"no token\\\");\\r\\n        return tokenId;\\r\\n    }\\r\\n\\r\\n    /// Extract Bytes\\r\\n    /// @notice Get the nth 4-byte chunk from a bytes32\\r\\n    /// @param data Data to extract bytes from\\r\\n    /// @param index Index of chunk\\r\\n    function extractBytes(bytes32 data, uint index) internal pure returns(bytes32){\\r\\n        uint inset = 32 * ( 7 -  index );\\r\\n        uint outset = 32 * index;\\r\\n        return ((data  << outset) >> outset) >> inset;\\r\\n    }\\r\\n\\r\\n    /// Extract Bytes\\r\\n    /// @notice Bit shift a bytes32 for XOR packing\\r\\n    /// @param data Data to bit shift\\r\\n    /// @param index How many 4-byte segments to shift it by\\r\\n    function shiftBytes(bytes32 data, uint index) internal pure returns(bytes32){\\r\\n        uint inset = 32 * ( 7 -  index );\\r\\n        return data << inset;\\r\\n    }\\r\\n\\r\\n    /// Release Mob\\r\\n    /// @notice Start Mob\\r\\n    function releaseMob() public onlyOwner{\\r\\n        require(!mobReleased,\\\"released\\\");\\r\\n        require(tokens.length > 0, \\\"no mint\\\");\\r\\n\\r\\n        mobReleased = true;\\r\\n\\r\\n        bytes32 _mobHash = mobHash;                                         //READ\\r\\n        uint eliminationBlock = block.number - (block.number % 245) - 10;    //READ\\r\\n\\r\\n        bytes32 updateHash  = extractBytes(keccak256(abi.encodePacked(_mobHash)),0);\\r\\n\\r\\n        bytes32 mobModulo = bytes32(tokens.length);\\r\\n        bytes32 destinationHash = extractBytes( blockhash(eliminationBlock),4) ;\\r\\n\\r\\n        bytes32 newMobHash =    shiftBytes(updateHash,0) ^                                                //WRITE\\r\\n                                shiftBytes(mobModulo,1) ^\\r\\n                                shiftBytes(mobModulo,2) ^\\r\\n                                shiftBytes(mobModulo,3) ^\\r\\n                                shiftBytes(destinationHash,4);\\r\\n\\r\\n        for(uint i = 0; i < 3; i++){\\r\\n            uint _tokenId = _getMobTokenId(i);                                       //READ x 3\\r\\n            emit Transfer(address(0),getMobOwner(i,newMobHash),_tokenId);           //EMIT x 3 max\\r\\n        }\\r\\n\\r\\n        mobHash = newMobHash;\\r\\n    }\\r\\n\\r\\n    /// Update Mobs Start\\r\\n    /// @notice Internal - Emits all the events sending mobs to 0. First part of mobs moving\\r\\n    function updateMobStart() internal{\\r\\n        if(!mobReleased || mobTokenIds[3] == 0) return;\\r\\n\\r\\n        //BURN THEM\\r\\n        bytes32 _mobHash = mobHash;                                         //READ\\r\\n        for(uint i = 0; i < 3; i++){\\r\\n            uint _tokenId = _getMobTokenId(i);                                       //READ x 3\\r\\n            if(_tokenId != MOB_OFFSET){\\r\\n                emit Transfer(getMobOwner(i,_mobHash),address(0),_tokenId);           //READx3, EMIT x 3 max\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// Update Mobs Finish\\r\\n    /// @notice Internal - Calculates mob owners and emits events sending to them. Second part of mobs moving\\r\\n    function updateMobFinish() internal {\\r\\n        if(!mobReleased) {\\r\\n            require(gasleft() > 100000,\\\"gas failsafe\\\");\\r\\n            return;\\r\\n        }\\r\\n        if(mobTokenIds[3] == 0) return;\\r\\n\\r\\n        require(gasleft() > 64500,\\\"gas failsafe\\\");\\r\\n\\r\\n        bytes32 _mobHash = mobHash;                                         //READ\\r\\n        uint eliminationBlock = block.number - (block.number % 245) - 10;    //READ\\r\\n\\r\\n        bytes32 updateHash  = extractBytes(keccak256(abi.encodePacked(_mobHash)),0);\\r\\n\\r\\n        bytes32 mobModulo0 = extractBytes(_mobHash,1);\\r\\n        bytes32 mobModulo1 = extractBytes(_mobHash,2);\\r\\n        bytes32 mobModulo2 = extractBytes(_mobHash,3);\\r\\n\\r\\n        bytes32 destinationHash = extractBytes( blockhash(eliminationBlock),4);\\r\\n\\r\\n        bytes32 newMobHash = shiftBytes(updateHash,0) ^\\r\\n                                shiftBytes(mobModulo0,1) ^\\r\\n                                shiftBytes(mobModulo1,2) ^\\r\\n                                shiftBytes(mobModulo2,3) ^\\r\\n                                shiftBytes(destinationHash,4);\\r\\n\\r\\n        mobHash = newMobHash; //WRITE\\r\\n\\r\\n        for(uint i = 0; i < 3; i++){\\r\\n            uint _tokenId = _getMobTokenId(i);                                       //READ x 3\\r\\n            if(_tokenId != MOB_OFFSET){\\r\\n                emit Transfer(address(0),getMobOwner(i,newMobHash),_tokenId);         //READx3, EMIT x 3 max\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Update Catch Mob\\r\\n    /// @notice Catch a mob that's in your wallet\\r\\n    /// @param _mobIndex Index of mob to catch\\r\\n    /// @dev Mints real token and updates mobs\\r\\n    function catchMob(uint _mobIndex) public {\\r\\n        IGBATrapsPartial(trapContract).useTrap(msg.sender);\\r\\n\\r\\n        require(_mobIndex < 3,\\\"mobIndex\\\");\\r\\n        bytes32 _mobHash = mobHash;\\r\\n        address mobOwner = getMobOwner(_mobIndex,_mobHash);\\r\\n        require(msg.sender == mobOwner,\\\"owner\\\");\\r\\n\\r\\n        updateMobStart();   //Kill all mobs\\r\\n\\r\\n        bytes32 updateHash  = extractBytes(_mobHash,0);\\r\\n\\r\\n        bytes32[3] memory mobModulo;\\r\\n\\r\\n        for(uint i = 0; i < 3; i++){\\r\\n            mobModulo[i] = extractBytes(_mobHash,i + 1);\\r\\n        }\\r\\n\\r\\n        uint mobTokenId = _getMobTokenId(_mobIndex);                //READ\\r\\n\\r\\n        //Mint real one\\r\\n        _mint(msg.sender,mobTokenId+MOB_OFFSET);\\r\\n\\r\\n        bool mintNewMob = true;\\r\\n        if(mobTokenIds[3] < TOTAL_MOB_COUNT){\\r\\n            mobTokenIds[_mobIndex] =  ++mobTokenIds[3];\\r\\n        }else{\\r\\n            mintNewMob = false;\\r\\n\\r\\n            //if final 3\\r\\n            mobTokenIds[3]++;\\r\\n            mobTokenIds[_mobIndex] = 0;\\r\\n\\r\\n            if(mobTokenIds[3] == TOTAL_MOB_COUNT + 3){\\r\\n                //if final mob, clear last slot to identify end condition\\r\\n                delete mobTokenIds[3];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        mobModulo[_mobIndex] = bytes32(tokens.length);\\r\\n\\r\\n        uint eliminationBlock = block.number - (block.number % 245) - 10;    //READ\\r\\n        bytes32 destinationHash = extractBytes( blockhash(eliminationBlock),4);\\r\\n\\r\\n        mobHash = shiftBytes(updateHash,0) ^                       //WRITE\\r\\n                    shiftBytes(mobModulo[0],1) ^\\r\\n                    shiftBytes(mobModulo[1],2) ^\\r\\n                    shiftBytes(mobModulo[2],3) ^\\r\\n                    shiftBytes(destinationHash,4);\\r\\n\\r\\n        updateMobFinish(); //release mobs\\r\\n    }\\r\\n\\r\\n    /// Mint (internal)\\r\\n    /// @notice Mints real tokens as per ERC721\\r\\n    /// @param _to Address to mint it for\\r\\n    /// @param _tokenId Token to mint\\r\\n    function _mint(address _to,uint _tokenId) internal{\\r\\n        emit Transfer(address(0), _to, _tokenId);\\r\\n\\r\\n        owners[_tokenId] =_to;\\r\\n        balances[_to]++;\\r\\n        tokens.push(_tokenId);\\r\\n    }\\r\\n\\r\\n    /// Is Valid Token (internal)\\r\\n    /// @notice Checks if given tokenId exists (Doesn't apply to mobs)\\r\\n    /// @param _tokenId TokenId to check\\r\\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\\r\\n        return owners[_tokenId] != address(0);\\r\\n    }\\r\\n\\r\\n    /// Require Valid (internal)\\r\\n    /// @notice Reverts if given token doesn't exist\\r\\n    function requireValid(uint _tokenId) internal view{\\r\\n        require(isValidToken(_tokenId),\\\"valid\\\");\\r\\n    }\\r\\n\\r\\n    /// Balance Of\\r\\n    /// @notice ERC721 balanceOf func, includes active mobs\\r\\n    function balanceOf(address _owner) external override view returns (uint256){\\r\\n        uint _balance = balances[_owner];\\r\\n        bytes32 _mobHash = mobHash;\\r\\n        for(uint i = 0; i < 3; i++){\\r\\n            if(getMobOwner(i, _mobHash) == _owner){\\r\\n                _balance++;\\r\\n            }\\r\\n        }\\r\\n        return _balance;\\r\\n    }\\r\\n\\r\\n    /// Owner Of\\r\\n    /// @notice ERC721 ownerOf func, includes active mobs\\r\\n    function ownerOf(uint256 _tokenId) public override view returns(address){\\r\\n        bytes32 _mobHash = mobHash;\\r\\n        for(uint i = 0; i < 3; i++){\\r\\n            if(_getMobTokenId(i) == _tokenId){\\r\\n                address owner = getMobOwner(i,_mobHash);\\r\\n                require(owner != address(0),\\\"invalid\\\");\\r\\n                return owner;\\r\\n            }\\r\\n        }\\r\\n        requireValid(_tokenId);\\r\\n        return owners[_tokenId];\\r\\n    }\\r\\n\\r\\n    /// Approve\\r\\n    /// @notice ERC721 function\\r\\n    function approve(address _approved, uint256 _tokenId)  external override{\\r\\n        address _owner = owners[_tokenId];\\r\\n        require( _owner == msg.sender                    //Require Sender Owns Token\\r\\n            || authorised[_owner][msg.sender]                //  or is approved for all.\\r\\n            ,\\\"permission\\\");\\r\\n        emit Approval(_owner, _approved, _tokenId);\\r\\n        allowance[_tokenId] = _approved;\\r\\n    }\\r\\n\\r\\n    /// Get Approved\\r\\n    /// @notice ERC721 function\\r\\n    function getApproved(uint256 _tokenId) external view override returns (address) {\\r\\n//        require(isValidToken(_tokenId),\\\"invalid\\\");\\r\\n        requireValid(_tokenId);\\r\\n        return allowance[_tokenId];\\r\\n    }\\r\\n\\r\\n    /// Is Approved For All\\r\\n    /// @notice ERC721 function\\r\\n    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\\r\\n        return authorised[_owner][_operator];\\r\\n    }\\r\\n\\r\\n    /// Set Approval For All\\r\\n    /// @notice ERC721 function\\r\\n    function setApprovalForAll(address _operator, bool _approved) external override {\\r\\n        emit ApprovalForAll(msg.sender,_operator, _approved);\\r\\n        authorised[msg.sender][_operator] = _approved;\\r\\n    }\\r\\n\\r\\n    /// Transfer From\\r\\n    /// @notice ERC721 function\\r\\n    /// @dev Fails for mobs\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) public override {\\r\\n        requireValid(_tokenId);\\r\\n\\r\\n        //Check Transferable\\r\\n        //There is a token validity check in ownerOf\\r\\n        address _owner = owners[_tokenId];\\r\\n\\r\\n        require ( _owner == msg.sender             //Require sender owns token\\r\\n            //Doing the two below manually instead of referring to the external methods saves gas\\r\\n            || allowance[_tokenId] == msg.sender      //or is approved for this token\\r\\n            || authorised[_owner][msg.sender]          //or is approved for all\\r\\n        ,\\\"permission\\\");\\r\\n        require(_owner == _from,\\\"owner\\\");\\r\\n        require(_to != address(0),\\\"zero\\\");\\r\\n\\r\\n        updateMobStart();\\r\\n\\r\\n        emit Transfer(_from, _to, _tokenId);\\r\\n\\r\\n        owners[_tokenId] =_to;\\r\\n\\r\\n        balances[_from]--;\\r\\n        balances[_to]++;\\r\\n\\r\\n        //Reset approved if there is one\\r\\n        if(allowance[_tokenId] != address(0)){\\r\\n            delete allowance[_tokenId];\\r\\n        }\\r\\n\\r\\n        updateMobFinish();\\r\\n    }\\r\\n\\r\\n    /// Safe Transfer From\\r\\n    /// @notice ERC721 function\\r\\n    /// @dev Fails for mobs\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public override {\\r\\n        transferFrom(_from, _to, _tokenId);\\r\\n\\r\\n        //Get size of \\\"_to\\\" address, if 0 it's a wallet\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_to)\\r\\n        }\\r\\n        if(size > 0){\\r\\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\\r\\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\")),\\\"receiver\\\");\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /// Safe Transfer From\\r\\n    /// @notice ERC721 function\\r\\n    /// @dev Fails for mobs\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\\r\\n        safeTransferFrom(_from,_to,_tokenId,\\\"\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    /// Name\\r\\n    /// @notice ERC721 Metadata function\\r\\n    /// @return _name Name of token\\r\\n    function name() external pure override returns (string memory _name){\\r\\n        return \\\"Ghostbusters: Afterlife Collectibles\\\";\\r\\n    }\\r\\n\\r\\n    /// Symbol\\r\\n    /// @notice ERC721 Metadata function\\r\\n    /// @return _symbol Symbol of token\\r\\n    function symbol() external pure override returns (string memory _symbol){\\r\\n        return \\\"GBAC\\\";\\r\\n    }\\r\\n\\r\\n    /// Token URI\\r\\n    /// @notice ERC721 Metadata function (includes active mobs)\\r\\n    /// @param _tokenId ID of token to check\\r\\n    /// @return URI (string)\\r\\n    function tokenURI(uint256 _tokenId) public view  override returns (string memory) {\\r\\n        ownerOf(_tokenId); //includes validity check\\r\\n\\r\\n        return string(abi.encodePacked(__uriBase,toString(_tokenId),__uriSuffix));\\r\\n    }\\r\\n\\r\\n    /// To String\\r\\n    /// @notice Converts uint to string\\r\\n    /// @param value uint to convert\\r\\n    /// @return String\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI's implementation - MIT license\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // ENUMERABLE FUNCTIONS (not actually needed for compliance but everyone likes totalSupply)\\r\\n    function totalSupply() public view returns (uint256){\\r\\n        uint highestMob = mobTokenIds[3];\\r\\n        if(!mobReleased || highestMob == 0){\\r\\n            return tokens.length;\\r\\n        }else if(highestMob < TOTAL_MOB_COUNT){\\r\\n            return tokens.length + 3;\\r\\n        }else{\\r\\n            return tokens.length + 3 - (TOTAL_MOB_COUNT - highestMob);\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceID) external override view returns (bool){\\r\\n        return supportedInterfaces[interfaceID];\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\r\\ninterface IERC721 /* is ERC165 */ {\\r\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n    ///  may be created and assigned without emitting Transfer. At the time of\\r\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when the approved address for an NFT is changed or\\r\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\r\\n    ///  When a Transfer event emits, this also indicates that the approved\\r\\n    ///  address for that NFT (if any) is reset to none.\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n    ///  The operator can manage all NFTs of the owner.\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n    /// @notice Count all NFTs assigned to an owner\\r\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n    ///  function throws for queries about the zero address.\\r\\n    /// @param _owner An address for whom to query the balance\\r\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n    /// @notice Find the owner of an NFT\\r\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n    ///  about them do throw.\\r\\n    /// @param _tokenId The identifier for an NFT\\r\\n    /// @return The address of the owner of the NFT\\r\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev This works identically to the other function with an extra data parameter,\\r\\n    ///  except this function just sets data to \\\"\\\".\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n    ///  THEY MAY BE PERMANENTLY LOST\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Change or reaffirm the approved address for an NFT\\r\\n    /// @dev The zero address indicates there is no approved address.\\r\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n    ///  operator of the current owner.\\r\\n    /// @param _approved The new approved NFT controller\\r\\n    /// @param _tokenId The NFT to approve\\r\\n    function approve(address _approved, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n    ///  all of `msg.sender`'s assets\\r\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n    ///  multiple operators per owner.\\r\\n    /// @param _operator Address to add to the set of authorized operators\\r\\n    /// @param _approved True if the operator is approved, false to revoke approval\\r\\n    function setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n    /// @notice Get the approved address for a single NFT\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n    /// @param _tokenId The NFT to find the approved address for\\r\\n    /// @return The approved address for this NFT, or the zero address if there is none\\r\\n    function getApproved(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Query if an address is an authorized operator for another address\\r\\n    /// @param _owner The address that owns the NFTs\\r\\n    /// @param _operator The address that acts on behalf of the owner\\r\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\\r\\ninterface IERC721Enumerable /* is ERC721 */ {\\r\\n    /// @notice Count NFTs tracked by this contract\\r\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\r\\n    ///  them has an assigned and queryable owner not equal to the zero address\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /// @notice Enumerate valid NFTs\\r\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\r\\n    /// @param _index A counter less than `totalSupply()`\\r\\n    /// @return The token identifier for the `_index`th NFT,\\r\\n    ///  (sort order not specified)\\r\\n    function tokenByIndex(uint256 _index) external view returns (uint256);\\r\\n\\r\\n    /// @notice Enumerate NFTs assigned to an owner\\r\\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\r\\n    ///  `_owner` is the zero address, representing invalid NFTs.\\r\\n    /// @param _owner An address where we are interested in NFTs owned by them\\r\\n    /// @param _index A counter less than `balanceOf(_owner)`\\r\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\r\\n    ///   (sort order not specified)\\r\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\r\\ninterface IERC721Metadata /* is ERC721 */ {\\r\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\r\\n    function name() external view returns (string memory _name);\\r\\n\\r\\n    /// @notice An abbreviated name for NFTs in this contract\\r\\n    function symbol() external view returns (string memory _symbol);\\r\\n\\r\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\r\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\r\\n    ///  Metadata JSON Schema\\\".\\r\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\r\\ninterface IERC721TokenReceiver {\\r\\n    /// @notice Handle the receipt of an NFT\\r\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\r\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\r\\n    ///  transfer. Return of other than the magic value MUST result in the\\r\\n    ///  transaction being reverted.\\r\\n    ///  Note: the contract address is always the message sender.\\r\\n    /// @param _operator The address which called `safeTransferFrom` function\\r\\n    /// @param _from The address which previously owned the token\\r\\n    /// @param _tokenId The NFT identifier which is being transferred\\r\\n    /// @param _data Additional data with no specified format\\r\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n    ///  unless throwing\\r\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/IGBATrapsPartial.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @author Andrew Parker\\r\\n/// @title Ghost Busters: Afterlife Traps NFT contract partial interface\\r\\n/// @notice For viewer func, and also for MSP because Traps relies on OpenZepp and MSP uses pure 721 implementation.\\r\\ninterface IGBATrapsPartial{\\r\\n    enum State { Paused, Whitelist, Public, Final}\\r\\n\\r\\n    function useTrap(address owner) external;\\r\\n\\r\\n    function tokensClaimed() external view returns(uint);\\r\\n    function hasMinted(address minter) external view returns(bool);\\r\\n    function saleStarted() external view returns(bool);\\r\\n    function whitelistEndTime() external view returns(uint);\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n    function mintState() external view returns(State);\\r\\n    function countdown() external view returns(uint);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * OpenZeppelin's Ownable, but without Context, because it saves about 500 bytes\\r\\n *   and compiled contract is pushing limits of Spurious Dragon and is unnecessary.\\r\\n\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"onlyOwner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"zero\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/GBAWhitelist.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\n\\r\\n/// @author Andrew Parker\\r\\n/// @title GBA Whitelist NFT Contract\\r\\n/// @notice Implementation of OpenZeppelin MerkleProof contract for GBA MiniStayPuft and Traps NFTs\\r\\ncontract GBAWhitelist{\\r\\n    bytes32 merkleRoot;\\r\\n\\r\\n    /// Constructor\\r\\n    /// @param _merkleRoot root of merkle tree\\r\\n    constructor(bytes32 _merkleRoot){\\r\\n        merkleRoot = _merkleRoot;\\r\\n    }\\r\\n\\r\\n    /// Is Whitelisted\\r\\n    /// @notice Is a given address whitelisted based on proof provided\\r\\n    /// @param proof Merkle proof\\r\\n    /// @param claimer address to check\\r\\n    /// @return Is whitelisted\\r\\n    function isWhitelisted(bytes32[] memory proof, address claimer) public view returns(bool){\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(claimer));\\r\\n        return MerkleProof.verify(proof,merkleRoot,leaf);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uriBase\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uriSuffix\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_trapContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelist\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reservist\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_pauseTime\",\"type\":\"uint256\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reservist\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Reserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mobIndex\",\"type\":\"uint256\"}],\"name\":\"catchMob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reservist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenCount\",\"type\":\"uint256\"},{\"internalType\":\"enum MiniStayPuft.Phase\",\"name\":\"_phase\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"mobMax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disablePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mobIndex\",\"type\":\"uint256\"}],\"name\":\"getMobTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"numTokens\",\"type\":\"uint16\"}],\"name\":\"mintGiveaway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"mintReserveState\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"_whitelistReserveCount\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"blockNumber\",\"type\":\"uint24\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pauseTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_count\",\"type\":\"uint8\"}],\"name\":\"preReserve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseMob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_count\",\"type\":\"uint16\"}],\"name\":\"reserve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uriBase\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uriSuffix\",\"type\":\"string\"}],\"name\":\"updateURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MiniStayPuft","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000009540ea4bc7d8df2ef8ed68110cdbf4171d42af5b0000000000000000000000008d01ddca9613fd28cc7d258e3324f12abbcee440000000000000000000000000000000000000000000000000000000000000000c504c414345484f4c4445522f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c2f504c414345484f4c4445520000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}