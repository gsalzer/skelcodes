{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\n\r\n// SPDX-License-Identifier: CC BY-NC-ND 4.0 International - PPS (Protected Public Source) License\r\n// Legal: https://continuousindex.org/docs#legal\r\n\r\n//----------------------------------------------------------------------------\r\n// Maths Library /////////////////////////////////////////////////////////////\r\n//----------------------------------------------------------------------------\r\n\r\nlibrary safeMath{\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    function usub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if(a <= b){ return 0; }\r\n        else{ return a - b; }\r\n    }    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Security //////////////////////////////////////////////////////\r\n// ----------------------------------------------------------------------------\r\ncontract Master {\r\n    \r\n     //Protect mastering \r\n    ////////////////////////////////////////////   \r\n    address internal      master;\r\n    address public        proctor;\r\n    \r\n    constructor() public {\r\n        master      = msg.sender;\r\n        proctor     = msg.sender;\r\n    }\r\n    modifier mastered {\r\n        require(msg.sender == master);\r\n        _;\r\n    }\r\n    modifier proctored {\r\n        require(msg.sender == proctor || msg.sender == master);\r\n        _;\r\n    }\r\n    function setMaster(address _address)    external mastered { master = _address; } \r\n    function setProctor(address _address)   external mastered { proctor = _address; }\r\n    \r\n    bool public paused = false;\r\n    function setPause(bool b)    external mastered { paused = b; }\r\n \r\n    bool public mintStopped = false;\r\n    function stopMinting(bool p) external mastered { mintStopped = p; }   \r\n}\r\n\r\n\r\n//----------------------------------------------------------------------------\r\n// IERC20 Ethereum OpenZeppelin Interface /////////////////////////////////////////////\r\n//----------------------------------------------------------------------------\r\ninterface IERC20 {\r\n    function totalSupply()                                          external view returns (uint256);\r\n    function balanceOf(address who)                                 external view returns (uint256);\r\n    function transfer(address to, uint256 value)                    external returns (bool);\r\n    function approve(address spender, uint256 value)                external returns (bool);\r\n    function allowance(address owner, address spender)              external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value)  external returns (bool);\r\n    event Transfer( address indexed from, address indexed to,  uint256 value);\r\n    event Approval( address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n//----------------------------------------------------------------------------\r\n// ERC20 Ethereum OpenZeppelin Contract adapted to the Ci's characteristics //\r\n//----------------------------------------------------------------------------\r\ncontract ERC20 is IERC20, Master {\r\n    \r\n     //Libraries using\r\n    ////////////////////////////////////////////   \r\n    using safeMath for uint;\r\n \r\n     //Vars\r\n    //////////////////////////////////////////// \r\n    string  public      version = \"A.1.0\";\r\n    uint256 internal    _totalSupply;\r\n    uint256 internal    _decimals;\r\n    string  internal    _name;\r\n    string  internal    _symbol;\r\n    \r\n     //Data structure\r\n    ////////////////////////////////////////////     \r\n    struct structAccount { uint256 Index; uint256 Balance; uint256 Allowance; uint256 AllowanceDate; address payable AgentWallet;}  \r\n    mapping (address => structAccount) internal AccountsAll; address[] internal AccountsIndexes;\r\n\r\n     //Creation of Coin params\r\n    //////////////////////////////////////////// \r\n    constructor () public {\r\n        _name           = \"Continuous index\";\r\n        _symbol         = \"Ci\";\r\n        _totalSupply    = 0;\r\n        _decimals       = 8; //10 ** 8\r\n        accountSet(0x0000000000000000000000000000000000000000, 0x0000000000000000000000000000000000000000);\r\n    }\r\n    \r\n     //ERC20 additional functions\r\n    //////////////////////////////////////////// \r\n    function name()         public view returns (string memory) {   return _name;  }\r\n    function symbol()       public view returns (string memory) { return _symbol; }\r\n    function decimals()     public view returns (uint256) {     return _decimals;  }\r\n    function totalSupply()  public view returns (uint256) {  return _totalSupply; }\r\n    \r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return AccountsAll[owner].Balance;\r\n    }\r\n    \r\n    function ETHBalanceOf() public view returns (uint){\r\n        return address(this).balance;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256){\r\n        return AccountsAll[owner].Allowance;\r\n    }\r\n    \r\n    function allowanceAndTimeStamp(address owner) public view returns (uint256, uint256){\r\n        return (AccountsAll[owner].Allowance, AccountsAll[owner].AllowanceDate);\r\n    }\r\n    \r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        require (AccountsAll[msg.sender].Balance >= value);\r\n        require (!paused);\r\n        require (to != address(0));\r\n        require (to != msg.sender);\r\n        \r\n        if( AccountsAll[msg.sender].Allowance > AccountsAll[msg.sender].Balance - value){\r\n            AccountsAll[msg.sender].Allowance = AccountsAll[msg.sender].Balance - value;\r\n            if(AccountsAll[msg.sender].Allowance == 0){ AccountsAll[msg.sender].AllowanceDate = 0;}\r\n        }\r\n        AccountsAll[msg.sender].Balance = AccountsAll[msg.sender].Balance.sub(value);\r\n        \r\n        address payable agent;//keep the agent in transfer to new wallets.\r\n        if( !accountExists(to) ) { agent = AccountsAll[msg.sender].AgentWallet; }\r\n        else{ agent = AccountsAll[to].AgentWallet; } //Mantiene el agente\r\n\r\n        accountCheckAdd(to);\r\n        \r\n        AccountsAll[to].Balance     = AccountsAll[to].Balance.add(value);\r\n        AccountsAll[to].AgentWallet = agent;\r\n        \r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(AccountsAll[msg.sender].Balance >= value);\r\n        require(value == 0 || value >= minCiToApprove);\r\n        require(!paused);\r\n        spender = proctor;\r\n        if(value > AccountsAll[msg.sender].Allowance){ AccountsAll[msg.sender].AllowanceDate = block.timestamp;  }\r\n        if(value == 0) { AccountsAll[msg.sender].AllowanceDate = 0; }\r\n        AccountsAll[msg.sender].Allowance = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; \r\n    }\r\n    \r\n    function approveInTheFuture(uint256 value, uint timestamp) external returns (bool) {\r\n        require(AccountsAll[msg.sender].Balance >= value);\r\n        require(value == 0 || value >= minCiToApprove);\r\n        require (!paused);\r\n        require (timestamp >= block.timestamp);\r\n        AccountsAll[msg.sender].AllowanceDate = timestamp;\r\n        if(value == 0) { AccountsAll[msg.sender].AllowanceDate = 0; }\r\n        AccountsAll[msg.sender].Allowance = value;\r\n        emit Approval(msg.sender, proctor, value);\r\n        return true; \r\n    }\r\n    \r\n    function transferFrom( address from, address to, uint256 value) public proctored returns (bool) {\r\n        require(AccountsAll[from].Balance   >= value);\r\n        require(AccountsAll[from].Allowance >= value);\r\n        require(to != address(0));\r\n     \r\n\r\n        AccountsAll[from].Balance   = AccountsAll[from].Balance.sub(value);\r\n        AccountsAll[from].Allowance = AccountsAll[from].Allowance.usub(value); //value always is the wallet allowance\r\n        if(AccountsAll[from].Allowance == 0){  AccountsAll[from].AllowanceDate = 0; } \r\n    \r\n        accountCheckAdd(to);\r\n        AccountsAll[to].Balance     = AccountsAll[to].Balance.add(value);\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n    \r\n    function mint(address to, uint256 value, uint256 _allowance, uint256 allowanceDate, address payable AgentWallet)    internal proctored{\r\n        require(to != address(0));\r\n        accountSet(to, AgentWallet);\r\n         _totalSupply = _totalSupply.add(value);\r\n        AccountsAll[to].Balance = AccountsAll[to].Balance.add(value);\r\n        require(_allowance <= AccountsAll[to].Balance);\r\n        if(_allowance!=0 && allowanceDate!=0){ \r\n            AccountsAll[to].Allowance = _allowance;\r\n            AccountsAll[to].AllowanceDate = allowanceDate;\r\n            emit Approval(to, proctor, _allowance);\r\n        }\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n    \r\n    function burn(uint256 value)                internal{\r\n        require(AccountsAll[msg.sender].Balance >= value);\r\n        _totalSupply = _totalSupply.sub(value);\r\n        AccountsAll[msg.sender].Balance = AccountsAll[msg.sender].Balance.sub(value);\r\n        AccountsAll[msg.sender].Allowance = AccountsAll[msg.sender].Allowance.usub(value);\r\n        if(AccountsAll[msg.sender].Allowance == 0){ AccountsAll[msg.sender].AllowanceDate = 0; }    \r\n        emit Transfer(msg.sender, address(0), value);\r\n    }\r\n    \r\n    function accountExists(address _address)        internal view returns (bool){\r\n        for (uint i=0; i<AccountsIndexes.length; i++) {\r\n            if( AccountsIndexes[i] == _address ){ return true;}\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function accountCheckAdd(address to)            internal{\r\n        if(!accountExists(to)){ \r\n            AccountsIndexes.push( to ); \r\n            AccountsAll[to].Index = AccountsIndexes.length-1;\r\n        }    \r\n    }\r\n    \r\n    function accountSet(address to, address payable AgentWallet) internal proctored{\r\n        accountCheckAdd(to);\r\n        //Protecting the original agent\r\n        if(AccountsAll[to].AgentWallet != AgentWallet && AccountsAll[to].AgentWallet != 0x0000000000000000000000000000000000000000){\r\n            AgentWallet = AccountsAll[to].AgentWallet;\r\n        }\r\n        if(AgentWallet == to) { AgentWallet = 0x0000000000000000000000000000000000000000; }\r\n        AccountsAll[to].AgentWallet = AgentWallet;\r\n    }\r\n    \r\n    function setName    (string memory a)  public proctored { _name     = a; }\r\n    function setSymbol  (string memory a)  public proctored { _symbol   = a; }\r\n\r\n    uint256 public minETHToGet = 1;\r\n    function setMinETHToPay(uint256 a)   external proctored {  minETHToGet = a; }\r\n\r\n    uint256 public minCiToApprove = 1;\r\n    function setMinCiToApprove(uint256 a) external proctored {  minCiToApprove = a; }\r\n}\r\n\r\n\r\n\r\npragma experimental ABIEncoderV2; //Only for statistics purpouses\r\n\r\ncontract CiStatistics is ERC20{\r\n\r\n    struct AA {address a;}\r\n    struct SS {string s;}\r\n    struct UU {uint u;}\r\n    struct TAccounts { uint256 Index; address Wallet; uint256 Balance; uint256 Allowance; uint256 AllowanceDate; address AgentWallet;}  \r\n   \r\n    //----------------------------------------------------------------------------\r\n    // Ci's public functions for statistical purposes only\r\n    //----------------------------------------------------------------------------  \r\n    function getAgentAccounts( address _AgentWallet )   public view returns (TAccounts[] memory){\r\n        uint c = 0;\r\n        for (uint v = 0; v < AccountsIndexes.length; v++) {\r\n            if( AccountsAll[ AccountsIndexes[v] ].AgentWallet == _AgentWallet ){\r\n                c++;\r\n            }\r\n        }        \r\n        uint a = 0;\r\n        TAccounts[] memory _AgentAccounts = new TAccounts[](c);\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].AgentWallet == _AgentWallet ){\r\n                _AgentAccounts[a].Index         = AccountsAll[ AccountsIndexes[i] ].Index;\r\n                _AgentAccounts[a].Wallet        = AccountsIndexes[i];\r\n                _AgentAccounts[a].Balance       = AccountsAll[ AccountsIndexes[i] ].Balance;\r\n                _AgentAccounts[a].Allowance     = AccountsAll[ AccountsIndexes[i] ].Allowance;\r\n                _AgentAccounts[a].AllowanceDate = AccountsAll[ AccountsIndexes[i] ].AllowanceDate;\r\n                _AgentAccounts[a].AgentWallet   = AccountsAll[ AccountsIndexes[i] ].AgentWallet;\r\n                a++;\r\n            }\r\n        }        \r\n        return _AgentAccounts;\r\n    } \r\n\r\n    function getAllAccounts()                           public view returns (TAccounts[] memory){\r\n        uint c = AccountsIndexes.length;\r\n        TAccounts[] memory _AllAccounts = new TAccounts[](c);\r\n        for (uint i = 0; i < c; i++) {\r\n                _AllAccounts[i].Index         = AccountsAll[ AccountsIndexes[i] ].Index;\r\n                _AllAccounts[i].Wallet        = AccountsIndexes[i];\r\n                _AllAccounts[i].Balance       = AccountsAll[ AccountsIndexes[i] ].Balance;\r\n                _AllAccounts[i].Allowance     = AccountsAll[ AccountsIndexes[i] ].Allowance;\r\n                _AllAccounts[i].AllowanceDate = AccountsAll[ AccountsIndexes[i] ].AllowanceDate;\r\n                _AllAccounts[i].AgentWallet   = AccountsAll[ AccountsIndexes[i] ].AgentWallet;\r\n        }        \r\n        return _AllAccounts;\r\n    }  \r\n\r\n    function getAccountByAddress( address _Wallet)      public view returns (TAccounts[] memory){\r\n        TAccounts[] memory _AccountByAddress = new TAccounts[](1);\r\n        _AccountByAddress[0].Index         = AccountsAll[ _Wallet ].Index;\r\n        _AccountByAddress[0].Wallet        = _Wallet;\r\n        _AccountByAddress[0].Balance       = AccountsAll[ _Wallet ].Balance;\r\n        _AccountByAddress[0].Allowance     = AccountsAll[ _Wallet ].Allowance;\r\n        _AccountByAddress[0].AllowanceDate = AccountsAll[ _Wallet ].AllowanceDate;\r\n        _AccountByAddress[0].AgentWallet   = AccountsAll[ _Wallet ].AgentWallet;\r\n        return _AccountByAddress;\r\n    } \r\n\r\n    function getAccountByIndex( uint  i)                public view returns (TAccounts[] memory){\r\n        TAccounts[] memory _AccountByIndex = new TAccounts[](1);\r\n        _AccountByIndex[0].Index         = AccountsAll[ AccountsIndexes[i] ].Index;\r\n        _AccountByIndex[0].Wallet        = AccountsIndexes[i];\r\n        _AccountByIndex[0].Balance       = AccountsAll[ AccountsIndexes[i] ].Balance;\r\n        _AccountByIndex[0].Allowance     = AccountsAll[ AccountsIndexes[i] ].Allowance;\r\n        _AccountByIndex[0].AllowanceDate = AccountsAll[ AccountsIndexes[i] ].AllowanceDate;\r\n        _AccountByIndex[0].AgentWallet   = AccountsAll[ AccountsIndexes[i] ].AgentWallet;\r\n        return _AccountByIndex;\r\n    }    \r\n\r\n    function getAllAllowancersAccounts()                public view returns (TAccounts[] memory){\r\n        uint c = 0;\r\n        for (uint v = 0; v < AccountsIndexes.length; v++) {\r\n            if( AccountsAll[ AccountsIndexes[v] ].Allowance > 0 && AccountsAll[ AccountsIndexes[v] ].AllowanceDate != 0 && AccountsAll[ AccountsIndexes[v] ].AllowanceDate <= block.timestamp ){\r\n                c++;\r\n            }\r\n        } \r\n        uint a = 0;\r\n        TAccounts[] memory _AllAllowancersAccounts = new TAccounts[](c);\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].Allowance > 0 && AccountsAll[ AccountsIndexes[i] ].AllowanceDate != 0 && AccountsAll[ AccountsIndexes[i] ].AllowanceDate <= block.timestamp ){\r\n                _AllAllowancersAccounts[a].Index         = AccountsAll[ AccountsIndexes[i] ].Index;\r\n                _AllAllowancersAccounts[a].Wallet        = AccountsIndexes[i];\r\n                _AllAllowancersAccounts[a].Balance       = AccountsAll[ AccountsIndexes[i] ].Balance;\r\n                _AllAllowancersAccounts[a].Allowance     = AccountsAll[ AccountsIndexes[i] ].Allowance;\r\n                _AllAllowancersAccounts[a].AllowanceDate = AccountsAll[ AccountsIndexes[i] ].AllowanceDate;\r\n                _AllAllowancersAccounts[a].AgentWallet   = AccountsAll[ AccountsIndexes[i] ].AgentWallet;\r\n                a++;\r\n            }\r\n        }        \r\n        return _AllAllowancersAccounts;\r\n    } \r\n}\r\n\r\n//----------------------------------------------------------------------------\r\n// Ci's Protocol Contract functions\r\n//----------------------------------------------------------------------------\r\n\r\ncontract CiProtocol is ERC20, CiStatistics{\r\n\r\n    //*************************************************************************\r\n    //\r\n    // All Ci's protocol activity and data is totally transparent and public. It's watched by the Ci's Proctor Oracle server. \r\n    // Any App, DApp, Ex or DEX can operate it freely because \r\n    //\r\n    // Ci's token price depends on the UNIX Time-stamp of GMT (Greenwich Mean Time) or Coordinated Universal Time or UTC+0. \r\n    // It is shielded and protected against whales, robots or AI manipulation.\r\n    // Anyone can calculate the price of Ci at any moment in time. (see Ci's website DOCS or DAPI for more info)\r\n    \r\n    //\r\n    // Continuousindex.org centralized server and site could disappear, be hacked or censored by a government but \r\n    // the Ethereum Ci's protocol contract can be operate in a fully decentralized manner with Metamask from the public IPFS site via continuousindex.crypto \r\n    // or\r\n    // downloading original Ci-DApp files from the PPS (Protected Public Source) Ci-DApp: https://github.com/ContinuousIndex \r\n    // and operate it decentralized with Metamask from a local host, uploading to IPFS net or Sia-SkyNet or whatever.\r\n    \r\n    //\r\n    // Neither the Ci's contract nor the Ci's website collects personal data of any kind. \r\n    // Ci has no centralized databases of any kind anywhere. // All data (address, balance, etc..) is managed by the smart contract.     \r\n    // For each Ci operation, the hash, price, quantity and time are recorded in the input of blockchain public transaction.\r\n\r\n    \r\n    //\r\n    // Enjoy a new step in finance freedom!\r\n    //\r\n    // Ci - The Continuous Estable Coin protocol - 2021 - https://continuousindex.org -  continuousindex.crypto\r\n    //\r\n    \r\n    //*************************************************************************\r\n    \r\n\t//The Ci TimeStamp Initial Date ///////////////////////////////////////////////////////\r\n    uint public CiInitDate = 1642888930; //Sat Jan 22 2022 22:02:10 GMT+0000 //22:02:10 22/01/2022\t\r\n\r\n\t//Compound Interest of Ci will always be greater if it change ////////////////////////\r\n    uint public CiPercent; \r\n\tfunction setCiPercent(uint256 a)  external proctored {  require( a > CiPercent); CiPercent = a; }\r\n\r\n\r\n    event ProctorCi_event( address indexed Buyer, uint WeiPayed, uint CiPrice, address indexed AgentWallet, string Ci_USD_Price, bytes32 indexed PayHash ); \r\n    bool locked_ProctorCi = false; \r\n    function ProctorCi(address Buyer, uint WeiPayed, uint CiPrice, address payable AgentWallet, string calldata Ci_USD_Price, bytes32 PayHash) external proctored {\r\n        require(!locked_ProctorCi); locked_ProctorCi = true;\r\n        require(CiPrice > 0);\r\n        uint TotalCiToEmit = WeiPayed.div(CiPrice);\r\n        require(WeiPayed >= minETHToGet);\r\n        address payable Seller;\r\n        uint    SellerAllowance;\r\n        uint    emitedToBuyer = 0;\r\n        uint    remainToEmit = TotalCiToEmit;\r\n        while( remainToEmit > 0 ){\r\n            if(getLowerAllowanceDate() != 0){\r\n                Seller = getLowerAllowanceDateAddress();\r\n                SellerAllowance = AccountsAll[ Seller ].Allowance;\r\n                if( SellerAllowance == remainToEmit ){ \r\n                    accountSet(Buyer, AgentWallet);\r\n                    transferFrom(Seller, Buyer, remainToEmit);\r\n                    emitedToBuyer = SellerAllowance;\r\n                    payToSeller(Seller, emitedToBuyer, CiPrice);\r\n                    payToAgent(Buyer, AgentWallet, emitedToBuyer, CiPrice);\r\n                    remainToEmit = 0;\r\n                }\r\n                else if( SellerAllowance > remainToEmit ){\r\n                    accountSet(Buyer, AgentWallet);\r\n                    transferFrom(Seller, Buyer, remainToEmit);\r\n                    emitedToBuyer = remainToEmit; //End\r\n                    payToSeller(Seller, emitedToBuyer, CiPrice);\r\n                    payToAgent(Buyer, AgentWallet, emitedToBuyer, CiPrice);\r\n                    remainToEmit = 0;\r\n                }\r\n                else if( SellerAllowance < remainToEmit ){\r\n                    accountSet(Buyer, AgentWallet);\r\n                    transferFrom(Seller, Buyer, SellerAllowance);\r\n                    emitedToBuyer = SellerAllowance;\r\n                    payToSeller(Seller, emitedToBuyer, CiPrice);\r\n                    payToAgent(Buyer, AgentWallet, emitedToBuyer, CiPrice);\r\n                    remainToEmit = remainToEmit.sub(SellerAllowance);  \r\n                }\r\n            }\r\n            else{\r\n                accountSet(Buyer, AgentWallet);\r\n                mint( Buyer, remainToEmit, 0, 0, 0x0000000000000000000000000000000000000000 );\r\n                payToAgent(Buyer, AgentWallet, remainToEmit, CiPrice);\r\n                remainToEmit = 0;\r\n            }\r\n        }\r\n        locked_ProctorCi = false;\r\n        emit ProctorCi_event(Buyer, WeiPayed, CiPrice, AgentWallet, Ci_USD_Price, PayHash ); \r\n    }\r\n    function payToSeller(address payable Seller, uint CiPayed, uint CiPrice) internal proctored {\r\n        uint WeiToPay = CiPayed.mul(CiPrice);\r\n        uint amountToSeller = (WeiToPay * (10000-AgenFee-CiFee) ) / 10000 ; \r\n        (bool sentToSeller, bytes memory result) = Seller.call.value(amountToSeller)(\"\");\r\n        require(sentToSeller);\r\n    }\r\n    function payToAgent(address Buyer, address payable AgentWallet, uint CiPayed, uint CiPrice) internal proctored {\r\n        uint WeiToPay = CiPayed.mul(CiPrice);\r\n        if(AgentWallet == 0x0000000000000000000000000000000000000000 ){\r\n            AgentWallet = AccountsAll[ Buyer ].AgentWallet;\r\n        }\r\n        if(AgentWallet != 0x0000000000000000000000000000000000000000 ){\r\n            uint amountToAgent  = (WeiToPay * (AgenFee)) / 10000; \r\n            (bool sentToAgent, bytes memory result) = AgentWallet.call.value(amountToAgent)(\"\");\r\n            require(sentToAgent);\r\n        }\r\n    }\r\n    \r\n    event PayForCi_event( address indexed AgentWallet, uint256 value, uint64 native);\r\n    \r\n    function PayForCi(address payable AgentWallet) external payable{ \r\n        require( msg.value >= minETHToGet, \"Not enough transfer amount\" ); \r\n        if(mintStopped){ require( getTotalAllowanced(-1) != 0, \"No Ci for sale now\" ); }\r\n        emit PayForCi_event(AgentWallet, msg.value, 0);\r\n    } \r\n    function () external payable { \r\n        require( msg.value >= minETHToGet, \"Not enough transfer amount\" ); \r\n        if(mintStopped){ require( getTotalAllowanced(-1) != 0, \"No Ci for sale now\" ); }\r\n        emit PayForCi_event(0x0000000000000000000000000000000000000000, msg.value, 1);\r\n    }\r\n\r\n    function ETHFromContract (address payable _address, uint value) external mastered {  _address.transfer(value); }\r\n     //Allow to recover any ERC20 sent into the contract for error\r\n    function TokensFromContract(address tokenAddress, uint256 tokenAmount) external mastered {\r\n        IERC20(tokenAddress).transfer(master, tokenAmount);\r\n    }\r\n    //Ci Settings //Depends on chain GAS prices and markets prices //4.99% Max by contract\r\n    uint64 public AgenFee; \r\n    uint64 public CiFee; \r\n    function setAgentFee(uint64 a, uint64 b) external proctored{ \r\n        require( a + b <= 499);  AgenFee = a; CiFee = b;\r\n    }\r\n    function getFees() public view returns (uint){ return AgenFee + CiFee; /*1 -> 0.01%  //10 -> 0.1%  //100 -> 1% //1000 -> 10% */ }\r\n    //Ci Bridge Functions - Migrate Ci between Ethereum chains\r\n    function migrateFromChain(uint CiToMigrate, uint chainId) external{ \r\n        burn( CiToMigrate ); //only msg.sender can burn\r\n    }\r\n    function migrateToChain(address wallet, uint CiToMigrate, uint allowance, uint allowanceDate, address payable AgentWallet) external proctored { \r\n        mint( wallet, CiToMigrate, allowance, allowanceDate, AgentWallet );\r\n    }\r\n    //Due to the special characteristics of Ci's ERC20 contrac, it is necessary to protect it in case of fraud.\r\n    function AddressBan(address _address) external mastered{\r\n        _totalSupply = _totalSupply - AccountsAll[_address].Balance; AccountsAll[_address].Balance = 0; AccountsAll[_address].Allowance = 0;  AccountsAll[_address].AllowanceDate = 0;\r\n    }\r\n    \r\n    //----------------------------------------------------------------------------\r\n    // Ci's Agent public functions\r\n    //----------------------------------------------------------------------------\r\n    function updateAgentWallet(address payable _newAddress) external{\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].AgentWallet == msg.sender){\r\n                AccountsAll[ AccountsIndexes[i] ].AgentWallet = _newAddress;\r\n            }\r\n        }        \r\n    }\r\n    \r\n    function transferAgentWallet(address payable _newAddress, uint i) external{\r\n        if( AccountsAll[ AccountsIndexes[i] ].AgentWallet == msg.sender){\r\n            AccountsAll[ AccountsIndexes[i] ].AgentWallet = _newAddress;\r\n        }\r\n    }\r\n    \r\n    function assignAgentWallet(address payable _newAddress, uint i) external proctored{\r\n        if( AccountsAll[ AccountsIndexes[i] ].AgentWallet == 0x0000000000000000000000000000000000000000){\r\n            AccountsAll[ AccountsIndexes[i] ].AgentWallet = _newAddress;\r\n        }\r\n    }\r\n    \r\n    function getAgentBalanced( address _AgentWallet)    public  view returns (uint){\r\n        uint total = 0;\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].AgentWallet == _AgentWallet ){\r\n                total += AccountsAll[ AccountsIndexes[i] ].Balance ;\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getAgentAllowed( address _AgentWallet)     public  view returns (uint){\r\n        uint total = 0;\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].AgentWallet == _AgentWallet && AccountsAll[ AccountsIndexes[i] ].AllowanceDate != 0){\r\n                total += AccountsAll[ AccountsIndexes[i] ].Allowance ;\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getLowerAllowanceDateAddress()             public view returns (address payable) {\r\n        uint    lowerAllowDate = block.timestamp;\r\n        uint    Key;\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if(AccountsAll[ AccountsIndexes[i] ].Allowance > 0 && AccountsAll[ AccountsIndexes[i] ].AllowanceDate != 0){\r\n                if( AccountsAll[ AccountsIndexes[i] ].AllowanceDate < lowerAllowDate ){\r\n                    lowerAllowDate = AccountsAll[ AccountsIndexes[i] ].AllowanceDate;\r\n                    Key = i;\r\n                }\r\n            }\r\n        }\r\n        if( Key == 0 ) { return 0x0000000000000000000000000000000000000000; }\r\n        return address(uint160( AccountsIndexes[Key] ) ); //address converted to payable.\r\n    }\r\n    \r\n    function getLowerAllowanceDate()                    public view returns (uint) {\r\n        if(AccountsIndexes.length == 0){ return 0; }\r\n        uint    lowerAllowDate = block.timestamp;\r\n        uint    Key = 0;\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if(AccountsAll[ AccountsIndexes[i] ].AllowanceDate != 0){\r\n                if( AccountsAll[ AccountsIndexes[i] ].AllowanceDate <= lowerAllowDate ){\r\n                    lowerAllowDate = AccountsAll[ AccountsIndexes[i] ].AllowanceDate;\r\n                    Key = i;\r\n                }\r\n            }\r\n        }\r\n        return AccountsAll[ AccountsIndexes[Key] ].AllowanceDate;\r\n    }\r\n\r\n    function getTotalValue()                            public view returns (uint) {\r\n        uint total = 0;\r\n        for (uint i=0; i < AccountsIndexes.length; i++) {\r\n            total += AccountsAll[AccountsIndexes[i]].Balance;\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getTimestamp()                             public view returns (uint) { \r\n        return (block.timestamp);\r\n    } \r\n    \r\n    function getTotalAccounts()                         public view returns (uint) {\r\n        return AccountsIndexes.length;\r\n    }\r\n    \r\n    function getBiggestWalletValue()                    public view returns (address,uint) {\r\n        uint    biggestValue = 0;\r\n        uint    Key = 0;\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].Balance >= biggestValue ){\r\n                biggestValue = AccountsAll[ AccountsIndexes[i] ].Balance;\r\n                Key = i;\r\n            }\r\n        }\r\n        return (AccountsIndexes[Key], AccountsAll[ AccountsIndexes[Key] ].Balance);\r\n    }    \r\n\r\n    function getAccountIndex(address _address)          public view returns (uint) {\r\n        return AccountsAll[_address].Index;\r\n    }\r\n    \r\n    function getAccountBalance(address _address)        public view returns (uint) {\r\n        return AccountsAll[_address].Balance;\r\n    }\r\n    \r\n    function getAccountAllowance(address _address)      public view returns (uint) {\r\n        return AccountsAll[_address].Allowance;\r\n    }\r\n    \r\n    function getAccountAllowanceDate(address _address)  public view returns (uint) {\r\n        return AccountsAll[_address].AllowanceDate;\r\n    }\r\n    \r\n    function getAccountAgentWallet(address _address)    public view returns (address) {\r\n        return AccountsAll[_address].AgentWallet;\r\n    }\r\n    \r\n    function getTotalAllowanced(int8 range)             public view returns (uint) {\r\n        uint    nowTime = block.timestamp;\r\n        uint    totalAllowanced = 0;\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].Allowance > 0 && AccountsAll[ AccountsIndexes[i] ].AllowanceDate != 0 ){\r\n                if(range == 0 )     { totalAllowanced += AccountsAll[ AccountsIndexes[i] ].Allowance;}\r\n                if(range == -1 )    { if( AccountsAll[ AccountsIndexes[i] ].AllowanceDate <= nowTime ){ totalAllowanced += AccountsAll[ AccountsIndexes[i] ].Allowance; } }\r\n                if(range == 1 )     { if( AccountsAll[ AccountsIndexes[i] ].AllowanceDate > nowTime ) { totalAllowanced += AccountsAll[ AccountsIndexes[i] ].Allowance;  } }                \r\n            }\r\n        }\r\n        return totalAllowanced;\r\n    }\r\n    \r\n    function getTotalAllowancers(int8 range)           public view returns (uint) { //all //past //future\r\n        uint    nowTime = block.timestamp;\r\n        uint    totalAllowancers = 0;\r\n        for (uint i = 0; i < AccountsIndexes.length; i++) {\r\n            if( AccountsAll[ AccountsIndexes[i] ].Allowance > 0 && AccountsAll[ AccountsIndexes[i] ].AllowanceDate != 0 ){\r\n                if(range == 0 )     { totalAllowancers ++; }\r\n                if(range == -1 )    { if( AccountsAll[ AccountsIndexes[i] ].AllowanceDate <= nowTime ){ totalAllowancers ++; } }\r\n                if(range == 1 )     { if( AccountsAll[ AccountsIndexes[i] ].AllowanceDate > nowTime ) { totalAllowancers ++;  } }\r\n            }\r\n        }\r\n        return totalAllowancers;\r\n    }\r\n    \r\n}//End CiProtocol Contract","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"AgentWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"native\",\"type\":\"uint64\"}],\"name\":\"PayForCi_event\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"WeiPayed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"CiPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"AgentWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"Ci_USD_Price\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"PayHash\",\"type\":\"bytes32\"}],\"name\":\"ProctorCi_event\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddressBan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AgenFee\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CiFee\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CiInitDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CiPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ETHFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"AgentWallet\",\"type\":\"address\"}],\"name\":\"PayForCi\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"Buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"WeiPayed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CiPrice\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"AgentWallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"Ci_USD_Price\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"PayHash\",\"type\":\"bytes32\"}],\"name\":\"ProctorCi\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"allowanceAndTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"approveInTheFuture\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"assignAgentWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccountAgentWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccountAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccountAllowanceDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Wallet\",\"type\":\"address\"}],\"name\":\"getAccountByAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AllowanceDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"AgentWallet\",\"type\":\"address\"}],\"internalType\":\"struct CiStatistics.TAccounts[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getAccountByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AllowanceDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"AgentWallet\",\"type\":\"address\"}],\"internalType\":\"struct CiStatistics.TAccounts[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccountIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_AgentWallet\",\"type\":\"address\"}],\"name\":\"getAgentAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AllowanceDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"AgentWallet\",\"type\":\"address\"}],\"internalType\":\"struct CiStatistics.TAccounts[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_AgentWallet\",\"type\":\"address\"}],\"name\":\"getAgentAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_AgentWallet\",\"type\":\"address\"}],\"name\":\"getAgentBalanced\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AllowanceDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"AgentWallet\",\"type\":\"address\"}],\"internalType\":\"struct CiStatistics.TAccounts[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllAllowancersAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AllowanceDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"AgentWallet\",\"type\":\"address\"}],\"internalType\":\"struct CiStatistics.TAccounts[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBiggestWalletValue\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLowerAllowanceDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLowerAllowanceDateAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"int8\",\"name\":\"range\",\"type\":\"int8\"}],\"name\":\"getTotalAllowanced\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"int8\",\"name\":\"range\",\"type\":\"int8\"}],\"name\":\"getTotalAllowancers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"CiToMigrate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"migrateFromChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"CiToMigrate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowanceDate\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"AgentWallet\",\"type\":\"address\"}],\"name\":\"migrateToChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCiToApprove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minETHToGet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintStopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proctor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"a\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"b\",\"type\":\"uint64\"}],\"name\":\"setAgentFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"setCiPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"setMinCiToApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"setMinETHToPay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setProctor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"p\",\"type\":\"bool\"}],\"name\":\"stopMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"transferAgentWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateAgentWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CiProtocol","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://16e2e658ff364066cfa931abbc11f3fc1b76a38328a6e4c505606e0b631204bf"}]}