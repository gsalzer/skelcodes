{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/access/AddressesProviderRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../tools/SafeOwnable.sol';\\nimport '../interfaces/IAddressesProviderRegistry.sol';\\nimport '../tools/Errors.sol';\\n\\n/**\\n * @title AddressesProviderRegistry contract\\n * @dev Main registry of AddressesProvider of multiple protocol's markets\\n * - Used for indexing purposes of protocol's markets\\n * - The id assigned to an AddressesProvider refers to the market it is connected with,\\n *   for example with `1` for the first market, `2` for the next one, etc\\n **/\\ncontract AddressesProviderRegistry is SafeOwnable, IAddressesProviderRegistry {\\n  struct Entry {\\n    uint256 id;\\n    uint16 index;\\n  }\\n  mapping(address => Entry) private _index;\\n  address[] private _providers;\\n\\n  address private _oneTimeRegistrar;\\n  uint256 private _oneTimeId;\\n\\n  function setOneTimeRegistrar(address registrar, uint256 expectedId) external override onlyOwner {\\n    _oneTimeId = expectedId;\\n    _oneTimeRegistrar = registrar;\\n  }\\n\\n  function renounceOneTimeRegistrar() external override {\\n    if (_oneTimeRegistrar == msg.sender) {\\n      _oneTimeRegistrar = address(0);\\n    }\\n  }\\n\\n  function getOneTimeRegistrar() external view override returns (address user, uint256 expectedId) {\\n    if (_oneTimeRegistrar == address(0)) {\\n      return (address(0), 0);\\n    }\\n    return (_oneTimeRegistrar, _oneTimeId);\\n  }\\n\\n  /**\\n   * @dev Returns the list of registered addresses provider\\n   * @return activeProviders - list of addresses provider, potentially containing address(0) elements\\n   **/\\n  function getAddressesProvidersList() external view override returns (address[] memory activeProviders) {\\n    return _providers;\\n  }\\n\\n  function prepareAddressesProvider(address provider) external override {\\n    require(msg.sender == _oneTimeRegistrar || msg.sender == owner(), Errors.TXT_OWNABLE_CALLER_NOT_OWNER);\\n    require(provider != address(0) && _index[provider].index == 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\\n    emit AddressesProviderPreparing(provider);\\n  }\\n\\n  /**\\n   * @dev Registers an addresses provider\\n   * @param provider The address of the new AddressesProvider\\n   * @param id The id for the new AddressesProvider, referring to the market it belongs to\\n   **/\\n  function registerAddressesProvider(address provider, uint256 id) external override {\\n    if (msg.sender == _oneTimeRegistrar) {\\n      require(_oneTimeId == 0 || _oneTimeId == id, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\\n      _oneTimeRegistrar = address(0);\\n    } else {\\n      require(msg.sender == owner(), Errors.TXT_OWNABLE_CALLER_NOT_OWNER);\\n      require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\\n    }\\n\\n    require(provider != address(0), Errors.LPAPR_PROVIDER_NOT_REGISTERED);\\n\\n    if (_index[provider].index > 0) {\\n      _index[provider].id = id;\\n    } else {\\n      require(_providers.length < type(uint16).max);\\n      _providers.push(provider);\\n      _index[provider] = Entry(id, uint16(_providers.length));\\n    }\\n\\n    emit AddressesProviderRegistered(provider);\\n  }\\n\\n  /**\\n   * @dev Removes a AddressesProvider from the list of registered addresses provider\\n   * @param provider The AddressesProvider address\\n   **/\\n  function unregisterAddressesProvider(address provider) external override onlyOwner {\\n    uint256 idx = _index[provider].index;\\n    require(idx != 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\\n\\n    delete (_index[provider]);\\n    if (idx == _providers.length) {\\n      _providers.pop();\\n    } else {\\n      _providers[idx - 1] = address(0);\\n    }\\n    for (; _providers.length > 0 && _providers[_providers.length - 1] == address(0); ) {\\n      _providers.pop();\\n    }\\n\\n    emit AddressesProviderUnregistered(provider);\\n  }\\n\\n  /**\\n   * @dev Returns the id on a registered AddressesProvider\\n   * @return The id or 0 if the AddressesProvider is not registered\\n   */\\n  function getAddressesProviderIdByAddress(address provider) external view override returns (uint256) {\\n    return _index[provider].id;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * Ownership is transferred in 2 phases: current owner calls {transferOwnership}\\n * then the new owner calls {acceptOwnership}.\\n * The last owner can recover ownership with {recoverOwnership} before {acceptOwnership} is called by the new owner.\\n *\\n * When ownership transfer was initiated, this module behaves like there is no owner, until\\n * either acceptOwnership() or recoverOwnership() is called.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract SafeOwnable {\\n  address private _lastOwner;\\n  address private _activeOwner;\\n  address private _pendingOwner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n  event OwnershipTransferring(address indexed previousOwner, address indexed pendingOwner);\\n\\n  /// @dev Initializes the contract setting the deployer as the initial owner.\\n  constructor() {\\n    _activeOwner = msg.sender;\\n    _pendingOwner = msg.sender;\\n    emit OwnershipTransferred(address(0), msg.sender);\\n  }\\n\\n  /// @dev Returns active owner\\n  function owner() public view returns (address) {\\n    return _activeOwner;\\n  }\\n\\n  function owners()\\n    public\\n    view\\n    returns (\\n      address lastOwner,\\n      address activeOwner,\\n      address pendingOwner\\n    )\\n  {\\n    return (_lastOwner, _activeOwner, _pendingOwner);\\n  }\\n\\n  /// @dev Reverts if called by any account other than the owner.\\n  /// Will also revert after transferOwnership() when neither acceptOwnership() nor recoverOwnership() was called.\\n  modifier onlyOwner() {\\n    require(\\n      _activeOwner == msg.sender,\\n      _pendingOwner == msg.sender ? 'Ownable: caller is not the owner (pending)' : 'Ownable: caller is not the owner'\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() external onlyOwner {\\n    emit OwnershipTransferred(_activeOwner, address(0));\\n    _activeOwner = address(0);\\n    _pendingOwner = address(0);\\n    _lastOwner = address(0);\\n  }\\n\\n  /// @dev Initiates ownership transfer of the contract to a new account `newOwner`.\\n  /// Can only be called by the current owner. The new owner must call acceptOwnership() to get the ownership.\\n  function transferOwnership(address newOwner) external onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferring(msg.sender, newOwner);\\n    _pendingOwner = newOwner;\\n    _lastOwner = _activeOwner;\\n    _activeOwner = address(0);\\n  }\\n\\n  /// @dev Accepts ownership of this contract. Can only be called by the new owner set with transferOwnership().\\n  function acceptOwnership() external {\\n    require(_activeOwner == address(0) && _pendingOwner == msg.sender, 'SafeOwnable: caller is not the pending owner');\\n\\n    emit OwnershipTransferred(_lastOwner, msg.sender);\\n    _lastOwner = address(0);\\n    _activeOwner = msg.sender;\\n  }\\n\\n  /// @dev Recovers ownership of this contract to the last owner after transferOwnership(),\\n  /// unless acceptOwnership() was already called by the new owner.\\n  function recoverOwnership() external {\\n    require(_activeOwner == address(0) && _lastOwner == msg.sender, 'SafeOwnable: caller can not recover ownership');\\n    emit OwnershipTransferring(msg.sender, address(0));\\n    emit OwnershipTransferred(msg.sender, msg.sender);\\n    _pendingOwner = msg.sender;\\n    _lastOwner = address(0);\\n    _activeOwner = msg.sender;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressesProviderRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IAddressesProviderRegistry {\\n  event AddressesProviderPreparing(address indexed newAddress);\\n  event AddressesProviderRegistered(address indexed newAddress);\\n  event AddressesProviderUnregistered(address indexed newAddress);\\n\\n  function getAddressesProvidersList() external view returns (address[] memory);\\n\\n  function getAddressesProviderIdByAddress(address) external view returns (uint256);\\n\\n  function prepareAddressesProvider(address provider) external;\\n\\n  function registerAddressesProvider(address provider, uint256 id) external;\\n\\n  function unregisterAddressesProvider(address provider) external;\\n\\n  function setOneTimeRegistrar(address user, uint256 expectedId) external;\\n\\n  function getOneTimeRegistrar() external view returns (address user, uint256 expectedId);\\n\\n  function renounceOneTimeRegistrar() external;\\n}\\n\"\r\n    },\r\n    \"contracts/tools/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Errors library\\n * @notice Defines the error messages emitted by the different contracts\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - MATH = Math libraries\\n *  - CT = Common errors between tokens (DepositToken, VariableDebtToken and StableDebtToken)\\n *  - AT = DepositToken\\n *  - SDT = StableDebtToken\\n *  - VDT = VariableDebtToken\\n *  - LP = LendingPool\\n *  - LPAPR = AddressesProviderRegistry\\n *  - LPC = LendingPoolConfiguration\\n *  - RL = ReserveLogic\\n *  - LPCM = LendingPoolExtension\\n *  - ST = Stake\\n */\\nlibrary Errors {\\n  //contract specific errors\\n  string public constant VL_INVALID_AMOUNT = '1'; // Amount must be greater than 0\\n  string public constant VL_NO_ACTIVE_RESERVE = '2'; // Action requires an active reserve\\n  string public constant VL_RESERVE_FROZEN = '3'; // Action cannot be performed because the reserve is frozen\\n  string public constant VL_UNKNOWN_RESERVE = '4'; // Action requires an active reserve\\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // User cannot withdraw more than the available balance (above min limit)\\n  string public constant VL_TRANSFER_NOT_ALLOWED = '6'; // Transfer cannot be allowed.\\n  string public constant VL_BORROWING_NOT_ENABLED = '7'; // Borrowing is not enabled\\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // Invalid interest rate mode selected\\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // The collateral balance is 0\\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // Health factor is lesser than the liquidation threshold\\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // There is not enough collateral to cover a new borrow\\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\\n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\\n  string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // The requested amount is exceeds max size of a stable loan\\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // to repay a debt, user needs to specify a correct debt type (variable or stable)\\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // To repay on behalf of an user an explicit amount to repay is needed\\n  string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // User does not have a stable rate loan in progress on this reserve\\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // User does not have a variable rate loan in progress on this reserve\\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // The collateral balance needs to be greater than 0\\n  string public constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // User deposit is already being used as collateral\\n  string public constant VL_RESERVE_MUST_BE_COLLATERAL = '21'; // This reserve must be enabled as collateral\\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // Interest rate rebalance conditions were not met\\n  string public constant AT_OVERDRAFT_DISABLED = '23'; // User doesn't accept allocation of overdraft\\n  string public constant VL_INVALID_SUB_BALANCE_ARGS = '24';\\n  string public constant AT_INVALID_SLASH_DESTINATION = '25';\\n\\n  string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // The caller of the function is not the lending pool configurator\\n\\n  string public constant LENDING_POOL_REQUIRED = '28'; // The caller of this function must be a lending pool\\n  string public constant CALLER_NOT_LENDING_POOL = '29'; // The caller of this function must be a lending pool\\n  string public constant AT_SUB_BALANCE_RESTIRCTED_FUNCTION = '30'; // The caller of this function must be a lending pool or a sub-balance operator\\n\\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // Reserve has already been initialized\\n  string public constant CALLER_NOT_POOL_ADMIN = '33'; // The caller must be the pool admin\\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // The liquidity of the reserve needs to be 0\\n\\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // Provider is not registered\\n  string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // Health factor is not below the threshold\\n  string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // The collateral chosen cannot be liquidated\\n  string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // User did not borrow the specified currency\\n  string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // There isn't enough liquidity available to liquidate\\n\\n  string public constant MATH_MULTIPLICATION_OVERFLOW = '48';\\n  string public constant MATH_ADDITION_OVERFLOW = '49';\\n  string public constant MATH_DIVISION_BY_ZERO = '50';\\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\\n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\\n  string public constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\\n  string public constant CALLER_NOT_STAKE_ADMIN = '57';\\n  string public constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\\n  string public constant CALLER_NOT_LIQUIDITY_CONTROLLER = '60';\\n  string public constant CALLER_NOT_REF_ADMIN = '61';\\n  string public constant VL_INSUFFICIENT_REWARD_AVAILABLE = '62';\\n  string public constant LP_CALLER_MUST_BE_DEPOSIT_TOKEN = '63';\\n  string public constant LP_IS_PAUSED = '64'; // Pool is paused\\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = '65';\\n  string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\\n  string public constant RC_INVALID_LTV = '67';\\n  string public constant RC_INVALID_LIQ_THRESHOLD = '68';\\n  string public constant RC_INVALID_LIQ_BONUS = '69';\\n  string public constant RC_INVALID_DECIMALS = '70';\\n  string public constant RC_INVALID_RESERVE_FACTOR = '71';\\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\\n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\\n  string public constant VL_TREASURY_REQUIRED = '74';\\n  string public constant LPC_INVALID_CONFIGURATION = '75'; // Invalid risk parameters for the reserve\\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '76'; // The caller must be the emergency admin\\n  string public constant UL_INVALID_INDEX = '77';\\n  string public constant VL_CONTRACT_REQUIRED = '78';\\n  string public constant SDT_STABLE_DEBT_OVERFLOW = '79';\\n  string public constant SDT_BURN_EXCEEDS_BALANCE = '80';\\n  string public constant CALLER_NOT_REWARD_CONFIG_ADMIN = '81'; // The caller of this function must be a reward admin\\n  string public constant LP_INVALID_PERCENTAGE = '82'; // Percentage can't be more than 100%\\n  string public constant LP_IS_NOT_TRUSTED_FLASHLOAN = '83';\\n  string public constant CALLER_NOT_SWEEP_ADMIN = '84';\\n  string public constant LP_TOO_MANY_NESTED_CALLS = '85';\\n  string public constant LP_RESTRICTED_FEATURE = '86';\\n  string public constant LP_TOO_MANY_FLASHLOAN_CALLS = '87';\\n  string public constant RW_BASELINE_EXCEEDED = '88';\\n  string public constant CALLER_NOT_REWARD_RATE_ADMIN = '89';\\n  string public constant CALLER_NOT_REWARD_CONTROLLER = '90';\\n  string public constant RW_REWARD_PAUSED = '91';\\n  string public constant CALLER_NOT_TEAM_MANAGER = '92';\\n  string public constant STK_REDEEM_PAUSED = '93';\\n  string public constant STK_INSUFFICIENT_COOLDOWN = '94';\\n  string public constant STK_UNSTAKE_WINDOW_FINISHED = '95';\\n  string public constant STK_INVALID_BALANCE_ON_COOLDOWN = '96';\\n  string public constant STK_EXCESSIVE_SLASH_PCT = '97';\\n  string public constant STK_WRONG_COOLDOWN_OR_UNSTAKE = '98';\\n  string public constant STK_PAUSED = '99';\\n\\n  string public constant TXT_OWNABLE_CALLER_NOT_OWNER = 'Ownable: caller is not the owner';\\n  string public constant TXT_CALLER_NOT_PROXY_OWNER = 'ProxyOwner: caller is not the owner';\\n  string public constant TXT_ACCESS_RESTRICTED = 'RESTRICTED';\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressesProviderPreparing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressesProviderRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressesProviderUnregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferring\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getAddressesProviderIdByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressesProvidersList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"activeProviders\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOneTimeRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expectedId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lastOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"activeOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"prepareAddressesProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"registerAddressesProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOneTimeRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expectedId\",\"type\":\"uint256\"}],\"name\":\"setOneTimeRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"unregisterAddressesProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AddressesProviderRegistry","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}