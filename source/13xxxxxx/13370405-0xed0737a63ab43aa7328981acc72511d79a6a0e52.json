{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/KernelFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IKernel.sol\\\";\\nimport \\\"../libraries/LibKernelStorage.sol\\\";\\nimport \\\"../libraries/LibOwnership.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract KernelFacet {\\n    using SafeMath for uint256;\\n\\n    uint256 constant public MAX_LOCK = 365 days;\\n    uint256 constant BASE_MULTIPLIER = 1e18;\\n\\n    event Deposit(address indexed user, uint256 amount, uint256 newBalance);\\n    event Withdraw(address indexed user, uint256 amountWithdrew, uint256 amountLeft);\\n    event Lock(address indexed user, uint256 timestamp);\\n    event Delegate(address indexed from, address indexed to);\\n    event DelegatedPowerIncreased(address indexed from, address indexed to, uint256 amount, uint256 to_newDelegatedPower);\\n    event DelegatedPowerDecreased(address indexed from, address indexed to, uint256 amount, uint256 to_newDelegatedPower);\\n\\n    function initKernel(address _leag, address _rewards) public {\\n        require(_leag != address(0), \\\"LEAG address must not be 0x0\\\");\\n\\n        LibKernelStorage.Storage storage ds = LibKernelStorage.kernelStorage();\\n\\n        require(!ds.initialized, \\\"Kernel: already initialized\\\");\\n        LibOwnership.enforceIsContractOwner();\\n\\n        ds.initialized = true;\\n\\n        ds.leag = IERC20(_leag);\\n        ds.rewards = IRewards(_rewards);\\n    }\\n\\n    // deposit allows a user to add more leag to his staked balance\\n    function deposit(uint256 amount) public {\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n       LibKernelStorage.Storage storage ds = LibKernelStorage.kernelStorage();\\n        uint256 allowance = ds.leag.allowance(msg.sender, address(this));\\n        require(allowance >= amount, \\\"Token allowance too small\\\");\\n\\n        // this must be called before the user's balance is updated so the rewards contract can calculate\\n        // the amount owed correctly\\n        if (address(ds.rewards) != address(0)) {\\n            ds.rewards.registerUserAction(msg.sender);\\n        }\\n\\n        uint256 newBalance = balanceOf(msg.sender).add(amount);\\n        _updateUserBalance(ds.userStakeHistory[msg.sender], newBalance);\\n        _updateLockedLeag(leagStakedAtTs(block.timestamp).add(amount));\\n\\n        address delegatedTo = userDelegatedTo(msg.sender);\\n        if (delegatedTo != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(delegatedTo).add(amount);\\n            _updateDelegatedPower(ds.delegatedPowerHistory[delegatedTo], newDelegatedPower);\\n\\n            emit DelegatedPowerIncreased(msg.sender, delegatedTo, amount, newDelegatedPower);\\n        }\\n        ds.leag.transferFrom(msg.sender, address(this), amount);\\n\\n        emit Deposit(msg.sender, amount, newBalance);\\n    }\\n\\n    // withdraw allows a user to withdraw funds if the balance is not locked\\n    function withdraw(uint256 amount) public {\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(userLockedUntil(msg.sender) <= block.timestamp, \\\"User balance is locked\\\");\\n\\n        uint256 balance = balanceOf(msg.sender);\\n        require(balance >= amount, \\\"Insufficient balance\\\");\\n\\n        LibKernelStorage.Storage storage ds = LibKernelStorage.kernelStorage();\\n\\n        // this must be called before the user's balance is updated so the rewards contract can calculate\\n        // the amount owed correctly\\n        if (address(ds.rewards) != address(0)) {\\n            ds.rewards.registerUserAction(msg.sender);\\n        }\\n\\n        _updateUserBalance(ds.userStakeHistory[msg.sender], balance.sub(amount));\\n        _updateLockedLeag(leagStakedAtTs(block.timestamp).sub(amount));\\n\\n        address delegatedTo = userDelegatedTo(msg.sender);\\n        if (delegatedTo != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(delegatedTo).sub(amount);\\n            _updateDelegatedPower(ds.delegatedPowerHistory[delegatedTo], newDelegatedPower);\\n\\n            emit DelegatedPowerDecreased(msg.sender, delegatedTo, amount, newDelegatedPower);\\n        }\\n\\n        ds.leag.transfer(msg.sender, amount);\\n\\n        emit Withdraw(msg.sender, amount, balance.sub(amount));\\n    }\\n\\n    // lock a user's currently staked balance until timestamp & add the bonus to his voting power\\n    function lock(uint256 timestamp) public {\\n        require(timestamp > block.timestamp, \\\"Timestamp must be in the future\\\");\\n        require(timestamp <= block.timestamp + MAX_LOCK, \\\"Timestamp too big\\\");\\n        require(balanceOf(msg.sender) > 0, \\\"Sender has no balance\\\");\\n\\n        LibKernelStorage.Storage storage ds = LibKernelStorage.kernelStorage();\\n        LibKernelStorage.Stake[] storage checkpoints = ds.userStakeHistory[msg.sender];\\n        LibKernelStorage.Stake storage currentStake = checkpoints[checkpoints.length - 1];\\n\\n        require(timestamp > currentStake.expiryTimestamp, \\\"New timestamp lower than current lock timestamp\\\");\\n\\n        _updateUserLock(checkpoints, timestamp);\\n\\n        emit Lock(msg.sender, timestamp);\\n    }\\n\\n    function depositAndLock(uint256 amount, uint256 timestamp) public {\\n        deposit(amount);\\n        lock(timestamp);\\n    }\\n\\n    // delegate allows a user to delegate his voting power to another user\\n    function delegate(address to) public {\\n        require(msg.sender != to, \\\"Can't delegate to self\\\");\\n\\n        uint256 senderBalance = balanceOf(msg.sender);\\n        require(senderBalance > 0, \\\"No balance to delegate\\\");\\n\\n        LibKernelStorage.Storage storage ds = LibKernelStorage.kernelStorage();\\n\\n        emit Delegate(msg.sender, to);\\n\\n        address delegatedTo = userDelegatedTo(msg.sender);\\n        if (delegatedTo != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(delegatedTo).sub(senderBalance);\\n            _updateDelegatedPower(ds.delegatedPowerHistory[delegatedTo], newDelegatedPower);\\n\\n            emit DelegatedPowerDecreased(msg.sender, delegatedTo, senderBalance, newDelegatedPower);\\n        }\\n\\n        if (to != address(0)) {\\n            uint256 newDelegatedPower = delegatedPower(to).add(senderBalance);\\n            _updateDelegatedPower(ds.delegatedPowerHistory[to], newDelegatedPower);\\n\\n            emit DelegatedPowerIncreased(msg.sender, to, senderBalance, newDelegatedPower);\\n        }\\n\\n        _updateUserDelegatedTo(ds.userStakeHistory[msg.sender], to);\\n    }\\n\\n    // stopDelegate allows a user to take back the delegated voting power\\n    function stopDelegate() public {\\n        return delegate(address(0));\\n    }\\n\\n    // balanceOf returns the current LEAG balance of a user (bonus not included)\\n    function balanceOf(address user) public view returns (uint256) {\\n        return balanceAtTs(user, block.timestamp);\\n    }\\n\\n    // balanceAtTs returns the amount of LEAG that the user currently staked (bonus NOT included)\\n    function balanceAtTs(address user, uint256 timestamp) public view returns (uint256) {\\n        LibKernelStorage.Stake memory stake = stakeAtTs(user, timestamp);\\n\\n        return stake.amount;\\n    }\\n\\n    // stakeAtTs returns the Stake object of the user that was valid at `timestamp`\\n    function stakeAtTs(address user, uint256 timestamp) public view returns (LibKernelStorage.Stake memory) {\\n        LibKernelStorage.Storage storage ds = LibKernelStorage.kernelStorage();\\n        LibKernelStorage.Stake[] storage stakeHistory = ds.userStakeHistory[user];\\n\\n        if (stakeHistory.length == 0 || timestamp < stakeHistory[0].timestamp) {\\n            return LibKernelStorage.Stake(block.timestamp, 0, block.timestamp, address(0));\\n        }\\n\\n        uint256 min = 0;\\n        uint256 max = stakeHistory.length - 1;\\n\\n        if (timestamp >= stakeHistory[max].timestamp) {\\n            return stakeHistory[max];\\n        }\\n\\n        // binary search of the value in the array\\n        while (max > min) {\\n            uint256 mid = (max + min + 1) / 2;\\n            if (stakeHistory[mid].timestamp <= timestamp) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        return stakeHistory[min];\\n    }\\n\\n    // votingPower returns the voting power (bonus included) + delegated voting power for a user at the current block\\n    function votingPower(address user) public view returns (uint256) {\\n        return votingPowerAtTs(user, block.timestamp);\\n    }\\n\\n    // votingPowerAtTs returns the voting power (bonus included) + delegated voting power for a user at a point in time\\n    function votingPowerAtTs(address user, uint256 timestamp) public view returns (uint256) {\\n        LibKernelStorage.Stake memory stake = stakeAtTs(user, timestamp);\\n\\n        uint256 ownVotingPower;\\n\\n        // if the user delegated his voting power to another user, then he doesn't have any voting power left\\n        if (stake.delegatedTo != address(0)) {\\n            ownVotingPower = 0;\\n        } else {\\n            uint256 balance = stake.amount;\\n            uint256 multiplier = _stakeMultiplier(stake, timestamp);\\n            ownVotingPower = balance.mul(multiplier).div(BASE_MULTIPLIER);\\n        }\\n\\n        uint256 delegatedVotingPower = delegatedPowerAtTs(user, timestamp);\\n\\n        return ownVotingPower.add(delegatedVotingPower);\\n    }\\n\\n    // leagStaked returns the total raw amount of LEAG staked at the current block\\n    function leagStaked() public view returns (uint256) {\\n        return leagStakedAtTs(block.timestamp);\\n    }\\n\\n    // leagStakedAtTs returns the total raw amount of LEAG users have deposited into the contract\\n    // it does not include any bonus\\n    function leagStakedAtTs(uint256 timestamp) public view returns (uint256) {\\n        return _checkpointsBinarySearch(LibKernelStorage.kernelStorage().leagStakedHistory, timestamp);\\n    }\\n\\n    // delegatedPower returns the total voting power that a user received from other users\\n    function delegatedPower(address user) public view returns (uint256) {\\n        return delegatedPowerAtTs(user, block.timestamp);\\n    }\\n\\n    // delegatedPowerAtTs returns the total voting power that a user received from other users at a point in time\\n    function delegatedPowerAtTs(address user, uint256 timestamp) public view returns (uint256) {\\n        return _checkpointsBinarySearch(LibKernelStorage.kernelStorage().delegatedPowerHistory[user], timestamp);\\n    }\\n\\n    // same as multiplierAtTs but for the current block timestamp\\n    function multiplierOf(address user) public view returns (uint256) {\\n        return multiplierAtTs(user, block.timestamp);\\n    }\\n\\n    // multiplierAtTs calculates the multiplier at a given timestamp based on the user's stake a the given timestamp\\n    // it includes the decay mechanism\\n    function multiplierAtTs(address user, uint256 timestamp) public view returns (uint256) {\\n        LibKernelStorage.Stake memory stake = stakeAtTs(user, timestamp);\\n\\n        return _stakeMultiplier(stake, timestamp);\\n    }\\n\\n    // userLockedUntil returns the timestamp until the user's balance is locked\\n    function userLockedUntil(address user) public view returns (uint256) {\\n        LibKernelStorage.Stake memory c = stakeAtTs(user, block.timestamp);\\n\\n        return c.expiryTimestamp;\\n    }\\n\\n    // userDelegatedTo returns the address to which a user delegated their voting power; address(0) if not delegated\\n    function userDelegatedTo(address user) public view returns (address) {\\n        LibKernelStorage.Stake memory c = stakeAtTs(user, block.timestamp);\\n\\n        return c.delegatedTo;\\n    }\\n\\n    // _checkpointsBinarySearch executes a binary search on a list of checkpoints that's sorted chronologically\\n    // looking for the closest checkpoint that matches the specified timestamp\\n    function _checkpointsBinarySearch(LibKernelStorage.Checkpoint[] storage checkpoints, uint256 timestamp) internal view returns (uint256) {\\n        if (checkpoints.length == 0 || timestamp < checkpoints[0].timestamp) {\\n            return 0;\\n        }\\n\\n        uint256 min = 0;\\n        uint256 max = checkpoints.length - 1;\\n\\n        if (timestamp >= checkpoints[max].timestamp) {\\n            return checkpoints[max].amount;\\n        }\\n\\n        // binary search of the value in the array\\n        while (max > min) {\\n            uint256 mid = (max + min + 1) / 2;\\n            if (checkpoints[mid].timestamp <= timestamp) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        return checkpoints[min].amount;\\n    }\\n\\n    // _stakeMultiplier calculates the multiplier for the given stake at the given timestamp\\n    function _stakeMultiplier(LibKernelStorage.Stake memory stake, uint256 timestamp) internal view returns (uint256) {\\n        if (timestamp >= stake.expiryTimestamp) {\\n            return BASE_MULTIPLIER;\\n        }\\n\\n        uint256 diff = stake.expiryTimestamp - timestamp;\\n        if (diff >= MAX_LOCK) {\\n            return BASE_MULTIPLIER.mul(2);\\n        }\\n\\n        return BASE_MULTIPLIER.add(diff.mul(BASE_MULTIPLIER).div(MAX_LOCK));\\n    }\\n\\n    // _updateUserBalance manages an array of checkpoints\\n    // if there's already a checkpoint for the same timestamp, the amount is updated\\n    // otherwise, a new checkpoint is inserted\\n    function _updateUserBalance(LibKernelStorage.Stake[] storage checkpoints, uint256 amount) internal {\\n        if (checkpoints.length == 0) {\\n            checkpoints.push(LibKernelStorage.Stake(block.timestamp, amount, block.timestamp, address(0)));\\n        } else {\\n            LibKernelStorage.Stake storage old = checkpoints[checkpoints.length - 1];\\n\\n            if (old.timestamp == block.timestamp) {\\n                old.amount = amount;\\n            } else {\\n                checkpoints.push(LibKernelStorage.Stake(block.timestamp, amount, old.expiryTimestamp, old.delegatedTo));\\n            }\\n        }\\n    }\\n\\n    // _updateUserLock updates the expiry timestamp on the user's stake\\n    // it assumes that if the user already has a balance, which is checked for in the lock function\\n    // then there must be at least 1 checkpoint\\n    function _updateUserLock(LibKernelStorage.Stake[] storage checkpoints, uint256 expiryTimestamp) internal {\\n        LibKernelStorage.Stake storage old = checkpoints[checkpoints.length - 1];\\n\\n        if (old.timestamp < block.timestamp) {\\n            checkpoints.push(LibKernelStorage.Stake(block.timestamp, old.amount, expiryTimestamp, old.delegatedTo));\\n        } else {\\n            old.expiryTimestamp = expiryTimestamp;\\n        }\\n    }\\n\\n    // _updateUserDelegatedTo updates the delegateTo property on the user's stake\\n    // it assumes that if the user already has a balance, which is checked for in the delegate function\\n    // then there must be at least 1 checkpoint\\n    function _updateUserDelegatedTo(LibKernelStorage.Stake[] storage checkpoints, address to) internal {\\n        LibKernelStorage.Stake storage old = checkpoints[checkpoints.length - 1];\\n\\n        if (old.timestamp < block.timestamp) {\\n            checkpoints.push(LibKernelStorage.Stake(block.timestamp, old.amount, old.expiryTimestamp, to));\\n        } else {\\n            old.delegatedTo = to;\\n        }\\n    }\\n\\n    // _updateDelegatedPower updates the power delegated TO the user in the checkpoints history\\n    function _updateDelegatedPower(LibKernelStorage.Checkpoint[] storage checkpoints, uint256 amount) internal {\\n        if (checkpoints.length == 0 || checkpoints[checkpoints.length - 1].timestamp < block.timestamp) {\\n            checkpoints.push(LibKernelStorage.Checkpoint(block.timestamp, amount));\\n        } else {\\n            LibKernelStorage.Checkpoint storage old = checkpoints[checkpoints.length - 1];\\n            old.amount = amount;\\n        }\\n    }\\n\\n    // _updateLockedLeag stores the new `amount` into the LEAG locked history\\n    function _updateLockedLeag(uint256 amount) internal {\\n        LibKernelStorage.Storage storage ds = LibKernelStorage.kernelStorage();\\n\\n        if (ds.leagStakedHistory.length == 0 || ds.leagStakedHistory[ds.leagStakedHistory.length - 1].timestamp < block.timestamp) {\\n            ds.leagStakedHistory.push(LibKernelStorage.Checkpoint(block.timestamp, amount));\\n        } else {\\n            LibKernelStorage.Checkpoint storage old = ds.leagStakedHistory[ds.leagStakedHistory.length - 1];\\n            old.amount = amount;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/LibKernelStorage.sol\\\";\\n\\ninterface IKernel {\\n    // deposit allows a user to add more leag to his staked balance\\n    function deposit(uint256 amount) external;\\n\\n    // withdraw allows a user to withdraw funds if the balance is not locked\\n    function withdraw(uint256 amount) external;\\n\\n    // lock a user's currently staked balance until timestamp & add the bonus to his voting power\\n    function lock(uint256 timestamp) external;\\n\\n    // delegate allows a user to delegate his voting power to another user\\n    function delegate(address to) external;\\n\\n    // stopDelegate allows a user to take back the delegated voting power\\n    function stopDelegate() external;\\n\\n    // lock the balance of a proposal creator until the voting ends; only callable by DAO\\n    function lockCreatorBalance(address user, uint256 timestamp) external;\\n\\n    // balanceOf returns the current LEAG balance of a user (bonus not included)\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    // balanceAtTs returns the amount of LEAG that the user currently staked (bonus NOT included)\\n    function balanceAtTs(address user, uint256 timestamp) external view returns (uint256);\\n\\n    // stakeAtTs returns the Stake object of the user that was valid at `timestamp`\\n    function stakeAtTs(address user, uint256 timestamp) external view returns (LibKernelStorage.Stake memory);\\n\\n    // votingPower returns the voting power (bonus included) + delegated voting power for a user at the current block\\n    function votingPower(address user) external view returns (uint256);\\n\\n    // votingPowerAtTs returns the voting power (bonus included) + delegated voting power for a user at a point in time\\n    function votingPowerAtTs(address user, uint256 timestamp) external view returns (uint256);\\n\\n    // leagStaked returns the total raw amount of LEAG staked at the current block\\n    function leagStaked() external view returns (uint256);\\n\\n    // leagStakedAtTs returns the total raw amount of LEAG users have deposited into the contract\\n    // it does not include any bonus\\n    function leagStakedAtTs(uint256 timestamp) external view returns (uint256);\\n\\n    // delegatedPower returns the total voting power that a user received from other users\\n    function delegatedPower(address user) external view returns (uint256);\\n\\n    // delegatedPowerAtTs returns the total voting power that a user received from other users at a point in time\\n    function delegatedPowerAtTs(address user, uint256 timestamp) external view returns (uint256);\\n\\n    // multiplierAtTs calculates the multiplier at a given timestamp based on the user's stake a the given timestamp\\n    // it includes the decay mechanism\\n    function multiplierAtTs(address user, uint256 timestamp) external view returns (uint256);\\n\\n    // userLockedUntil returns the timestamp until the user's balance is locked\\n    function userLockedUntil(address user) external view returns (uint256);\\n\\n    // userDidDelegate returns the address to which a user delegated their voting power; address(0) if not delegated\\n    function userDelegatedTo(address user) external view returns (address);\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibKernelStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IRewards.sol\\\";\\n\\nlibrary LibKernelStorage {\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"com.enterdao.kernel.storage\\\");\\n\\n    struct Checkpoint {\\n        uint256 timestamp;\\n        uint256 amount;\\n    }\\n\\n    struct Stake {\\n        uint256 timestamp;\\n        uint256 amount;\\n        uint256 expiryTimestamp;\\n        address delegatedTo;\\n    }\\n\\n    struct Storage {\\n        bool initialized;\\n\\n        // mapping of user address to history of Stake objects\\n        // every user action creates a new object in the history\\n        mapping(address => Stake[]) userStakeHistory;\\n\\n        // array of leag staked Checkpoint\\n        // deposits/withdrawals create a new object in the history (max one per block)\\n        Checkpoint[] leagStakedHistory;\\n\\n        // mapping of user address to history of delegated power\\n        // every delegate/stopDelegate call create a new checkpoint (max one per block)\\n        mapping(address => Checkpoint[]) delegatedPowerHistory;\\n\\n        IERC20 leag;\\n        IRewards rewards;\\n    }\\n\\n    function kernelStorage() internal pure returns (Storage storage ds) {\\n        bytes32 position = STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibOwnership.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibDiamondStorage.sol\\\";\\n\\nlibrary LibOwnership {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n\\n        address previousOwner = ds.contractOwner;\\n        require(previousOwner != _newOwner, \\\"Previous owner and new owner must be different\\\");\\n\\n        ds.contractOwner = _newOwner;\\n\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = LibDiamondStorage.diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() view internal {\\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \\\"Must be contract owner\\\");\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \\\"Must be contract owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IRewards {\\n    function registerUserAction(address user) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamondStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct Facet {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        // function selector => facet address and selector position in selectors array\\n        mapping(bytes4 => Facet) facets;\\n        bytes4[] selectors;\\n\\n        // ERC165\\n        mapping(bytes4 => bool) supportedInterfaces;\\n\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to_newDelegatedPower\",\"type\":\"uint256\"}],\"name\":\"DelegatedPowerDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to_newDelegatedPower\",\"type\":\"uint256\"}],\"name\":\"DelegatedPowerIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLeft\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"balanceAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"delegatedPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"delegatedPowerAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"depositAndLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leag\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"}],\"name\":\"initKernel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leagStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"leagStakedAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"multiplierAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"multiplierOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"stakeAtTs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegatedTo\",\"type\":\"address\"}],\"internalType\":\"struct LibKernelStorage.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userDelegatedTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userLockedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"votingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"votingPowerAtTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KernelFacet","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"9999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}