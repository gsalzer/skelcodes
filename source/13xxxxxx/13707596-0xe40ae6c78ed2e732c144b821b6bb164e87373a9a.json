{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface ISmartSwap {\r\n    function isSystem(address caller) external returns(bool);   // check if caller is system wallet.\r\n    function decimals(address token) external returns(uint256);   // token address => token decimals\r\n    function processingFee() external returns(uint256); // Processing fee\r\n    function companySPFee() external returns(uint256); // Company fee for SP\r\n    function reimburse(address user, uint256 amount) external; // reimburse user for SP payment\r\n    function swap(\r\n        address tokenA,\r\n        address tokenB, \r\n        address receiver,\r\n        uint256 amountA,\r\n        address licensee,\r\n        bool isInvestment,\r\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\r\n        uint128 limitPice,   // Do not match user if token A price less this limit\r\n        uint256 fee          // company + licensee fee amount\r\n    )\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function cancel(\r\n        address tokenA,\r\n        address tokenB, \r\n        address receiver,\r\n        uint256 amountA    //amount of tokenA to cancel\r\n    )\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function claimTokenBehalf(\r\n        address tokenA, // foreignToken\r\n        address tokenB, // nativeToken\r\n        address sender,\r\n        address receiver,\r\n        bool isInvestment,\r\n        uint128 amountA,    //amount of tokenA that has to be swapped\r\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\r\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\r\n    )   \r\n        external\r\n        returns (bool);\r\n}\r\n\r\ncontract SPImplementation{\r\n    struct Tokens {\r\n        address nativeToken;\r\n        address foreignToken;\r\n        uint8 nativeDecimals;\r\n        uint8 foreignDecimals;        \r\n    }\r\n    Tokens public tokensData;\r\n    address public nativeTokenReceiver;\r\n    address public foreignTokenReceiver;\r\n    address public owner;\r\n\r\n    ISmartSwap public smartSwap; // assign SmartSwap address here\r\n    uint256 private feeAmountLimit; // limit of amount that System withdraw for fee reimbursement\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event FeeTransfer(address indexed systemWallet, uint256 fee);\r\n    event Deposit(uint256 value);\r\n\r\n    // run only once from proxy\r\n    function initialize(\r\n        address _owner,     // contract owner\r\n        address _nativeToken, // native token that will be send to SmartSwap\r\n        address _foreignToken, // foreign token that has to be received from SmartSwap (on foreign chain)\r\n        address _nativeTokenReceiver, // address on Binance to deposit native token\r\n        address _foreignTokenReceiver, // address on Binance to deposit foreign token\r\n        uint256 _feeAmountLimit // limit of amount that System may withdraw for fee reimbursement\r\n    )\r\n        external\r\n    {\r\n        require(owner == address(0)); // run only once\r\n        require(\r\n            _nativeToken != address(0)\r\n            && _foreignToken != address(0)\r\n            && _nativeTokenReceiver != address(0)\r\n            && _foreignTokenReceiver != address(0)\r\n        );\r\n        tokensData.nativeToken = _nativeToken;\r\n        tokensData.foreignToken = _foreignToken;\r\n        nativeTokenReceiver = _nativeTokenReceiver;\r\n        foreignTokenReceiver = _foreignTokenReceiver;\r\n        feeAmountLimit = _feeAmountLimit;\r\n        smartSwap = ISmartSwap(msg.sender);\r\n        tokensData.nativeDecimals = uint8(smartSwap.decimals(tokensData.nativeToken));\r\n        tokensData.foreignDecimals = uint8(smartSwap.decimals(tokensData.foreignToken));\r\n        owner = _owner;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Deposit(msg.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the system.\r\n    */\r\n    modifier onlySystem() {\r\n        require(smartSwap.isSystem(msg.sender), \"Caller is not the system\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    // set limit of amount that System withdraw for fee reimbursement\r\n    function setFeeAmountLimit(uint256 amount) external onlyOwner {\r\n        feeAmountLimit = amount;\r\n    }\r\n\r\n    // get limit of amount that System withdraw for fee reimbursement\r\n    function getFeeAmountLimit() external view returns(uint256) {\r\n        return feeAmountLimit;\r\n    }\r\n\r\n    function cancel(uint256 amount) external onlySystem {\r\n        smartSwap.cancel(tokensData.nativeToken, tokensData.foreignToken, foreignTokenReceiver, amount);\r\n    }\r\n\r\n    // Allow owner withdraw tokens from contract\r\n    function withdraw(address token, uint256 amount) external onlyOwner {\r\n        if (token < address(9))\r\n            safeTransferETH(msg.sender, amount);\r\n        else\r\n            safeTransfer(token, msg.sender, amount);\r\n    }\r\n\r\n\r\n\r\n    // add liquidity to counterparty \r\n    function addLiquidityAndClaimBehalf(\r\n        uint256 feeAmount,   // processing fee amount to reimburse system wallet.\r\n        uint128 amount,    //amount of native token that has to be swapped (amount of provided liquidity)\r\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\r\n        uint128[] memory claimAmount, // claim amount (in foreign tokens).\r\n        uint256[] memory foreignBalance,  // total tokens amount sent by user to pair on other chain\r\n        address[] memory senderCounterparty, // correspondent value from SwapRequest event\r\n        address[] memory receiverCounterparty,    // correspondent value from SwapRequest event\r\n        uint256[] memory reimbursement   // amount of reimbursement to user in native coin (BNB, ETH)\r\n    ) \r\n        external \r\n        onlySystem \r\n    {\r\n        require(feeAmountLimit >= feeAmount, \"Fee limit exceeded\");\r\n\r\n        feeAmountLimit -= feeAmount;\r\n        Tokens memory t = tokensData;\r\n        require(claimAmount.length == foreignBalance.length &&\r\n            senderCounterparty.length == receiverCounterparty.length &&\r\n            foreignBalance.length == senderCounterparty.length &&\r\n            foreignBalance.length == reimbursement.length, \r\n            \"Wrong length\"\r\n        );\r\n        // send swap request\r\n        swap(t, amount, feeAmount);\r\n        // claim tokens on users behalf\r\n        claimBehalf(t, currentRate, claimAmount, foreignBalance, senderCounterparty, receiverCounterparty);\r\n        // send reimbursement to users\r\n        for (uint256 i = 0; i < reimbursement.length; i++) {\r\n            if (reimbursement[i] != 0) {\r\n                smartSwap.reimburse(receiverCounterparty[i], reimbursement[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimBehalf(\r\n        Tokens memory t, \r\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\r\n        uint128[] memory claimAmount, // claim amount (in foreign tokens).\r\n        uint256[] memory foreignBalance,  // total tokens amount sent by user to pair on other chain\r\n        address[] memory senderCounterparty, // correspondent value from SwapRequest event\r\n        address[] memory receiverCounterparty    // correspondent value from SwapRequest event\r\n    ) \r\n        internal \r\n    {\r\n        uint256 totalAmount;\r\n        for (uint256 i = 0; i < claimAmount.length; i++) {\r\n            totalAmount += claimAmount[i];\r\n            smartSwap.claimTokenBehalf(\r\n                t.foreignToken,\r\n                t.nativeToken,\r\n                senderCounterparty[i],\r\n                receiverCounterparty[i],\r\n                false,\r\n                claimAmount[i],\r\n                currentRate, \r\n                foreignBalance[i]\r\n            );\r\n        }\r\n        //require(totalAmount * currentRate / (10**(18+t.foreignDecimals-t.nativeDecimals)) <= uint256(amount), \"Insuficiant amount\");\r\n    }\r\n\r\n    function swap(Tokens memory t, uint128 amount, uint256 feeAmount) internal {\r\n        uint256 processingFee = smartSwap.processingFee();\r\n        if (t.nativeToken > address(9)) {\r\n            // can't get company fee amount\r\n            IERC20(t.nativeToken).approve(address(smartSwap), uint256(amount));\r\n            smartSwap.swap{value: processingFee}(\r\n                t.nativeToken, \r\n                t.foreignToken,\r\n                foreignTokenReceiver, \r\n                amount, \r\n                address(0),\r\n                false, \r\n                0,\r\n                0,\r\n                0\r\n            );            \r\n        } else {    // native coin (ETH, BNB)\r\n            uint256 fee = uint256(amount)*smartSwap.companySPFee()/10000;  // company fee\r\n            processingFee = fee + processingFee;\r\n            smartSwap.swap{value: uint256(amount) + processingFee}(\r\n                t.nativeToken, \r\n                t.foreignToken,\r\n                foreignTokenReceiver, \r\n                amount, \r\n                address(0),\r\n                false, \r\n                0,\r\n                0,\r\n                fee\r\n            );\r\n        }\r\n        require(processingFee <= feeAmount, \"Insuficiant fee\");\r\n        feeAmount -= processingFee; // we already paid processing fee to SmartSwap contract\r\n        if (feeAmount != 0) {\r\n            payable(msg.sender).transfer(feeAmount);\r\n            smartSwap.reimburse(owner, feeAmount);\r\n            emit FeeTransfer(msg.sender, feeAmount);\r\n        }        \r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'ETH_TRANSFER_FAILED');\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"systemWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128[]\",\"name\":\"claimAmount\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"foreignBalance\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"senderCounterparty\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"receiverCounterparty\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"reimbursement\",\"type\":\"uint256[]\"}],\"name\":\"addLiquidityAndClaimBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreignTokenReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_foreignToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_foreignTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmountLimit\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeTokenReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setFeeAmountLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartSwap\",\"outputs\":[{\"internalType\":\"contract ISmartSwap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nativeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"foreignToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"nativeDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"foreignDecimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SPImplementation","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://177e6673126e5b69440aeff50f0cc97fd36575b001df146c257bc79264e1eff1"}]}