{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/OfficialBuffDoge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./utils/IUniswapV2Factory.sol\\\";\\nimport \\\"./utils/IUniswapV2Pair.sol\\\";\\nimport \\\"./utils/IUniswapV2Router02.sol\\\";\\nimport \\\"./utils/IERC20.sol\\\";\\nimport \\\"./utils/TimeLock.sol\\\";\\n\\n/**\\n * @notice ERC20 token with cost basis tracking and restricted loss-taking\\n */\\ncontract OfficialBuffDoge is IERC20, TimeLock {\\n\\n    address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n\\n    mapping (address => uint256) private _rOwned;\\n    mapping (address => uint256) private _tOwned;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    mapping(address => uint256) private _basisOf;\\n    mapping(address => uint256) public cooldownOf;\\n    mapping (address => bool) private _isAllowedTransfer;\\n    mapping (address => bool) private _isExcluded;\\n    mapping (address => bool) private _blackList;\\n\\n    address[] private _excluded;\\n\\n    string  private _NAME;\\n    string  private _SYMBOL;\\n    uint256 private _DECIMALS;\\n   \\n    uint256 private constant _MAX = ~uint256(0);\\n    uint256 private constant _GRANULARITY = 100;\\n    uint256 private constant _maxTeamMintAmount = 1e8 ether;\\n   \\n    uint256 private _tTotal;\\n    uint256 private _rTotal;\\n    \\n    uint256 private _tFeeTotal;\\n    uint256 private _tBurnTotal;\\n    uint256 private _tMarketingFeeTotal;\\n\\n    uint256 public    _TAX_FEE; // 3%\\n    uint256 public   _BURN_FEE; // 3%\\n    uint256 public _MARKET_FEE; // 3%\\n\\n    // Track original fees to bypass fees for charity account\\n    uint256 private mintedSupply;\\n\\n\\n    address private _shoppingCart;\\n    address private _rewardWallet;\\n    address private _pair;\\n    address private _owner;\\n\\n    bool private _paused;\\n    bool private _isEnableSwapTokenforEth;\\n\\n    struct Minting {\\n        address recipient;\\n        uint amount;\\n    }\\n\\n    struct StandardFees {\\n        uint taxFee;\\n        uint rewardFee;\\n        uint marketFee;\\n        uint taxPenaltyFee;\\n        uint rewardPenaltyFee;\\n        uint marketPenaltyFee;\\n    }\\n    StandardFees private _standardFees;\\n\\n    mapping(address => address) private _referralOwner;\\n    mapping(address => uint256) private _referralOwnerTotalFee;\\n\\n    constructor (string memory _name, string memory _symbol, uint256 _decimals, uint256 _supply, address _oldBuff, address[] memory blackList, address[] memory exchangeList) {\\n        _owner = msg.sender;\\n        _NAME = _name;\\n        _SYMBOL = _symbol;\\n        _DECIMALS = _decimals;\\n        _tTotal =_supply * (10 ** uint256(_DECIMALS));\\n        _rTotal = (_MAX - (_MAX % _tTotal));\\n\\n        // setup uniswap pair and store address\\n        _pair = IUniswapV2Factory(IUniswapV2Router02(UNISWAP_ROUTER).factory())\\n            .createPair(IUniswapV2Router02(UNISWAP_ROUTER).WETH(), address(this));\\n        _rOwned[address(this)] = _rTotal;\\n        _excludeAccount(msg.sender);\\n        _excludeAccount(address(this));\\n        _excludeAccount(_pair);\\n        _excludeAccount(UNISWAP_ROUTER);\\n\\n        // prepare to add liquidity\\n        _approve(address(this), _owner, _rTotal);\\n\\n        _paused = true;\\n        _isEnableSwapTokenforEth = false;\\n\\n        if (blackList.length > 0) {\\n            for(uint k = 0; k < blackList.length; k++) {\\n                _blackList[blackList[k]] = true;\\n            }\\n        }\\n\\n        for(uint k = 0; k < exchangeList.length; k++) {\\n            uint balances = IERC20(_oldBuff).balanceOf(exchangeList[k]);\\n            if(balances > 0) {\\n                _transfer(address(this), exchangeList[k], balances);\\n            }\\n        }\\n\\n        _transfer(address(this), msg.sender, 40 * 1e7 ether);\\n    }\\n\\n    modifier isNotPaused() {\\n        require(_paused == false, \\\"ERR: paused already\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function name() external view returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return _SYMBOL;\\n    }\\n\\n    function decimals() external view returns (uint256) {\\n        return _DECIMALS;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcluded[account]) return _tOwned[account];\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\\n        return true;\\n    }\\n\\n    function isExcluded(address account) external view returns (bool) {\\n        return _isExcluded[account];\\n    }\\n    \\n    function totalFees() external view returns (uint256) {\\n        return _tFeeTotal;\\n    }\\n    \\n    function totalBurn() external view returns (uint256) {\\n        return _tBurnTotal;\\n    }\\n    \\n    function totalMarketingFees() external view returns (uint256) {\\n        return _tMarketingFeeTotal;\\n    }\\n\\n    function checkReferralReward(address referralOwner) external view returns (uint256) {\\n        return _referralOwnerTotalFee[referralOwner];\\n    }\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount,,,,,,) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        return rAmount / _getRate();\\n    }\\n\\n    function excludeAccount(address account) external onlyOwner {\\n        _excludeAccount(account);\\n    }\\n\\n    function _excludeAccount(address account) private {\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\n        if(_rOwned[account] > 0) {\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\n        }\\n        _isExcluded[account] = true;\\n        _excluded.push(account);\\n        _isAllowedTransfer[account] = true;\\n        excludeFromLock(account);\\n    }\\n\\n    function includeAccount(address account) external onlyOwner {\\n        require(_isExcluded[account], \\\"Account is already included\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _tOwned[account] = 0;\\n                _isExcluded[account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"TOKEN20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"TOKEN20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function basisOf(address account) public view returns (uint256) {\\n        uint256 basis = _basisOf[account];\\n        if (basis == 0 && balanceOf(account) > 0) {\\n            basis = 0;\\n        }\\n        return basis;\\n    }\\n\\n    function setBusinessWallet(address businessAddress) external onlyOwner isNotPaused returns (bool) {\\n        require(businessAddress != address(0), \\\"ERR: zero address\\\");\\n        _shoppingCart = businessAddress;\\n        uint256 cartAmount = 5e7 ether;\\n        _removeFee();\\n        _transferFromExcluded(address(this), businessAddress, cartAmount);\\n        _restoreAllFee();\\n        _excludeAccount(businessAddress);\\n        return true;\\n    }\\n\\n    function setRewardAddress(address rewardAddress) external onlyOwner isNotPaused returns (bool) {\\n        require(rewardAddress != address(0), \\\"ERR: zero address\\\");\\n        _rewardWallet = rewardAddress;\\n        uint256 burnAmount = 35 * 1e7 ether;\\n        _removeFee();\\n        _transferFromExcluded(address(this), rewardAddress, burnAmount);\\n        _restoreAllFee();\\n        _excludeAccount(rewardAddress);\\n        return true;\\n    }\\n\\n    function setReferralOwner(address referralUser, address referralOwner) external returns (bool) {\\n        require(_referralOwner[referralUser] == address(0), \\\"ERR: address registered already\\\");\\n        require(referralUser != address(0), \\\"ERR: zero address\\\");\\n        require(referralOwner != address(0), \\\"ERR: zero address\\\");\\n        _referralOwner[referralUser] = referralOwner;\\n        return true;\\n    }\\n\\n    function setStandardFee(StandardFees memory _standardFee) external onlyOwner isNotPaused returns (bool) {\\n        require (_standardFee.taxFee < 100 && _standardFee.rewardFee < 100 && _standardFee.marketFee < 100, \\\"ERR: Fee is so high\\\");\\n        require (\\n            _standardFee.taxPenaltyFee < 100 && _standardFee.rewardPenaltyFee < 100 &&\\n            _standardFee.marketPenaltyFee < 100, \\\"ERR: Fee is so high\\\");\\n        _standardFees = _standardFee;\\n        return true;\\n    }\\n\\n    function addBlackList(address blackAddress) external onlyOwner returns (bool) {\\n        require(blackAddress != _owner);\\n        require(!_blackList[blackAddress]);\\n        _blackList[blackAddress] = true;\\n        return true;\\n    }\\n\\n    function removeBlackList(address removeAddress) external onlyOwner returns (bool) {\\n        require(_blackList[removeAddress]);\\n        require(removeAddress != _owner);\\n        _blackList[removeAddress] = false;\\n        return true;\\n    }\\n   \\n    function mintDev(Minting[] calldata mintings) external onlyOwner returns (bool) {\\n        require(mintings.length > 0, \\\"ERR: zero address array\\\");\\n        _removeFee();       \\n        for(uint i = 0; i < mintings.length; i++) {\\n            Minting memory m = mintings[i];\\n            require(mintedSupply + m.amount <= _maxTeamMintAmount, \\\"ERR: exceed max team mint amount\\\");\\n            _transferFromExcluded(address(this), m.recipient, m.amount);\\n            mintedSupply += m.amount;\\n            lockAddress(m.recipient, uint64(180 days));\\n        }        \\n        _restoreAllFee();\\n        return true;\\n    }    \\n\\n    function pausedEnable() external onlyOwner returns (bool) {\\n        require(!_paused, \\\"ERR: already pause enabled\\\");\\n        _paused = true;\\n        return true;\\n    }\\n\\n    function pausedNotEnable() external onlyOwner returns (bool) {\\n        require(_paused, \\\"ERR: already pause disabled\\\");\\n        _paused = false;\\n        return true;\\n    }\\n\\n    function swapTokenForEthEnable() external onlyOwner isNotPaused returns (bool) {\\n        require(!_isEnableSwapTokenforEth, \\\"ERR: already enabled\\\");\\n        _isEnableSwapTokenforEth = true;\\n        return true;\\n    }\\n\\n    function swapTokenForEthDisable() external onlyOwner isNotPaused returns (bool) {\\n        require(_isEnableSwapTokenforEth, \\\"ERR: already disabled\\\");\\n        _isEnableSwapTokenforEth = false;\\n        return true;\\n    }\\n\\n    function checkReferralOwner(address referralUser) external view returns (address) {\\n        require(referralUser != address(0), \\\"ERR: zero address\\\");\\n        return _referralOwner[referralUser];\\n    }\\n\\n    function checkedTimeLock(address user) external view returns (bool) {\\n        return !isUnLocked(user);\\n    }\\n\\n    function checkAllowedTransfer(address user) external view returns (bool) {\\n        return _isAllowedTransfer[user];\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        require(!_blackList[from] && !_blackList[to]);\\n        // ignore minting and burning\\n        if (from == address(0) || to == address(0)) return;\\n        // ignore add/remove liquidity\\n        if (from == address(this) || to == address(this)) return;\\n        if (from == _owner || to == _owner) return;\\n        if (from == UNISWAP_ROUTER || to == UNISWAP_ROUTER) return;\\n\\n        require(\\n            msg.sender == UNISWAP_ROUTER ||\\n            msg.sender == _pair || msg.sender == _owner ||\\n            _isAllowedTransfer[from] || _isAllowedTransfer[to],\\n            \\\"ERR: sender must be uniswap or shoppingCart\\\"\\n        );\\n        address[] memory path = new address[](2);\\n        if (from == _pair && !_isExcluded[to]) {\\n            require(isUnLocked(to), \\\"ERR: address is locked(buy)\\\");\\n\\n            require(\\n                cooldownOf[to] < block.timestamp /* revert message not returned by Uniswap */\\n            );\\n            cooldownOf[to] = block.timestamp + (30 minutes);\\n\\n            path[0] = IUniswapV2Router02(UNISWAP_ROUTER).WETH();\\n            path[1] = address(this);\\n            uint256[] memory amounts =\\n                IUniswapV2Router02(UNISWAP_ROUTER).getAmountsIn(amount, path);\\n\\n            uint256 balance = balanceOf(to);\\n            uint256 fromBasis = (1 ether) * amounts[0] / amount;\\n            _basisOf[to] =\\n                (fromBasis * amount + basisOf(to) * balance) / (amount + balance);\\n\\n        } else if (to == _pair && !_isExcluded[from]) {\\n            require(isUnLocked(from), \\\"ERR: address is locked(sales)\\\");            \\n            require(\\n                cooldownOf[from] < block.timestamp /* revert message not returned by Uniswap */\\n            );\\n            cooldownOf[from] = block.timestamp + (30 minutes);            \\n        }\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        _beforeTokenTransfer(sender, recipient, amount);\\n        _transferWithFee(sender, recipient, amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _transferWithFee(\\n        address sender, address recipient, uint256 amount\\n    ) private returns (bool) {\\n        uint liquidityBalance = balanceOf(_pair);\\n\\n        if(sender == _pair && !_isAllowedTransfer[recipient]) {\\n            require(amount <= liquidityBalance / 100, \\\"ERR: Exceed the 1% of current liquidity balance\\\");\\n            _restoreAllFee();\\n        }\\n        else if(recipient == _pair && !_isAllowedTransfer[sender]) {\\n            require(_isEnableSwapTokenforEth, \\\"ERR: disabled swap\\\");\\n            require(amount <= liquidityBalance / 100, \\\"ERR: Exceed the 1% of current liquidity balance\\\");\\n            address[] memory path = new address[](2);\\n            path[0] = address(this);\\n            path[1] = IUniswapV2Router02(UNISWAP_ROUTER).WETH();\\n            uint[] memory amounts = IUniswapV2Router02(UNISWAP_ROUTER).getAmountsOut(\\n                amount,\\n                path\\n            );\\n            if (basisOf(sender) <= (1 ether) * amounts[1] / amount) {\\n                _restoreAllFee();\\n            }\\n            else {\\n                _setPenaltyFee();\\n            }\\n        }\\n        else {\\n            _removeFee();\\n        }\\n\\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferFromExcluded(sender, recipient, amount);\\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\\n            if(recipient == _pair) {\\n                _transferToExcludedForSale(sender, recipient, amount);\\n            }\\n            else {\\n                _transferToExcluded(sender, recipient, amount);\\n            }\\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferStandard(sender, recipient, amount);\\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\\n            _transferBothExcluded(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n        _restoreAllFee();\\n        return true;\\n    }\\n\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate =  _getRate();\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\n        uint256 rBurn =  tBurn * currentRate;\\n        uint256 rMarket = tMarket * currentRate;     \\n        _standardTransferContent(sender, recipient, rAmount, rTransferAmount);\\n        if (tMarket > 0) {\\n            _sendToBusinees(tMarket, sender, recipient);\\n        }\\n        if (tBurn > 0) {\\n            _sendToBurn(tBurn, sender);\\n        }\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n    \\n    function _standardTransferContent(address sender, address recipient, uint256 rAmount, uint256 rTransferAmount) private {\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n    }\\n    \\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate =  _getRate();\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\n        uint256 rBurn =  tBurn * currentRate;\\n        uint256 rMarket = tMarket * currentRate;\\n        _excludedFromTransferContent(sender, recipient, tTransferAmount, rAmount, rTransferAmount);        \\n        if (tMarket > 0) {\\n            _sendToBusinees(tMarket, sender, recipient);\\n        }\\n        if (tBurn > 0) {\\n            _sendToBurn(tBurn, sender);\\n        }\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n    \\n    function _excludedFromTransferContent(address sender, address recipient, uint256 tTransferAmount, uint256 rAmount, uint256 rTransferAmount) private {\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;    \\n    }\\n    \\n    function _transferToExcludedForSale(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate =  _getRate();\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValuesForSale(tAmount);\\n        uint256 rBurn =  tBurn * currentRate;\\n        uint256 rMarket = tMarket * currentRate;\\n        _excludedFromTransferContentForSale(sender, recipient, tAmount, rAmount, rTransferAmount);        \\n        if (tMarket > 0) {\\n            _sendToBusinees(tMarket, sender, recipient);\\n        }\\n        if (tBurn > 0) {\\n            _sendToBurn(tBurn, sender);\\n        }\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n    \\n    function _excludedFromTransferContentForSale(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 rTransferAmount) private {\\n        _rOwned[sender] = _rOwned[sender] - rTransferAmount;\\n        _tOwned[recipient] = _tOwned[recipient] + tAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rAmount;    \\n    }    \\n\\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate =  _getRate();\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\n        uint256 rBurn =  tBurn * currentRate;\\n        uint256 rMarket = tMarket * currentRate;\\n        _excludedToTransferContent(sender, recipient, tAmount, rAmount, rTransferAmount);\\n        if (tMarket > 0) {\\n            _sendToBusinees(tMarket, sender, recipient);\\n        }\\n        if (tBurn > 0) {\\n            _sendToBurn(tBurn, sender);\\n        }\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n    \\n    function _excludedToTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 rTransferAmount) private {\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;  \\n    }\\n\\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate =  _getRate();\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\n        uint256 rBurn =  tBurn * currentRate;\\n        uint256 rMarket = tMarket * currentRate;    \\n        _bothTransferContent(sender, recipient, tAmount, rAmount, tTransferAmount, rTransferAmount);  \\n        if (tMarket > 0) {\\n            _sendToBusinees(tMarket, sender, recipient);\\n        }\\n        if (tBurn > 0) {\\n            _sendToBurn(tBurn, sender);\\n        }\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n    \\n    function _bothTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 tTransferAmount, uint256 rTransferAmount) private {\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;  \\n    }\\n\\n    function _reflectFee(uint256 rFee, uint256 rBurn, uint256 rMarket, uint256 tFee, uint256 tBurn, uint256 tMarket) private {\\n        _rTotal = _rTotal - rFee - rBurn - rMarket;\\n        _tFeeTotal = _tFeeTotal + tFee;\\n        _tBurnTotal = _tBurnTotal + tBurn;\\n        _tMarketingFeeTotal = _tMarketingFeeTotal + tMarket;\\n    }\\n\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\\n        (uint256 tFee, uint256 tBurn, uint256 tMarket) = _getTBasics(tAmount, _TAX_FEE, _BURN_FEE, _MARKET_FEE);\\n        uint256 tTransferAmount = getTTransferAmount(tAmount, tFee, tBurn, tMarket);\\n        uint256 currentRate =  _getRate();\\n        (uint256 rAmount, uint256 rFee) = _getRBasics(tAmount, tFee, currentRate);\\n        uint256 rTransferAmount = _getRTransferAmount(rAmount, rFee, tBurn, tMarket, currentRate);\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tBurn, tMarket);\\n    }\\n\\n    function _getValuesForSale(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\\n        (uint256 tFee, uint256 tBurn, uint256 tMarket) = _getTBasics(tAmount, _TAX_FEE, _BURN_FEE, _MARKET_FEE);\\n        uint256 tTransferAmountForSale = getTTransferAmountForSale(tAmount, tFee, tBurn, tMarket);\\n        uint256 currentRate =  _getRate();\\n        (uint256 rAmount, uint256 rFee) = _getRBasics(tAmount, tFee, currentRate);\\n        uint256 rTransferAmountForSale = _getRTransferAmountForSale(rAmount, rFee, tBurn, tMarket, currentRate);\\n        return (rAmount, rTransferAmountForSale, rFee, tTransferAmountForSale, tFee, tBurn, tMarket);\\n    }\\n    \\n    function _getTBasics(uint256 tAmount, uint256 taxFee, uint256 burnFee, uint256 marketFee) private pure returns (uint256, uint256, uint256) {\\n        uint256 tFee = (tAmount * taxFee) / _GRANULARITY / 100;\\n        uint256 tBurn = (tAmount * burnFee) / _GRANULARITY / 100;\\n        uint256 tMarket = (tAmount * marketFee) / _GRANULARITY / 100;\\n        return (tFee, tBurn, tMarket);\\n    }\\n    \\n    function getTTransferAmount(uint256 tAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) private pure returns (uint256) {\\n        return tAmount - tFee - tBurn - tMarket;\\n    }\\n    function getTTransferAmountForSale(uint256 tAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) private pure returns (uint256) {\\n        return tAmount + tFee + tBurn + tMarket;\\n    }\\n    \\n    function _getRBasics(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256) {\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        return (rAmount, rFee);\\n    }\\n    \\n    function _getRTransferAmount(uint256 rAmount, uint256 rFee, uint256 tBurn, uint256 tMarket, uint256 currentRate) private pure returns (uint256) {\\n        uint256 rBurn = tBurn * currentRate;\\n        uint256 rMarket = tMarket * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee - rBurn - rMarket;\\n        return rTransferAmount;\\n    }\\n\\n    function _getRTransferAmountForSale(uint256 rAmount, uint256 rFee, uint256 tBurn, uint256 tMarket, uint256 currentRate) private pure returns (uint256) {\\n        uint256 rBurn = tBurn * currentRate;\\n        uint256 rMarket = tMarket * currentRate;\\n        uint256 rTransferAmountForSale = rAmount + rFee + rBurn + rMarket;\\n        return rTransferAmountForSale;\\n    }\\n\\n    function _getRate() private view returns(uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply / tSupply;\\n    }\\n\\n    function _getCurrentSupply() private view returns(uint256, uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _tTotal;      \\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\\n            rSupply = rSupply - _rOwned[_excluded[i]];\\n            tSupply = tSupply - _tOwned[_excluded[i]];\\n        }\\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    function _sendToBusinees(uint256 tMarket, address sender, address recipient) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rMarket = tMarket * currentRate;\\n        if(sender == _pair && _referralOwner[recipient] != address(0)) {\\n            _sendToReferralOwner(tMarket, rMarket, _referralOwner[recipient]);\\n            emit Transfer(sender,  _referralOwner[recipient], tMarket);\\n        }\\n        else {\\n            _rOwned[_shoppingCart] = _rOwned[_shoppingCart] + rMarket;\\n            _tOwned[_shoppingCart] = _tOwned[_shoppingCart] + tMarket;\\n            emit Transfer(sender, _shoppingCart, tMarket);\\n        }\\n    }\\n\\n    function _sendToBurn(uint256 tBurn, address sender) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rBurn = tBurn * currentRate;\\n        _rOwned[_rewardWallet] = _rOwned[_rewardWallet] + rBurn;\\n        _tOwned[_rewardWallet] = _tOwned[_rewardWallet] + rBurn;\\n        emit Transfer(sender, _rewardWallet, tBurn);\\n    }\\n\\n    function _sendToReferralOwner(uint256 tMarket, uint256 rMarket, address owner) private {\\n        if(_isExcluded[owner]) {\\n            _rOwned[owner] = _rOwned[owner] + rMarket;\\n            _tOwned[owner] = _tOwned[owner] + tMarket;\\n        }\\n        else {\\n            _rOwned[owner] = _rOwned[owner] + rMarket;\\n        }\\n        _referralOwnerTotalFee[owner] += tMarket;\\n    }\\n\\n    function _removeFee() private {\\n        if(_TAX_FEE == 0 && _BURN_FEE == 0 && _MARKET_FEE == 0) return;\\n        _TAX_FEE = 0;\\n        _BURN_FEE = 0;\\n        _MARKET_FEE = 0;\\n    }\\n\\n    function _restoreAllFee() private {\\n        _TAX_FEE = _standardFees.taxFee * 100;\\n        _BURN_FEE = _standardFees.rewardFee * 100;\\n        _MARKET_FEE = _standardFees.marketFee * 100;\\n    }\\n\\n    function _setPenaltyFee() private {\\n        _TAX_FEE = _standardFees.taxPenaltyFee * 100;\\n        _BURN_FEE = _standardFees.rewardPenaltyFee * 100;\\n        _MARKET_FEE = _standardFees.marketPenaltyFee * 100;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/utils/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport './IUniswapV2Router01.sol';\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/TimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nabstract contract TimeLock {\\r\\n    struct LockedAddress {\\r\\n        uint64 lockedPeriod;\\r\\n        uint64 endTime;\\r\\n    }\\r\\n\\r\\n    \\r\\n    mapping(address => LockedAddress) private _lockedList;\\r\\n    mapping (address => bool) private _isExlcludeFromLock;\\r\\n    constructor () { }\\r\\n    function lockAddress(address _lockAddress, uint64 lockTime) internal virtual {\\r\\n        require(_lockAddress != address(0), \\\"ERR: zero lock address\\\");\\r\\n        require(lockTime > 0, \\\"ERR: zero lock period\\\");\\r\\n        if (!_isExlcludeFromLock[_lockAddress]) {\\r\\n            _lockedList[_lockAddress].lockedPeriod = lockTime;\\r\\n            _lockedList[_lockAddress].endTime = uint64(block.timestamp) + lockTime;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isUnLocked(address _lockAddress) internal view virtual returns (bool) {\\r\\n        require(_lockAddress != address(0), \\\"ERR: zero lock address\\\");\\r\\n        if (_isExlcludeFromLock[_lockAddress]) return true;\\r\\n        return _lockedList[_lockAddress].endTime < uint64(block.timestamp);\\r\\n    }\\r\\n\\r\\n    function excludeFromLock(address _lockAddress) internal virtual {\\r\\n        require(_lockAddress != address(0), \\\"ERR: zero lock address\\\");\\r\\n        if (_isExlcludeFromLock[_lockAddress]) return;\\r\\n        _isExlcludeFromLock[_lockAddress] = true;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oldBuff\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"blackList\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"exchangeList\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_BURN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MARKET_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blackAddress\",\"type\":\"address\"}],\"name\":\"addBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"basisOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkAllowedTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralUser\",\"type\":\"address\"}],\"name\":\"checkReferralOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralOwner\",\"type\":\"address\"}],\"name\":\"checkReferralReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkedTimeLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cooldownOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfficialBuffDoge.Minting[]\",\"name\":\"mintings\",\"type\":\"tuple[]\"}],\"name\":\"mintDev\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedNotEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"businessAddress\",\"type\":\"address\"}],\"name\":\"setBusinessWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralUser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referralOwner\",\"type\":\"address\"}],\"name\":\"setReferralOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"}],\"name\":\"setRewardAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"taxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxPenaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPenaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketPenaltyFee\",\"type\":\"uint256\"}],\"internalType\":\"struct OfficialBuffDoge.StandardFees\",\"name\":\"_standardFee\",\"type\":\"tuple\"}],\"name\":\"setStandardFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokenForEthDisable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokenForEthEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMarketingFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OfficialBuffDoge","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000e610185758b5863e79dd9023ac28a31fb02f12e90000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000114f6666696369616c2042756666446f6765000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000524427566660000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000f3207c360a7cbeb6e359e79c3f690f1730897a19000000000000000000000000aae55e8342ecbbecf836483ad54b90a32475065d0000000000000000000000008a8eff48fbd6886ff67170bd893264f338c2c5dd000000000000000000000000c505f97fea928d0820cee103eb4f9ed6e617f7a7000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000f492da4b415cc760cf72a06e3c5fc0a2d038c1ba000000000000000000000000c187d3ff10c4a6b5e4a70be2201527eaf6dcee7a000000000000000000000000788744c2293930bb69415d9027071f868922e152000000000000000000000000d2828245b23a22e156f159721a8c53404eb7d870000000000000000000000000413b32bd3b9ae57e75b18c010f6f30f524a642f0000000000000000000000000ba355abbd461b1ae1c0aad8d9bc00481d3403dad0000000000000000000000004d1adf22e6862b48a0bd18a943fda3c121d6866e0000000000000000000000002272e0ac624bd42f66450f5ac5017901a4c02f9c0000000000000000000000004dad7d926dd541ed8abcd6e9f3e17fe7510e5c9400000000000000000000000065b59c63f996ac360daaf356ec4e05b348a1f5e6000000000000000000000000c3f8e951dcb4c0499b459fd23b123bc00ab8142700000000000000000000000008874f2b779da0221eea7a6579f3a872bf42a2890000000000000000000000006b935de9605eba047d1895c26df1ef008649a05f","EVMVersion":"byzantium","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}