{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n// File: contracts/libraries/EVMScriptCreator.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @author psirex\r\n/// @notice Contains methods for convenient creation\r\n/// of EVMScripts in EVMScript factories contracts\r\nlibrary EVMScriptCreator {\r\n    // Id of default CallsScript Aragon's executor.\r\n    bytes4 private constant SPEC_ID = hex\"00000001\";\r\n\r\n    /// @notice Encodes one method call as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4 _methodId,\r\n        bytes memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _commands) {\r\n        return\r\n            abi.encodePacked(\r\n                SPEC_ID,\r\n                _to,\r\n                uint32(_evmScriptCallData.length) + 4,\r\n                _methodId,\r\n                _evmScriptCallData\r\n            );\r\n    }\r\n\r\n    /// @notice Encodes multiple calls of the same method on one contract as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4 _methodId,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        for (uint256 i = 0; i < _evmScriptCallData.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to,\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodId,\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n\r\n    /// @notice Encodes multiple calls to different methods within the same contract as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4[] memory _methodIds,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        require(_methodIds.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < _methodIds.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to,\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodIds[i],\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n\r\n    /// @notice Encodes multiple calls to different contracts as EVMScript\r\n    function createEVMScript(\r\n        address[] memory _to,\r\n        bytes4[] memory _methodIds,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        require(_to.length == _methodIds.length, \"LENGTH_MISMATCH\");\r\n        require(_to.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < _to.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to[i],\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodIds[i],\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IEVMScriptFactory.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @author psirex\r\n/// @notice Interface which every EVMScript factory used in EasyTrack contract has to implement\r\ninterface IEVMScriptFactory {\r\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\r\n        external\r\n        returns (bytes memory);\r\n}\r\n\r\n// File: contracts/EVMScriptFactories/IncreaseNodeOperatorStakingLimit.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ninterface INodeOperatorsRegistry {\r\n    function getNodeOperator(uint256 _id, bool _fullInfo)\r\n        external\r\n        view\r\n        returns (\r\n            bool active,\r\n            string memory name,\r\n            address rewardAddress,\r\n            uint64 stakingLimit,\r\n            uint64 stoppedValidators,\r\n            uint64 totalSigningKeys,\r\n            uint64 usedSigningKeys\r\n        );\r\n\r\n    function setNodeOperatorStakingLimit(uint256 _id, uint64 _stakingLimit) external;\r\n}\r\n\r\n/// @author psirex\r\n/// @notice Creates EVMScript to increase staking limit for node operator\r\ncontract IncreaseNodeOperatorStakingLimit is IEVMScriptFactory {\r\n    struct NodeOperatorData {\r\n        uint256 id;\r\n        bool active;\r\n        address rewardAddress;\r\n        uint256 stakingLimit;\r\n        uint256 totalSigningKeys;\r\n    }\r\n\r\n    // -------------\r\n    // ERRORS\r\n    // -------------\r\n\r\n    string private constant ERROR_NODE_OPERATOR_DISABLED = \"NODE_OPERATOR_DISABLED\";\r\n    string private constant ERROR_CALLER_IS_NOT_NODE_OPERATOR = \"CALLER_IS_NOT_NODE_OPERATOR\";\r\n    string private constant ERROR_STAKING_LIMIT_TOO_LOW = \"STAKING_LIMIT_TOO_LOW\";\r\n    string private constant ERROR_NOT_ENOUGH_SIGNING_KEYS = \"NOT_ENOUGH_SIGNING_KEYS\";\r\n\r\n    // -------------\r\n    // VARIABLES\r\n    // -------------\r\n\r\n    /// @notice Address of NodeOperatorsRegistry contract\r\n    INodeOperatorsRegistry public immutable nodeOperatorsRegistry;\r\n\r\n    // -------------\r\n    // CONSTRUCTOR\r\n    // -------------\r\n\r\n    constructor(address _nodeOperatorsRegistry) {\r\n        nodeOperatorsRegistry = INodeOperatorsRegistry(_nodeOperatorsRegistry);\r\n    }\r\n\r\n    // -------------\r\n    // EXTERNAL METHODS\r\n    // -------------\r\n\r\n    /// @notice Creates EVMScript to increase staking limit for node operator\r\n    /// @param _creator Address who creates EVMScript\r\n    /// @param _evmScriptCallData Encoded tuple: (uint256 _nodeOperatorId, uint256 _stakingLimit) where\r\n    /// _nodeOperatorId - id of node operator in NodeOperatorsRegistry\r\n    /// _stakingLimit - new staking limit\r\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\r\n        external\r\n        view\r\n        override\r\n        returns (bytes memory)\r\n    {\r\n        _validateCreatorAndEVMScriptCallData(_creator, _evmScriptCallData);\r\n        return\r\n            EVMScriptCreator.createEVMScript(\r\n                address(nodeOperatorsRegistry),\r\n                nodeOperatorsRegistry.setNodeOperatorStakingLimit.selector,\r\n                _evmScriptCallData\r\n            );\r\n    }\r\n\r\n    /// @notice Decodes call data used by createEVMScript method\r\n    /// @param _evmScriptCallData Encoded tuple: (uint256 _nodeOperatorId, uint256 _stakingLimit) where\r\n    /// _nodeOperatorId - id of node operator in NodeOperatorsRegistry\r\n    /// _stakingLimit - new staking limit\r\n    /// @return _nodeOperatorId Id of node operator in NodeOperatorsRegistry\r\n    /// @return _stakingLimit New staking limit\r\n    function decodeEVMScriptCallData(bytes memory _evmScriptCallData)\r\n        external\r\n        pure\r\n        returns (uint256 _nodeOperatorId, uint256 _stakingLimit)\r\n    {\r\n        return _decodeEVMScriptCallData(_evmScriptCallData);\r\n    }\r\n\r\n    // ------------------\r\n    // PRIVATE METHODS\r\n    // ------------------\r\n\r\n    function _decodeEVMScriptCallData(bytes memory _evmScriptCallData)\r\n        private\r\n        pure\r\n        returns (uint256 _nodeOperatorId, uint256 _stakingLimit)\r\n    {\r\n        (_nodeOperatorId, _stakingLimit) = abi.decode(_evmScriptCallData, (uint256, uint256));\r\n    }\r\n\r\n    function _validateCreatorAndEVMScriptCallData(address _creator, bytes memory _evmScriptCallData)\r\n        private\r\n        view\r\n    {\r\n        (uint256 _nodeOperatorId, uint256 _stakingLimit) =\r\n            _decodeEVMScriptCallData(_evmScriptCallData);\r\n        NodeOperatorData memory nodeOperatorData = _getNodeOperatorData(_nodeOperatorId);\r\n        require(nodeOperatorData.rewardAddress == _creator, ERROR_CALLER_IS_NOT_NODE_OPERATOR);\r\n        require(nodeOperatorData.active, ERROR_NODE_OPERATOR_DISABLED);\r\n        require(nodeOperatorData.stakingLimit < _stakingLimit, ERROR_STAKING_LIMIT_TOO_LOW);\r\n        require(nodeOperatorData.totalSigningKeys >= _stakingLimit, ERROR_NOT_ENOUGH_SIGNING_KEYS);\r\n    }\r\n\r\n    function _getNodeOperatorData(uint256 _nodeOperatorId)\r\n        private\r\n        view\r\n        returns (NodeOperatorData memory _nodeOperatorData)\r\n    {\r\n        (bool active, , address rewardAddress, uint64 stakingLimit, , uint64 totalSigningKeys, ) =\r\n            nodeOperatorsRegistry.getNodeOperator(_nodeOperatorId, false);\r\n\r\n        _nodeOperatorData.id = _nodeOperatorId;\r\n        _nodeOperatorData.active = active;\r\n        _nodeOperatorData.rewardAddress = rewardAddress;\r\n        _nodeOperatorData.stakingLimit = stakingLimit;\r\n        _nodeOperatorData.totalSigningKeys = totalSigningKeys;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeOperatorsRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_evmScriptCallData\",\"type\":\"bytes\"}],\"name\":\"createEVMScript\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_evmScriptCallData\",\"type\":\"bytes\"}],\"name\":\"decodeEVMScriptCallData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeOperatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeOperatorsRegistry\",\"outputs\":[{\"internalType\":\"contract INodeOperatorsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IncreaseNodeOperatorStakingLimit","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000055032650b14df07b85bf18a3a3ec8e0af2e028d5","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d4dbd9fd56df0df9f7586c43a0c97395c1c0da1a9e1512a8e99ad25fdaa94e40"}]}