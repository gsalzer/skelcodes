{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GmDataInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface GmDataInterface {\\n    struct GmDataSet {\\n        bytes imageName;\\n        bytes compressedImage;\\n        uint256 compressedSize;\\n    }\\n\\n    function getSvg(uint256 index) external pure returns (GmDataSet memory);\\n}\\n\"\r\n    },\r\n    \"contracts/GmRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {InflateLib} from \\\"./InflateLib.sol\\\";\\nimport {GmDataInterface} from \\\"./GmDataInterface.sol\\\";\\nimport {StringsUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\n\\ninterface ICourierFont {\\n    function font() external view returns (string memory);\\n}\\n\\ncontract GmRenderer {\\n    ICourierFont private immutable font;\\n    GmDataInterface private immutable gmData1;\\n    GmDataInterface private immutable gmData2;\\n\\n    struct Color {\\n        bytes hexNum;\\n        bytes name;\\n    }\\n\\n    constructor(\\n        ICourierFont fontAddress,\\n        GmDataInterface gmData1Address,\\n        GmDataInterface gmData2Address\\n    ) {\\n        font = fontAddress;\\n        gmData1 = gmData1Address;\\n        gmData2 = gmData2Address;\\n    }\\n\\n    /// @notice decompresses the GmDataSet\\n    /// @param gmData, compressed ascii svg data\\n    function decompress(GmDataInterface.GmDataSet memory gmData)\\n        public\\n        pure\\n        returns (bytes memory, bytes memory)\\n    {\\n        (, bytes memory inflated) = InflateLib.puff(\\n            gmData.compressedImage,\\n            gmData.compressedSize\\n        );\\n        return (gmData.imageName, inflated);\\n    }\\n\\n    /// @notice returns an svg filter\\n    /// @param index, a random number derived from the seed\\n    function _getFilter(uint256 index) internal pure returns (bytes memory) {\\n\\n        // 1 || 2 || 3 || 4 || 5 -> noise 5%\\n        if (\\n            (index == 1) ||\\n            (index == 2) ||\\n            (index == 3) ||\\n            (index == 4) ||\\n            (index == 5)\\n        ) {\\n            return \\\"noise\\\";\\n        }\\n\\n        // 7 || 8 || 98 -> scribble 3%\\n        if ((index == 7) || (index == 8) || (index == 9)) {\\n            return \\\"scribble\\\";\\n        }\\n\\n        // 10 - 29 -> morph 20%\\n        if (((100 - index) > 70) && ((100 - index) <= 90)) {\\n            return \\\"morph\\\";\\n        }\\n\\n        // 30 - 39 -> glow 10%\\n        if (((100 - index) > 60) && ((100 - index) <= 70)) {\\n            return \\\"glow\\\";\\n        }\\n\\n        // 69 -> fractal 1%\\n        if (index == 69) {\\n            return \\\"fractal\\\";\\n        }\\n\\n        return \\\"none\\\";\\n    }\\n\\n    /// @notice returns a background color and font color\\n    /// @param seed, pseudo random seed\\n    function _getColors(bytes32 seed)\\n        internal\\n        pure\\n        returns (Color memory bgColor, Color memory fontColor)\\n    {\\n        uint32 bgRand = uint32(bytes4(seed)) % 111;\\n        uint32 fontJitter = uint32(bytes4(seed << 32)) % 5;\\n        uint32 fontOperation = uint8(bytes1(seed << 64)) % 2;\\n        uint32 fontRand;\\n        if (fontOperation == 0) {\\n            fontRand = (bgRand + (55 + fontJitter)) % 111;\\n        } else {\\n            fontRand = (bgRand + (55 - fontJitter)) % 111;\\n        }\\n\\n        return (_getColor(bgRand), _getColor(fontRand));\\n    }\\n\\n    /// @notice executes string comparison against two strings\\n    /// @param a, first string\\n    /// @param b, second string\\n    function strCompare(string memory a, string memory b) internal pure returns (bool) {\\n        if(bytes(a).length != bytes(b).length) {\\n            return false;\\n        } else {\\n            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\\n        }\\n    }\\n\\n    /// @notice returns the raw svg yielded by seed\\n    /// @param seed, pseudo random seed\\n    function svgRaw(bytes32 seed)\\n        external\\n        view\\n        returns (\\n            bytes memory,\\n            bytes memory,\\n            bytes memory,\\n            bytes memory,\\n            bytes memory\\n        )\\n    {\\n        uint32 style = uint32(bytes4(seed << 65)) % 69;\\n        uint32 filterRand = uint32(bytes4(seed << 97)) % 100;\\n        bytes memory filter = _getFilter(filterRand);\\n\\n        (Color memory bgColor, Color memory fontColor) = _getColors(seed);\\n\\n        bytes memory inner;\\n        bytes memory name;\\n        if (style < 50) {\\n            (name, inner) = decompress(gmData1.getSvg(style));\\n        } else {\\n            (name, inner) = decompress(gmData2.getSvg(style));\\n        }\\n\\n        if ((strCompare(string(name), \\\"Hex\\\")) || (strCompare(string(name), \\\"Binary\\\")) || (strCompare(string(name), \\\"Morse\\\")) || (strCompare(string(name), \\\"Mnemonic\\\"))){\\n            filter = \\\"none\\\";\\n        }\\n\\n        return (\\n            abi.encodePacked(\\n                svgPreambleString(bgColor.hexNum, fontColor.hexNum, filter),\\n                inner,\\n                \\\"</svg>\\\"\\n            ),\\n            name,\\n            bgColor.name,\\n            fontColor.name,\\n            filter\\n        );\\n    }\\n\\n    /// @notice returns the svg filters\\n    function svgFilterDefs() private view returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                '<defs><filter id=\\\"fractal\\\" filterUnits=\\\"objectBoundingBox\\\" x=\\\"0%\\\" y=\\\"0%\\\" width=\\\"100%\\\" height=\\\"100%\\\" ><feTurbulence id=\\\"turbulence\\\" type=\\\"fractalNoise\\\" baseFrequency=\\\"0.03\\\" numOctaves=\\\"1\\\" ><animate attributeName=\\\"baseFrequency\\\" values=\\\"0.01;0.4;0.01\\\" dur=\\\"100s\\\" repeatCount=\\\"indefinite\\\" /></feTurbulence><feDisplacementMap in=\\\"SourceGraphic\\\" scale=\\\"50\\\"></feDisplacementMap></filter><filter id=\\\"morph\\\"><feMorphology operator=\\\"dilate\\\" radius=\\\"0\\\"><animate attributeName=\\\"radius\\\" values=\\\"0;5;0\\\" dur=\\\"8s\\\" repeatCount=\\\"indefinite\\\" /></feMorphology></filter><filter id=\\\"glow\\\" filterUnits=\\\"objectBoundingBox\\\" x=\\\"0%\\\" y=\\\"0%\\\" width=\\\"100%\\\" height=\\\"100%\\\" ><feGaussianBlur stdDeviation=\\\"5\\\" result=\\\"blur2\\\" in=\\\"SourceGraphic\\\" /><feMerge><feMergeNode in=\\\"blur2\\\" /><feMergeNode in=\\\"SourceGraphic\\\" /></feMerge></filter><filter id=\\\"noise\\\"><feTurbulence baseFrequency=\\\"0.05\\\"/><feColorMatrix type=\\\"hueRotate\\\" values=\\\"0\\\"><animate attributeName=\\\"values\\\" from=\\\"0\\\" to=\\\"360\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\"/></feColorMatrix><feColorMatrix type=\\\"matrix\\\" values=\\\"0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0\\\"/><feDisplacementMap in=\\\"SourceGraphic\\\" scale=\\\"10\\\"/></filter><filter id=\\\"none\\\"><feOffset></feOffset></filter><filter id=\\\"scribble\\\"><feTurbulence type=\\\"turbulence\\\" baseFrequency=\\\"0.05\\\" numOctaves=\\\"2\\\" result=\\\"turbulence\\\"/><feDisplacementMap in2=\\\"turbulence\\\" in=\\\"SourceGraphic\\\" scale=\\\"50\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"G\\\"/></filter><filter id=\\\"tile\\\" x=\\\"10\\\" y=\\\"10\\\" width=\\\"10%\\\" height=\\\"10%\\\"><feTile in=\\\"SourceGraphic\\\" x=\\\"10\\\" y=\\\"10\\\" width=\\\"10\\\" height=\\\"10\\\" /><feTile/></filter></defs>'\\n            );\\n    }\\n\\n    /// @notice returns the svg preamble\\n    /// @param bgColor, color of the background as hex string\\n    /// @param fontColor, color of the font as hex string\\n    /// @param filter, filter for the svg\\n    function svgPreambleString(\\n        bytes memory bgColor,\\n        bytes memory fontColor,\\n        bytes memory filter\\n    ) private view returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                \\\"<svg viewBox='0 0 640 640' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'><style> @font-face { font-family: CourierFont; src: url('\\\",\\n                font.font(),\\n                \\\"') format('opentype'); }\\\",\\n                \\\".base{filter:url(#\\\",\\n                filter,\\n                \\\");fill:\\\",\\n                fontColor,\\n                \\\";font-family:CourierFont;font-size: 16px;}</style>\\\",\\n                svgFilterDefs(),\\n                '<rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"',\\n                bgColor,\\n                '\\\" /> '\\n            );\\n    }\\n\\n    /// @notice returns the Color yielded by index\\n    /// @param index, random number determined by seed\\n    function _getColor(uint32 index)\\n        internal\\n        pure\\n        returns (Color memory color)\\n    {\\n        // AUTOGEN:START\\n\\n        if (index == 0) {\\n            color.hexNum = \\\"#000000\\\";\\n            color.name = \\\"Black\\\";\\n        }\\n\\n        if (index == 1) {\\n            color.hexNum = \\\"#004c6a\\\";\\n            color.name = \\\"Navy Dark Blue\\\";\\n        }\\n\\n        if (index == 2) {\\n            color.hexNum = \\\"#0098d4\\\";\\n            color.name = \\\"Bayern Blue\\\";\\n        }\\n\\n        if (index == 3) {\\n            color.hexNum = \\\"#00e436\\\";\\n            color.name = \\\"Lexaloffle Green\\\";\\n        }\\n\\n        if (index == 4) {\\n            color.hexNum = \\\"#1034a6\\\";\\n            color.name = \\\"Egyptian Blue\\\";\\n        }\\n\\n        if (index == 5) {\\n            color.hexNum = \\\"#008811\\\";\\n            color.name = \\\"Lush Garden\\\";\\n        }\\n\\n        if (index == 6) {\\n            color.hexNum = \\\"#06d078\\\";\\n            color.name = \\\"Underwater Fern\\\";\\n        }\\n\\n        if (index == 7) {\\n            color.hexNum = \\\"#1c1cf0\\\";\\n            color.name = \\\"Bluebonnet\\\";\\n        }\\n\\n        if (index == 8) {\\n            color.hexNum = \\\"#127453\\\";\\n            color.name = \\\"Green Velvet\\\";\\n        }\\n\\n        if (index == 9) {\\n            color.hexNum = \\\"#14bab4\\\";\\n            color.name = \\\"Super Rare Jade\\\";\\n        }\\n\\n        if (index == 10) {\\n            color.hexNum = \\\"#111122\\\";\\n            color.name = \\\"Corbeau\\\";\\n        }\\n\\n        if (index == 11) {\\n            color.hexNum = \\\"#165d95\\\";\\n            color.name = \\\"Lapis Jewel\\\";\\n        }\\n\\n        if (index == 12) {\\n            color.hexNum = \\\"#16b8f3\\\";\\n            color.name = \\\"Zima Blue\\\";\\n        }\\n\\n        if (index == 13) {\\n            color.hexNum = \\\"#1ef876\\\";\\n            color.name = \\\"Synthetic Spearmint\\\";\\n        }\\n\\n        if (index == 14) {\\n            color.hexNum = \\\"#214fc6\\\";\\n            color.name = \\\"New Car\\\";\\n        }\\n\\n        if (index == 15) {\\n            color.hexNum = \\\"#249148\\\";\\n            color.name = \\\"Paperboy's Lawn\\\";\\n        }\\n\\n        if (index == 16) {\\n            color.hexNum = \\\"#24da91\\\";\\n            color.name = \\\"Reptile Green\\\";\\n        }\\n\\n        if (index == 17) {\\n            color.hexNum = \\\"#223311\\\";\\n            color.name = \\\"Darkest Forest\\\";\\n        }\\n\\n        if (index == 18) {\\n            color.hexNum = \\\"#297f6d\\\";\\n            color.name = \\\"Mermaid Sea\\\";\\n        }\\n\\n        if (index == 19) {\\n            color.hexNum = \\\"#22cccc\\\";\\n            color.name = \\\"Mermaid Net\\\";\\n        }\\n\\n        if (index == 20) {\\n            color.hexNum = \\\"#2e2249\\\";\\n            color.name = \\\"Elderberry\\\";\\n        }\\n\\n        if (index == 21) {\\n            color.hexNum = \\\"#326ab1\\\";\\n            color.name = \\\"Dover Straits\\\";\\n        }\\n\\n        if (index == 22) {\\n            color.hexNum = \\\"#2bc51b\\\";\\n            color.name = \\\"Felwood Leaves\\\";\\n        }\\n\\n        if (index == 23) {\\n            color.hexNum = \\\"#391285\\\";\\n            color.name = \\\"Pixie Powder\\\";\\n        }\\n\\n        if (index == 24) {\\n            color.hexNum = \\\"#2e58e8\\\";\\n            color.name = \\\"Veteran's Day Blue\\\";\\n        }\\n\\n        if (index == 25) {\\n            color.hexNum = \\\"#419f59\\\";\\n            color.name = \\\"Chateau Green\\\";\\n        }\\n\\n        if (index == 26) {\\n            color.hexNum = \\\"#45e9c1\\\";\\n            color.name = \\\"Aphrodite Aqua\\\";\\n        }\\n\\n        if (index == 27) {\\n            color.hexNum = \\\"#424330\\\";\\n            color.name = \\\"Garden Path\\\";\\n        }\\n\\n        if (index == 28) {\\n            color.hexNum = \\\"#429395\\\";\\n            color.name = \\\"Catalan\\\";\\n        }\\n\\n        if (index == 29) {\\n            color.hexNum = \\\"#44dd00\\\";\\n            color.name = \\\"Magic Blade\\\";\\n        }\\n\\n        if (index == 30) {\\n            color.hexNum = \\\"#432e6f\\\";\\n            color.name = \\\"Her Highness\\\";\\n        }\\n\\n        if (index == 31) {\\n            color.hexNum = \\\"#4477dd\\\";\\n            color.name = \\\"Andrea Blue\\\";\\n        }\\n\\n        if (index == 32) {\\n            color.hexNum = \\\"#5ad33e\\\";\\n            color.name = \\\"Verdant Fields\\\";\\n        }\\n\\n        if (index == 33) {\\n            color.hexNum = \\\"#3a18b1\\\";\\n            color.name = \\\"Indigo Blue\\\";\\n        }\\n\\n        if (index == 34) {\\n            color.hexNum = \\\"#556611\\\";\\n            color.name = \\\"Forestial Outpost\\\";\\n        }\\n\\n        if (index == 35) {\\n            color.hexNum = \\\"#55bb88\\\";\\n            color.name = \\\"Bleached Olive\\\";\\n        }\\n\\n        if (index == 36) {\\n            color.hexNum = \\\"#5500ee\\\";\\n            color.name = \\\"Tezcatlipoca Blue\\\";\\n        }\\n\\n        if (index == 37) {\\n            color.hexNum = \\\"#545554\\\";\\n            color.name = \\\"Carbon Copy\\\";\\n        }\\n\\n        if (index == 38) {\\n            color.hexNum = \\\"#58a0bc\\\";\\n            color.name = \\\"Dupain\\\";\\n        }\\n\\n        if (index == 39) {\\n            color.hexNum = \\\"#55ff22\\\";\\n            color.name = \\\"Traffic Green\\\";\\n        }\\n\\n        if (index == 40) {\\n            color.hexNum = \\\"#5b3e90\\\";\\n            color.name = \\\"Daisy Bush\\\";\\n        }\\n\\n        if (index == 41) {\\n            color.hexNum = \\\"#6688ff\\\";\\n            color.name = \\\"Deep Denim\\\";\\n        }\\n\\n        if (index == 42) {\\n            color.hexNum = \\\"#61e160\\\";\\n            color.name = \\\"Lightish Green\\\";\\n        }\\n\\n        if (index == 43) {\\n            color.hexNum = \\\"#6a31ca\\\";\\n            color.name = \\\"Sagat Purple\\\";\\n        }\\n\\n        if (index == 44) {\\n            color.hexNum = \\\"#667c3e\\\";\\n            color.name = \\\"Military Green\\\";\\n        }\\n\\n        if (index == 45) {\\n            color.hexNum = \\\"#68c89d\\\";\\n            color.name = \\\"Intense Jade\\\";\\n        }\\n\\n        if (index == 46) {\\n            color.hexNum = \\\"#6d1008\\\";\\n            color.name = \\\"Chestnut Brown\\\";\\n        }\\n\\n        if (index == 47) {\\n            color.hexNum = \\\"#696374\\\";\\n            color.name = \\\"Purple Punch\\\";\\n        }\\n\\n        if (index == 48) {\\n            color.hexNum = \\\"#6fb7e0\\\";\\n            color.name = \\\"Life Force\\\";\\n        }\\n\\n        if (index == 49) {\\n            color.hexNum = \\\"#770044\\\";\\n            color.name = \\\"Dawn of the Fairies\\\";\\n        }\\n\\n        if (index == 50) {\\n            color.hexNum = \\\"#7851a9\\\";\\n            color.name = \\\"Royal Lavender\\\";\\n        }\\n\\n        if (index == 51) {\\n            color.hexNum = \\\"#769c18\\\";\\n            color.name = \\\"Luminescent Green\\\";\\n        }\\n\\n        if (index == 52) {\\n            color.hexNum = \\\"#7be892\\\";\\n            color.name = \\\"Ragweed\\\";\\n        }\\n\\n        if (index == 53) {\\n            color.hexNum = \\\"#703be7\\\";\\n            color.name = \\\"Bluish Purple\\\";\\n        }\\n\\n        if (index == 54) {\\n            color.hexNum = \\\"#7b8b5d\\\";\\n            color.name = \\\"Sage Leaves\\\";\\n        }\\n\\n        if (index == 55) {\\n            color.hexNum = \\\"#82d9c5\\\";\\n            color.name = \\\"Tender Turquoise\\\";\\n        }\\n\\n        if (index == 56) {\\n            color.hexNum = \\\"#7e2530\\\";\\n            color.name = \\\"Scarlet Shade\\\";\\n        }\\n\\n        if (index == 57) {\\n            color.hexNum = \\\"#83769c\\\";\\n            color.name = \\\"Voxatron Purple\\\";\\n        }\\n\\n        if (index == 58) {\\n            color.hexNum = \\\"#88cc00\\\";\\n            color.name = \\\"Fabulous Frog\\\";\\n        }\\n\\n        if (index == 59) {\\n            color.hexNum = \\\"#881166\\\";\\n            color.name = \\\"Possessed Purple\\\";\\n        }\\n\\n        if (index == 60) {\\n            color.hexNum = \\\"#8756e4\\\";\\n            color.name = \\\"Gloomy Purple\\\";\\n        }\\n\\n        if (index == 61) {\\n            color.hexNum = \\\"#93b13d\\\";\\n            color.name = \\\"Green Tea Ice Cream\\\";\\n        }\\n\\n        if (index == 62) {\\n            color.hexNum = \\\"#90fda9\\\";\\n            color.name = \\\"Foam Green\\\";\\n        }\\n\\n        if (index == 63) {\\n            color.hexNum = \\\"#914b13\\\";\\n            color.name = \\\"Parasite Brown\\\";\\n        }\\n\\n        if (index == 64) {\\n            color.hexNum = \\\"#919c81\\\";\\n            color.name = \\\"Whispering Willow\\\";\\n        }\\n\\n        if (index == 65) {\\n            color.hexNum = \\\"#99eeee\\\";\\n            color.name = \\\"Freezy Breezy\\\";\\n        }\\n\\n        if (index == 66) {\\n            color.hexNum = \\\"#983d53\\\";\\n            color.name = \\\"Algae Red\\\";\\n        }\\n\\n        if (index == 67) {\\n            color.hexNum = \\\"#9c87c1\\\";\\n            color.name = \\\"Petrified Purple\\\";\\n        }\\n\\n        if (index == 68) {\\n            color.hexNum = \\\"#98da2c\\\";\\n            color.name = \\\"Effervescent Lime\\\";\\n        }\\n\\n        if (index == 69) {\\n            color.hexNum = \\\"#942193\\\";\\n            color.name = \\\"Acai Juice\\\";\\n        }\\n\\n        if (index == 70) {\\n            color.hexNum = \\\"#a675fe\\\";\\n            color.name = \\\"Purple Illusionist\\\";\\n        }\\n\\n        if (index == 71) {\\n            color.hexNum = \\\"#a4c161\\\";\\n            color.name = \\\"Jungle Juice\\\";\\n        }\\n\\n        if (index == 72) {\\n            color.hexNum = \\\"#aa00cc\\\";\\n            color.name = \\\"Ferocious Fuchsia\\\";\\n        }\\n\\n        if (index == 73) {\\n            color.hexNum = \\\"#a85e39\\\";\\n            color.name = \\\"Earthen Jug\\\";\\n        }\\n\\n        if (index == 74) {\\n            color.hexNum = \\\"#aaa9a4\\\";\\n            color.name = \\\"Ellie Grey\\\";\\n        }\\n\\n        if (index == 75) {\\n            color.hexNum = \\\"#aaee11\\\";\\n            color.name = \\\"Glorious Green Glitter\\\";\\n        }\\n\\n        if (index == 76) {\\n            color.hexNum = \\\"#ad4379\\\";\\n            color.name = \\\"Mystic Maroon\\\";\\n        }\\n\\n        if (index == 77) {\\n            color.hexNum = \\\"#b195e4\\\";\\n            color.name = \\\"Dreamy Candy Forest\\\";\\n        }\\n\\n        if (index == 78) {\\n            color.hexNum = \\\"#b1dd52\\\";\\n            color.name = \\\"Conifer\\\";\\n        }\\n\\n        if (index == 79) {\\n            color.hexNum = \\\"#c034af\\\";\\n            color.name = \\\"Pink Perennial\\\";\\n        }\\n\\n        if (index == 80) {\\n            color.hexNum = \\\"#b78727\\\";\\n            color.name = \\\"University of California Gold\\\";\\n        }\\n\\n        if (index == 81) {\\n            color.hexNum = \\\"#b9d08b\\\";\\n            color.name = \\\"Young Leaves\\\";\\n        }\\n\\n        if (index == 82) {\\n            color.hexNum = \\\"#bb11ee\\\";\\n            color.name = \\\"Promiscuous Pink\\\";\\n        }\\n\\n        if (index == 83) {\\n            color.hexNum = \\\"#c06960\\\";\\n            color.name = \\\"Tapestry Red\\\";\\n        }\\n\\n        if (index == 84) {\\n            color.hexNum = \\\"#bebbc9\\\";\\n            color.name = \\\"Silverberry\\\";\\n        }\\n\\n        if (index == 85) {\\n            color.hexNum = \\\"#bf0a30\\\";\\n            color.name = \\\"Old Glory Red\\\";\\n        }\\n\\n        if (index == 86) {\\n            color.hexNum = \\\"#c35b99\\\";\\n            color.name = \\\"Llilacquered\\\";\\n        }\\n\\n        if (index == 87) {\\n            color.hexNum = \\\"#caa906\\\";\\n            color.name = \\\"Christmas Gold\\\";\\n        }\\n\\n        if (index == 88) {\\n            color.hexNum = \\\"#c2f177\\\";\\n            color.name = \\\"Cucumber Milk\\\";\\n        }\\n\\n        if (index == 89) {\\n            color.hexNum = \\\"#d648d7\\\";\\n            color.name = \\\"Pinkish Purple\\\";\\n        }\\n\\n        if (index == 90) {\\n            color.hexNum = \\\"#cf9346\\\";\\n            color.name = \\\"Fleshtone Shade Wash\\\";\\n        }\\n\\n        if (index == 91) {\\n            color.hexNum = \\\"#d3e0b1\\\";\\n            color.name = \\\"Rockmelon Rind\\\";\\n        }\\n\\n        if (index == 92) {\\n            color.hexNum = \\\"#d22d1d\\\";\\n            color.name = \\\"Pure Red\\\";\\n        }\\n\\n        if (index == 93) {\\n            color.hexNum = \\\"#d28083\\\";\\n            color.name = \\\"Galah\\\";\\n        }\\n\\n        if (index == 94) {\\n            color.hexNum = \\\"#d5c7e8\\\";\\n            color.name = \\\"Foggy Love\\\";\\n        }\\n\\n        if (index == 95) {\\n            color.hexNum = \\\"#db1459\\\";\\n            color.name = \\\"Rubylicious\\\";\\n        }\\n\\n        if (index == 96) {\\n            color.hexNum = \\\"#dd66bb\\\";\\n            color.name = \\\"Pink Charge\\\";\\n        }\\n\\n        if (index == 97) {\\n            color.hexNum = \\\"#e2b227\\\";\\n            color.name = \\\"Gold Tips\\\";\\n        }\\n\\n        if (index == 98) {\\n            color.hexNum = \\\"#ee0099\\\";\\n            color.name = \\\"Love Vessel\\\";\\n        }\\n\\n        if (index == 99) {\\n            color.hexNum = \\\"#dd55ff\\\";\\n            color.name = \\\"Flaming Flamingo\\\";\\n        }\\n\\n        if (index == 100) {\\n            color.hexNum = \\\"#eda367\\\";\\n            color.name = \\\"Adventure Orange\\\";\\n        }\\n\\n        if (index == 101) {\\n            color.hexNum = \\\"#e9f1d0\\\";\\n            color.name = \\\"Yellowish White\\\";\\n        }\\n\\n        if (index == 102) {\\n            color.hexNum = \\\"#ef3939\\\";\\n            color.name = \\\"Vivaldi Red\\\";\\n        }\\n\\n        if (index == 103) {\\n            color.hexNum = \\\"#e78ea5\\\";\\n            color.name = \\\"Underwater Flare\\\";\\n        }\\n\\n        if (index == 104) {\\n            color.hexNum = \\\"#eedd11\\\";\\n            color.name = \\\"Yellow Buzzing\\\";\\n        }\\n\\n        if (index == 105) {\\n            color.hexNum = \\\"#ee2277\\\";\\n            color.name = \\\"Furious Fuchsia\\\";\\n        }\\n\\n        if (index == 106) {\\n            color.hexNum = \\\"#f075e6\\\";\\n            color.name = \\\"Lian Hong Lotus Pink\\\";\\n        }\\n\\n        if (index == 107) {\\n            color.hexNum = \\\"#f7c34c\\\";\\n            color.name = \\\"Creamy Sweet Corn\\\";\\n        }\\n\\n        if (index == 108) {\\n            color.hexNum = \\\"#fc0fc0\\\";\\n            color.name = \\\"CGA Pink\\\";\\n        }\\n\\n        if (index == 109) {\\n            color.hexNum = \\\"#ff6622\\\";\\n            color.name = \\\"Sparrows Fire\\\";\\n        }\\n\\n        if (index == 110) {\\n            color.hexNum = \\\"#fbaf8d\\\";\\n            color.name = \\\"Orange Grove\\\";\\n        }\\n\\n        // AUTOGEN:END\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InflateLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n//\\n// inflate content script:\\n// var pako = require('pako')\\n// var deflate = (str) => [str.length,Buffer.from(pako.deflateRaw(Buffer.from(str, 'utf-8'), {level: 9})).toString('hex')]\\n//\\n\\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\\nlibrary InflateLib {\\n    // Maximum bits in a code\\n    uint256 constant MAXBITS = 15;\\n    // Maximum number of literal/length codes\\n    uint256 constant MAXLCODES = 286;\\n    // Maximum number of distance codes\\n    uint256 constant MAXDCODES = 30;\\n    // Maximum codes lengths to read\\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\\n    // Number of fixed literal/length codes\\n    uint256 constant FIXLCODES = 288;\\n\\n    // Error codes\\n    enum ErrorCode {\\n        ERR_NONE, // 0 successful inflate\\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\\n        ERR_CONSTRUCT // 14 internal: error in construct()\\n    }\\n\\n    // Input and output state\\n    struct State {\\n        //////////////////\\n        // Output state //\\n        //////////////////\\n        // Output buffer\\n        bytes output;\\n        // Bytes written to out so far\\n        uint256 outcnt;\\n        /////////////////\\n        // Input state //\\n        /////////////////\\n        // Input buffer\\n        bytes input;\\n        // Bytes read so far\\n        uint256 incnt;\\n        ////////////////\\n        // Temp state //\\n        ////////////////\\n        // Bit buffer\\n        uint256 bitbuf;\\n        // Number of bits in bit buffer\\n        uint256 bitcnt;\\n        //////////////////////////\\n        // Static Huffman codes //\\n        //////////////////////////\\n        Huffman lencode;\\n        Huffman distcode;\\n    }\\n\\n    // Huffman code decoding tables\\n    struct Huffman {\\n        uint256[] counts;\\n        uint256[] symbols;\\n    }\\n\\n    function bits(State memory s, uint256 need)\\n        private\\n        pure\\n        returns (ErrorCode, uint256)\\n    {\\n        // Bit accumulator (can use up to 20 bits)\\n        uint256 val;\\n\\n        // Load at least need bits into val\\n        val = s.bitbuf;\\n        while (s.bitcnt < need) {\\n            if (s.incnt == s.input.length) {\\n                // Out of input\\n                return (ErrorCode.ERR_NOT_TERMINATED, 0);\\n            }\\n\\n            // Load eight bits\\n            val |= uint256(uint8(s.input[s.incnt++])) << s.bitcnt;\\n            s.bitcnt += 8;\\n        }\\n\\n        // Drop need bits and update buffer, always zero to seven bits left\\n        s.bitbuf = val >> need;\\n        s.bitcnt -= need;\\n\\n        // Return need bits, zeroing the bits above that\\n        uint256 ret = (val & ((1 << need) - 1));\\n        return (ErrorCode.ERR_NONE, ret);\\n    }\\n\\n    function _stored(State memory s) private pure returns (ErrorCode) {\\n        // Length of stored block\\n        uint256 len;\\n\\n        // Discard leftover bits from current byte (assumes s.bitcnt < 8)\\n        s.bitbuf = 0;\\n        s.bitcnt = 0;\\n\\n        // Get length and check against its one's complement\\n        if (s.incnt + 4 > s.input.length) {\\n            // Not enough input\\n            return ErrorCode.ERR_NOT_TERMINATED;\\n        }\\n        len = uint256(uint8(s.input[s.incnt++]));\\n        len |= uint256(uint8(s.input[s.incnt++])) << 8;\\n\\n        if (\\n            uint8(s.input[s.incnt++]) != (~len & 0xFF) ||\\n            uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)\\n        ) {\\n            // Didn't match complement!\\n            return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\\n        }\\n\\n        // Copy len bytes from in to out\\n        if (s.incnt + len > s.input.length) {\\n            // Not enough input\\n            return ErrorCode.ERR_NOT_TERMINATED;\\n        }\\n        if (s.outcnt + len > s.output.length) {\\n            // Not enough output space\\n            return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n        }\\n        while (len != 0) {\\n            // Note: Solidity reverts on underflow, so we decrement here\\n            len -= 1;\\n            s.output[s.outcnt++] = s.input[s.incnt++];\\n        }\\n\\n        // Done with a valid stored block\\n        return ErrorCode.ERR_NONE;\\n    }\\n\\n    function _decode(State memory s, Huffman memory h)\\n        private\\n        pure\\n        returns (ErrorCode, uint256)\\n    {\\n        // Current number of bits in code\\n        uint256 len;\\n        // Len bits being decoded\\n        uint256 code = 0;\\n        // First code of length len\\n        uint256 first = 0;\\n        // Number of codes of length len\\n        uint256 count;\\n        // Index of first code of length len in symbol table\\n        uint256 index = 0;\\n        // Error code\\n        ErrorCode err;\\n\\n        for (len = 1; len <= MAXBITS; len++) {\\n            // Get next bit\\n            uint256 tempCode;\\n            (err, tempCode) = bits(s, 1);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, 0);\\n            }\\n            code |= tempCode;\\n            count = h.counts[len];\\n\\n            // If length len, return symbol\\n            if (code < first + count) {\\n                return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n            }\\n            // Else update for next length\\n            index += count;\\n            first += count;\\n            first <<= 1;\\n            code <<= 1;\\n        }\\n\\n        // Ran out of codes\\n        return (ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE, 0);\\n    }\\n\\n    function _construct(\\n        Huffman memory h,\\n        uint256[] memory lengths,\\n        uint256 n,\\n        uint256 start\\n    ) private pure returns (ErrorCode) {\\n        // Current symbol when stepping through lengths[]\\n        uint256 symbol;\\n        // Current length when stepping through h.counts[]\\n        uint256 len;\\n        // Number of possible codes left of current length\\n        uint256 left;\\n        // Offsets in symbol table for each length\\n        uint256[MAXBITS + 1] memory offs;\\n\\n        // Count number of codes of each length\\n        for (len = 0; len <= MAXBITS; len++) {\\n            h.counts[len] = 0;\\n        }\\n        for (symbol = 0; symbol < n; symbol++) {\\n            // Assumes lengths are within bounds\\n            h.counts[lengths[start + symbol]]++;\\n        }\\n        // No codes!\\n        if (h.counts[0] == n) {\\n            // Complete, but decode() will fail\\n            return (ErrorCode.ERR_NONE);\\n        }\\n\\n        // Check for an over-subscribed or incomplete set of lengths\\n\\n        // One possible code of zero length\\n        left = 1;\\n\\n        for (len = 1; len <= MAXBITS; len++) {\\n            // One more bit, double codes left\\n            left <<= 1;\\n            if (left < h.counts[len]) {\\n                // Over-subscribed--return error\\n                return ErrorCode.ERR_CONSTRUCT;\\n            }\\n            // Deduct count from possible codes\\n\\n            left -= h.counts[len];\\n        }\\n\\n        // Generate offsets into symbol table for each length for sorting\\n        offs[1] = 0;\\n        for (len = 1; len < MAXBITS; len++) {\\n            offs[len + 1] = offs[len] + h.counts[len];\\n        }\\n\\n        // Put symbols in table sorted by length, by symbol order within each length\\n        for (symbol = 0; symbol < n; symbol++) {\\n            if (lengths[start + symbol] != 0) {\\n                h.symbols[offs[lengths[start + symbol]]++] = symbol;\\n            }\\n        }\\n\\n        // Left > 0 means incomplete\\n        return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\\n    }\\n\\n    function _codes(\\n        State memory s,\\n        Huffman memory lencode,\\n        Huffman memory distcode\\n    ) private pure returns (ErrorCode) {\\n        // Decoded symbol\\n        uint256 symbol;\\n        // Length for copy\\n        uint256 len;\\n        // Distance for copy\\n        uint256 dist;\\n        // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\\n        // Size base for length codes 257..285\\n        uint16[29] memory lens =\\n            [\\n                3,\\n                4,\\n                5,\\n                6,\\n                7,\\n                8,\\n                9,\\n                10,\\n                11,\\n                13,\\n                15,\\n                17,\\n                19,\\n                23,\\n                27,\\n                31,\\n                35,\\n                43,\\n                51,\\n                59,\\n                67,\\n                83,\\n                99,\\n                115,\\n                131,\\n                163,\\n                195,\\n                227,\\n                258\\n            ];\\n        // Extra bits for length codes 257..285\\n        uint8[29] memory lext =\\n            [\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                1,\\n                1,\\n                2,\\n                2,\\n                2,\\n                2,\\n                3,\\n                3,\\n                3,\\n                3,\\n                4,\\n                4,\\n                4,\\n                4,\\n                5,\\n                5,\\n                5,\\n                5,\\n                0\\n            ];\\n        // Offset base for distance codes 0..29\\n        uint16[30] memory dists =\\n            [\\n                1,\\n                2,\\n                3,\\n                4,\\n                5,\\n                7,\\n                9,\\n                13,\\n                17,\\n                25,\\n                33,\\n                49,\\n                65,\\n                97,\\n                129,\\n                193,\\n                257,\\n                385,\\n                513,\\n                769,\\n                1025,\\n                1537,\\n                2049,\\n                3073,\\n                4097,\\n                6145,\\n                8193,\\n                12289,\\n                16385,\\n                24577\\n            ];\\n        // Extra bits for distance codes 0..29\\n        uint8[30] memory dext =\\n            [\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                2,\\n                2,\\n                3,\\n                3,\\n                4,\\n                4,\\n                5,\\n                5,\\n                6,\\n                6,\\n                7,\\n                7,\\n                8,\\n                8,\\n                9,\\n                9,\\n                10,\\n                10,\\n                11,\\n                11,\\n                12,\\n                12,\\n                13,\\n                13\\n            ];\\n        // Error code\\n        ErrorCode err;\\n\\n        // Decode literals and length/distance pairs\\n        while (symbol != 256) {\\n            (err, symbol) = _decode(s, lencode);\\n            if (err != ErrorCode.ERR_NONE) {\\n                // Invalid symbol\\n                return err;\\n            }\\n\\n            if (symbol < 256) {\\n                // Literal: symbol is the byte\\n                // Write out the literal\\n                if (s.outcnt == s.output.length) {\\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                }\\n                s.output[s.outcnt] = bytes1(uint8(symbol));\\n                s.outcnt++;\\n            } else if (symbol > 256) {\\n                uint256 tempBits;\\n                // Length\\n                // Get and compute length\\n                symbol -= 257;\\n                if (symbol >= 29) {\\n                    // Invalid fixed code\\n                    return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\\n                }\\n\\n                (err, tempBits) = bits(s, lext[symbol]);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return err;\\n                }\\n                len = lens[symbol] + tempBits;\\n\\n                // Get and check distance\\n                (err, symbol) = _decode(s, distcode);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Invalid symbol\\n                    return err;\\n                }\\n                (err, tempBits) = bits(s, dext[symbol]);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return err;\\n                }\\n                dist = dists[symbol] + tempBits;\\n                if (dist > s.outcnt) {\\n                    // Distance too far back\\n                    return ErrorCode.ERR_DISTANCE_TOO_FAR;\\n                }\\n\\n                // Copy length bytes from distance bytes back\\n                if (s.outcnt + len > s.output.length) {\\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                }\\n                while (len != 0) {\\n                    // Note: Solidity reverts on underflow, so we decrement here\\n                    len -= 1;\\n                    s.output[s.outcnt] = s.output[s.outcnt - dist];\\n                    s.outcnt++;\\n                }\\n            } else {\\n                s.outcnt += len;\\n            }\\n        }\\n\\n        // Done with a valid fixed or dynamic block\\n        return ErrorCode.ERR_NONE;\\n    }\\n\\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\\n        // Build fixed Huffman tables\\n        // TODO this is all a compile-time constant\\n        uint256 symbol;\\n        uint256[] memory lengths = new uint256[](FIXLCODES);\\n\\n        // Literal/length table\\n        for (symbol = 0; symbol < 144; symbol++) {\\n            lengths[symbol] = 8;\\n        }\\n        for (; symbol < 256; symbol++) {\\n            lengths[symbol] = 9;\\n        }\\n        for (; symbol < 280; symbol++) {\\n            lengths[symbol] = 7;\\n        }\\n        for (; symbol < FIXLCODES; symbol++) {\\n            lengths[symbol] = 8;\\n        }\\n\\n        _construct(s.lencode, lengths, FIXLCODES, 0);\\n\\n        // Distance table\\n        for (symbol = 0; symbol < MAXDCODES; symbol++) {\\n            lengths[symbol] = 5;\\n        }\\n\\n        _construct(s.distcode, lengths, MAXDCODES, 0);\\n\\n        return ErrorCode.ERR_NONE;\\n    }\\n\\n    function _fixed(State memory s) private pure returns (ErrorCode) {\\n        // Decode data until end-of-block code\\n        return _codes(s, s.lencode, s.distcode);\\n    }\\n\\n    function _build_dynamic_lengths(State memory s)\\n        private\\n        pure\\n        returns (ErrorCode, uint256[] memory)\\n    {\\n        uint256 ncode;\\n        // Index of lengths[]\\n        uint256 index;\\n        // Descriptor code lengths\\n        uint256[] memory lengths = new uint256[](MAXCODES);\\n        // Error code\\n        ErrorCode err;\\n        // Permutation of code length codes\\n        uint8[19] memory order =\\n            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\\n\\n        (err, ncode) = bits(s, 4);\\n        if (err != ErrorCode.ERR_NONE) {\\n            return (err, lengths);\\n        }\\n        ncode += 4;\\n\\n        // Read code length code lengths (really), missing lengths are zero\\n        for (index = 0; index < ncode; index++) {\\n            (err, lengths[order[index]]) = bits(s, 3);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lengths);\\n            }\\n        }\\n        for (; index < 19; index++) {\\n            lengths[order[index]] = 0;\\n        }\\n\\n        return (ErrorCode.ERR_NONE, lengths);\\n    }\\n\\n    function _build_dynamic(State memory s)\\n        private\\n        pure\\n        returns (\\n            ErrorCode,\\n            Huffman memory,\\n            Huffman memory\\n        )\\n    {\\n        // Number of lengths in descriptor\\n        uint256 nlen;\\n        uint256 ndist;\\n        // Index of lengths[]\\n        uint256 index;\\n        // Error code\\n        ErrorCode err;\\n        // Descriptor code lengths\\n        uint256[] memory lengths = new uint256[](MAXCODES);\\n        // Length and distance codes\\n        Huffman memory lencode =\\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\\n        Huffman memory distcode =\\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\\n        uint256 tempBits;\\n\\n        // Get number of lengths in each table, check lengths\\n        (err, nlen) = bits(s, 5);\\n        if (err != ErrorCode.ERR_NONE) {\\n            return (err, lencode, distcode);\\n        }\\n        nlen += 257;\\n        (err, ndist) = bits(s, 5);\\n        if (err != ErrorCode.ERR_NONE) {\\n            return (err, lencode, distcode);\\n        }\\n        ndist += 1;\\n\\n        if (nlen > MAXLCODES || ndist > MAXDCODES) {\\n            // Bad counts\\n            return (\\n                ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES,\\n                lencode,\\n                distcode\\n            );\\n        }\\n\\n        (err, lengths) = _build_dynamic_lengths(s);\\n        if (err != ErrorCode.ERR_NONE) {\\n            return (err, lencode, distcode);\\n        }\\n\\n        // Build huffman table for code lengths codes (use lencode temporarily)\\n        err = _construct(lencode, lengths, 19, 0);\\n        if (err != ErrorCode.ERR_NONE) {\\n            // Require complete code set here\\n            return (\\n                ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE,\\n                lencode,\\n                distcode\\n            );\\n        }\\n\\n        // Read length/literal and distance code length tables\\n        index = 0;\\n        while (index < nlen + ndist) {\\n            // Decoded value\\n            uint256 symbol;\\n            // Last length to repeat\\n            uint256 len;\\n\\n            (err, symbol) = _decode(s, lencode);\\n            if (err != ErrorCode.ERR_NONE) {\\n                // Invalid symbol\\n                return (err, lencode, distcode);\\n            }\\n\\n            if (symbol < 16) {\\n                // Length in 0..15\\n                lengths[index++] = symbol;\\n            } else {\\n                // Repeat instruction\\n                // Assume repeating zeros\\n                len = 0;\\n                if (symbol == 16) {\\n                    // Repeat last length 3..6 times\\n                    if (index == 0) {\\n                        // No last length!\\n                        return (\\n                            ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH,\\n                            lencode,\\n                            distcode\\n                        );\\n                    }\\n                    // Last length\\n                    len = lengths[index - 1];\\n                    (err, tempBits) = bits(s, 2);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        return (err, lencode, distcode);\\n                    }\\n                    symbol = 3 + tempBits;\\n                } else if (symbol == 17) {\\n                    // Repeat zero 3..10 times\\n                    (err, tempBits) = bits(s, 3);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        return (err, lencode, distcode);\\n                    }\\n                    symbol = 3 + tempBits;\\n                } else {\\n                    // == 18, repeat zero 11..138 times\\n                    (err, tempBits) = bits(s, 7);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        return (err, lencode, distcode);\\n                    }\\n                    symbol = 11 + tempBits;\\n                }\\n\\n                if (index + symbol > nlen + ndist) {\\n                    // Too many lengths!\\n                    return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\\n                }\\n                while (symbol != 0) {\\n                    // Note: Solidity reverts on underflow, so we decrement here\\n                    symbol -= 1;\\n\\n                    // Repeat last or zero symbol times\\n                    lengths[index++] = len;\\n                }\\n            }\\n        }\\n\\n        // Check for end-of-block code -- there better be one!\\n        if (lengths[256] == 0) {\\n            return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\\n        }\\n\\n        // Build huffman table for literal/length codes\\n        err = _construct(lencode, lengths, nlen, 0);\\n        if (\\n            err != ErrorCode.ERR_NONE &&\\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                nlen != lencode.counts[0] + lencode.counts[1])\\n        ) {\\n            // Incomplete code ok only for single length 1 code\\n            return (\\n                ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS,\\n                lencode,\\n                distcode\\n            );\\n        }\\n\\n        // Build huffman table for distance codes\\n        err = _construct(distcode, lengths, ndist, nlen);\\n        if (\\n            err != ErrorCode.ERR_NONE &&\\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                ndist != distcode.counts[0] + distcode.counts[1])\\n        ) {\\n            // Incomplete code ok only for single length 1 code\\n            return (\\n                ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS,\\n                lencode,\\n                distcode\\n            );\\n        }\\n\\n        return (ErrorCode.ERR_NONE, lencode, distcode);\\n    }\\n\\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\\n        // Length and distance codes\\n        Huffman memory lencode;\\n        Huffman memory distcode;\\n        // Error code\\n        ErrorCode err;\\n\\n        (err, lencode, distcode) = _build_dynamic(s);\\n        if (err != ErrorCode.ERR_NONE) {\\n            return err;\\n        }\\n\\n        // Decode data until end-of-block code\\n        return _codes(s, lencode, distcode);\\n    }\\n\\n    function puff(bytes memory source, uint256 destlen)\\n        internal\\n        pure\\n        returns (ErrorCode, bytes memory)\\n    {\\n        // Input/output state\\n        State memory s =\\n            State(\\n                new bytes(destlen),\\n                0,\\n                source,\\n                0,\\n                0,\\n                0,\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\\n            );\\n        // Temp: last bit\\n        uint256 last;\\n        // Temp: block type bit\\n        uint256 t;\\n        // Error code\\n        ErrorCode err;\\n\\n        // Build fixed Huffman tables\\n        err = _build_fixed(s);\\n        if (err != ErrorCode.ERR_NONE) {\\n            return (err, s.output);\\n        }\\n\\n        // Process blocks until last block or error\\n        while (last == 0) {\\n            // One if last block\\n            (err, last) = bits(s, 1);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, s.output);\\n            }\\n\\n            // Block type 0..3\\n            (err, t) = bits(s, 2);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, s.output);\\n            }\\n\\n            err = (\\n                t == 0\\n                    ? _stored(s)\\n                    : (\\n                        t == 1\\n                            ? _fixed(s)\\n                            : (\\n                                t == 2\\n                                    ? _dynamic(s)\\n                                    : ErrorCode.ERR_INVALID_BLOCK_TYPE\\n                            )\\n                    )\\n            );\\n            // type == 3, invalid\\n\\n            if (err != ErrorCode.ERR_NONE) {\\n                // Return with error\\n                break;\\n            }\\n        }\\n\\n        return (err, s.output);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ICourierFont\",\"name\":\"fontAddress\",\"type\":\"address\"},{\"internalType\":\"contract GmDataInterface\",\"name\":\"gmData1Address\",\"type\":\"address\"},{\"internalType\":\"contract GmDataInterface\",\"name\":\"gmData2Address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"imageName\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"compressedImage\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"compressedSize\",\"type\":\"uint256\"}],\"internalType\":\"struct GmDataInterface.GmDataSet\",\"name\":\"gmData\",\"type\":\"tuple\"}],\"name\":\"decompress\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"svgRaw\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GmRenderer","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"0000000000000000000000004f58ee8f0ed85d8e02fd8a33ebc8122433bf6112000000000000000000000000944bbd7e287c74a6eab7d3c9aaad0707301fe036000000000000000000000000e643991873f308bb35e8fa39928bf8af4bd85386","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}