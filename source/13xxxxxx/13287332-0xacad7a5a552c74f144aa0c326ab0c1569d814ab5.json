{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/XPNUtils.sol\": {\r\n      \"content\": \"// Copyright (C) 2021 Exponent\\n\\n// This file is part of Exponent.\\n\\n// Exponent is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// Exponent is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with Exponent.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.0;\\nimport \\\"./interface/AggregatorV3Interface.sol\\\";\\nimport \\\"./interface/enzyme/IComptroller.sol\\\";\\nimport \\\"./interface/enzyme/IPolicyManager.sol\\\";\\n\\nlibrary XPNUtils {\\n    int256 public constant ONE = 1e18;\\n    int256 public constant chainlinkONE = 1e8;\\n    // @notice enzyme fees ID for fees invocation\\n    uint256 constant FEE_INVOCATION = 0;\\n    // @notice enzyme fees ID for fees payout\\n    uint256 constant FEE_PAYOUT = 0;\\n    // @notice enzyme ID for removing tracked asset\\n    uint256 constant REMOVE_TRACKED = 2;\\n    // @notice enzyme ID for adding tracked asset\\n    uint256 constant ADD_TRACKED = 1;\\n\\n    function compareStrings(string memory first, string memory second)\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return (keccak256(abi.encodePacked((first))) ==\\n            keccak256(abi.encodePacked((second))));\\n    }\\n\\n    function parseChainlinkPrice(address _feed) external view returns (int256) {\\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(_feed);\\n        (\\n            uint80 roundID,\\n            int256 price,\\n            ,\\n            uint256 timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n\\n        require(timeStamp != 0, \\\"Chainlink: round is not complete\\\");\\n        require(answeredInRound >= roundID, \\\"Chainlink: stale data\\\");\\n        require(price != 0, \\\"Chainlink: returned 0\\\");\\n        int256 priceScaled = (price * ONE) / int256(10)**priceFeed.decimals();\\n        return priceScaled;\\n    }\\n\\n    function buyEnzymeShares(address _comptroller, uint256 _amount)\\n        external\\n        returns (uint256)\\n    {\\n        address[] memory buyer = new address[](1);\\n        uint256[] memory amount = new uint256[](1);\\n        uint256[] memory expect = new uint256[](1);\\n        buyer[0] = address(this);\\n        amount[0] = _amount;\\n        expect[0] = 1;\\n        uint256[] memory sharesBought = IComptroller(_comptroller).buyShares(\\n            buyer, // this contract as a single buyer\\n            amount, // amount of shares to purchase\\n            expect // expect at least 1 share\\n        );\\n        return sharesBought[0]; // should have bought only a single share amount\\n    }\\n\\n    function redeemEnzymeShares(address _comptroller, uint256 _amount)\\n        external\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        address[] memory additionalAssets = new address[](0);\\n        address[] memory assetsToSkip = new address[](0);\\n        return\\n            IComptroller(_comptroller).redeemSharesDetailed(\\n                _amount, // quantity of shares to redeem\\n                additionalAssets, // no additional assets\\n                assetsToSkip // don't skip any assets\\n            );\\n    }\\n\\n    // @dev performs 2 actions: settle current fee on Enzyme vault and mint\\n    //      new shares to vault owner representing accrued fees\\n    function invokeAndPayoutEnzymeFees(\\n        address _comptroller,\\n        address _feeManager,\\n        address[] memory _fees\\n    ) external {\\n        // calculate and settle the current fees accrued on the fund\\n        IComptroller(_comptroller).callOnExtension(\\n            _feeManager,\\n            FEE_INVOCATION, // 0 is action ID for invoking fees\\n            \\\"\\\"\\n        );\\n        // payout the outstanding shares to enzyme vault owner (this contract)\\n        IComptroller(_comptroller).callOnExtension(\\n            _feeManager,\\n            FEE_PAYOUT, // 1 is action ID for payout of outstanding shares\\n            abi.encode(_fees) // payout using all the fees available ie. performance and management fee\\n        );\\n    }\\n\\n    // @notice declare self as the sole depositor of the enzyme vault contract\\n    // @dev address(this) is called in the execution context of the caller\\n    function enforceSoleEnzymeDepositor(\\n        address _comptroller,\\n        address _policyManager,\\n        address _whitelistPolicy\\n    ) external {\\n        address[] memory buyersToAdd = new address[](1);\\n        address[] memory buyersToRemove = new address[](0);\\n        buyersToAdd[0] = address(this);\\n\\n        IPolicyManager(_policyManager).enablePolicyForFund(\\n            _comptroller,\\n            _whitelistPolicy,\\n            abi.encode(buyersToAdd, buyersToRemove)\\n        );\\n    }\\n\\n    function addEnzymeTrackedAsset(\\n        address _comptroller,\\n        address _integrationManager,\\n        address _asset\\n    ) external {\\n        address[] memory assets = new address[](1);\\n        assets[0] = _asset;\\n        bytes memory addTrackedArgs = abi.encode(assets);\\n        IComptroller(_comptroller).callOnExtension(\\n            _integrationManager,\\n            ADD_TRACKED,\\n            abi.encode(assets)\\n        );\\n    }\\n\\n    function removeEnzymeTrackedAsset(\\n        address _comptroller,\\n        address _integrationManager,\\n        address _asset\\n    ) external {\\n        address[] memory assets = new address[](1);\\n        assets[0] = _asset;\\n        bytes memory removeTrackedArgs = abi.encode(assets);\\n        IComptroller(_comptroller).callOnExtension(\\n            _integrationManager,\\n            REMOVE_TRACKED,\\n            abi.encode(assets)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interface/enzyme/IComptroller.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.0;\\n\\ninterface IComptroller {\\n    function buyShares(\\n        address[] calldata,\\n        uint256[] calldata,\\n        uint256[] calldata\\n    ) external returns (uint256[] memory sharesReceivedAmounts_);\\n\\n    function redeemSharesDetailed(\\n        uint256,\\n        address[] calldata,\\n        address[] calldata\\n    ) external returns (address[] memory, uint256[] memory);\\n\\n    function callOnExtension(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/enzyme/IPolicyManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.0;\\n\\ninterface IPolicyManager {\\n    function enablePolicyForFund(\\n        address,\\n        address,\\n        bytes calldata\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkONE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"first\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"second\",\"type\":\"string\"}],\"name\":\"compareStrings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feed\",\"type\":\"address\"}],\"name\":\"parseChainlinkPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"XPNUtils","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"50","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}