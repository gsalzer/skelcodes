{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PendlePoolsReadWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n\\ninterface IERC20 {\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface PendleYieldToken is IERC20 {\\n    function expiry() external view returns (uint256);\\n}\\n\\ninterface PendleMarket is IERC20 {\\n    function expiry() external view returns (uint256);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint256 xytBalance,\\n            uint256 xytWeight,\\n            uint256 tokenBalance,\\n            uint256 tokenWeight,\\n            uint256 currentBlock\\n        );\\n\\n    function token() external view returns (address);\\n\\n    function xyt() external view returns (address);\\n}\\n\\ninterface SushiSwapPool is IERC20 {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        );\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n}\\n\\ninterface PendleLiquidityMining {\\n    function allocationSettings(uint256 epochId, uint256 expiry) external view returns (uint256);\\n\\n    function balances(address user) external view returns (uint256);\\n\\n    function epochDuration() external view returns (uint256);\\n\\n    function getBalances(uint256 expiry, address user) external view returns (uint256);\\n\\n    function numberOfEpochs() external view returns (uint256);\\n\\n    function readEpochData(uint256 epochId, address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalStakeUnits,\\n            uint256 totalRewards,\\n            uint256 lastUpdated,\\n            uint256 stakeUnitsForUser,\\n            uint256 availableRewardsForUser\\n        );\\n\\n    function readExpiryData(uint256 expiry)\\n        external\\n        view\\n        returns (\\n            uint256 totalStakeLP,\\n            uint256 lastNYield,\\n            uint256 paramL,\\n            address lpHolder\\n        );\\n\\n    function startTime() external view returns (uint256);\\n\\n    function latestSetting() external view returns (uint256 id, uint256 firstEpochToApply);\\n\\n    function totalRewardsForEpoch(uint256 epochId) external view returns (uint256 rewards);\\n}\\n\\ninterface PendleSingleStaking {\\n    function balances(address account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface PendleSingleStakingManager {\\n    function rewardPerBlock() external view returns (uint256);\\n}\\n\\ninterface PendleLiquidityRewardsProxy {\\n    function redeemAndCalculateAccruing(\\n        address liqMining,\\n        uint256 expiry,\\n        address user\\n    )\\n        external\\n        returns (\\n            uint256 userStakeUnits,\\n            uint256 userStake,\\n            uint256 totalStakeUnits,\\n            uint256 totalStake,\\n            uint256 userTentativeReward\\n        );\\n    \\n    function redeemAndCalculateAccruingV2(\\n        address liqMiningV2,\\n        address user\\n    )\\n        external\\n        returns (\\n            uint256 userStakeUnits,\\n            uint256 userStake,\\n            uint256 totalStakeUnits,\\n            uint256 totalStake,\\n            uint256 userTentativeReward\\n        );\\n\\n    function redeemAndCalculateVested(\\n        address liqMiningContract,\\n        uint256[] calldata expiries,\\n        address user\\n    )\\n        external\\n        returns (\\n            uint256 rewards,\\n            uint256[] memory vestedRewards,\\n            uint256 currentEpoch\\n        );\\n\\n    function redeemAndCalculateVestedV2(\\n        address liqMiningContractV2,\\n        address user\\n    )\\n        external\\n        returns (\\n            uint256 rewards,\\n            uint256[] memory vestedRewards,\\n            uint256 currentEpoch\\n        );\\n}\\n\\ncontract PendlePoolsReadWrapper {\\n    using SafeMath for uint256;\\n\\n    enum Type {\\n        PendleMarket,\\n        SushiSwapPool\\n    }\\n\\n    struct Reserves {\\n        uint256 ytotBalance;\\n        uint256 ytotWeight;\\n        uint256 tokenBalance;\\n        uint256 tokenWeight;\\n    }\\n\\n    address constant public SUSHISWAP_MASTERCHEF = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd;\\n\\n    function tokenApprove(\\n        IERC20 _token,\\n        address _staking,\\n        uint256 _allowance\\n    ) public {\\n        _token.approve(_staking, _allowance);\\n    }\\n\\n    function claim(\\n        PendleLiquidityRewardsProxy _rewardsProxy,\\n        address _liqMining,\\n        uint256 _expiry,\\n        address _user,\\n        Type _type\\n    )\\n        public\\n        returns (\\n            uint256 accruingRewards,\\n            uint256[] memory vestedRewards\\n        )\\n    {\\n        if (_type == Type.PendleMarket) {\\n            uint256[] memory expiry = new uint256[](1);\\n            expiry[0] = _expiry;\\n\\n            ( , , , , accruingRewards) = _rewardsProxy.redeemAndCalculateAccruing(\\n                _liqMining,\\n                _expiry,\\n                _user\\n            );\\n\\n            (, vestedRewards, ) = _rewardsProxy.redeemAndCalculateVested(\\n                _liqMining,\\n                expiry,\\n                _user\\n            );\\n        } else if (_type == Type.SushiSwapPool) {\\n            uint256[] memory expiry = new uint256[](1);\\n            expiry[0] = _expiry;\\n\\n            ( , , , , accruingRewards) = _rewardsProxy.redeemAndCalculateAccruingV2(\\n                _liqMining,\\n                _user\\n            );\\n\\n            (, vestedRewards, ) = _rewardsProxy.redeemAndCalculateVestedV2(\\n                _liqMining,\\n                _user\\n            );\\n        } else {\\n            revert(\\\"invalid type\\\");\\n        }\\n    }\\n\\n    function getLiquidityMiningInfo(\\n        address _poolOrMarket,\\n        PendleLiquidityMining _staking,\\n        Type _type\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 expiry,\\n            string memory marketSymbol,\\n            string memory tokenSymbol,\\n            uint256 lpTotalSupply,\\n            uint256 totalStakeLP,\\n            uint256 totalRewards,\\n            uint8 tokenDecimals,\\n            uint8 xytDecimals,\\n            Reserves memory reserves\\n        )\\n    {\\n        if (_type == Type.PendleMarket) {\\n            (tokenSymbol, tokenDecimals, xytDecimals, expiry) = _getYTTokenInfo(_poolOrMarket);\\n            reserves = _getYTReserves(_poolOrMarket);\\n            marketSymbol = PendleMarket(_poolOrMarket).symbol();\\n            lpTotalSupply = PendleMarket(_poolOrMarket).totalSupply();\\n\\n            (totalStakeLP, , , ) = _staking.readExpiryData(expiry);\\n            (uint256 latestSettingId, ) = _staking.latestSetting();\\n            uint256 allocationSettings = _staking.allocationSettings(latestSettingId, expiry);\\n            uint256 currentEpoch = _epochOfTimestamp(block.timestamp, _staking);\\n            totalRewards =\\n                allocationSettings.mul(_staking.totalRewardsForEpoch(currentEpoch)) /\\n                1e9;\\n        } else if (_type == Type.SushiSwapPool) {\\n            (tokenSymbol, tokenDecimals, xytDecimals, expiry) = _getOTTokenInfo(_poolOrMarket);\\n            reserves = _getOTReserves(_poolOrMarket);\\n            marketSymbol = SushiSwapPool(_poolOrMarket).symbol();\\n            lpTotalSupply = SushiSwapPool(_poolOrMarket).totalSupply();\\n\\n            uint256 epoch = _epochOfTimestamp(block.timestamp, _staking);\\n            totalStakeLP = IERC20(_poolOrMarket).balanceOf(address(_staking));\\n            if (totalStakeLP == 0) { // If the LP is staked in SushiSwap MasterChef\\n              totalStakeLP = IERC20(_poolOrMarket).balanceOf(SUSHISWAP_MASTERCHEF);\\n            }\\n            (, totalRewards, , , ) = _staking.readEpochData(epoch, address(0));\\n        } else {\\n            revert(\\\"invalid type\\\");\\n        }\\n    }\\n\\n    function getStakingInfo(\\n        PendleYieldToken _pool,\\n        PendleLiquidityMining _staking,\\n        address _user,\\n        Type _type\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 expiry,\\n            uint256 numberOfEpochs,\\n            uint256 epochDuration,\\n            uint256 userStaked,\\n            uint256 userAvailableToStake,\\n            uint256 userAllowance\\n        )\\n    {\\n        if (_type == Type.PendleMarket) {\\n            expiry = _pool.expiry();\\n        } else if (_type == Type.SushiSwapPool) {\\n            address token0 = SushiSwapPool(address(_pool)).token0();\\n            address token1 = SushiSwapPool(address(_pool)).token1();\\n\\n            try PendleYieldToken(token0).expiry() returns (uint256 _expiry) {\\n                expiry = _expiry;\\n            } catch {\\n                expiry = PendleYieldToken(token1).expiry();\\n            }\\n        } else {\\n            revert(\\\"invalid type\\\");\\n        }\\n\\n        numberOfEpochs = _staking.numberOfEpochs();\\n        epochDuration = _staking.epochDuration();\\n\\n        try _staking.getBalances(expiry, _user) returns (uint256 res) {\\n            userStaked = res;\\n        } catch {\\n            userStaked = _staking.balances(_user);\\n        }\\n\\n        userAvailableToStake = _pool.balanceOf(_user);\\n        userAllowance = _pool.allowance(_user, address(_staking));\\n    }\\n\\n    function getSingleStakingInfo(\\n        PendleSingleStaking _staking,\\n        PendleSingleStakingManager _manager,\\n        IERC20 _pendle,\\n        address _user\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 totalSupply,\\n            uint256 rewardPerBlock,\\n            uint256 userAvailableToStake,\\n            uint256 userAllowance,\\n            uint256 userShare\\n        )\\n    {\\n        totalSupply = _staking.totalSupply();\\n        rewardPerBlock = _manager.rewardPerBlock();\\n        userAvailableToStake = _pendle.balanceOf(_user);\\n        userAllowance = _pendle.allowance(_user, address(_staking));\\n        userShare = _staking.balances(_user);\\n    }\\n\\n    function _epochOfTimestamp(uint256 _t, PendleLiquidityMining _lm)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return (_t.sub(_lm.startTime())).div(_lm.epochDuration()).add(1);\\n    }\\n\\n    function _getYTTokenInfo(address _market)\\n        internal\\n        view\\n        returns (\\n            string memory tokenSymbol,\\n            uint8 tokenDecimals,\\n            uint8 ytotDecimals,\\n            uint256 expiry\\n        )\\n    {\\n        IERC20 token = IERC20(PendleMarket(_market).token());\\n        IERC20 xyt = IERC20(PendleMarket(_market).xyt());\\n\\n        tokenSymbol = token.symbol();\\n        tokenDecimals = token.decimals();\\n        ytotDecimals = xyt.decimals();\\n        expiry = PendleMarket(_market).expiry();\\n    }\\n\\n    function _getOTTokenInfo(address _pool)\\n        internal\\n        view\\n        returns (\\n            string memory tokenSymbol,\\n            uint8 tokenDecimals,\\n            uint8 ytotDecimals,\\n            uint256 expiry\\n        )\\n    {\\n        address token0 = SushiSwapPool(address(_pool)).token0();\\n        address token1 = SushiSwapPool(address(_pool)).token1();\\n        PendleYieldToken ot;\\n        IERC20 token;\\n\\n        try PendleYieldToken(token0).expiry() returns (uint256 _expiry) {\\n            expiry = _expiry;\\n            ot = PendleYieldToken(SushiSwapPool(_pool).token0());\\n            token = IERC20(SushiSwapPool(_pool).token1());\\n        } catch {\\n            expiry = PendleYieldToken(token1).expiry();\\n            ot = PendleYieldToken(SushiSwapPool(_pool).token1());\\n            token = IERC20(SushiSwapPool(_pool).token0());\\n        }\\n\\n        tokenSymbol = token.symbol();\\n        tokenDecimals = token.decimals();\\n        ytotDecimals = ot.decimals();\\n    }\\n\\n    function _getYTReserves(address _market) internal view returns (Reserves memory reserves) {\\n        (\\n            uint256 xytBalance,\\n            uint256 xytWeight,\\n            uint256 tokenBalance,\\n            uint256 tokenWeight,\\n\\n        ) = PendleMarket(_market).getReserves();\\n        reserves.ytotBalance = xytBalance;\\n        reserves.ytotWeight = xytWeight;\\n        reserves.tokenBalance = tokenBalance;\\n        reserves.tokenWeight = tokenWeight;\\n    }\\n\\n    function _getOTReserves(address _pool) internal view returns (Reserves memory reserves) {\\n        uint256 reserve0;\\n        uint256 reserve1;\\n        bool token0IsYT = false;\\n        address token0 = SushiSwapPool(_pool).token0();\\n\\n        try PendleYieldToken(token0).expiry() {\\n            token0IsYT = true;\\n        } catch {}\\n\\n        if (token0IsYT) {\\n            (reserve0, reserve1, ) = SushiSwapPool(_pool).getReserves();\\n        } else {\\n            (reserve1, reserve0, ) = SushiSwapPool(_pool).getReserves();\\n        }\\n\\n        reserves.ytotBalance = reserve0;\\n        reserves.ytotWeight = (uint256(1) << 40) / 2;\\n        reserves.tokenBalance = reserve1;\\n        reserves.tokenWeight = reserves.ytotWeight;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"SUSHISWAP_MASTERCHEF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PendleLiquidityRewardsProxy\",\"name\":\"_rewardsProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liqMining\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"enum PendlePoolsReadWrapper.Type\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accruingRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"vestedRewards\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolOrMarket\",\"type\":\"address\"},{\"internalType\":\"contract PendleLiquidityMining\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"enum PendlePoolsReadWrapper.Type\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getLiquidityMiningInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"marketSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"xytDecimals\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ytotBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ytotWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeight\",\"type\":\"uint256\"}],\"internalType\":\"struct PendlePoolsReadWrapper.Reserves\",\"name\":\"reserves\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PendleSingleStaking\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"contract PendleSingleStakingManager\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_pendle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getSingleStakingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAvailableToStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PendleYieldToken\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"contract PendleLiquidityMining\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"enum PendlePoolsReadWrapper.Type\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getStakingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfEpochs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAvailableToStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAllowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allowance\",\"type\":\"uint256\"}],\"name\":\"tokenApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PendlePoolsReadWrapper","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"15000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}