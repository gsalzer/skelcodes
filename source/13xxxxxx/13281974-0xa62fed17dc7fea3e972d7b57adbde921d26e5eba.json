{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, throws on overflow.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface FungibleChromaInterface {\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    function burn(address account, uint256 amount) external;\r\n}\r\n\r\ncontract Chroma is IERC721 {\r\n    using SafeMath for uint256;\r\n\r\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    uint256 public numTokens;\r\n\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n    mapping(uint256 => address) public idToOwner;\r\n    mapping(uint256 => address) internal idToApproval;\r\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\r\n    mapping(address => uint256[]) public ownerToIds;\r\n    mapping(uint256 => uint256) public idToOwnerIndex;\r\n\r\n    string internal nftName = \"Chroma\";\r\n    string internal nftSymbol = unicode\"â– \";\r\n\r\n    bool private reentrancyLock = false;\r\n\r\n    /* Prevent a contract function from being reentrant-called. */\r\n    modifier reentrancyGuard() {\r\n        if (reentrancyLock) {\r\n            revert();\r\n        }\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender ||\r\n                idToApproval[_tokenId] == msg.sender ||\r\n                ownerToOperators[tokenOwner][msg.sender],\r\n            \"Cannot transfer.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender ||\r\n                ownerToOperators[tokenOwner][msg.sender],\r\n            \"Cannot operate.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0), \"Invalid token.\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _adminAddress) {\r\n        adminAddress = _adminAddress;\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\r\n    }\r\n\r\n    function _mintNFT(\r\n        address _recipient,\r\n        uint256 red,\r\n        uint256 green,\r\n        uint256 blue\r\n    ) internal {\r\n        _addNFToken(_recipient, _RGBToId(red, green, blue));\r\n    }\r\n\r\n    function _addNFToken(address _to, uint256 _tokenId) internal {\r\n        require(\r\n            idToOwner[_tokenId] == address(0),\r\n            \"Cannot add, already owned.\"\r\n        );\r\n        idToOwner[_tokenId] = _to;\r\n        ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);\r\n    }\r\n\r\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from, \"Incorrect owner.\");\r\n        delete idToOwner[_tokenId];\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex) {\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n\r\n        ownerToIds[_from].pop();\r\n    }\r\n\r\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\r\n        return ownerToIds[_owner].length;\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Incorrect owner.\");\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\r\n                msg.sender,\r\n                _from,\r\n                _tokenId,\r\n                _data\r\n            );\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    function _clearApproval(uint256 _tokenId) private {\r\n        if (idToApproval[_tokenId] != address(0)) {\r\n            delete idToApproval[_tokenId];\r\n        }\r\n    }\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexDigit(uint8 d) internal pure returns (bytes1) {\r\n        if (0 <= d && d <= 9) {\r\n            return bytes1(uint8(bytes1(\"0\")) + d);\r\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\r\n            return bytes1(uint8(bytes1(\"a\")) + d - 10);\r\n        }\r\n        // revert(\"Invalid hex digit\");\r\n        revert();\r\n    }\r\n\r\n    function toHexString(uint256 a) public pure returns (string memory) {\r\n        uint256 count = 2;\r\n        uint256 b = a;\r\n\r\n        bytes memory res = new bytes(count);\r\n        for (uint256 i = 0; i < count; ++i) {\r\n            b = a % 16;\r\n            res[count - i - 1] = toHexDigit(uint8(b));\r\n            a /= 16;\r\n        }\r\n        return string(res);\r\n    }\r\n\r\n    function _toHex(uint256 _id) internal pure returns (string memory) {\r\n        string memory r = toHexString(idToRed(_id));\r\n        string memory g = toHexString(idToGreen(_id));\r\n        string memory b = toHexString(idToBlue(_id));\r\n        return string(abi.encodePacked(r, g, b));\r\n    }\r\n\r\n    function toHex(uint256 _id) external pure returns (string memory) {\r\n        return _toHex(_id);\r\n    }\r\n\r\n    function getData(uint256 _id) external pure returns (string memory) {\r\n        return _toHex(_id);\r\n    }\r\n\r\n    function toRGBString(uint256 _id) public pure returns (string memory) {\r\n        string memory r = toString(idToRed(_id));\r\n        string memory g = toString(idToGreen(_id));\r\n        string memory b = toString(idToBlue(_id));\r\n        return string(abi.encodePacked(\"rgb(\", r, \",\", g, \",\", b, \")\"));\r\n    }\r\n\r\n    function idToRed(uint256 _id) public pure returns (uint256) {\r\n        return _id >> 16;\r\n    }\r\n\r\n    function idToGreen(uint256 _id) public pure returns (uint256) {\r\n        return (_id & 0xffff) >> 8;\r\n    }\r\n\r\n    function idToBlue(uint256 _id) public pure returns (uint256) {\r\n        return _id & 0xff;\r\n    }\r\n\r\n    function _RGBToId(\r\n        uint256 red,\r\n        uint256 green,\r\n        uint256 blue\r\n    ) internal pure returns (uint256) {\r\n        return (red << 16) + (green << 8) + blue;\r\n    }\r\n\r\n    function RGBToId(\r\n        uint256 _red,\r\n        uint256 _green,\r\n        uint256 _blue\r\n    ) public pure returns (uint256) {\r\n        return _RGBToId(_red, _green, _blue);\r\n    }\r\n\r\n    //////////////////////////\r\n    ////    Enumerable    ////\r\n    //////////////////////////\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return numTokens;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_index < ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n    //////////////////////////\r\n    ////  Administration  ////\r\n    //////////////////////////\r\n    address payable public adminAddress;\r\n    address public chromaticPlotAddress;\r\n    address public fungibleChromaAddress;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Only admin.\");\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address payable _newAdmin) external onlyAdmin {\r\n        adminAddress = _newAdmin;\r\n    }\r\n\r\n    function setChromaticPlotAddress(address _chromaticPlotAddress)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        chromaticPlotAddress = _chromaticPlotAddress;\r\n    }\r\n\r\n    function setFungibleChromaAddress(address _fungibleChromaAddress)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        fungibleChromaAddress = _fungibleChromaAddress;\r\n    }\r\n\r\n    //////////////////////////\r\n    ////   Transmutation  ////\r\n    //////////////////////////\r\n    event PlotTransmutation(\r\n        address indexed transmuter,\r\n        uint256 index,\r\n        uint256 count,\r\n        uint256 blueStart,\r\n        uint256 red,\r\n        uint256 green\r\n    );\r\n\r\n    modifier onlyChromaticPlot() {\r\n        require(msg.sender == chromaticPlotAddress, \"Only Mint Plot.\");\r\n        _;\r\n    }\r\n\r\n    mapping(uint256 => uint256) public transmutationCount;\r\n\r\n    function transmutePlotToNFTs(\r\n        address _recipient,\r\n        uint256 _plotId,\r\n        uint256 _count\r\n    ) external onlyChromaticPlot returns (bool) {\r\n        return _transmute(_recipient, _plotId, _count);\r\n    }\r\n\r\n    function transmutePlotToERC20(\r\n        address _recipient,\r\n        uint256 _plotId,\r\n        uint256 _count\r\n    ) external onlyChromaticPlot returns (bool) {\r\n        bool complete = _transmute(address(this), _plotId, _count);\r\n        FungibleChromaInterface(fungibleChromaAddress).mint(_recipient, _count);\r\n        return complete;\r\n    }\r\n\r\n    function _transmute(\r\n        address _recipient,\r\n        uint256 _plotId,\r\n        uint256 _count\r\n    ) internal returns (bool) {\r\n        require(\r\n            transmutationCount[_plotId] + _count <= 256,\r\n            \"exceeds chroma remaining\"\r\n        );\r\n        require(\r\n            _count <= 128,\r\n            \"cannot transmute more than 128 chroma at a time\"\r\n        );\r\n\r\n        uint256 index = transmutationCount[_plotId];\r\n        transmutationCount[_plotId] += _count;\r\n\r\n        uint256 red = _plotId.div(256);\r\n        uint256 green = _plotId.mod(256);\r\n\r\n        emit PlotTransmutation(\r\n            _recipient,\r\n            numTokens,\r\n            _count,\r\n            index,\r\n            red,\r\n            green\r\n        );\r\n\r\n        for (uint256 blue = index; blue < index + _count; blue++) {\r\n            _mintNFT(_recipient, red, green, blue);\r\n        }\r\n        if (transmutationCount[_plotId] == 256) return true;\r\n\r\n        numTokens = numTokens + _count;\r\n        return false;\r\n    }\r\n\r\n    function transmuteSingleToNFT(uint256 _id) external reentrancyGuard {\r\n        require(\r\n            idToOwner[_id] == address(this),\r\n            \"token must be owned by sender\"\r\n        );\r\n        FungibleChromaInterface(fungibleChromaAddress).burn(msg.sender, 1);\r\n        _transfer(msg.sender, _id);\r\n    }\r\n\r\n    function transmuteMultipleToNFT(uint256[] calldata _ids)\r\n        external\r\n        reentrancyGuard\r\n    {\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            uint256 id = _ids[i];\r\n            require(\r\n                idToOwner[id] == address(this),\r\n                \"token must be owned by sender\"\r\n            );\r\n            _transfer(msg.sender, id);\r\n        }\r\n        FungibleChromaInterface(fungibleChromaAddress).burn(\r\n            msg.sender,\r\n            _ids.length\r\n        );\r\n    }\r\n\r\n    function transmuteSingleToERC20(uint256 _id) external reentrancyGuard {\r\n        require(idToOwner[_id] == msg.sender, \"token must be owned by sender\");\r\n        _transfer(address(this), _id);\r\n        FungibleChromaInterface(fungibleChromaAddress).mint(msg.sender, 1);\r\n    }\r\n\r\n    function transmuteMultipleToERC20(uint256[] calldata _ids)\r\n        external\r\n        reentrancyGuard\r\n    {\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            require(\r\n                idToOwner[_ids[i]] == msg.sender,\r\n                \"token must be owned by sender\"\r\n            );\r\n            _transfer(address(this), _ids[i]);\r\n        }\r\n        FungibleChromaInterface(fungibleChromaAddress).mint(\r\n            msg.sender,\r\n            _ids.length\r\n        );\r\n    }\r\n\r\n    //////////////////////////\r\n    //// ERC 721 and 165  ////\r\n    //////////////////////////\r\n\r\n    function isContract(address _addr)\r\n        internal\r\n        view\r\n        returns (bool addressCheck)\r\n    {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        } // solhint-disable-line\r\n        addressCheck = size > 0;\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Wrong from address.\");\r\n        require(_to != address(0), \"Cannot send to 0x0.\");\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId)\r\n        external\r\n        override\r\n        canOperate(_tokenId)\r\n        validNFToken(_tokenId)\r\n    {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        idToApproval[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved)\r\n        external\r\n        override\r\n    {\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(_owner != address(0));\r\n        return _getOwnerNFTCount(_owner);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address _owner)\r\n    {\r\n        require(idToOwner[_tokenId] != address(0));\r\n        _owner = idToOwner[_tokenId];\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        validNFToken(_tokenId)\r\n        returns (address)\r\n    {\r\n        return idToApproval[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        address from = idToOwner[_tokenId];\r\n        _clearApproval(_tokenId);\r\n\r\n        _removeNFToken(from, _tokenId);\r\n        _addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    function getOwnedTokenIds(address owner)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 length = ownerToIds[owner].length;\r\n        uint256[] memory owned = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            owned[i] = ownerToIds[owner][i];\r\n        }\r\n        return owned;\r\n    }\r\n\r\n    function getOwnedTokenIdsSegment(\r\n        address owner,\r\n        uint256 startIndex,\r\n        uint256 count\r\n    ) public view returns (uint256[] memory) {\r\n        uint256[] memory owned = new uint256[](count);\r\n        for (uint256 i = startIndex; i < startIndex + count; i++) {\r\n            owned[i - startIndex] = ownerToIds[owner][i];\r\n        }\r\n        return owned;\r\n    }\r\n\r\n    //////////////////////////\r\n    ////     Metadata     ////\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Returns a descriptive name for a collection of NFTokens.\r\n     * @return _name Representing name.\r\n     */\r\n    function name() external view returns (string memory _name) {\r\n        _name = nftName;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an abbreviated name for NFTokens.\r\n     * @return _symbol Representing symbol.\r\n     */\r\n    function symbol() external view returns (string memory _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmuter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blueStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"red\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"green\",\"type\":\"uint256\"}],\"name\":\"PlotTransmutation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_red\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_green\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blue\",\"type\":\"uint256\"}],\"name\":\"RGBToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chromaticPlotAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fungibleChromaAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnedTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getOwnedTokenIdsSegment\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"idToBlue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"idToGreen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwnerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"idToRed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerToIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chromaticPlotAddress\",\"type\":\"address\"}],\"name\":\"setChromaticPlotAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fungibleChromaAddress\",\"type\":\"address\"}],\"name\":\"setFungibleChromaAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"toHex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"toHexString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"toRGBString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transmutationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"transmuteMultipleToERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"transmuteMultipleToNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_plotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"transmutePlotToERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_plotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"transmutePlotToNFTs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"transmuteSingleToERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"transmuteSingleToNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Chroma","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d462c185735d3b90c06ba95f3f6d28959c28c72a","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://35af8f0ee4e552588847920f8f8822f9dfc29417cb32834c7854926a01812749"}]}