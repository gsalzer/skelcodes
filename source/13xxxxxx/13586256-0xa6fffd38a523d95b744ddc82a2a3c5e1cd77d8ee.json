{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-11-10\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IVoterID {\r\n    /**\r\n        Minting function\r\n    */\r\n    function createIdentityFor(address newId, uint tokenId, string memory uri) external;\r\n\r\n    /**\r\n        Who's in charge around here\r\n    */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n        How many of these things exist?\r\n    */\r\n    function totalSupply() external view returns (uint);\r\n}\r\n\r\ninterface IPriceGate {\r\n\r\n    function getCost(uint) external view returns (uint ethCost);\r\n\r\n    function passThruGate(uint, address) external payable;\r\n}\r\n\r\n\r\ninterface IEligibility {\r\n    \r\n    function isEligible(uint, address, bytes32[] memory) external view returns (bool eligible);\r\n\r\n    function passThruGate(uint, address, bytes32[] memory) external;\r\n}\r\n\r\n\r\nlibrary MerkleLib {\r\n\r\n    function verifyProof(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\r\n        bytes32 currentHash = leaf;\r\n\r\n        for (uint i = 0; i < proof.length; i += 1) {\r\n            currentHash = parentHash(currentHash, proof[i]);\r\n        }\r\n\r\n        return currentHash == root;\r\n    }\r\n\r\n    function parentHash(bytes32 a, bytes32 b) public pure returns (bytes32) {\r\n        if (a < b) {\r\n            return keccak256(abi.encode(a, b));\r\n        } else {\r\n            return keccak256(abi.encode(b, a));\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MerkleIdentity {\r\n    using MerkleLib for bytes32;\r\n\r\n    struct MerkleTree {\r\n        bytes32 metadataMerkleRoot;\r\n        bytes32 ipfsHash;\r\n        address nftAddress;\r\n        address priceGateAddress;\r\n        address eligibilityAddress;\r\n        uint eligibilityIndex; // enables re-use of eligibility contracts\r\n        uint priceIndex; // enables re-use of price gate contracts\r\n    }\r\n\r\n    mapping (uint => MerkleTree) public merkleTrees;\r\n    uint public numTrees;\r\n\r\n    address public management;\r\n    address public treeAdder;\r\n\r\n    event MerkleTreeAdded(uint indexed index, address indexed nftAddress);\r\n\r\n    modifier managementOnly() {\r\n        require (msg.sender == management, 'Only management may call this');\r\n        _;\r\n    }\r\n\r\n    constructor(address _mgmt) {\r\n        management = _mgmt;\r\n        treeAdder = _mgmt;\r\n    }\r\n\r\n    // change the management key\r\n    function setManagement(address newMgmt) external managementOnly {\r\n        management = newMgmt;\r\n    }\r\n\r\n    function setTreeAdder(address newAdder) external managementOnly {\r\n        treeAdder = newAdder;\r\n    }\r\n\r\n    function setIpfsHash(uint merkleIndex, bytes32 hash) external managementOnly {\r\n        MerkleTree storage tree = merkleTrees[merkleIndex];\r\n        tree.ipfsHash = hash;\r\n    }\r\n\r\n    function addMerkleTree(bytes32 metadataMerkleRoot, bytes32 ipfsHash, address nftAddress, address priceGateAddress, address eligibilityAddress, uint eligibilityIndex, uint priceIndex) external {\r\n        require(msg.sender == treeAdder, 'Only treeAdder can add trees');\r\n        MerkleTree storage tree = merkleTrees[++numTrees];\r\n        tree.metadataMerkleRoot = metadataMerkleRoot;\r\n        tree.ipfsHash = ipfsHash;\r\n        tree.nftAddress = nftAddress;\r\n        tree.priceGateAddress = priceGateAddress;\r\n        tree.eligibilityAddress = eligibilityAddress;\r\n        tree.eligibilityIndex = eligibilityIndex;\r\n        tree.priceIndex = priceIndex;\r\n        emit MerkleTreeAdded(numTrees, nftAddress);\r\n    }\r\n\r\n    function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\r\n        MerkleTree storage tree = merkleTrees[merkleIndex];\r\n        IVoterID id = IVoterID(tree.nftAddress);\r\n\r\n        // mint an identity first, this keeps the token-collision gas cost down\r\n        id.createIdentityFor(msg.sender, tokenId, uri);\r\n\r\n        // check that the merkle index is real\r\n        require(merkleIndex <= numTrees, 'merkleIndex out of range');\r\n\r\n        // verify that the metadata is real\r\n        require(verifyMetadata(tree.metadataMerkleRoot, tokenId, uri, metadataProof), \"The metadata proof could not be verified\");\r\n\r\n        // check eligibility of address\r\n        IEligibility(tree.eligibilityAddress).passThruGate(tree.eligibilityIndex, msg.sender, addressProof);\r\n\r\n        // check that the price is right\r\n        IPriceGate(tree.priceGateAddress).passThruGate{value: msg.value}(tree.priceIndex, msg.sender);\r\n\r\n    }\r\n\r\n    function getPrice(uint merkleIndex) public view returns (uint) {\r\n        MerkleTree memory tree = merkleTrees[merkleIndex];\r\n        uint ethCost = IPriceGate(tree.priceGateAddress).getCost(tree.priceIndex);\r\n        return ethCost;\r\n    }\r\n\r\n    function isEligible(uint merkleIndex, address recipient, bytes32[] memory proof) public view returns (bool) {\r\n        MerkleTree memory tree = merkleTrees[merkleIndex];\r\n        return IEligibility(tree.eligibilityAddress).isEligible(tree.eligibilityIndex, recipient, proof);\r\n    }\r\n\r\n    function verifyMetadata(bytes32 root, uint tokenId, string memory uri, bytes32[] memory proof) public pure returns (bool) {\r\n        bytes32 leaf = keccak256(abi.encode(tokenId, uri));\r\n        return root.verifyProof(leaf, proof);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"MerkleTreeAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"metadataMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceGateAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"eligibilityAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eligibilityIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceIndex\",\"type\":\"uint256\"}],\"name\":\"addMerkleTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleTrees\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"metadataMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceGateAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"eligibilityAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eligibilityIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTrees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"setIpfsHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdder\",\"type\":\"address\"}],\"name\":\"setTreeAdder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeAdder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyMetadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"addressProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"metadataProof\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"MerkleIdentity","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b","EVMVersion":"Default","Library":"MerkleLib:458efd41740ffb27d86a9157050c0707b41e9520","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://636912fd89346682867bd639dc54deee17c31722deb52b0a8d29f497c5efaaf2"}]}