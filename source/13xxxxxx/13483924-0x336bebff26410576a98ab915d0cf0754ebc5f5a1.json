{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GenerativemasksScript.sol\": {\r\n      \"content\": \"/*\\n\\n   _____                           _   _                               _\\n  / ____|                         | | (_)                             | |\\n | |  __  ___ _ __   ___ _ __ __ _| |_ ___   _____ _ __ ___   __ _ ___| | _____\\n | | |_ |/ _ \\\\ '_ \\\\ / _ \\\\ '__/ _` | __| \\\\ \\\\ / / _ \\\\ '_ ` _ \\\\ / _` / __| |/ / __|\\n | |__| |  __/ | | |  __/ | | (_| | |_| |\\\\ V /  __/ | | | | | (_| \\\\__ \\\\   <\\\\__ \\\\\\n  \\\\_____|\\\\___|_| |_|\\\\___|_|  \\\\__,_|\\\\__|_| \\\\_/ \\\\___|_| |_| |_|\\\\__,_|___/_|\\\\_\\\\___/\\n\\nThis contract contains a fully on-chain migrated Generativemasks script and related information.\\n\\n## About original contract and project\\n\\n- Original contract is deployed at Aug-08-2021\\n- Project launched at Aug-17-2021\\n\\n## About creator and team\\n\\n### Creator\\n\\n* Name: takawo shunsuke\\n* OpenProcessing: https://openprocessing.org/user/6533\\n* Twitter: https://twitter.com/takawo\\n\\n### Team\\n\\n- Toshiaki Takase\\n- wildmouse\\n\\n## Miscellaneous\\n\\n- GitHub: https://github.com/generativemasks\\n\\n*/\\n\\n// SPDX-License-Identifier: MIT\\n// Disclaimer: This is a license for the contract code, not for the scripts stored in ORIGINAL_SCRIPT.\\n// The license for ORIGINAL_SCRIPT is the one specified in SCRIPT_LICENSE.\\n\\npragma solidity =0.8.6;\\n\\ncontract GenerativemasksScript {\\n\\n    address public NFT = address(0x80416304142Fa37929f8A4Eee83eE7D2dAc12D7c);\\n\\n    string public constant NAME = \\\"Generativemasks\\\";\\n\\n    string public constant CREATOR = \\\"takawo shunsuke\\\";\\n\\n    string public constant DESCRIPTION = \\\"The inspiration for this work came from discovering a sense of life in geometric patterns that are symmetrically arranged. With unexpected shapes and patterns, I tried to express the scary yet somehow charming atmosphere of Native American totem poles and indigenous Japanese Yokai.\\\";\\n\\n    string public constant SCRIPT_LICENSE = \\\"CC BY-NC-SA 3.0\\\";\\n\\n    string public constant USED_LIBRARY = \\\"p5.js\\\";\\n\\n    string public constant LIBRARY_VERSION = \\\"1.3.1\\\";\\n\\n    uint256 public constant METADATA_INDEX = 3799;\\n\\n    function getMaskNumberWithTokenId(uint256 tokenId) external pure returns (uint256) {\\n        return (tokenId + METADATA_INDEX) % 10000;\\n    }\\n\\n    function getTokenIdWithMaskNumber(uint256 maskNumber) external pure returns (uint256) {\\n        return ((maskNumber + 10000) - METADATA_INDEX) % 10000;\\n    }\\n\\n    string public constant ORIGINAL_SCRIPT =\\nunicode\\\"const urlParams = new URLSearchParams(window.location.search);\\\"\\nunicode\\\"const seed = urlParams.get('seed');\\\"\\nunicode\\\"\\\"\\nunicode\\\"let palette;\\\"\\nunicode\\\"let g;\\\"\\nunicode\\\"let current = seed;\\\"\\nunicode\\\"let texture;\\\"\\nunicode\\\"\\\"\\nunicode\\\"function setup() {\\\"\\nunicode\\\"  createCanvas(1600, 1600);\\\"\\nunicode\\\"  pixelDensity(1);\\\"\\nunicode\\\"  colorMode(HSB, 360, 100, 100, 100);\\\"\\nunicode\\\"  angleMode(DEGREES);\\\"\\nunicode\\\"\\\"\\nunicode\\\"  texture = createGraphics(width, height);\\\"\\nunicode\\\"  texture.colorMode(HSB, 360, 100, 100, 100);\\\"\\nunicode\\\"  texture.angleMode(DEGREES);\\\"\\nunicode\\\"\\\"\\nunicode\\\"  texture.stroke(0, 0, 0, 1);\\\"\\nunicode\\\"  for (let i = 0; i < (width * height * 1) / 100; i++) {\\\"\\nunicode\\\"    let x = random(width);\\\"\\nunicode\\\"    let y = random(height);\\\"\\nunicode\\\"    let angle = 90 + random(15) * (random(100) > 50 ? -1 : 1);\\\"\\nunicode\\\"    let d = width / 10;\\\"\\nunicode\\\"    texture.line(\\\"\\nunicode\\\"      x + cos(angle) * d,\\\"\\nunicode\\\"      y + sin(angle) * d,\\\"\\nunicode\\\"      x + cos(angle + 180) * d,\\\"\\nunicode\\\"      y + sin(angle + 180) * d\\\"\\nunicode\\\"    );\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"function draw() {\\\"\\nunicode\\\"  clear();\\\"\\nunicode\\\"\\\"\\nunicode\\\"  palette = shuffle(createPalette(random(url)), true);\\\"\\nunicode\\\"  randomSeed(current);\\\"\\nunicode\\\"  noiseSeed(current);\\\"\\nunicode\\\"\\\"\\nunicode\\\"  let offset = width / 10;\\\"\\nunicode\\\"  let x = offset;\\\"\\nunicode\\\"  let y = offset;\\\"\\nunicode\\\"  let w = width - offset * 2;\\\"\\nunicode\\\"  let h = height - offset * 2;\\\"\\nunicode\\\"\\\"\\nunicode\\\"  let c = palette[0];\\\"\\nunicode\\\"  palette.shift();\\\"\\nunicode\\\"\\\"\\nunicode\\\"  push();\\\"\\nunicode\\\"  fill(c);\\\"\\nunicode\\\"  strokeWeight(30);\\\"\\nunicode\\\"  stroke(c);\\\"\\nunicode\\\"  let nScale = random(60, 200);\\\"\\nunicode\\\"  drawShape(x + w / 2, y + h / 2, (w * 3) / 4, nScale);\\\"\\nunicode\\\"  drawingContext.clip();\\\"\\nunicode\\\"  drawGraphic(0, 0, width, height, palette, this);\\\"\\nunicode\\\"  pop();\\\"\\nunicode\\\"\\\"\\nunicode\\\"  g = get();\\\"\\nunicode\\\"\\\"\\nunicode\\\"  background(random(palette));\\\"\\nunicode\\\"\\\"\\nunicode\\\"  let area = detectEdge(g);\\\"\\nunicode\\\"  rectMode(CORNERS);\\\"\\nunicode\\\"  let center = detectCenter(area);\\\"\\nunicode\\\"  let v = p5.Vector.sub(\\\"\\nunicode\\\"    createVector(width / 2, height / 2),\\\"\\nunicode\\\"    createVector(center.x, center.y)\\\"\\nunicode\\\"  );\\\"\\nunicode\\\"\\\"\\nunicode\\\"  push();\\\"\\nunicode\\\"  imageMode(CENTER);\\\"\\nunicode\\\"  translate(v.x + g.width / 2, v.y + g.height / 2);\\\"\\nunicode\\\"  drawingContext.shadowColor = color(0, 0, 0, 50);\\\"\\nunicode\\\"  drawingContext.shadowBlur = max(width, height) / 20;\\\"\\nunicode\\\"  drawingContext.shadowOffsetY = max(width, height) / 40;\\\"\\nunicode\\\"\\\"\\nunicode\\\"  image(g, 0, 0);\\\"\\nunicode\\\"  pop();\\\"\\nunicode\\\"  image(texture, 0, 0);\\\"\\nunicode\\\"\\\"\\nunicode\\\"  noLoop()\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"function detectCenter(area) {\\\"\\nunicode\\\"  let x = lerp(area.minX, area.maxX, 0.5);\\\"\\nunicode\\\"  let y = lerp(area.minY, area.maxY, 0.5);\\\"\\nunicode\\\"  let w = abs(area.maxX - area.minX);\\\"\\nunicode\\\"  let h = abs(area.maxY - area.minY);\\\"\\nunicode\\\"  return {\\\"\\nunicode\\\"    x: x,\\\"\\nunicode\\\"    y: y,\\\"\\nunicode\\\"    w: w,\\\"\\nunicode\\\"    h: h,\\\"\\nunicode\\\"  };\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"function detectEdge(g) {\\\"\\nunicode\\\"  let minX, minY, maxX, maxY;\\\"\\nunicode\\\"  minX = g.width;\\\"\\nunicode\\\"  minY = g.height;\\\"\\nunicode\\\"  maxX = 0;\\\"\\nunicode\\\"  maxY = 0;\\\"\\nunicode\\\"  g.loadPixels();\\\"\\nunicode\\\"  for (let j = 0; j < g.height; j++) {\\\"\\nunicode\\\"    for (let i = 0; i < g.width; i++) {\\\"\\nunicode\\\"      let n = i * 4 + j * g.width * 4 + 3;\\\"\\nunicode\\\"      let alpha = g.pixels[n];\\\"\\nunicode\\\"      if (alpha > 0) {\\\"\\nunicode\\\"        minX = min(minX, i);\\\"\\nunicode\\\"        minY = min(minY, j);\\\"\\nunicode\\\"        maxX = max(maxX, i);\\\"\\nunicode\\\"        maxY = max(maxY, j);\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"    }\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"  return {\\\"\\nunicode\\\"    minX: minX,\\\"\\nunicode\\\"    minY: minY,\\\"\\nunicode\\\"    maxX: maxX,\\\"\\nunicode\\\"    maxY: maxY,\\\"\\nunicode\\\"  };\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"function drawGraphic(x, y, w, h, colors, target) {\\\"\\nunicode\\\"  let g = createGraphics(w / 2, h);\\\"\\nunicode\\\"  g.angleMode(DEGREES);\\\"\\nunicode\\\"  let gx = 0;\\\"\\nunicode\\\"  let gy = 0;\\\"\\nunicode\\\"  let gxStep, gyStep;\\\"\\nunicode\\\"\\\"\\nunicode\\\"  if (random() > 0.5) {\\\"\\nunicode\\\"    while (gy < g.height) {\\\"\\nunicode\\\"      gyStep = random(g.height / 100, g.height / 5);\\\"\\nunicode\\\"      if (gy + gyStep > g.height || g.height - (gy + gyStep) < g.height / 20) {\\\"\\nunicode\\\"        gyStep = g.height - gy;\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      gx = 0;\\\"\\nunicode\\\"      while (gx < g.width) {\\\"\\nunicode\\\"        gxStep = gyStep;\\\"\\nunicode\\\"        if (gx + gxStep > g.width || g.width - (gx + gxStep) < g.width / 10) {\\\"\\nunicode\\\"          gxStep = g.width - gx;\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        drawPattern(g, gx, gy, gxStep, gyStep, colors);\\\"\\nunicode\\\"        gx += gxStep;\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      gy += gyStep;\\\"\\nunicode\\\"    }\\\"\\nunicode\\\"  } else {\\\"\\nunicode\\\"    while (gx < g.width) {\\\"\\nunicode\\\"      gxStep = random(g.width / 100, g.width / 5);\\\"\\nunicode\\\"      if (gx + gxStep > g.width || g.width - (gx + gxStep) < g.width / 20) {\\\"\\nunicode\\\"        gxStep = g.width - gx;\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      gy = 0;\\\"\\nunicode\\\"      while (gy < g.height) {\\\"\\nunicode\\\"        gyStep = gxStep;\\\"\\nunicode\\\"        if (gy + gyStep > g.height || g.height - (gy + gyStep) < g.height / 10) {\\\"\\nunicode\\\"          gyStep = g.height - gy;\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        drawPattern(g, gx, gy, gxStep, gyStep, colors);\\\"\\nunicode\\\"        gy += gyStep;\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      gx += gxStep;\\\"\\nunicode\\\"    }\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"\\\"\\nunicode\\\"  target.push();\\\"\\nunicode\\\"  target.translate(x + w / 2, y + h / 2);\\\"\\nunicode\\\"  target.imageMode(CENTER);\\\"\\nunicode\\\"  target.scale(1, 1);\\\"\\nunicode\\\"  target.image(g, -g.width / 2, 0);\\\"\\nunicode\\\"  target.scale(-1, 1);\\\"\\nunicode\\\"  target.image(g, -g.width / 2, 0);\\\"\\nunicode\\\"  target.pop();\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"function drawPattern(g, x, y, w, h, colors) {\\\"\\nunicode\\\"  let rotate_num = (int(random(4)) * 360) / 4;\\\"\\nunicode\\\"  g.push();\\\"\\nunicode\\\"  g.translate(x + w / 2, y + h / 2);\\\"\\nunicode\\\"  g.rotate(rotate_num);\\\"\\nunicode\\\"  if (rotate_num % 180 == 90) {\\\"\\nunicode\\\"    let tmp = w;\\\"\\nunicode\\\"    w = h;\\\"\\nunicode\\\"    h = tmp;\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"  g.translate(-w / 2, -h / 2);\\\"\\nunicode\\\"  g.drawingContext.shadowColor = color(0, 0, 0, 33);\\\"\\nunicode\\\"  g.drawingContext.shadowBlur = max(w, h) / 5;\\\"\\nunicode\\\"  let sep = int(random(1, 6));\\\"\\nunicode\\\"\\\"\\nunicode\\\"  let c = -1,\\\"\\nunicode\\\"    pc = -1;\\\"\\nunicode\\\"  g.stroke(0, (20 / 100) * 255);\\\"\\nunicode\\\"\\\"\\nunicode\\\"  switch (int(random(8))) {\\\"\\nunicode\\\"    case 0:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"        g.arc(0, 0, w * 2, h * 2, 0, 90);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"    case 1:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w / 2, 0);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.arc(0, 0, w, h, 0, 180);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w / 2, h);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.arc(0, 0, w, h, 0 + 180, 180 + 180);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"    case 2:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.arc(0, 0, w * sqrt(2), h * sqrt(2), 0, 90);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w, h);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.arc(0, 0, w * sqrt(2), h * sqrt(2), 0 + 180, 90 + 180);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"    case 3:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w / 2, h / 2);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"        g.ellipse(0, 0, w, h);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"    case 4:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"        g.triangle(0, 0, w, 0, 0, h);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"    case 5:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w / 2, 0);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.triangle(-w / 2, 0, w / 2, 0, 0, h / 2);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w / 2, h);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.triangle(-w / 2, 0, w / 2, 0, 0, -h / 2);\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"    case 6:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.triangle(0, 0, w * sqrt(2), 0, 0, h * sqrt(2));\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w, h);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.arc(0, 0, -w * sqrt(2), 0, 0, -h * sqrt(2));\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"    case 7:\\\"\\nunicode\\\"      for (let i = 1; i > 0; i -= 1 / sep) {\\\"\\nunicode\\\"        while (pc == c) {\\\"\\nunicode\\\"          c = random(colors);\\\"\\nunicode\\\"        }\\\"\\nunicode\\\"        pc = c;\\\"\\nunicode\\\"        g.push();\\\"\\nunicode\\\"        g.translate(w / 2, h / 2);\\\"\\nunicode\\\"        g.rotate(45);\\\"\\nunicode\\\"        g.scale(i);\\\"\\nunicode\\\"        g.strokeWeight(1 / i);\\\"\\nunicode\\\"        g.fill(c);\\\"\\nunicode\\\"        g.rectMode(CENTER);\\\"\\nunicode\\\"        g.square(0, 0, sqrt(sq(w) + sq(h)));\\\"\\nunicode\\\"        g.pop();\\\"\\nunicode\\\"      }\\\"\\nunicode\\\"      break;\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"  g.pop();\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"function createPalette(_url) {\\\"\\nunicode\\\"  let slash_index = _url.lastIndexOf(\\\\\\\"/\\\\\\\");\\\"\\nunicode\\\"  let pallate_str = _url.slice(slash_index + 1);\\\"\\nunicode\\\"  let arr = pallate_str.split(\\\\\\\"-\\\\\\\");\\\"\\nunicode\\\"  for (let i = 0; i < arr.length; i++) {\\\"\\nunicode\\\"    arr[i] = color(\\\\\\\"#\\\\\\\" + arr[i]);\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"  return arr;\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"function drawShape(cx, cy, r, nPhase) {\\\"\\nunicode\\\"  push();\\\"\\nunicode\\\"  translate(cx, cy, r);\\\"\\nunicode\\\"  rotate(-90);\\\"\\nunicode\\\"  let arr = [];\\\"\\nunicode\\\"  beginShape();\\\"\\nunicode\\\"  for (let angle = 0; angle < 180; angle += 1) {\\\"\\nunicode\\\"    let nr = map(noise(cx, cy, angle / nPhase, r), 0, 1, (r * 1) / 8, r);\\\"\\nunicode\\\"    nr = constrain(nr, 0, width / 2);\\\"\\nunicode\\\"    arr.push(nr);\\\"\\nunicode\\\"    let x = cos(angle) * nr;\\\"\\nunicode\\\"    let y = sin(angle) * nr;\\\"\\nunicode\\\"    vertex(x, y);\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"  arr.reverse();\\\"\\nunicode\\\"  for (let angle = 180; angle < 180 + 180; angle += 1) {\\\"\\nunicode\\\"    let nr = arr[0];\\\"\\nunicode\\\"    arr.shift();\\\"\\nunicode\\\"    let x = cos(angle) * nr;\\\"\\nunicode\\\"    let y = sin(angle) * nr;\\\"\\nunicode\\\"    vertex(x, y);\\\"\\nunicode\\\"  }\\\"\\nunicode\\\"  endShape(CLOSE);\\\"\\nunicode\\\"\\\"\\nunicode\\\"  pop();\\\"\\nunicode\\\"}\\\"\\nunicode\\\"\\\"\\nunicode\\\"let url = [\\\"\\nunicode\\\"  \\\\\\\"202c39-283845-b8b08d-f2d492-f29559\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"1f2041-4b3f72-ffc857-119da4-19647e\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"2f4858-33658a-86bbd8-f6ae2d-f26419\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"ffac81-ff928b-fec3a6-efe9ae-cdeac0\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"f79256-fbd1a2-7dcfb6-00b2ca-1d4e89\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"e27396-ea9ab2-efcfe3-eaf2d7-b3dee2\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"966b9d-c98686-f2b880-fff4ec-e7cfbc\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"50514f-f25f5c-ffe066-247ba0-70c1b3\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"177e89-084c61-db3a34-ffc857-323031\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"390099-9e0059-ff0054-ff5400-ffbd00\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"0d3b66-faf0ca-f4d35e-ee964b-f95738\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"177e89-084c61-db3a34-ffc857-323031\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"780000-c1121f-fdf0d5-003049-669bbc\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"eae4e9-fff1e6-fde2e4-fad2e1-e2ece9-bee1e6-f0efeb-dfe7fd-cddafd\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"f94144-f3722c-f8961e-f9c74f-90be6d-43aa8b-577590\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"555b6e-89b0ae-bee3db-faf9f9-ffd6ba\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"9b5de5-f15bb5-fee440-00bbf9-00f5d4\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"ef476f-ffd166-06d6a0-118ab2-073b4c\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"006466-065a60-0b525b-144552-1b3a4b-212f45-272640-312244-3e1f47-4d194d\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"f94144-f3722c-f8961e-f9844a-f9c74f-90be6d-43aa8b-4d908e-577590-277da1\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"f6bd60-f7ede2-f5cac3-84a59d-f28482\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"0081a7-00afb9-fdfcdc-fed9b7-f07167\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"f4f1de-e07a5f-3d405b-81b29a-f2cc8f\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"50514f-f25f5c-ffe066-247ba0-70c1b3\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"001219-005f73-0a9396-94d2bd-e9d8a6-ee9b00-ca6702-bb3e03-ae2012-9b2226\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"ef476f-ffd166-06d6a0-118ab2-073b4c\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"fec5bb-fcd5ce-fae1dd-f8edeb-e8e8e4-d8e2dc-ece4db-ffe5d9-ffd7ba-fec89a\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"e63946-f1faee-a8dadc-457b9d-1d3557\\\\\\\",\\\"\\nunicode\\\"  \\\\\\\"264653-2a9d8f-e9c46a-f4a261-e76f51\\\\\\\",\\\"\\nunicode\\\"]\\\"\\n;\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"CREATOR\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIBRARY_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"METADATA_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORIGINAL_SCRIPT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SCRIPT_LICENSE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USED_LIBRARY\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMaskNumberWithTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maskNumber\",\"type\":\"uint256\"}],\"name\":\"getTokenIdWithMaskNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"GenerativemasksScript","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}