{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"openzeppelin-solidity/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Mandelbrot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 Arran Schlosberg / Twitter @divergence_art\\n// All Rights Reserved\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"openzeppelin-solidity/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @dev Pure-Solidity rendering of Mandelbrot and similar fractals.\\n */\\ncontract Mandelbrot is Ownable {\\n    /**\\n     * @dev Defines the fixed-point precision for non-integer numbers.\\n     *\\n     * The number 1 is represented as 1<<PRECISION, 0.5 as 1<<(PRECISION-1).\\n     * These values can be thought of as the binary equivalent of working in\\n     * cents vs dollars (100c = $1) which is the same 2 _decimal_ precision.\\n     *\\n     * Addition functions as normal. Multiplication results in twice as many\\n     * fractional bits so requires devision by the \\\"dollar-equivalent\\\":\\n     * \\n     *   $1 × $2 = $2\\n     *   100c × 200c = 20,000 (extra precision) / 100 = $2\\n     *\\n     * The binary equivalent of this division is a right arithmetic shift (sar)\\n     * to maintain the sign. The specific value was chosen to avoid overflow\\n     * based on Mandelbrot escape conditions. Although it's possible to first\\n     * right-shift both the multiplier and multiplicand by PRECISION/2 and then\\n     * multiply in order to allow higher values, this changes gas from 8 to 11\\n     * as mul=5 and sar=3.\\n     */\\n    uint256 private constant PRECISION = 125;\\n\\n    /**\\n     * @dev Pre-computed value for PRECISION+2.\\n     */\\n    uint256 private constant PRECISION_PLUS_2 = 127;\\n\\n    /**\\n     * @dev The number 1 in @PRECISION fixed-point representation.\\n     *\\n     * This is useful for external callers, which should use ONE as bignum menas\\n     * of computing fractions.\\n     */\\n    int256 public constant ONE = 2**125;\\n\\n    /**\\n     * @dev The number 2 in @PRECISION fixed-point representation.\\n     */\\n    int256 private constant TWO = 2**126;\\n\\n    /**\\n     * @dev By now I think you can see the pattern.\\n     */\\n    int256 private constant FOUR = 2**127;\\n\\n    /**\\n     * @dev You're gonna have to trust me on this one!\\n     */\\n    int256 private constant POINT_FOUR = 0xccccccccccccccccccccccccccccccc;\\n\\n    /**\\n     * @dev Some bounds checks for inclusion in the cardioid, main bulb, etc.\\n     */\\n    int256 private constant QUARTER = 2**123;\\n    int256 private constant EIGHTH = 2**122;\\n    int256 private constant SIXTEENTH = 2**121;\\n    int256 private constant NEG_THREE_QUARTERS = 2**123 - 2**125;\\n    int256 private constant NEG_ONE_PT_TWO_FIVE = -(2**123 + 2**125);\\n\\n    /**\\n     * @dev The number -2 in @PRECISION fixed-point representation.\\n     *\\n     * This is the lower bound of the parts of real and imaginary axes on which\\n     * fractals are defined.\\n     */\\n    int256 public constant NEG_TWO = -TWO;\\n\\n    /**\\n     * @dev Supported Mandelbrot-derived fractals.\\n     *\\n     * The INVALID sentinel value MUST be last as it allows for rapid checking\\n     * of valid values with <.\\n     */\\n    enum Fractal {\\n        Mandelbrot,\\n        Mandelbar,\\n        Multi3,\\n        BurningShip,\\n\\n        INVALID\\n    }\\n\\n    /**\\n     * @dev Parameters for computing a patch in a fractal.\\n     */\\n    struct Patch {\\n        // Fixed-point values, not actually integers. See ONE.\\n        int256 minReal;\\n        int256 minImaginary;\\n        // Dimensions in pixels. Pixel width is controlled by zoomLog2.\\n        int256 width;\\n        int256 height;\\n        // For a full fractal, set equal width and height, and\\n        // zoomLog2 = log_2(width).\\n        int16 zoomLog2;\\n        uint8 maxIterations;\\n        Fractal fractal;\\n    }\\n\\n    /**\\n     * @dev Computes escape times (pixel values) for a fractal rendering.\\n     *\\n     * These are the components that make up the final image when concatenated,\\n     * but are computed piecemeal to save compute time of any single call.\\n     */\\n    function patchPixels(Patch memory patch) public pure returns (bytes memory) {\\n        require(patch.width > 0, \\\"Non-positive width\\\");\\n        require(patch.height > 0, \\\"Non-positive height\\\");\\n        require(patch.zoomLog2 > 0, \\\"Non-positive zoom\\\");\\n        require(patch.fractal < Fractal.INVALID, \\\"Unsupported fractal\\\");\\n\\n        // Mandelbrots are defined on [-2,2] (i.e. width 4 = 2^2), hence the use\\n        // of PRECISION+2. Every increment of zoomLog2 increases the\\n        // mangification of both axes 2× by halving the pixelWidth.\\n        int256 pixelWidth;\\n        {\\n            int16 zoomLog2 = patch.zoomLog2;\\n            assembly { pixelWidth := shl(sub(PRECISION_PLUS_2, zoomLog2), 1) }\\n        }\\n        int256 maxRe = patch.minReal + pixelWidth*patch.width;\\n        int256 maxIm = patch.minImaginary + pixelWidth*patch.height;\\n\\n        // While this duplicates a lot of code, it saves having the if statement\\n        // inside the loops, which would be much less efficient.\\n        if (patch.fractal == Fractal.Mandelbrot) {\\n            return _mandelbrot(patch, pixelWidth, maxRe, maxIm);\\n        } else if (patch.fractal == Fractal.Mandelbar) {\\n            return _mandelbar(patch, pixelWidth, maxRe, maxIm);\\n        } else if (patch.fractal == Fractal.Multi3) {\\n            return _multi3(patch, pixelWidth, maxRe, maxIm);\\n        } else if (patch.fractal == Fractal.BurningShip) {\\n            return _burningShip(patch, pixelWidth, maxRe, maxIm);\\n        }\\n        // The check for patch.fractal < Fractal.INVALID makes this impossible,\\n        // but we still need a return value.\\n        return new bytes(0);\\n    }\\n\\n    /**\\n     * @dev Computes the standard Mandelbrot.\\n     */\\n    function _mandelbrot(Patch memory patch, int256 pixelWidth, int256 maxRe, int256 maxIm) internal pure returns (bytes memory) {\\n        bytes memory pixels = new bytes(uint256(patch.width * patch.height));\\n        \\n        int256 zRe;\\n        int256 zIm;\\n        int256 reSq;\\n        int256 imSq;\\n\\n        uint8 maxIters  = patch.maxIterations;\\n        uint256 pixelIdx = 0;\\n        for (int256 cIm = patch.minImaginary; cIm < maxIm; cIm += pixelWidth) {\\n            for (int256 cRe = patch.minReal; cRe < maxRe; cRe += pixelWidth) {\\n                // Points in the Mandelbrot are expensive to compute by force\\n                // because they require maxIters iterations. Ruling out the two\\n                // largest areas adds a little more computation to other\\n                // regions, but is a net saving.\\n                //\\n                // From https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Border_tracing_/_edge_checking\\n                //\\n                // NOTE: to keep the stack small, all variable names are\\n                // overloaded with different meanings. It's ugly, but so be it.\\n\\n                // TODO: the checks are only performed based on real ranges;\\n                // test if there's a benefit to computing |cIm| and limiting\\n                // further. At this point the speed-up is good enough to render\\n                // a 256x256 fairly quickly, for some subjective definition of\\n                // \\\"fairly\\\".\\n\\n                // Inside the cardioid?\\n                if (cRe >= NEG_THREE_QUARTERS && cRe < POINT_FOUR) {\\n                    zRe = cRe - QUARTER;\\n                    zIm = cIm;\\n                    assembly {\\n                        reSq := shr(PRECISION, mul(zRe, zRe)) // (x - 1/4)^2\\n                        imSq := shr(PRECISION, mul(zIm, zIm)) // y^2\\n                        zIm := add(reSq, imSq) // q\\n                        zRe := add(zRe, zIm) // q + x - 1/4\\n                        zRe := sar(PRECISION, mul(zRe, zIm)) // q(q + x - 1/4)\\n                        imSq := shr(2, imSq) // y^2/4\\n                    }\\n                    if (zRe <= imSq) {\\n                        pixelIdx++;\\n                        continue;\\n                    }\\n                }\\n                \\n                // Inside the main bulb?\\n                if (cRe <= NEG_THREE_QUARTERS && cRe >= NEG_ONE_PT_TWO_FIVE) {\\n                    zRe = cRe + ONE;\\n                    zIm = cIm;\\n                    assembly {\\n                        reSq := shr(PRECISION, mul(zRe, zRe))\\n                        imSq := shr(PRECISION, mul(zIm, zIm))\\n                    }\\n                    if (reSq + imSq <= SIXTEENTH) {\\n                        pixelIdx++;\\n                        continue;\\n                    }\\n                }\\n\\n                // Brute-force computation from here on. Variables now mean what\\n                // they say on the tin.\\n\\n                // Technically z_0 = (0,0) but z_1 is always c, so skip that\\n                // iteration and eke out an extra iteration.\\n                zRe = cRe;\\n                zIm = cIm;\\n                uint8 pixelVal;\\n                assembly {\\n                    for { let i := 0 } lt(i, maxIters) { i := add(i, 1) } {\\n                        reSq := shr(PRECISION, mul(zRe, zRe))\\n                        imSq := shr(PRECISION, mul(zIm, zIm))\\n                        \\n                        if gt(add(reSq, imSq), FOUR) {\\n                            pixelVal := sub(maxIters, i)\\n                            i := maxIters\\n                        }\\n\\n                        // (x+iy)^2 = (x^2 - y^2) + 2ixy\\n                        //\\n                        // mul is 5 gas but add is 3, so 2xy is mul(add(x,x),y) instead\\n                        // of mul(mul(x,y),2)\\n                        zIm := add(cIm, sar(PRECISION, mul(add(zRe, zRe), zIm)))\\n                        zRe := add(cRe, sub(reSq, imSq))\\n\\n                    } // for maxIters\\n                } // assembly\\n\\n                pixels[pixelIdx] = bytes1(pixelVal);\\n                pixelIdx++;\\n\\n            } // for cIm\\n        } // for cRe\\n\\n        return pixels;\\n    }\\n\\n    /**\\n     * @dev Computes the \\\"Mandelbar\\\", taking the conjugate of z (hence bar).\\n     *\\n     * Also known as a \\\"Tricorn\\\". This differs from _mandelbrot() in that it has\\n     * no efficiency checks, initial zIm = -cIm (not cIm) and the zIm in the\\n     * assembly block is wrapped in sub(0, …). Each difference is noted with\\n     * comments.\\n     */\\n    function _mandelbar(Patch memory patch, int256 pixelWidth, int256 maxRe, int256 maxIm) internal pure returns (bytes memory) {\\n        bytes memory pixels = new bytes(uint256(patch.width * patch.height));\\n        \\n        int256 zRe;\\n        int256 zIm;\\n        int256 reSq;\\n        int256 imSq;\\n\\n        uint8 maxIters  = patch.maxIterations;\\n        uint256 pixelIdx = 0;\\n        for (int256 cIm = patch.minImaginary; cIm < maxIm; cIm += pixelWidth) {\\n            for (int256 cRe = patch.minReal; cRe < maxRe; cRe += pixelWidth) {\\n                // Note: there are no containment checks we can do to reduce\\n                // brute-force computation.\\n\\n                // Technically z_0 = (0,0) but z_1 is always c, so skip that\\n                // iteration and eke out an extra iteration.\\n                zRe = cRe;\\n                // Note: the -cIm for the conjugate.\\n                zIm = -cIm;\\n                uint8 pixelVal;\\n                assembly {\\n                    for { let i := 0 } lt(i, maxIters) { i := add(i, 1) } {\\n                        reSq := shr(PRECISION, mul(zRe, zRe))\\n                        imSq := shr(PRECISION, mul(zIm, zIm))\\n                        \\n                        if gt(add(reSq, imSq), FOUR) {\\n                            pixelVal := sub(maxIters, i)\\n                            i := maxIters\\n                        }\\n\\n                        // (x+iy)^2 = (x^2 - y^2) + 2ixy\\n                        //\\n                        // mul is 5 gas but add is 3, so 2xy is mul(add(x,x),y) instead\\n                        // of mul(mul(x,y),2)\\n                        //\\n                        // Note: the sub(0, …) is the \\\"bar\\\" part of the fractal.\\n                        zIm := sub(0, add(cIm, sar(PRECISION, mul(add(zRe, zRe), zIm))))\\n                        zRe := add(cRe, sub(reSq, imSq))\\n\\n                    } // for maxIters\\n                } // assembly\\n\\n                pixels[pixelIdx] = bytes1(pixelVal);\\n                pixelIdx++;\\n\\n            } // for cIm\\n        } // for cRe\\n\\n        return pixels;\\n    }\\n\\n    /**\\n     * @dev Computes the 3-headed Multibrot, z_n -> z_n^4 + z_0;\\n     *\\n     * This is effectively the same as the Mandelbrot but we square z_n twice.\\n     * Each difference is noted with comments.\\n     */\\n    function _multi3(Patch memory patch, int256 pixelWidth, int256 maxRe, int256 maxIm) internal pure returns (bytes memory) {\\n        bytes memory pixels = new bytes(uint256(patch.width * patch.height));\\n        \\n        int256 zRe;\\n        int256 zIm;\\n        int256 reSq;\\n        int256 imSq;\\n\\n        uint8 maxIters  = patch.maxIterations;\\n        uint256 pixelIdx = 0;\\n        for (int256 cIm = patch.minImaginary; cIm < maxIm; cIm += pixelWidth) {\\n            for (int256 cRe = patch.minReal; cRe < maxRe; cRe += pixelWidth) {\\n                // As with the containment tests for the Mandelbrot cardioid and\\n                // bulb, variable names are sometimes used differently to reduce\\n                // stack usage. \\n\\n                assembly {\\n                    reSq := shr(PRECISION, mul(cRe, cRe))\\n                    imSq := shr(PRECISION, mul(cIm, cIm))\\n                    reSq := add(reSq, imSq) // |z^2|\\n                }\\n                if (reSq > FOUR) {\\n                    // There's odd behaviour in the [-2,-2] corner without this\\n                    // initial check.\\n                    pixels[pixelIdx] = bytes1(maxIters);\\n                    pixelIdx++;\\n                    continue;\\n                } else if (reSq < EIGHTH) {\\n                    // Multibrots have cardioid-oids (great word eh?) that grow\\n                    // in minimum radius as the power increases. The\\n                    // Mandelbrot's cardioid inverts to 0.25.\\n                    // \\n                    // TODO: loosen this bound to rule out more computation.\\n                    pixelIdx++;\\n                    continue;\\n                }\\n\\n                // Brute-force computation from here on. Variables now mean what\\n                // they say on the tin.\\n\\n                // Technically z_0 = (0,0) but z_1 is always c, so skip that\\n                // iteration and eke out an extra iteration.\\n                zRe = cRe;\\n                zIm = cIm;\\n                uint8 pixelVal;\\n                assembly {\\n                    for { let i := 0 } lt(i, maxIters) { i := add(i, 1) } {\\n                        reSq := shr(PRECISION, mul(zRe, zRe))\\n                        imSq := shr(PRECISION, mul(zIm, zIm))\\n\\n                        // Note: instead of immediately checking for divergence,\\n                        // we complete z^2 and then check |z^2|^2 > 4 whereas\\n                        // the standard Mandelbrot checks |z|^2.\\n                        //\\n                        // (x+iy)^2 = (x^2 - y^2) + 2ixy\\n                        //\\n                        // mul is 5 gas but add is 3, so 2xy is mul(add(x,x),y) instead\\n                        // of mul(mul(x,y),2)\\n                        //\\n                        // Note: unlike Mandelbrot, we don't add z_0 (c) yet.\\n                        zIm := sar(PRECISION, mul(add(zRe, zRe), zIm))\\n                        zRe := sub(reSq, imSq)\\n                        \\n                        // // Note: reSq + imSq = |z^2|^2\\n                        reSq := shr(PRECISION, mul(zRe, zRe))\\n                        imSq := shr(PRECISION, mul(zIm, zIm))\\n\\n                        if gt(add(reSq, imSq), FOUR) {\\n                            pixelVal := sub(maxIters, i)\\n                            i := maxIters\\n                        }\\n\\n                        // Note: same as above except adding c.\\n                        zIm := add(cIm, sar(PRECISION, mul(add(zRe, zRe), zIm)))\\n                        zRe := add(cRe, sub(reSq, imSq))\\n\\n                    } // for maxIters\\n                } // assembly\\n\\n                pixels[pixelIdx] = bytes1(pixelVal);\\n                pixelIdx++;\\n\\n            } // for cIm\\n        } // for cRe\\n\\n        return pixels;\\n    }\\n\\n    /**\\n     * @dev Computes the Burning Ship by using |Re| and |Im|.\\n     */\\n    function _burningShip(Patch memory patch, int256 pixelWidth, int256 maxRe, int256 maxIm) internal pure returns (bytes memory) {\\n        bytes memory pixels = new bytes(uint256(patch.width * patch.height));\\n        \\n        int256 zRe;\\n        int256 zIm;\\n        int256 reSq;\\n        int256 imSq;\\n\\n        uint8 maxIters  = patch.maxIterations;\\n        uint256 pixelIdx = 0;\\n        // Note: the burning ship only looks like a ship when the imaginary axis\\n        // is flipped. Flipping the real is common too.\\n        for (int256 cIm = maxIm - pixelWidth; cIm >= patch.minImaginary; cIm -= pixelWidth) {\\n            for (int256 cRe = maxRe - pixelWidth; cRe >= patch.minReal; cRe -= pixelWidth) {\\n                // Technically z_0 = (0,0) but z_1 is always c, so skip that\\n                // iteration and eke out an extra iteration.\\n                zRe = cRe;\\n                zIm = cIm;\\n                uint8 pixelVal;\\n                assembly {\\n                    for { let i := 0 } lt(i, maxIters) { i := add(i, 1) } {\\n                        reSq := shr(PRECISION, mul(zRe, zRe))\\n                        imSq := shr(PRECISION, mul(zIm, zIm))\\n                        \\n                        if gt(add(reSq, imSq), FOUR) {\\n                            pixelVal := sub(maxIters, i)\\n                            i := maxIters\\n                        }\\n\\n                        // (x+iy)^2 = (x^2 - y^2) + 2ixy\\n                        //\\n                        // mul is 5 gas but add is 3, so 2xy is mul(add(x,x),y) instead\\n                        // of mul(mul(x,y),2)\\n                        zIm := add(cIm, sar(PRECISION, mul(add(zRe, zRe), zIm)))\\n                        zRe := add(cRe, sub(reSq, imSq))\\n\\n                        // Note: burning ship is identical to Mandelbrot except\\n                        // for the absolute values of real and imaginary.\\n                        if slt(zRe, 0) {\\n                            zRe := sub(0, zRe)\\n                        }\\n                        if slt(zIm, 0) {\\n                            zIm := sub(0, zIm)\\n                        }\\n                    } // for maxIters\\n                } // assembly\\n\\n                pixels[pixelIdx] = bytes1(pixelVal);\\n                pixelIdx++;\\n\\n            } // for cIm\\n        } // for cRe\\n\\n        return pixels;\\n    }\\n\\n    /**\\n     * @dev Precomputed pixels with their generating information.\\n     */\\n    struct CachedPatch {\\n        bytes pixels;\\n        Patch patch;\\n    }\\n\\n    /**\\n     * @dev A cache of precomputed pixels.\\n     *\\n     * Key is patchCacheKey(patch).\\n     */\\n    mapping(uint256 => CachedPatch) public patchCache;\\n\\n    /**\\n     * @dev Returns the key for the patchCache mapping of this patch.\\n     */\\n    function patchCacheKey(Patch memory patch) public pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(patch)));\\n    }\\n\\n    /**\\n     * @dev Cache a precomputed patch of pixels.\\n     *\\n     * See verifyCachedPatch().\\n     */\\n    function cachePatch(bytes memory pixels, Patch memory patch) public onlyOwner {\\n        require(pixels.length == uint256(patch.width * patch.height), \\\"Invalid dimensions\\\");\\n        patchCache[patchCacheKey(patch)] = CachedPatch(pixels, patch);\\n    }\\n\\n    /**\\n     * @dev Returns a cached patch, confirming existence.\\n     *\\n     * As mappings always return a value, width and height both > 0 is used as\\n     * a proxy for the patch having been cached. Those with 0 area are\\n     * redundant anyway.\\n     */\\n    function cachedPatch(uint256 cacheIdx) public view returns (CachedPatch memory) {\\n        CachedPatch memory cached = patchCache[cacheIdx];\\n        require(cached.patch.width > 0 && cached.patch.height > 0, \\\"Patch not cached\\\");\\n        return cached;\\n    }\\n\\n    /**\\n     * @dev Recompute pixels for a patch and confirm that they match the cache.\\n     *\\n     * This contract works on a trust-but-verify model. If patchPixels() were to\\n     * be used in a transaction, the gas fee would make the entire project\\n     * infeasible. Instead, it's only used in (free, read-only) calls, and the\\n     * returned values are stored via cachePatch(), which is cheaper. It's\\n     * possible to recompute the patch at any time via another free call to\\n     * verifyCachedPatch().\\n     */\\n    function verifyCachedPatch(uint256 cacheIdx) public view returns (bool) {\\n        CachedPatch memory cached = cachedPatch(cacheIdx);\\n        bytes memory fresh = patchPixels(cached.patch);\\n        return keccak256(fresh) == keccak256(cached.pixels);\\n    }\\n\\n    /**\\n     * @dev Returns a concatenated pixel buffer of cached patches.\\n     */\\n    function concatenatePatches(uint256[] memory patches) public view returns (bytes memory) {\\n        CachedPatch[] memory cached = new CachedPatch[](patches.length);\\n\\n        uint256 len;\\n        for (uint i = 0; i < patches.length; i++) {\\n            cached[i] = cachedPatch(patches[i]);\\n            len += cached[i].pixels.length;\\n        }\\n\\n        bytes memory buf = new bytes(len);\\n        uint idx;\\n        for (uint i = 0; i < cached.length; i++) {\\n            for (uint j = 0; j < cached[i].pixels.length; j++) {\\n                buf[idx] = cached[i].pixels[j];\\n                idx++;\\n            }\\n        }\\n        return buf;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NEG_TWO\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"pixels\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"minReal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"minImaginary\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"width\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"height\",\"type\":\"int256\"},{\"internalType\":\"int16\",\"name\":\"zoomLog2\",\"type\":\"int16\"},{\"internalType\":\"uint8\",\"name\":\"maxIterations\",\"type\":\"uint8\"},{\"internalType\":\"enum Mandelbrot.Fractal\",\"name\":\"fractal\",\"type\":\"uint8\"}],\"internalType\":\"struct Mandelbrot.Patch\",\"name\":\"patch\",\"type\":\"tuple\"}],\"name\":\"cachePatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cacheIdx\",\"type\":\"uint256\"}],\"name\":\"cachedPatch\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pixels\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"minReal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"minImaginary\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"width\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"height\",\"type\":\"int256\"},{\"internalType\":\"int16\",\"name\":\"zoomLog2\",\"type\":\"int16\"},{\"internalType\":\"uint8\",\"name\":\"maxIterations\",\"type\":\"uint8\"},{\"internalType\":\"enum Mandelbrot.Fractal\",\"name\":\"fractal\",\"type\":\"uint8\"}],\"internalType\":\"struct Mandelbrot.Patch\",\"name\":\"patch\",\"type\":\"tuple\"}],\"internalType\":\"struct Mandelbrot.CachedPatch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"patches\",\"type\":\"uint256[]\"}],\"name\":\"concatenatePatches\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"patchCache\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"pixels\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"minReal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"minImaginary\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"width\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"height\",\"type\":\"int256\"},{\"internalType\":\"int16\",\"name\":\"zoomLog2\",\"type\":\"int16\"},{\"internalType\":\"uint8\",\"name\":\"maxIterations\",\"type\":\"uint8\"},{\"internalType\":\"enum Mandelbrot.Fractal\",\"name\":\"fractal\",\"type\":\"uint8\"}],\"internalType\":\"struct Mandelbrot.Patch\",\"name\":\"patch\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"minReal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"minImaginary\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"width\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"height\",\"type\":\"int256\"},{\"internalType\":\"int16\",\"name\":\"zoomLog2\",\"type\":\"int16\"},{\"internalType\":\"uint8\",\"name\":\"maxIterations\",\"type\":\"uint8\"},{\"internalType\":\"enum Mandelbrot.Fractal\",\"name\":\"fractal\",\"type\":\"uint8\"}],\"internalType\":\"struct Mandelbrot.Patch\",\"name\":\"patch\",\"type\":\"tuple\"}],\"name\":\"patchCacheKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"minReal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"minImaginary\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"width\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"height\",\"type\":\"int256\"},{\"internalType\":\"int16\",\"name\":\"zoomLog2\",\"type\":\"int16\"},{\"internalType\":\"uint8\",\"name\":\"maxIterations\",\"type\":\"uint8\"},{\"internalType\":\"enum Mandelbrot.Fractal\",\"name\":\"fractal\",\"type\":\"uint8\"}],\"internalType\":\"struct Mandelbrot.Patch\",\"name\":\"patch\",\"type\":\"tuple\"}],\"name\":\"patchPixels\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cacheIdx\",\"type\":\"uint256\"}],\"name\":\"verifyCachedPatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Mandelbrot","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}