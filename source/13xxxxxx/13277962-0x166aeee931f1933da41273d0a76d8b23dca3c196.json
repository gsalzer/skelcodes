{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT \r\npragma solidity 0.8.7;\r\n\r\n/*\r\nWARNING: This is a trap. It is designed for the dev to make money from overconfident searchers.\r\nHowever, It *is* possible for sophisticated searchers to drain all the money from this contract \r\nat a rate of about 2.75 ETH per hour.\r\n\r\nPlay at your own risk, and know that you probably don't understand all the risks.\r\nNo refunds. I drink your tears. That's the whole point.\r\n\r\nHOW IT WORKS\r\n1. Register your upcoming attempt by calling register()\r\n    - Registering costs 1 ETH. You get this back, plus 0.02 ETH profit, only if you succeed in stealing the cheese.\r\n    - EOA's only.\r\n    - Must not register if your address is already registered.\r\n2. Steal the cheese by calling stealTheCheese() while passing in the target block number.\r\n    - You must wait at least 1 block after registering before trying to steal the cheese.\r\n    - You must use a priority fee of at least 20 gwei.\r\n    - You must pass in the correct block number.\r\n    - You must not try to steal the cheese for a block in which it's already been stolen.\r\n\r\nBreak any rule and you lose your 1 ETH. Otherwise, you get it back + another 0.02 ETH.\r\n\r\nMy hope is that I'll earn at least 1 ETH in failures before someone figures it out and drains the contract.\r\n\r\nThis contract has not been audited and is probably broken. Go nuts.\r\n*/\r\ncontract MouseTrap {\r\n    \r\n    mapping(address => uint256) public registeredBlock;\r\n    uint256 private lastBlockCheeseWasStolen;\r\n    address payable public immutable dev;\r\n    \r\n    constructor() {\r\n        require(msg.sender == tx.origin, 'dev must be EOA');\r\n        dev = payable(msg.sender);\r\n    }\r\n    \r\n    receive() external payable {}\r\n    \r\n    function register() external payable {\r\n        // no risk, no reward\r\n        if (msg.value < 1 ether) return;\r\n        \r\n        // EOA only\r\n        if (msg.sender != tx.origin) {\r\n            _lose();\r\n            return;\r\n        }\r\n        \r\n        // already registered\r\n        if (registeredBlock[msg.sender] != 0) {\r\n            _lose();\r\n            return;\r\n        }\r\n        \r\n        // successfully registered!\r\n        registeredBlock[msg.sender] = block.number;\r\n    }\r\n    \r\n    function stealTheCheese(uint256 _targetBlock) external {\r\n        // must register before trying to steal cheese\r\n        if (registeredBlock[msg.sender] == 0) return;\r\n        \r\n        // must wait at least 1 block after registering before trying to steal cheese\r\n        if (block.number == registeredBlock[msg.sender]) {\r\n            _lose();\r\n            return;\r\n        }\r\n        \r\n        // must have priority fee of at least 20 gwei\r\n        if (tx.gasprice - block.basefee < 20 gwei) {\r\n            _lose();\r\n            return;\r\n        }\r\n        \r\n        // must pass in the correct block number\r\n        if (_targetBlock != block.number) {\r\n            _lose();\r\n            return;\r\n        }\r\n        \r\n        // cheese can be stolen only once per block\r\n        if (lastBlockCheeseWasStolen == block.number) {\r\n            _lose();\r\n            return;\r\n        }\r\n        \r\n        lastBlockCheeseWasStolen = block.number;\r\n\r\n        // winner!!\r\n        sendValue(payable(msg.sender), 1.02 ether);\r\n    }\r\n    \r\n    function _lose() private {\r\n        registeredBlock[msg.sender] = 0;\r\n        sendValue(dev, 1 ether);\r\n    }\r\n\r\n    // OpenZeppelin's sendValue function\r\n\tfunction sendValue(address payable recipient, uint256 amount) private {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetBlock\",\"type\":\"uint256\"}],\"name\":\"stealTheCheese\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MouseTrap","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://762e60b63e05e4a6f7c41c294c860bb33b2c24b05a8d3f7f0318fb650c1fd916"}]}