{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165Storage.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Storage based implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\nabstract contract ERC165Storage is ERC165 {\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/access/IKOAccessControlsLookup.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IKOAccessControlsLookup {\r\n    function hasAdminRole(address _address) external view returns (bool);\r\n\r\n    function isVerifiedArtist(uint256 _index, address _account, bytes32[] calldata _merkleProof) external view returns (bool);\r\n\r\n    function isVerifiedArtistProxy(address _artist, address _proxy) external view returns (bool);\r\n\r\n    function hasLegacyMinterRole(address _address) external view returns (bool);\r\n\r\n    function hasContractRole(address _address) external view returns (bool);\r\n\r\n    function hasContractOrAdminRole(address _address) external view returns (bool);\r\n}\r\n\r\n// File: contracts/core/IERC2981.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @notice This is purely an extension for the KO platform\r\n/// @notice Royalties on KO are defined at an edition level for all tokens from the same edition\r\ninterface IERC2981EditionExtension {\r\n\r\n    /// @notice Does the edition have any royalties defined\r\n    function hasRoyalties(uint256 _editionId) external view returns (bool);\r\n\r\n    /// @notice Get the royalty receiver - all royalties should be sent to this account if not zero address\r\n    function getRoyaltiesReceiver(uint256 _editionId) external view returns (address);\r\n}\r\n\r\n/**\r\n * ERC2981 standards interface for royalties\r\n */\r\ninterface IERC2981 is IERC165, IERC2981EditionExtension {\r\n    /// ERC165 bytes to add to interface array - set in parent contract\r\n    /// implementing this standard\r\n    ///\r\n    /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\r\n    /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n    /// _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n    /// @notice Called with the sale price to determine how much royalty\r\n    //          is owed and to whom.\r\n    /// @param _tokenId - the NFT asset queried for royalty information\r\n    /// @param _value - the sale price of the NFT asset specified by _tokenId\r\n    /// @return _receiver - address of who should be sent the royalty payment\r\n    /// @return _royaltyAmount - the royalty payment amount for _value sale price\r\n    function royaltyInfo(\r\n        uint256 _tokenId,\r\n        uint256 _value\r\n    ) external view returns (\r\n        address _receiver,\r\n        uint256 _royaltyAmount\r\n    );\r\n\r\n}\r\n\r\n// File: contracts/core/IKODAV3Minter.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IKODAV3Minter {\r\n\r\n    function mintBatchEdition(uint16 _editionSize, address _to, string calldata _uri) external returns (uint256 _editionId);\r\n\r\n    function mintBatchEditionAndComposeERC20s(uint16 _editionSize, address _to, string calldata _uri, address[] calldata _erc20s, uint256[] calldata _amounts) external returns (uint256 _editionId);\r\n\r\n    function mintConsecutiveBatchEdition(uint16 _editionSize, address _to, string calldata _uri) external returns (uint256 _editionId);\r\n}\r\n\r\n// File: contracts/programmable/ITokenUriResolver.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface ITokenUriResolver {\r\n\r\n    /// @notice Return the edition or token level URI - token level trumps edition level if found\r\n    function tokenURI(uint256 _editionId, uint256 _tokenId) external view returns (string memory);\r\n\r\n    /// @notice Do we have an edition level or token level token URI resolver set\r\n    function isDefined(uint256 _editionId, uint256 _tokenId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/core/IERC2309.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n  @title ERC-2309: ERC-721 Batch Mint Extension\r\n  @dev https://github.com/ethereum/EIPs/issues/2309\r\n */\r\ninterface IERC2309 {\r\n    /**\r\n      @notice This event is emitted when ownership of a batch of tokens changes by any mechanism.\r\n      This includes minting, transferring, and burning.\r\n\r\n      @dev The address executing the transaction MUST own all the tokens within the range of\r\n      fromTokenId and toTokenId, or MUST be an approved operator to act on the owners behalf.\r\n      The fromTokenId and toTokenId MUST be a sequential range of tokens IDs.\r\n      When minting/creating tokens, the `fromAddress` argument MUST be set to `0x0` (i.e. zero address).\r\n      When burning/destroying tokens, the `toAddress` argument MUST be set to `0x0` (i.e. zero address).\r\n\r\n      @param fromTokenId The token ID that begins the batch of tokens being transferred\r\n      @param toTokenId The token ID that ends the batch of tokens being transferred\r\n      @param fromAddress The address transferring ownership of the specified range of tokens\r\n      @param toAddress The address receiving ownership of the specified range of tokens.\r\n    */\r\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\r\n}\r\n\r\n// File: contracts/core/IHasSecondarySaleFees.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Royalties formats required for use on the Rarible platform\r\n/// @dev https://docs.rarible.com/asset/royalties-schema\r\ninterface IHasSecondarySaleFees is IERC165 {\r\n\r\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\r\n\r\n    function getFeeRecipients(uint256 id) external returns (address payable[] memory);\r\n\r\n    function getFeeBps(uint256 id) external returns (uint[] memory);\r\n}\r\n\r\n// File: contracts/core/IKODAV3.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Core KODA V3 functionality\r\ninterface IKODAV3 is\r\nIERC165, // Contract introspection\r\nIERC721, // Core NFTs\r\nIERC2309, // Consecutive batch mint\r\nIERC2981, // Royalties\r\nIHasSecondarySaleFees // Rariable / Foundation royalties\r\n{\r\n    // edition utils\r\n\r\n    function getCreatorOfEdition(uint256 _editionId) external view returns (address _originalCreator);\r\n\r\n    function getCreatorOfToken(uint256 _tokenId) external view returns (address _originalCreator);\r\n\r\n    function getSizeOfEdition(uint256 _editionId) external view returns (uint256 _size);\r\n\r\n    function getEditionSizeOfToken(uint256 _tokenId) external view returns (uint256 _size);\r\n\r\n    function editionExists(uint256 _editionId) external view returns (bool);\r\n\r\n    // Has the edition been disabled / soft burnt\r\n    function isEditionSalesDisabled(uint256 _editionId) external view returns (bool);\r\n\r\n    // Has the edition been disabled / soft burnt OR sold out\r\n    function isSalesDisabledOrSoldOut(uint256 _editionId) external view returns (bool);\r\n\r\n    // Work out the max token ID for an edition ID\r\n    function maxTokenIdOfEdition(uint256 _editionId) external view returns (uint256 _tokenId);\r\n\r\n    // Helper method for getting the next primary sale token from an edition starting low to high token IDs\r\n    function getNextAvailablePrimarySaleToken(uint256 _editionId) external returns (uint256 _tokenId);\r\n\r\n    // Helper method for getting the next primary sale token from an edition starting high to low token IDs\r\n    function getReverseAvailablePrimarySaleToken(uint256 _editionId) external view returns (uint256 _tokenId);\r\n\r\n    // Utility method to get all data needed for the next primary sale, low token ID to high\r\n    function facilitateNextPrimarySale(uint256 _editionId) external returns (address _receiver, address _creator, uint256 _tokenId);\r\n\r\n    // Utility method to get all data needed for the next primary sale, high token ID to low\r\n    function facilitateReversePrimarySale(uint256 _editionId) external returns (address _receiver, address _creator, uint256 _tokenId);\r\n\r\n    // Expanded royalty method for the edition, not token\r\n    function royaltyAndCreatorInfo(uint256 _editionId, uint256 _value) external returns (address _receiver, address _creator, uint256 _amount);\r\n\r\n    // Allows the creator to correct mistakes until the first token from an edition is sold\r\n    function updateURIIfNoSaleMade(uint256 _editionId, string calldata _newURI) external;\r\n\r\n    // Has any primary transfer happened from an edition\r\n    function hasMadePrimarySale(uint256 _editionId) external view returns (bool);\r\n\r\n    // Has the edition sold out\r\n    function isEditionSoldOut(uint256 _editionId) external view returns (bool);\r\n\r\n    // Toggle on/off the edition from being able to make sales\r\n    function toggleEditionSalesDisabled(uint256 _editionId) external;\r\n\r\n    // token utils\r\n\r\n    function exists(uint256 _tokenId) external view returns (bool);\r\n\r\n    function getEditionIdOfToken(uint256 _tokenId) external pure returns (uint256 _editionId);\r\n\r\n    function getEditionDetails(uint256 _tokenId) external view returns (address _originalCreator, address _owner, uint16 _size, uint256 _editionId, string memory _uri);\r\n\r\n    function hadPrimarySaleOfToken(uint256 _tokenId) external view returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/core/composable/TopDownERC20Composable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ERC998ERC20TopDown {\r\n    event ReceivedERC20(address indexed _from, uint256 indexed _tokenId, address indexed _erc20Contract, uint256 _value);\r\n    event ReceivedERC20ForEdition(address indexed _from, uint256 indexed _editionId, address indexed _erc20Contract, uint256 _value);\r\n    event TransferERC20(uint256 indexed _tokenId, address indexed _to, address indexed _erc20Contract, uint256 _value);\r\n\r\n    function balanceOfERC20(uint256 _tokenId, address _erc20Contract) external view returns (uint256);\r\n\r\n    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external;\r\n\r\n    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) external;\r\n}\r\n\r\ninterface ERC998ERC20TopDownEnumerable {\r\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256);\r\n\r\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address);\r\n}\r\n\r\n/// @notice ERC998 ERC721 > ERC20 Top Down implementation\r\nabstract contract TopDownERC20Composable is ERC998ERC20TopDown, ERC998ERC20TopDownEnumerable, ReentrancyGuard, Context {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    // Edition ID -> ERC20 contract -> Balance of ERC20 for every token in Edition\r\n    mapping(uint256 => mapping(address => uint256)) public editionTokenERC20Balances;\r\n\r\n    // Edition ID -> ERC20 contract -> Token ID -> Balance Transferred out of token\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public editionTokenERC20TransferAmounts;\r\n\r\n    // Edition ID -> Linked ERC20 contract addresses\r\n    mapping(uint256 => EnumerableSet.AddressSet) ERC20sEmbeddedInEdition;\r\n\r\n    // Token ID -> Linked ERC20 contract addresses\r\n    mapping(uint256 => EnumerableSet.AddressSet) ERC20sEmbeddedInNft;\r\n\r\n    // Token ID -> ERC20 contract -> balance of ERC20 owned by token\r\n    mapping(uint256 => mapping(address => uint256)) public ERC20Balances;\r\n\r\n    /// @notice the ERC20 balance of a NFT token given an ERC20 token address\r\n    function balanceOfERC20(uint256 _tokenId, address _erc20Contract) public override view returns (uint256) {\r\n        IKODAV3 koda = IKODAV3(address(this));\r\n        uint256 editionId = koda.getEditionIdOfToken(_tokenId);\r\n\r\n        uint256 editionBalance = editionTokenERC20Balances[editionId][_erc20Contract];\r\n        uint256 tokenEditionBalance = editionBalance / koda.getSizeOfEdition(editionId);\r\n        uint256 spentTokens = editionTokenERC20TransferAmounts[editionId][_erc20Contract][_tokenId];\r\n        tokenEditionBalance = tokenEditionBalance - spentTokens;\r\n\r\n        return tokenEditionBalance + ERC20Balances[_tokenId][_erc20Contract];\r\n    }\r\n\r\n    /// @notice Transfer out an ERC20 from an NFT\r\n    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external override nonReentrant {\r\n        _prepareERC20LikeTransfer(_tokenId, _to, _erc20Contract, _value);\r\n\r\n        IERC20(_erc20Contract).transfer(_to, _value);\r\n\r\n        emit TransferERC20(_tokenId, _to, _erc20Contract, _value);\r\n    }\r\n\r\n    /// @notice An NFT token owner (or approved) can compose multiple ERC20s in their NFT\r\n    function getERC20s(address _from, uint256[] calldata _tokenIds, address _erc20Contract, uint256 _totalValue) external {\r\n        uint256 totalTokens = _tokenIds.length;\r\n        require(totalTokens > 0 && _totalValue > 0, \"Empty values\");\r\n\r\n        uint256 valuePerToken = _totalValue / totalTokens;\r\n        for (uint i = 0; i < totalTokens; i++) {\r\n            getERC20(_from, _tokenIds[i], _erc20Contract, valuePerToken);\r\n        }\r\n    }\r\n\r\n    /// @notice A NFT token owner (or approved address) can compose any ERC20 in their NFT\r\n    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) public override nonReentrant {\r\n        require(_value > 0, \"Value zero\");\r\n        require(_from == _msgSender(), \"Only owner\");\r\n\r\n        address spender = _msgSender();\r\n        IERC721 self = IERC721(address(this));\r\n\r\n        address owner = self.ownerOf(_tokenId);\r\n        require(\r\n            owner == spender || self.isApprovedForAll(owner, spender) || self.getApproved(_tokenId) == spender,\r\n            \"Invalid spender\"\r\n        );\r\n\r\n        uint256 editionId = IKODAV3(address(this)).getEditionIdOfToken(_tokenId);\r\n        bool editionAlreadyContainsERC20 = ERC20sEmbeddedInEdition[editionId].contains(_erc20Contract);\r\n        bool nftAlreadyContainsERC20 = ERC20sEmbeddedInNft[_tokenId].contains(_erc20Contract);\r\n\r\n        // does not already contain _erc20Contract\r\n        if (!editionAlreadyContainsERC20 && !nftAlreadyContainsERC20) {\r\n            ERC20sEmbeddedInNft[_tokenId].add(_erc20Contract);\r\n        }\r\n\r\n        ERC20Balances[_tokenId][_erc20Contract] = ERC20Balances[_tokenId][_erc20Contract] + _value;\r\n\r\n        IERC20 token = IERC20(_erc20Contract);\r\n        require(token.allowance(_from, address(this)) >= _value, \"Exceeds allowance\");\r\n\r\n        token.transferFrom(_from, address(this), _value);\r\n\r\n        emit ReceivedERC20(_from, _tokenId, _erc20Contract, _value);\r\n    }\r\n\r\n    function _composeERC20IntoEdition(address _from, uint256 _editionId, address _erc20Contract, uint256 _value) internal nonReentrant {\r\n        require(_value > 0, \"Value zero\");\r\n\r\n        require(!ERC20sEmbeddedInEdition[_editionId].contains(_erc20Contract), \"Edition contains ERC20\");\r\n\r\n        ERC20sEmbeddedInEdition[_editionId].add(_erc20Contract);\r\n        editionTokenERC20Balances[_editionId][_erc20Contract] = editionTokenERC20Balances[_editionId][_erc20Contract] + _value;\r\n\r\n        IERC20(_erc20Contract).transferFrom(_from, address(this), _value);\r\n\r\n        emit ReceivedERC20ForEdition(_from, _editionId, _erc20Contract, _value);\r\n    }\r\n\r\n    function totalERC20Contracts(uint256 _tokenId) override public view returns (uint256) {\r\n        uint256 editionId = IKODAV3(address(this)).getEditionIdOfToken(_tokenId);\r\n        return ERC20sEmbeddedInNft[_tokenId].length() + ERC20sEmbeddedInEdition[editionId].length();\r\n    }\r\n\r\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) override external view returns (address) {\r\n        uint256 numOfERC20sInNFT = ERC20sEmbeddedInNft[_tokenId].length();\r\n        if (_index >= numOfERC20sInNFT) {\r\n            uint256 editionId =  IKODAV3(address(this)).getEditionIdOfToken(_tokenId);\r\n            return ERC20sEmbeddedInEdition[editionId].at(_index - numOfERC20sInNFT);\r\n        }\r\n\r\n        return ERC20sEmbeddedInNft[_tokenId].at(_index);\r\n    }\r\n\r\n    /// --- Internal ----\r\n\r\n    function _prepareERC20LikeTransfer(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) private {\r\n        // To avoid stack too deep, do input checks within this scope\r\n        {\r\n            require(_value > 0, \"Value zero\");\r\n            require(_to != address(0), \"Zero address\");\r\n\r\n            IERC721 self = IERC721(address(this));\r\n\r\n            address owner = self.ownerOf(_tokenId);\r\n            require(\r\n                owner == _msgSender() || self.isApprovedForAll(owner, _msgSender()) || self.getApproved(_tokenId) == _msgSender(),\r\n                \"Not owner\"\r\n            );\r\n        }\r\n\r\n        // Check that the NFT contains the ERC20\r\n        bool nftContainsERC20 = ERC20sEmbeddedInNft[_tokenId].contains(_erc20Contract);\r\n\r\n        IKODAV3 koda = IKODAV3(address(this));\r\n        uint256 editionId = koda.getEditionIdOfToken(_tokenId);\r\n        bool editionContainsERC20 = ERC20sEmbeddedInEdition[editionId].contains(_erc20Contract);\r\n        require(nftContainsERC20 || editionContainsERC20, \"No such ERC20\");\r\n\r\n        // Check there is enough balance to transfer out\r\n        require(balanceOfERC20(_tokenId, _erc20Contract) >= _value, \"Exceeds balance\");\r\n\r\n        uint256 editionSize = koda.getSizeOfEdition(editionId);\r\n        uint256 tokenInitialBalance = editionTokenERC20Balances[editionId][_erc20Contract] / editionSize;\r\n        uint256 spentTokens = editionTokenERC20TransferAmounts[editionId][_erc20Contract][_tokenId];\r\n        uint256 editionTokenBalance = tokenInitialBalance - spentTokens;\r\n\r\n        // Check whether the value can be fully transferred from the edition balance, token balance or both balances\r\n        if (editionTokenBalance >= _value) {\r\n            editionTokenERC20TransferAmounts[editionId][_erc20Contract][_tokenId] = spentTokens + _value;\r\n        } else if (ERC20Balances[_tokenId][_erc20Contract] >= _value) {\r\n            ERC20Balances[_tokenId][_erc20Contract] = ERC20Balances[_tokenId][_erc20Contract] - _value;\r\n        } else {\r\n            // take from both balances\r\n            editionTokenERC20TransferAmounts[editionId][_erc20Contract][_tokenId] = spentTokens + editionTokenBalance;\r\n            uint256 amountOfTokensToSpendFromTokenBalance = _value - editionTokenBalance;\r\n            ERC20Balances[_tokenId][_erc20Contract] = ERC20Balances[_tokenId][_erc20Contract] - amountOfTokensToSpendFromTokenBalance;\r\n        }\r\n\r\n        // The ERC20 is no longer composed within the token if the balance falls to zero\r\n        if (nftContainsERC20 && ERC20Balances[_tokenId][_erc20Contract] == 0) {\r\n            ERC20sEmbeddedInNft[_tokenId].remove(_erc20Contract);\r\n        }\r\n\r\n        // If all tokens in an edition have spent their ERC20 balance, then we can remove the link\r\n        if (editionContainsERC20) {\r\n            uint256 allTokensInEditionERC20Balance;\r\n            for (uint i = 0; i < editionSize; i++) {\r\n                uint256 tokenBal = tokenInitialBalance - editionTokenERC20TransferAmounts[editionId][_erc20Contract][editionId + i];\r\n                allTokensInEditionERC20Balance = allTokensInEditionERC20Balance + tokenBal;\r\n            }\r\n\r\n            if (allTokensInEditionERC20Balance == 0) {\r\n                ERC20sEmbeddedInEdition[editionId].remove(_erc20Contract);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/core/composable/TopDownSimpleERC721Composable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\nabstract contract TopDownSimpleERC721Composable is Context {\r\n    struct ComposedNFT {\r\n        address nft;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    // KODA Token ID -> composed nft\r\n    mapping(uint256 => ComposedNFT) public kodaTokenComposedNFT;\r\n\r\n    // External NFT address -> External Token ID -> KODA token ID\r\n    mapping(address => mapping(uint256 => uint256)) public composedNFTsToKodaToken;\r\n\r\n    event ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId);\r\n    event TransferChild(uint256 indexed _tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\r\n\r\n    /// @notice compose a set of the same child ERC721s into a KODA tokens\r\n    /// @notice Caller must own both KODA and child NFT tokens\r\n    function composeNFTsIntoKodaTokens(uint256[] calldata _kodaTokenIds, address _nft, uint256[] calldata _nftTokenIds) external {\r\n        uint256 totalKodaTokens = _kodaTokenIds.length;\r\n        require(totalKodaTokens > 0 && totalKodaTokens == _nftTokenIds.length, \"Invalid list\");\r\n\r\n        IERC721 nftContract = IERC721(_nft);\r\n\r\n        for (uint i = 0; i < totalKodaTokens; i++) {\r\n            uint256 _kodaTokenId = _kodaTokenIds[i];\r\n            uint256 _nftTokenId = _nftTokenIds[i];\r\n\r\n            require(\r\n                IERC721(address(this)).ownerOf(_kodaTokenId) == nftContract.ownerOf(_nftTokenId),\r\n                \"Owner mismatch\"\r\n            );\r\n\r\n            kodaTokenComposedNFT[_kodaTokenId] = ComposedNFT(_nft, _nftTokenId);\r\n            composedNFTsToKodaToken[_nft][_nftTokenId] = _kodaTokenId;\r\n\r\n            nftContract.transferFrom(_msgSender(), address(this), _nftTokenId);\r\n            emit ReceivedChild(_msgSender(), _kodaTokenId, _nft, _nftTokenId);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfer a child 721 wrapped within a KODA token to a given recipient\r\n    /// @notice only KODA token owner can call this\r\n    function transferChild(uint256 _kodaTokenId, address _recipient) external {\r\n        require(\r\n            IERC721(address(this)).ownerOf(_kodaTokenId) == _msgSender(),\r\n            \"Only KODA owner\"\r\n        );\r\n\r\n        address nft = kodaTokenComposedNFT[_kodaTokenId].nft;\r\n        uint256 nftId = kodaTokenComposedNFT[_kodaTokenId].tokenId;\r\n\r\n        delete kodaTokenComposedNFT[_kodaTokenId];\r\n        delete composedNFTsToKodaToken[nft][nftId];\r\n\r\n        IERC721(nft).transferFrom(address(this), _recipient, nftId);\r\n\r\n        emit TransferChild(_kodaTokenId, _recipient, nft, nftId);\r\n    }\r\n}\r\n\r\n// File: contracts/core/Konstants.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\ncontract Konstants {\r\n\r\n    // Every edition always goes up in batches of 1000\r\n    uint16 public constant MAX_EDITION_SIZE = 1000;\r\n\r\n    // magic method that defines the maximum range for an edition - this is fixed forever - tokens are minted in range\r\n    function _editionFromTokenId(uint256 _tokenId) internal pure returns (uint256) {\r\n        return (_tokenId / MAX_EDITION_SIZE) * MAX_EDITION_SIZE;\r\n    }\r\n}\r\n\r\n// File: contracts/core/BaseKoda.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract BaseKoda is Konstants, Context, IKODAV3 {\r\n\r\n    bytes4 constant internal ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n\r\n    event AdminUpdateSecondaryRoyalty(uint256 _secondarySaleRoyalty);\r\n    event AdminUpdateBasisPointsModulo(uint256 _basisPointsModulo);\r\n    event AdminUpdateModulo(uint256 _modulo);\r\n    event AdminEditionReported(uint256 indexed _editionId, bool indexed _reported);\r\n    event AdminArtistAccountReported(address indexed _account, bool indexed _reported);\r\n    event AdminUpdateAccessControls(IKOAccessControlsLookup indexed _oldAddress, IKOAccessControlsLookup indexed _newAddress);\r\n\r\n    modifier onlyContract(){\r\n        _onlyContract();\r\n        _;\r\n    }\r\n\r\n    function _onlyContract() private view {\r\n        require(accessControls.hasContractRole(_msgSender()), \"Must be contract\");\r\n    }\r\n\r\n    modifier onlyAdmin(){\r\n        _onlyAdmin();\r\n        _;\r\n    }\r\n\r\n    function _onlyAdmin() private view {\r\n        require(accessControls.hasAdminRole(_msgSender()), \"Must be admin\");\r\n    }\r\n\r\n    IKOAccessControlsLookup public accessControls;\r\n\r\n    // A onchain reference to editions which have been reported for some infringement purposes to KO\r\n    mapping(uint256 => bool) public reportedEditionIds;\r\n\r\n    // A onchain reference to accounts which have been lost/hacked etc\r\n    mapping(address => bool) public reportedArtistAccounts;\r\n\r\n    // Secondary sale commission\r\n    uint256 public secondarySaleRoyalty = 12_50000; // 12.5% by default\r\n\r\n    /// @notice precision 100.00000%\r\n    uint256 public modulo = 100_00000;\r\n\r\n    /// @notice Basis points conversion modulo\r\n    /// @notice This is used by the IHasSecondarySaleFees implementation which is different than EIP-2981 specs\r\n    uint256 public basisPointsModulo = 1000;\r\n\r\n    constructor(IKOAccessControlsLookup _accessControls) {\r\n        accessControls = _accessControls;\r\n    }\r\n\r\n    function reportEditionId(uint256 _editionId, bool _reported) onlyAdmin public {\r\n        reportedEditionIds[_editionId] = _reported;\r\n        emit AdminEditionReported(_editionId, _reported);\r\n    }\r\n\r\n    function reportArtistAccount(address _account, bool _reported) onlyAdmin public {\r\n        reportedArtistAccounts[_account] = _reported;\r\n        emit AdminArtistAccountReported(_account, _reported);\r\n    }\r\n\r\n    function updateBasisPointsModulo(uint256 _basisPointsModulo) onlyAdmin public {\r\n        require(_basisPointsModulo > 0, \"Is zero\");\r\n        basisPointsModulo = _basisPointsModulo;\r\n        emit AdminUpdateBasisPointsModulo(_basisPointsModulo);\r\n    }\r\n\r\n    function updateModulo(uint256 _modulo) onlyAdmin public {\r\n        require(_modulo > 0, \"Is zero\");\r\n        modulo = _modulo;\r\n        emit AdminUpdateModulo(_modulo);\r\n    }\r\n\r\n    function updateSecondaryRoyalty(uint256 _secondarySaleRoyalty) onlyAdmin public {\r\n        secondarySaleRoyalty = _secondarySaleRoyalty;\r\n        emit AdminUpdateSecondaryRoyalty(_secondarySaleRoyalty);\r\n    }\r\n\r\n    function updateAccessControls(IKOAccessControlsLookup _accessControls) public onlyAdmin {\r\n        require(_accessControls.hasAdminRole(_msgSender()), \"Must be admin\");\r\n        emit AdminUpdateAccessControls(accessControls, _accessControls);\r\n        accessControls = _accessControls;\r\n    }\r\n\r\n    /// @dev Allows for the ability to extract stuck ERC20 tokens\r\n    /// @dev Only callable from admin\r\n    function withdrawStuckTokens(address _tokenAddress, uint256 _amount, address _withdrawalAccount) onlyAdmin public {\r\n        IERC20(_tokenAddress).transfer(_withdrawalAccount, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/core/KnownOriginDigitalAssetV3.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title A ERC-721 compliant contract which has a focus on being GAS efficient along with being able to support\r\n/// both unique tokens and multi-editions sharing common traits but of limited supply\r\n///\r\n/// @author KnownOrigin Labs - https://knownorigin.io/\r\n///\r\n/// @notice The NFT supports a range of standards such as:\r\n/// @notice EIP-2981 Royalties Standard\r\n/// @notice EIP-2309 Consecutive batch mint\r\n/// @notice ERC-998 Top-down ERC-20 composable\r\ncontract KnownOriginDigitalAssetV3 is\r\nTopDownERC20Composable,\r\nTopDownSimpleERC721Composable,\r\nBaseKoda,\r\nERC165Storage,\r\nIKODAV3Minter {\r\n\r\n    event EditionURIUpdated(uint256 indexed _editionId);\r\n    event EditionSalesDisabledToggled(uint256 indexed _editionId, bool _oldValue, bool _newValue);\r\n    event SealedEditionMetaDataSet(uint256 indexed _editionId);\r\n    event SealedTokenMetaDataSet(uint256 indexed _tokenId);\r\n    event AdditionalEditionUnlockableSet(uint256 indexed _editionId);\r\n    event AdminRoyaltiesRegistryProxySet(address indexed _royaltiesRegistryProxy);\r\n    event AdminTokenUriResolverSet(address indexed _tokenUriResolver);\r\n\r\n    modifier validateEdition(uint256 _editionId) {\r\n        _validateEdition(_editionId);\r\n        _;\r\n    }\r\n\r\n    function _validateEdition(uint256 _editionId) private view {\r\n        require(_editionExists(_editionId), \"Edition does not exist\");\r\n    }\r\n\r\n    modifier validateCreator(uint256 _editionId) {\r\n        address creator = getCreatorOfEdition(_editionId);\r\n        require(\r\n            _msgSender() == creator || accessControls.isVerifiedArtistProxy(creator, _msgSender()),\r\n            \"Only creator or proxy\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @notice Token name\r\n    string public constant name = \"KnownOriginDigitalAsset\";\r\n\r\n    /// @notice Token symbol\r\n    string public constant symbol = \"KODA\";\r\n\r\n    /// @notice KODA version\r\n    string public constant version = \"3\";\r\n\r\n    /// @notice Royalties registry\r\n    IERC2981 public royaltiesRegistryProxy;\r\n\r\n    /// @notice Token URI resolver\r\n    ITokenUriResolver public tokenUriResolver;\r\n\r\n    /// @notice Edition number pointer\r\n    uint256 public editionPointer;\r\n\r\n    struct EditionDetails {\r\n        address creator; // primary edition/token creator\r\n        uint16 editionSize; // onchain edition size\r\n        string uri; // the referenced metadata\r\n    }\r\n\r\n    /// @dev tokens are minted in batches - the first token ID used is representative of the edition ID\r\n    mapping(uint256 => EditionDetails) internal editionDetails;\r\n\r\n    /// @dev Mapping of tokenId => owner - only set on first transfer (after mint) such as a primary sale and/or gift\r\n    mapping(uint256 => address) internal owners;\r\n\r\n    /// @dev Mapping of owner => number of tokens owned\r\n    mapping(address => uint256) internal balances;\r\n\r\n    /// @dev Mapping of tokenId => approved address\r\n    mapping(uint256 => address) internal approvals;\r\n\r\n    /// @dev Mapping of owner => operator => approved\r\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\r\n\r\n    /// @notice Optional one time use storage slot for additional edition metadata\r\n    mapping(uint256 => string) public sealedEditionMetaData;\r\n\r\n    /// @notice Optional one time use storage slot for additional token metadata such ass peramweb metadata\r\n    mapping(uint256 => string) public sealedTokenMetaData;\r\n\r\n    /// @notice Allows a creator to disable sales of their edition\r\n    mapping(uint256 => bool) public editionSalesDisabled;\r\n\r\n    constructor(\r\n        IKOAccessControlsLookup _accessControls,\r\n        IERC2981 _royaltiesRegistryProxy,\r\n        uint256 _editionPointer\r\n    ) BaseKoda(_accessControls) {\r\n        // starting point for new edition IDs\r\n        editionPointer = _editionPointer;\r\n\r\n        // optional registry address - can be constructed as zero address\r\n        royaltiesRegistryProxy = _royaltiesRegistryProxy;\r\n\r\n        // INTERFACE_ID_ERC721\r\n        _registerInterface(0x80ac58cd);\r\n\r\n        // INTERFACE_ID_ERC721_METADATA\r\n        _registerInterface(0x5b5e139f);\r\n\r\n        // _INTERFACE_ID_ERC2981\r\n        _registerInterface(0x2a55205a);\r\n\r\n        // _INTERFACE_ID_FEES\r\n        _registerInterface(0xb7799584);\r\n    }\r\n\r\n    /// @notice Mints batches of tokens emitting multiple Transfer events\r\n    function mintBatchEdition(uint16 _editionSize, address _to, string calldata _uri)\r\n    public\r\n    override\r\n    onlyContract\r\n    returns (uint256 _editionId) {\r\n        return _mintBatchEdition(_editionSize, _to, _uri);\r\n    }\r\n\r\n    /// @notice Mints an edition token batch and composes ERC20s for every token in the edition\r\n    function mintBatchEditionAndComposeERC20s(\r\n        uint16 _editionSize,\r\n        address _to,\r\n        string calldata _uri,\r\n        address[] calldata _erc20s,\r\n        uint256[] calldata _amounts\r\n    ) external\r\n    override\r\n    onlyContract\r\n    returns (uint256 _editionId) {\r\n        uint256 totalErc20s = _erc20s.length;\r\n        require(totalErc20s > 0 && totalErc20s == _amounts.length, \"Tokens invalid\");\r\n\r\n        _editionId = _mintBatchEdition(_editionSize, _to, _uri);\r\n\r\n        for (uint i = 0; i < totalErc20s; i++) {\r\n            _composeERC20IntoEdition(_to, _editionId, _erc20s[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    function _mintBatchEdition(uint16 _editionSize, address _to, string calldata _uri) internal returns (uint256) {\r\n        require(_editionSize > 0 && _editionSize <= MAX_EDITION_SIZE, \"Invalid size\");\r\n\r\n        uint256 start = generateNextEditionNumber();\r\n\r\n        // N.B: Dont store owner, see ownerOf method to special case checking to avoid storage costs on creation\r\n\r\n        // assign balance\r\n        balances[_to] = balances[_to] + _editionSize;\r\n\r\n        // edition of x\r\n        editionDetails[start] = EditionDetails(_to, _editionSize, _uri);\r\n\r\n        // Loop emit all transfer events\r\n        uint256 end = start + _editionSize;\r\n        for (uint i = start; i < end; i++) {\r\n            emit Transfer(address(0), _to, i);\r\n        }\r\n        return start;\r\n    }\r\n\r\n    /// @notice Mints batches of tokens but emits a single ConsecutiveTransfer event EIP-2309\r\n    function mintConsecutiveBatchEdition(uint16 _editionSize, address _to, string calldata _uri)\r\n    public\r\n    override\r\n    onlyContract\r\n    returns (uint256 _editionId) {\r\n        require(_editionSize > 0 && _editionSize <= MAX_EDITION_SIZE, \"Invalid size\");\r\n\r\n        uint256 start = generateNextEditionNumber();\r\n\r\n        // N.B: Dont store owner, see ownerOf method to special case checking to avoid storage costs on creation\r\n\r\n        // assign balance\r\n        balances[_to] = balances[_to] + _editionSize;\r\n\r\n        // Start ID always equals edition ID\r\n        editionDetails[start] = EditionDetails(_to, _editionSize, _uri);\r\n\r\n        // emit EIP-2309 consecutive transfer event\r\n        emit ConsecutiveTransfer(start, start + _editionSize, address(0), _to);\r\n\r\n        return start;\r\n    }\r\n\r\n    /// @notice Allows the creator of an edition to update the token URI provided that no primary sales have been made\r\n    function updateURIIfNoSaleMade(uint256 _editionId, string calldata _newURI)\r\n    external\r\n    override\r\n    validateCreator(_editionId) {\r\n        require(\r\n            !hasMadePrimarySale(_editionId) && (!tokenUriResolverActive() || !tokenUriResolver.isDefined(_editionId, 0)),\r\n            \"Invalid state\"\r\n        );\r\n\r\n        editionDetails[_editionId].uri = _newURI;\r\n\r\n        emit EditionURIUpdated(_editionId);\r\n    }\r\n\r\n    /// @notice Increases the edition pointer and then returns this pointer for minting methods\r\n    function generateNextEditionNumber() internal returns (uint256) {\r\n        editionPointer = editionPointer + MAX_EDITION_SIZE;\r\n        return editionPointer;\r\n    }\r\n\r\n    /// @notice URI for an edition. Individual tokens in an edition will have this URI when tokenURI() is called\r\n    function editionURI(uint256 _editionId) validateEdition(_editionId) public view returns (string memory) {\r\n\r\n        // Here we are checking only that the edition has a edition level resolver - there may be a overridden token level resolver\r\n        if (tokenUriResolverActive() && tokenUriResolver.isDefined(_editionId, 0)) {\r\n            return tokenUriResolver.tokenURI(_editionId, 0);\r\n        }\r\n\r\n        return editionDetails[_editionId].uri;\r\n    }\r\n\r\n    /// @notice Returns the URI based on the edition associated with a token\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\r\n        require(_exists(_tokenId), \"Token does not exist\");\r\n        uint256 editionId = _editionFromTokenId(_tokenId);\r\n\r\n        if (tokenUriResolverActive() && tokenUriResolver.isDefined(editionId, _tokenId)) {\r\n            return tokenUriResolver.tokenURI(editionId, _tokenId);\r\n        }\r\n\r\n        return editionDetails[editionId].uri;\r\n    }\r\n\r\n    /// @notice Allows the caller to check if external URI resolver is active\r\n    function tokenUriResolverActive() public view returns (bool) {\r\n        return address(tokenUriResolver) != address(0);\r\n    }\r\n\r\n    /// @notice Additional metadata string for an edition\r\n    function editionAdditionalMetaData(uint256 _editionId) public view returns (string memory) {\r\n        return sealedEditionMetaData[_editionId];\r\n    }\r\n\r\n    /// @notice Additional metadata string for a token\r\n    function tokenAdditionalMetaData(uint256 _tokenId) public view returns (string memory) {\r\n        return sealedTokenMetaData[_tokenId];\r\n    }\r\n\r\n    /// @notice Additional metadata string for an edition given a token ID\r\n    function editionAdditionalMetaDataForToken(uint256 _tokenId) public view returns (string memory) {\r\n        uint256 editionId = _editionFromTokenId(_tokenId);\r\n        return sealedEditionMetaData[editionId];\r\n    }\r\n\r\n    function getEditionDetails(uint256 _tokenId)\r\n    public\r\n    override\r\n    view\r\n    returns (address _originalCreator, address _owner, uint16 _size, uint256 _editionId, string memory _uri) {\r\n        uint256 editionId = _editionFromTokenId(_tokenId);\r\n        EditionDetails storage edition = editionDetails[editionId];\r\n        return (\r\n        edition.creator,\r\n        _ownerOf(_tokenId, editionId),\r\n        edition.editionSize,\r\n        editionId,\r\n        tokenURI(_tokenId)\r\n        );\r\n    }\r\n\r\n\r\n    /// @notice If primary sales for an edition are disabled\r\n    function isEditionSalesDisabled(uint256 _editionId) external view override returns (bool) {\r\n        return editionSalesDisabled[_editionId];\r\n    }\r\n\r\n    /// @notice If primary sales for an edition are disabled or if the edition is sold out\r\n    function isSalesDisabledOrSoldOut(uint256 _editionId) external view override returns (bool) {\r\n        return editionSalesDisabled[_editionId] || isEditionSoldOut(_editionId);\r\n    }\r\n\r\n    /// @notice Toggle for disabling primary sales for an edition\r\n    function toggleEditionSalesDisabled(uint256 _editionId) validateEdition(_editionId) external override {\r\n        address creator = editionDetails[_editionId].creator;\r\n\r\n        require(\r\n            creator == _msgSender() || accessControls.hasAdminRole(_msgSender()),\r\n            \"Only creator or admin\"\r\n        );\r\n\r\n        emit EditionSalesDisabledToggled(_editionId, editionSalesDisabled[_editionId], !editionSalesDisabled[_editionId]);\r\n\r\n        editionSalesDisabled[_editionId] = !editionSalesDisabled[_editionId];\r\n    }\r\n\r\n    ///////////////////\r\n    // Creator query //\r\n    ///////////////////\r\n\r\n    function getCreatorOfEdition(uint256 _editionId) public override view returns (address _originalCreator) {\r\n        return _getCreatorOfEdition(_editionId);\r\n    }\r\n\r\n    function getCreatorOfToken(uint256 _tokenId) public override view returns (address _originalCreator) {\r\n        return _getCreatorOfEdition(_editionFromTokenId(_tokenId));\r\n    }\r\n\r\n    function _getCreatorOfEdition(uint256 _editionId) internal view returns (address _originalCreator) {\r\n        return editionDetails[_editionId].creator;\r\n    }\r\n\r\n    ////////////////\r\n    // Size query //\r\n    ////////////////\r\n\r\n    function getSizeOfEdition(uint256 _editionId) public override view returns (uint256 _size) {\r\n        return editionDetails[_editionId].editionSize;\r\n    }\r\n\r\n    function getEditionSizeOfToken(uint256 _tokenId) public override view returns (uint256 _size) {\r\n        return editionDetails[_editionFromTokenId(_tokenId)].editionSize;\r\n    }\r\n\r\n    /////////////////////\r\n    // Existence query //\r\n    /////////////////////\r\n\r\n    function editionExists(uint256 _editionId) public override view returns (bool) {\r\n        return _editionExists(_editionId);\r\n    }\r\n\r\n    function _editionExists(uint256 _editionId) internal view returns (bool) {\r\n        return editionDetails[_editionId].editionSize > 0;\r\n    }\r\n\r\n    function exists(uint256 _tokenId) public override view returns (bool) {\r\n        return _exists(_tokenId);\r\n    }\r\n\r\n    function _exists(uint256 _tokenId) internal view returns (bool) {\r\n        return _ownerOf(_tokenId, _editionFromTokenId(_tokenId)) != address(0);\r\n    }\r\n\r\n    /// @notice Returns the last token ID of an edition based on the edition's size\r\n    function maxTokenIdOfEdition(uint256 _editionId) public override view returns (uint256 _tokenId) {\r\n        return _maxTokenIdOfEdition(_editionId);\r\n    }\r\n\r\n    function _maxTokenIdOfEdition(uint256 _editionId) internal view returns (uint256 _tokenId) {\r\n        return editionDetails[_editionId].editionSize + _editionId;\r\n    }\r\n\r\n    ////////////////\r\n    // Edition ID //\r\n    ////////////////\r\n\r\n    function getEditionIdOfToken(uint256 _tokenId) public override pure returns (uint256 _editionId) {\r\n        return _editionFromTokenId(_tokenId);\r\n    }\r\n\r\n    function _royaltyInfo(uint256 _tokenId, uint256 _value) internal view returns (address _receiver, uint256 _royaltyAmount) {\r\n        uint256 editionId = _editionFromTokenId(_tokenId);\r\n        // If we have a registry and its defined, use it\r\n        if (royaltyRegistryActive() && royaltiesRegistryProxy.hasRoyalties(editionId)) {\r\n            // Note: any registry must be edition aware so to only store one entry for all within the edition\r\n            (_receiver, _royaltyAmount) = royaltiesRegistryProxy.royaltyInfo(editionId, _value);\r\n        } else {\r\n            // Fall back to KO defaults\r\n            _receiver = _getCreatorOfEdition(editionId);\r\n            _royaltyAmount = (_value / modulo) * secondarySaleRoyalty;\r\n        }\r\n    }\r\n\r\n    //////////////\r\n    // ERC-2981 //\r\n    //////////////\r\n\r\n    // Abstract away token royalty registry, proxy through to the implementation\r\n    function royaltyInfo(uint256 _tokenId, uint256 _value)\r\n    external\r\n    override\r\n    view\r\n    returns (address _receiver, uint256 _royaltyAmount) {\r\n        return _royaltyInfo(_tokenId, _value);\r\n    }\r\n\r\n    // Expanded method at edition level and expanding on the funds receiver and the creator\r\n    function royaltyAndCreatorInfo(uint256 _tokenId, uint256 _value)\r\n    external\r\n    view\r\n    override\r\n    returns (address receiver, address creator, uint256 royaltyAmount) {\r\n        address originalCreator = _getCreatorOfEdition(_editionFromTokenId(_tokenId));\r\n        (address _receiver, uint256 _royaltyAmount) = _royaltyInfo(_tokenId, _value);\r\n        return (_receiver, originalCreator, _royaltyAmount);\r\n    }\r\n\r\n    function hasRoyalties(uint256 _editionId) validateEdition(_editionId) external override view returns (bool) {\r\n        return royaltyRegistryActive() && royaltiesRegistryProxy.hasRoyalties(_editionId)\r\n        || secondarySaleRoyalty > 0;\r\n    }\r\n\r\n    function getRoyaltiesReceiver(uint256 _tokenId) public override view returns (address) {\r\n        uint256 editionId = _editionFromTokenId(_tokenId);\r\n        if (royaltyRegistryActive() && royaltiesRegistryProxy.hasRoyalties(editionId)) {\r\n            return royaltiesRegistryProxy.getRoyaltiesReceiver(editionId);\r\n        }\r\n        return _getCreatorOfEdition(editionId);\r\n    }\r\n\r\n    function royaltyRegistryActive() public view returns (bool) {\r\n        return address(royaltiesRegistryProxy) != address(0);\r\n    }\r\n\r\n    //////////////////////////////\r\n    // Has Secondary Sale Fees //\r\n    ////////////////////////////\r\n\r\n    function getFeeRecipients(uint256 _tokenId) external view override returns (address payable[] memory) {\r\n        address payable[] memory feeRecipients = new address payable[](1);\r\n        feeRecipients[0] = payable(getRoyaltiesReceiver(_tokenId));\r\n        return feeRecipients;\r\n    }\r\n\r\n    function getFeeBps(uint256) external view override returns (uint[] memory) {\r\n        uint[] memory feeBps = new uint[](1);\r\n        feeBps[0] = uint(secondarySaleRoyalty) / basisPointsModulo;\r\n        // convert to basis points\r\n        return feeBps;\r\n    }\r\n\r\n    ////////////////////////////////////\r\n    // Primary Sale Utilities methods //\r\n    ////////////////////////////////////\r\n\r\n    /// @notice List of token IDs that are still with the original creator\r\n    function getAllUnsoldTokenIdsForEdition(uint256 _editionId) validateEdition(_editionId) public view returns (uint256[] memory) {\r\n        uint256 maxTokenId = _maxTokenIdOfEdition(_editionId);\r\n\r\n        // work out number of unsold tokens in order to allocate memory to an array later\r\n        uint256 numOfUnsoldTokens;\r\n        for (uint256 i = _editionId; i < maxTokenId; i++) {\r\n            // if no owner set - assume primary if not moved\r\n            if (owners[i] == address(0)) {\r\n                numOfUnsoldTokens += 1;\r\n            }\r\n        }\r\n\r\n        uint256[] memory unsoldTokens = new uint256[](numOfUnsoldTokens);\r\n\r\n        // record token IDs of unsold tokens\r\n        uint256 nextIndex;\r\n        for (uint256 tokenId = _editionId; tokenId < maxTokenId; tokenId++) {\r\n            // if no owner set - assume primary if not moved\r\n            if (owners[tokenId] == address(0)) {\r\n                unsoldTokens[nextIndex] = tokenId;\r\n                nextIndex += 1;\r\n            }\r\n        }\r\n\r\n        return unsoldTokens;\r\n    }\r\n\r\n    /// @notice For a given edition, returns the next token and associated royalty information\r\n    function facilitateNextPrimarySale(uint256 _editionId)\r\n    public\r\n    view\r\n    override\r\n    returns (address receiver, address creator, uint256 tokenId) {\r\n        require(!editionSalesDisabled[_editionId], \"Edition disabled\");\r\n\r\n        uint256 _tokenId = getNextAvailablePrimarySaleToken(_editionId);\r\n        address _creator = _getCreatorOfEdition(_editionId);\r\n\r\n        if (royaltyRegistryActive() && royaltiesRegistryProxy.hasRoyalties(_editionId)) {\r\n            address _receiver = royaltiesRegistryProxy.getRoyaltiesReceiver(_editionId);\r\n            return (_receiver, _creator, _tokenId);\r\n        }\r\n\r\n        return (_creator, _creator, _tokenId);\r\n    }\r\n\r\n    /// @notice Return the next unsold token ID for a given edition unless all tokens have been sold\r\n    function getNextAvailablePrimarySaleToken(uint256 _editionId) public override view returns (uint256 _tokenId) {\r\n        uint256 maxTokenId = _maxTokenIdOfEdition(_editionId);\r\n\r\n        // low to high\r\n        for (uint256 tokenId = _editionId; tokenId < maxTokenId; tokenId++) {\r\n            // if no owner set - assume primary if not moved\r\n            if (owners[tokenId] == address(0)) {\r\n                return tokenId;\r\n            }\r\n        }\r\n        revert(\"Primary market exhausted\");\r\n    }\r\n\r\n    /// @notice Starting from the last token in an edition and going down the first, returns the next unsold token (if any)\r\n    function getReverseAvailablePrimarySaleToken(uint256 _editionId) public override view returns (uint256 _tokenId) {\r\n        uint256 highestTokenId = _maxTokenIdOfEdition(_editionId) - 1;\r\n\r\n        // high to low\r\n        while (highestTokenId >= _editionId) {\r\n            // if no owner set - assume primary if not moved\r\n            if (owners[highestTokenId] == address(0)) {\r\n                return highestTokenId;\r\n            }\r\n            highestTokenId--;\r\n        }\r\n        revert(\"Primary market exhausted\");\r\n    }\r\n\r\n    /// @notice Using the reverse token ID logic of an edition, returns next token ID and associated royalty information\r\n    function facilitateReversePrimarySale(uint256 _editionId)\r\n    public\r\n    view\r\n    override\r\n    returns (address receiver, address creator, uint256 tokenId) {\r\n        require(!editionSalesDisabled[_editionId], \"Edition disabled\");\r\n\r\n        uint256 _tokenId = getReverseAvailablePrimarySaleToken(_editionId);\r\n        address _creator = _getCreatorOfEdition(_editionId);\r\n\r\n        if (royaltyRegistryActive() && royaltiesRegistryProxy.hasRoyalties(_editionId)) {\r\n            address _receiver = royaltiesRegistryProxy.getRoyaltiesReceiver(_editionId);\r\n            return (_receiver, _creator, _tokenId);\r\n        }\r\n\r\n        return (_creator, _creator, _tokenId);\r\n    }\r\n\r\n    /// @notice If the token specified by token ID has been sold on the primary market\r\n    function hadPrimarySaleOfToken(uint256 _tokenId) public override view returns (bool) {\r\n        return owners[_tokenId] != address(0);\r\n    }\r\n\r\n    /// @notice If any token in the edition has been sold\r\n    function hasMadePrimarySale(uint256 _editionId) validateEdition(_editionId) public override view returns (bool) {\r\n        uint256 maxTokenId = _maxTokenIdOfEdition(_editionId);\r\n\r\n        // low to high\r\n        for (uint256 tokenId = _editionId; tokenId < maxTokenId; tokenId++) {\r\n            // if no owner set - assume primary if not moved\r\n            if (owners[tokenId] != address(0)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice If all tokens in the edition have been sold\r\n    function isEditionSoldOut(uint256 _editionId) validateEdition(_editionId) public override view returns (bool) {\r\n        uint256 maxTokenId = _maxTokenIdOfEdition(_editionId);\r\n\r\n        // low to high\r\n        for (uint256 tokenId = _editionId; tokenId < maxTokenId; tokenId++) {\r\n            // if no owner set - assume primary if not moved\r\n            if (owners[tokenId] == address(0)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    //////////////\r\n    // Defaults //\r\n    //////////////\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///      `onERC721Received` on `_to` and throws if the return value is not\r\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param _data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) override external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n\r\n        // move the token\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///      except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) override external {\r\n        _safeTransferFrom(_from, _to, _tokenId, bytes(\"\"));\r\n\r\n        // move the token\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) private {\r\n        _transferFrom(_from, _to, _tokenId);\r\n\r\n        uint256 receiverCodeSize;\r\n        assembly {\r\n            receiverCodeSize := extcodesize(_to)\r\n        }\r\n        if (receiverCodeSize > 0) {\r\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\r\n                _msgSender(),\r\n                _from,\r\n                _tokenId,\r\n                _data\r\n            );\r\n            require(\r\n                selector == ERC721_RECEIVED,\r\n                \"Invalid selector\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///         THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `_msgSender()` is the current owner, an authorized\r\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///      `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) override external {\r\n        _transferFrom(_from, _to, _tokenId);\r\n\r\n        // move the token\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _transferFrom(address _from, address _to, uint256 _tokenId) private {\r\n        // enforce not being able to send to zero as we have explicit rules what a minted but unbound owner is\r\n        require(_to != address(0), \"Invalid to address\");\r\n\r\n        // Ensure the owner is the sender\r\n        address owner = _ownerOf(_tokenId, _editionFromTokenId(_tokenId));\r\n        require(owner != address(0), \"Invalid owner\");\r\n        require(_from == owner, \"Owner mismatch\");\r\n\r\n        address spender = _msgSender();\r\n        address approvedAddress = getApproved(_tokenId);\r\n        require(\r\n            spender == owner // sending to myself\r\n            || isApprovedForAll(owner, spender)  // is approved to send any behalf of owner\r\n            || approvedAddress == spender, // is approved to move this token ID\r\n            \"Invalid spender\"\r\n        );\r\n\r\n        // Ensure approval for token ID is cleared\r\n        if (approvedAddress != address(0)) {\r\n            approvals[_tokenId] = address(0);\r\n        }\r\n\r\n        // set new owner - this will now override any specific other mappings for the base edition config\r\n        owners[_tokenId] = _to;\r\n\r\n        // Modify balances\r\n        balances[_from] = balances[_from] - 1;\r\n        balances[_to] = balances[_to] + 1;\r\n    }\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) override public view returns (address) {\r\n        uint256 editionId = _editionFromTokenId(_tokenId);\r\n        address owner = _ownerOf(_tokenId, editionId);\r\n        require(owner != address(0), \"Invalid owner\");\r\n        return owner;\r\n    }\r\n\r\n    /// @dev Newly created editions and its tokens minted to a creator don't have the owner set until the token is sold on the primary market\r\n    /// @dev Therefore, if internally an edition exists and owner of token is zero address, then creator still owns the token\r\n    /// @dev Otherwise, the token owner is returned or the zero address if the token does not exist\r\n    function _ownerOf(uint256 _tokenId, uint256 _editionId) internal view returns (address) {\r\n\r\n        // If an owner assigned\r\n        address owner = owners[_tokenId];\r\n        if (owner != address(0)) {\r\n            return owner;\r\n        }\r\n\r\n        // fall back to edition creator\r\n        address possibleCreator = _getCreatorOfEdition(_editionId);\r\n        if (possibleCreator != address(0) && (_maxTokenIdOfEdition(_editionId) - 1) >= _tokenId) {\r\n            return possibleCreator;\r\n        }\r\n\r\n        return address(0);\r\n    }\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///      operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) override external {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_approved != owner, \"Approved is owner\");\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"Invalid sender\");\r\n        approvals[_tokenId] = _approved;\r\n        emit Approval(owner, _approved, _tokenId);\r\n    }\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///         all of `msg.sender`\"s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///      multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) override external {\r\n        operatorApprovals[_msgSender()][_operator] = _approved;\r\n        emit ApprovalForAll(\r\n            _msgSender(),\r\n            _operator,\r\n            _approved\r\n        );\r\n    }\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///      function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) override external view returns (uint256) {\r\n        require(_owner != address(0), \"Invalid owner\");\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) override public view returns (address){\r\n        return approvals[_tokenId];\r\n    }\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) override public view returns (bool){\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    /// @notice An extension to the default ERC721 behaviour, derived from ERC-875.\r\n    /// @dev Allowing for batch transfers from the provided address, will fail if from does not own all the tokens\r\n    function batchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds) public {\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            _safeTransferFrom(_from, _to, _tokenIds[i], bytes(\"\"));\r\n            emit Transfer(_from, _to, _tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice An extension to the default ERC721 behaviour, derived from ERC-875 but using the ConsecutiveTransfer event\r\n    /// @dev Allowing for batch transfers from the provided address, will fail if from does not own all the tokens\r\n    function consecutiveBatchTransferFrom(address _from, address _to, uint256 _fromTokenId, uint256 _toTokenId) public {\r\n        for (uint256 i = _fromTokenId; i <= _toTokenId; i++) {\r\n            _safeTransferFrom(_from, _to, i, bytes(\"\"));\r\n        }\r\n        emit ConsecutiveTransfer(_fromTokenId, _toTokenId, _from, _to);\r\n    }\r\n\r\n    /////////////////////\r\n    // Admin functions //\r\n    /////////////////////\r\n\r\n    function setRoyaltiesRegistryProxy(IERC2981 _royaltiesRegistryProxy) onlyAdmin public {\r\n        royaltiesRegistryProxy = _royaltiesRegistryProxy;\r\n        emit AdminRoyaltiesRegistryProxySet(address(_royaltiesRegistryProxy));\r\n    }\r\n\r\n    function setTokenUriResolver(ITokenUriResolver _tokenUriResolver) onlyAdmin public {\r\n        tokenUriResolver = _tokenUriResolver;\r\n        emit AdminTokenUriResolverSet(address(_tokenUriResolver));\r\n    }\r\n\r\n    ///////////////////////\r\n    // Creator functions //\r\n    ///////////////////////\r\n\r\n    function composeERC20sAsCreator(uint16 _editionId, address[] calldata _erc20s, uint256[] calldata _amounts)\r\n    external\r\n    validateCreator(_editionId) {\r\n        require(!isEditionSoldOut(_editionId), \"Edition soldout\");\r\n\r\n        uint256 totalErc20s = _erc20s.length;\r\n        require(totalErc20s > 0 && totalErc20s == _amounts.length, \"Tokens invalid\");\r\n\r\n        for (uint i = 0; i < totalErc20s; i++) {\r\n            _composeERC20IntoEdition(_msgSender(), _editionId, _erc20s[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Optional metadata storage slot which allows the creator to set an additional metadata blob on the edition\r\n    function lockInAdditionalMetaData(uint256 _editionId, string calldata _metadata)\r\n    external\r\n    validateCreator(_editionId) {\r\n        require(bytes(sealedEditionMetaData[_editionId]).length == 0, \"Already set\");\r\n        sealedEditionMetaData[_editionId] = _metadata;\r\n        emit SealedEditionMetaDataSet(_editionId);\r\n    }\r\n\r\n    /// @notice Optional metadata storage slot which allows a token owner to set an additional metadata blob on the token\r\n    function lockInAdditionalTokenMetaData(uint256 _tokenId, string calldata _metadata) external {\r\n        require(\r\n            _msgSender() == ownerOf(_tokenId) || accessControls.hasContractRole(_msgSender()),\r\n            \"Invalid caller\"\r\n        );\r\n        require(bytes(sealedTokenMetaData[_tokenId]).length == 0, \"Already set\");\r\n        sealedTokenMetaData[_tokenId] = _metadata;\r\n        emit SealedTokenMetaDataSet(_tokenId);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IKOAccessControlsLookup\",\"name\":\"_accessControls\",\"type\":\"address\"},{\"internalType\":\"contract IERC2981\",\"name\":\"_royaltiesRegistryProxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_editionPointer\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"AdditionalEditionUnlockableSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_reported\",\"type\":\"bool\"}],\"name\":\"AdminArtistAccountReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_reported\",\"type\":\"bool\"}],\"name\":\"AdminEditionReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_royaltiesRegistryProxy\",\"type\":\"address\"}],\"name\":\"AdminRoyaltiesRegistryProxySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenUriResolver\",\"type\":\"address\"}],\"name\":\"AdminTokenUriResolverSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IKOAccessControlsLookup\",\"name\":\"_oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IKOAccessControlsLookup\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"AdminUpdateAccessControls\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_basisPointsModulo\",\"type\":\"uint256\"}],\"name\":\"AdminUpdateBasisPointsModulo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_modulo\",\"type\":\"uint256\"}],\"name\":\"AdminUpdateModulo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_secondarySaleRoyalty\",\"type\":\"uint256\"}],\"name\":\"AdminUpdateSecondaryRoyalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_oldValue\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_newValue\",\"type\":\"bool\"}],\"name\":\"EditionSalesDisabledToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"EditionURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"ReceivedChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ReceivedERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ReceivedERC20ForEdition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"SealedEditionMetaDataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"SealedTokenMetaDataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"bps\",\"type\":\"uint256[]\"}],\"name\":\"SecondarySaleFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"TransferChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferERC20\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ERC20Balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EDITION_SIZE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControls\",\"outputs\":[{\"internalType\":\"contract IKOAccessControlsLookup\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"}],\"name\":\"balanceOfERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basisPointsModulo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_editionId\",\"type\":\"uint16\"},{\"internalType\":\"address[]\",\"name\":\"_erc20s\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"composeERC20sAsCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_kodaTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"composeNFTsIntoKodaTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"composedNFTsToKodaToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"consecutiveBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"editionAdditionalMetaData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"editionAdditionalMetaDataForToken\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"editionExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editionPointer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editionSalesDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"editionTokenERC20Balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editionTokenERC20TransferAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"editionURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"erc20ContractByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"facilitateNextPrimarySale\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"facilitateReversePrimarySale\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"getAllUnsoldTokenIdsForEdition\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"getCreatorOfEdition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_originalCreator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreatorOfToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_originalCreator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalValue\",\"type\":\"uint256\"}],\"name\":\"getERC20s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getEditionDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_originalCreator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_size\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getEditionIdOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getEditionSizeOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getFeeBps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getFeeRecipients\",\"outputs\":[{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"getNextAvailablePrimarySaleToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"getReverseAvailablePrimarySaleToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltiesReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"getSizeOfEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"hadPrimarySaleOfToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"hasMadePrimarySale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"hasRoyalties\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"isEditionSalesDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"isEditionSoldOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"isSalesDisabledOrSoldOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kodaTokenComposedNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"lockInAdditionalMetaData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"lockInAdditionalTokenMetaData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"maxTokenIdOfEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_editionSize\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"mintBatchEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_editionSize\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"_erc20s\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintBatchEditionAndComposeERC20s\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_editionSize\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"mintConsecutiveBatchEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modulo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_reported\",\"type\":\"bool\"}],\"name\":\"reportArtistAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_reported\",\"type\":\"bool\"}],\"name\":\"reportEditionId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reportedArtistAccounts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reportedEditionIds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltiesRegistryProxy\",\"outputs\":[{\"internalType\":\"contract IERC2981\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"royaltyAndCreatorInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyRegistryActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sealedEditionMetaData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sealedTokenMetaData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondarySaleRoyalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC2981\",\"name\":\"_royaltiesRegistryProxy\",\"type\":\"address\"}],\"name\":\"setRoyaltiesRegistryProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenUriResolver\",\"name\":\"_tokenUriResolver\",\"type\":\"address\"}],\"name\":\"setTokenUriResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"}],\"name\":\"toggleEditionSalesDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenAdditionalMetaData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenUriResolver\",\"outputs\":[{\"internalType\":\"contract ITokenUriResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenUriResolverActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"totalERC20Contracts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_kodaTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"transferChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKOAccessControlsLookup\",\"name\":\"_accessControls\",\"type\":\"address\"}],\"name\":\"updateAccessControls\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_basisPointsModulo\",\"type\":\"uint256\"}],\"name\":\"updateBasisPointsModulo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_modulo\",\"type\":\"uint256\"}],\"name\":\"updateModulo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_secondarySaleRoyalty\",\"type\":\"uint256\"}],\"name\":\"updateSecondaryRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_newURI\",\"type\":\"string\"}],\"name\":\"updateURIIfNoSaleMade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_withdrawalAccount\",\"type\":\"address\"}],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KnownOriginDigitalAssetV3","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009028b16494a9363f3eaaf381a6fde67296abc68c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c3500","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5712aba8ff8bcb06b189f5b71d437e5dcf339bf4f383c556b796b346234366d8"}]}