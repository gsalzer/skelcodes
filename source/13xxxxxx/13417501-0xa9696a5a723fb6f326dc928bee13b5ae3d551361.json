{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/InterPack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n\\ninterface ICubes {\\n    function mintByPack(address owner) external;\\n}\\n\\n\\ncontract InterPack is Ownable {\\n    \\n    modifier callerIsUser() {\\n        require(tx.origin == msg.sender, \\\"The caller is another contract\\\");\\n        _;\\n    }\\n\\n    modifier onlyCollaborator() {\\n        bool isCollaborator = false;\\n        for (uint256 i; i < collaborators.length; i++) {\\n            if (collaborators[i].addr == msg.sender) {\\n                isCollaborator = true;\\n\\n                break;\\n            }\\n        }\\n\\n        require(\\n            owner() == _msgSender() || isCollaborator,\\n            \\\"Ownable: caller is not the owner nor a collaborator\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    modifier mintStarted() {\\n        require(\\n            (startRegularMintDate != 0 && startRegularMintDate <= block.timestamp),\\n            \\\"You are too early\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    \\n    uint256 private startRegularMintDate = 1632952800; // 29.09.2021 22:00 UTC\\n\\n    uint256 private claimPrice = 90000000000000000;\\n\\n    \\n    uint256 private totalTokens = 8116;\\n    uint256 private totalMintedTokens = 0;\\n\\n\\n    uint128 private basisPoints = 10000;\\n    \\n    uint16 private maxRegularClaimsPerWallet = 20;\\n    \\n    mapping(address => uint256) private claimedTokenPerWallet;\\n    \\n    \\n    struct Collaborators {\\n        address addr;\\n        uint256 cut;\\n    }\\n    \\n    Collaborators[] internal collaborators;\\n    \\n    address private packContractAddress;\\n    address private cubesContractAddress;\\n    \\n    struct Holder { \\n       bool set;\\n       uint8 minted;\\n    }\\n    \\n    mapping(address => Holder) private mintpassHolders;\\n    uint256 private mintpassHoldersCurrentSize = 0;\\n    uint8 private maxFreeSetsPerHolder = 1;\\n    \\n\\n    \\n    // ONLY OWNER\\n\\n    /**\\n     * Sets the collaborators of the project with their cuts\\n     */\\n    function addCollaborators(Collaborators[] memory _collaborators)\\n        external\\n        onlyOwner\\n    {\\n        require(collaborators.length == 0, \\\"Collaborators were already set\\\");\\n\\n        uint128 totalCut;\\n        for (uint256 i; i < _collaborators.length; i++) {\\n            collaborators.push(_collaborators[i]);\\n            totalCut += uint128(_collaborators[i].cut);\\n        }\\n\\n        require(totalCut == basisPoints, \\\"Total cut does not add to 100%\\\");\\n    }\\n\\n    \\n    \\n    function setCubesAddr(address _addr) external onlyOwner {\\n       cubesContractAddress = _addr;\\n    }\\n    \\n    function setPackAddr(address _addr) external onlyOwner {\\n       packContractAddress = _addr;\\n    }\\n\\n    /**\\n     * @dev Sets the claim price for each token\\n     */\\n    function setClaimPrice(uint256 _claimPrice) external onlyOwner {\\n        claimPrice = _claimPrice;\\n    }\\n    \\n    function setStartRegularMintDate(uint256 _startMintDate) external onlyOwner {\\n        startRegularMintDate = _startMintDate;\\n    }\\n    \\n    function setTotalTokens(uint256 _num) external onlyOwner {\\n        require (_num >= totalMintedTokens, \\\"Cannot be less than already minted\\\");\\n        totalTokens = _num;\\n    }\\n\\n    function setMaxPerWallet(uint16 _num) external onlyOwner {\\n        maxRegularClaimsPerWallet = _num;\\n    }\\n\\n    \\n    function giftSet(address[] calldata _addresses) external onlyOwner {\\n        require((totalMintedTokens + _addresses.length) <= totalTokens, \\\"No sets left to be minted\\\");\\n\\n        for (uint i = 0; i < _addresses.length; i++) {\\n            ICubes(cubesContractAddress).mintByPack(_addresses[i]);\\n        }\\n        \\n        \\n        totalMintedTokens = totalMintedTokens + _addresses.length;\\n    }\\n    \\n    function addMintpassHolders(address[] calldata _addrs) external onlyOwner {\\n        require((mintpassHoldersCurrentSize + _addrs.length) <= 1000, 'Max mintpass holders num exceed');\\n        \\n        for (uint128 i = 0; i < _addrs.length; i++) {\\n            mintpassHolders[_addrs[i]] = Holder(true, 0);\\n        }\\n        \\n        mintpassHoldersCurrentSize = mintpassHoldersCurrentSize + _addrs.length;\\n    }\\n    \\n    function setMaxFreeSetsPerholder(uint8 _num) external onlyOwner {\\n        maxFreeSetsPerHolder = _num;\\n    }\\n    \\n    // ONLY collaborators\\n    \\n    /**\\n     * @dev Allows to withdraw the Ether in the contract and split it among the collaborators\\n     */\\n    function withdraw() external onlyCollaborator {\\n        uint256 totalBalance = address(this).balance;\\n\\n        for (uint256 i; i < collaborators.length; i++) {\\n            payable(collaborators[i].addr).transfer(\\n                mulScale(totalBalance, collaborators[i].cut, basisPoints)\\n            );\\n        }\\n    }\\n\\n\\n    // END ONLY COLLABORATORS\\n\\n\\n    \\n    \\n    fallback() external payable {}\\n    \\n    receive() external payable {}\\n    \\n    function getAvailableToMint() external view returns (uint256) {\\n        return (totalTokens - totalMintedTokens);\\n    }\\n    \\n    function mint(uint8 _numOfPacks) external payable callerIsUser mintStarted {\\n        require(msg.value >= (claimPrice * _numOfPacks), \\\"Not enough Ether to mint a pack\\\");\\n        require((totalMintedTokens + _numOfPacks) <= totalTokens, \\\"No packs left to be minted\\\");\\n        \\n        require(\\n            (claimedTokenPerWallet[msg.sender] + _numOfPacks) <= maxRegularClaimsPerWallet,\\n            \\\"You cannot claim more packs.\\\"\\n        );\\n\\n        for (uint8 j = 0; j < _numOfPacks; j++) {\\n            ICubes(cubesContractAddress).mintByPack(msg.sender);\\n        }\\n        \\n        totalMintedTokens = totalMintedTokens + _numOfPacks;\\n        claimedTokenPerWallet[msg.sender] = claimedTokenPerWallet[msg.sender] + _numOfPacks;\\n    }\\n    \\n    function mintByPack(address owner) external {\\n        require(msg.sender == packContractAddress, \\\"Unauthorized\\\");\\n        ICubes(cubesContractAddress).mintByPack(owner);\\n    }\\n    \\n    function claimFreeSet() external {\\n        \\n        require(true == mintpassHolders[msg.sender].set, \\\"You are not in the mintpass holder list.\\\");\\n        require(maxFreeSetsPerHolder > mintpassHolders[msg.sender].minted, \\\"You cannot claim more free sets.\\\");\\n        \\n        mintpassHolders[msg.sender].minted++;\\n        ICubes(cubesContractAddress).mintByPack(msg.sender);\\n        totalMintedTokens++;\\n    }\\n    \\n    function getMintpassHoldersCurrentSize() external view returns (uint) {\\n        return mintpassHoldersCurrentSize;\\n    }\\n    \\n    function isAddresRegisterdAsMintpassHolder (address _addr) external view returns (bool) {\\n        return mintpassHolders[_addr].set;\\n    }\\n    \\n    function getNumOfFreeSetMinted (address _addr) external view returns (uint8) {\\n        return mintpassHolders[_addr].minted;\\n    }\\n    \\n    function getNumOfMintsPerAddr(address _addr) external view returns (uint256) {\\n        return claimedTokenPerWallet[_addr];\\n    }\\n    \\n    // INTERNAL \\n    \\n    function mulScale(\\n        uint256 x,\\n        uint256 y,\\n        uint128 scale\\n    ) internal pure returns (uint256) {\\n        uint256 a = x / scale;\\n        uint256 b = x % scale;\\n        uint256 c = y / scale;\\n        uint256 d = y % scale;\\n\\n        return a * c * scale + a * d + b * c + (b * d) / scale;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cut\",\"type\":\"uint256\"}],\"internalType\":\"struct InterPack.Collaborators[]\",\"name\":\"_collaborators\",\"type\":\"tuple[]\"}],\"name\":\"addCollaborators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"addMintpassHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFreeSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableToMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintpassHoldersCurrentSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getNumOfFreeSetMinted\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getNumOfMintsPerAddr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"giftSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isAddresRegisterdAsMintpassHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_numOfPacks\",\"type\":\"uint8\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"mintByPack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimPrice\",\"type\":\"uint256\"}],\"name\":\"setClaimPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setCubesAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_num\",\"type\":\"uint8\"}],\"name\":\"setMaxFreeSetsPerholder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_num\",\"type\":\"uint16\"}],\"name\":\"setMaxPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPackAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startMintDate\",\"type\":\"uint256\"}],\"name\":\"setStartRegularMintDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"setTotalTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"InterPack","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}