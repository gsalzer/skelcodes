{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/helpers/OptionHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"../interfaces/IConfigurationManager.sol\\\";\\nimport \\\"../interfaces/IPodOption.sol\\\";\\nimport \\\"../interfaces/IOptionAMMPool.sol\\\";\\nimport \\\"../interfaces/IOptionPoolRegistry.sol\\\";\\n\\n/**\\n * @title PodOption\\n * @author Pods Finance\\n * @notice Represents a Proxy that can perform a set of operations on the behalf of an user\\n */\\ncontract OptionHelper is ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev store globally accessed configurations\\n     */\\n    IConfigurationManager public immutable configurationManager;\\n\\n    event OptionsBought(\\n        address indexed buyer,\\n        address indexed optionAddress,\\n        uint256 optionsBought,\\n        address inputToken,\\n        uint256 inputSold\\n    );\\n\\n    event OptionsSold(\\n        address indexed seller,\\n        address indexed optionAddress,\\n        uint256 optionsSold,\\n        address outputToken,\\n        uint256 outputReceived\\n    );\\n\\n    event OptionsMintedAndSold(\\n        address indexed seller,\\n        address indexed optionAddress,\\n        uint256 optionsMintedAndSold,\\n        address outputToken,\\n        uint256 outputBought\\n    );\\n\\n    event LiquidityAdded(\\n        address indexed staker,\\n        address indexed optionAddress,\\n        uint256 amountOptions,\\n        address token,\\n        uint256 tokenAmount\\n    );\\n\\n    constructor(IConfigurationManager _configurationManager) public {\\n        require(\\n            Address.isContract(address(_configurationManager)),\\n            \\\"OptionHelper: Configuration Manager is not a contract\\\"\\n        );\\n        configurationManager = _configurationManager;\\n    }\\n\\n    modifier withinDeadline(uint256 deadline) {\\n        require(deadline > block.timestamp, \\\"OptionHelper: deadline expired\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Mint options\\n     * @dev Mints an amount of options and return to caller\\n     *\\n     * @param option The option contract to mint\\n     * @param optionAmount Amount of options to mint\\n     */\\n    function mint(IPodOption option, uint256 optionAmount) external {\\n        _mint(option, optionAmount);\\n\\n        // Transfers back the minted options\\n        IERC20(address(option)).safeTransfer(msg.sender, optionAmount);\\n    }\\n\\n    /**\\n     * @notice Mint and sell options\\n     * @dev Mints an amount of options and sell it in pool\\n     *\\n     * @param option The option contract to mint\\n     * @param optionAmount Amount of options to mint\\n     * @param minTokenAmount Minimum amount of output tokens accepted\\n     * @param deadline The deadline in unix-timestamp that limits the transaction from happening\\n     * @param initialIVGuess The initial implied volatility guess\\n     */\\n    function mintAndSellOptions(\\n        IPodOption option,\\n        uint256 optionAmount,\\n        uint256 minTokenAmount,\\n        uint256 deadline,\\n        uint256 initialIVGuess\\n    ) external nonReentrant withinDeadline(deadline) {\\n        IOptionAMMPool pool = _getPool(option);\\n\\n        _mint(option, optionAmount);\\n\\n        // Approve pool transfer\\n        IERC20(address(option)).safeApprove(address(pool), optionAmount);\\n\\n        // Sells options to pool\\n        uint256 tokensBought = pool.tradeExactAInput(optionAmount, minTokenAmount, msg.sender, initialIVGuess);\\n\\n        emit OptionsMintedAndSold(msg.sender, address(option), optionAmount, pool.tokenB(), tokensBought);\\n    }\\n\\n    /**\\n     * @notice Mint and add liquidity\\n     * @dev Mint options and provide them as liquidity to the pool\\n     *\\n     * @param option The option contract to mint\\n     * @param optionAmount Amount of options to mint\\n     * @param tokenAmount Amount of tokens to provide as liquidity\\n     */\\n    function mintAndAddLiquidity(\\n        IPodOption option,\\n        uint256 optionAmount,\\n        uint256 tokenAmount\\n    ) external nonReentrant {\\n        IOptionAMMPool pool = _getPool(option);\\n        IERC20 tokenB = IERC20(pool.tokenB());\\n\\n        _mint(option, optionAmount);\\n\\n        if (tokenAmount > 0) {\\n            // Take stable token from caller\\n            tokenB.safeTransferFrom(msg.sender, address(this), tokenAmount);\\n        }\\n\\n        // Approve pool transfer\\n        IERC20(address(option)).safeApprove(address(pool), optionAmount);\\n        tokenB.safeApprove(address(pool), tokenAmount);\\n\\n        // Adds options and tokens to pool as liquidity\\n        pool.addLiquidity(optionAmount, tokenAmount, msg.sender);\\n\\n        emit LiquidityAdded(msg.sender, address(option), optionAmount, pool.tokenB(), tokenAmount);\\n    }\\n\\n    /**\\n     * @notice Mint and add liquidity using only collateralAmount as input\\n     * @dev Mint options and provide them as liquidity to the pool\\n     *\\n     * @param option The option contract to mint\\n     * @param collateralAmount Amount of collateral tokens to be used to both mint and mint into the stable side\\n     */\\n    function mintAndAddLiquidityWithCollateral(IPodOption option, uint256 collateralAmount) external nonReentrant {\\n        require(option.optionType() == IPodOption.OptionType.PUT, \\\"OptionHelper: Invalid option type\\\");\\n        IOptionAMMPool pool = _getPool(option);\\n        IERC20 tokenB = IERC20(pool.tokenB());\\n\\n        (uint256 optionAmount, uint256 tokenBToAdd) = _calculateEvenAmounts(option, collateralAmount);\\n\\n        _mint(option, optionAmount);\\n\\n        tokenB.safeTransferFrom(msg.sender, address(this), tokenBToAdd);\\n\\n        // Approve pool transfer\\n        IERC20(address(option)).safeApprove(address(pool), optionAmount);\\n        tokenB.safeApprove(address(pool), tokenBToAdd);\\n\\n        // Adds options and tokens to pool as liquidity\\n        pool.addLiquidity(optionAmount, tokenBToAdd, msg.sender);\\n\\n        emit LiquidityAdded(msg.sender, address(option), optionAmount, pool.tokenB(), tokenBToAdd);\\n    }\\n\\n    /**\\n     * @notice Add liquidity\\n     * @dev Provide options as liquidity to the pool\\n     *\\n     * @param option The option contract to mint\\n     * @param optionAmount Amount of options to provide\\n     * @param tokenAmount Amount of tokens to provide as liquidity\\n     */\\n    function addLiquidity(\\n        IPodOption option,\\n        uint256 optionAmount,\\n        uint256 tokenAmount\\n    ) external nonReentrant {\\n        IOptionAMMPool pool = _getPool(option);\\n        IERC20 tokenB = IERC20(pool.tokenB());\\n\\n        if (optionAmount > 0) {\\n            // Take options from caller\\n            IERC20(address(option)).safeTransferFrom(msg.sender, address(this), optionAmount);\\n        }\\n\\n        if (tokenAmount > 0) {\\n            // Take stable token from caller\\n            tokenB.safeTransferFrom(msg.sender, address(this), tokenAmount);\\n        }\\n\\n        // Approve pool transfer\\n        IERC20(address(option)).safeApprove(address(pool), optionAmount);\\n        tokenB.safeApprove(address(pool), tokenAmount);\\n\\n        // Adds options and tokens to pool as liquidity\\n        pool.addLiquidity(optionAmount, tokenAmount, msg.sender);\\n\\n        emit LiquidityAdded(msg.sender, address(option), optionAmount, pool.tokenB(), tokenAmount);\\n    }\\n\\n    /**\\n     * @notice Sell exact amount of options\\n     * @dev Sell an amount of options from pool\\n     *\\n     * @param option The option contract to sell\\n     * @param optionAmount Amount of options to sell\\n     * @param minTokenReceived Min amount of input tokens to receive\\n     * @param deadline The deadline in unix-timestamp that limits the transaction from happening\\n     * @param initialIVGuess The initial implied volatility guess\\n     */\\n    function sellExactOptions(\\n        IPodOption option,\\n        uint256 optionAmount,\\n        uint256 minTokenReceived,\\n        uint256 deadline,\\n        uint256 initialIVGuess\\n    ) external withinDeadline(deadline) nonReentrant {\\n        IOptionAMMPool pool = _getPool(option);\\n        IERC20 tokenA = IERC20(pool.tokenA());\\n\\n        // Take input amount from caller\\n        tokenA.safeTransferFrom(msg.sender, address(this), optionAmount);\\n\\n        // Approve pool transfer\\n        tokenA.safeApprove(address(pool), optionAmount);\\n\\n        // Buys options from pool\\n        uint256 tokenAmountReceived = pool.tradeExactAInput(optionAmount, minTokenReceived, msg.sender, initialIVGuess);\\n\\n        emit OptionsSold(msg.sender, address(option), optionAmount, pool.tokenB(), tokenAmountReceived);\\n    }\\n\\n    /**\\n     * @notice Sell estimated amount of options\\n     * @dev Sell an estimated amount of options to the pool\\n     *\\n     * @param option The option contract to sell\\n     * @param maxOptionAmount max Amount of options to sell\\n     * @param exactTokenReceived exact amount of input tokens to receive\\n     * @param deadline The deadline in unix-timestamp that limits the transaction from happening\\n     * @param initialIVGuess The initial implied volatility guess\\n     */\\n    function sellOptionsAndReceiveExactTokens(\\n        IPodOption option,\\n        uint256 maxOptionAmount,\\n        uint256 exactTokenReceived,\\n        uint256 deadline,\\n        uint256 initialIVGuess\\n    ) external withinDeadline(deadline) nonReentrant {\\n        IOptionAMMPool pool = _getPool(option);\\n        IERC20 tokenA = IERC20(pool.tokenA());\\n\\n        // Take input amount from caller\\n        tokenA.safeTransferFrom(msg.sender, address(this), maxOptionAmount);\\n\\n        // Approve pool transfer\\n        tokenA.safeApprove(address(pool), maxOptionAmount);\\n\\n        // Buys options from pool\\n        uint256 optionsSold = pool.tradeExactBOutput(exactTokenReceived, maxOptionAmount, msg.sender, initialIVGuess);\\n\\n        uint256 unusedFunds = maxOptionAmount.sub(optionsSold);\\n\\n        // Reset allowance\\n        tokenA.safeApprove(address(pool), 0);\\n\\n        // Transfer back unused funds\\n        if (unusedFunds > 0) {\\n            tokenA.safeTransfer(msg.sender, unusedFunds);\\n        }\\n\\n        emit OptionsSold(msg.sender, address(option), optionsSold, pool.tokenB(), exactTokenReceived);\\n    }\\n\\n    /**\\n     * @notice Buy exact amount of options\\n     * @dev Buys an amount of options from pool\\n     *\\n     * @param option The option contract to buy\\n     * @param optionAmount Amount of options to buy\\n     * @param maxTokenAmount Max amount of input tokens sold\\n     * @param deadline The deadline in unix-timestamp that limits the transaction from happening\\n     * @param initialIVGuess The initial implied volatility guess\\n     */\\n    function buyExactOptions(\\n        IPodOption option,\\n        uint256 optionAmount,\\n        uint256 maxTokenAmount,\\n        uint256 deadline,\\n        uint256 initialIVGuess\\n    ) external withinDeadline(deadline) nonReentrant {\\n        IOptionAMMPool pool = _getPool(option);\\n        IERC20 tokenB = IERC20(pool.tokenB());\\n\\n        // Take input amount from caller\\n        tokenB.safeTransferFrom(msg.sender, address(this), maxTokenAmount);\\n\\n        // Approve pool transfer\\n        tokenB.safeApprove(address(pool), maxTokenAmount);\\n\\n        // Buys options from pool\\n        uint256 tokensSold = pool.tradeExactAOutput(optionAmount, maxTokenAmount, msg.sender, initialIVGuess);\\n        uint256 unusedFunds = maxTokenAmount.sub(tokensSold);\\n\\n        // Reset allowance\\n        tokenB.safeApprove(address(pool), 0);\\n\\n        // Transfer back unused funds\\n        if (unusedFunds > 0) {\\n            tokenB.safeTransfer(msg.sender, unusedFunds);\\n        }\\n\\n        emit OptionsBought(msg.sender, address(option), optionAmount, pool.tokenB(), tokensSold);\\n    }\\n\\n    /**\\n     * @notice Buy estimated amount of options\\n     * @dev Buys an estimated amount of options from pool\\n     *\\n     * @param option The option contract to buy\\n     * @param minOptionAmount Min amount of options bought\\n     * @param tokenAmount The exact amount of input tokens sold\\n     * @param deadline The deadline in unix-timestamp that limits the transaction from happening\\n     * @param initialIVGuess The initial implied volatility guess\\n     */\\n    function buyOptionsWithExactTokens(\\n        IPodOption option,\\n        uint256 minOptionAmount,\\n        uint256 tokenAmount,\\n        uint256 deadline,\\n        uint256 initialIVGuess\\n    ) external withinDeadline(deadline) nonReentrant {\\n        IOptionAMMPool pool = _getPool(option);\\n        IERC20 tokenB = IERC20(pool.tokenB());\\n\\n        // Take input amount from caller\\n        tokenB.safeTransferFrom(msg.sender, address(this), tokenAmount);\\n\\n        // Approve pool transfer\\n        tokenB.safeApprove(address(pool), tokenAmount);\\n\\n        // Buys options from pool\\n        uint256 optionsBought = pool.tradeExactBInput(tokenAmount, minOptionAmount, msg.sender, initialIVGuess);\\n\\n        emit OptionsBought(msg.sender, address(option), optionsBought, pool.tokenB(), tokenAmount);\\n    }\\n\\n    /**\\n     * @dev Mints an amount of tokens collecting the strike tokens from the caller\\n     *\\n     * @param option The option contract to mint\\n     * @param amount The amount of options to mint\\n     */\\n    function _mint(IPodOption option, uint256 amount) internal {\\n        require(Address.isContract(address(option)), \\\"OptionHelper: Option is not a contract\\\");\\n\\n        if (option.optionType() == IPodOption.OptionType.PUT) {\\n            IERC20 strikeAsset = IERC20(option.strikeAsset());\\n            uint256 strikeToTransfer = option.strikeToTransfer(amount);\\n\\n            // Take strike asset from caller\\n            strikeAsset.safeTransferFrom(msg.sender, address(this), strikeToTransfer);\\n\\n            // Approving strike asset transfer to Option\\n            strikeAsset.safeApprove(address(option), strikeToTransfer);\\n\\n            option.mint(amount, msg.sender);\\n        } else if (option.optionType() == IPodOption.OptionType.CALL) {\\n            IERC20 underlyingAsset = IERC20(option.underlyingAsset());\\n\\n            // Take underlying asset from caller\\n            underlyingAsset.safeTransferFrom(msg.sender, address(this), amount);\\n\\n            // Approving underlying asset to Option\\n            underlyingAsset.safeApprove(address(option), amount);\\n\\n            option.mint(amount, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the AMM Pool associated with the option\\n     *\\n     * @param option The option to search for\\n     * @return IOptionAMMPool\\n     */\\n    function _getPool(IPodOption option) internal view returns (IOptionAMMPool) {\\n        IOptionPoolRegistry registry = IOptionPoolRegistry(configurationManager.getOptionPoolRegistry());\\n        address exchangeOptionAddress = registry.getPool(address(option));\\n        require(exchangeOptionAddress != address(0), \\\"OptionHelper: pool not found\\\");\\n        return IOptionAMMPool(exchangeOptionAddress);\\n    }\\n\\n    /**\\n     * @dev Returns the AMM Pool associated with the option\\n     *\\n     * @param option The option to search for\\n     * @param collateralAmount Total collateral amount that will be used to mint and add liquidity\\n     * @return amountOfOptions amount of options to mint\\n     * @return amountOfTokenB  amount of stable to add liquidity\\n     */\\n    function _calculateEvenAmounts(IPodOption option, uint256 collateralAmount)\\n        internal\\n        view\\n        returns (uint256 amountOfOptions, uint256 amountOfTokenB)\\n    {\\n        // 1) Get BS Unit Price\\n        IOptionAMMPool pool = _getPool(option);\\n\\n        uint256 ABPrice = pool.getABPrice();\\n        uint256 strikePrice = option.strikePrice();\\n        uint256 optionDecimals = option.underlyingAssetDecimals();\\n\\n        amountOfOptions = collateralAmount.mul(10**optionDecimals).div(strikePrice.add(ABPrice));\\n        amountOfTokenB = amountOfOptions.mul(ABPrice).div(10**optionDecimals);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfigurationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity >=0.6.12;\\n\\ninterface IConfigurationManager {\\n    function setParameter(bytes32 name, uint256 value) external;\\n\\n    function setEmergencyStop(address emergencyStop) external;\\n\\n    function setPricingMethod(address pricingMethod) external;\\n\\n    function setIVGuesser(address ivGuesser) external;\\n\\n    function setIVProvider(address ivProvider) external;\\n\\n    function setPriceProvider(address priceProvider) external;\\n\\n    function setCapProvider(address capProvider) external;\\n\\n    function setAMMFactory(address ammFactory) external;\\n\\n    function setOptionFactory(address optionFactory) external;\\n\\n    function setOptionHelper(address optionHelper) external;\\n\\n    function setOptionPoolRegistry(address optionPoolRegistry) external;\\n\\n    function getParameter(bytes32 name) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function getEmergencyStop() external view returns (address);\\n\\n    function getPricingMethod() external view returns (address);\\n\\n    function getIVGuesser() external view returns (address);\\n\\n    function getIVProvider() external view returns (address);\\n\\n    function getPriceProvider() external view returns (address);\\n\\n    function getCapProvider() external view returns (address);\\n\\n    function getAMMFactory() external view returns (address);\\n\\n    function getOptionFactory() external view returns (address);\\n\\n    function getOptionHelper() external view returns (address);\\n\\n    function getOptionPoolRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPodOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPodOption is IERC20 {\\n    /** Enums */\\n    // @dev 0 for Put, 1 for Call\\n    enum OptionType { PUT, CALL }\\n    // @dev 0 for European, 1 for American\\n    enum ExerciseType { EUROPEAN, AMERICAN }\\n\\n    /** Events */\\n    event Mint(address indexed minter, uint256 amount);\\n    event Unmint(address indexed minter, uint256 optionAmount, uint256 strikeAmount, uint256 underlyingAmount);\\n    event Exercise(address indexed exerciser, uint256 amount);\\n    event Withdraw(address indexed minter, uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    /** Functions */\\n\\n    /**\\n     * @notice Locks collateral and write option tokens.\\n     *\\n     * @dev The issued amount ratio is 1:1, i.e., 1 option token for 1 underlying token.\\n     *\\n     * The collateral could be the strike or the underlying asset depending on the option type: Put or Call,\\n     * respectively\\n     *\\n     * It presumes the caller has already called IERC20.approve() on the\\n     * strike/underlying token contract to move caller funds.\\n     *\\n     * Options can only be minted while the series is NOT expired.\\n     *\\n     * It is also important to notice that options will be sent back\\n     * to `msg.sender` and not the `owner`. This behavior is designed to allow\\n     * proxy contracts to mint on others behalf. The `owner` will be able to remove\\n     * the deposited collateral after series expiration or by calling unmint(), even\\n     * if a third-party minted options on its behalf.\\n     *\\n     * @param amountOfOptions The amount option tokens to be issued\\n     * @param owner Which address will be the owner of the options\\n     */\\n    function mint(uint256 amountOfOptions, address owner) external;\\n\\n    /**\\n     * @notice Allow option token holders to use them to exercise the amount of units\\n     * of the locked tokens for the equivalent amount of the exercisable assets.\\n     *\\n     * @dev It presumes the caller has already called IERC20.approve() exercisable asset\\n     * to move caller funds.\\n     *\\n     * On American options, this function can only called anytime before expiration.\\n     * For European options, this function can only be called during the exerciseWindow.\\n     * Meaning, after expiration and before the end of exercise window.\\n     *\\n     * @param amountOfOptions The amount option tokens to be exercised\\n     */\\n    function exercise(uint256 amountOfOptions) external;\\n\\n    /**\\n     * @notice After series expiration in case of American or after exercise window for European,\\n     * allow minters who have locked their collateral to withdraw them proportionally\\n     * to their minted options.\\n     *\\n     * @dev If assets had been exercised during the option series the minter may withdraw\\n     * the exercised assets or a combination of exercised and collateral.\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Unlocks collateral by burning option tokens.\\n     *\\n     * Options can only be burned while the series is NOT expired.\\n     *\\n     * @param amountOfOptions The amount option tokens to be burned\\n     */\\n    function unmint(uint256 amountOfOptions) external;\\n\\n    function optionType() external view returns (OptionType);\\n\\n    function exerciseType() external view returns (ExerciseType);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function underlyingAssetDecimals() external view returns (uint8);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function strikeAssetDecimals() external view returns (uint8);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function strikePriceDecimals() external view returns (uint8);\\n\\n    function expiration() external view returns (uint256);\\n\\n    function startOfExerciseWindow() external view returns (uint256);\\n\\n    function hasExpired() external view returns (bool);\\n\\n    function isTradeWindow() external view returns (bool);\\n\\n    function isExerciseWindow() external view returns (bool);\\n\\n    function isWithdrawWindow() external view returns (bool);\\n\\n    function strikeToTransfer(uint256 amountOfOptions) external view returns (uint256);\\n\\n    function getSellerWithdrawAmounts(address owner)\\n        external\\n        view\\n        returns (uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    function underlyingReserves() external view returns (uint256);\\n\\n    function strikeReserves() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionAMMPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IAMM.sol\\\";\\n\\ninterface IOptionAMMPool is IAMM {\\n    // @dev 0 for when tokenA enter the pool and B leaving (A -> B)\\n    // and 1 for the opposite direction\\n    enum TradeDirection { AB, BA }\\n\\n    function tradeExactAInput(\\n        uint256 exactAmountAIn,\\n        uint256 minAmountBOut,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function tradeExactAOutput(\\n        uint256 exactAmountAOut,\\n        uint256 maxAmountBIn,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function tradeExactBInput(\\n        uint256 exactAmountBIn,\\n        uint256 minAmountAOut,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function tradeExactBOutput(\\n        uint256 exactAmountBOut,\\n        uint256 maxAmountAIn,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function getOptionTradeDetailsExactAInput(uint256 exactAmountAIn)\\n        external\\n        view\\n        returns (\\n            uint256 amountBOutput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getOptionTradeDetailsExactAOutput(uint256 exactAmountAOut)\\n        external\\n        view\\n        returns (\\n            uint256 amountBInput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getOptionTradeDetailsExactBInput(uint256 exactAmountBIn)\\n        external\\n        view\\n        returns (\\n            uint256 amountAOutput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getOptionTradeDetailsExactBOutput(uint256 exactAmountBOut)\\n        external\\n        view\\n        returns (\\n            uint256 amountAInput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getRemoveLiquidityAmounts(\\n        uint256 percentA,\\n        uint256 percentB,\\n        address user\\n    ) external view returns (uint256 withdrawAmountA, uint256 withdrawAmountB);\\n\\n    function getABPrice() external view returns (uint256);\\n\\n    function getAdjustedIV() external view returns (uint256);\\n\\n    function withdrawRewards() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionPoolRegistry.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\n\\ninterface IOptionPoolRegistry {\\n    event PoolSet(address indexed factory, address indexed option, address pool);\\n\\n    function getPool(address option) external view returns (address);\\n\\n    function setPool(address option, address pool) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IAMM {\\n    function addLiquidity(\\n        uint256 amountOfA,\\n        uint256 amountOfB,\\n        address owner\\n    ) external;\\n\\n    function removeLiquidity(uint256 amountOfA, uint256 amountOfB) external;\\n\\n    function tokenA() external view returns (address);\\n\\n    function tokenB() external view returns (address);\\n\\n    function tokenADecimals() external view returns (uint8);\\n\\n    function tokenBDecimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IConfigurationManager\",\"name\":\"_configurationManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"optionAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOptions\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"optionAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionsBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputSold\",\"type\":\"uint256\"}],\"name\":\"OptionsBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"optionAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionsMintedAndSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputBought\",\"type\":\"uint256\"}],\"name\":\"OptionsMintedAndSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"optionAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionsSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputReceived\",\"type\":\"uint256\"}],\"name\":\"OptionsSold\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"buyExactOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOptionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"buyOptionsWithExactTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationManager\",\"outputs\":[{\"internalType\":\"contract IConfigurationManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"mintAndAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"mintAndAddLiquidityWithCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"mintAndSellOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"sellExactOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxOptionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exactTokenReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"sellOptionsAndReceiveExactTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OptionHelper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e4da64757b2b29db43429a52caf7ad884c76f8b0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}