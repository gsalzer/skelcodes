{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: agpl-3.0\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary DataTypes {\r\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        uint40 lastUpdateTimestamp;\r\n        //tokens addresses\r\n        address aTokenAddress;\r\n        address stableDebtTokenAddress;\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint8 id;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        //bit 0-15: LTV\r\n        //bit 16-31: Liq. threshold\r\n        //bit 32-47: Liq. bonus\r\n        //bit 48-55: Decimals\r\n        //bit 56: Reserve is active\r\n        //bit 57: reserve is frozen\r\n        //bit 58: borrowing is enabled\r\n        //bit 59: stable rate borrowing enabled\r\n        //bit 60-63: reserved\r\n        //bit 64-79: reserve factor\r\n        uint256 data;\r\n    }\r\n\r\n    struct UserConfigurationMap {\r\n        uint256 data;\r\n    }\r\n\r\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n\r\n// Part: IAaveIncentivesController\r\n\r\ninterface IAaveIncentivesController {\r\n    /**\r\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n     * @param user The address of the user\r\n     * @return The rewards\r\n     **/\r\n    function getRewardsBalance(address[] calldata assets, address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n     * @param amount Amount of rewards to claim\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewards(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n     * @param amount Amount of rewards to claim\r\n     * @param user Address to check and claim rewards\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewardsOnBehalf(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address user,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev returns the unclaimed rewards of the user\r\n     * @param user the address of the user\r\n     * @return the unclaimed user rewards\r\n     */\r\n    function getUserUnclaimedRewards(address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev for backward compatibility with previous implementation of the Incentives controller\r\n     */\r\n    function REWARD_TOKEN() external view returns (address);\r\n\r\n    function getDistributionEnd() external view returns (uint256);\r\n\r\n    function getAssetData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n\r\n// Part: IBaseFee\r\n\r\ninterface IBaseFee {\r\n    function basefee_global() external view returns (uint256);\r\n}\r\n\r\n// Part: ILendingPoolAddressesProvider\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n    event MarketIdSet(string newMarketId);\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event ConfigurationAdminUpdated(address indexed newAddress);\r\n    event EmergencyAdminUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n    function getMarketId() external view returns (string memory);\r\n\r\n    function setMarketId(string calldata marketId) external;\r\n\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    function getLendingPool() external view returns (address);\r\n\r\n    function setLendingPoolImpl(address pool) external;\r\n\r\n    function getLendingPoolConfigurator() external view returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n    function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n    function setLendingPoolCollateralManager(address manager) external;\r\n\r\n    function getPoolAdmin() external view returns (address);\r\n\r\n    function setPoolAdmin(address admin) external;\r\n\r\n    function getEmergencyAdmin() external view returns (address);\r\n\r\n    function setEmergencyAdmin(address admin) external;\r\n\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    function setPriceOracle(address priceOracle) external;\r\n\r\n    function getLendingRateOracle() external view returns (address);\r\n\r\n    function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n\r\n// Part: IOptionalERC20\r\n\r\ninterface IOptionalERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// Part: IPriceOracle\r\n\r\ninterface IPriceOracle {\r\n    function getAssetPrice(address _asset) external view returns (uint256);\r\n\r\n    function getAssetsPrices(address[] calldata _assets)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getSourceOfAsset(address _asset) external view returns (address);\r\n\r\n    function getFallbackOracle() external view returns (address);\r\n}\r\n\r\n// Part: IReserveInterestRateStrategy\r\n\r\n/**\r\n * @title IReserveInterestRateStrategyInterface interface\r\n * @dev Interface for the calculation of the interest rates\r\n * @author Aave\r\n */\r\ninterface IReserveInterestRateStrategy {\r\n    function OPTIMAL_UTILIZATION_RATE() external view returns (uint256);\r\n\r\n    function EXCESS_UTILIZATION_RATE() external view returns (uint256);\r\n\r\n    function variableRateSlope1() external view returns (uint256);\r\n\r\n    function variableRateSlope2() external view returns (uint256);\r\n\r\n    function baseVariableBorrowRate() external view returns (uint256);\r\n\r\n    function getMaxVariableBorrowRate() external view returns (uint256);\r\n\r\n    function calculateInterestRates(\r\n        address reserve,\r\n        uint256 utilizationRate,\r\n        uint256 totalStableDebt,\r\n        uint256 totalVariableDebt,\r\n        uint256 averageStableBorrowRate,\r\n        uint256 reserveFactor\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 liquidityRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 variableBorrowRate\r\n        );\r\n}\r\n\r\n// Part: IScaledBalanceToken\r\n\r\ninterface IScaledBalanceToken {\r\n    /**\r\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n     * @param user The user whose balance is calculated\r\n     * @return The scaled balance of the user\r\n     **/\r\n    function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the scaled balance of the user and the scaled total supply.\r\n     * @param user The address of the user\r\n     * @return The scaled balance of the user\r\n     * @return The scaled balance and the scaled total supply\r\n     **/\r\n    function getScaledUserBalanceAndSupply(address user)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    /**\r\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n     * @return The scaled total supply\r\n     **/\r\n    function scaledTotalSupply() external view returns (uint256);\r\n}\r\n\r\n// Part: IStakedAave\r\n\r\ninterface IStakedAave {\r\n    function stake(address to, uint256 amount) external;\r\n\r\n    function redeem(address to, uint256 amount) external;\r\n\r\n    function cooldown() external;\r\n\r\n    function claimRewards(address to, uint256 amount) external;\r\n\r\n    function getTotalRewardsBalance(address) external view returns (uint256);\r\n\r\n    function COOLDOWN_SECONDS() external view returns (uint256);\r\n\r\n    function stakersCooldowns(address) external view returns (uint256);\r\n\r\n    function UNSTAKE_WINDOW() external view returns (uint256);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/IERC20\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeMath\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Part: WadRayMath\r\n\r\n/**\r\n * @title WadRayMath library\r\n * @author Aave\r\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n **/\r\n\r\nlibrary WadRayMath {\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant halfWAD = WAD / 2;\r\n\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant halfRAY = RAY / 2;\r\n\r\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n    /**\r\n     * @return One ray, 1e27\r\n     **/\r\n    function ray() internal pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    /**\r\n     * @return One wad, 1e18\r\n     **/\r\n\r\n    function wad() internal pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    /**\r\n     * @return Half ray, 1e27/2\r\n     **/\r\n    function halfRay() internal pure returns (uint256) {\r\n        return halfRAY;\r\n    }\r\n\r\n    /**\r\n     * @return Half ray, 1e18/2\r\n     **/\r\n    function halfWad() internal pure returns (uint256) {\r\n        return halfWAD;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two wad, rounding half up to the nearest wad\r\n     * @param a Wad\r\n     * @param b Wad\r\n     * @return The result of a*b, in wad\r\n     **/\r\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(a <= (type(uint256).max - halfWAD) / b);\r\n\r\n        return (a * b + halfWAD) / WAD;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two wad, rounding half up to the nearest wad\r\n     * @param a Wad\r\n     * @param b Wad\r\n     * @return The result of a/b, in wad\r\n     **/\r\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        uint256 halfB = b / 2;\r\n\r\n        require(a <= (type(uint256).max - halfB) / WAD);\r\n\r\n        return (a * WAD + halfB) / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two ray, rounding half up to the nearest ray\r\n     * @param a Ray\r\n     * @param b Ray\r\n     * @return The result of a*b, in ray\r\n     **/\r\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(a <= (type(uint256).max - halfRAY) / b);\r\n\r\n        return (a * b + halfRAY) / RAY;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two ray, rounding half up to the nearest ray\r\n     * @param a Ray\r\n     * @param b Ray\r\n     * @return The result of a/b, in ray\r\n     **/\r\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        uint256 halfB = b / 2;\r\n\r\n        require(a <= (type(uint256).max - halfB) / RAY);\r\n\r\n        return (a * RAY + halfB) / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Casts ray down to wad\r\n     * @param a Ray\r\n     * @return a casted to wad, rounded half up to the nearest wad\r\n     **/\r\n    function rayToWad(uint256 a) internal pure returns (uint256) {\r\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n        uint256 result = halfRatio + a;\r\n        require(result >= halfRatio);\r\n\r\n        return result / WAD_RAY_RATIO;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts wad up to ray\r\n     * @param a Wad\r\n     * @return a converted in ray\r\n     **/\r\n    function wadToRay(uint256 a) internal pure returns (uint256) {\r\n        uint256 result = a * WAD_RAY_RATIO;\r\n        require(result / WAD_RAY_RATIO == a);\r\n        return result;\r\n    }\r\n}\r\n\r\n// Part: ILendingPool\r\n\r\ninterface ILendingPool {\r\n    /**\r\n     * @dev Emitted on deposit()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the deposit\r\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n     * @param amount The amount deposited\r\n     * @param referral The referral code used\r\n     **/\r\n    event Deposit(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on withdraw()\r\n     * @param reserve The address of the underlyng asset being withdrawn\r\n     * @param user The address initiating the withdrawal, owner of aTokens\r\n     * @param to Address that will receive the underlying\r\n     * @param amount The amount to be withdrawn\r\n     **/\r\n    event Withdraw(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n     * @param reserve The address of the underlying asset being borrowed\r\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n     * initiator of the transaction on flashLoan()\r\n     * @param onBehalfOf The address that will be getting the debt\r\n     * @param amount The amount borrowed out\r\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n     * @param borrowRate The numeric rate at which the user has borrowed\r\n     * @param referral The referral code used\r\n     **/\r\n    event Borrow(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint256 borrowRateMode,\r\n        uint256 borrowRate,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on repay()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The beneficiary of the repayment, getting his debt reduced\r\n     * @param repayer The address of the user initiating the repay(), providing the funds\r\n     * @param amount The amount repaid\r\n     **/\r\n    event Repay(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed repayer,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on swapBorrowRateMode()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user swapping his rate mode\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralEnabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralDisabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on rebalanceStableBorrowRate()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user for which the rebalance has been executed\r\n     **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on flashLoan()\r\n     * @param target The address of the flash loan receiver contract\r\n     * @param initiator The address initiating the flash loan\r\n     * @param asset The address of the asset being flash borrowed\r\n     * @param amount The amount flash borrowed\r\n     * @param premium The fee flash borrowed\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event FlashLoan(\r\n        address indexed target,\r\n        address indexed initiator,\r\n        address indexed asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        uint16 referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered.\r\n     */\r\n    event Paused();\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted.\r\n     */\r\n    event Unpaused();\r\n\r\n    /**\r\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n     * LendingPoolCollateral manager using a DELEGATECALL\r\n     * This allows to have the events in the generated ABI for LendingPool.\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n     * @param liquidator The address of the liquidator\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    event LiquidationCall(\r\n        address indexed collateralAsset,\r\n        address indexed debtAsset,\r\n        address indexed user,\r\n        uint256 debtToCover,\r\n        uint256 liquidatedCollateralAmount,\r\n        address liquidator,\r\n        bool receiveAToken\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n     * gets added to the LendingPool ABI\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param liquidityRate The new liquidity rate\r\n     * @param stableBorrowRate The new stable borrow rate\r\n     * @param variableBorrowRate The new variable borrow rate\r\n     * @param liquidityIndex The new liquidity index\r\n     * @param variableBorrowIndex The new variable borrow index\r\n     **/\r\n    event ReserveDataUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @return The final amount repaid\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 rateMode,\r\n        address onBehalfOf\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n    /**\r\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n     *        borrowed at a stable rate and depositors are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n     * @param asset The address of the underlying asset deposited\r\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n     * For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts amounts being flash-borrowed\r\n     * @param modes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata modes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralETH the total collateral in ETH of the user\r\n     * @return totalDebtETH the total debt in ETH of the user\r\n     * @return availableBorrowsETH the borrowing power left of the user\r\n     * @return currentLiquidationThreshold the liquidation threshold of the user\r\n     * @return ltv the loan to value of the user\r\n     * @return healthFactor the current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function initReserve(\r\n        address reserve,\r\n        address aTokenAddress,\r\n        address stableDebtAddress,\r\n        address variableDebtAddress,\r\n        address interestRateStrategyAddress\r\n    ) external;\r\n\r\n    function setReserveInterestRateStrategyAddress(\r\n        address reserve,\r\n        address rateStrategyAddress\r\n    ) external;\r\n\r\n    function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n    /**\r\n     * @dev Returns the configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The configuration of the reserve\r\n     **/\r\n    function getConfiguration(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the configuration of the user across all the reserves\r\n     * @param user The user address\r\n     * @return The configuration of the user\r\n     **/\r\n    function getUserConfiguration(address user)\r\n        external\r\n        view\r\n        returns (DataTypes.UserConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the normalized income normalized income of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve's normalized income\r\n     */\r\n    function getReserveNormalizedIncome(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the normalized variable debt per unit of asset\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve normalized variable debt\r\n     */\r\n    function getReserveNormalizedVariableDebt(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the state and configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The state of the reserve\r\n     **/\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveData memory);\r\n\r\n    function finalizeTransfer(\r\n        address asset,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 balanceFromAfter,\r\n        uint256 balanceToBefore\r\n    ) external;\r\n\r\n    function getReservesList() external view returns (address[] memory);\r\n\r\n    function getAddressesProvider()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function setPause(bool val) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n\r\n// Part: IProtocolDataProvider\r\n\r\ninterface IProtocolDataProvider {\r\n    struct TokenData {\r\n        string symbol;\r\n        address tokenAddress;\r\n    }\r\n\r\n    function ADDRESSES_PROVIDER()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function getAllReservesTokens() external view returns (TokenData[] memory);\r\n\r\n    function getAllATokens() external view returns (TokenData[] memory);\r\n\r\n    function getReserveConfigurationData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 decimals,\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            uint256 reserveFactor,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive,\r\n            bool isFrozen\r\n        );\r\n\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 availableLiquidity,\r\n            uint256 totalStableDebt,\r\n            uint256 totalVariableDebt,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 averageStableBorrowRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            uint40 lastUpdateTimestamp\r\n        );\r\n\r\n    function getUserReserveData(address asset, address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentStableDebt,\r\n            uint256 currentVariableDebt,\r\n            uint256 principalStableDebt,\r\n            uint256 scaledVariableDebt,\r\n            uint256 stableBorrowRate,\r\n            uint256 liquidityRate,\r\n            uint40 stableRateLastUpdated,\r\n            bool usageAsCollateralEnabled\r\n        );\r\n\r\n    function getReserveTokensAddresses(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            address aTokenAddress,\r\n            address stableDebtTokenAddress,\r\n            address variableDebtTokenAddress\r\n        );\r\n}\r\n\r\n// Part: IVariableDebtToken\r\n\r\n/**\r\n * @title IVariableDebtToken\r\n * @author Aave\r\n * @notice Defines the basic interface for a variable debt token.\r\n **/\r\ninterface IVariableDebtToken is IERC20, IScaledBalanceToken {\r\n    /**\r\n     * @dev Emitted after the mint action\r\n     * @param from The address performing the mint\r\n     * @param onBehalfOf The address of the user on which behalf minting has been performed\r\n     * @param value The amount to be minted\r\n     * @param index The last index of the reserve\r\n     **/\r\n    event Mint(\r\n        address indexed from,\r\n        address indexed onBehalfOf,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Mints debt token to the `onBehalfOf` address\r\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n     * of credit delegate, or same as `onBehalfOf` otherwise\r\n     * @param onBehalfOf The address receiving the debt tokens\r\n     * @param amount The amount of debt being minted\r\n     * @param index The variable debt index of the reserve\r\n     * @return `true` if the the previous balance of the user is 0\r\n     **/\r\n    function mint(\r\n        address user,\r\n        address onBehalfOf,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when variable debt is burnt\r\n     * @param user The user which debt has been burned\r\n     * @param amount The amount of debt being burned\r\n     * @param index The index of the user\r\n     **/\r\n    event Burn(address indexed user, uint256 amount, uint256 index);\r\n\r\n    /**\r\n     * @dev Burns user variable debt\r\n     * @param user The user which debt is burnt\r\n     * @param index The variable debt index of the reserve\r\n     **/\r\n    function burn(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the address of the incentives controller contract\r\n     **/\r\n    function getIncentivesController()\r\n        external\r\n        view\r\n        returns (IAaveIncentivesController);\r\n}\r\n\r\n// Part: IInitializableAToken\r\n\r\n/**\r\n * @title IInitializableAToken\r\n * @notice Interface for the initialize function on AToken\r\n * @author Aave\r\n **/\r\ninterface IInitializableAToken {\r\n    /**\r\n     * @dev Emitted when an aToken is initialized\r\n     * @param underlyingAsset The address of the underlying asset\r\n     * @param pool The address of the associated lending pool\r\n     * @param treasury The address of the treasury\r\n     * @param incentivesController The address of the incentives controller for this aToken\r\n     * @param aTokenDecimals the decimals of the underlying\r\n     * @param aTokenName the name of the aToken\r\n     * @param aTokenSymbol the symbol of the aToken\r\n     * @param params A set of encoded parameters for additional initialization\r\n     **/\r\n    event Initialized(\r\n        address indexed underlyingAsset,\r\n        address indexed pool,\r\n        address treasury,\r\n        address incentivesController,\r\n        uint8 aTokenDecimals,\r\n        string aTokenName,\r\n        string aTokenSymbol,\r\n        bytes params\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the aToken\r\n     * @param pool The address of the lending pool where this aToken will be used\r\n     * @param treasury The address of the Aave treasury, receiving the fees on this aToken\r\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n     * @param incentivesController The smart contract managing potential incentives distribution\r\n     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n     * @param aTokenName The name of the aToken\r\n     * @param aTokenSymbol The symbol of the aToken\r\n     */\r\n    function initialize(\r\n        ILendingPool pool,\r\n        address treasury,\r\n        address underlyingAsset,\r\n        IAaveIncentivesController incentivesController,\r\n        uint8 aTokenDecimals,\r\n        string calldata aTokenName,\r\n        string calldata aTokenSymbol,\r\n        bytes calldata params\r\n    ) external;\r\n}\r\n\r\n// Part: IAToken\r\n\r\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\r\n    /**\r\n     * @dev Emitted after the mint action\r\n     * @param from The address performing the mint\r\n     * @param value The amount being\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event Mint(address indexed from, uint256 value, uint256 index);\r\n\r\n    /**\r\n     * @dev Mints `amount` aTokens to `user`\r\n     * @param user The address receiving the minted tokens\r\n     * @param amount The amount of tokens getting minted\r\n     * @param index The new liquidity index of the reserve\r\n     * @return `true` if the the previous balance of the user was 0\r\n     */\r\n    function mint(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted after aTokens are burned\r\n     * @param from The owner of the aTokens, getting them burned\r\n     * @param target The address that will receive the underlying\r\n     * @param value The amount being burned\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event Burn(\r\n        address indexed from,\r\n        address indexed target,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted during the transfer action\r\n     * @param from The user whose tokens are being transferred\r\n     * @param to The recipient\r\n     * @param value The amount being transferred\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    event BalanceTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        uint256 index\r\n    );\r\n\r\n    /**\r\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n     * @param user The owner of the aTokens, getting them burned\r\n     * @param receiverOfUnderlying The address that will receive the underlying\r\n     * @param amount The amount being burned\r\n     * @param index The new liquidity index of the reserve\r\n     **/\r\n    function burn(\r\n        address user,\r\n        address receiverOfUnderlying,\r\n        uint256 amount,\r\n        uint256 index\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Mints aTokens to the reserve treasury\r\n     * @param amount The amount of tokens getting minted\r\n     * @param index The new liquidity index of the reserve\r\n     */\r\n    function mintToTreasury(uint256 amount, uint256 index) external;\r\n\r\n    /**\r\n     * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n     * @param from The address getting liquidated, current owner of the aTokens\r\n     * @param to The recipient\r\n     * @param value The amount of tokens getting transferred\r\n     **/\r\n    function transferOnLiquidation(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n     * assets in borrow(), withdraw() and flashLoan()\r\n     * @param user The recipient of the underlying\r\n     * @param amount The amount getting transferred\r\n     * @return The amount transferred\r\n     **/\r\n    function transferUnderlyingTo(address user, uint256 amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Invoked to execute actions on the aToken side after a repayment.\r\n     * @param user The user executing the repayment\r\n     * @param amount The amount getting repaid\r\n     **/\r\n    function handleRepayment(address user, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the address of the incentives controller contract\r\n     **/\r\n    function getIncentivesController()\r\n        external\r\n        view\r\n        returns (IAaveIncentivesController);\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n     **/\r\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n}\r\n\r\n// File: AaveLenderBorrowerLib.sol\r\n\r\nlibrary AaveLenderBorrowerLib {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    struct CalcMaxDebtLocalVars {\r\n        uint256 availableLiquidity;\r\n        uint256 totalStableDebt;\r\n        uint256 totalVariableDebt;\r\n        uint256 totalDebt;\r\n        uint256 utilizationRate;\r\n        uint256 totalLiquidity;\r\n        uint256 targetUtilizationRate;\r\n        uint256 maxProtocolDebt;\r\n    }\r\n\r\n    struct IrsVars {\r\n        uint256 optimalRate;\r\n        uint256 baseRate;\r\n        uint256 slope1;\r\n        uint256 slope2;\r\n    }\r\n\r\n    uint256 internal constant MAX_BPS = 10_000;\r\n    IBaseFee internal constant baseFeeProvider =\r\n        IBaseFee(0xf8d0Ec04e94296773cE20eFbeeA82e76220cD549);\r\n    IProtocolDataProvider public constant protocolDataProvider =\r\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\r\n\r\n    function lendingPool() public view returns (ILendingPool) {\r\n        return\r\n            ILendingPool(\r\n                protocolDataProvider.ADDRESSES_PROVIDER().getLendingPool()\r\n            );\r\n    }\r\n\r\n    function priceOracle() public view returns (IPriceOracle) {\r\n        return\r\n            IPriceOracle(\r\n                protocolDataProvider.ADDRESSES_PROVIDER().getPriceOracle()\r\n            );\r\n    }\r\n\r\n    function incentivesController(\r\n        IAToken aToken,\r\n        IVariableDebtToken variableDebtToken,\r\n        bool isWantIncentivised,\r\n        bool isInvestmentTokenIncentivised\r\n    ) public view returns (IAaveIncentivesController) {\r\n        if (isWantIncentivised) {\r\n            return aToken.getIncentivesController();\r\n        } else if (isInvestmentTokenIncentivised) {\r\n            return variableDebtToken.getIncentivesController();\r\n        } else {\r\n            return IAaveIncentivesController(0);\r\n        }\r\n    }\r\n\r\n    function toETH(uint256 _amount, address asset)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _amount.mul(priceOracle().getAssetPrice(asset)).div(\r\n                uint256(10)**uint256(IOptionalERC20(asset).decimals())\r\n            );\r\n    }\r\n\r\n    function fromETH(uint256 _amount, address asset)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _amount\r\n                .mul(uint256(10)**uint256(IOptionalERC20(asset).decimals()))\r\n                .div(priceOracle().getAssetPrice(asset));\r\n    }\r\n\r\n    function calcMaxDebt(address _investmentToken, uint256 _acceptableCostsRay)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 currentProtocolDebt,\r\n            uint256 maxProtocolDebt,\r\n            uint256 targetU\r\n        )\r\n    {\r\n        // This function is used to calculate the maximum amount of debt that the protocol can take\r\n        // to keep the cost of capital lower than the set acceptableCosts\r\n        // This maxProtocolDebt will be used to decide if capital costs are acceptable or not\r\n        // and to repay required debt to keep the rates below acceptable costs\r\n\r\n        // Hack to avoid the stack too deep compiler error.\r\n        CalcMaxDebtLocalVars memory vars;\r\n        DataTypes.ReserveData memory reserveData =\r\n            lendingPool().getReserveData(address(_investmentToken));\r\n        IReserveInterestRateStrategy irs =\r\n            IReserveInterestRateStrategy(\r\n                reserveData.interestRateStrategyAddress\r\n            );\r\n\r\n        (\r\n            vars.availableLiquidity, // = total supply - total stable debt - total variable debt\r\n            vars.totalStableDebt, // total debt paying stable interest rates\r\n            vars.totalVariableDebt, // total debt paying stable variable rates\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = protocolDataProvider.getReserveData(address(_investmentToken));\r\n\r\n        vars.totalDebt = vars.totalStableDebt.add(vars.totalVariableDebt);\r\n        vars.totalLiquidity = vars.availableLiquidity.add(vars.totalDebt);\r\n        vars.utilizationRate = vars.totalDebt == 0\r\n            ? 0\r\n            : vars.totalDebt.rayDiv(vars.totalLiquidity);\r\n\r\n        // Aave's Interest Rate Strategy Parameters (see docs)\r\n        IrsVars memory irsVars;\r\n        irsVars.optimalRate = irs.OPTIMAL_UTILIZATION_RATE();\r\n        irsVars.baseRate = irs.baseVariableBorrowRate(); // minimum cost of capital with 0 % of utilisation rate\r\n        irsVars.slope1 = irs.variableRateSlope1(); // rate of increase of cost of debt up to Optimal Utilisation Rate\r\n        irsVars.slope2 = irs.variableRateSlope2(); // rate of increase of cost of debt above Optimal Utilisation Rate\r\n\r\n        // acceptableCosts should always be > baseVariableBorrowRate\r\n        // If it's not this will revert since the strategist set the wrong\r\n        // acceptableCosts value\r\n        if (\r\n            vars.utilizationRate < irsVars.optimalRate &&\r\n            _acceptableCostsRay < irsVars.baseRate.add(irsVars.slope1)\r\n        ) {\r\n            // we solve Aave's Interest Rates equation for sub optimal utilisation rates\r\n            // IR = BASERATE + SLOPE1 * CURRENT_UTIL_RATE / OPTIMAL_UTIL_RATE\r\n            vars.targetUtilizationRate = (\r\n                _acceptableCostsRay.sub(irsVars.baseRate)\r\n            )\r\n                .rayMul(irsVars.optimalRate)\r\n                .rayDiv(irsVars.slope1);\r\n        } else {\r\n            // Special case where protocol is above utilization rate but we want\r\n            // a lower interest rate than (base + slope1)\r\n            if (_acceptableCostsRay < irsVars.baseRate.add(irsVars.slope1)) {\r\n                return (toETH(vars.totalDebt, address(_investmentToken)), 0, 0);\r\n            }\r\n\r\n            // we solve Aave's Interest Rates equation for utilisation rates above optimal U\r\n            // IR = BASERATE + SLOPE1 + SLOPE2 * (CURRENT_UTIL_RATE - OPTIMAL_UTIL_RATE) / (1-OPTIMAL_UTIL_RATE)\r\n            vars.targetUtilizationRate = (\r\n                _acceptableCostsRay.sub(irsVars.baseRate.add(irsVars.slope1))\r\n            )\r\n                .rayMul(uint256(1e27).sub(irsVars.optimalRate))\r\n                .rayDiv(irsVars.slope2)\r\n                .add(irsVars.optimalRate);\r\n        }\r\n\r\n        vars.maxProtocolDebt = vars\r\n            .totalLiquidity\r\n            .rayMul(vars.targetUtilizationRate)\r\n            .rayDiv(1e27);\r\n\r\n        return (\r\n            toETH(vars.totalDebt, address(_investmentToken)),\r\n            toETH(vars.maxProtocolDebt, address(_investmentToken)),\r\n            vars.targetUtilizationRate\r\n        );\r\n    }\r\n\r\n    function calculateAmountToRepay(\r\n        uint256 amountETH,\r\n        uint256 totalCollateralETH,\r\n        uint256 totalDebtETH,\r\n        uint256 warningLTV,\r\n        uint256 targetLTV,\r\n        address investmentToken,\r\n        uint256 minThreshold\r\n    ) public view returns (uint256) {\r\n        if (amountETH == 0) {\r\n            return 0;\r\n        }\r\n        // we check if the collateral that we are withdrawing leaves us in a risky range, we then take action\r\n        uint256 amountToWithdrawETH = amountETH;\r\n        // calculate the collateral that we are leaving after withdrawing\r\n        uint256 newCollateral =\r\n            totalCollateralETH > amountToWithdrawETH\r\n                ? totalCollateralETH.sub(amountToWithdrawETH)\r\n                : 0;\r\n        uint256 ltvAfterWithdrawal =\r\n            newCollateral > 0\r\n                ? totalDebtETH.mul(MAX_BPS).div(newCollateral)\r\n                : type(uint256).max;\r\n        // check if the new LTV is in UNHEALTHY range\r\n        // remember that if balance > _amountNeeded, ltvAfterWithdrawal == 0 (0 risk)\r\n        // this is not true but the effect will be the same\r\n        if (ltvAfterWithdrawal <= warningLTV) {\r\n            // no need of repaying debt because the LTV is ok\r\n            return 0;\r\n        } else if (ltvAfterWithdrawal == type(uint256).max) {\r\n            // we are withdrawing 100% of collateral so we need to repay full debt\r\n            return fromETH(totalDebtETH, address(investmentToken));\r\n        }\r\n        // WARNING: this only works for a single collateral asset, otherwise liquidationThreshold might change depending on the collateral being withdrawn\r\n        // e.g. we have USDC + WBTC as collateral, end liquidationThreshold will be different depending on which asset we withdraw\r\n        uint256 newTargetDebt = targetLTV.mul(newCollateral).div(MAX_BPS);\r\n        // if newTargetDebt is higher, we don't need to repay anything\r\n        if (newTargetDebt > totalDebtETH) {\r\n            return 0;\r\n        }\r\n        return\r\n            fromETH(\r\n                totalDebtETH.sub(newTargetDebt) < minThreshold\r\n                    ? totalDebtETH\r\n                    : totalDebtETH.sub(newTargetDebt),\r\n                address(investmentToken)\r\n            );\r\n    }\r\n\r\n    function checkCooldown(\r\n        bool isWantIncentivised,\r\n        bool isInvestmentTokenIncentivised,\r\n        address stkAave\r\n    ) external view returns (bool) {\r\n        if (!isWantIncentivised && !isInvestmentTokenIncentivised) {\r\n            return false;\r\n        }\r\n\r\n        uint256 cooldownStartTimestamp =\r\n            IStakedAave(stkAave).stakersCooldowns(address(this));\r\n        uint256 COOLDOWN_SECONDS = IStakedAave(stkAave).COOLDOWN_SECONDS();\r\n        uint256 UNSTAKE_WINDOW = IStakedAave(stkAave).UNSTAKE_WINDOW();\r\n        return\r\n            cooldownStartTimestamp != 0 &&\r\n            block.timestamp > cooldownStartTimestamp.add(COOLDOWN_SECONDS) &&\r\n            block.timestamp <=\r\n            cooldownStartTimestamp.add(COOLDOWN_SECONDS).add(UNSTAKE_WINDOW);\r\n    }\r\n\r\n    function shouldRebalance(\r\n        address investmentToken,\r\n        uint256 acceptableCostsRay,\r\n        uint256 targetLTV,\r\n        uint256 warningLTV,\r\n        uint256 totalCollateralETH,\r\n        uint256 totalDebtETH,\r\n        uint256 maxGasPriceToTend\r\n    ) external view returns (bool) {\r\n        uint256 currentLTV = totalDebtETH.mul(MAX_BPS).div(totalCollateralETH);\r\n\r\n        (uint256 currentProtocolDebt, uint256 maxProtocolDebt, ) =\r\n            calcMaxDebt(investmentToken, acceptableCostsRay);\r\n\r\n        // If we are in danger zone then repay debt regardless of the current gas price\r\n        if (currentLTV > warningLTV) {\r\n            return true;\r\n        }\r\n\r\n        if (\r\n            (currentLTV < targetLTV &&\r\n                currentProtocolDebt < maxProtocolDebt &&\r\n                targetLTV.sub(currentLTV) > 1000) || // WE NEED TO TAKE ON MORE DEBT (we need a 10p.p (1000bps) difference)\r\n            (currentProtocolDebt > maxProtocolDebt) // UNHEALTHY BORROWING COSTS\r\n        ) {\r\n            return baseFeeProvider.basefee_global() <= maxGasPriceToTend;\r\n        }\r\n\r\n        // no call to super.tendTrigger as it would return false\r\n        return false;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investmentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_acceptableCostsRay\",\"type\":\"uint256\"}],\"name\":\"calcMaxDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentProtocolDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProtocolDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetU\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"warningLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetLTV\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"investmentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minThreshold\",\"type\":\"uint256\"}],\"name\":\"calculateAmountToRepay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isWantIncentivised\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isInvestmentTokenIncentivised\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"stkAave\",\"type\":\"address\"}],\"name\":\"checkCooldown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"fromETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAToken\",\"name\":\"aToken\",\"type\":\"IAToken\"},{\"internalType\":\"contract IVariableDebtToken\",\"name\":\"variableDebtToken\",\"type\":\"IVariableDebtToken\"},{\"internalType\":\"bool\",\"name\":\"isWantIncentivised\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isInvestmentTokenIncentivised\",\"type\":\"bool\"}],\"name\":\"incentivesController\",\"outputs\":[{\"internalType\":\"contract IAaveIncentivesController\",\"name\":\"\",\"type\":\"IAaveIncentivesController\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"ILendingPool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"IPriceOracle\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolDataProvider\",\"outputs\":[{\"internalType\":\"contract IProtocolDataProvider\",\"name\":\"\",\"type\":\"IProtocolDataProvider\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investmentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptableCostsRay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"warningLTV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPriceToTend\",\"type\":\"uint256\"}],\"name\":\"shouldRebalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"toETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AaveLenderBorrowerLib","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b2f0fd5c5268960fa4217b0cb415df84639cd3f29fa7ebe8148cba7c246094b1"}]}