{"status":"1","message":"OK","result":[{"SourceCode":"{\"Bits.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n* @dev Taken from https://github.com/ethereum/solidity-examples/blob/master/src/bits/Bits.sol\\n*/\\nlibrary Bits {\\n\\n    uint256 internal constant ONE = uint256(1);\\n\\n    /**\\n    * @notice Sets the bit at the given \\u0027index\\u0027 in \\u0027self\\u0027 to:\\n    *  \\u00271\\u0027 - if the bit is \\u00270\\u0027\\n    *  \\u00270\\u0027 - if the bit is \\u00271\\u0027\\n    * @return The modified value\\n    */\\n    function toggleBit(uint256 self, uint8 index) internal pure returns (uint256) {\\n        return self ^ ONE \\u003c\\u003c index;\\n    }\\n\\n    /**\\n    * @notice Get the value of the bit at the given \\u0027index\\u0027 in \\u0027self\\u0027.\\n    */\\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8(self \\u003e\\u003e index \\u0026 1);\\n    }\\n\\n    /**\\n    * @notice Check if the bit at the given \\u0027index\\u0027 in \\u0027self\\u0027 is set.\\n    * @return  \\u0027true\\u0027 - if the value of the bit is \\u00271\\u0027,\\n    *          \\u0027false\\u0027 - if the value of the bit is \\u00270\\u0027\\n    */\\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\\n        return self \\u003e\\u003e index \\u0026 1 == 1;\\n    }\\n\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn\\u0027t required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n\\n        // To change the approve amount you first have to reduce the addresses`\\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\\n        //  already 0 to mitigate the race condition described here:\\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n        require(value == 0 || _allowed[msg.sender][spender] == 0);\\n\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified addresses\\n     * @param from The address to transfer from.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that mints an amount of the token and assigns it to\\n     * an account. This encapsulates the modification of balances such that the\\n     * proper events are emitted.\\n     * @param account The account that will receive the created tokens.\\n     * @param value The amount that will be created.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Approve an address to spend another addresses\\u0027 tokens.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param value The number of tokens that can be spent.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender\\u0027s allowance for said account. Uses the\\n     * internal burn function.\\n     * Emits an Approval event (reflecting the reduced allowance).\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"IERC20.sol\\\";\\n\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\nabstract contract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @return the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @return the number of decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC900History.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\n// Minimum interface to interact with Aragon\\u0027s Aggregator\\ninterface IERC900History {\\n    function totalStakedForAt(address addr, uint256 blockNumber) external view returns (uint256);\\n    function totalStakedAt(uint256 blockNumber) external view returns (uint256);\\n    function supportsHistory() external pure returns (bool);\\n}\\n\"},\"IStakingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"NuCypherToken.sol\\\";\\n\\ninterface IStakingEscrow {\\n    function token() external view returns (NuCypherToken);\\n    function secondsPerPeriod() external view returns (uint32);\\n    function stakerFromWorker(address) external view returns (address);\\n    function getAllTokens(address) external view returns (uint256);\\n    function slashStaker(address, uint256, address, uint256) external;\\n    function genesisSecondsPerPeriod() external view returns (uint32);\\n    function getPastDowntimeLength(address) external view returns (uint256);\\n    function findIndexOfPastDowntime(address, uint16) external view returns (uint256);\\n    function getPastDowntime(address, uint256) external view returns (uint16, uint16);\\n    function getLastCommittedPeriod(address) external view returns (uint16);\\n    function minLockedPeriods() external view returns (uint16);\\n    function maxAllowableLockedTokens() external view returns (uint256);\\n    function minAllowableLockedTokens() external view returns (uint256);\\n    function getCompletedWork(address) external view returns (uint256);\\n    function depositFromWorkLock(address, uint256, uint16) external;\\n    function setWorkMeasurement(address, bool) external returns (uint256);\\n    function setSnapshots(bool _enableSnapshots) external;\\n}\\n\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Math\\n * @dev Assorted math operations\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Calculates the average of two numbers. Since these are integers,\\n     * averages of an even and odd number cannot be represented, and will be\\n     * rounded down.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"},\"NuCypherToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"ERC20.sol\\\";\\nimport \\\"ERC20Detailed.sol\\\";\\n\\n\\n/**\\n* @title NuCypherToken\\n* @notice ERC20 token\\n* @dev Optional approveAndCall() functionality to notify a contract if an approve() has occurred.\\n*/\\ncontract NuCypherToken is ERC20, ERC20Detailed(\\u0027NuCypher\\u0027, \\u0027NU\\u0027, 18) {\\n\\n    /**\\n    * @notice Set amount of tokens\\n    * @param _totalSupplyOfTokens Total number of tokens\\n    */\\n    constructor (uint256 _totalSupplyOfTokens) {\\n        _mint(msg.sender, _totalSupplyOfTokens);\\n    }\\n\\n    /**\\n    * @notice Approves and then calls the receiving contract\\n    *\\n    * @dev call the receiveApproval function on the contract you want to be notified.\\n    * receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\\n    */\\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\\n        external returns (bool success)\\n    {\\n        approve(_spender, _value);\\n        TokenRecipient(_spender).receiveApproval(msg.sender, _value, address(this), _extraData);\\n        return true;\\n    }\\n\\n}\\n\\n\\n/**\\n* @dev Interface to use the receiveApproval method\\n*/\\ninterface TokenRecipient {\\n\\n    /**\\n    * @notice Receives a notification of approval of the transfer\\n    * @param _from Sender of approval\\n    * @param _value  The amount of tokens to be spent\\n    * @param _tokenContract Address of the token contract\\n    * @param _extraData Extra data\\n    */\\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\n\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        require(token.transfer(to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        require(token.transferFrom(from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\\n        require(token.approve(spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        require(token.approve(spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        require(token.approve(spender, newAllowance));\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"},\"Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Snapshot\\n * @notice Manages snapshots of size 128 bits (32 bits for timestamp, 96 bits for value)\\n * 96 bits is enough for storing NU token values, and 32 bits should be OK for block numbers\\n * @dev Since each storage slot can hold two snapshots, new slots are allocated every other TX. Thus, gas cost of adding snapshots is 51400 and 36400 gas, alternately.\\n * Based on Aragon\\u0027s Checkpointing (https://https://github.com/aragonone/voting-connectors/blob/master/shared/contract-utils/contracts/Checkpointing.sol)\\n * On average, adding snapshots spends ~6500 less gas than the 256-bit checkpoints of Aragon\\u0027s Checkpointing\\n */\\nlibrary Snapshot {\\n\\n    function encodeSnapshot(uint32 _time, uint96 _value) internal pure returns(uint128) {\\n        return uint128(uint256(_time) \\u003c\\u003c 96 | uint256(_value));\\n    }\\n\\n    function decodeSnapshot(uint128 _snapshot) internal pure returns(uint32 time, uint96 value){\\n        time = uint32(bytes4(bytes16(_snapshot)));\\n        value = uint96(_snapshot);\\n    }\\n\\n    function addSnapshot(uint128[] storage _self, uint256 _value) internal {\\n        addSnapshot(_self, block.number, _value);\\n    }\\n\\n    function addSnapshot(uint128[] storage _self, uint256 _time, uint256 _value) internal {\\n        uint256 length = _self.length;\\n        if (length != 0) {\\n            (uint32 currentTime, ) = decodeSnapshot(_self[length - 1]);\\n            if (uint32(_time) == currentTime) {\\n                _self[length - 1] = encodeSnapshot(uint32(_time), uint96(_value));\\n                return;\\n            } else if (uint32(_time) \\u003c currentTime){\\n                revert();\\n            }\\n        }\\n        _self.push(encodeSnapshot(uint32(_time), uint96(_value)));\\n    }\\n\\n    function lastSnapshot(uint128[] storage _self) internal view returns (uint32, uint96) {\\n        uint256 length = _self.length;\\n        if (length \\u003e 0) {\\n            return decodeSnapshot(_self[length - 1]);\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    function lastValue(uint128[] storage _self) internal view returns (uint96) {\\n        (, uint96 value) = lastSnapshot(_self);\\n        return value;\\n    }\\n\\n    function getValueAt(uint128[] storage _self, uint256 _time256) internal view returns (uint96) {\\n        uint32 _time = uint32(_time256);\\n        uint256 length = _self.length;\\n\\n        // Short circuit if there\\u0027s no checkpoints yet\\n        // Note that this also lets us avoid using SafeMath later on, as we\\u0027ve established that\\n        // there must be at least one checkpoint\\n        if (length == 0) {\\n            return 0;\\n        }\\n\\n        // Check last checkpoint\\n        uint256 lastIndex = length - 1;\\n        (uint32 snapshotTime, uint96 snapshotValue) = decodeSnapshot(_self[length - 1]);\\n        if (_time \\u003e= snapshotTime) {\\n            return snapshotValue;\\n        }\\n\\n        // Check first checkpoint (if not already checked with the above check on last)\\n        (snapshotTime, snapshotValue) = decodeSnapshot(_self[0]);\\n        if (length == 1 || _time \\u003c snapshotTime) {\\n            return 0;\\n        }\\n\\n        // Do binary search\\n        // As we\\u0027ve already checked both ends, we don\\u0027t need to check the last checkpoint again\\n        uint256 low = 0;\\n        uint256 high = lastIndex - 1;\\n        uint32 midTime;\\n        uint96 midValue;\\n\\n        while (high \\u003e low) {\\n            uint256 mid = (high + low + 1) / 2; // average, ceil round\\n            (midTime, midValue) = decodeSnapshot(_self[mid]);\\n\\n            if (_time \\u003e midTime) {\\n                low = mid;\\n            } else if (_time \\u003c midTime) {\\n                // Note that we don\\u0027t need SafeMath here because mid must always be greater than 0\\n                // from the while condition\\n                high = mid - 1;\\n            } else {\\n                // _time == midTime\\n                return midValue;\\n            }\\n        }\\n\\n        (, snapshotValue) = decodeSnapshot(_self[low]);\\n        return snapshotValue;\\n    }\\n}\\n\"},\"StakingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"IERC900History.sol\\\";\\nimport \\\"NuCypherToken.sol\\\";\\nimport \\\"Bits.sol\\\";\\nimport \\\"Snapshot.sol\\\";\\nimport \\\"Upgradeable.sol\\\";\\nimport \\\"Math.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\n\\n\\n/**\\n* @notice WorkLock interface\\n*/\\ninterface WorkLockInterface {\\n    function token() external view returns (NuCypherToken);\\n}\\n\\n\\n/**\\n* @title StakingEscrowStub\\n* @notice Stub is used to deploy main StakingEscrow after all other contract and make some variables immutable\\n* @dev |v1.1.0|\\n*/\\ncontract StakingEscrowStub is Upgradeable {\\n    NuCypherToken public immutable token;\\n    // only to deploy WorkLock\\n    uint32 public immutable secondsPerPeriod = 1;\\n    uint16 public immutable minLockedPeriods = 0;\\n    uint256 public immutable minAllowableLockedTokens;\\n    uint256 public immutable maxAllowableLockedTokens;\\n\\n    /**\\n    * @notice Predefines some variables for use when deploying other contracts\\n    * @param _token Token contract\\n    * @param _minAllowableLockedTokens Min amount of tokens that can be locked\\n    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        uint256 _minAllowableLockedTokens,\\n        uint256 _maxAllowableLockedTokens\\n    ) {\\n        require(_token.totalSupply() \\u003e 0 \\u0026\\u0026\\n            _maxAllowableLockedTokens != 0);\\n\\n        token = _token;\\n        minAllowableLockedTokens = _minAllowableLockedTokens;\\n        maxAllowableLockedTokens = _maxAllowableLockedTokens;\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n\\n        // we have to use real values even though this is a stub\\n        require(address(delegateGet(_testTarget, this.token.selector)) == address(token));\\n    }\\n}\\n\\n\\n/**\\n* @title StakingEscrow\\n* @notice Contract holds and locks stakers tokens.\\n* Each staker that locks their tokens will receive some compensation\\n* @dev |v6.1.1|\\n*/\\ncontract StakingEscrow is Upgradeable, IERC900History {\\n\\n    using Bits for uint256;\\n    using SafeMath for uint256;\\n    using Snapshot for uint128[];\\n    using SafeERC20 for NuCypherToken;\\n\\n    /**\\n    * @notice Signals that tokens were deposited\\n    * @param staker Staker address\\n    * @param value Amount deposited (in NuNits)\\n    */\\n    event Deposited(address indexed staker, uint256 value);\\n\\n    /**\\n    * @notice Signals that NU tokens were withdrawn to the staker\\n    * @param staker Staker address\\n    * @param value Amount withdraws (in NuNits)\\n    */\\n    event Withdrawn(address indexed staker, uint256 value);\\n\\n    /**\\n    * @notice Signals that the staker was slashed\\n    * @param staker Staker address\\n    * @param penalty Slashing penalty\\n    * @param investigator Investigator address\\n    * @param reward Value of reward provided to investigator (in NuNits)\\n    */\\n    event Slashed(address indexed staker, uint256 penalty, address indexed investigator, uint256 reward);\\n\\n    struct SubStakeInfo {\\n        uint16 firstPeriod;\\n        uint16 lastPeriod;\\n        uint16 unlockingDuration;\\n        uint128 lockedValue;\\n    }\\n\\n    struct Downtime {\\n        uint16 startPeriod;\\n        uint16 endPeriod;\\n    }\\n\\n    struct StakerInfo {\\n        uint256 value;\\n        uint16 currentCommittedPeriod;\\n        uint16 nextCommittedPeriod;\\n        uint16 lastCommittedPeriod;\\n        uint16 stub1; // former slot for lockReStakeUntilPeriod\\n        uint256 completedWork;\\n        uint16 workerStartPeriod; // period when worker was bonded\\n        address worker;\\n        uint256 flags; // uint256 to acquire whole slot and minimize operations on it\\n\\n        uint256 reservedSlot1;\\n        uint256 reservedSlot2;\\n        uint256 reservedSlot3;\\n        uint256 reservedSlot4;\\n        uint256 reservedSlot5;\\n\\n        Downtime[] pastDowntime;\\n        SubStakeInfo[] subStakes;\\n        uint128[] history;\\n\\n    }\\n\\n    // indices for flags (0-4 were in use, skip it in future)\\n//    uint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\\n\\n    NuCypherToken public immutable token;\\n    WorkLockInterface public immutable workLock;\\n\\n    uint128 public previousPeriodSupply; // outdated\\n    uint128 public currentPeriodSupply; // outdated\\n    uint16 public currentMintingPeriod; // outdated\\n\\n    mapping (address =\\u003e StakerInfo) public stakerInfo;\\n    address[] public stakers;\\n    mapping (address =\\u003e address) public stakerFromWorker;  // outdated\\n\\n    mapping (uint16 =\\u003e uint256) stub1; // former slot for lockedPerPeriod\\n    uint128[] public balanceHistory;  // outdated\\n\\n    address stub2; // former slot for PolicyManager\\n    address stub3; // former slot for Adjudicator\\n    address stub4; // former slot for WorkLock\\n\\n    mapping (uint16 =\\u003e uint256) public lockedPerPeriod; // outdated\\n\\n    /**\\n    * @notice Constructor sets address of token contract and parameters for staking\\n    * @param _token NuCypher token contract\\n    * @param _workLock WorkLock contract. Zero address if there is no WorkLock\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        WorkLockInterface _workLock\\n    ) {\\n        require(_token.totalSupply() \\u003e 0 \\u0026\\u0026\\n            (address(_workLock) == address(0) || _workLock.token() == _token),\\n            \\\"Input addresses must be deployed contracts\\\"\\n        );\\n\\n        token = _token;\\n        workLock = _workLock;\\n    }\\n\\n    /**\\n    * @dev Checks the existence of a staker in the contract\\n    */\\n    modifier onlyStaker()\\n    {\\n        require(stakerInfo[msg.sender].value \\u003e 0, \\\"Caller must be a staker\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Checks caller is WorkLock contract\\n    */\\n    modifier onlyWorkLock()\\n    {\\n        require(msg.sender == address(workLock), \\\"Caller must be the WorkLock contract\\\");\\n        _;\\n    }\\n\\n    //------------------------Main getters------------------------\\n    /**\\n    * @notice Get all tokens belonging to the staker\\n    */\\n    function getAllTokens(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].value;\\n    }\\n\\n//    /**\\n//    * @notice Get all flags for the staker\\n//    */\\n//    function getFlags(address _staker)\\n//        external view returns (\\n//            bool snapshots\\n//        )\\n//    {\\n//        StakerInfo storage info = stakerInfo[_staker];\\n//        snapshots = !info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX);\\n//    }\\n\\n    /**\\n    * @notice Get work that completed by the staker\\n    */\\n    function getCompletedWork(address _staker) external view returns (uint256) {\\n        return token.totalSupply();\\n    }\\n\\n\\n    //------------------------Main methods------------------------\\n    /**\\n    * @notice Stub for WorkLock\\n    * @param _staker Staker\\n    * @param _measureWork Value for `measureWork` parameter\\n    * @return Work that was previously done\\n    */\\n    function setWorkMeasurement(address _staker, bool _measureWork)\\n        external onlyWorkLock returns (uint256)\\n    {\\n        return 0;\\n    }\\n\\n    /**\\n    * @notice Deposit tokens from WorkLock contract\\n    * @param _staker Staker address\\n    * @param _value Amount of tokens to deposit\\n    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\\n    */\\n    function depositFromWorkLock(\\n        address _staker,\\n        uint256 _value,\\n        uint16 _unlockingDuration\\n    )\\n        external onlyWorkLock\\n    {\\n        require(_value != 0, \\\"Amount of tokens to deposit must be specified\\\");\\n        StakerInfo storage info = stakerInfo[_staker];\\n        // initial stake of the staker\\n        if (info.value == 0 \\u0026\\u0026 info.lastCommittedPeriod == 0) {\\n            stakers.push(_staker);\\n        }\\n        token.safeTransferFrom(msg.sender, address(this), _value);\\n        info.value += _value;\\n\\n        emit Deposited(_staker, _value);\\n    }\\n\\n    //-------------------------Slashing-------------------------\\n    /**\\n    * @notice Slash the staker\\u0027s stake and reward the investigator\\n    * @param _staker Staker\\u0027s address\\n    * @param _penalty Penalty\\n    * @param _investigator Investigator\\n    * @param _reward Reward for the investigator\\n    */\\n    function slashStaker(\\n        address _staker,\\n        uint256 _penalty,\\n        address _investigator,\\n        uint256 _reward\\n    )\\n        internal\\n    {\\n        require(_penalty \\u003e 0, \\\"Penalty must be specified\\\");\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (info.value \\u003c= _penalty) {\\n            _penalty = info.value;\\n        }\\n        info.value -= _penalty;\\n        if (_reward \\u003e _penalty) {\\n            _reward = _penalty;\\n        }\\n\\n        emit Slashed(_staker, _penalty, _investigator, _reward);\\n        if (_reward \\u003e 0) {\\n            token.safeTransfer(_investigator, _reward);\\n        }\\n    }\\n\\n    //-------------Additional getters for stakers info-------------\\n    /**\\n    * @notice Return the length of the array of stakers\\n    */\\n    function getStakersLength() external view virtual returns (uint256) {\\n        return stakers.length;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of sub stakes\\n    */\\n    function getSubStakesLength(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].subStakes.length;\\n    }\\n\\n    /**\\n    * @notice Return the information about sub stake\\n    */\\n    function getSubStakeInfo(address _staker, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (SubStakeInfo)\\n        // TODO \\\"virtual\\\" only for tests, probably will be removed after #1512\\n        external view virtual returns (\\n            uint16 firstPeriod,\\n            uint16 lastPeriod,\\n            uint16 unlockingDuration,\\n            uint128 lockedValue\\n        )\\n    {\\n        SubStakeInfo storage info = stakerInfo[_staker].subStakes[_index];\\n        firstPeriod = info.firstPeriod;\\n        lastPeriod = info.lastPeriod;\\n        unlockingDuration = info.unlockingDuration;\\n        lockedValue = info.lockedValue;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of past downtime\\n    */\\n    function getPastDowntimeLength(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].pastDowntime.length;\\n    }\\n\\n    /**\\n    * @notice Return the information about past downtime\\n    */\\n    function  getPastDowntime(address _staker, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (Downtime)\\n        external view returns (uint16 startPeriod, uint16 endPeriod)\\n    {\\n        Downtime storage downtime = stakerInfo[_staker].pastDowntime[_index];\\n        startPeriod = downtime.startPeriod;\\n        endPeriod = downtime.endPeriod;\\n    }\\n\\n    //------------------ ERC900 connectors ----------------------\\n\\n    function totalStakedForAt(address _owner, uint256 _blockNumber) public view override returns (uint256) {\\n        if (isUpgrade == UPGRADE_TRUE) {\\n            return stakerInfo[_owner].history.getValueAt(_blockNumber);\\n        }\\n        return 0;\\n    }\\n\\n    function totalStakedAt(uint256 _blockNumber) public view override returns (uint256) {\\n        if (isUpgrade == UPGRADE_TRUE) {\\n            return balanceHistory.getValueAt(_blockNumber);\\n        }\\n        return token.totalSupply();\\n    }\\n\\n    function supportsHistory() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    //------------------------Upgradeable------------------------\\n    /**\\n    * @dev Get StakerInfo structure by delegatecall\\n    */\\n    function delegateGetStakerInfo(address _target, bytes32 _staker)\\n        internal returns (StakerInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.stakerInfo.selector, 1, _staker, 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n\\n        require(delegateGet(_testTarget, this.getStakersLength.selector) == stakers.length);\\n        if (stakers.length == 0) {\\n            return;\\n        }\\n        address stakerAddress = stakers[0];\\n        require(address(uint160(delegateGet(_testTarget, this.stakers.selector, 0))) == stakerAddress);\\n        StakerInfo storage info = stakerInfo[stakerAddress];\\n        bytes32 staker = bytes32(uint256(stakerAddress));\\n        StakerInfo memory infoToCheck = delegateGetStakerInfo(_testTarget, staker);\\n        require(\\n            infoToCheck.value == info.value \\u0026\\u0026\\n            infoToCheck.flags == info.flags\\n        );\\n    }\\n\\n}\\n\"},\"Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"Ownable.sol\\\";\\n\\n\\n/**\\n* @notice Base contract for upgradeable contract\\n* @dev Inherited contract should implement verifyState(address) method by checking storage variables\\n* (see verifyState(address) in Dispatcher). Also contract should implement finishUpgrade(address)\\n* if it is using constructor parameters by coping this parameters to the dispatcher storage\\n*/\\nabstract contract Upgradeable is Ownable {\\n\\n    event StateVerified(address indexed testTarget, address sender);\\n    event UpgradeFinished(address indexed target, address sender);\\n\\n    /**\\n    * @dev Contracts at the target must reserve the same location in storage for this address as in Dispatcher\\n    * Stored data actually lives in the Dispatcher\\n    * However the storage layout is specified here in the implementing contracts\\n    */\\n    address public target;\\n\\n    /**\\n    * @dev Previous contract address (if available). Used for rollback\\n    */\\n    address public previousTarget;\\n\\n    /**\\n    * @dev Upgrade status. Explicit `uint8` type is used instead of `bool` to save gas by excluding 0 value\\n    */\\n    uint8 public isUpgrade;\\n\\n    /**\\n    * @dev Guarantees that next slot will be separated from the previous\\n    */\\n    uint256 stubSlot;\\n\\n    /**\\n    * @dev Constants for `isUpgrade` field\\n    */\\n    uint8 constant UPGRADE_FALSE = 1;\\n    uint8 constant UPGRADE_TRUE = 2;\\n\\n    /**\\n    * @dev Checks that function executed while upgrading\\n    * Recommended to add to `verifyState` and `finishUpgrade` methods\\n    */\\n    modifier onlyWhileUpgrading()\\n    {\\n        require(isUpgrade == UPGRADE_TRUE);\\n        _;\\n    }\\n\\n    /**\\n    * @dev Method for verifying storage state.\\n    * Should check that new target contract returns right storage value\\n    */\\n    function verifyState(address _testTarget) public virtual onlyWhileUpgrading {\\n        emit StateVerified(_testTarget, msg.sender);\\n    }\\n\\n    /**\\n    * @dev Copy values from the new target to the current storage\\n    * @param _target New target contract address\\n    */\\n    function finishUpgrade(address _target) public virtual onlyWhileUpgrading {\\n        emit UpgradeFinished(_target, msg.sender);\\n    }\\n\\n    /**\\n    * @dev Base method to get data\\n    * @param _target Target to call\\n    * @param _selector Method selector\\n    * @param _numberOfArguments Number of used arguments\\n    * @param _argument1 First method argument\\n    * @param _argument2 Second method argument\\n    * @return memoryAddress Address in memory where the data is located\\n    */\\n    function delegateGetData(\\n        address _target,\\n        bytes4 _selector,\\n        uint8 _numberOfArguments,\\n        bytes32 _argument1,\\n        bytes32 _argument2\\n    )\\n        internal returns (bytes32 memoryAddress)\\n    {\\n        assembly {\\n            memoryAddress := mload(0x40)\\n            mstore(memoryAddress, _selector)\\n            if gt(_numberOfArguments, 0) {\\n                mstore(add(memoryAddress, 0x04), _argument1)\\n            }\\n            if gt(_numberOfArguments, 1) {\\n                mstore(add(memoryAddress, 0x24), _argument2)\\n            }\\n            switch delegatecall(gas(), _target, memoryAddress, add(0x04, mul(0x20, _numberOfArguments)), 0, 0)\\n                case 0 {\\n                    revert(memoryAddress, 0)\\n                }\\n                default {\\n                    returndatacopy(memoryAddress, 0x0, returndatasize())\\n                }\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" without parameters.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(address _target, bytes4 _selector)\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 0, 0, 0);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" with one parameter.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(address _target, bytes4 _selector, bytes32 _argument)\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 1, _argument, 0);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" with two parameters.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(\\n        address _target,\\n        bytes4 _selector,\\n        bytes32 _argument1,\\n        bytes32 _argument2\\n    )\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 2, _argument1, _argument2);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract NuCypherToken\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract WorkLockInterface\",\"name\":\"_workLock\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investigator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"testTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"StateVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UpgradeFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceHistory\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMintingPeriod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPeriodSupply\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_unlockingDuration\",\"type\":\"uint16\"}],\"name\":\"depositFromWorkLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"finishUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getAllTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getCompletedWork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPastDowntime\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"startPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"endPeriod\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getPastDowntimeLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSubStakeInfo\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"firstPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"unlockingDuration\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"lockedValue\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getSubStakesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgrade\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"lockedPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousPeriodSupply\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_measureWork\",\"type\":\"bool\"}],\"name\":\"setWorkMeasurement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerFromWorker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"currentCommittedPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"nextCommittedPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastCommittedPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stub1\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"completedWork\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"workerStartPeriod\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"worker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot5\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract NuCypherToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalStakedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalStakedForAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_testTarget\",\"type\":\"address\"}],\"name\":\"verifyState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"workLock\",\"outputs\":[{\"internalType\":\"contract WorkLockInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StakingEscrow","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004fe83213d56308330ec302a8bd641f1d0113a4cc000000000000000000000000e9778e69a961e64d3cdbb34cf6778281d34667c2","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://033196e27830a6dc94e16ed9c79ec2cbfcf62931d6c95dc89c09ea73fe0006a2"}]}