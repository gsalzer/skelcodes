{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n/* solium-disable error-reason */\npragma solidity 0.8.10;\npragma abicoder v2;\n\n\n/// @title Utils\n/// @notice Utils contract for various helpers used by the Raiden Network smart\n/// contracts.\ncontract Utils {\n\n    uint256 constant MAX_SAFE_UINT256 = 2**256 - 1;\n\n    /// @notice Check if a contract exists\n    /// @param contract_address The address to check whether a contract is\n    /// deployed or not\n    /// @return True if a contract exists, false otherwise\n    function contractExists(address contract_address) public view returns (bool) {\n        uint size;\n\n        assembly { // solium-disable-line security/no-inline-assembly\n            size := extcodesize(contract_address)\n        }\n\n        return size > 0;\n    }\n\n    string public constant signature_prefix = \"\\x19Ethereum Signed Message:\\n\";\n\n    function min(uint256 a, uint256 b) public pure returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n\n    function max(uint256 a, uint256 b) public pure returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n\n    /// @dev Special subtraction function that does not fail when underflowing.\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Minimum between the result of the subtraction and 0, the maximum\n    /// subtrahend for which no underflow occurs\n    function failsafe_subtract(uint256 a, uint256 b)\n        public\n        pure\n        returns (uint256, uint256)\n    {\n        unchecked {\n            return a > b ? (a - b, b) : (0, a);\n        }\n    }\n\n    /// @dev Special addition function that does not fail when overflowing.\n    /// @param a Addend\n    /// @param b Addend\n    /// @return Maximum between the result of the addition or the maximum\n    /// uint256 value\n    function failsafe_addition(uint256 a, uint256 b)\n        public\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 sum = a + b;\n            return sum >= a ? sum : MAX_SAFE_UINT256;\n        }\n    }\n}\n\ninterface Token {\n\n    /// @return supply total amount of tokens\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Optionally implemented function to show the number of decimals for the token\n    function decimals() external view returns (uint8 decimals);\n}\n/* solium-disable indentation */\n\n/* solium-disable error-reason */\n\nlibrary ECVerify {\n\n    function ecverify(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address signature_address)\n    {\n        require(signature.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n\n            // Here we are loading the last 32 bytes, including 31 bytes following the signature.\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28);\n\n        signature_address = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(signature_address != address(0x0));\n\n        return signature_address;\n    }\n}\n/* solium-disable error-reason */\n\nlibrary MessageType {\n\n    enum MessageTypeId {\n        None,\n        BalanceProof,\n        BalanceProofUpdate,\n        Withdraw,\n        CooperativeSettle,\n        IOU,\n        MSReward\n    }\n}\n\n/// @title SecretRegistry\n/// @notice SecretRegistry contract for registering secrets from Raiden Network\n/// clients.\ncontract SecretRegistry {\n    // sha256(secret) => block number at which the secret was revealed\n    mapping(bytes32 => uint256) private secrethash_to_block;\n\n    event SecretRevealed(bytes32 indexed secrethash, bytes32 secret);\n\n    /// @notice Registers a hash time lock secret and saves the block number.\n    /// This allows the lock to be unlocked after the expiration block\n    /// @param secret The secret used to lock the hash time lock\n    /// @return true if secret was registered, false if the secret was already\n    /// registered\n    function registerSecret(bytes32 secret) public returns (bool) {\n        bytes32 secrethash = sha256(abi.encodePacked(secret));\n        if (secrethash_to_block[secrethash] > 0) {\n            return false;\n        }\n        secrethash_to_block[secrethash] = block.number;\n        emit SecretRevealed(secrethash, secret);\n        return true;\n    }\n\n    /// @notice Registers multiple hash time lock secrets and saves the block\n    /// number\n    /// @param secrets The array of secrets to be registered\n    /// @return true if all secrets could be registered, false otherwise\n    function registerSecretBatch(bytes32[] memory secrets) public returns (bool) {\n        bool completeSuccess = true;\n        for(uint i = 0; i < secrets.length; i++) {\n            if(!registerSecret(secrets[i])) {\n                completeSuccess = false;\n            }\n        }\n        return completeSuccess;\n    }\n\n    /// @notice Get the stored block number at which the secret was revealed\n    /// @param secrethash The hash of the registered secret `keccak256(secret)`\n    /// @return The block number at which the secret was revealed\n    function getSecretRevealBlockHeight(bytes32 secrethash) public view returns (uint256) {\n        return secrethash_to_block[secrethash];\n    }\n}\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\ncontract Controllable {\n\n    address public controller;\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"Can only be called by controller\");\n        _;\n    }\n\n    /// @notice Changes the controller who is allowed to deprecate or remove limits.\n    /// Can only be called by the controller.\n    function changeController(address new_controller)\n        external\n        onlyController\n    {\n        controller = new_controller;\n    }\n}\n\n/// @title TokenNetwork\n/// @notice Stores and manages all the Raiden Network channels that use the\n/// token specified in this TokenNetwork contract.\ncontract TokenNetwork is Utils, Controllable {\n    // Instance of the token used by the channels\n    Token public token;\n\n    // Instance of SecretRegistry used for storing secrets revealed in a\n    // mediating transfer.\n    SecretRegistry public secret_registry;\n\n    uint256 public settlement_timeout_min;\n    uint256 public settlement_timeout_max;\n\n    // The deposit limit per channel per participant.\n    uint256 public channel_participant_deposit_limit;\n    // The total combined deposit of all channels across the whole network\n    uint256 public token_network_deposit_limit;\n\n    // Global, monotonically increasing counter that keeps track of all the\n    // opened channels in this contract\n    uint256 public channel_counter;\n\n    // Only for the limited Red Eyes release\n    bool public safety_deprecation_switch = false;\n\n    // channel_identifier => Channel\n    // channel identifier is the channel_counter value at the time of opening\n    // the channel\n    mapping (uint256 => Channel) public channels;\n\n    // This is needed to enforce one channel per pair of participants\n    // The key is keccak256(participant1_address, participant2_address)\n    mapping (bytes32 => uint256) public participants_hash_to_channel_identifier;\n\n    // We keep the unlock data in a separate mapping to allow channel data\n    // structures to be removed when settling uncooperatively. If there are\n    // locked pending transfers, we need to store data needed to unlock them at\n    // a later time.\n    // The key is `keccak256(uint256 channel_identifier, address participant,\n    // address partner)` Where `participant` is the participant that sent the\n    // pending transfers We need `partner` for knowing where to send the\n    // claimable tokens\n    mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data;\n\n    struct Participant {\n        // Total amount of tokens transferred to this smart contract through\n        // the `setTotalDeposit` function, for a specific channel, in the\n        // participant's benefit.\n        // This is a strictly monotonic value. Note that direct token transfer\n        // into the contract cannot be tracked and will be stuck.\n        uint256 deposit;\n\n        // Total amount of tokens withdrawn by the participant during the\n        // lifecycle of this channel.\n        // This is a strictly monotonic value.\n        uint256 withdrawn_amount;\n\n        // This is a value set to true after the channel has been closed, only\n        // if this is the participant who closed the channel.\n        bool is_the_closer;\n\n        // keccak256 of the balance data provided after a closeChannel or an\n        // updateNonClosingBalanceProof call\n        bytes32 balance_hash;\n\n        // Monotonically increasing counter of the off-chain transfers,\n        // provided along with the balance_hash\n        uint256 nonce;\n    }\n\n    enum ChannelState {\n        NonExistent, // 0\n        Opened,      // 1\n        Closed,      // 2\n        Settled,     // 3; Note: The channel has at least one pending unlock\n        Removed      // 4; Note: Channel data is removed, there are no pending unlocks\n    }\n\n    struct Channel {\n        // After opening the channel this value represents the settlement\n        // window. This is the number of blocks that need to be mined between\n        // closing the channel uncooperatively and settling the channel.\n        // After the channel has been uncooperatively closed, this value\n        // represents the block number after which settleChannel can be called.\n        uint256 settle_block_number;\n\n        ChannelState state;\n\n        mapping(address => Participant) participants;\n    }\n\n    struct WithdrawInput {\n        address participant;\n        uint256 total_withdraw;\n        uint256 expiration_block;\n        bytes participant_signature;\n        bytes partner_signature;\n    }\n\n    struct SettlementData {\n        uint256 deposit;\n        uint256 withdrawn;\n        uint256 transferred;\n        uint256 locked;\n    }\n\n    struct UnlockData {\n        // keccak256 hash of the pending locks from the Raiden client\n        bytes32 locksroot;\n        // Total amount of tokens locked in the pending locks corresponding\n        // to the `locksroot`\n        uint256 locked_amount;\n    }\n\n    struct SettleInput {\n        address participant;\n        uint256 transferred_amount;\n        uint256 locked_amount;\n        bytes32 locksroot;\n    }\n\n    event ChannelOpened(\n        uint256 indexed channel_identifier,\n        address indexed participant1,\n        address indexed participant2,\n        uint256 settle_timeout\n    );\n\n    event ChannelNewDeposit(\n        uint256 indexed channel_identifier,\n        address indexed participant,\n        uint256 total_deposit\n    );\n\n    // Fires when the deprecation_switch's value changes\n    event DeprecationSwitch(bool new_value);\n\n    // total_withdraw is how much the participant has withdrawn during the\n    // lifetime of the channel. The actual amount which the participant withdrew\n    // is `total_withdraw - total_withdraw_from_previous_event_or_zero`\n    event ChannelWithdraw(\n        uint256 indexed channel_identifier,\n        address indexed participant,\n        uint256 total_withdraw\n    );\n\n    event ChannelClosed(\n        uint256 indexed channel_identifier,\n        address indexed closing_participant,\n        uint256 indexed nonce,\n        bytes32 balance_hash\n    );\n\n    event ChannelUnlocked(\n        uint256 indexed channel_identifier,\n        address indexed receiver,\n        address indexed sender,\n        bytes32 locksroot,\n        uint256 unlocked_amount,\n        uint256 returned_tokens\n    );\n\n    event NonClosingBalanceProofUpdated(\n        uint256 indexed channel_identifier,\n        address indexed closing_participant,\n        uint256 indexed nonce,\n        bytes32 balance_hash\n    );\n\n    event ChannelSettled(\n        uint256 indexed channel_identifier,\n        address participant1,\n        uint256 participant1_amount,\n        bytes32 participant1_locksroot,\n        address participant2,\n        uint256 participant2_amount,\n        bytes32 participant2_locksroot\n    );\n\n    modifier isSafe() {\n        require(safety_deprecation_switch == false, \"TN: network is deprecated\");\n        _;\n    }\n\n    modifier isOpen(uint256 channel_identifier) {\n        require(channels[channel_identifier].state == ChannelState.Opened, \"TN: channel not open\");\n        _;\n    }\n\n    modifier settleTimeoutValid(uint256 timeout) {\n        require(timeout >= settlement_timeout_min, \"TN: settle timeout < min\");\n        require(timeout <= settlement_timeout_max, \"TN: settle timeout > max\");\n        _;\n    }\n\n    /// @param _token_address The address of the ERC20 token contract\n    /// @param _secret_registry The address of SecretRegistry contract that witnesses the onchain secret reveals\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _controller The Ethereum address that can disable new deposits and channel creation\n    /// @param _channel_participant_deposit_limit The maximum amount of tokens that can be deposited by each\n    /// participant of each channel. MAX_SAFE_UINT256 means no limits\n    /// @param _token_network_deposit_limit The maximum amount of tokens that this contract can hold\n    /// MAX_SAFE_UINT256 means no limits\n    constructor(\n        address _token_address,\n        address _secret_registry,\n        uint256 _settlement_timeout_min,\n        uint256 _settlement_timeout_max,\n        address _controller,\n        uint256 _channel_participant_deposit_limit,\n        uint256 _token_network_deposit_limit\n    ) {\n        require(_token_address != address(0x0), \"TN: invalid token address\");\n        require(_secret_registry != address(0x0), \"TN: invalid SR address\");\n        require(_controller != address(0x0), \"TN: invalid controller address\");\n        require(_settlement_timeout_min > 0, \"TN: invalid settle timeout min\");\n        require(_settlement_timeout_max > _settlement_timeout_min, \"TN: invalid settle timeouts\");\n        require(contractExists(_token_address), \"TN: invalid token contract\");\n        require(contractExists(_secret_registry), \"TN: invalid SR contract\");\n        require(_channel_participant_deposit_limit > 0, \"TN: invalid participant limit\");\n        require(_token_network_deposit_limit > 0, \"TN: invalid network deposit limit\");\n        require(_token_network_deposit_limit >= _channel_participant_deposit_limit, \"TN: invalid deposit limits\");\n\n        token = Token(_token_address);\n\n        secret_registry = SecretRegistry(_secret_registry);\n        settlement_timeout_min = _settlement_timeout_min;\n        settlement_timeout_max = _settlement_timeout_max;\n\n        // Make sure the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"TN: no supply for token\");\n\n        controller = _controller;\n        channel_participant_deposit_limit = _channel_participant_deposit_limit;\n        token_network_deposit_limit = _token_network_deposit_limit;\n    }\n\n    function deprecate() public isSafe onlyController {\n        safety_deprecation_switch = true;\n        emit DeprecationSwitch(safety_deprecation_switch);\n    }\n\n    /// @notice Opens a new channel between `participant1` and `participant2`.\n    /// Can be called by anyone\n    /// @param participant1 Ethereum address of a channel participant\n    /// @param participant2 Ethereum address of the other channel participant\n    /// @param settle_timeout Number of blocks that need to be mined between a\n    /// call to closeChannel and settleChannel\n    function openChannel(address participant1, address participant2, uint256 settle_timeout)\n        public\n        isSafe\n        settleTimeoutValid(settle_timeout)\n        returns (uint256)\n    {\n        bytes32 pair_hash;\n        uint256 channel_identifier;\n\n        // Red Eyes release token network limit\n        require(token.balanceOf(address(this)) < token_network_deposit_limit, \"TN/open: network deposit limit reached\");\n\n        // First increment the counter\n        // There will never be a channel with channel_identifier == 0\n        channel_counter += 1;\n        channel_identifier = channel_counter;\n\n        pair_hash = getParticipantsHash(participant1, participant2);\n\n        // There must only be one channel opened between two participants at\n        // any moment in time.\n        require(participants_hash_to_channel_identifier[pair_hash] == 0, \"TN/open: channel exists for participants\");\n        participants_hash_to_channel_identifier[pair_hash] = channel_identifier;\n\n        Channel storage channel = channels[channel_identifier];\n\n        // We always increase the channel counter, therefore no channel data can already exist,\n        // corresponding to this channel_identifier. This check must never fail.\n        assert(channel.settle_block_number == 0);\n        assert(channel.state == ChannelState.NonExistent);\n\n        // Store channel information\n        channel.settle_block_number = settle_timeout;\n        channel.state = ChannelState.Opened;\n\n        emit ChannelOpened(\n            channel_identifier,\n            participant1,\n            participant2,\n            settle_timeout\n        );\n\n        return channel_identifier;\n    }\n\n    /// @notice Opens a new channel between `participant1` and `participant2`\n    /// and deposits for `participant1`. Can be called by anyone\n    /// @param participant1 Ethereum address of a channel participant\n    /// @param participant2 Ethereum address of the other channel participant\n    /// @param settle_timeout Number of blocks that need to be mined between a\n    /// call to closeChannel and settleChannel\n    /// @param participant1_total_deposit The total amount of tokens that\n    /// `participant1` will have as deposit\n    function openChannelWithDeposit(\n        address participant1,\n        address participant2,\n        uint256 settle_timeout,\n        uint256 participant1_total_deposit\n    )\n        public\n        isSafe\n        settleTimeoutValid(settle_timeout)\n        returns (uint256)\n    {\n        uint256 channel_identifier;\n\n        channel_identifier = openChannel(participant1, participant2, settle_timeout);\n        setTotalDepositFor(\n            channel_identifier,\n            participant1,\n            participant1_total_deposit,\n            participant2,\n            msg.sender\n        );\n\n        return channel_identifier;\n    }\n\n    /// @notice Sets the channel participant total deposit value.\n    /// Can be called by anyone.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant Channel participant whose deposit is being set\n    /// @param total_deposit The total amount of tokens that the participant\n    /// will have as a deposit\n    /// @param partner Channel partner address, needed to compute the total\n    /// channel deposit\n    function setTotalDeposit(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_deposit,\n        address partner\n    )\n        public\n        isSafe\n        isOpen(channel_identifier)\n    {\n        setTotalDepositFor(\n            channel_identifier,\n            participant,\n            total_deposit,\n            partner,\n            msg.sender\n        );\n    }\n\n    /// @notice Allows `participant` to withdraw tokens from the channel that he\n    /// has with `partner`, without closing it. Can be called by anyone. Can\n    /// only be called once per each signed withdraw message\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant Channel participant, who will receive the withdrawn\n    /// amount\n    /// @param total_withdraw Total amount of tokens that are marked as\n    /// withdrawn from the channel during the channel lifecycle\n    /// @param participant_signature Participant's signature on the withdraw\n    /// data\n    /// @param partner_signature Partner's signature on the withdraw data\n    function setTotalWithdraw(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_withdraw,\n        uint256 expiration_block,\n        bytes calldata participant_signature,\n        bytes calldata partner_signature\n    )\n        external\n        isOpen(channel_identifier)\n    {\n        this.setTotalWithdraw2(\n            channel_identifier,\n            WithdrawInput({\n                participant: participant,\n                total_withdraw: total_withdraw,\n                expiration_block: expiration_block,\n                participant_signature: participant_signature,\n                partner_signature: partner_signature\n            })\n        );\n    }\n\n    function setTotalWithdraw2(\n        uint256 channel_identifier,\n        WithdrawInput memory withdraw_data\n    )\n        external\n        isOpen(channel_identifier)\n    {\n        uint256 total_deposit;\n        uint256 current_withdraw;\n        address partner;\n\n        require(withdraw_data.total_withdraw > 0, \"TN/withdraw: total withdraw is zero\");\n        require(block.number < withdraw_data.expiration_block, \"TN/withdraw: expired\");\n\n        // Authenticate both channel partners via their signatures.\n        // `participant` is a part of the signed message, so given in the calldata.\n        require(withdraw_data.participant == recoverAddressFromWithdrawMessage(\n            channel_identifier,\n            withdraw_data.participant,\n            withdraw_data.total_withdraw,\n            withdraw_data.expiration_block,\n            withdraw_data.participant_signature\n        ), \"TN/withdraw: invalid participant sig\");\n        partner = recoverAddressFromWithdrawMessage(\n            channel_identifier,\n            withdraw_data.participant,\n            withdraw_data.total_withdraw,\n            withdraw_data.expiration_block,\n            withdraw_data.partner_signature\n        );\n\n        // Validate that authenticated partners and the channel identifier match\n        require(\n            channel_identifier == getChannelIdentifier(withdraw_data.participant, partner),\n            \"TN/withdraw: channel id mismatch\"\n        );\n\n        // Read channel state after validating the function input\n        Channel storage channel = channels[channel_identifier];\n        Participant storage participant_state = channel.participants[withdraw_data.participant];\n        Participant storage partner_state = channel.participants[partner];\n\n        total_deposit = participant_state.deposit + partner_state.deposit;\n\n        // Entire withdrawn amount must not be bigger than the current channel deposit\n        require(\n            (withdraw_data.total_withdraw + partner_state.withdrawn_amount) <= total_deposit,\n            \"TN/withdraw: withdraw > deposit\"\n        );\n        require(\n            withdraw_data.total_withdraw <= (withdraw_data.total_withdraw + partner_state.withdrawn_amount),\n            \"TN/withdraw: overflow\"\n        );\n\n        // Using the total_withdraw (monotonically increasing) in the signed\n        // message ensures that we do not allow replay attack to happen, by\n        // using the same withdraw proof twice.\n        // Next two lines enforce the monotonicity of total_withdraw and check for an underflow:\n        // (we use <= because current_withdraw == total_withdraw for the first withdraw)\n        current_withdraw = withdraw_data.total_withdraw - participant_state.withdrawn_amount;\n        require(current_withdraw <= withdraw_data.total_withdraw, \"TN/withdraw: underflow\");\n\n        // The actual amount of tokens that will be transferred must be > 0 to disable the reuse of\n        // withdraw messages completely.\n        require(current_withdraw > 0, \"TN/withdraw: amount is zero\");\n\n        // This should never fail at this point. Added check for security, because we directly set\n        // the participant_state.withdrawn_amount = total_withdraw,\n        // while we transfer `current_withdraw` tokens.\n        assert(participant_state.withdrawn_amount + current_withdraw == withdraw_data.total_withdraw);\n\n        emit ChannelWithdraw(\n            channel_identifier,\n            withdraw_data.participant,\n            withdraw_data.total_withdraw\n        );\n\n        // Do the state change and tokens transfer\n        participant_state.withdrawn_amount = withdraw_data.total_withdraw;\n        require(token.transfer(withdraw_data.participant, current_withdraw), \"TN/withdraw: transfer failed\");\n\n        // This should never happen, as we have an overflow check in setTotalDeposit\n        assert(total_deposit >= participant_state.deposit);\n        assert(total_deposit >= partner_state.deposit);\n\n        // A withdraw should never happen if a participant already has a\n        // balance proof in storage. This should never fail as we use isOpen.\n        assert(participant_state.nonce == 0);\n        assert(partner_state.nonce == 0);\n    }\n\n    /// @notice Cooperatively settles the balances between the two channel\n    /// participants and transfers the agreed upon token amounts to the\n    /// participants. After this the channel lifecycle has ended and no more\n    /// operations can be done on it.\n    /// An important constraint is that this function checks that all tokens\n    /// in this channel are withdrawn. This means that the channel can *not*\n    /// have any outstanding locked transfers.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param data1 Withdraw data of the first participant\n    /// @param data2 Withdraw data of the second participant\n    function cooperativeSettle(\n        uint256 channel_identifier,\n        WithdrawInput memory data1,\n        WithdrawInput memory data2\n    )\n        external\n        isOpen(channel_identifier)\n    {\n        uint256 total_deposit;\n\n        // Validate that authenticated partners and the channel identifier match\n        require(\n            channel_identifier == getChannelIdentifier(data1.participant, data2.participant),\n            \"TN/coopSettle: channel id mismatch\"\n        );\n        Channel storage channel = channels[channel_identifier];\n\n        Participant storage participant1_state = channel.participants[data1.participant];\n        Participant storage participant2_state = channel.participants[data2.participant];\n        total_deposit = participant1_state.deposit + participant2_state.deposit;\n\n        // The sum of the provided balances must be equal to the total\n        // available deposit. This also implies that no locks must exist in the channel\n        // when this is called, as otherwise the withdrawable amount would be smaller\n        // than required.\n        require((data1.total_withdraw + data2.total_withdraw) == total_deposit, \"TN/coopSettle: incomplete amounts\");\n        // Overflow check for the balances addition from the above check.\n        // This overflow should never happen if the token.transfer function is implemented\n        // correctly. We do not control the token implementation, therefore we add this\n        // check for safety.\n        require(data1.total_withdraw <= data1.total_withdraw + data2.total_withdraw, \"TN/coopSettle: overflow\");\n\n        if (data1.total_withdraw > 0) {\n            this.setTotalWithdraw2(\n                channel_identifier,\n                data1\n            );\n        }\n        if (data2.total_withdraw > 0) {\n            this.setTotalWithdraw2(\n                channel_identifier,\n                data2\n            );\n        }\n        removeChannelData(channel, channel_identifier, data1.participant, data2.participant);\n\n        emit ChannelSettled(\n            channel_identifier,\n            data1.participant,\n            data1.total_withdraw,\n            0,\n            data2.participant,\n            data2.total_withdraw,\n            0\n        );\n    }\n\n    /// @notice Close the channel defined by the two participant addresses.\n    /// Anybody can call this function on behalf of a participant (called\n    /// the closing participant), providing a balance proof signed by\n    /// both parties. Callable only once\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param closing_participant Channel participant who closes the channel\n    /// @param non_closing_participant Channel partner of the `closing_participant`,\n    /// who provided the balance proof\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\n    /// locksroot)\n    /// @param additional_hash Computed from the message. Used for message\n    /// authentication\n    /// @param nonce Strictly monotonic value used to order transfers\n    /// @param non_closing_signature Non-closing participant's signature of the balance proof data\n    /// @param closing_signature Closing participant's signature of the balance\n    /// proof data\n    function closeChannel(\n        uint256 channel_identifier,\n        address non_closing_participant,\n        address closing_participant,\n        // The next four arguments form a balance proof.\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory non_closing_signature,\n        bytes memory closing_signature\n    )\n        public\n        isOpen(channel_identifier)\n    {\n        require(\n            channel_identifier == getChannelIdentifier(closing_participant, non_closing_participant),\n            \"TN/close: channel id mismatch\"\n        );\n\n        address recovered_non_closing_participant_address;\n\n        Channel storage channel = channels[channel_identifier];\n\n        channel.state = ChannelState.Closed;\n        channel.participants[closing_participant].is_the_closer = true;\n\n        // This is the block number at which the channel can be settled.\n        channel.settle_block_number += uint256(block.number);\n\n        // The closing participant must have signed the balance proof.\n        address recovered_closing_participant_address = recoverAddressFromBalanceProofCounterSignature(\n            MessageType.MessageTypeId.BalanceProof,\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            non_closing_signature,\n            closing_signature\n        );\n        require(closing_participant == recovered_closing_participant_address, \"TN/close: invalid closing sig\");\n\n        // Nonce 0 means that the closer never received a transfer, therefore\n        // never received a balance proof, or he is intentionally not providing\n        // the latest transfer, in which case the closing party is going to\n        // lose the tokens that were transferred to him.\n        if (nonce > 0) {\n            recovered_non_closing_participant_address = recoverAddressFromBalanceProof(\n                channel_identifier,\n                balance_hash,\n                nonce,\n                additional_hash,\n                non_closing_signature\n            );\n            // Signature must be from the channel partner\n            require(\n                non_closing_participant == recovered_non_closing_participant_address,\n                \"TN/close: invalid non-closing sig\"\n            );\n\n            updateBalanceProofData(\n                channel,\n                recovered_non_closing_participant_address,\n                nonce,\n                balance_hash\n            );\n        }\n\n        emit ChannelClosed(channel_identifier, closing_participant, nonce, balance_hash);\n    }\n\n    /// @notice Called on a closed channel, the function allows the non-closing\n    /// participant to provide the last balance proof, which modifies the\n    /// closing participant's state. Can be called multiple times by anyone.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param closing_participant Channel participant who closed the channel\n    /// @param non_closing_participant Channel participant who needs to update\n    /// the balance proof\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\n    /// locksroot)\n    /// @param additional_hash Computed from the message. Used for message\n    /// authentication\n    /// @param nonce Strictly monotonic value used to order transfers\n    /// @param closing_signature Closing participant's signature of the balance\n    /// proof data\n    /// @param non_closing_signature Non-closing participant signature of the\n    /// balance proof data\n    function updateNonClosingBalanceProof(\n        uint256 channel_identifier,\n        address closing_participant,\n        address non_closing_participant,\n        // The next four arguments form a balance proof\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes calldata closing_signature,\n        bytes calldata non_closing_signature\n    )\n        external\n    {\n        require(\n            channel_identifier == getChannelIdentifier(closing_participant,non_closing_participant),\n             \"TN/update: channel id mismatch\"\n        );\n        require(balance_hash != bytes32(0x0), \"TN/update: balance hash is zero\");\n        require(nonce > 0, \"TN/update: nonce is zero\");\n\n        address recovered_non_closing_participant;\n        address recovered_closing_participant;\n\n        Channel storage channel = channels[channel_identifier];\n\n        require(channel.state == ChannelState.Closed, \"TN/update: channel not closed\");\n\n        // We need the signature from the non-closing participant to allow\n        // anyone to make this transaction. E.g. a monitoring service.\n        recovered_non_closing_participant = recoverAddressFromBalanceProofCounterSignature(\n            MessageType.MessageTypeId.BalanceProofUpdate,\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature,\n            non_closing_signature\n        );\n        require(non_closing_participant == recovered_non_closing_participant, \"TN/update: invalid non-closing sig\");\n\n        recovered_closing_participant = recoverAddressFromBalanceProof(\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature\n        );\n        require(closing_participant == recovered_closing_participant, \"TN/update: invalid closing sig\");\n\n        Participant storage closing_participant_state = channel.participants[closing_participant];\n        // Make sure the first signature is from the closing participant\n        require(closing_participant_state.is_the_closer, \"TN/update: incorrect signature order\");\n\n        // Update the balance proof data for the closing_participant\n        updateBalanceProofData(channel, closing_participant, nonce, balance_hash);\n\n        emit NonClosingBalanceProofUpdated(\n            channel_identifier,\n            closing_participant,\n            nonce,\n            balance_hash\n        );\n    }\n\n    /// @notice Settles the balance between the two parties. Note that arguments\n    /// order counts: `participant1_transferred_amount +\n    /// participant1_locked_amount` <= `participant2_transferred_amount +\n    /// participant2_locked_amount`\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant1 Channel participant\n    /// @param participant1_transferred_amount The latest known amount of tokens\n    /// transferred from `participant1` to `participant2`\n    /// @param participant1_locked_amount Amount of tokens owed by\n    /// `participant1` to `participant2`, contained in locked transfers that\n    /// will be retrieved by calling `unlock` after the channel is settled\n    /// @param participant1_locksroot The latest known hash of the\n    /// pending hash-time locks of `participant1`, used to validate the unlocked\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\n    /// @param participant2 Other channel participant\n    /// @param participant2_transferred_amount The latest known amount of tokens\n    /// transferred from `participant2` to `participant1`\n    /// @param participant2_locked_amount Amount of tokens owed by\n    /// `participant2` to `participant1`, contained in locked transfers that\n    /// will be retrieved by calling `unlock` after the channel is settled\n    /// @param participant2_locksroot The latest known hash of the\n    /// pending hash-time locks of `participant2`, used to validate the unlocked\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\n    function settleChannel(\n        uint256 channel_identifier,\n        address participant1,\n        uint256 participant1_transferred_amount,\n        uint256 participant1_locked_amount,\n        bytes32 participant1_locksroot,\n        address participant2,\n        uint256 participant2_transferred_amount,\n        uint256 participant2_locked_amount,\n        bytes32 participant2_locksroot\n    )\n        public\n    {\n        settleChannel2(\n            channel_identifier,\n            SettleInput({\n                participant: participant1,\n                transferred_amount: participant1_transferred_amount,\n                locked_amount: participant1_locked_amount,\n                locksroot: participant1_locksroot\n            }),\n            SettleInput({\n                participant: participant2,\n                transferred_amount: participant2_transferred_amount,\n                locked_amount: participant2_locked_amount,\n                locksroot: participant2_locksroot\n            })\n        );\n    }\n\n    function settleChannel2(\n        uint256 channel_identifier,\n        SettleInput memory participant1_settlement,\n        SettleInput memory participant2_settlement\n    )\n        public\n    {\n        // There are several requirements that this function MUST enforce:\n        // - it MUST never fail; therefore, any overflows or underflows must be\n        // handled gracefully\n        // - it MUST ensure that if participants use the latest valid balance proofs,\n        // provided by the official Raiden client, the participants will be able\n        // to receive correct final balances at the end of the channel lifecycle\n        // - it MUST ensure that the participants cannot cheat by providing an\n        // old, valid balance proof of their partner; meaning that their partner MUST\n        // receive at least the amount of tokens that he would have received if\n        // the latest valid balance proofs are used.\n        // - the contract cannot determine if a balance proof is invalid (values\n        // are not within the constraints enforced by the official Raiden client),\n        // therefore it cannot ensure correctness. Users MUST use the official\n        // Raiden clients for signing balance proofs.\n\n        address participant1 = participant1_settlement.participant;\n        address participant2 = participant2_settlement.participant;\n        require(\n            channel_identifier == getChannelIdentifier(participant1, participant2),\n            \"TN/settle: channel id mismatch\"\n        );\n\n        Channel storage channel = channels[channel_identifier];\n\n        require(channel.state == ChannelState.Closed, \"TN/settle: channel not closed\");\n\n        // Settlement window must be over\n        require(channel.settle_block_number < block.number, \"TN/settle: settlement timeout\");\n\n        Participant storage participant1_state = channel.participants[participant1];\n        Participant storage participant2_state = channel.participants[participant2];\n\n        require(\n            verifyBalanceHashData(participant1_state, participant1_settlement),\n            \"TN/settle: invalid data for participant 1\"\n        );\n\n        require(\n            verifyBalanceHashData(participant2_state, participant2_settlement),\n            \"TN/settle: invalid data for participant 2\"\n        );\n\n        // We are calculating the final token amounts that need to be\n        // transferred to the participants now and the amount of tokens that\n        // need to remain locked in the contract. These tokens can be unlocked\n        // by calling `unlock`.\n        // participant1_transferred_amount = the amount of tokens that\n        //   participant1 will receive in this transaction.\n        // participant2_transferred_amount = the amount of tokens that\n        //   participant2 will receive in this transaction.\n        // participant1_locked_amount = the amount of tokens remaining in the\n        //   contract, representing pending transfers from participant1 to participant2.\n        // participant2_locked_amount = the amount of tokens remaining in the\n        //   contract, representing pending transfers from participant2 to participant1.\n        // We are reusing variables due to the local variables number limit.\n        // For better readability this can be refactored further.\n        (\n            participant1_settlement.transferred_amount,\n            participant2_settlement.transferred_amount,\n            participant1_settlement.locked_amount,\n            participant2_settlement.locked_amount\n        ) = getSettleTransferAmounts(\n            participant1_state,\n            participant1_settlement.transferred_amount,\n            participant1_settlement.locked_amount,\n            participant2_state,\n            participant2_settlement.transferred_amount,\n            participant2_settlement.locked_amount\n        );\n\n        removeChannelData(channel, channel_identifier, participant1, participant2);\n\n        // Store balance data needed for `unlock`, including the calculated\n        // locked amounts remaining in the contract.\n        storeUnlockData(\n            channel_identifier,\n            participant1_settlement,\n            participant2\n        );\n        storeUnlockData(\n            channel_identifier,\n            participant2_settlement,\n            participant1\n        );\n\n        emit ChannelSettled(\n            channel_identifier,\n            participant1,\n            participant1_settlement.transferred_amount,\n            participant1_settlement.locksroot,\n            participant2,\n            participant2_settlement.transferred_amount,\n            participant2_settlement.locksroot\n        );\n\n        // Do the actual token transfers\n        if (participant1_settlement.transferred_amount > 0) {\n            require(\n                token.transfer(participant1, participant1_settlement.transferred_amount),\n                \"TN/settle: transfer for participant 1 failed\"\n            );\n        }\n\n        if (participant2_settlement.transferred_amount > 0) {\n            require(\n                token.transfer(participant2, participant2_settlement.transferred_amount),\n                \"TN/settle: transfer for participant 2 failed\"\n            );\n        }\n    }\n\n    /// @notice Unlocks all pending off-chain transfers from `sender` to\n    /// `receiver` and sends the locked tokens corresponding to locks with\n    /// secrets registered on-chain to the `receiver`. Locked tokens\n    /// corresponding to locks where the secret was not revealed on-chain will\n    /// return to the `sender`. Anyone can call unlock.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param receiver Address who will receive the claimable unlocked\n    /// tokens\n    /// @param sender Address who sent the pending transfers and will receive\n    /// the unclaimable unlocked tokens\n    /// @param locks All pending locks concatenated in order of creation\n    /// that `sender` sent to `receiver`\n    function unlock(\n        uint256 channel_identifier,\n        address receiver,\n        address sender,\n        bytes memory locks\n    )\n        public\n    {\n        // Channel represented by channel_identifier must be settled and\n        // channel data deleted\n        require(\n            channel_identifier != getChannelIdentifier(receiver, sender),\n            \"TN/unlock: channel id still exists\"\n        );\n\n        // After the channel is settled the storage is cleared, therefore the\n        // value will be NonExistent and not Settled. The value Settled is used\n        // for the external APIs\n        require(\n            channels[channel_identifier].state == ChannelState.NonExistent,\n            \"TN/unlock: channel not settled\"\n        );\n\n        bytes32 unlock_key;\n        bytes32 computed_locksroot;\n        uint256 unlocked_amount;\n        uint256 locked_amount;\n        uint256 returned_tokens;\n\n        // Calculate the locksroot for the pending transfers and the amount of\n        // tokens corresponding to the locked transfers with secrets revealed\n        // on chain.\n        (computed_locksroot, unlocked_amount) = getHashAndUnlockedAmount(\n            locks\n        );\n\n        // The sender must have a non-empty locksroot on-chain that must be\n        // the same as the computed locksroot.\n        // Get the amount of tokens that have been left in the contract, to\n        // account for the pending transfers `sender` -> `receiver`.\n        unlock_key = getUnlockIdentifier(channel_identifier, sender, receiver);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n        locked_amount = unlock_data.locked_amount;\n\n        // Locksroot must be the same as the computed locksroot\n        require(unlock_data.locksroot == computed_locksroot, \"TN/unlock: locksroot mismatch\");\n\n        // There are no pending transfers if the locked_amount is 0.\n        // Transaction must fail\n        require(locked_amount > 0, \"TN/unlock: zero locked amount\");\n\n        // Make sure we don't transfer more tokens than previously reserved in\n        // the smart contract.\n        unlocked_amount = min(unlocked_amount, locked_amount);\n\n        // Transfer the rest of the tokens back to the sender\n        returned_tokens = locked_amount - unlocked_amount;\n\n        // Remove sender's unlock data\n        delete unlock_identifier_to_unlock_data[unlock_key];\n\n        emit ChannelUnlocked(\n            channel_identifier,\n            receiver,\n            sender,\n            computed_locksroot,\n            unlocked_amount,\n            returned_tokens\n        );\n\n        // Transfer the unlocked tokens to the receiver. unlocked_amount can\n        // be 0\n        if (unlocked_amount > 0) {\n            require(token.transfer(receiver, unlocked_amount), \"TN/unlock: unlocked transfer failed\");\n        }\n\n        // Transfer the rest of the tokens back to the sender\n        if (returned_tokens > 0) {\n            require(token.transfer(sender, returned_tokens), \"TN/unlock: returned transfer failed\");\n        }\n\n        // At this point, this should always be true\n        assert(locked_amount >= returned_tokens);\n        assert(locked_amount >= unlocked_amount);\n    }\n\n    /// @notice Returns the unique identifier for the channel given by the\n    /// contract\n    /// @param participant Address of a channel participant\n    /// @param partner Address of the other channel participant\n    /// @return Unique identifier for the channel. It can be 0 if channel does\n    /// not exist\n    function getChannelIdentifier(address participant, address partner)\n        public\n        view\n        returns (uint256)\n    {\n        require(participant != address(0x0), \"TN: participant address zero\");\n        require(partner != address(0x0), \"TN: partner address zero\");\n        require(participant != partner, \"TN: identical addresses\");\n\n        bytes32 pair_hash = getParticipantsHash(participant, partner);\n        return participants_hash_to_channel_identifier[pair_hash];\n    }\n\n    /// @dev Returns the channel specific data.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant1 Address of a channel participant\n    /// @param participant2 Address of the other channel participant\n    /// @return Channel settle_block_number and state\n    /// @notice The contract cannot really distinguish Settled and Removed\n    /// states, especially when wrong participants are given as input.\n    /// The contract does not remember the participants of the channel\n    function getChannelInfo(\n        uint256 channel_identifier,\n        address participant1,\n        address participant2\n    )\n        external\n        view\n        returns (uint256, ChannelState)\n    {\n        bytes32 unlock_key1;\n        bytes32 unlock_key2;\n\n        Channel storage channel = channels[channel_identifier];\n        ChannelState state = channel.state;  // This must **not** update the storage\n\n        if (state == ChannelState.NonExistent &&\n            channel_identifier > 0 &&\n            channel_identifier <= channel_counter\n        ) {\n            // The channel has been settled, channel data is removed Therefore,\n            // the channel state in storage is actually `0`, or `NonExistent`\n            // However, for this view function, we return `Settled`, in order\n            // to provide a consistent external API\n            state = ChannelState.Settled;\n\n            // We might still have data stored for future unlock operations\n            // Only if we do not, we can consider the channel as `Removed`\n            unlock_key1 = getUnlockIdentifier(channel_identifier, participant1, participant2);\n            UnlockData storage unlock_data1 = unlock_identifier_to_unlock_data[unlock_key1];\n\n            unlock_key2 = getUnlockIdentifier(channel_identifier, participant2, participant1);\n            UnlockData storage unlock_data2 = unlock_identifier_to_unlock_data[unlock_key2];\n\n            if (unlock_data1.locked_amount == 0 && unlock_data2.locked_amount == 0) {\n                state = ChannelState.Removed;\n            }\n        }\n\n        return (\n            channel.settle_block_number,\n            state\n        );\n    }\n\n    /// @dev Returns the channel specific data.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant Address of the channel participant whose data will be\n    /// returned\n    /// @param partner Address of the channel partner\n    /// @return Participant's deposit, withdrawn_amount, whether the participant\n    /// has called `closeChannel` or not, balance_hash, nonce, locksroot,\n    /// locked_amount\n    function getChannelParticipantInfo(\n            uint256 channel_identifier,\n            address participant,\n            address partner\n    )\n        external\n        view\n        returns (uint256, uint256, bool, bytes32, uint256, bytes32, uint256)\n    {\n        bytes32 unlock_key;\n\n        Participant storage participant_state = channels[channel_identifier].participants[\n            participant\n        ];\n        unlock_key = getUnlockIdentifier(channel_identifier, participant, partner);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n\n        return (\n            participant_state.deposit,\n            participant_state.withdrawn_amount,\n            participant_state.is_the_closer,\n            participant_state.balance_hash,\n            participant_state.nonce,\n            unlock_data.locksroot,\n            unlock_data.locked_amount\n        );\n    }\n\n    /// @dev Get the hash of the participant addresses, ordered\n    /// lexicographically\n    /// @param participant Address of a channel participant\n    /// @param partner Address of the other channel participant\n    function getParticipantsHash(address participant, address partner)\n        public\n        pure\n        returns (bytes32)\n    {\n        require(participant != address(0x0), \"TN: participant address zero\");\n        require(partner != address(0x0), \"TN: partner address zero\");\n        require(participant != partner, \"TN: identical addresses\");\n\n        if (participant < partner) {\n            return keccak256(abi.encodePacked(participant, partner));\n        } else {\n            return keccak256(abi.encodePacked(partner, participant));\n        }\n    }\n\n    /// @dev Get the hash of the channel identifier and the participant\n    /// addresses (whose ordering matters). The hash might be useful for\n    /// the receiver to look up the appropriate UnlockData to claim\n    /// @param channel_identifier Identifier for the channel which the\n    /// UnlockData is about\n    /// @param sender Sender of the pending transfers that the UnlockData\n    /// represents\n    /// @param receiver Receiver of the pending transfers that the UnlockData\n    /// represents\n    function getUnlockIdentifier(\n        uint256 channel_identifier,\n        address sender,\n        address receiver\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        require(sender != receiver, \"TN: sender/receiver mismatch\");\n        return keccak256(abi.encodePacked(channel_identifier, sender, receiver));\n    }\n\n    function setTotalDepositFor(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_deposit,\n        address partner,\n        address token_owner\n    )\n        internal\n    {\n        require(channel_identifier == getChannelIdentifier(participant, partner), \"TN/deposit: channel id mismatch\");\n        require(total_deposit > 0, \"TN/deposit: total_deposit is zero\");\n        require(total_deposit <= channel_participant_deposit_limit, \"TN/deposit: deposit limit reached\");\n\n        uint256 added_deposit;\n        uint256 channel_deposit;\n\n        Channel storage channel = channels[channel_identifier];\n        Participant storage participant_state = channel.participants[participant];\n        Participant storage partner_state = channel.participants[partner];\n\n        unchecked {\n            // Calculate the actual amount of tokens that will be transferred\n            added_deposit = total_deposit - participant_state.deposit;\n\n            // The actual amount of tokens that will be transferred must be > 0\n            require(added_deposit > 0, \"TN/deposit: no deposit added\");\n\n            // Underflow check; we use <= because added_deposit == total_deposit for the first deposit\n            require(added_deposit <= total_deposit, \"TN/deposit: deposit underflow\");\n\n            // This should never fail at this point. Added check for security, because we directly set\n            // the participant_state.deposit = total_deposit, while we transfer `added_deposit` tokens\n            assert(participant_state.deposit + added_deposit == total_deposit);\n\n            // Red Eyes release token network limit\n            require(\n                token.balanceOf(address(this)) + added_deposit <= token_network_deposit_limit,\n                \"TN/deposit: network limit reached\"\n            );\n\n            // Update the participant's channel deposit\n            participant_state.deposit = total_deposit;\n\n            // Calculate the entire channel deposit, to avoid overflow\n            channel_deposit = participant_state.deposit + partner_state.deposit;\n            // Overflow check\n            require(channel_deposit >= participant_state.deposit, \"TN/deposit: deposit overflow\");\n        }\n\n        emit ChannelNewDeposit(\n            channel_identifier,\n            participant,\n            participant_state.deposit\n        );\n\n        // Do the transfer\n        require(token.transferFrom(token_owner, address(this), added_deposit), \"TN/deposit: transfer failed\");\n    }\n\n    function updateBalanceProofData(\n        Channel storage channel,\n        address participant,\n        uint256 nonce,\n        bytes32 balance_hash\n    )\n        internal\n    {\n        Participant storage participant_state = channel.participants[participant];\n\n        // Multiple calls to updateNonClosingBalanceProof can be made and we\n        // need to store the last known balance proof data.\n        // This line prevents Monitoring Services from getting rewards\n        // again and again using the same reward proof.\n        require(nonce > participant_state.nonce, \"TN: nonce reused\");\n\n        participant_state.nonce = nonce;\n        participant_state.balance_hash = balance_hash;\n    }\n\n    function storeUnlockData(\n        uint256 channel_identifier,\n        SettleInput memory settle_input,\n        address receiver\n    )\n        internal\n    {\n        // If there are transfers to unlock, store the locksroot and total\n        // amount of tokens\n        if (settle_input.locked_amount == 0) {\n            return;\n        }\n\n        bytes32 key = getUnlockIdentifier(channel_identifier, settle_input.participant, receiver);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[key];\n        unlock_data.locksroot = settle_input.locksroot;\n        unlock_data.locked_amount = settle_input.locked_amount;\n    }\n\n    function getChannelAvailableDeposit(\n        Participant storage participant1_state,\n        Participant storage participant2_state\n    )\n        internal\n        view\n        returns (uint256 total_available_deposit)\n    {\n        total_available_deposit = (\n            participant1_state.deposit +\n            participant2_state.deposit -\n            participant1_state.withdrawn_amount -\n            participant2_state.withdrawn_amount\n        );\n    }\n\n    /// @dev Function that calculates the amount of tokens that the participants\n    /// will receive when calling settleChannel.\n    /// Check https://github.com/raiden-network/raiden-contracts/issues/188 for the settlement\n    /// algorithm analysis and explanations.\n    function getSettleTransferAmounts(\n        Participant storage participant1_state,\n        uint256 participant1_transferred_amount,\n        uint256 participant1_locked_amount,\n        Participant storage participant2_state,\n        uint256 participant2_transferred_amount,\n        uint256 participant2_locked_amount\n    )\n        private\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        // The scope of this function is to compute the settlement amounts that\n        // the two channel participants will receive when calling settleChannel\n        // and the locked amounts that remain in the contract, to account for\n        // the pending, not finalized transfers, that will be received by the\n        // participants when calling `unlock`.\n\n        // The amount of tokens that participant1 MUST receive at the end of\n        // the channel lifecycle (after settleChannel and unlock) is:\n        // B1 = D1 - W1 + T2 - T1 + Lc2 - Lc1\n\n        // The amount of tokens that participant2 MUST receive at the end of\n        // the channel lifecycle (after settleChannel and unlock) is:\n        // B2 = D2 - W2 + T1 - T2 + Lc1 - Lc2\n\n        // B1 + B2 = TAD = D1 + D2 - W1 - W2\n        // TAD = total available deposit at settlement time\n\n        // L1 = Lc1 + Lu1\n        // L2 = Lc2 + Lu2\n\n        // where:\n        // B1 = final balance of participant1 after the channel is removed\n        // D1 = total amount deposited by participant1 into the channel\n        // W1 = total amount withdrawn by participant1 from the channel\n        // T2 = total amount transferred by participant2 to participant1 (finalized transfers)\n        // T1 = total amount transferred by participant1 to participant2 (finalized transfers)\n        // L1 = total amount of tokens locked in pending transfers, sent by\n        //   participant1 to participant2\n        // L2 = total amount of tokens locked in pending transfers, sent by\n        //   participant2 to participant1\n        // Lc2 = the amount that can be claimed by participant1 from the pending\n        //   transfers (that have not been finalized off-chain), sent by\n        //   participant2 to participant1. These are part of the locked amount\n        //   value from participant2's balance proof. They are considered claimed\n        //   if the secret corresponding to these locked transfers was registered\n        //   on-chain, in the SecretRegistry contract, before the lock's expiration.\n        // Lu1 = unclaimable locked amount from L1\n        // Lc1 = the amount that can be claimed by participant2 from the pending\n        //   transfers (that have not been finalized off-chain),\n        //   sent by participant1 to participant2\n        // Lu2 = unclaimable locked amount from L2\n\n        // Notes:\n        // 1) The unclaimble tokens from a locked amount will return to the sender.\n        // At the time of calling settleChannel, the TokenNetwork contract does\n        // not know what locked amounts are claimable or unclaimable.\n        // 2) There are some Solidity constraints that make the calculations\n        // more difficult: attention to overflows and underflows, that MUST be\n        // handled without throwing.\n\n        // Cases that require attention:\n        // case1. If participant1 does NOT provide a balance proof or provides\n        // an old balance proof.  participant2_transferred_amount can be [0,\n        // real_participant2_transferred_amount) We MUST NOT punish\n        // participant2.\n        // case2. If participant2 does NOT provide a balance proof or provides\n        // an old balance proof.  participant1_transferred_amount can be [0,\n        // real_participant1_transferred_amount) We MUST NOT punish\n        // participant1.\n        // case3. If neither participants provide a balance proof, we just\n        // subtract their withdrawn amounts from their deposits.\n\n        // This is why, the algorithm implemented in Solidity is:\n        // (explained at each step, below)\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\n        // RmaxP1 = min(TAD, RmaxP1)\n        // RmaxP2 = TAD - RmaxP1\n        // SL2 = min(RmaxP1, L2)\n        // S1 = RmaxP1 - SL2\n        // SL1 = min(RmaxP2, L1)\n        // S2 = RmaxP2 - SL1\n\n        // where:\n        // RmaxP1 = due to possible over/underflows that only appear when using\n        //    old balance proofs & the fact that settlement balance calculation\n        //    is symmetric (we can calculate either RmaxP1 and RmaxP2 first,\n        //    order does not affect result), this is a convention used to determine\n        //    the maximum receivable amount of participant1 at settlement time\n        // S1 = amount received by participant1 when calling settleChannel\n        // SL1 = the maximum amount from L1 that can be locked in the\n        //   TokenNetwork contract when calling settleChannel (due to overflows\n        //   that only happen when using old balance proofs)\n        // S2 = amount received by participant2 when calling settleChannel\n        // SL2 = the maximum amount from L2 that can be locked in the\n        //   TokenNetwork contract when calling settleChannel (due to overflows\n        //   that only happen when using old balance proofs)\n\n        uint256 participant1_amount;\n        uint256 participant2_amount;\n        uint256 total_available_deposit;\n\n        SettlementData memory participant1_settlement;\n        SettlementData memory participant2_settlement;\n\n        participant1_settlement.deposit = participant1_state.deposit;\n        participant1_settlement.withdrawn = participant1_state.withdrawn_amount;\n        participant1_settlement.transferred = participant1_transferred_amount;\n        participant1_settlement.locked = participant1_locked_amount;\n\n        participant2_settlement.deposit = participant2_state.deposit;\n        participant2_settlement.withdrawn = participant2_state.withdrawn_amount;\n        participant2_settlement.transferred = participant2_transferred_amount;\n        participant2_settlement.locked = participant2_locked_amount;\n\n        // TAD = D1 + D2 - W1 - W2 = total available deposit at settlement time\n        total_available_deposit = getChannelAvailableDeposit(\n            participant1_state,\n            participant2_state\n        );\n\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\n        // This amount is the maximum possible amount that participant1 can\n        // receive at settlement time and also contains the entire locked amount\n        //  of the pending transfers from participant2 to participant1.\n        participant1_amount = getMaxPossibleReceivableAmount(\n            participant1_settlement.deposit,\n            participant1_settlement.withdrawn,\n            participant1_settlement.transferred,\n            participant1_settlement.locked,\n            participant2_settlement.transferred,\n            participant2_settlement.locked\n        );\n\n        // RmaxP1 = min(TAD, RmaxP1)\n        // We need to bound this to the available channel deposit in order to\n        // not send tokens from other channels. The only case where TAD is\n        // smaller than RmaxP1 is when at least one balance proof is old.\n        participant1_amount = min(participant1_amount, total_available_deposit);\n\n        // RmaxP2 = TAD - RmaxP1\n        // Now it is safe to subtract without underflow\n        participant2_amount = total_available_deposit - participant1_amount;\n\n        // SL2 = min(RmaxP1, L2)\n        // S1 = RmaxP1 - SL2\n        // Both operations are done by failsafe_subtract\n        // We take out participant2's pending transfers locked amount, bounding\n        // it by the maximum receivable amount of participant1\n        (participant1_amount, participant2_locked_amount) = failsafe_subtract(\n            participant1_amount,\n            participant2_locked_amount\n        );\n\n        // SL1 = min(RmaxP2, L1)\n        // S2 = RmaxP2 - SL1\n        // Both operations are done by failsafe_subtract\n        // We take out participant1's pending transfers locked amount, bounding\n        // it by the maximum receivable amount of participant2\n        (participant2_amount, participant1_locked_amount) = failsafe_subtract(\n            participant2_amount,\n            participant1_locked_amount\n        );\n\n        // This should never throw:\n        // S1 and S2 MUST be smaller than TAD\n        assert(participant1_amount <= total_available_deposit);\n        assert(participant2_amount <= total_available_deposit);\n        // S1 + S2 + SL1 + SL2 == TAD\n        assert(total_available_deposit == (\n            participant1_amount +\n            participant2_amount +\n            participant1_locked_amount +\n            participant2_locked_amount\n        ));\n\n        return (\n            participant1_amount,\n            participant2_amount,\n            participant1_locked_amount,\n            participant2_locked_amount\n        );\n    }\n\n    function verifyBalanceHashData(\n        Participant storage participant,\n        SettleInput memory settle_input\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // When no balance proof has been provided, we need to check this\n        // separately because hashing values of 0 outputs a value != 0\n        if (participant.balance_hash == 0 &&\n            settle_input.transferred_amount == 0 &&\n            settle_input.locked_amount == 0\n            /* locksroot is ignored. */\n        ) {\n            return true;\n        }\n\n        // Make sure the hash of the provided state is the same as the stored\n        // balance_hash\n        return participant.balance_hash == keccak256(abi.encodePacked(\n            settle_input.transferred_amount,\n            settle_input.locked_amount,\n            settle_input.locksroot\n        ));\n    }\n\n    /// @dev Calculates the hash of the pending transfers data and\n    /// calculates the amount of tokens that can be unlocked because the secret\n    /// was registered on-chain.\n    function getHashAndUnlockedAmount(bytes memory locks)\n        internal\n        view\n        returns (bytes32, uint256)\n    {\n        uint256 length = locks.length;\n\n        // each lock has this form:\n        // (locked_amount || expiration_block || secrethash) = 3 * 32 bytes\n        require(length % 96 == 0, \"TN: invalid locks size\");\n\n        uint256 i;\n        uint256 total_unlocked_amount;\n        uint256 unlocked_amount;\n        bytes32 total_hash;\n\n        for (i = 32; i < length; i += 96) {\n            unlocked_amount = getLockedAmountFromLock(locks, i);\n            total_unlocked_amount += unlocked_amount;\n        }\n\n        total_hash = keccak256(locks);\n\n        return (total_hash, total_unlocked_amount);\n    }\n\n    function getLockedAmountFromLock(bytes memory locks, uint256 offset)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 expiration_block;\n        uint256 locked_amount;\n        uint256 reveal_block;\n        bytes32 secrethash;\n\n        if (locks.length <= offset) {\n            return 0;\n        }\n\n        assembly { // solium-disable-line security/no-inline-assembly\n            expiration_block := mload(add(locks, offset))\n            locked_amount := mload(add(locks, add(offset, 32)))\n            secrethash := mload(add(locks, add(offset, 64)))\n        }\n\n        // Check if the lock's secret was revealed in the SecretRegistry The\n        // secret must have been revealed in the SecretRegistry contract before\n        // the lock's expiration_block in order for the hash time lock transfer\n        // to be successful.\n        reveal_block = secret_registry.getSecretRevealBlockHeight(secrethash);\n        if (reveal_block == 0 || expiration_block <= reveal_block) {\n            locked_amount = 0;\n        }\n\n        return locked_amount;\n    }\n\n    function removeChannelData(Channel storage channel, uint256 channel_identifier, address participant1, address participant2)\n        internal\n    {\n        bytes32 pair_hash;\n\n        // Remove channel data from storage\n        delete channel.participants[participant1];\n        delete channel.participants[participant2];\n        delete channels[channel_identifier];\n\n        // Remove the pair's channel counter\n        pair_hash = getParticipantsHash(participant1, participant2);\n        delete participants_hash_to_channel_identifier[pair_hash];\n    }\n\n    function recoverAddressFromBalanceProof(\n        uint256 channel_identifier,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32\n        string memory message_length = \"212\";\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            block.chainid,\n            uint256(MessageType.MessageTypeId.BalanceProof),\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n    }\n\n    function recoverAddressFromBalanceProofCounterSignature(\n        MessageType.MessageTypeId message_type_id,\n        uint256 channel_identifier,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory closing_signature,\n        bytes memory non_closing_signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32 + 65\n        string memory message_prefix = \"\\x19Ethereum Signed Message:\\n277\";\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            message_prefix,\n            address(this),\n            block.chainid,\n            uint256(message_type_id),\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, non_closing_signature);\n    }\n\n    function recoverAddressFromWithdrawMessage(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_withdraw,\n        uint256 expiration_block,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 32\n        string memory message_length = \"200\";\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            block.chainid,\n            uint256(MessageType.MessageTypeId.Withdraw),\n            channel_identifier,\n            participant,\n            total_withdraw,\n            expiration_block\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n    }\n\n    function getMaxPossibleReceivableAmount(\n        uint256 participant1_deposit,\n        uint256 participant1_withdrawn,\n        uint256 participant1_transferred,\n        uint256 participant1_locked,\n        uint256 participant2_transferred,\n        uint256 participant2_locked\n    )\n        public\n        pure\n        returns (uint256)\n    {\n        uint256 participant1_max_transferred;\n        uint256 participant2_max_transferred;\n        uint256 participant1_net_max_received;\n        uint256 participant1_max_amount;\n\n        // This is the maximum possible amount that participant1 could transfer\n        // to participant2, if all the pending lock secrets have been\n        // registered\n        participant1_max_transferred = failsafe_addition(\n            participant1_transferred,\n            participant1_locked\n        );\n\n        // This is the maximum possible amount that participant2 could transfer\n        // to participant1, if all the pending lock secrets have been\n        // registered\n        participant2_max_transferred = failsafe_addition(\n            participant2_transferred,\n            participant2_locked\n        );\n\n        // We enforce this check artificially, in order to get rid of hard\n        // to deal with over/underflows. Settlement balance calculation is\n        // symmetric (we can calculate either RmaxP1 and RmaxP2 first, order does\n        // not affect result). This means settleChannel must be called with\n        // ordered values.\n        require(participant2_max_transferred >= participant1_max_transferred, \"TN: transfers not ordered\");\n\n        assert(participant1_max_transferred >= participant1_transferred);\n        assert(participant2_max_transferred >= participant2_transferred);\n\n        // This is the maximum amount that participant1 can receive at settlement time\n        participant1_net_max_received = (\n            participant2_max_transferred -\n            participant1_max_transferred\n        );\n\n        // Next, we add the participant1's deposit and subtract the already\n        // withdrawn amount\n        participant1_max_amount = failsafe_addition(\n            participant1_net_max_received,\n            participant1_deposit\n        );\n\n        // Subtract already withdrawn amount\n        (participant1_max_amount, ) = failsafe_subtract(\n            participant1_max_amount,\n            participant1_withdrawn\n        );\n        return participant1_max_amount;\n    }\n\n    /// @notice Removes the balance limits.\n    /// Can only be called by the controller.\n    function removeLimits()\n        external\n        onlyController\n    {\n        channel_participant_deposit_limit = MAX_SAFE_UINT256;\n        token_network_deposit_limit = MAX_SAFE_UINT256;\n    }\n\n    /// @notice For backwards compatibility and testing only\n    /// This can probably be removed once https://github.com/ethereum/web3.py/issues/1677 is fixed.\n    function chain_id()\n        external\n        returns (uint256)\n    {\n        return block.chainid;\n    }\n}\n\n/// @title TokenNetworkRegistry\n/// @notice The TokenNetwork Registry deploys new TokenNetwork contracts for the\n/// Raiden Network protocol.\ncontract TokenNetworkRegistry is Utils, Controllable {\n    address public secret_registry_address;\n    uint256 public settlement_timeout_min;\n    uint256 public settlement_timeout_max;\n    uint256 public max_token_networks;\n\n    // Only for the limited Red Eyes release\n    uint256 public token_network_created = 0;\n\n    // Token address => TokenNetwork address\n    mapping(address => address) public token_to_token_networks;\n\n    event TokenNetworkCreated(address indexed token_address, address indexed token_network_address);\n\n    modifier canCreateTokenNetwork() {\n        require(token_network_created < max_token_networks, \"TNR: registry full\");\n        _;\n    }\n\n    /// @param _secret_registry_address The address of SecretRegistry that's used by all\n    /// TokenNetworks created by this contract\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _max_token_networks the number of tokens that can be registered\n    /// MAX_UINT256 means no limits\n    constructor(\n        address _secret_registry_address,\n        uint256 _settlement_timeout_min,\n        uint256 _settlement_timeout_max,\n        uint256 _max_token_networks\n    ) {\n        require(_settlement_timeout_min > 0, \"TNR: invalid settle timeout min\");\n        require(_settlement_timeout_max > 0, \"TNR: invalid settle timeout max\");\n        require(_settlement_timeout_max > _settlement_timeout_min, \"TNR: invalid settle timeouts\");\n        require(_secret_registry_address != address(0x0), \"TNR: invalid SR address\");\n        require(contractExists(_secret_registry_address), \"TNR: invalid SR\");\n        require(_max_token_networks > 0, \"TNR: invalid TN limit\");\n        secret_registry_address = _secret_registry_address;\n        settlement_timeout_min = _settlement_timeout_min;\n        settlement_timeout_max = _settlement_timeout_max;\n        max_token_networks = _max_token_networks;\n\n        controller = msg.sender;\n    }\n\n    /// @notice Deploy a new TokenNetwork contract for the Token deployed at\n    /// `_token_address`\n    /// @param _token_address Ethereum address of an already deployed token, to\n    /// be used in the new TokenNetwork contract\n    function createERC20TokenNetwork(\n        address _token_address,\n        uint256 _channel_participant_deposit_limit,\n        uint256 _token_network_deposit_limit\n    )\n        public\n        canCreateTokenNetwork\n        returns (address token_network_address)\n    {\n        // After the limits have been removed, new token networks must be created without limits\n        // See https://github.com/raiden-network/raiden-contracts/issues/1416\n        if (max_token_networks == MAX_SAFE_UINT256) {\n            require(_channel_participant_deposit_limit == MAX_SAFE_UINT256, \"TNR: limits must be set to MAX_INT\");\n            require(_token_network_deposit_limit == MAX_SAFE_UINT256, \"TNR: limits must be set to MAX_INT\");\n        }\n\n        require(token_to_token_networks[_token_address] == address(0x0), \"TNR: token already registered\");\n\n        // We limit the number of token networks to 1 for the Bug Bounty release\n        token_network_created = token_network_created + 1;\n\n        TokenNetwork token_network;\n\n        // Token contract checks are in the corresponding TokenNetwork contract\n        token_network = new TokenNetwork(\n            _token_address,\n            secret_registry_address,\n            settlement_timeout_min,\n            settlement_timeout_max,\n            controller,\n            _channel_participant_deposit_limit,\n            _token_network_deposit_limit\n        );\n\n        token_network_address = address(token_network);\n\n        token_to_token_networks[_token_address] = token_network_address;\n        emit TokenNetworkCreated(_token_address, token_network_address);\n\n        return token_network_address;\n    }\n\n    function createERC20TokenNetworkWithoutLimits(\n        address _token_address\n    )\n        external\n        returns (address token_network_address)\n    {\n        return createERC20TokenNetwork(_token_address, MAX_SAFE_UINT256, MAX_SAFE_UINT256);\n    }\n\n    /// @notice Removes the limit on the number of token networks.\n    /// Can only be called by the controller.\n    function removeLimits()\n        external\n        onlyController\n    {\n        max_token_networks = MAX_SAFE_UINT256;\n    }\n}\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_secret_registry_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_settlement_timeout_min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_settlement_timeout_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_token_networks\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"}],\"name\":\"TokenNetworkCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"contractExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_channel_participant_deposit_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token_network_deposit_limit\",\"type\":\"uint256\"}],\"name\":\"createERC20TokenNetwork\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"}],\"name\":\"createERC20TokenNetworkWithoutLimits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"failsafe_addition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"failsafe_subtract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_token_networks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secret_registry_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlement_timeout_max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlement_timeout_min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signature_prefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_network_created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token_to_token_networks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenNetworkRegistry","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000070f0c29b946e63803bd0be796e17e47138668a68000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000002","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}