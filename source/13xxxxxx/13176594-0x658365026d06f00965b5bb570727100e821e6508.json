{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/farm/AGLDFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\nimport '@solidstate/contracts/token/ERC20/IERC20.sol';\\nimport '@solidstate/contracts/utils/SafeERC20.sol';\\n\\nimport '../token/IMagic.sol';\\n\\ncontract AGLDFarm {\\n    using SafeERC20 for IERC20;\\n\\n    address private immutable MAGIC;\\n    address private immutable ADVENTURE_GOLD;\\n    uint256 public immutable EXPIRATION;\\n    uint256 private immutable RATE;\\n\\n    mapping(address => uint256) public depositBalances;\\n    mapping(address => uint256) public depositBlocks;\\n\\n    constructor(\\n        address magic,\\n        address adventureGold,\\n        uint256 rate,\\n        uint256 expiration\\n    ) {\\n        MAGIC = magic;\\n        ADVENTURE_GOLD = adventureGold;\\n        RATE = rate;\\n        EXPIRATION = block.number + expiration;\\n    }\\n\\n    function calculateRewards(address account)\\n        public\\n        view\\n        returns (uint256 reward)\\n    {\\n        reward =\\n            (RATE *\\n                depositBalances[account] *\\n                (Math.min(block.number, EXPIRATION) - depositBlocks[account])) /\\n            (1 ether);\\n    }\\n\\n    function claimRewards() public {\\n        uint256 reward = calculateRewards(msg.sender);\\n\\n        if (reward > 0) {\\n            IMagic(MAGIC).mint(msg.sender, reward);\\n        }\\n\\n        depositBlocks[msg.sender] = Math.min(block.number, EXPIRATION);\\n    }\\n\\n    function deposit(uint256 amount) external {\\n        require(\\n            IERC20(ADVENTURE_GOLD).balanceOf(address(this)) + amount <=\\n                50e6 ether,\\n            'AGLDFarm: deposit cap reached'\\n        );\\n        claimRewards();\\n        IERC20(ADVENTURE_GOLD).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n        depositBalances[msg.sender] += amount;\\n    }\\n\\n    function withdraw(uint256 amount) external {\\n        require(\\n            depositBalances[msg.sender] >= amount,\\n            'AGLDFarm: insufficient balance'\\n        );\\n\\n        claimRewards();\\n\\n        unchecked {\\n            depositBalances[msg.sender] -= amount;\\n        }\\n\\n        IERC20(ADVENTURE_GOLD).safeTransfer(msg.sender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Internal} from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n  /**\\n   * @notice query the total minted token supply\\n   * @return token supply\\n   */\\n  function totalSupply () external view returns (uint256);\\n\\n  /**\\n   * @notice query the token balance of given account\\n   * @param account address to query\\n   * @return token balance\\n   */\\n  function balanceOf (\\n    address account\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice query the allowance granted from given holder to given spender\\n   * @param holder approver of allowance\\n   * @param spender recipient of allowance\\n   * @return token allowance\\n   */\\n  function allowance (\\n    address holder,\\n    address spender\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice grant approval to spender to spend tokens\\n   * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n   * @param spender recipient of allowance\\n   * @param amount quantity of tokens approved for spending\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function approve (\\n    address spender,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transfer (\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient on behalf of given holder\\n   * @param holder holder of tokens prior to transfer\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transferFrom (\\n    address holder,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '../token/ERC20/IERC20.sol';\\nimport {AddressUtils} from './AddressUtils.sol';\\n\\n/**\\n * @title Safe ERC20 interaction library\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @notice send transaction data and check validity of return value, if present\\n     * @param token ERC20 token interface\\n     * @param data transaction data\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/IMagic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@solidstate/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IMagic is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n  function toString (address account) internal pure returns (string memory) {\\n    bytes32 value = bytes32(uint256(uint160(account)));\\n    bytes memory alphabet = '0123456789abcdef';\\n    bytes memory chars = new bytes(42);\\n\\n    chars[0] = '0';\\n    chars[1] = 'x';\\n\\n    for (uint256 i = 0; i < 20; i++) {\\n      chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n      chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n    }\\n\\n    return string(chars);\\n  }\\n\\n  function isContract (address account) internal view returns (bool) {\\n    uint size;\\n    assembly { size := extcodesize(account) }\\n    return size > 0;\\n  }\\n\\n  function sendValue (address payable account, uint amount) internal {\\n    (bool success, ) = account.call{ value: amount }('');\\n    require(success, 'AddressUtils: failed to send value');\\n  }\\n\\n  function functionCall (address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, 'AddressUtils: failed low-level call');\\n  }\\n\\n  function functionCall (address target, bytes memory data, string memory error) internal returns (bytes memory) {\\n    return _functionCallWithValue(target, data, 0, error);\\n  }\\n\\n  function functionCallWithValue (address target, bytes memory data, uint value) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, 'AddressUtils: failed low-level call with value');\\n  }\\n\\n  function functionCallWithValue (address target, bytes memory data, uint value, string memory error) internal returns (bytes memory) {\\n    require(address(this).balance >= value, 'AddressUtils: insufficient balance for call');\\n    return _functionCallWithValue(target, data, value, error);\\n  }\\n\\n  function _functionCallWithValue (address target, bytes memory data, uint value, string memory error) private returns (bytes memory) {\\n    require(isContract(target), 'AddressUtils: function call to non-contract');\\n\\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\\n\\n    if (success) {\\n      return returnData;\\n    } else if (returnData.length > 0) {\\n      assembly {\\n        let returnData_size := mload(returnData)\\n        revert(add(32, returnData), returnData_size)\\n      }\\n    } else {\\n      revert(error);\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"magic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adventureGold\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EXPIRATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AGLDFarm","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b0c7a3ba49c7a6eaba6cd4a96c55a1391070ac9a00000000000000000000000032353a6c91143bfd6c7d363b546e62a9a2489a2000000000000000000000000000000000000000000000000000000f2882bf0aaa000000000000000000000000000000000000000000000000000000000002bf20","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}