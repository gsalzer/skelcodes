{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"oracles/OraclePoolToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\nimport \\\"../helpers/SafeMath.sol\\\";\\nimport \\\"../helpers/IUniswapV2PairFull.sol\\\";\\nimport \\\"../interfaces/IOracleEth.sol\\\";\\nimport \\\"../interfaces/IOracleUsd.sol\\\";\\nimport \\\"../interfaces/IOracleRegistry.sol\\\";\\nimport \\\"../interfaces/IToken.sol\\\";\\n\\n\\n/**\\n * @title OraclePoolToken\\n * @dev Calculates the USD price of Uniswap LP tokens\\n **/\\ncontract OraclePoolToken is IOracleUsd {\\n    using SafeMath for uint;\\n\\n    IOracleRegistry public immutable oracleRegistry;\\n\\n    address public immutable WETH;\\n\\n    uint public immutable Q112 = 2 ** 112;\\n\\n    constructor(address _oracleRegistry) {\\n        oracleRegistry = IOracleRegistry(_oracleRegistry);\\n        WETH = IOracleRegistry(_oracleRegistry).WETH();\\n    }\\n\\n    /**\\n     * @notice Flashloan-resistant logic to determine USD price of Uniswap LP tokens\\n     * @notice Pair must be registered at Chainlink\\n     * @param asset The LP token address\\n     * @param amount Amount of asset\\n     * @return Q112 encoded price of asset in USD\\n     **/\\n    function assetToUsd(\\n        address asset,\\n        uint amount\\n    )\\n        public\\n        override\\n        view\\n        returns (uint)\\n    {\\n        IUniswapV2PairFull pair = IUniswapV2PairFull(asset);\\n        address underlyingAsset;\\n        if (pair.token0() == WETH) {\\n            underlyingAsset = pair.token1();\\n        } else if (pair.token1() == WETH) {\\n            underlyingAsset = pair.token0();\\n        } else {\\n            revert(\\\"Unit Protocol: NOT_REGISTERED_PAIR\\\");\\n        }\\n\\n        address oracle = oracleRegistry.oracleByAsset(underlyingAsset);\\n        require(oracle != address(0), \\\"Unit Protocol: ORACLE_NOT_FOUND\\\");\\n\\n        uint eAvg;\\n\\n        { // fix stack too deep\\n          uint assetPrecision = 10 ** IToken(underlyingAsset).decimals();\\n\\n          uint usdValue_q112 = IOracleUsd(oracle).assetToUsd(underlyingAsset, assetPrecision) / assetPrecision;\\n          // average price of 1 token unit in ETH\\n          eAvg = IOracleEth(oracleRegistry.oracleByAsset(WETH)).usdToEth(usdValue_q112);\\n        }\\n\\n        (uint112 _reserve0, uint112 _reserve1,) = pair.getReserves();\\n        uint aPool; // current asset pool\\n        uint ePool; // current WETH pool\\n        if (pair.token0() == underlyingAsset) {\\n            aPool = uint(_reserve0);\\n            ePool = uint(_reserve1);\\n        } else {\\n            aPool = uint(_reserve1);\\n            ePool = uint(_reserve0);\\n        }\\n\\n        uint eCurr = ePool.mul(Q112).div(aPool); // current price of 1 token in WETH\\n        uint ePoolCalc; // calculated WETH pool\\n\\n        if (eCurr < eAvg) {\\n            // flashloan buying WETH\\n            uint sqrtd = ePool.mul((ePool).mul(9).add(\\n                aPool.mul(3988000).mul(eAvg).div(Q112)\\n            ));\\n            uint eChange = sqrt(sqrtd).sub(ePool.mul(1997)).div(2000);\\n            ePoolCalc = ePool.add(eChange);\\n        } else {\\n            // flashloan selling WETH\\n            uint a = aPool.mul(eAvg);\\n            uint b = a.mul(9).div(Q112);\\n            uint c = ePool.mul(3988000);\\n            uint sqRoot = sqrt(a.div(Q112).mul(b.add(c)));\\n            uint d = a.mul(3).div(Q112);\\n            uint eChange = ePool.sub(d.add(sqRoot).div(2000));\\n            ePoolCalc = ePool.sub(eChange);\\n        }\\n\\n        uint num = ePoolCalc.mul(2).mul(amount);\\n        uint priceInEth;\\n        if (num > Q112) {\\n            priceInEth = num.div(pair.totalSupply()).mul(Q112);\\n        } else {\\n            priceInEth = num.mul(Q112).div(pair.totalSupply());\\n        }\\n\\n        return IOracleEth(oracleRegistry.oracleByAsset(WETH)).ethToUsd(priceInEth);\\n    }\\n\\n    function sqrt(uint x) internal pure returns (uint y) {\\n        if (x > 3) {\\n            uint z = x / 2 + 1;\\n            y = x;\\n            while (z < y) {\\n                y = z;\\n                z = (x / z + z) / 2;\\n            }\\n        } else if (x != 0) {\\n            y = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.6;\\n\\ninterface IToken {\\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"interfaces/IOracleRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface IOracleRegistry {\\n\\n    struct Oracle {\\n        uint oracleType;\\n        address oracleAddress;\\n    }\\n\\n    function WETH (  ) external view returns ( address );\\n    function getKeydonixOracleTypes (  ) external view returns ( uint256[] memory );\\n    function getOracles (  ) external view returns ( Oracle[] memory foundOracles );\\n    function keydonixOracleTypes ( uint256 ) external view returns ( uint256 );\\n    function maxOracleType (  ) external view returns ( uint256 );\\n    function oracleByAsset ( address asset ) external view returns ( address );\\n    function oracleByType ( uint256 ) external view returns ( address );\\n    function oracleTypeByAsset ( address ) external view returns ( uint256 );\\n    function oracleTypeByOracle ( address ) external view returns ( uint256 );\\n    function setKeydonixOracleTypes ( uint256[] memory _keydonixOracleTypes ) external;\\n    function setOracle ( uint256 oracleType, address oracle ) external;\\n    function setOracleTypeForAsset ( address asset, uint256 oracleType ) external;\\n    function setOracleTypeForAssets ( address[] memory assets, uint256 oracleType ) external;\\n    function unsetOracle ( uint256 oracleType ) external;\\n    function unsetOracleForAsset ( address asset ) external;\\n    function unsetOracleForAssets ( address[] memory assets ) external;\\n    function vaultParameters (  ) external view returns ( address );\\n}\\n\"\r\n    },\r\n    \"interfaces/IOracleUsd.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.6;\\n\\ninterface IOracleUsd {\\n\\n    // returns Q112-encoded value\\n    // returned value 10**18 * 2**112 is $1\\n    function assetToUsd(address asset, uint amount) external view returns (uint);\\n}\"\r\n    },\r\n    \"interfaces/IOracleEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.6;\\n\\ninterface IOracleEth {\\n\\n    // returns Q112-encoded value\\n    // returned value 10**18 * 2**112 is 1 Ether\\n    function assetToEth(address asset, uint amount) external view returns (uint);\\n\\n    // returns the value \\\"as is\\\"\\n    function ethToUsd(uint amount) external view returns (uint);\\n\\n    // returns the value \\\"as is\\\"\\n    function usdToEth(uint amount) external view returns (uint);\\n}\"\r\n    },\r\n    \"helpers/IUniswapV2PairFull.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\ninterface IUniswapV2PairFull {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"helpers/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Q112\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"assetToUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleRegistry\",\"outputs\":[{\"internalType\":\"contract IOracleRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OraclePoolToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000075fbfe26b21fd3ea008af0c764949f8214150c8f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}