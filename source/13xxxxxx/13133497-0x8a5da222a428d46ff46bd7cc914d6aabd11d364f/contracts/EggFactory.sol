// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
/**                                                                        
                                        ████████                                  
                                      ██        ██                                
                                    ██▒▒▒▒        ██                              
                                  ██▒▒▒▒▒▒      ▒▒▒▒██                            
                                  ██▒▒▒▒▒▒      ▒▒▒▒██                            
                                ██  ▒▒▒▒        ▒▒▒▒▒▒██                          
                                ██                ▒▒▒▒██                          
                              ██▒▒      ▒▒▒▒▒▒          ██                        
                              ██      ▒▒▒▒▒▒▒▒▒▒        ██                        
                              ██      ▒▒▒▒▒▒▒▒▒▒    ▒▒▒▒██                        
                              ██▒▒▒▒  ▒▒▒▒▒▒▒▒▒▒  ▒▒▒▒▒▒██                        
                                ██▒▒▒▒  ▒▒▒▒▒▒    ▒▒▒▒██                          
                                ██▒▒▒▒            ▒▒▒▒██                          
                                  ██▒▒              ██                            
                                    ████        ████                              
                                        ████████                    

                     ____                          ____  _      _         
                    |  _ \  ___ _ __ _ __  _   _  | __ )(_)_ __| |__  ___ 
                    | | | |/ _ \ '__| '_ \| | | | |  _ \| | '__| '_ \/ __|
                    | |_| |  __/ |  | |_) | |_| | | |_) | | |  | |_) \__ \
                    |____/ \___|_|  | .__/ \__, | |____/|_|_|  |_.__/|___/
                                    |_|    |___/                          
         _   _           _      ____                           _   _                 
        | \ | | _____  _| |_   / ___| ___ _ __   ___ _ __ __ _| |_(_) ___  _ __  ___ 
        |  \| |/ _ \ \/ / __| | |  _ / _ \ '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
        | |\  |  __/>  <| |_  | |_| |  __/ | | |  __/ | | (_| | |_| | (_) | | | \__ \
        |_| \_|\___/_/\_\\__|  \____|\___|_| |_|\___|_|  \__,_|\__|_|\___/|_| |_|___/

 */
contract DerpyBirbsNewGen is Context, ERC721Enumerable, ERC721Burnable, Ownable {
    uint internal constant MAX_MATING_TIMES = 1;

    mapping(uint => uint) internal timesMated;
    mapping(uint => uint[2]) internal parents;

    uint[] internal genIntervals = [8192, 12288, 14336, 15360, 15872, 16128, 16256, 16320, 16352, 16368, 16376, 16380, 16382, 16383];
    uint[] internal genIndexes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    uint internal currentGen = 0;

    address internal genOneAddress;

    string internal _baseTokenURI;
    
    bool internal URISet = false;

    /**
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(string memory name, string memory symbol, address _genOneAddress) ERC721(name, symbol) {
        genOneAddress = _genOneAddress;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    event Mating(uint firstPartner,uint secondPartner,uint id);

    function firstGenMultiMate(uint [] memory partners) external {
        require(partners.length <= 32,"Can't mate more than 32 Birbs at once");
        require(partners.length % 2 == 0,"Must be an even numbers of Birbs");
        require(partners.length >= 2,"Must provide at least 2 Birbs");

        uint i;
        for(i = 0; i < partners.length; i++){
            require(partners[i] <= 8192,"This function is for Gen 1 Birbs only");
            require(IERC721(genOneAddress).ownerOf(partners[i]) == _msgSender(), "You dont own all the partners");  
            require(timesMated[partners[i]] < MAX_MATING_TIMES, "One of the partners has mated too many times");
            timesMated[partners[i]] = timesMated[partners[i]] + 1;
        }

        uint id;
        for(i = 0; i < partners.length; i = i + 2){
            require(partners[i] != partners[i+1],"You are trying to mate a Birb with himself");

            id = genIntervals[0]+genIndexes[0] + 1;
            _mint(_msgSender(), id);
            
            parents[id] = [partners[i],partners[i+1]];
            genIndexes[0] = genIndexes[0] + 1;

            emit Mating(partners[i],partners[i+1],id);
        }
    }

    function nextGensMultimate(uint [] memory partners) external {
        require(partners.length <= 32,"Can't mate more than 32 Birbs at once");
        require(partners.length % 2 == 0,"Must be an even numbers of Birbs");
        require(partners.length >= 2,"Must provide at least 2 Birbs");

        uint i;
        for(i = 0; i < partners.length; i++){
            require(partners[i] <= 16383,"That Birb does not exist");
            require(partners[i] > 8192,"This function is for gen 2 or higher");
            require(ownerOf(partners[i]) == _msgSender(), "You dont own all the partners");  
            require(timesMated[partners[i]] < MAX_MATING_TIMES, "One of the partners has mated too many times");
            timesMated[partners[i]] = timesMated[partners[i]] + 1;
        }

        uint j;
        uint id;
        for(i = 0; i < partners.length; i = i + 2){
            require(partners[i] != partners[i+1],"You are trying to mate a Birb with himself");

            for(j = 0; partners[i] > genIntervals[j]; j++){}
            require(currentGen >= j,"Mating is not enabled for this gen");

            require(partners[i+1] <= genIntervals[j],"Cross gen breeding: Birb from a next gen");
            require(partners[i+1] > genIntervals[j-1],"Cross gen breeding: Birb from a previous gen");

            id = genIntervals[j] + genIndexes[j] + 1;

            _mint(_msgSender(), id);

            parents[id] = [partners[i],partners[i+1]];
            genIndexes[j] = genIndexes[j] + 1;
            
            emit Mating(partners[i],partners[i+1],id);
        }
    }

    function setBaseURI(string memory baseTokenURI) external onlyOwner{
        require(URISet == false);
        _baseTokenURI = baseTokenURI;
    }

    /**
    * Makes metadata URI permanent
    */
    function sealURI() external onlyOwner{
        require(URISet == false);
        URISet = true;
    }

    function goToNextGen() external onlyOwner{
        require(currentGen < 13);
        currentGen = currentGen + 1;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function getTimesMated(uint birbID) external view returns (uint256) {
        return timesMated[birbID];
    }

    function getParents(uint birbID) external view returns (uint256 [2] memory) {
        return parents[birbID];
    }

    function getBirbsInGen(uint gen) external view returns (uint){
        return genIndexes[gen];
    }

    function getCurrentGen() external view returns (uint){
        return currentGen;
    }
}

