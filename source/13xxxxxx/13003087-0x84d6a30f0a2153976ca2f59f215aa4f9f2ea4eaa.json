{"status":"1","message":"OK","result":[{"SourceCode":"// File: iface/IParassetGovernance.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @dev This interface defines the governance methods\r\ninterface IParassetGovernance {\r\n    /// @dev Set governance authority\r\n    /// @param addr Destination address\r\n    /// @param flag Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function setGovernance(address addr, uint flag) external;\r\n\r\n    /// @dev Get governance rights\r\n    /// @param addr Destination address\r\n    /// @return Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function getGovernance(address addr) external view returns (uint);\r\n\r\n    /// @dev Check whether the target address has governance rights for the given target\r\n    /// @param addr Destination address\r\n    /// @param flag Permission weight. The permission of the target address must be greater than this weight to pass the check\r\n    /// @return True indicates permission\r\n    function checkGovernance(address addr, uint flag) external view returns (bool);\r\n}\r\n// File: ParassetBase.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract ParassetBase {\r\n\r\n    // Lock flag\r\n    uint256 _locked;\r\n\r\n\t/// @dev To support open-zeppelin/upgrades\r\n    /// @param governance IParassetGovernance implementation contract address\r\n    function initialize(address governance) public virtual {\r\n        require(_governance == address(0), \"Log:ParassetBase!initialize\");\r\n        _governance = governance;\r\n        _locked = 0;\r\n    }\r\n\r\n    /// @dev IParassetGovernance implementation contract address\r\n    address public _governance;\r\n\r\n    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \r\n    ///      super.update(newGovernance) when overriding, and override method without onlyGovernance\r\n    /// @param newGovernance IParassetGovernance implementation contract address\r\n    function update(address newGovernance) public virtual {\r\n\r\n        address governance = _governance;\r\n        require(governance == msg.sender || IParassetGovernance(governance).checkGovernance(msg.sender, 0), \"Log:ParassetBase:!gov\");\r\n        _governance = newGovernance;\r\n    }\r\n\r\n    /// @dev Uniform accuracy\r\n    /// @param inputToken Initial token\r\n    /// @param inputTokenAmount Amount of token\r\n    /// @param outputToken Converted token\r\n    /// @return stability Amount of outputToken\r\n    function getDecimalConversion(\r\n        address inputToken, \r\n        uint256 inputTokenAmount, \r\n        address outputToken\r\n    ) public view returns(uint256) {\r\n    \tuint256 inputTokenDec = 18;\r\n    \tuint256 outputTokenDec = 18;\r\n    \tif (inputToken != address(0x0)) {\r\n    \t\tinputTokenDec = IERC20(inputToken).decimals();\r\n    \t}\r\n    \tif (outputToken != address(0x0)) {\r\n    \t\toutputTokenDec = IERC20(outputToken).decimals();\r\n    \t}\r\n    \treturn inputTokenAmount * (10**outputTokenDec) / (10**inputTokenDec);\r\n    }\r\n\r\n    //---------modifier------------\r\n\r\n    modifier onlyGovernance() {\r\n        require(IParassetGovernance(_governance).checkGovernance(msg.sender, 0), \"Log:ParassetBase:!gov\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_locked == 0, \"Log:ParassetBase:!_locked\");\r\n        _locked = 1;\r\n        _;\r\n        _locked = 0;\r\n    }\r\n}\r\n// File: iface/IERC20.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: iface/ILPStakingMiningPool.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface ILPStakingMiningPool {\r\n\tfunction getBlock(uint256 endBlock) external view returns(uint256);\r\n\tfunction getBalance(address stakingToken, address account) external view returns(uint256);\r\n\tfunction getChannelInfo(address stakingToken) external view returns(uint256 lastUpdateBlock, uint256 endBlock, uint256 rewardRate, uint256 rewardPerTokenStored, uint256 totalSupply);\r\n\tfunction getAccountReward(address stakingToken, address account) external view returns(uint256);\r\n\tfunction stake(uint256 amount, address stakingToken) external;\r\n\tfunction withdraw(uint256 amount, address stakingToken) external;\r\n\tfunction getReward(address stakingToken) external;\r\n}\r\n// File: lib/TransferHelper.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n// File: LPStakingMiningPool.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract LPStakingMiningPool is ParassetBase, ILPStakingMiningPool {\r\n\r\n\t// ASET\r\n    address public _rewardsToken;\r\n    \r\n    // token => channel info\r\n    mapping(address => Channel) _tokenChannel;\r\n    struct Channel {\r\n        // recently operated block\r\n        // limit4294967295\r\n        uint32 lastUpdateBlock;\r\n        // end block\r\n        // limit4294967295\r\n        uint32 endBlock;\r\n        // revenue efficiency\r\n        uint192 rewardRate;\r\n        // profit per share\r\n        uint256 rewardPerTokenStored;\r\n        // total locked position\r\n        uint256 totalSupply;\r\n        // user address => Account info\r\n        mapping(address => Account) accounts;\r\n    }\r\n\r\n    struct Account {\r\n        // locked position\r\n        uint256 balance;\r\n        // latest profit per share\r\n        uint256 userRewardPerTokenPaid;\r\n    }\r\n\r\n    //---------view---------\r\n\r\n    /// @dev Get the endBlock\r\n    /// @param endBlock block number at the end of this mining cycle\r\n    /// @return actual ending block number\r\n    function getBlock(uint256 endBlock) public view override returns(uint256) {\r\n        uint256 nowBlock = block.number;\r\n        if (nowBlock > endBlock) {\r\n            return endBlock;\r\n        }\r\n        return nowBlock;\r\n    }\r\n    \r\n    /// @dev Get the amount of locked funds\r\n    /// @param stakingToken staking token address\r\n    /// @param account user address\r\n    /// @return the amount of locked staked token\r\n    function getBalance(\r\n        address stakingToken, \r\n        address account\r\n    ) external view override returns(uint256) {\r\n        return _tokenChannel[stakingToken].accounts[account].balance;\r\n    }\r\n\r\n    /// @dev Get the lock channel information\r\n    /// @param stakingToken staking token address\r\n    /// @return lastUpdateBlock the height of the recently operated block\r\n    /// @return endBlock mining end block\r\n    /// @return rewardRate mining efficiency per block\r\n    /// @return rewardPerTokenStored receivable mine per share\r\n    /// @return totalSupply total locked position\r\n    function getChannelInfo(\r\n        address stakingToken\r\n    ) external view override returns (\r\n        uint256 lastUpdateBlock, \r\n        uint256 endBlock, \r\n        uint256 rewardRate, \r\n        uint256 rewardPerTokenStored, \r\n        uint256 totalSupply\r\n    ) {\r\n        Channel storage channelInfo = _tokenChannel[stakingToken];\r\n        return (channelInfo.lastUpdateBlock, \r\n                channelInfo.endBlock, \r\n                channelInfo.rewardRate, \r\n                channelInfo.rewardPerTokenStored, \r\n                channelInfo.totalSupply);\r\n    }\r\n\r\n    /// @dev Get the estimated number of receivables\r\n    /// @param stakingToken staking token address\r\n    /// @param account user address\r\n    /// @return the estimated number of receivables\r\n    function getAccountReward(\r\n        address stakingToken, \r\n        address account\r\n    ) external view override returns(uint256) {\r\n        Channel storage channelInfo = _tokenChannel[stakingToken];\r\n        (,,uint256 userReward) = _calcReward(channelInfo, account);\r\n        return userReward;\r\n    }\r\n\r\n    /// @dev Get the account data\r\n    /// @param stakingToken staking token address\r\n    /// @param account user address\r\n    /// @return balance the amount of locked staked token\r\n    /// @return userRewardPerTokenPaid receivable mine per share\r\n    function getAccountInfo(\r\n        address stakingToken, \r\n        address account\r\n    ) external view returns(\r\n        uint256 balance, \r\n        uint256 userRewardPerTokenPaid\r\n    ) {\r\n        Account memory accountInfo = _tokenChannel[stakingToken].accounts[account];\r\n        return (accountInfo.balance, accountInfo.userRewardPerTokenPaid);\r\n    }\r\n\r\n    function _calcReward(\r\n        Channel storage channelInfo,\r\n        address account\r\n    ) private view returns(\r\n        uint32 _nowBlock, \r\n        uint256 _rewardPerTokenStored, \r\n        uint256 _userReward\r\n    ) {\r\n        uint256 nowBlock = getBlock(channelInfo.endBlock);\r\n        uint256 totalSupply = channelInfo.totalSupply;\r\n        uint256 rewardPerTokenStored = channelInfo.rewardPerTokenStored;\r\n        uint256 lastUpdateBlock = channelInfo.lastUpdateBlock;\r\n        uint256 accrued = (lastUpdateBlock == 0 ? 0 : (nowBlock - lastUpdateBlock) * channelInfo.rewardRate);\r\n\r\n        _nowBlock = uint32(nowBlock);\r\n        _rewardPerTokenStored = (totalSupply == 0 ? \r\n                                rewardPerTokenStored : \r\n                                (rewardPerTokenStored + accrued * 1e18 / totalSupply));\r\n        _userReward = channelInfo.accounts[account].balance\r\n                      * (_rewardPerTokenStored \r\n                      - channelInfo.accounts[account].userRewardPerTokenPaid)\r\n                      / 1e18;\r\n    }\r\n\r\n    //---------governance----------\r\n\r\n    /// @dev Set up mining token\r\n    function setRewardsToken(address add) external onlyGovernance {\r\n        _rewardsToken = add;\r\n    }\r\n\r\n    /// @dev Increase mining token (open mining)\r\n    /// @param tokenAmount increase the number of token\r\n    /// @param from mining token transfer address\r\n    /// @param rewardRate mining efficiency per block\r\n    /// @param stakingToken staking token address\r\n    function addToken(\r\n        uint256 tokenAmount, \r\n        address from, \r\n        uint96 rewardRate, \r\n        address stakingToken\r\n    ) external onlyGovernance {\r\n    \tTransferHelper.safeTransferFrom(_rewardsToken, from, address(this), tokenAmount);\r\n        Channel storage channelInfo = _tokenChannel[stakingToken];\r\n    \tchannelInfo.lastUpdateBlock = uint32(block.number);\r\n        channelInfo.rewardRate = rewardRate;\r\n    \tchannelInfo.endBlock = uint32(tokenAmount / rewardRate + block.number);\r\n    }\r\n\r\n    /// @dev Set the lock channel information\r\n    /// @param lastUpdateBlock the height of the recently operated block\r\n    /// @param endBlock mining end block\r\n    /// @param rewardRate mining efficiency per block\r\n    /// @param stakingToken staking token address\r\n    function setChannelInfo(\r\n        uint32 lastUpdateBlock, \r\n        uint32 endBlock, \r\n        uint96 rewardRate,\r\n        address stakingToken\r\n    ) external onlyGovernance {\r\n        Channel storage channelInfo = _tokenChannel[stakingToken];\r\n        // settlement\r\n        (, uint256 rewardPerTokenStored,) = _calcReward(channelInfo, address(this));\r\n        channelInfo.rewardPerTokenStored = rewardPerTokenStored;\r\n        // update\r\n        channelInfo.lastUpdateBlock = lastUpdateBlock;\r\n        channelInfo.endBlock = endBlock;\r\n        channelInfo.rewardRate = rewardRate;\r\n    }\r\n\r\n    //---------transaction---------\r\n\r\n    /// @dev Stake\r\n    /// @param amount amount of stake token\r\n    /// @param stakingToken staking token address\r\n    function stake(uint256 amount, address stakingToken) external override nonReentrant {\r\n        require(amount > 0, \"Log:LPStakingMiningPool:!0\");\r\n\r\n        Channel storage channelInfo = _tokenChannel[stakingToken];\r\n        _getReward(channelInfo, msg.sender);\r\n\r\n        TransferHelper.safeTransferFrom(stakingToken, msg.sender, address(this), amount);\r\n\r\n    \tchannelInfo.totalSupply = channelInfo.totalSupply + amount;\r\n        channelInfo.accounts[msg.sender].balance = channelInfo.accounts[msg.sender].balance + amount;\r\n    }\r\n\r\n    /// @dev Withdraw\r\n    /// @param amount amount of stake token\r\n    /// @param stakingToken staking token address\r\n    function withdraw(uint256 amount, address stakingToken) external override nonReentrant {\r\n        require(amount > 0, \"Log:LPStakingMiningPool:!0\");\r\n\r\n        Channel storage channelInfo = _tokenChannel[stakingToken];\r\n        _getReward(channelInfo, msg.sender);\r\n\r\n        channelInfo.totalSupply = channelInfo.totalSupply - amount;\r\n        channelInfo.accounts[msg.sender].balance = channelInfo.accounts[msg.sender].balance - amount;\r\n\r\n    \tTransferHelper.safeTransfer(stakingToken, msg.sender, amount);\r\n    }\r\n\r\n    /// @dev Receive income\r\n    /// @param stakingToken staking token address\r\n    function getReward(address stakingToken) external override nonReentrant {\r\n        Channel storage channelInfo = _tokenChannel[stakingToken];\r\n        _getReward(channelInfo, msg.sender);\r\n    }\r\n\r\n    function _getReward(Channel storage channelInfo, address to) private {\r\n        (uint32 lastUpdateBlock, uint256 rewardPerTokenStored, uint256 userReward) = _calcReward(channelInfo, to);\r\n\r\n        channelInfo.rewardPerTokenStored = rewardPerTokenStored;\r\n        channelInfo.lastUpdateBlock = lastUpdateBlock;\r\n\r\n        if (to != address(0)) {\r\n            if (userReward > 0) {\r\n                // transfer ASET\r\n                _safeAsetTransfer(to, userReward);\r\n            }\r\n            channelInfo.accounts[to].userRewardPerTokenPaid = rewardPerTokenStored;\r\n        }\r\n    }\r\n\r\n    function _safeAsetTransfer(address to, uint256 amount) private returns (uint256) {\r\n        uint256 asetBal = IERC20(_rewardsToken).balanceOf(address(this));\r\n        if (amount > asetBal) {\r\n            amount = asetBal;\r\n        }\r\n        // allow zero amount\r\n        TransferHelper.safeTransfer(_rewardsToken, to, amount);\r\n        return amount;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"_governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"rewardRate\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRewardPerTokenPaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"getBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"}],\"name\":\"getChannelInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenStored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"}],\"name\":\"getDecimalConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"lastUpdateBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"rewardRate\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"}],\"name\":\"setChannelInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"setRewardsToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LPStakingMiningPool","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"6666","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bade940803878c68d906cda38b0a22581c5cdc3285a548414822333797130a04"}]}